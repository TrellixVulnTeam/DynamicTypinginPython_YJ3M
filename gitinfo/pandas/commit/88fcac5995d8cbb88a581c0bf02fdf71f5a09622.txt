commit 88fcac5995d8cbb88a581c0bf02fdf71f5a09622
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jan 27 12:48:50 2012 -0500

    ENH: close #694, #693, #692

diff --git a/RELEASE.rst b/RELEASE.rst
index 98a742203..0182c7899 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -111,6 +111,8 @@ pandas 0.7.0
     ``col_space``
   - Rename ``precision`` to ``accuracy`` in engineering float formatter (GH
     #395)
+  - The default delimiter for ``read_csv`` is comma rather than letting
+    ``csv.Sniffer`` infer it
 
 **Improvements to existing features**
 
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index fccfacd79..b9e3c9714 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -8,6 +8,7 @@ import numpy as np
 
 from pandas.core.index import Index, MultiIndex
 from pandas.core.frame import DataFrame
+import pandas.core.common as com
 import pandas._tseries as lib
 
 from pandas.util.decorators import Appender
@@ -21,8 +22,8 @@ filepath_or_buffer : string or file handle / StringIO
 %s
 header : int, default 0
     Row to use for the column labels of the parsed DataFrame
-skiprows : list-like
-    Row numbers to skip (0-indexed)
+skiprows : list-like or integer
+    Row numbers to skip (0-indexed) or number of rows to skip (int)
 index_col : int or sequence, default None
     Column to use as the row labels of the DataFrame. If a sequence is
     given, a MultiIndex is used.
@@ -48,14 +49,16 @@ converters : dict. optional
     be integers or column labels
 verbose : boolean, default False
     Indicate number of NA values placed in non-numeric columns
+delimiter : string, default None
+    Alternative argument name for sep
 
 Returns
 -------
 result : DataFrame or TextParser
 """
 
-_csv_sep = """sep : string, default None
-    Delimiter to use. By default will try to automatically determine
+_csv_sep = """sep : string, default ','
+    Delimiter to use. If sep is None, will try to automatically determine
     this"""
 
 _table_sep = """sep : string, default \\t (tab-stop)
@@ -65,37 +68,25 @@ _read_csv_doc = """
 Read CSV (comma-separated) file into DataFrame
 
 %s
-
-Returns
--------
-parsed : DataFrame
 """ % (_parser_params % _csv_sep)
 
 _read_csv_doc = """
 Read CSV (comma-separated) file into DataFrame
 
 %s
-
-Returns
--------
-parsed : DataFrame
 """ % (_parser_params % _csv_sep)
 
 _read_table_doc = """
-Read delimited file into DataFrame
+Read general delimited file into DataFrame
 
 %s
-
-Returns
--------
-parsed : DataFrame
 """ % (_parser_params % _table_sep)
 
 @Appender(_read_csv_doc)
-def read_csv(filepath_or_buffer, sep=None, header=0, index_col=None, names=None,
+def read_csv(filepath_or_buffer, sep=',', header=0, index_col=None, names=None,
              skiprows=None, na_values=None, parse_dates=False,
              date_parser=None, nrows=None, iterator=False, chunksize=None,
-             skip_footer=0, converters=None, verbose=False):
+             skip_footer=0, converters=None, verbose=False, delimiter=None):
     if hasattr(filepath_or_buffer, 'read'):
         f = filepath_or_buffer
     else:
@@ -105,6 +96,9 @@ def read_csv(filepath_or_buffer, sep=None, header=0, index_col=None, names=None,
         except Exception: # pragma: no cover
             f = open(filepath_or_buffer, 'r')
 
+    if delimiter is not None:
+        sep = delimiter
+
     if date_parser is not None:
         parse_dates = True
 
@@ -130,14 +124,14 @@ def read_csv(filepath_or_buffer, sep=None, header=0, index_col=None, names=None,
 def read_table(filepath_or_buffer, sep='\t', header=0, index_col=None,
                names=None, skiprows=None, na_values=None, parse_dates=False,
                date_parser=None, nrows=None, iterator=False, chunksize=None,
-               skip_footer=0, converters=None, verbose=False):
+               skip_footer=0, converters=None, verbose=False, delimiter=None):
     return read_csv(filepath_or_buffer, sep=sep, header=header,
                     skiprows=skiprows, index_col=index_col,
                     na_values=na_values, date_parser=date_parser,
                     names=names, parse_dates=parse_dates,
                     nrows=nrows, iterator=iterator, chunksize=chunksize,
                     skip_footer=skip_footer, converters=converters,
-                    verbose=verbose)
+                    verbose=verbose, delimiter=delimiter)
 
 def read_clipboard(**kwargs):  # pragma: no cover
     """
@@ -216,6 +210,9 @@ class TextParser(object):
         self.date_parser = date_parser
         self.chunksize = chunksize
         self.passed_names = names is not None
+
+        if com.is_integer(skiprows):
+            skiprows = range(skiprows)
         self.skiprows = set() if skiprows is None else set(skiprows)
         self.skip_footer = skip_footer
         self.delimiter = delimiter
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 7698bcf39..b22716c5f 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -69,11 +69,15 @@ ignore,this,row
         data = read_csv(StringIO(text), skiprows=range(6), header=None,
                         index_col=0, parse_dates=True)
 
+        data2 = read_csv(StringIO(text), skiprows=6, header=None,
+                         index_col=0, parse_dates=True)
+
         expected = DataFrame(np.arange(1., 10.).reshape((3,3)),
                              columns=['X.2', 'X.3', 'X.4'],
                              index=[datetime(2000, 1, 1), datetime(2000, 1, 2),
                                     datetime(2000, 1, 3)])
         assert_frame_equal(data, expected)
+        assert_frame_equal(data, data2)
 
 
     def test_detect_string_na(self):
@@ -272,14 +276,17 @@ baz,7,8,9
         self.assert_(data.index.equals(Index(['foo', 'bar', 'baz'])))
 
     def test_sniff_delimiter(self):
-        data = """index|A|B|C
+        text = """index|A|B|C
 foo|1|2|3
 bar|4|5|6
 baz|7|8|9
 """
-        data = read_csv(StringIO(data), index_col=0)
+        data = read_csv(StringIO(text), index_col=0, sep=None)
         self.assert_(data.index.equals(Index(['foo', 'bar', 'baz'])))
 
+        data2 = read_csv(StringIO(text), index_col=0, delimiter='|')
+        assert_frame_equal(data, data2)
+
     def test_read_nrows(self):
         df = read_csv(StringIO(self.data1), nrows=3)
         expected = read_csv(StringIO(self.data1))[:3]
@@ -566,6 +573,17 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         df = read_table(StringIO(text), sep='\s+')
         self.assertEquals(df.index.names, ['one', 'two', 'three', 'four'])
 
+    def test_read_csv_parse_simple_list(self):
+        text = """foo
+bar baz
+qux foo
+foo
+bar"""
+        df = read_csv(StringIO(text), header=None)
+        expected = DataFrame({'X.1' : ['foo', 'bar baz', 'qux foo',
+                                       'foo', 'bar']})
+        assert_frame_equal(df, expected)
+
 class TestParseSQL(unittest.TestCase):
 
     def test_convert_sql_column_floats(self):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 152e90e4e..553305b4d 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1962,8 +1962,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         df_s = df.to_string()
 
-        # Python 2.5 just wants me to be sad
-        if sys.version_info[0] == 2 and sys.version_info[1] < 6:
+        # Python 2.5 just wants me to be sad. And debian 32-bit
+        #sys.version_info[0] == 2 and sys.version_info[1] < 6:
+        if '%.4g' % 1.7e8 == '1.7e+008':
             expected = ('   x        \n0  0.0000000\n1  0.2500000\n'
                         '2  3456.0000\n3  1.20e+046\n4  1.64e+006\n'
                         '5  1.70e+008\n6  1.2534560\n7  3.1415927\n'
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index c19d37cb5..14b35facc 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -85,6 +85,10 @@ class TestDataFramePlots(unittest.TestCase):
                        columns=range(15))
         _check_plot_works(df.plot, kind='bar')
 
+        df = DataFrame({'a': [0, 1], 'b': [1, 0]})
+        foo
+        _check_plot_works(df.plot, kind='bar')
+
     @slow
     def test_boxplot(self):
         df = DataFrame(np.random.randn(6, 4),

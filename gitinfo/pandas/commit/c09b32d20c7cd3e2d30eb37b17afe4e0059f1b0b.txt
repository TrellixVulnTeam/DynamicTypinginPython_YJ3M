commit c09b32d20c7cd3e2d30eb37b17afe4e0059f1b0b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Apr 16 23:34:07 2011 -0400

    work on arith operators. need to test

diff --git a/pandas/lib/Makefile b/pandas/lib/Makefile
new file mode 100644
index 000000000..ecfea00ff
--- /dev/null
+++ b/pandas/lib/Makefile
@@ -0,0 +1,6 @@
+
+sparse: src/sparse.pyx
+	-python build.py build_ext --inplace
+
+test: sparse
+	-python test_sparse.py
\ No newline at end of file
diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index da8c5e5d7..89cbb1668 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -43,29 +43,35 @@ cdef class SparseIndex:
 cdef class DenseIndex(SparseIndex):
 
     cdef readonly:
-        pyst length
+        pyst length, npoints
         ndarray indices
 
     cdef:
-        int32_t* indbuf
+        int32_t* indp
 
     def __init__(self, pyst length, indices):
         self.length = length
         self.indices = np.ascontiguousarray(indices, dtype=np.int32)
 
-        self.indbuf = <int32_t*> self.indices.data
+        self.indp = <int32_t*> self.indices.data
 
     def __repr__(self):
         output = 'sparse.DenseIndex\n'
         output += 'Indices: %s\n' % repr(self.indices)
         return output
 
+    def to_dense(self):
+        return self
+
     def to_block(self):
         pass
 
     cpdef intersect(self, SparseIndex):
         pass
 
+#-------------------------------------------------------------------------------
+# BlockIndex
+
 cdef class BlockIndex(SparseIndex):
     '''
 
@@ -136,6 +142,9 @@ cdef class BlockIndex(SparseIndex):
             if self.blengths[i] == 0:
                 raise ValueError('Zero-length block %d' % i)
 
+    def to_block(self):
+        return self
+
     def to_dense(self):
         cdef:
             pyst i = 0, j, b
@@ -154,86 +163,103 @@ cdef class BlockIndex(SparseIndex):
         return DenseIndex(self.length, indices)
 
     cpdef BlockIndex intersect(self, BlockIndex other):
-        cdef:
-            pyst out_length
-            ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
-
-            list out_blocs = []
-            list out_blengths = []
-
-        # unwise? should enforce same length?
-        out_length = int_max(self.length, other.length)
-
-        xloc = self.blocs
-        xlen = self.blengths
-        yloc = other.blocs
-        ylen = other.blengths
-
-        cdef pyst xi = 0, yi = 0
-        cdef int32_t cur_loc, cur_length, xend, yend, diff
-        while True:
-            # we are done (or possibly never began)
-            if xi >= self.nblocks or yi >= other.nblocks:
-                break
-
-            # completely symmetric...would like to avoid code dup but oh well
-            if xloc[xi] >= yloc[yi]:
-                cur_loc = xloc[xi]
-                diff = xloc[xi] - yloc[yi]
-
-                if ylen[yi] - diff <= 0:
-                    # have to skip this block
-                    yi += 1
-                    continue
-
-                if ylen[yi] - diff < xlen[xi]:
-                    # take end of y block, move onward
-                    cur_length = ylen[yi] - diff
-                    yi += 1
-                else:
-                    # take end of x block
-                    cur_length = xlen[xi]
-                    xi += 1
-
-            else: # xloc[xi] < yloc[yi]
-                cur_loc = yloc[yi]
-                diff = yloc[yi] - xloc[xi]
-
-                if xlen[xi] - diff <= 0:
-                    # have to skip this block
-                    xi += 1
-                    continue
-
-                if xlen[xi] - diff < ylen[yi]:
-                    # take end of x block, move onward
-                    cur_length = xlen[xi] - diff
-                    xi += 1
-                else:
-                    # take end of y block
-                    cur_length = ylen[yi]
-                    yi += 1
-
-            out_blocs.append(cur_loc)
-            out_blengths.append(cur_length)
-
-        return BlockIndex(self.length, out_blocs, out_blengths)
+        return block_intersect(self, other)
+
+cdef BlockIndex block_intersect(BlockIndex x, BlockIndex y):
+    cdef:
+        pyst out_length
+        ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
+
+        list out_blocs = []
+        list out_blengths = []
+
+        pyst xi = 0, yi = 0
+        int32_t cur_loc, cur_length, xend, yend, diff
+
+    # unwise? should enforce same length?
+    out_length = int_max(x.length, y.length)
+
+    xloc = x.blocs
+    xlen = x.blengths
+    yloc = y.blocs
+    ylen = y.blengths
+
+    while True:
+        # we are done (or possibly never began)
+        if xi >= x.nblocks or yi >= y.nblocks:
+            break
+
+        # completely symmetric...would like to avoid code dup but oh well
+        if xloc[xi] >= yloc[yi]:
+            cur_loc = xloc[xi]
+            diff = xloc[xi] - yloc[yi]
+
+            if ylen[yi] - diff <= 0:
+                # have to skip this block
+                yi += 1
+                continue
+
+            if ylen[yi] - diff < xlen[xi]:
+                # take end of y block, move onward
+                cur_length = ylen[yi] - diff
+                yi += 1
+            else:
+                # take end of x block
+                cur_length = xlen[xi]
+                xi += 1
+
+        else: # xloc[xi] < yloc[yi]
+            cur_loc = yloc[yi]
+            diff = yloc[yi] - xloc[xi]
+
+            if xlen[xi] - diff <= 0:
+                # have to skip this block
+                xi += 1
+                continue
+
+            if xlen[xi] - diff < ylen[yi]:
+                # take end of x block, move onward
+                cur_length = xlen[xi] - diff
+                xi += 1
+            else:
+                # take end of y block
+                cur_length = ylen[yi]
+                yi += 1
+
+        out_blocs.append(cur_loc)
+        out_blengths.append(cur_length)
+
+    return BlockIndex(x.length, out_blocs, out_blengths)
+
+#-------------------------------------------------------------------------------
+# SparseVector
 
 cdef class SparseVector:
     '''
     Data structure for storing sparse representation of floating point data
+
+    Parameters
+    ----------
     '''
 
-    cdef public:
+    cdef readonly:
+        pyst length
         ndarray values
+
+    cdef public:
         SparseIndex index
+        object fill_value
 
     cdef:
         float64_t* vbuf
 
-    def __init__(self, ndarray values, SparseIndex index):
+    def __init__(self, ndarray values, SparseIndex index, fill_value=None):
         self.values = np.ascontiguousarray(values, dtype=np.float64)
         self.vbuf = <float64_t*> self.values.data
 
+        self.length = len(values)
+        self.fill_value = fill_value
+
     def __repr__(self):
         # just for devel...
         output = 'sparse.SparseVector\n'
@@ -244,31 +270,131 @@ cdef class SparseVector:
     cpdef reindex(self):
         pass
 
-    cpdef add(self, SparseVector other):
-        return self._combine(other, __add)
+    def __add__(self, other):
+        return self.add(other)
+    def __sub__(self, other):
+        return self.sub(other)
+    def __mul__(self, other):
+        return self.mul(other)
+    def __div__(self, other):
+        return self.div(other)
 
-    cpdef sub(self, SparseVector other):
-        return self._combine(other, __sub)
+    cpdef add(self, other):
+        return self._combine_vector(other, __add)
 
-    cpdef mul(self, SparseVector other):
-        return self._combine(other, __mul)
+    cpdef sub(self, other):
+        return self._combine_vector(other, __sub)
 
-    cpdef div(self, SparseVector other):
-        return self._combine(other, __div)
+    cpdef mul(self, other):
+        return self._combine_vector(other, __mul)
 
-    cdef ndarray _combine(self, SparseVector other, double_func op):
-        cdef SparseIndex out_index = self.index.intersect(other.index)
-        cdef ndarray out = np.empty(out_index.npoints, dtype=np.float64)
+    cpdef div(self, other):
+        return self._combine_vector(other, __div)
 
-        if isinstance(out_index, BlockIndex):
-            block_op(self.vbuf, other.vbuf, <float64_t*> out.data,
-                     op, self.index, other.index)
-        elif isinstance(out_index, DenseIndex):
-            pass
+    cdef SparseVector _combine_scalar(self, float64_t other, object op):
+        new_values = op(self.values, other)
+        return SparseVector(new_values, self.index)
 
-        return SparseVector(out, out_index)
+    cdef SparseVector _combine_vector(self, SparseVector other, double_func op):
+        if isinstance(self.index, BlockIndex):
+            return block_op(self, other, op)
+        elif isinstance(self.index, DenseIndex):
+            return dense_op(self, other, op)
 
-cdef block_op(float64_t* xbuf, float64_t* ybuf, float64_t* out,
-              double_func op,
-              BlockIndex xindex, BlockIndex yindex) except -1:
-    pass
+# faster to convert everything to dense?
+
+cdef SparseVector block_op(SparseVector x, SparseVector y, double_func op):
+    cdef:
+        BlockIndex xindex, yindex, out_index
+        int xi = 0, yi = 0, out_i = 0 # fp buf indices
+        int xbp, ybp, obp # block positions
+        pyst xblock = 0, yblock = 0, outblock = 0 # block numbers
+
+        SparseVector out
+
+    xindex = x.index.to_block()
+    yindex = y.index.to_block()
+
+    # need to do this first to know size of result array
+    out_index = x.index.intersect(y.index).to_block()
+
+    outarr = np.empty(out_index.npoints, dtype=np.float64)
+    out = SparseVector(outarr, out_index)
+
+    # walk the two SparseVectors, adding matched locations...
+    for out_i from 0 <= out_i < out.length:
+
+        # I have a feeling this is inefficient
+
+        # walk x
+        while xindex.locp[xblock] + xbp < out_index.locp[outblock] + obp:
+            xbp += 1
+            xi += 1
+            if xbp == xindex.lenp[xblock]:
+                xblock += 1
+                xbp = 0
+
+        # walk y
+        while yindex.locp[yblock] + ybp < out_index.locp[outblock] + obp:
+            ybp += 1
+            yi += 1
+            if ybp == yindex.lenp[yblock]:
+                yblock += 1
+                ybp = 0
+
+        out.vbuf[out_i] = op(x.vbuf[xi], y.vbuf[yi])
+
+        # advance. strikes me as too complicated
+        xi += 1
+        yi += 1
+
+        xbp += 1
+        if xbp == xindex.lenp[xblock]:
+            xblock += 1
+            xbp = 0
+
+        ybp += 1
+        if ybp == yindex.lenp[yblock]:
+            yblock += 1
+            ybp = 0
+
+        obp += 1
+        if obp == out_index.lenp[oblock]:
+            oblock += 1
+            obp = 0
+
+    return out
+
+cdef SparseVector dense_op(SparseVector x, SparseVector y, double_func op):
+    cdef:
+        DenseIndex xindex, yindex, out_index
+        int xi = 0, yi = 0, out_i = 0 # fp buf indices
+
+        SparseVector out
+
+    xindex = x.index.to_dense()
+    yindex = y.index.to_dense()
+
+    # need to do this first to know size of result array
+    out_index = x.index.intersect(y.index).to_dense()
+    outarr = np.empty(out_index.npoints, dtype=np.float64)
+    out = SparseVector(outarr, out_index)
+
+    # walk the two SparseVectors, adding matched locations...
+    for out_i from 0 <= out_i < out.length:
+
+        # walk x
+        while xindex.indp[xi] < out_index.indp[out_i]:
+            xi += 1
+
+        # walk y
+        while yindex.indp[yi] < out_index.indp[out_i]:
+            yi += 1
+
+        out.vbuf[out_i] = op(x.vbuf[xi], y.vbuf[yi])
+
+        # advance
+        xi += 1
+        yi += 1
+
+    return out
diff --git a/pandas/lib/test_sparse.py b/pandas/lib/test_sparse.py
index 6ce037037..e789691c2 100644
--- a/pandas/lib/test_sparse.py
+++ b/pandas/lib/test_sparse.py
@@ -2,6 +2,7 @@ from unittest import TestCase
 
 import nose
 import numpy as np
+import operator
 from numpy.testing import assert_almost_equal, assert_equal
 
 from sparse import DenseIndex, BlockIndex, SparseVector
@@ -15,6 +16,42 @@ class TestDenseIndex(TestCase):
     def test_intersect(self):
         pass
 
+
+
+TEST_LENGTH = 20
+
+plain_case = dict(xloc = [0, 7, 15],
+                  xlen = [3, 5, 5],
+                  yloc = [2, 9, 14],
+                  ylen = [2, 3, 5],
+                  eloc = [2, 9, 15],
+                  elen = [1, 3, 4])
+delete_blocks = dict(xloc = [0, 5],
+                     xlen = [4, 4],
+                     yloc = [1],
+                     ylen = [4],
+                     eloc = [1],
+                     elen = [3])
+split_blocks = dict(xloc = [0],
+                    xlen = [10],
+                    yloc = [0, 5],
+                    ylen = [3, 7],
+                    eloc = [0, 5],
+                    elen = [3, 5])
+skip_block = dict(xloc = [10],
+                  xlen = [5],
+                  yloc = [0, 12],
+                  ylen = [5, 3],
+                  eloc = [12],
+                  elen = [3])
+
+no_intersect = dict(xloc = [0, 10],
+                    xlen = [4, 6],
+                    yloc = [5, 17],
+                    ylen = [4, 2],
+                    eloc = [],
+                    elen = [])
+
 class TestBlockIndex(TestCase):
 
     def setUp(self):
@@ -38,11 +75,13 @@ class TestBlockIndex(TestCase):
 
     def test_intersect(self):
 
-        length = 20
+        def _check_case_dict(case):
+            _check_case(case['xloc'], case['xlen'], case['yloc'], case['ylen'],
+                        case['eloc'], case['elen'])
 
         def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
-            xindex = BlockIndex(length, xloc, xlen)
-            yindex = BlockIndex(length, yloc, ylen)
+            xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
+            yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
             result = xindex.intersect(yindex)
 
             self.assert_(isinstance(result, BlockIndex))
@@ -50,58 +89,11 @@ class TestBlockIndex(TestCase):
             assert_equal(result.blocs, eloc)
             assert_equal(result.blengths, elen)
 
-        # plain old test case
-
-        xlocs = [0, 7, 15]
-        xlengths = [3, 5, 5]
-        ylocs = [2, 9, 14]
-        ylengths = [2, 3, 5]
-        exp_locs = [2, 9, 15]
-        exp_lengths = [1, 3, 4]
-
-        _check_case(xlocs, xlengths, ylocs, ylengths,
-                    exp_locs, exp_lengths)
-
-        # delete blocks
-        xlocs = [0, 5]; xlengths = [4, 4]
-        ylocs = [1]; ylengths = [4]
-        exp_locs = [1]
-        exp_lengths = [3]
-
-        _check_case(xlocs, xlengths, ylocs, ylengths,
-                    exp_locs, exp_lengths)
-
-        # split blocks
-        xlocs = [0]
-        xlengths = [10]
-        ylocs = [0, 5]
-        ylengths = [3, 7]
-        exp_locs = [0, 5]
-        exp_lengths = [3, 5]
-
-        _check_case(xlocs, xlengths, ylocs, ylengths,
-                    exp_locs, exp_lengths)
-
-        # skip block
-        xlocs = [10]
-        xlengths = [5]
-        ylocs = [0, 12]
-        ylengths = [5, 3]
-        exp_locs = [12]
-        exp_lengths = [3]
-        _check_case(xlocs, xlengths, ylocs, ylengths,
-                    exp_locs, exp_lengths)
-
-        # no intersection
-        xlocs = [0, 10]
-        xlengths = [4, 6]
-        ylocs = [5, 17]
-        ylengths = [4, 2]
-        exp_locs = []
-        exp_lengths = []
-
-        _check_case(xlocs, xlengths, ylocs, ylengths,
-                    exp_locs, exp_lengths)
+        _check_case_dict(plain_case)
+        _check_case_dict(delete_blocks)
+        _check_case_dict(split_blocks)
+        _check_case_dict(skip_block)
+        _check_case_dict(no_intersect)
 
         # one or both is empty
         _check_case([0], [5], [], [], [], [])
@@ -118,8 +110,23 @@ class TestBlockIndex(TestCase):
         assert_equal(dense.indices, exp_inds)
 
 class TestSparseVector(TestCase):
-    pass
 
+    def _arith_op_tests(self, op):
+        pass
+
+# too cute? oh but how I abhor code duplication
+
+check_ops = ['add', 'sub', 'mul', 'div']
+def make_optestf(op):
+    def f(self):
+        self._arith_op_tests(getattr(operator, op))
+    f.__name__ = 'test_%s' % op
+    return f
+
+for op in check_ops:
+    f = make_optestf(op)
+    setattr(TestSparseVector, f.__name__, f)
+    del f
 
 if __name__ == '__main__':
     import nose

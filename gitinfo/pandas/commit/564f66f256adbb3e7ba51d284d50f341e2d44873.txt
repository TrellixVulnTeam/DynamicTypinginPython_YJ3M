commit 564f66f256adbb3e7ba51d284d50f341e2d44873
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jul 20 16:39:19 2012 -0400

    ENH/BUG: handle tz-aware datetime.datetime in to_datetime, add utc=True option to allow conversion to utc, close #1581

diff --git a/RELEASE.rst b/RELEASE.rst
index b48efed87..bfed9d91f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -58,6 +58,8 @@ pandas 0.8.1
   - Accelerate 3-axis multi data selection from homogeneous Panel (#979)
   - Add ``adjust`` option to ewma to disable adjustment factor (#1584)
   - Add new matplotlib converters for high frequency time series plotting (#1599)
+  - Handling of tz-aware datetime.datetime objects in to_datetime; raise
+    Exception unless utc=True given (#1581)
 
 **Bug fixes**
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 6685fd3ad..ec6ceab3d 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -640,13 +640,15 @@ cdef inline _string_to_dts(object val, pandas_datetimestruct* dts):
         raise ValueError('Unable to parse %s' % str(val))
 
 def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False,
-                      format=None):
+                      format=None, utc=None):
     cdef:
         Py_ssize_t i, n = len(values)
         object val
         ndarray[int64_t] iresult
         ndarray[object] oresult
         pandas_datetimestruct dts
+        bint utc_convert = bool(utc)
+        _TSObject _ts
 
     from dateutil.parser import parse
 
@@ -658,8 +660,18 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False,
             if util._checknull(val):
                 iresult[i] = iNaT
             elif PyDateTime_Check(val):
-                iresult[i] = _pydatetime_to_dts(val, &dts)
-                _check_dts_bounds(iresult[i], &dts)
+                if val.tzinfo is not None:
+                    if utc_convert:
+                        _ts = convert_to_tsobject(val)
+                        iresult[i] = _ts.value
+                        _check_dts_bounds(iresult[i], &_ts.dts)
+                    else:
+                        raise ValueError('Tz-aware datetime.datetime cannot '
+                                         'be converted to datetime64 unless '
+                                         'utc=True')
+                else:
+                    iresult[i] = _pydatetime_to_dts(val, &dts)
+                    _check_dts_bounds(iresult[i], &dts)
             elif PyDate_Check(val):
                 iresult[i] = _date_to_datetime64(val, &dts)
                 _check_dts_bounds(iresult[i], &dts)
@@ -777,6 +789,7 @@ def i8_to_pydt(int64_t i8, object tzinfo = None):
 
 try:
     import pytz
+    UTC = pytz.utc
     have_pytz = True
 except:
     have_pytz = False
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 805c3c686..335eebe6c 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -352,6 +352,23 @@ class TestTimeZoneSupport(unittest.TestCase):
         result = ts['1/3/2000']
         self.assertAlmostEqual(result, ts[2])
 
+    def test_convert_tz_aware_datetime_datetime(self):
+        # #1581
+
+        tz = pytz.timezone('US/Eastern')
+
+        dates = [datetime(2000, 1, 1), datetime(2000, 1, 2),
+                 datetime(2000, 1, 3)]
+
+        dates_aware = [tz.localize(x) for x in dates]
+
+        self.assertRaises(Exception, to_datetime, dates_aware)
+
+        converted = to_datetime(dates_aware, utc=True)
+        ex_vals = [Timestamp(x).value for x in dates_aware]
+        self.assert_(np.array_equal(converted.asi8, ex_vals))
+        self.assert_(converted.tz is pytz.utc)
+
 class TestTimeZones(unittest.TestCase):
 
     def setUp(self):
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 4f461ac1b..506466d64 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -61,7 +61,7 @@ def _figure_out_timezone(start, end, tzinfo):
     return start, end, tz
 
 
-def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
+def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True):
     """
     Convert argument to datetime
 
@@ -70,6 +70,9 @@ def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
     arg : string, datetime, array of strings (with possible NAs)
     errors : {'ignore', 'raise'}, default 'ignore'
         Errors are ignored by default (values left untouched)
+    utc : boolean, default None
+        Return UTC DatetimeIndex if True (converting any tz-aware
+        datetime.datetime objects as well)
 
     Returns
     -------
@@ -84,6 +87,7 @@ def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
     elif isinstance(arg, Series):
         values = lib.array_to_datetime(com._ensure_object(arg.values),
                                        raise_=errors == 'raise',
+                                       utc=utc,
                                        dayfirst=dayfirst)
         return Series(values, index=arg.index, name=arg.name)
     elif isinstance(arg, (np.ndarray, list)):
@@ -91,9 +95,10 @@ def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
             arg = np.array(arg, dtype='O')
         result = lib.array_to_datetime(com._ensure_object(arg),
                                        raise_=errors == 'raise',
+                                       utc=utc,
                                        dayfirst=dayfirst)
         if com.is_datetime64_dtype(result) and box:
-            result = DatetimeIndex(result)
+            result = DatetimeIndex(result, tz='utc' if utc else None)
         return result
     try:
         if not arg:

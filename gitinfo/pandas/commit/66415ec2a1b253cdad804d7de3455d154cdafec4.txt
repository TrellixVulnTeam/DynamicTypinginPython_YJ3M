commit 66415ec2a1b253cdad804d7de3455d154cdafec4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Nov 18 13:53:30 2012 -0500

    BUG: fix conflict between passed names, usecols, header options. note API breakage from <= 0.9.1. close #2270

diff --git a/RELEASE.rst b/RELEASE.rst
index 3e370f039..bc4bcee22 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -22,8 +22,8 @@ Where to get it
 * Binary installers on PyPI: http://pypi.python.org/pypi/pandas
 * Documentation: http://pandas.pydata.org
 
-pandas 0.9.2
-============
+pandas 0.10.0
+=============
 
 **Release date:** Not yet released
 
@@ -33,6 +33,11 @@ pandas 0.9.2
 
 **API Changes**
 
+  - ``names`` handling in file parsing: if explicit column `names` passed,
+    `header` argument will be respected. If there is an existing header column,
+    this can rename the columns. To fix legacy code, put ``header=None`` when
+    passing ``names``
+
 **Improvements to existing features**
 
   - Grouped histogram via `by` keyword in Series/DataFrame.hist (#2186)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 40418ad3d..52c8c4aa6 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -56,8 +56,8 @@ index_col : int or sequence, default None
     Column to use as the row labels of the DataFrame. If a sequence is
     given, a MultiIndex is used.
 names : array-like
-    List of column names to use. If passed, header will be implicitly set to
-    None.
+    List of column names to use. If header=True, replace existing header,
+    otherwise this ignores the header=0 default
 na_values : list-like or dict, default None
     Additional strings to recognize as NA/NaN. If dict passed, specific
     per-column NA values
@@ -872,7 +872,8 @@ class CParserWrapper(ParserBase):
             data = sorted(data.items())
             data = dict((k, v) for k, (i, v) in zip(names, data))
 
-            names = self._filter_usecols(names)
+            if self._reader.names is None:
+                names = self._filter_usecols(names)
 
             names, data = self._do_date_conversions(names, data)
 
@@ -882,7 +883,9 @@ class CParserWrapper(ParserBase):
 
             # ugh, mutation
             names = list(self.orig_names)
-            names = self._filter_usecols(names)
+
+            if self._reader.names is None:
+                names = self._filter_usecols(names)
 
             # columns as list
             alldata = [x[1] for x in data]
@@ -1130,8 +1133,6 @@ class PythonParser(ParserBase):
 
     def _infer_columns(self):
         names = self.names
-        if names is not None:
-            self.header = None
 
         if self.header is not None:
             if len(self.buf) > 0:
@@ -1155,7 +1156,14 @@ class PythonParser(ParserBase):
                 if cur_count > 0:
                     columns[i] = '%s.%d' % (col, cur_count)
                 counts[col] = cur_count + 1
+
             self._clear_buffer()
+
+            if names is not None:
+                if len(names) != len(columns):
+                    raise Exception('Number of passed names did not match '
+                                    'number of header fields in the file')
+                columns = names
         else:
             if len(self.buf) > 0:
                 line = self.buf[0]
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 8b1414e00..06ea4bcb0 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -279,7 +279,8 @@ KORD,19990127 22:00:00, 21:56:00, -0.5900, 1.7100, 5.1000, 0.0000, 290.0000
 
         try:
             # it works!
-            df = self.read_csv(StringIO('1,2'), names=['a', 'b'], sep=None)
+            df = self.read_csv(StringIO('1,2'), names=['a', 'b'],
+                               header=None, sep=None)
             tm.assert_frame_equal(DataFrame({'a': [1], 'b': [2]}), df)
         finally:
             sys.stdout = sys.__stdout__
@@ -351,11 +352,13 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000"""
         xp = DataFrame({'a' : [1, 5, 9], 'b' : [2, 6, 10], 'c' : [3, 7, 11],
                         'd' : [4, 8, 12]},
                        index=Index(['hello', 'world', 'foo'], name='message'))
-        rs = self.read_csv(StringIO(data), names=names, index_col=['message'])
+        rs = self.read_csv(StringIO(data), names=names,
+                           header=None, index_col=['message'])
         tm.assert_frame_equal(xp, rs)
         self.assert_(xp.index.name == rs.index.name)
 
-        rs = self.read_csv(StringIO(data), names=names, index_col='message')
+        rs = self.read_csv(StringIO(data), names=names,
+                           header=None, index_col='message')
         tm.assert_frame_equal(xp, rs)
         self.assert_(xp.index.name == rs.index.name)
 
@@ -677,7 +680,8 @@ c,4,5
 """
         df = self.read_table(StringIO(data), sep=',', header=None)
         names = ['foo', 'bar', 'baz', 'quux', 'panda']
-        df2 = self.read_table(StringIO(data), sep=',', header=None, names=names)
+        df2 = self.read_table(StringIO(data), sep=',', header=None,
+                              names=names)
         expected = [[1,2,3,4,5.],
                     [6,7,8,9,10],
                     [11,12,13,14,15]]
@@ -693,7 +697,7 @@ bar,4,5,6
 baz,7,8,9
 """
         names = ['A', 'B', 'C']
-        df = self.read_csv(StringIO(data), names=names)
+        df = self.read_csv(StringIO(data), names=names, header=None)
 
         self.assertEqual(names, ['A', 'B', 'C'])
 
@@ -704,18 +708,22 @@ baz,7,8,9
 
     def test_read_csv_dataframe(self):
         df = self.read_csv(self.csv1, index_col=0, parse_dates=True)
-        df2 = self.read_table(self.csv1, sep=',', index_col=0, parse_dates=True)
+        df2 = self.read_table(self.csv1, sep=',', index_col=0,
+                              parse_dates=True)
         self.assert_(np.array_equal(df.columns, ['A', 'B', 'C', 'D']))
         self.assert_(df.index.name == 'index')
-        self.assert_(isinstance(df.index[0], (datetime, np.datetime64, Timestamp)))
+        self.assert_(isinstance(df.index[0], (datetime, np.datetime64,
+                                              Timestamp)))
         self.assert_(df.values.dtype == np.float64)
         tm.assert_frame_equal(df, df2)
 
     def test_read_csv_no_index_name(self):
         df = self.read_csv(self.csv2, index_col=0, parse_dates=True)
-        df2 = self.read_table(self.csv2, sep=',', index_col=0, parse_dates=True)
+        df2 = self.read_table(self.csv2, sep=',', index_col=0,
+                              parse_dates=True)
         self.assert_(np.array_equal(df.columns, ['A', 'B', 'C', 'D', 'E']))
-        self.assert_(isinstance(df.index[0], (datetime, np.datetime64, Timestamp)))
+        self.assert_(isinstance(df.index[0], (datetime, np.datetime64,
+                                              Timestamp)))
         self.assert_(df.ix[:, ['A', 'B', 'C', 'D']].values.dtype == np.float64)
         tm.assert_frame_equal(df, df2)
 
@@ -980,7 +988,8 @@ baz,12,13,14,15
 
         # regular index
         names = ['index', 'A', 'B', 'C', 'D']
-        df = self.read_csv(StringIO(no_header), index_col=0, names=names)
+        df = self.read_csv(StringIO(no_header), index_col=0,
+                           header=None, names=names)
         expected = self.read_csv(StringIO(self.data1), index_col=0)
         tm.assert_frame_equal(df, expected)
 
@@ -995,7 +1004,8 @@ bar,two,12,13,14,15
         lines = data.split('\n')
         no_header = '\n'.join(lines[1:])
         names = ['index1', 'index2', 'A', 'B', 'C', 'D']
-        df = self.read_csv(StringIO(no_header), index_col=[0, 1], names=names)
+        df = self.read_csv(StringIO(no_header), index_col=[0, 1],
+                           header=None, names=names)
         expected = self.read_csv(StringIO(data), index_col=[0, 1])
         tm.assert_frame_equal(df, expected)
 
@@ -1023,7 +1033,8 @@ bar,two,12,13,14,15
         no_header = '\n'.join(lines[1:])
         names = ['A', 'B', 'C', 'D']
 
-        df = self.read_csv(StringIO(no_header), index_col=[0, 1], names=names)
+        df = self.read_csv(StringIO(no_header), index_col=[0, 1],
+                           header=None, names=names)
         expected = self.read_csv(StringIO(data), index_col=[0, 1])
         tm.assert_frame_equal(df, expected)
 
@@ -1032,7 +1043,8 @@ bar,two,12,13,14,15
         tm.assert_frame_equal(df2, df)
 
         # reverse order of index
-        df = self.read_csv(StringIO(no_header), index_col=[1, 0], names=names)
+        df = self.read_csv(StringIO(no_header), index_col=[1, 0], names=names,
+                           header=None)
         expected = self.read_csv(StringIO(data), index_col=[1, 0])
         tm.assert_frame_equal(df, expected)
 
@@ -1177,10 +1189,10 @@ bar"""
 02/02/2010,1,2
 """
         parser = lambda d: parse(d, dayfirst=True)
-        df = self.read_csv(StringIO(text), skiprows=[0],
-                      names=['time', 'Q', 'NTU'], index_col=0,
-                      parse_dates=True, date_parser=parser,
-                      na_values=['NA'])
+        df = self.read_csv(StringIO(text),
+                           names=['time', 'Q', 'NTU'], header=0,
+                           index_col=0, parse_dates=True,
+                           date_parser=parser, na_values=['NA'])
 
         exp_index = Index([datetime(2010, 1, 31), datetime(2010, 2, 1),
                            datetime(2010, 2, 2)], name='time')
@@ -1704,7 +1716,7 @@ eight,1,2,3"""
         sfile = StringIO(s)
         # it's 33 columns
         result = self.read_csv(sfile, names=range(33), na_values=['-9999.0'],
-                               skipinitialspace=True)
+                               header=None, skipinitialspace=True)
         self.assertTrue(pd.isnull(result.ix[0, 29]))
 
 class TestCParserHighMemory(ParserTests, unittest.TestCase):
@@ -1800,6 +1812,12 @@ a,b,c
 
         tm.assert_frame_equal(result, result2)
 
+        result = self.read_csv(StringIO(data), usecols=[1, 2], header=0,
+                               names=['foo', 'bar'])
+        expected = self.read_csv(StringIO(data), usecols=[1, 2])
+        expected.columns = ['foo', 'bar']
+        tm.assert_frame_equal(result, expected)
+
     def test_pure_python_failover(self):
         data = "a,b,c\n1,2,3#ignore this!\n4,5,6#ignorethistoo"
 
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index e0dc32c7e..90a2d9b22 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -25,11 +25,6 @@ cimport numpy as cnp
 from numpy cimport ndarray, uint8_t, uint64_t
 
 import numpy as np
-
-# cdef extern from "Python.h":
-#     void Py_INCREF(PyObject*)
-#     void Py_XDECREF(PyObject*)
-
 cimport util
 
 import pandas.lib as lib
@@ -401,10 +396,7 @@ cdef class TextReader:
         #----------------------------------------
         # header stuff
 
-        self.names = names
         self.leading_cols = 0
-        if names is not None:
-            header = None
 
         # TODO: no header vs. header is not the first row
         if header is None:
@@ -415,6 +407,7 @@ cdef class TextReader:
             self.parser.header = header
             self.parser_start = header + 1
 
+        self.names = names
         self.header, self.table_width = self._get_header()
 
         # compute buffer_lines as function of table width
@@ -545,6 +538,16 @@ cdef class TextReader:
 
             data_line = self.parser.header + 1
 
+            if self.names is not None:
+                if self.has_usecols and len(self.names) != len(self.usecols):
+                    raise CParserError('Number of passed names do not match'
+                                       ' usecols length.')
+                # elif not self.has_usecols:
+                #     lead = len(self.names) < self.table_width
+                #     self.leading_cols = lead
+
+                header = self.names
+
         elif self.names is not None:
             # Names passed
             if self.parser.lines < 1:
@@ -562,15 +565,20 @@ cdef class TextReader:
         # Corner case, not enough lines in the file
         if self.parser.lines < data_line + 1:
             field_count = len(header)
-        else:
+        elif not self.has_usecols:
             field_count = self.parser.line_fields[data_line]
+
             passed_count = len(header)
 
             if passed_count > field_count:
-                raise CParserError('Column names have %d fields, data has %d'
-                                   ' fields' % (passed_count, field_count))
+                raise CParserError('Column names have %d fields, '
+                                   'data has %d fields'
+                                   % (passed_count, field_count))
 
             self.leading_cols = field_count - passed_count
+        else:
+            # TODO: some better check here
+            pass
 
         return header, field_count
 
@@ -712,7 +720,7 @@ cdef class TextReader:
 
     def _convert_column_data(self, rows=None, upcast_na=False, footer=0):
         cdef:
-            Py_ssize_t i, ncols
+            Py_ssize_t i, nused, ncols
             kh_str_t *na_hashset = NULL
             int start, end
             object name
@@ -730,8 +738,9 @@ cdef class TextReader:
         #     end -= footer
 
         results = {}
+        nused = 0
         for i in range(self.table_width):
-            name = self._get_column_name(i)
+            name = self._get_column_name(i, nused)
 
             if self.has_usecols and not (i in self.usecols or
                                          name in self.usecols):
@@ -773,6 +782,9 @@ cdef class TextReader:
 
             results[i] = col_res
 
+            # number of used columns
+            nused += 1
+
         self.parser_start += end - start
 
         return results
@@ -920,11 +932,14 @@ cdef class TextReader:
     cdef _free_na_set(self, kh_str_t *table):
         kh_destroy_str(table)
 
-    cdef _get_column_name(self, i):
-        if self.header is not None:
-            return self.header[i - self.leading_cols]
+    cdef _get_column_name(self, Py_ssize_t i, Py_ssize_t nused):
+        if self.has_usecols and self.names is not None:
+            return self.names[nused]
         else:
-            return None
+            if self.header is not None:
+                return self.header[i - self.leading_cols]
+            else:
+                return None
 
 class CParserError(Exception):
     pass
diff --git a/pandas/src/parser/tokenizer.c b/pandas/src/parser/tokenizer.c
index 48cc193d4..445ef0527 100644
--- a/pandas/src/parser/tokenizer.c
+++ b/pandas/src/parser/tokenizer.c
@@ -7,7 +7,7 @@ See LICENSE for the license
 */
 
  /*
-n   Low-level ascii-file processing for pandas. Combines some elements from
+   Low-level ascii-file processing for pandas. Combines some elements from
    Python's built-in csv module and Warren Weckesser's textreader project on
    GitHub. See Python Software Foundation License and BSD licenses for these.
 
@@ -24,9 +24,6 @@ n   Low-level ascii-file processing for pandas. Combines some elements from
 #define READ_ERROR_OUT_OF_MEMORY   1
 
 
-#define HAVE_MEMMAP
-#define HAVE_GZIP
-
 /*
 * restore:
 *  RESTORE_NOT     (0):
@@ -1238,153 +1235,6 @@ int tokenize_all_rows(parser_t *self) {
     return status;
 }
 
-/*
-  Iteration through ragged matrix structure
-*/
-
-/* int test_tokenize(char *fname) { */
-/*     parser_t *self; */
-/*     coliter_t citer; */
-/*     int status = 0; */
-/*     int nbytes = CHUNKSIZE; */
-
-/*     clock_t start = clock(); */
-
-/*     self = parser_new(); */
-/*     self->chunksize = nbytes; */
-
-/*     // self->source = malloc(sizeof(file_source)); */
-
-/*     FILE* fp = fopen(fname, "rb"); */
-/*     parser_file_source_init(self, fp); */
-
-/*     parser_set_default_options(self); */
-
-/*     if (parser_init(self) < 0) { */
-/*         return -1; */
-/*     } */
-
-/*     self->header = 0; */
-
-/*     status = tokenize_all_rows(self); */
-
-/*     if (status != 0) { */
-/*         if (self->error_msg == NULL) { */
-/*             printf("PARSE_ERROR: no message\n"); */
-/*         } */
-/*         else { */
-/*             printf("PARSE_ERROR: %s", self->error_msg); */
-/*         } */
-/*     } */
-
-
-/*     // debug_print_parser(parser); */
-
-/*     // return 0; */
-/*     /\* if (status < 0) { *\/ */
-/*     /\*  return status; *\/ */
-/*     /\* } *\/ */
-
-/*     /\* int i, words = 0; *\/ */
-/*     /\* for (i = 0; i < parser.stream_len; ++i) *\/ */
-/*     /\* { *\/ */
-/*     /\*     if (parser.stream[i] == '\0') words++; *\/ */
-/*     /\* } *\/ */
-
-/*     printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC); */
-/*     /\* return 0; *\/ */
-
-/*     int i, j, error, columns; */
-/*     char *word; */
-/*     double data; */
-
-/*     columns = self->line_fields[0]; */
-
-/*     printf("columns: %d\n", columns); */
-/*     printf("errno is %d\n", errno); */
-
-/*     for (j = 0; j < columns; ++j) */
-/*     { */
-/*         coliter_setup(&citer, self, j, 0); */
-
-/*         for (i = 0; i < self->lines; ++i) */
-/*         { */
-/*             if (j >= self->line_fields[i]) continue; */
-
-/*             word = COLITER_NEXT(citer); */
-/*             error = to_double(word, &data, self->sci, self->decimal); */
-/*             if (error != 1) { */
-/*                 printf("error at %d, errno: %d\n", i, errno); */
-/*                 printf("failed: %s %d\n", word, (int) strlen(word)); */
-/*                 break; */
-/*             } */
-/*         } */
-/*     } */
-
-/*     /\* for (j = 0; j < columns; ++j) *\/ */
-/*     /\* { *\/ */
-/*     /\*  // citer = coliter_new(&parser, j); *\/ */
-/*     /\*  for (i = 0; i < parser->lines; ++i) *\/ */
-/*     /\*  { *\/ */
-/*     /\*      if (j >= parser->line_fields[i]) continue; *\/ */
-/*     /\*      word = parser->words[parser->line_start[i] + j]; *\/ */
-/*     /\*      error = to_double(word, &data, parser->sci, parser->decimal); *\/ */
-/*     /\*      if (error != 1) { *\/ */
-/*     /\*          printf("error at %d, errno: %d\n", i, errno); *\/ */
-/*     /\*          printf("failed: %s %d\n", word, (int) strlen(word)); *\/ */
-/*     /\*          break; *\/ */
-/*     /\*      } *\/ */
-/*     /\*  } *\/ */
-/*     /\*  // free(citer); *\/ */
-/*     /\* } *\/ */
-
-/*     printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC); */
-
-/*     /\* for (i = 0; i < parser.words_len; ++i) *\/ */
-/*     /\* { *\/ */
-/*     /\*     error = to_double(parser.words[i], &data, parser.sci, parser.decimal); *\/ */
-/*     /\*  if (error != 1) { *\/ */
-/*     /\*      ; *\/ */
-/*     /\*      printf("failed: %s %d\n", parser.words[i], *\/ */
-/*     /\*             (int) strlen(parser.words[i])); *\/ */
-/*     /\*  } else { *\/ */
-/*     /\*      ; *\/ */
-/*     /\*      /\\* printf("success: %.4f\n", data); *\\/ *\/ */
-/*     /\*  } *\/ */
-/*     /\* } *\/ */
-
-
-/*     /\* for (i = 0; i < parser.words_len; ++i) *\/ */
-/*     /\* { *\/ */
-/*     /\*     error = to_double(parser.words[i], &data, parser.sci, parser.decimal); *\/ */
-/*     /\*  if (error != 1) { *\/ */
-/*     /\*      ; *\/ */
-/*             /\* printf("failed: %s %d\n", parser.words[i], *\/ */
-/*             /\*     (int) strlen(parser.words[i])); *\/ */
-/*     /\*  } else { *\/ */
-/*     /\*      ; *\/ */
-/*     /\*      /\\* printf("success: %.4f\n", data); *\\/ *\/ */
-/*     /\*  } *\/ */
-/*     /\* } *\/ */
-
-
-/*     /\* printf("saw %d words\n", words); *\/ */
-
-/*     // debug_print_parser(&parser); */
-
-/*     parser_free(self); */
-
-/*     fclose(fp); */
-
-/*     /\* if (parser_cleanup(self) < 0) { *\/ */
-/*     /\*     return -1; *\/ */
-/*     /\* } *\/ */
-
-/*     /\* free(parser); *\/ */
-
-/*     return status; */
-/* } */
-
 
 void test_count_lines(char *fname) {
     clock_t start = clock();
@@ -1423,27 +1273,6 @@ void test_count_lines(char *fname) {
 }
 
 
-/* int main(int argc, char *argv[]) */
-/* { */
-/*     // import_array(); */
-
-/*     TRACE(("hello: %s\n", "Wes")); */
-
-/*     test_tokenize("/Users/wesm/code/pandas/pandas/io/tests/test1.csv"); */
-
-/*     // char *msg = (char*) malloc(50); */
-/*     // sprintf(msg, "Hello: %s\n", "wes"); */
-/*     // printf("%s", msg); */
-
-/*     /\* int i; *\/ */
-/*     /\* for (i = 0; i < 10; ++i) *\/ */
-/*     /\* { *\/ */
-/*     /\*  test_count_lines("../foo.csv"); *\/ */
-/*     /\* } *\/ */
-
-/*     return 0; */
-/* } */
-
 
 // forward declaration
 double P_INLINE xstrtod(const char *p, char **q, char decimal, char sci, int skip_trailing);
@@ -1533,51 +1362,51 @@ int P_INLINE to_longlong(char *item, long long *p_value)
 
 int P_INLINE to_longlong_thousands(char *item, long long *p_value, char tsep)
 {
-	int i, pos, status, n = strlen(item), count = 0;
-	char *tmp;
+    int i, pos, status, n = strlen(item), count = 0;
+    char *tmp;
     char *p_end;
 
-	for (i = 0; i < n; ++i)
-	{
-		if (*(item + i) == tsep) {
-			count++;
-		}
-	}
+    for (i = 0; i < n; ++i)
+    {
+        if (*(item + i) == tsep) {
+            count++;
+        }
+    }
 
-	if (count == 0) {
-		return to_longlong(item, p_value);
-	}
+    if (count == 0) {
+        return to_longlong(item, p_value);
+    }
 
-	tmp = (char*) malloc((n - count + 1) * sizeof(char));
-	if (tmp == NULL) {
-		return 0;
-	}
+    tmp = (char*) malloc((n - count + 1) * sizeof(char));
+    if (tmp == NULL) {
+        return 0;
+    }
 
-	pos = 0;
-	for (i = 0; i < n; ++i)
-	{
-		if (item[i] != tsep)
-			tmp[pos++] = item[i];
-	}
+    pos = 0;
+    for (i = 0; i < n; ++i)
+    {
+        if (item[i] != tsep)
+            tmp[pos++] = item[i];
+    }
 
-	tmp[pos] = '\0';
+    tmp[pos] = '\0';
 
-	status = to_longlong(tmp, p_value);
-	free(tmp);
+    status = to_longlong(tmp, p_value);
+    free(tmp);
 
-	return status;
+    return status;
 }
 
 int to_boolean(char *item, uint8_t *val) {
-	char *tmp;
-	int i, status = 0;
+    char *tmp;
+    int i, status = 0;
 
     static const char *tstrs[2] = {"TRUE", "YES"};
     static const char *fstrs[2] = {"FALSE", "NO"};
 
-	tmp = malloc(sizeof(char) * (strlen(item) + 1));
-	strcpy(tmp, item);
-	uppercase(tmp);
+    tmp = malloc(sizeof(char) * (strlen(item) + 1));
+    strcpy(tmp, item);
+    uppercase(tmp);
 
     for (i = 0; i < 2; ++i)
     {
@@ -1598,8 +1427,8 @@ int to_boolean(char *item, uint8_t *val) {
     status = -1;
 
 done:
-	free(tmp);
-	return status;
+    free(tmp);
+    return status;
 }
 
 // #define TEST
@@ -1609,15 +1438,15 @@ done:
 int main(int argc, char *argv[])
 {
     double x, y;
-	long long xi;
+    long long xi;
     int status;
     char *s;
 
     //s = "0.10e-3-+5.5e2i";
     // s = "1-0j";
     // status = to_complex(s, &x, &y, 'e', '.');
-	s = "123,789";
-	status = to_longlong_thousands(s, &xi, ',');
+    s = "123,789";
+    status = to_longlong_thousands(s, &xi, ',');
     printf("s = '%s'\n", s);
     printf("status = %d\n", status);
     printf("x = %d\n", (int) xi);
@@ -1672,7 +1501,7 @@ int main(int argc, char *argv[])
 //
 
 double P_INLINE xstrtod(const char *str, char **endptr, char decimal,
-					  char sci, int skip_trailing)
+                      char sci, int skip_trailing)
 {
   double number;
   int exponent;
@@ -1786,7 +1615,7 @@ double P_INLINE xstrtod(const char *str, char **endptr, char decimal,
 
 
   if (number == HUGE_VAL) {
-	  errno = ERANGE;
+      errno = ERANGE;
   }
 
   if (skip_trailing) {
@@ -1822,7 +1651,7 @@ double atof(const char *str)
 // ---------------------------------------------------------------------------
 
 int64_t str_to_int64(const char *p_item, int64_t int_min, int64_t int_max,
-					 int *error, char tsep)
+                     int *error, char tsep)
 {
     const char *p = (const char *) p_item;
     int isneg = 0;
@@ -1858,39 +1687,39 @@ int64_t str_to_int64(const char *p_item, int64_t int_min, int64_t int_max,
 
         // Process the digits.
         d = *p;
-		if (tsep != '\0') {
-			while (1) {
-				if (d == tsep) {
-					d = *++p;
-					continue;
-				} else if (!isdigit(d)) {
-					break;
-				}
-				if ((number > pre_min) ||
-					((number == pre_min) && (d - '0' <= dig_pre_min))) {
-
-					number = number * 10 - (d - '0');
-					d = *++p;
-				}
-				else {
-					*error = ERROR_OVERFLOW;
-					return 0;
-				}
-			}
-		} else {
-			while (isdigit(d)) {
-				if ((number > pre_min) ||
-					((number == pre_min) && (d - '0' <= dig_pre_min))) {
-
-					number = number * 10 - (d - '0');
-					d = *++p;
-				}
-				else {
-					*error = ERROR_OVERFLOW;
-					return 0;
-				}
-			}
-		}
+        if (tsep != '\0') {
+            while (1) {
+                if (d == tsep) {
+                    d = *++p;
+                    continue;
+                } else if (!isdigit(d)) {
+                    break;
+                }
+                if ((number > pre_min) ||
+                    ((number == pre_min) && (d - '0' <= dig_pre_min))) {
+
+                    number = number * 10 - (d - '0');
+                    d = *++p;
+                }
+                else {
+                    *error = ERROR_OVERFLOW;
+                    return 0;
+                }
+            }
+        } else {
+            while (isdigit(d)) {
+                if ((number > pre_min) ||
+                    ((number == pre_min) && (d - '0' <= dig_pre_min))) {
+
+                    number = number * 10 - (d - '0');
+                    d = *++p;
+                }
+                else {
+                    *error = ERROR_OVERFLOW;
+                    return 0;
+                }
+            }
+        }
     }
     else {
         // If number is less than pre_max, at least one more digit
@@ -1902,41 +1731,41 @@ int64_t str_to_int64(const char *p_item, int64_t int_min, int64_t int_max,
 
         // Process the digits.
         d = *p;
-		if (tsep != '\0') {
-			while (1) {
-				if (d == tsep) {
-					d = *++p;
-					continue;
-				} else if (!isdigit(d)) {
-					break;
-				}
-				if ((number < pre_max) ||
-					((number == pre_max) && (d - '0' <= dig_pre_max))) {
-
-					number = number * 10 + (d - '0');
-					d = *++p;
-
-				}
-				else {
-					*error = ERROR_OVERFLOW;
-					return 0;
-				}
-			}
-		} else {
-			while (isdigit(d)) {
-				if ((number < pre_max) ||
-					((number == pre_max) && (d - '0' <= dig_pre_max))) {
-
-					number = number * 10 + (d - '0');
-					d = *++p;
-
-				}
-				else {
-					*error = ERROR_OVERFLOW;
-					return 0;
-				}
-			}
-		}
+        if (tsep != '\0') {
+            while (1) {
+                if (d == tsep) {
+                    d = *++p;
+                    continue;
+                } else if (!isdigit(d)) {
+                    break;
+                }
+                if ((number < pre_max) ||
+                    ((number == pre_max) && (d - '0' <= dig_pre_max))) {
+
+                    number = number * 10 + (d - '0');
+                    d = *++p;
+
+                }
+                else {
+                    *error = ERROR_OVERFLOW;
+                    return 0;
+                }
+            }
+        } else {
+            while (isdigit(d)) {
+                if ((number < pre_max) ||
+                    ((number == pre_max) && (d - '0' <= dig_pre_max))) {
+
+                    number = number * 10 + (d - '0');
+                    d = *++p;
+
+                }
+                else {
+                    *error = ERROR_OVERFLOW;
+                    return 0;
+                }
+            }
+        }
     }
 
     // Skip trailing spaces.
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index ad9203ae6..3a4936862 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -349,7 +349,8 @@ class TestDataFrameFormatting(unittest.TestCase):
         lines = result.split('\n')
         header = lines[0].strip().split()
         joined = '\n'.join([re.sub('\s+', ' ', x).strip() for x in lines[1:]])
-        recons = read_table(StringIO(joined), names=header, sep=' ')
+        recons = read_table(StringIO(joined), names=header,
+                            header=None, sep=' ')
         tm.assert_series_equal(recons['B'], biggie['B'])
         self.assertEqual(recons['A'].count(), biggie['A'].count())
         self.assert_((np.abs(recons['A'].dropna() -

commit a06d9a664a4c056fadaa92ae01ceb55ebdb89119
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 17 06:44:13 2009 +0000

    more DataFrame unit test coverage
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@86 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 27b8467ed..52b957c4c 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -274,19 +274,9 @@ class DataFrame(Picklable, Groupable):
             return self._series[item]
         except (TypeError, KeyError):
             if isinstance(item, slice):
-                start, stop = item.start, item.stop
-                start = 0 if start is None else start
-                stop = len(self) if stop is None else stop
-                if start < 0:
-                    start += len(self)
-                if stop < 0:
-                    stop += len(self)
-
-                dateRange = self.index[start:stop]
-                newColumns = {}
-                for col, series in self.iteritems():
-                    newColumns[col] = series[start:stop]
-                return DataFrame(data=newColumns, index=dateRange)
+                dateRange = self.index[item]
+                return self.reindex(dateRange)
+
             elif isinstance(item, np.ndarray):
 
                 if len(item) != len(self.index):
@@ -314,9 +304,6 @@ class DataFrame(Picklable, Groupable):
             else:
                 cleanSeries = Series(value, index=self.index)
 
-            if len(cleanSeries) != len(self.index):
-                raise Exception('Series was wrong length!')
-
             self._series[key] = cleanSeries
         # Scalar
         else:
@@ -417,14 +404,12 @@ class DataFrame(Picklable, Groupable):
                 newSeries = func(series, other[col])
                 newColumns[col] = newSeries.reindex(newIndex)
             else:
-                cls = series.__class__
-                newColumns[col] = cls(np.repeat(NaN, len(newIndex)),
-                                          index=newIndex)
+                newColumns[col] = series.fromValue(np.NaN, index=newIndex)
+
         for col, series in other.iteritems():
             if col not in self:
                 cls = series.__class__
-                newColumns[col] = cls(np.repeat(NaN, len(newIndex)),
-                                      index=newIndex)
+                newColumns[col] = series.fromValue(np.NaN, index=newIndex)
 
         return DataFrame(data=newColumns, index=newIndex)
 
@@ -491,27 +476,24 @@ class DataFrame(Picklable, Groupable):
 #-------------------------------------------------------------------------------
 # Public methods
 
-    def toCSV(self, path=None, nanRep='', cols=None, inclHeader=True,
-              inclIndex=True, verbose=False):
+    def toCSV(self, path, nanRep='', cols=None, header=True,
+              index=True, verbose=False):
         """
         Write the DataFrame to a CSV file
         """
-        if path is None:
-            import sys
-            f = sys.stdout
-        else:
-            f = open(path, 'w')
+        f = open(path, 'w')
+
         cols = self.cols() if cols is None else cols
 
-        if inclHeader:
-            if inclIndex:
+        if header:
+            if index:
                 f.write(',' + ','.join([str(c) for c in cols]))
             else:
                 f.write(','.join([str(c) for c in cols]))
             f.write('\n')
 
         for idx in self.index:
-            if inclIndex:
+            if index:
                 f.write(str(idx) + ',')
             for col in cols:
                 val = self._series[col].get(idx)
@@ -521,10 +503,10 @@ class DataFrame(Picklable, Groupable):
                     val = str(val)
                 f.write(val + ',')
             f.write('\n')
-        if path is not None:
-            f.close()
 
-        if verbose:
+        f.close()
+
+        if verbose: # pragma: no cover
             print 'CSV file written successfully: %s' % path
 
     def toDataMatrix(self):
@@ -604,17 +586,20 @@ class DataFrame(Picklable, Groupable):
         """
         newIndex = np.concatenate((self.index, otherFrame.index))
         newValues = {}
+        
         for column, series in self.iteritems():
             if column in otherFrame:
                 newValues[column] = series.append(otherFrame[column])
             else:
                 newValues[column] = series
+
         for column, series in otherFrame.iteritems():
             if column not in self:
                 newValues[column] = series
+
         return DataFrame(data=newValues, index=newIndex)
 
-    def asfreq(self, freq, fillMethod = None):
+    def asfreq(self, freq, fillMethod=None):
         """
         Convert all TimeSeries inside to specified frequency using DateOffset
         objects. Optionally provide fill method to pad/backfill/interpolate
@@ -633,7 +618,7 @@ class DataFrame(Picklable, Groupable):
         else:
             dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
 
-        return self.reindex(dateRange, fillMethod = fillMethod)
+        return self.reindex(dateRange, fillMethod=fillMethod)
 
     def asMatrix(self, columns=None):
         """
@@ -674,11 +659,11 @@ class DataFrame(Picklable, Groupable):
 
         # Get the covariance with items that have NaN values
         for i, A in enumerate(mat):
-            bada = np.isnan(A)
-            if np.any(bada):
+            aok = np.isfinite(A)
+            if not aok.all():
                 for j, B in enumerate(mat):
-                    commonVec = (- bada) & (- np.isnan(B))
-                    if any(commonVec):
+                    commonVec = aok & np.isfinite(B)
+                    if commonVec.any():
                         ac, bc = A[commonVec], B[commonVec]
                         c = np.corrcoef(ac, bc)[0, 1]
                         correl[i, j] = c
@@ -788,76 +773,67 @@ class DataFrame(Picklable, Groupable):
         ----
         Error thrown if all of fromDate, toDate, nPeriods specified.
         """
-        if toDate:
-            if toDate not in self.index:
-                if toDate > self.index[0]:
-                    toDate = self.index.asOfDate(toDate)
-                else:
-                    raise Exception('End date after last date in this index!')
-        if fromDate:
-            if fromDate not in self.index:
-                if fromDate < self.index[-1]:
-                    fromDate = self.index.asOfDate(fromDate)
-                else:
-                    raise Exception('Begin date after last date in this index!')
-        if fromDate and toDate:
-            if nPeriods:
+        beg_slice, end_slice = self._getIndices(fromDate, toDate)
+
+        if nPeriods:
+            if fromDate and toDate:
                 raise Exception('fromDate/toDate, toDate/nPeriods, ' + \
                                 ' fromDate/nPeriods are mutually exclusive')
-            beg_slice = self.index.indexMap[fromDate]
-            end_slice = self.index.indexMap[toDate] + 1
-        elif fromDate and nPeriods:
-            beg_slice = self.index.indexMap[fromDate]
-            end_slice = self.index.indexMap[fromDate] + nPeriods
-        elif toDate and nPeriods:
-            beg_slice = self.index.indexMap[toDate] - nPeriods + 1
-            end_slice = self.index.indexMap[toDate] + 1
-        else:
-            raise Exception('Not enough arguments provided to getTS')
+            elif fromDate:
+                end_slice = min(len(self), beg_slice + nPeriods)
+            elif toDate:
+                beg_slice = max(0, end_slice - nPeriods)
+            else:
+                raise Exception('Not enough arguments provided to getTS')
 
-        # Fix indices in case they fall out of the boundaries
-        beg_slice = max(0, beg_slice)
-        end_slice = min(len(self.index), end_slice)
         dateRange = self.index[beg_slice:end_slice]
 
         if colName:
-            return self[colName][beg_slice:end_slice]
+            return self[colName].reindex(dateRange)
         else:
-            newColumns = {}
-            for col, series in self.iteritems():
-                newColumns[col] = series[beg_slice:end_slice]
-            return DataFrame(data=newColumns, index=dateRange)
+            return self.reindex(dateRange)
 
-    def truncate(self, before = None, after = None):
-        """
-        Placeholder for documentation
+    def truncate(self, before=None, after=None, periods=None):
+        """Function truncate a sorted DataFrame before and/or after
+        some particular dates.
+
+        Parameters
+        ----------
+        before : date
+            Truncate before date
+        after : date
+            Truncate after date
+        
+        Returns
+        -------
+        DataFrame
         """
-        import bisect
+        beg_slice, end_slice = self._getIndices(before, after)
+        
+        return self[beg_slice:end_slice]
 
-        before = datetools.to_datetime(before)
-        after = datetools.to_datetime(after)
+    def _getIndices(self, before, after):
+        before = arg_before = datetools.to_datetime(before)
+        after = arg_after = datetools.to_datetime(after)
 
-        if before is not None:
-            binsearch = bisect.bisect_left(self.index, before)
-            cur = self.index[binsearch]
-            next = self.index[min(binsearch + 1, len(self.index) - 1)]
-            leftDate = cur if cur >= before else next
-        else:
-            leftDate = self.index[0]
-
-        if after is not None:
-            if after < self.index[-1]:
-                binsearch = bisect.bisect_right(self.index, after)
-                cur = self.index[binsearch]
-                prior = self.index[max(binsearch - 1, 0)]
-                rightDate = cur if cur <= after else prior
-            else:
-                rightDate = self.index[-1]
-        else:
-            rightDate = self.index[-1]
+        if before is None:
+            before = self.index[0]
+        elif before not in self.index:
+            loc = self.index.searchsorted(before, side='left')
+            before = self.index[loc]
 
-        return self.getTS(fromDate=leftDate, toDate=rightDate)
+        if after is None:
+            after = self.index[-1]
+        elif after not in self.index:
+            loc = self.index.searchsorted(after, side='right') - 1
+            loc = loc if loc < len(self.index) else -1
+            after = self.index[loc]
 
+        beg_slice = self.index.indexMap[before]
+        end_slice = self.index.indexMap[after] + 1
+
+        return beg_slice, end_slice
+        
     def getXS(self, key, subset=None, asOf=False):
         """
         Returns a row from the DataFrame as a Series object.
@@ -914,7 +890,7 @@ class DataFrame(Picklable, Groupable):
         fillMethod : {'backfill', 'pad', 'interpolate', None}
             Method to use for filling holes in reindexed DataFrame
         """
-        if newIndex is self.index:
+        if self.index.equals(newIndex):
             return self.copy()
 
         if len(newIndex) == 0:
@@ -1044,11 +1020,6 @@ class DataFrame(Picklable, Groupable):
         results = {}
         for col, series in self.iteritems():
             result = func(series)
-
-            # WORKAROUND FOR NUMPY/SCIPY FUNCTIONS RETURNING UNSIZED NDARRAY
-            if isinstance(result, np.ndarray) and result.ndim == 0:
-                result = result.item()
-
             results[col] = result
 
         if hasattr(results.values()[0], '__iter__'):
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 4ca69356f..92a1ebf97 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -548,22 +548,9 @@ class DataMatrix(DataFrame):
         This is a magic method. Do NOT call explicity.
         """
         if isinstance(item, slice):
-            start, stop = item.start, item.stop
-            start = 0 if start is None else start
-            stop = len(self) if stop is None else stop
-            if start < 0:
-                start += len(self)
-            if stop < 0:
-                stop += len(self)
-
-            indexRange = self.index[start:stop]
-            if self.objects is not None:
-                newObjects = self.objects.reindex(indexRange)
-            else:
-                newObjects = None
+            indexRange = self.index[item]
+            return self.reindex(indexRange)
 
-            return DataMatrix(data=self.values[start:stop], index=indexRange,
-                              columns=self.columns, objects=newObjects)
         elif isinstance(item, np.ndarray):
             if len(item) != len(self.index):
                 raise Exception('Item wrong length %d instead of %d!' %
diff --git a/pandas/core/tests/common.py b/pandas/core/tests/common.py
index d227eba6c..1e60f6a67 100644
--- a/pandas/core/tests/common.py
+++ b/pandas/core/tests/common.py
@@ -60,9 +60,17 @@ def assert_dict_equal(a, b, compare_keys=True):
         assert_almost_equal(a[k], b[k])
 
 def assert_series_equal(left, right):
-    assert(np.array_equal(left, right))
+    assert_almost_equal(left, right)
     assert(np.array_equal(left.index, right.index))
 
+def assert_frame_equal(left, right):
+    for col, series in left.iteritems():
+        assert(col in right)
+        assert_series_equal(series, right[col])
+
+    for col in right:
+        assert(col in left)
+    
 def assert_contains_all(iterable, dic):
     for k in iterable:
         assert(k in dic)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 815356e6a..7c830ceb3 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -2,6 +2,7 @@
 
 from copy import deepcopy
 from datetime import datetime
+import os
 import unittest
 
 from numpy import random
@@ -9,6 +10,7 @@ import numpy as np
 
 from pandas.core.api import DateRange, DataFrame, Index, Series
 from pandas.core.datetools import bday
+import pandas.core.datetools as datetools
 
 from pandas.core.tests.common import assert_almost_equal, randn
 import pandas.core.tests.common as common
@@ -40,7 +42,8 @@ class TestDataFrame(unittest.TestCase):
             'col3' : self.ts3,
             'col4' : self.ts4,
         }
-
+        self.empty = DataFrame({})
+        
     def test_constructor(self):
         df = DataFrame()
         self.assert_(len(df.index) == 0)
@@ -130,9 +133,7 @@ class TestDataFrame(unittest.TestCase):
                           mat, ['A', 'B'], [1, 2])
 
     def test_nonzero(self):
-        empty = DataFrame({})
-
-        self.assertFalse(empty)
+        self.assertFalse(self.empty)
 
         self.assert_(self.frame)
         
@@ -253,17 +254,57 @@ class TestDataFrame(unittest.TestCase):
         f = -self.frame
 
     def test_firstTimeWithNValues(self):
-        pass
+        self.frame['A'][:5] = np.NaN
 
-    def test_firstTimeWithValue(self):
-        pass
+        index = self.frame._firstTimeWithNValues()
+        self.assert_(index == self.frame.index[5])
+        
+    def test_firstLastValid(self):
+        N = len(self.frame.index)
+        mat = randn(N)
+        mat[:5] = np.NaN
+        mat[-5:] = np.NaN
+        
+        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        index = frame._firstTimeWithValue()
 
-    def test_lastTimeWithValue(self):
-        pass
+        self.assert_(index == frame.index[5])
+
+        index = frame._lastTimeWithValue()
+        self.assert_(index == frame.index[-6])        
 
     def test_combineFrame(self):
-        pass
+        frame_copy = self.frame.reindex(self.frame.index[::2])
 
+        del frame_copy['D']
+        frame_copy['C'][:5] = np.NaN
+
+        added = self.frame + frame_copy
+        common.assert_dict_equal(added['A'].valid(),
+                                 self.frame['A'] * 2,
+                                 compare_keys=False)
+
+        self.assert_(np.isnan(added['C'][:5]).all())
+        self.assert_(np.isnan(added['D']).all())
+            
+        self_added = self.frame + self.frame
+        self.assert_(self_added.index is self.frame.index)
+        
+        added_rev = frame_copy + self.frame
+        self.assert_(np.isnan(added['D']).all())
+        
+        # corner cases
+
+        # empty
+        plus_empty = self.frame + self.empty
+        self.assert_(np.isnan(plus_empty.values).all())
+
+        empty_plus = self.empty + self.frame
+        self.assert_(np.isnan(empty_plus.values).all())
+
+        empty_empty = self.empty + self.empty
+        self.assert_(not empty_empty)
+        
     def test_combineSeries(self):
         pass
 
@@ -271,10 +312,19 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_toCSV(self):
-        pass
+        path = '__tmp__'
+
+        self.frame['A'][:5] = np.NaN
+
+        self.frame.toCSV(path)
+        self.frame.toCSV(path, cols=['A', 'B'])
+        self.frame.toCSV(path, header=False)
+        self.frame.toCSV(path, index=False)
+        
+        os.remove(path)
 
     def test_toDataMatrix(self):
-        pass
+        dm = self.frame.toDataMatrix()
 
     def test_toString(self):
         pass
@@ -295,11 +345,30 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_append(self):
-        pass
+        begin_index = self.frame.index[:5]
+        end_index = self.frame.index[5:]
+
+        begin_frame = self.frame.reindex(begin_index)
+        end_frame = self.frame.reindex(end_index)
 
+        appended = begin_frame.append(end_frame)
+        assert_almost_equal(appended['A'], self.frame['A'])
+        
+        del end_frame['A']
+        partial_appended = begin_frame.append(end_frame)
+        self.assert_('A' in partial_appended)
+
+        partial_appended = end_frame.append(begin_frame)
+        self.assert_('A' in partial_appended)
+        
     def test_asfreq(self):
-        pass
+        offset_monthly = self.tsframe.asfreq(datetools.bmonthEnd)
+        rule_monthly = self.tsframe.asfreq('EOM')
+        
+        assert_almost_equal(offset_monthly['A'], rule_monthly['A'])
 
+        filled = rule_monthly.asfreq('WEEKDAY', fillMethod='pad')
+        
     def test_asMatrix(self):
         frame = self.frame
         mat = frame.asMatrix()
@@ -328,33 +397,106 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_corr(self):
-        pass
+        self.frame['A'][:5] = np.NaN
+        self.frame['B'][:10] = np.NaN
 
-    def test_dropEmptyRows(self):
-        pass
+        correls = self.frame.corr()
+
+        assert_almost_equal(correls['A']['C'],
+                            self.frame['A'].corr(self.frame['C']))
 
+    def test_dropEmptyRows(self):
+        N = len(self.frame.index)
+        mat = randn(N)
+        mat[:5] = np.NaN
+        
+        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        
+        smaller_frame = frame.dropEmptyRows()
+        self.assert_(np.array_equal(smaller_frame['foo'], mat[5:]))
+        
     def test_dropIncompleteRows(self):
-        pass
+        N = len(self.frame.index)
+        mat = randn(N)
+        mat[:5] = np.NaN
+        
+        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        frame['bar'] = 5
+        
+        smaller_frame = frame.dropIncompleteRows()
+        self.assert_(np.array_equal(smaller_frame['foo'], mat[5:]))
 
+        samesize_frame = frame.dropIncompleteRows(specificColumns=['bar'])
+        self.assert_(samesize_frame.index is self.frame.index)
+        
     def test_fill(self):
-        pass
+        self.tsframe['A'][:5] = np.NaN
+        self.tsframe['A'][-5:] = np.NaN
+
+        zero_filled = self.tsframe.fill(0)
+        self.assert_((zero_filled['A'][:5] == 0).all())
 
+        padded = self.tsframe.fill(method='pad')
+        self.assert_(np.isnan(padded['A'][:5]).all())
+        self.assert_((padded['A'][-5:] == padded['A'][-5]).all())
+        
     def test_getTS(self):
         frame = self.tsframe
+
         tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
-        for i, idx in enumerate(tsFrame.index):
-            self.assertEqual(idx, frame.index[5+i])
-            for col, series in tsFrame.iteritems():
-                self.assertEqual(idx, series.index[i])
-        for col, series in frame.iteritems():
-            for idx, value in series.iteritems():
-                if np.isnan(value):
-                    self.assert_(np.isnan(frame[col][idx]))
-                else:
-                    self.assertEqual(value, frame[col][idx])
+        common.assert_frame_equal(tsFrame, frame[5:10])
+
+        tsFrame = frame.getTS(fromDate=frame.index[5], toDate=frame.index[9])
+        common.assert_frame_equal(tsFrame, frame[5:10])
+        
+        tsFrame = frame.getTS(nPeriods=5, toDate=frame.index[9])
+        common.assert_frame_equal(tsFrame, frame[5:10])
+
+        A = frame.getTS(colName='A', nPeriods=5, toDate=frame.index[9])
+        common.assert_series_equal(A, frame['A'][5:10])
+
+        self.assertRaises(Exception, frame.getTS, nPeriods=5)
 
     def test_truncate(self):
-        pass
+        offset = datetools.bday
+
+        ts = self.tsframe[::3]
+
+        start, end = self.tsframe.index[3], self.tsframe.index[6]
+
+        start_missing = self.tsframe.index[2]
+        end_missing = self.tsframe.index[7]
+
+        # neither specified
+        truncated = ts.truncate()
+        common.assert_frame_equal(truncated, ts)
+
+        # both specified
+        expected = ts[1:3]
+
+        truncated = ts.truncate(start, end)
+        common.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(start_missing, end_missing)
+        common.assert_frame_equal(truncated, expected)
+
+        # start specified
+        expected = ts[1:]
+
+        truncated = ts.truncate(before=start)
+        common.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(before=start_missing)
+        common.assert_frame_equal(truncated, expected)
+
+        # end specified
+        expected = ts[:3]
+
+        truncated = ts.truncate(after=end)
+        common.assert_frame_equal(truncated, expected)
+
+        truncated = ts.truncate(after=end_missing)
+        common.assert_frame_equal(truncated, expected)
 
     def test_getXS(self):
         idx = self.frame.index[5]
@@ -412,6 +554,10 @@ class TestDataFrame(unittest.TestCase):
         newFrame = self.frame.reindex([])
         self.assert_(not newFrame)
 
+        # pass non-Index
+        newFrame = self.frame.reindex(list(self.ts1.index))
+        self.assert_(newFrame.index.equals(self.ts1.index))
+        
     def test_reindex_mixed(self):
         pass
         
@@ -452,10 +598,15 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_sortUp(self):
-        pass
+        # what to do?
+        sorted = self.frame.sortUp()
+
+        sorted_A = self.frame.sortUp(column='A')
 
     def test_sortDown(self):
-        pass
+        sorted = self.frame.sortDown()
+
+        sorted_A = self.frame.sortDown(column='A')
 
     def test_filterLike(self):
         pass

commit 57427ac95c34c67fce13bb61937d5ac985314ee2
Author: Jeff Reback <jeff@reback.net>
Date:   Tue May 5 10:33:10 2015 -0400

    BUG: Bug in grouping with multiple pd.Grouper where one is non-time based (GH10063)

diff --git a/doc/source/whatsnew/v0.16.1.txt b/doc/source/whatsnew/v0.16.1.txt
index 9436b4c4b..4cd470562 100755
--- a/doc/source/whatsnew/v0.16.1.txt
+++ b/doc/source/whatsnew/v0.16.1.txt
@@ -231,7 +231,7 @@ Bug Fixes
 - Fixed bug in ``StataWriter`` resulting in changes to input ``DataFrame`` upon save (:issue:`9795`).
 - Bug in ``transform`` causing length mismatch when null entries were present and a fast aggregator was being used (:issue:`9697`)
 - Bug in ``equals`` causing false negatives when block order differed (:issue:`9330`)
-
+- Bug in grouping with multiple ``pd.Grouper`` where one is non-time based (:issue:`10063`)
 - Bug in ``read_sql_table`` error when reading postgres table with timezone (:issue:`7139`)
 - Bug in ``DataFrame`` slicing may not retain metadata (:issue:`9776`)
 - Bug where ``TimdeltaIndex`` were not properly serialized in fixed ``HDFStore`` (:issue:`9635`)
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index f141790fb..1f76d80c3 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -280,7 +280,10 @@ class Grouper(object):
         return self.grouper
 
     def _get_binner_for_grouping(self, obj):
-        raise AbstractMethodError(self)
+        """ default to the standard binner here """
+        group_axis = obj._get_axis(self.axis)
+        return Grouping(group_axis, None, obj=obj, name=self.key,
+                        level=self.level, sort=self.sort, in_axis=False)
 
     @property
     def groups(self):
@@ -1964,8 +1967,12 @@ class Grouping(object):
                 if self.name is None:
                     self.name = grouper.name
 
+            # we are done
+            if isinstance(self.grouper, Grouping):
+                self.grouper = self.grouper.grouper
+
             # no level passed
-            if not isinstance(self.grouper, (Series, Index, Categorical, np.ndarray)):
+            elif not isinstance(self.grouper, (Series, Index, Categorical, np.ndarray)):
                 if getattr(self.grouper, 'ndim', 1) != 1:
                     t = self.name or str(type(self.grouper))
                     raise ValueError("Grouper for '%s' not 1-dimensional" % t)
@@ -2834,7 +2841,7 @@ class NDFrameGroupBy(GroupBy):
                     v = next(v for v in values if v is not None)
                 except StopIteration:
                     # If all values are None, then this will throw an error.
-                    # We'd prefer it return an empty dataframe. 
+                    # We'd prefer it return an empty dataframe.
                     return DataFrame()
                 if v is None:
                     return DataFrame()
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index d19271eaf..c30830860 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -430,6 +430,21 @@ class TestGroupBy(tm.TestCase):
         expected = s.groupby(level='one').sum()
         assert_series_equal(result, expected)
 
+    def test_grouper_getting_correct_binner(self):
+
+        # GH 10063
+        # using a non-time-based grouper and a time-based grouper
+        # and specifying levels
+        df = DataFrame({'A' : 1 },
+                       index=pd.MultiIndex.from_product([list('ab'),
+                                                         date_range('20130101',periods=80)],
+                                                        names=['one','two']))
+        result = df.groupby([pd.Grouper(level='one'),pd.Grouper(level='two',freq='M')]).sum()
+        expected = DataFrame({'A' : [31,28,21,31,28,21]},
+                              index=MultiIndex.from_product([list('ab'),date_range('20130101',freq='M',periods=3)],
+                                                            names=['one','two']))
+        assert_frame_equal(result, expected)
+
     def test_grouper_iter(self):
         self.assertEqual(sorted(self.df.groupby('A').grouper), ['bar', 'foo'])
 

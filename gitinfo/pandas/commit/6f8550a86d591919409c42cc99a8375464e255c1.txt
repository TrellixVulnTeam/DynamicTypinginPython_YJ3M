commit 6f8550a86d591919409c42cc99a8375464e255c1
Author: jreback <jeff@reback.net>
Date:   Sat Aug 10 10:20:42 2013 -0400

    BUG: (GH4532) Fix bug in having a rhs of np.timedelta64 or np.offsets.DateOffset when operating
         with datetimes

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 0bcdd2276..7bac2f801 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -166,6 +166,8 @@ pandas 0.13
   - Fixed issue where individual ``names``, ``levels`` and ``labels`` could be
     set on ``MultiIndex`` without validation (:issue:`3714`, :issue:`4039`)
   - Fixed (:issue:`3334`) in pivot_table. Margins did not compute if values is the index.
+  - Fix bug in having a rhs of ``np.timedelta64`` or ``np.offsets.DateOffset`` when operating
+    with datetimes (:issue:`4532`)
 
 pandas 0.12
 ===========
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e28305820..ad74796d3 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -23,6 +23,7 @@ from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index, _handle_legacy_indexes)
 from pandas.core.indexing import (_SeriesIndexer, _check_bool_indexer,
                                   _check_slice_bounds, _maybe_convert_indices)
+from pandas.tseries.offsets import DateOffset
 from pandas.tseries.index import DatetimeIndex
 from pandas.tseries.period import PeriodIndex, Period
 from pandas import compat
@@ -99,16 +100,24 @@ def _arith_method(op, name, fill_zeros=None):
                     values = np.array([values])
                 inferred_type = lib.infer_dtype(values)
                 if inferred_type in set(['datetime64','datetime','date','time']):
+                    # a datetlike
                     if not (isinstance(values, pa.Array) and com.is_datetime64_dtype(values)):
                         values = tslib.array_to_datetime(values)
-                elif inferred_type in set(['timedelta','timedelta64']):
-                    # need to convert timedelta to ns here
-                    # safest to convert it to an object arrany to process
+                elif inferred_type in set(['timedelta']):
+                    # have a timedelta, convert to to ns here
                     if not (isinstance(values, pa.Array) and com.is_timedelta64_dtype(values)):
                         values = com._possibly_cast_to_timedelta(values)
+                elif inferred_type in set(['timedelta64']):
+                    # have a timedelta64, make sure dtype dtype is ns
+                    values = com._possibly_cast_to_timedelta(values)
                 elif inferred_type in set(['integer']):
+                    # py3 compat where dtype is 'm' but is an integer
                     if values.dtype.kind == 'm':
                         values = values.astype('timedelta64[ns]')
+                elif isinstance(values[0],DateOffset):
+                    # handle DateOffsets
+                    values = pa.array([ v.delta for v in values ])
+                    values = com._possibly_cast_to_timedelta(values)
                 else:
                     values = pa.array(values)
                 return values
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index b192aded4..cae75fb6e 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1949,6 +1949,27 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assert_(result.dtype=='m8[ns]')
         assert_series_equal(result,expected)
 
+        # GH 4532
+        # operate with pd.offsets
+        s = Series([Timestamp('20130101 9:01'),Timestamp('20130101 9:02')])
+
+        import pdb; pdb.set_trace()
+        result = s + pd.offsets.Second(5)
+        expected = Series([Timestamp('20130101 9:01:05'),Timestamp('20130101 9:02:05')])
+
+        result = s + pd.offsets.Milli(5)
+        expected = Series([Timestamp('20130101 9:01:00.005'),Timestamp('20130101 9:02:00.005')])
+        assert_series_equal(result,expected)
+
+        # operate with np.timedelta64 correctly
+        result = s + np.timedelta64(1,'s')
+        expected = Series([Timestamp('20130101 9:01:01'),Timestamp('20130101 9:02:01')])
+        assert_series_equal(result,expected)
+
+        result = s + np.timedelta64(5,'ms')
+        expected = Series([Timestamp('20130101 9:01:00.005'),Timestamp('20130101 9:02:00.005')])
+        assert_series_equal(result,expected)
+
     def test_operators_datetimelike(self):
 
         ### timedelta64 ###

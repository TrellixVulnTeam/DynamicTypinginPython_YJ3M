commit 8b4d2084c8e3ddd0f0b01ddead66efe26602406d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue May 3 01:03:32 2011 -0400

    skeleton of sparse WidePanel, unit tests and stubs, more necessary functionality

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d4c56faa3..d211321c0 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -642,7 +642,8 @@ class DataFrame(Picklable, Groupable):
             if col in this and col in other:
                 new_data[col] = func(this[col], other[col])
 
-        return DataFrame(data=new_data, index=new_index, columns=new_columns)
+        return self._constructor(data=new_data, index=new_index,
+                                 columns=new_columns)
 
     def _compare_frame(self, other, func):
         if not self._indexed_same(other):
@@ -653,8 +654,8 @@ class DataFrame(Picklable, Groupable):
         for col in self.columns:
             new_data[col] = func(self[col], other[col])
 
-        return DataFrame(data=new_data, index=self.index,
-                         columns=self.columns)
+        return self._constructor(data=new_data, index=self.index,
+                                 columns=self.columns)
 
     def _indexed_same(self, other):
         same_index = self.index.equals(other.index)
@@ -686,12 +687,15 @@ class DataFrame(Picklable, Groupable):
         this = self
         if self.index is not new_index:
             this = self.reindex(new_index)
+
+        if other.index is not new_index:
             other = other.reindex(new_index)
 
         for col, series in this.iteritems():
-            new_data[col] = func(series, other)
+            new_data[col] = func(series.values, other.values)
 
-        return DataFrame(new_data, index=new_index, columns=self.columns)
+        return self._constructor(new_data, index=new_index,
+                                 columns=self.columns)
 
     def _combine_match_columns(self, other, func):
         new_data = {}
@@ -705,15 +709,16 @@ class DataFrame(Picklable, Groupable):
         for col in intersection:
             new_data[col] = func(self[col], other[col])
 
-        return DataFrame(new_data, index=self.index, columns=union)
+        return self._constructor(new_data, index=self.index,
+                                 columns=union)
 
     def _combine_const(self, other, func):
         new_data = {}
         for col, series in self.iteritems():
             new_data[col] = func(series, other)
 
-        return DataFrame(data=new_data, index=self.index,
-                         columns=self.columns)
+        return self._constructor(data=new_data, index=self.index,
+                                 columns=self.columns)
 
 #-------------------------------------------------------------------------------
 # Public methods
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 2ed89cf62..c7d6db090 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -228,7 +228,7 @@ class WidePanel(Panel, Groupable):
                          self.minor_axis)
 
     @classmethod
-    def fromDict(cls, data, intersect=False, dtype=float):
+    def from_dict(cls, data, intersect=False, dtype=float):
         """
         Construct WidePanel from dict of DataFrame objects
 
@@ -249,6 +249,8 @@ class WidePanel(Panel, Groupable):
 
         return cls(values, items, index, columns)
 
+    fromDict = from_dict
+
     def keys(self):
         return list(self.items)
 
@@ -312,7 +314,7 @@ class WidePanel(Panel, Groupable):
             if len(value.items) != 1:
                 raise ValueError('Input panel must have only one item!')
 
-            value = value.toWide()[value.items[0]]
+            value = value.to_wide()[value.items[0]]
 
         if isinstance(value, DataFrame):
             value = value.reindex(index=self.major_axis,
@@ -449,8 +451,7 @@ class WidePanel(Panel, Groupable):
                              self.minor_axis)
 
     def __neg__(self):
-        return WidePanel(-self.values, self.items, self.major_axis,
-                          self.minor_axis)
+        return -1 * self
 
     def _combineFrame(self, other, func, axis=0):
         index, columns = self._get_plane_axes(axis)
@@ -470,6 +471,23 @@ class WidePanel(Panel, Groupable):
         return WidePanel(newValues, self.items, self.major_axis,
                          self.minor_axis)
 
+    def _combinePanel(self, other, func):
+        if isinstance(other, LongPanel):
+            other = other.to_wide()
+
+        items = self.items + other.items
+        major = self.major_axis + other.major_axis
+        minor = self.minor_axis + other.minor_axis
+
+        # could check that everything's the same size, but forget it
+
+        this = self.reindex(items=items, major=major, minor=minor)
+        other = other.reindex(items=items, major=major, minor=minor)
+
+        result_values = func(this.values, other.values)
+
+        return WidePanel(result_values, items, major, minor)
+
     def fill(self, value=None, method='pad'): # pragma: no cover
         warnings.warn("fill is being replaced by fillna, and the fill function "
                       "behavior will disappear in the next release: please "
@@ -504,7 +522,7 @@ class WidePanel(Panel, Groupable):
             for col, s in self.iteritems():
                 result[col] = s.fillna(method=method, value=value)
 
-            return WidePanel.fromDict(result)
+            return WidePanel.from_dict(result)
         else:
             # Float type values
             vals = self.values.copy()
@@ -513,23 +531,6 @@ class WidePanel(Panel, Groupable):
             return WidePanel(vals, self.items, self.major_axis,
                              self.minor_axis)
 
-    def _combinePanel(self, other, func):
-        if isinstance(other, LongPanel):
-            other = other.toWide()
-
-        items = self.items + other.items
-        major = self.major_axis + other.major_axis
-        minor = self.minor_axis + other.minor_axis
-
-        # could check that everything's the same size, but forget it
-
-        this = self.reindex(items=items, major=major, minor=minor)
-        other = other.reindex(items=items, major=major, minor=minor)
-
-        result_values = func(this.values, other.values)
-
-        return WidePanel(result_values, items, major, minor)
-
     add = _wide_arith_method(operator.add, 'add')
     subtract = _wide_arith_method(operator.sub, 'subtract')
     divide = _wide_arith_method(operator.div, 'divide')
@@ -625,7 +626,7 @@ class WidePanel(Panel, Groupable):
 
         return WidePanel(new_values, *new_axes)
 
-    def toLong(self, filter_observations=True):
+    def to_long(self, filter_observations=True):
         """
         Transform wide format into long (stacked) format
 
@@ -674,6 +675,8 @@ class WidePanel(Panel, Groupable):
 
         return LongPanel(values, self.items, index)
 
+    toLong = to_long
+
     def filter(self, items):
         """
         Restrict items in panel to input list
@@ -1217,9 +1220,9 @@ class LongPanel(Panel):
         -------
         y : LongPanel
         """
-        wide = self.toWide()
+        wide = self.to_wide()
         result = wide._combineFrame(other, func, axis=axis)
-        return result.toLong()
+        return result.to_long()
 
     def _combinePanel(self, other, func):
         """
@@ -1278,7 +1281,7 @@ class LongPanel(Panel):
         return LongPanel(new_values, self.items, new_index,
                          factors=new_factors)
 
-    def toWide(self):
+    def to_wide(self):
         """
         Transform long (stacked) format into wide format
 
@@ -1303,6 +1306,8 @@ class LongPanel(Panel):
 
         return WidePanel(values, self.items, self.major_axis, self.minor_axis)
 
+    toWide = to_wide
+
     def toCSV(self, path):
         def format_cols(items):
             cols = ['Major', 'Minor'] + list(items)
@@ -1988,7 +1993,7 @@ def pivot(index, columns, values):
 
         longPanel = LongPanel(valueMat, ['foo'], longIndex)
         longPanel = longPanel.sort()
-        return longPanel.toWide()['foo']
+        return longPanel.to_wide()['foo']
     except PanelError:
         return _slow_pivot(index, columns, values)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 88b7c931d..bdef633a8 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -176,6 +176,10 @@ class Series(np.ndarray, Picklable, Groupable):
 
         return subarr
 
+    # @property
+    # def _constructor(self):
+    #     return Series
+
     def __hash__(self):
         raise TypeError('unhashable type')
 
@@ -277,10 +281,9 @@ class Series(np.ndarray, Picklable, Groupable):
 
         # is there a case where this would NOT be an ndarray?
         # need to find an example, I took out the case for now
-
         dataSlice = values[key]
-        indices = Index(self.index.view(ndarray)[key])
-        return Series(dataSlice, index=indices)
+        new_index = Index(self.index.view(ndarray)[key])
+        return Series(dataSlice, index=new_index)
 
     def get(self, key, default=None):
         """
@@ -311,12 +314,9 @@ class Series(np.ndarray, Picklable, Groupable):
 
         The reason that the getslice returns copies is that otherwise you
         will have a reference to the original series which could be
-        inadvertently changed if the slice were altered (made mutable).
+        inadvertently changed
         """
-        newArr = self.values[i:j].copy()
-        newIndex = self.index[i:j]
-
-        return Series(newArr, index=newIndex)
+        return Series(self.values[i:j].copy(), index=self.index[i:j])
 
     def __setitem__(self, key, value):
         """
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 600a78164..ba6489e3d 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -3,7 +3,7 @@ Data structures for sparse float data. Life is made simpler by dealing only with
 float64 data
 """
 
-from numpy import nan
+from numpy import nan, ndarray
 import numpy as np
 
 import operator
@@ -214,6 +214,21 @@ class SparseSeries(Series):
         subarr.index = index
         return subarr
 
+    @property
+    def _constructor(self):
+        def make_sp_series(data, index=None):
+            return SparseSeries(data, index=index, fill_value=self.fill_value,
+                                kind=self.kind)
+
+        return make_sp_series
+
+    @property
+    def kind(self):
+        if isinstance(self.sp_index, BlockIndex):
+            return 'block'
+        elif isinstance(self.sp_index, IntIndex):
+            return 'integer'
+
     def __array_finalize__(self, obj):
         """
         Gets called after any ufunc or other array operations, necessary
@@ -223,6 +238,21 @@ class SparseSeries(Series):
         self.sp_index = getattr(obj, 'sp_index', None)
         self.fill_value = getattr(obj, 'fill_value', None)
 
+    # TODO
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(ndarray.__reduce__(self))
+        subclass_state = (self.index, )
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
+    def __setstate__(self, state):
+        """Necessary for making this object picklable"""
+        nd_state, own_state = state
+        ndarray.__setstate__(self, nd_state)
+        index, = own_state
+        self.index = index
+
     def __len__(self):
         return self.sp_index.length
 
@@ -247,9 +277,78 @@ class SparseSeries(Series):
     __idiv__ = __div__
     __ipow__ = __pow__
 
+    def __getitem__(self, key):
+        """
+
+        """
+        try:
+            return self._get_val_at(self.index.indexMap[key])
+
+        except KeyError:
+            if isinstance(key, (int, np.integer)):
+                return self._get_val_at(key)
+            raise Exception('Requested index not in this series!')
+
+        except TypeError:
+            # Could not hash item, must be array-like?
+            pass
+
+        # is there a case where this would NOT be an ndarray?
+        # need to find an example, I took out the case for now
+
+        dataSlice = self.values[key]
+        new_index = Index(self.index.view(ndarray)[key])
+        return self._constructor(dataSlice, index=new_index)
+
+    def _get_val_at(self, loc):
+        sp_loc = self.sp_index.lookup(loc)
+        if sp_loc == -1:
+            return self.fill_value
+        else:
+            return self.sp_values[sp_loc]
+
+    def __getslice__(self, i, j):
+        return self._constructor(self.values[i:j], index=self.index[i:j])
+
+    def get(self, key, default=None):
+        """
+        Returns value occupying requested index, default to specified
+        missing value if not present
+
+        Parameters
+        ----------
+        key : object
+            Index value looking for
+        default : object, optional
+            Value to return if key not in index
+
+        Returns
+        -------
+        y : scalar
+        """
+        if key in self.index:
+            return ndarray.__getitem__(self, self.index.indexMap[key])
+        else:
+            return default
+
+    def __setitem__(self, key, value):
+        """
+        If this series is mutable, set specified indices equal to given values.
+        """
+        try:
+            loc = self.index.indexMap[key]
+            ndarray.__setitem__(self, loc, value)
+        except Exception:
+            values = self.values
+            values[key] = value
+
+    def __setslice__(self, i, j, value):
+        """Set slice equal to given value(s)"""
+        ndarray.__setslice__(self, i, j, value)
+
     @property
     def values(self):
-        output = np.empty(self.sp_index.length, dtype=np.float64)
+        output = np.empty(len(self), dtype=np.float64)
         int_index = self.sp_index.to_int_index()
         output.fill(self.fill_value)
         output.put(int_index.indices, self)
@@ -306,7 +405,6 @@ class SparseSeries(Series):
         indexer, mask = self.index.get_indexer(new_index, method=method)
         new_values = values.take(indexer)
 
-        # TODO: always use NaN here?
         notmask = -mask
         if notmask.any():
             np.putmask(new_values, notmask, nan)
@@ -399,6 +497,11 @@ class SparseDataFrame(DataFrame):
         DataFrame.__init__(self, data, index=index, columns=columns,
                            dtype=None)
 
+    def __array_wrap__(self, result):
+        return SparseDataFrame(result, index=self.index, columns=self.columns,
+                               kind=self.default_kind,
+                               default_fill_value=self.default_fill_value)
+
     @property
     def _constructor(self):
         return SparseDataFrame
@@ -436,12 +539,23 @@ class SparseDataFrame(DataFrame):
 
         # TODO: figure out how to handle this case, all nan's?
         # add in any other columns we want to have (completeness)
+        nan_vec = np.empty(len(index))
+        nan_vec.fill(nan)
         for c in columns:
             if c not in sdict:
-                sdict[c] = sp_maker([])
+                sdict[c] = sp_maker(nan_vec)
 
         return sdict, columns, index
 
+    def copy(self):
+        """
+        Make a deep copy of this frame
+        """
+        return SparseDataFrame(self._series, index=self.index,
+                               columns=self.columns,
+                               default_fill_value=self.default_fill_value,
+                               kind=self.default_kind)
+
     def _insert_item(self, key, value):
         if hasattr(value, '__iter__'):
             if isinstance(value, Series):
@@ -449,7 +563,8 @@ class SparseDataFrame(DataFrame):
                 if not isinstance(value, SparseSeries):
                     cleanSeries = SparseSeries(cleanSeries)
             else:
-                cleanSeries = Series(value, index=self.index)
+                cleanSeries = SparseSeries(value, index=self.index,
+                                           fill_value=self.default_fill_value)
 
             self._series[key] = cleanSeries
         # Scalar
@@ -497,12 +612,196 @@ class SparseDataFrame(DataFrame):
 
         return SparseDataFrame(new_series, index=index, columns=self.columns)
 
-class SparsePanel(object):
+    def _reindex_columns(self, columns):
+        # TODO: fill value handling
+        sdict = dict((k, v) for k, v in self.iteritems() if k in columns)
+        return self._constructor(sdict, index=self.index, columns=columns)
+
+def stack_sparse_frame(frame, filter_observations=True):
     """
 
     """
+    I, N, K = self.dims
+
+    if filter_observations:
+        mask = np.isfinite(self.values).all(axis=0)
+        size = mask.sum()
+        selector = mask.ravel()
+    else:
+        size = N * K
+        selector = slice(None, None)
+
+    values = np.empty((size, I), dtype=float)
+
+    for i in xrange(len(self.items)):
+        values[:, i] = self.values[i].ravel()[selector]
+
+    major_labels = np.arange(N).repeat(K)[selector]
+
+    # Anyone think of a better way to do this? np.repeat does not
+    # do what I want
+    minor_labels = np.arange(K).reshape(1, K)[np.zeros(N, dtype=int)]
+    minor_labels = minor_labels.ravel()[selector]
 
+    if filter_observations:
+        mask = selector
+    else:
+        mask = None
+
+    index = LongPanelIndex(self.major_axis,
+                           self.minor_axis,
+                           major_labels,
+                           minor_labels,
+                           mask=mask)
+
+    return LongPanel(values, self.items, index)
+
+from pandas.core.panel import WidePanel
+
+class SparsePanel(WidePanel):
+    """
+
+    """
     def __init__(self, frames):
+        self.frames = frames
+        # self.items = Index(sorted(
+
+    def __getitem__(self, key):
+        """
+        """
+        pass
+
+    def __setitem__(self, key, value):
         pass
 
+    def __delitem__(self, key):
+        pass
+
+    def pop(self, key):
+        pass
+
+    #----------------------------------------------------------------------
+    # pickling
+
+    def __getstate__(self):
+        pass
+
+    def __setstate__(self, state):
+        pass
+
+    @property
+    def values(self):
+        """
+
+        """
+        pass
+
+    @classmethod
+    def from_dict(cls, data, intersect=False):
+        pass
+
+    def copy(self):
+        pass
+
+    def to_long(self):
+        pass
+
+    def reindex(self, major=None, items=None, minor=None, method=None):
+        result = self
+
+        if major is not None:
+            result = result._reindex_axis(major, method, 1)
+
+        if minor is not None:
+            result = result._reindex_axis(minor, method, 2)
+
+        if items is not None:
+            result = result._reindex_axis(items, method, 0)
+
+        if result is self:
+            raise ValueError('Must specify at least one axis')
+
+        return result
+
+    def _combine(self, other, func, axis=0):
+        if isinstance(other, DataFrame):
+            return self._combineFrame(other, func, axis=axis)
+        elif isinstance(other, Panel):
+            return self._combinePanel(other, func)
+        elif np.isscalar(other):
+            newValues = func(self.values, other)
+
+            return WidePanel(newValues, self.items, self.major_axis,
+                             self.minor_axis)
+
+    def _combineFrame(self, other, func, axis=0):
+        index, columns = self._get_plane_axes(axis)
+        axis = self._get_axis_number(axis)
+
+        other = other.reindex(index=index, columns=columns)
+
+        if axis == 0:
+            newValues = func(self.values, other.values)
+        elif axis == 1:
+            newValues = func(self.values.swapaxes(0, 1), other.values.T)
+            newValues = newValues.swapaxes(0, 1)
+        elif axis == 2:
+            newValues = func(self.values.swapaxes(0, 2), other.values)
+            newValues = newValues.swapaxes(0, 2)
+
+        return WidePanel(newValues, self.items, self.major_axis,
+                         self.minor_axis)
+
+    def _combinePanel(self, other, func):
+        if isinstance(other, LongPanel):
+            other = other.to_wide()
+
+        items = self.items + other.items
+        major = self.major_axis + other.major_axis
+        minor = self.minor_axis + other.minor_axis
+
+        # could check that everything's the same size, but forget it
+
+        this = self.reindex(items=items, major=major, minor=minor)
+        other = other.reindex(items=items, major=major, minor=minor)
+
+        result_values = func(this.values, other.values)
+
+        return WidePanel(result_values, items, major, minor)
+
+    def major_xs(self, key):
+        """
+        Parameters
+        ----------
+
+        Returns
+        -------
+        y : DataMatrix
+            index -> minor axis, columns -> items
+        """
+        try:
+            loc = self.major_axis.indexMap[key]
+        except KeyError:
+            raise KeyError('%s not contained in major axis!' % key)
+
+        mat = np.array(self.values[:, loc, :].T)
+        return DataMatrix(mat, index=self.minor_axis, columns=self.items)
+
+    def minor_xs(self, key):
+        """
+        Parameters
+        ----------
+
+        Returns
+        -------
+        y : DataMatrix
+            index -> major axis, columns -> items
+        """
+        try:
+            loc = self.minor_axis.indexMap[key]
+        except KeyError:
+            raise KeyError('%s not contained in minor axis!' % key)
+
+        mat = np.array(self.values[:, :, loc].T)
+        return DataMatrix(mat, index=self.major_axis, columns=self.items)
 
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index bad824198..94beff3fc 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1696,5 +1696,7 @@ class TestDataFrame(unittest.TestCase):
         desc = self.frame.describe()
 
 if __name__ == '__main__':
-    unittest.main()
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
 
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index 317e66dd4..e06ecbe57 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -6,7 +6,8 @@ import operator
 from numpy import nan
 import numpy as np
 
-from pandas.util.testing import assert_almost_equal, assert_series_equal
+from pandas.util.testing import (assert_almost_equal, assert_series_equal,
+                                 assert_frame_equal)
 from numpy.testing import assert_equal
 
 from pandas import DataFrame, DateRange
@@ -194,7 +195,30 @@ class TestSparseSeries(TestCase):
         self.assert_(self.bseries.sp_values[0] != 97)
 
     def test_getitem(self):
-        pass
+        def _check_indexing(sp, dense):
+            for idx, val in dense.iteritems():
+                assert_almost_equal(val, sp[idx])
+
+            for i in xrange(len(dense)):
+                assert_almost_equal(sp[i], dense[i])
+
+        _check_indexing(self.bseries, self.bseries.to_dense())
+        _check_indexing(self.zbseries, self.zbseries.to_dense())
+        _check_indexing(self.iseries, self.iseries.to_dense())
+        _check_indexing(self.ziseries, self.ziseries.to_dense())
+
+    def test_getitem_fancy_index(self):
+        idx = self.bseries.index
+        res = self.bseries[::2]
+        self.assert_(isinstance(res, SparseSeries))
+        assert_sp_series_equal(res, self.bseries.reindex(idx[::2]))
+
+        res = self.bseries[:5]
+        self.assert_(isinstance(res, SparseSeries))
+        assert_sp_series_equal(res, self.bseries.reindex(idx[:5]))
+
+        res = self.bseries[5:]
+        assert_sp_series_equal(res, self.bseries.reindex(idx[5:]))
 
     def test_setitem(self):
         pass
@@ -337,6 +361,8 @@ class TestSparseDataFrame(TestCase):
         self.dates = DateRange('1/1/2011', periods=10)
 
         self.frame = SparseDataFrame(self.data, index=self.dates)
+        self.iframe = SparseDataFrame(self.data, index=self.dates,
+                                      kind='integer')
 
         values = self.frame.values.copy()
         values[np.isnan(values)] = 0
@@ -345,10 +371,39 @@ class TestSparseDataFrame(TestCase):
                                       default_fill_value=0,
                                       index=self.dates)
 
+        values = self.frame.values.copy()
+        values[np.isnan(values)] = 2
+        self.fill_frame = SparseDataFrame(values, columns=['A', 'B', 'C', 'D'],
+                                          default_fill_value=2,
+                                          index=self.dates)
+
+    def test_copy(self):
+        cp = self.frame.copy()
+        self.assert_(isinstance(cp, SparseDataFrame))
+        assert_sp_frame_equal(cp, self.frame)
+        self.assert_(cp.index is self.frame.index)
+
+        # TODO: Test that DATA is copied!
+
     def test_constructor(self):
         for col, series in self.frame.iteritems():
             self.assert_(isinstance(series, SparseSeries))
 
+        self.assert_(isinstance(self.iframe['A'].sp_index, IntIndex))
+
+        # construct from nested dict
+        data = {}
+        for c, s in self.frame.iteritems():
+            data[c] = s.toDict()
+
+        sdf = SparseDataFrame(data)
+        assert_sp_frame_equal(sdf, self.frame)
+
+    def test_array_interface(self):
+        res = np.sqrt(self.frame)
+        dres = np.sqrt(self.frame.to_dense())
+        assert_frame_equal(res.to_dense(), dres)
+
     def test_dense_to_sparse(self):
         df = DataFrame({'A' : [nan, nan, nan, 1, 2],
                         'B' : [1, 2, nan, nan, nan]})
@@ -371,49 +426,98 @@ class TestSparseDataFrame(TestCase):
         pass
 
     def test_sparse_series_ops(self):
-        def _compare_to_dense(a, b, op, fill=np.NaN):
+        self._check_frame_ops(self.frame)
+        self._check_frame_ops(self.iframe)
+
+        self._check_frame_ops(self.zframe)
+        self._check_frame_ops(self.fill_frame)
+
+    def _check_frame_ops(self, frame):
+        def _compare_to_dense(a, b, da, db, op, fill=np.NaN):
             sparse_result = op(a, b)
-            dense_result = op(a.to_dense(), b.to_dense())
+            dense_result = op(da, db)
             dense_result = dense_result.to_sparse(fill_value=fill)
             assert_sp_frame_equal(sparse_result, dense_result,
                                   exact_indices=False)
 
-        def _compare_to_dense_rev(a, b, op):
-            sparse_result = op(b, a)
-            dense_result = op(b.to_dense(), a.to_dense())
-            dense_result = dense_result.to_sparse(fill_value=a.fill_value)
-            assert_sp_frame_equal(sparse_result, dense_result,
-                                  exact_indices=False)
-
         opnames = ['add', 'sub', 'mul', 'div']
         ops = [getattr(operator, name) for name in opnames]
 
-        fidx = self.frame.index
+        fidx = frame.index
 
         # time series operations
 
-        series = [self.frame['A'],
-                  self.frame['B'],
-                  self.frame['C'],
-                  self.frame['D'],
-                  self.frame['A'].reindex(fidx[:7]),
-                  self.frame['A'].reindex(fidx[::2])]
+        series = [frame['A'], frame['B'],
+                  frame['C'], frame['D'],
+                  frame['A'].reindex(fidx[:7]),
+                  frame['A'].reindex(fidx[::2]),
+                  SparseSeries([], index=[])]
 
         for op in ops:
             for s in series:
-                _compare_to_dense(self.frame, s, op)
-                _compare_to_dense(s, self.frame, op)
+                _compare_to_dense(frame, s, frame.to_dense(),
+                                  s.to_dense(), op)
+                _compare_to_dense(s, frame, s.to_dense(),
+                                  frame.to_dense(), op)
 
         # cross-sectional operations
+        series = [frame.xs(fidx[0]),
+                  frame.xs(fidx[3]),
+                  frame.xs(fidx[5]),
+                  frame.xs(fidx[7]),
+                  frame.xs(fidx[5])[:2]]
 
-
-        # TODO: fill value consistency?
+        for op in ops:
+            for s in series:
+                _compare_to_dense(frame, s, frame.to_dense(),
+                                  s, op)
+                _compare_to_dense(s, frame, s,
+                                  frame.to_dense(), op)
 
     def test_scalar_ops(self):
         pass
 
+    def test_insert_col(self):
+        sdf = self.frame.copy()
+
+        # insert SparseSeries
+        sdf['E'] = sdf['A']
+        self.assert_(isinstance(sdf['E'], SparseSeries))
+        assert_sp_series_equal(sdf['E'], sdf['A'])
+
+        # TODO insert SparseSeries differently-indexed
+        sdf['E'] = sdf['A'][::2]
+
+        # insert Series
+        sdf['F'] = sdf['A'].to_dense()
+        self.assert_(isinstance(sdf['F'], SparseSeries))
+        assert_sp_series_equal(sdf['F'], sdf['A'])
+
+        # insert Series differently-indexed
+
+        # insert ndarray
+
+        # insert ndarray wrong size
+
+
+    def test_corr(self):
+        res = self.frame.corr()
+        self.assert_(isinstance(res, SparseDataFrame))
+        assert_frame_equal(res.to_dense(), self.frame.to_dense().corr())
+
+    def test_reindex(self):
+        # propagate CORRECT fill value
+
+        pass
+
+class TestSparseWidePanel(TestCase):
+    pass
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
 
+    # nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure',
+    #                      '--with-profile'],
+    #                exit=False)
diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index e8c3dacd5..74c60599d 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -24,7 +24,10 @@ cdef inline float64_t __sub(float64_t a, float64_t b):
     return a - b
 cdef inline float64_t __div(float64_t a, float64_t b):
     if b == 0:
-        return INF
+        if a >= 0:
+            return INF
+        else:
+            return -INF
     else:
         return a / b
 
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index e1125982c..8235690a9 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -103,7 +103,7 @@ def assert_dict_equal(a, b, compare_keys=True):
 
 def assert_series_equal(left, right):
     assert_almost_equal(left, right)
-    assert(np.array_equal(left.index, right.index))
+    assert(left.index.equals(right.index))
 
 def assert_frame_equal(left, right):
     for col, series in left.iteritems():

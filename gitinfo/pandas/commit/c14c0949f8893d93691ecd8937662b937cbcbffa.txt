commit c14c0949f8893d93691ecd8937662b937cbcbffa
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jun 1 16:23:06 2012 -0400

    ENH: implement cut function for turning continuous variable into categorical variable, close #415

diff --git a/RELEASE.rst b/RELEASE.rst
index 5c3d0814e..8bebb16c5 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -78,6 +78,8 @@ pandas 0.8.0
   - Add ``method`` argument to ``align`` method for forward/backward fillin
     (#216)
   - Add Panel.transpose method for rearranging axes (#695)
+  - Add new ``cut`` function (patterned after R) for discretizing data into
+    equal range-length bins or arbitrary breaks of your choosing (#415)
 
 **Improvements to existing features**
 
diff --git a/doc/source/whatsnew/v0.8.0.txt b/doc/source/whatsnew/v0.8.0.txt
index 3d6b85ae9..cf5a9953a 100644
--- a/doc/source/whatsnew/v0.8.0.txt
+++ b/doc/source/whatsnew/v0.8.0.txt
@@ -101,6 +101,8 @@ index duplication in many-to-many joins)
 Other new features
 ~~~~~~~~~~~~~~~~~~
 
+- New ``cut`` function (like R's cut function) for computing a categorical
+  variable from a continuous variable by binning values
 - Add limit argument to fillna/reindex
 - More flexible multiple function application in GroupBy, and can pass list
   (name, function) tuples to get result in particular order with given names
diff --git a/pandas/__init__.py b/pandas/__init__.py
index a265ad3ce..da754c4cc 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -32,7 +32,8 @@ from pandas.io.parsers import (read_csv, read_table, read_clipboard,
 from pandas.io.pytables import HDFStore
 from pandas.util.testing import debug
 
+from pandas.tools.describe import value_range
 from pandas.tools.merge import merge, concat, ordered_merge
 from pandas.tools.pivot import pivot_table, crosstab
 from pandas.tools.plotting import scatter_matrix
-from pandas.tools.describe import value_range
+from pandas.tools.tile import cut
diff --git a/pandas/tools/tests/test_tile.py b/pandas/tools/tests/test_tile.py
index 8982b7a6d..bdbc201fa 100644
--- a/pandas/tools/tests/test_tile.py
+++ b/pandas/tools/tests/test_tile.py
@@ -3,14 +3,88 @@ import unittest
 
 import numpy as np
 
-from pandas import DataFrame, Series
+from pandas import DataFrame, Series, unique
 import pandas.util.testing as tm
+import pandas.core.common as com
 
 from pandas.tools.tile import cut
 
+from numpy.testing import assert_equal, assert_almost_equal
+
+class TestCut(unittest.TestCase):
+
+    def test_simple(self):
+        data = np.ones(5)
+        result = cut(data, 4, labels=False)
+        desired = [2, 2, 2, 2, 2]
+        assert_equal(result, desired)
+
+    def test_bins(self):
+        data = np.array([.2, 1.4, 2.5, 6.2, 9.7, 2.1])
+        result, bins = cut(data, 3, labels=False, retbins=True)
+        assert_equal(result, [1, 1, 1, 2, 3, 1])
+        assert_almost_equal(bins, [ 0.1905, 3.36666667, 6.53333333, 9.7])
+
+    def test_right(self):
+        data = np.array([.2, 1.4, 2.5, 6.2, 9.7, 2.1, 2.575])
+        result, bins = cut(data, 4, right=True, labels=False, retbins=True)
+        assert_equal(result, [1, 1, 1, 3, 4, 1, 1])
+        assert_almost_equal(bins, [0.1905, 2.575, 4.95, 7.325, 9.7])
+
+    def test_noright(self):
+        data = np.array([.2, 1.4, 2.5, 6.2, 9.7, 2.1, 2.575])
+        result, bins = cut(data, 4, right=False, labels=False, retbins=True)
+        assert_equal(result, [1, 1, 1, 3, 4, 1, 2])
+        assert_almost_equal(bins, [ 0.2, 2.575, 4.95, 7.325, 9.7095])
+
+    def test_arraylike(self):
+        data = [.2, 1.4, 2.5, 6.2, 9.7, 2.1]
+        result, bins = cut(data, 3, labels=False, retbins=True)
+        assert_equal(result, [1, 1, 1, 2, 3, 1])
+        assert_almost_equal(bins, [ 0.1905, 3.36666667, 6.53333333, 9.7])
+
+    def test_bins_not_monotonic(self):
+        data = [.2, 1.4, 2.5, 6.2, 9.7, 2.1]
+        self.assertRaises(ValueError, cut, data, [0.1, 1.5, 1, 10])
+
+    def test_labels(self):
+        arr = np.tile(np.arange(0, 1.01, 0.1), 4)
+
+        labels, bins = cut(arr, 4, retbins=True)
+        distinct_labels = sorted(unique(labels))
+        ex_labels = ['(-0.001, 0.25]', '(0.25, 0.5]', '(0.5, 0.75]',
+                     '(0.75, 1]']
+        self.assertEqual(distinct_labels, ex_labels)
+
+        labels, bins = cut(arr, 4, retbins=True, right=False)
+        distinct_labels = sorted(unique(labels))
+        ex_labels = ['[0, 0.25)', '[0.25, 0.5)', '[0.5, 0.75)',
+                     '[0.75, 1.001)']
+        self.assertEqual(distinct_labels, ex_labels)
+
+    def test_label_precision(self):
+        arr = np.arange(0, 0.75, 0.01)
+
+        labels = cut(arr, 4, precision=2)
+        distinct_labels = sorted(unique(labels))
+        ex_labels = ['(-0.00074, 0.18]', '(0.18, 0.37]', '(0.37, 0.55]',
+                     '(0.55, 0.74]']
+        self.assertEqual(distinct_labels, ex_labels)
+
+    def test_na_handling(self):
+        arr = np.arange(0, 0.75, 0.01)
+        arr[::3] = np.nan
+
+        labels = cut(arr, 4)
+        ex_labels = np.where(com.isnull(arr), np.nan, labels)
+
+        tm.assert_almost_equal(labels, ex_labels)
+
+        labels = cut(arr, 4, labels=False)
+        ex_labels = np.where(com.isnull(arr), np.nan, labels)
+        tm.assert_almost_equal(labels, ex_labels)
 
 if __name__ == '__main__':
-    import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
 
diff --git a/pandas/tools/tile.py b/pandas/tools/tile.py
index ba1bf98e8..e4a92ad1e 100644
--- a/pandas/tools/tile.py
+++ b/pandas/tools/tile.py
@@ -2,37 +2,159 @@
 Quantilization functions and related stuff
 """
 
-import numpy as np
+from pandas.core.api import DataFrame, Series
+import pandas.core.common as com
+import pandas.core.nanops as nanops
 
+import numpy as np
 
-def cut(data, bins, closed='right', labels=None,
-        precision=3):
+def cut(x, bins, right=True, labels=None, retbins=False, precision=3):
     """
+    Return indices of half-open bins to which each value of `x` belongs.
 
     Parameters
     ----------
-    data : Series or ndarray
-    bins : array or integer
-        Integer number of bins (equal-size) or array of break points
-    closed : {'right', 'left'}, default 'right'
-        Side of half-open interval which is closed
-    precision : integer, default 3
-
+    x : array-like
+        Input array to be binned. It has to be 1-dimensional.
+    bins : int or sequence of scalars
+        If `bins` is an int, it defines the number of equal-width bins in the
+        range of `x`. However, in this case, the range of `x` is extended
+        by .1% on each side to include the min or max values of `x`. If
+        `bins` is a sequence it defines the bin edges allowing for
+        non-uniform bin width. No extension of the range of `x` is done in
+        this case.
+    right : bool, optional
+        Indicates whether the bins include the rightmost edge or not. If
+        right == True (the default), then the bins [1,2,3,4] indicate
+        (1,2], (2,3], (3,4].
+    labels : array or boolean, default None
+        Labels to use for bin edges, or False to return integer bin labels
+    retbins : bool, optional
+        Whether to return the bins or not. Can be useful if bins is given
+        as a scalar.
 
+    Returns
+    -------
+    out : ndarray of labels
+        Same shape as `x`. Array of strings by default, integers if
+        labels=False
+    bins : ndarray of floats
+        Returned only if `retbins` is True.
+
+    Notes
+    -----
+    The `cut` function can be useful for going from a continuous variable to
+    a categorical variable. For example, `cut` could convert ages to groups
+    of age ranges.
+
+    Examples
+    --------
+    >>> cut(np.array([.2, 1.4, 2.5, 6.2, 9.7, 2.1]), 3, retbins=True)
+    (array([(0.191, 3.367], (0.191, 3.367], (0.191, 3.367], (3.367, 6.533],
+           (6.533, 9.7], (0.191, 3.367]], dtype=object),
+     array([ 0.1905    ,  3.36666667,  6.53333333,  9.7       ]))
+    >>> cut(np.ones(5), 4, labels=False)
+    array([2, 2, 2, 2, 2])
     """
-    bins = np.asarray(bins)
-    labels = bins.searchsorted(data.values, side=closed)
+    #NOTE: this binning code is changed a bit from histogram for var(x) == 0
+    if not np.iterable(bins):
+        if np.isscalar(bins) and bins < 1:
+            raise ValueError("`bins` should be a positive integer.")
+        try: # for array-like
+            sz = x.size
+        except AttributeError:
+            x = np.asarray(x)
+            sz = x.size
+        if sz == 0:
+            # handle empty arrays. Can't determine range, so use 0-1.
+            rng = (0, 1)
+        else:
+            rng = (nanops.nanmin(x), nanops.nanmax(x))
+        mn, mx = [mi + 0.0 for mi in rng]
+
+        if mn == mx: # adjust end points before binning
+            mn -= .001 * mn
+            mx += .001 * mx
+            bins = np.linspace(mn, mx, bins+1, endpoint=True)
+        else: # adjust end points after binning
+            bins = np.linspace(mn, mx, bins+1, endpoint=True)
+            adj = (mx - mn) * 0.001 # 0.1% of the range
+            if right:
+                bins[0] -= adj
+            else:
+                bins[-1] += adj
+
+    else:
+        bins = np.asarray(bins)
+        if (np.diff(bins) < 0).any():
+            raise ValueError('bins must increase monotonically.')
+
+    side = 'left' if right else 'right'
+    ids = bins.searchsorted(x, side=side)
 
-    if labels is None or labels is not False:
-        if closed == 'left':
-            strings = ['[%s, %s)' % tup for tup in zip(bins, bins[1:])]
+    mask = com.isnull(x)
+    has_nas = mask.any()
+
+
+    if labels is not False:
+        if labels is None:
+            labels = bins
+        else:
+            if len(labels) != len(bins):
+                raise ValueError('labels must be same length as bins')
+
+        fmt = lambda v: _format_label(v, precision=precision)
+        if right:
+            strings = ['(%s, %s]' % (fmt(x), fmt(y))
+                       for x, y in zip(labels, labels[1:])]
         else:
-            strings = ['(%s, %s]' % tup for tup in zip(bins, bins[1:])]
+            strings = ['[%s, %s)' % (fmt(x), fmt(y))
+                       for x, y in zip(labels, labels[1:])]
+
         strings = np.asarray(strings, dtype=object)
-        return strings.take(labels - 1)
 
-    return labels, data.values
+        if has_nas:
+            np.putmask(ids, mask, 0)
 
+        labels = com.take_1d(strings, ids - 1)
+    else:
+        labels = ids
+        if has_nas:
+            labels = labels.astype(np.float64)
+            np.putmask(labels, mask, np.nan)
+
+    if not retbins:
+        return labels
+
+    return labels, bins
+
+def _format_label(x, precision=3):
+    fmt_str = '%%.%dg' % precision
+    if com.is_float(x):
+        frac, whole = np.modf(x)
+        sgn = '-' if x < 0 else ''
+        whole = abs(whole)
+        if frac != 0.0:
+            val = fmt_str % frac
+            if 'e' in val:
+                return _trim_zeros(fmt_str % x)
+            else:
+                val = _trim_zeros(val)
+                if '.' in val:
+                    return sgn + '.'.join(('%d' % whole, val.split('.')[1]))
+                else:
+                    return sgn + '.'.join(('%d' % whole, val))
+        else:
+            return sgn + '%d' % whole
+    else:
+        return str(x)
+
+def _trim_zeros(x):
+    while len(x) > 1 and x[-1] == '0':
+        x = x[:-1]
+    if len(x) > 1 and x[-1] == '.':
+        x = x[:-1]
+    return x
 
 def bucket(series, k, by=None):
     """

commit 56051cf6a0ce2d0cc468eccf22dc2316819aeb92
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat May 12 12:02:58 2012 -0400

    REF: remove period multipliers, close #1199

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 3e4db56e4..c481d7a02 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1233,7 +1233,7 @@ cdef inline int64_t remove_mult(int64_t period_ord_w_mult, int64_t mult):
 
     return period_ord_w_mult * mult + 1;
 
-def dt64arr_to_periodarr(ndarray[int64_t] dtarr, int freq, int64_t mult):
+def dt64arr_to_periodarr(ndarray[int64_t] dtarr, int freq):
     """
     Convert array of datetime64 values (passed in as 'i8' dtype) to a set of
     periods corresponding to desired frequency, per period convention.
@@ -1251,10 +1251,9 @@ def dt64arr_to_periodarr(ndarray[int64_t] dtarr, int freq, int64_t mult):
         PyArray_DatetimeToDatetimeStruct(dtarr[i], NPY_FR_us, &dts)
         out[i] = get_period_ordinal(dts.year, dts.month, dts.day,
                                   dts.hour, dts.min, dts.sec, freq)
-        out[i] = apply_mult(out[i], mult)
     return out
 
-def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int freq, int64_t mult):
+def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int freq):
     """
     Convert array to datetime64 values from a set of ordinals corresponding to
     periods per period convention.
@@ -1268,15 +1267,15 @@ def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int freq, int64_t mult):
     out = np.empty(l, dtype='i8')
 
     for i in range(l):
-        out[i] = period_ordinal_to_dt64(periodarr[i], freq, mult)
+        out[i] = period_ordinal_to_dt64(periodarr[i], freq)
 
     return out
 
 cdef char START = 'S'
 cdef char END = 'E'
 
-cpdef int64_t period_asfreq(int64_t period_ordinal, int freq1, int64_t mult1,
-                            int freq2, int64_t mult2, bint end):
+cpdef int64_t period_asfreq(int64_t period_ordinal, int freq1, int freq2,
+                            bint end):
     """
     Convert period ordinal from one frequency to another, and if upsampling,
     choose to use start ('S') or end ('E') of period.
@@ -1284,24 +1283,17 @@ cpdef int64_t period_asfreq(int64_t period_ordinal, int freq1, int64_t mult1,
     cdef:
         int64_t retval
 
-    period_ordinal = remove_mult(period_ordinal, mult1)
-
-    if mult1 != 1 and end:
-        period_ordinal += (mult1 - 1)
-
     if end:
         retval = asfreq(period_ordinal, freq1, freq2, END)
     else:
         retval = asfreq(period_ordinal, freq1, freq2, START)
-    retval = apply_mult(retval, mult2)
 
     if retval == INT32_MIN:
         raise ValueError('Frequency conversion failed')
 
     return retval
 
-def period_asfreq_arr(ndarray[int64_t] arr, int freq1, int64_t mult1,
-                      int freq2, int64_t mult2, bint end):
+def period_asfreq_arr(ndarray[int64_t] arr, int freq1, int freq2, bint end):
     """
     Convert int64-array of period ordinals from one frequency to another, and
     if upsampling, choose to use start ('S') or end ('E') of period.
@@ -1326,32 +1318,25 @@ def period_asfreq_arr(ndarray[int64_t] arr, int freq1, int64_t mult1,
         relation = START
 
     for i in range(n):
-        ordinal = remove_mult(arr[i], mult1)
         val = func(arr[i], relation, &finfo)
         if val == -1:
             raise ValueError("Unable to convert to desired frequency.")
-        result[i] = apply_mult(val, mult2)
+        result[i] = val
 
     return result
 
-def period_ordinal(int y, int m, int d, int h, int min, int s,
-                   int freq, int64_t mult):
+def period_ordinal(int y, int m, int d, int h, int min, int s, int freq):
     cdef:
         int64_t ordinal
 
-    ordinal = get_period_ordinal(y, m, d, h, min, s, freq)
+    return get_period_ordinal(y, m, d, h, min, s, freq)
 
-    return apply_mult(ordinal, mult)
 
-cpdef int64_t period_ordinal_to_dt64(int64_t period_ordinal, int freq,
-                                     int64_t mult):
+cpdef int64_t period_ordinal_to_dt64(int64_t ordinal, int freq):
     cdef:
-        int64_t ordinal
         npy_datetimestruct dts
         date_info dinfo
 
-    ordinal = remove_mult(period_ordinal, mult)
-
     get_date_info(ordinal, freq, &dinfo)
 
     dts.year = dinfo.year
@@ -1364,22 +1349,21 @@ cpdef int64_t period_ordinal_to_dt64(int64_t period_ordinal, int freq,
 
     return PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
 
-def period_ordinal_to_string(int64_t value, int freq, int64_t mult):
+def period_ordinal_to_string(int64_t value, int freq):
     cdef:
         char *ptr
 
-    ptr = period_to_string(remove_mult(value, mult), freq)
+    ptr = period_to_string(value, freq)
 
     if ptr == NULL:
         raise ValueError("Could not create string from ordinal '%s'" % value)
 
     return <object> ptr
 
-def period_strftime(int64_t value, int freq, int64_t mult, object fmt):
+def period_strftime(int64_t value, int freq, object fmt):
     cdef:
         char *ptr
 
-    value = remove_mult(value, mult)
     ptr = period_to_string2(value, freq, <char*>fmt)
 
     if ptr == NULL:
@@ -1391,13 +1375,11 @@ def period_strftime(int64_t value, int freq, int64_t mult, object fmt):
 
 ctypedef int (*accessor)(int64_t ordinal, int freq) except INT32_MIN
 
-def get_period_field(int code, int64_t value, int freq,
-                     int64_t mult):
+def get_period_field(int code, int64_t value, int freq):
     cdef accessor f = _get_accessor_func(code)
-    return f(remove_mult(value, mult), freq)
+    return f(value, freq)
 
-def get_period_field_arr(int code, ndarray[int64_t] arr,
-                         int freq, int64_t mult):
+def get_period_field_arr(int code, ndarray[int64_t] arr, int freq):
     cdef:
         Py_ssize_t i, sz
         ndarray[int64_t] out
@@ -1409,7 +1391,7 @@ def get_period_field_arr(int code, ndarray[int64_t] arr,
     out = np.empty(sz, dtype=np.int64)
 
     for i in range(sz):
-        out[i] = f(remove_mult(arr[i], mult), freq)
+        out[i] = f(arr[i], freq)
 
     return out
 
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index e55570086..705d66d84 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -68,7 +68,7 @@ def get_freq_code(freqstr):
     return code, stride
 
 
-def _get_freq_str(base, mult):
+def _get_freq_str(base, mult=1):
     code = _reverse_period_code_map.get(base)
     if code is None:
         return _unknown_freq
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 11dc22cf0..3d7f730af 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -24,7 +24,7 @@ def _period_field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        return lib.get_period_field(alias, self.ordinal, base, mult)
+        return lib.get_period_field(alias, self.ordinal, base)
     f.__name__ = name
     return property(f)
 
@@ -33,7 +33,7 @@ def _field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        return lib.get_period_field_arr(alias, self.values, base, mult)
+        return lib.get_period_field_arr(alias, self.values, base)
     f.__name__ = name
     return property(f)
 
@@ -108,6 +108,8 @@ class Period(object):
                 raise ValueError("If value is None, year cannot be None")
 
             base, mult = _gfc(freq)
+            if mult != 1:
+                raise ValueError('Only mult == 1 supported')
 
             if quarter is not None:
                 mnum = _month_numbers[_freq_mod._get_rule_month(freq)] + 1
@@ -116,7 +118,7 @@ class Period(object):
                     year -= 1
 
             self.ordinal = lib.period_ordinal(year, month, day, hour, minute,
-                                            second, base, mult)
+                                              second, base)
 
         elif isinstance(value, Period):
             other = value
@@ -163,12 +165,15 @@ class Period(object):
             raise ValueError(msg)
 
         base, mult = _gfc(freq)
+        if mult != 1:
+            raise ValueError('Only mult == 1 supported')
 
         if self.ordinal is None:
-            self.ordinal = lib.period_ordinal(dt.year, dt.month, dt.day, dt.hour,
-                                            dt.minute, dt.second, base, mult)
+            self.ordinal = lib.period_ordinal(dt.year, dt.month, dt.day,
+                                              dt.hour, dt.minute, dt.second,
+                                              base)
 
-        self.freq = _freq_mod._get_freq_str(base, mult)
+        self.freq = _freq_mod._get_freq_str(base)
 
     def __eq__(self, other):
         if isinstance(other, Period):
@@ -210,14 +215,16 @@ class Period(object):
         base1, mult1 = _gfc(self.freq)
         base2, mult2 = _gfc(freq)
 
+        if mult2 != 1:
+            raise ValueError('Only mult == 1 supported')
+
         if how not in ('S', 'E'):
             raise ValueError('relation argument must be one of S or E')
 
         end = how == 'E'
-        new_ordinal = lib.period_asfreq(self.ordinal, base1, mult1,
-                                        base2, mult2, end)
+        new_ordinal = lib.period_asfreq(self.ordinal, base1, base2, end)
 
-        return Period(ordinal=new_ordinal, freq=(base2, mult2))
+        return Period(ordinal=new_ordinal, freq=base2)
 
     @property
     def start_time(self):
@@ -250,7 +257,11 @@ class Period(object):
         else:
             base, mult = _gfc(freq)
             new_val = self.asfreq(freq, how)
-        dt64 = lib.period_ordinal_to_dt64(new_val.ordinal, base, mult)
+
+        if mult != 1:
+            raise ValueError('Only mult == 1 supported')
+
+        dt64 = lib.period_ordinal_to_dt64(new_val.ordinal, base)
         ts_freq = _period_rule_to_timestamp_rule(new_val.freq, how=how)
         return Timestamp(dt64, offset=to_offset(ts_freq))
 
@@ -274,15 +285,13 @@ class Period(object):
 
     def __repr__(self):
         base, mult = _gfc(self.freq)
-        formatted = lib.period_ordinal_to_string(self.ordinal, base, mult)
+        formatted = lib.period_ordinal_to_string(self.ordinal, base)
         freqstr = _freq_mod._reverse_period_code_map[base]
-        if mult == 1:
-            return "Period('%s', '%s')" % (formatted, freqstr)
-        return ("Period('%s', '%d%s')" % (formatted, mult, freqstr))
+        return "Period('%s', '%s')" % (formatted, freqstr)
 
     def __str__(self):
         base, mult = _gfc(self.freq)
-        formatted = lib.period_ordinal_to_string(self.ordinal, base, mult)
+        formatted = lib.period_ordinal_to_string(self.ordinal, base)
         return ("%s" % formatted)
 
     def strftime(self, fmt):
@@ -424,9 +433,9 @@ class Period(object):
         """
         base, mult = _gfc(self.freq)
         if fmt is not None:
-            return lib.period_strftime(self.ordinal, base, mult, fmt)
+            return lib.period_strftime(self.ordinal, base, fmt)
         else:
-            return lib.period_ordinal_to_string(self.ordinal, base, mult)
+            return lib.period_ordinal_to_string(self.ordinal, base)
 
 def _period_unbox(key, check=None):
     '''
@@ -465,7 +474,7 @@ def dt64arr_to_periodarr(data, freq):
     else:
         base, mult = freq
 
-    return lib.dt64arr_to_periodarr(data.view('i8'), base, mult)
+    return lib.dt64arr_to_periodarr(data.view('i8'), base)
 
 # --- Period index sketch
 
@@ -589,8 +598,7 @@ class PeriodIndex(Int64Index):
                 else:
                     base1, mult1 = _gfc(data.freq)
                     base2, mult2 = _gfc(freq)
-                    data = lib.period_asfreq_arr(data.values, base1, mult1,
-                                                 base2, mult2, 1)
+                    data = lib.period_asfreq_arr(data.values, base1, base2, 1)
             else:
                 if freq is None and len(data) > 0:
                     freq = getattr(data[0], 'freq')
@@ -664,12 +672,14 @@ class PeriodIndex(Int64Index):
         else:
             base2, mult2 = freq
 
+        if mult2 != 1:
+            raise ValueError('Only mult == 1 supported')
+
         if how not in ('S', 'E'):
             raise ValueError('relation argument must be one of S or E')
 
         end = how == 'E'
-        new_data = lib.period_asfreq_arr(self.values, base1, mult1,
-                                         base2, mult2, end)
+        new_data = lib.period_asfreq_arr(self.values, base1, base2, end)
 
         result = new_data.view(PeriodIndex)
         result.name = self.name
@@ -719,12 +729,14 @@ class PeriodIndex(Int64Index):
         if freq is None:
             base, mult = _gfc(self.freq)
             new_data = self
-            # freq = self.freq
         else:
             base, mult = _gfc(freq)
             new_data = self.asfreq(freq, how)
-            # freq = 'infer'
-        new_data = lib.periodarr_to_dt64arr(new_data.values, base, mult)
+
+        if mult != 1:
+            raise ValueError('Only mult == 1 supported')
+
+        new_data = lib.periodarr_to_dt64arr(new_data.values, base)
         return DatetimeIndex(new_data, freq='infer')
 
     def shift(self, n):
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 92441661a..7b2230d57 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -153,9 +153,6 @@ class TestPeriodProperties(TestCase):
         i1 = Period('1982', freq='Min')
         self.assert_(i1.freq[0] != '1')
 
-        i2 = Period('11/30/2005', freq='2Q')
-        self.assertEquals(i2.freq[0], '2')
-
     def test_to_timestamp(self):
         p = Period('1982', freq='A')
         start_ts = p.to_timestamp(how='S')
@@ -1304,6 +1301,14 @@ class TestPeriodIndex(TestCase):
             result = stamps.to_period(freq)
             self.assert_(rng.equals(result))
 
+    def test_no_multiples(self):
+        self.assertRaises(ValueError, period_range, '1989Q3', periods=10,
+                          freq='2Q')
+
+        self.assertRaises(ValueError, period_range, '1989', periods=10,
+                          freq='2A')
+        self.assertRaises(ValueError, Period, '1989', freq='2A')
+
     # def test_iindex_multiples(self):
     #     ii = PeriodIndex(start='1/1/10', end='12/31/12', freq='2M')
     #     self.assertEquals(ii[0], Period('1/1/10', '2M'))

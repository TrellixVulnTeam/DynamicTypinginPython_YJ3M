commit 074afbc63d236de9520a9ff323c1b330dfa089e3
Author: Chang She <chang@lambdafoundry.com>
Date:   Mon Apr 2 20:55:43 2012 -0400

    fixed 4Q1984 turning into 4Q3984
    IntervalIndex constructor now allows you to omit freq argument if interval start/end is passed
    Handle lower case time rules. Can parse ('Min', 5) as freq
    Interval supports aliasing for frequency names

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index cda40720e..342fd0080 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -104,7 +104,23 @@ class Interval(object):
     def __init__(self, value=None, freq=None,
                  year=None, month=1, quarter=None, day=1,
                  hour=0, minute=0, second=0):
+        """
+        Represents an interval of time
 
+        Parameters
+        ----------
+        value : Interval or basestring, default None
+            The time interval represented (e.g., '4Q2005')
+        freq : str, default None
+            e.g., 'B' for businessday, ('Min', 5) or '5Min' for 5 minutes
+        year : int, default None
+        month : int, default 1
+        quarter : int, default None
+        day : int, default 1
+        hour : int, default 0
+        minute : int, default 0
+        second : int, default 0
+        """
         # freq points to a tuple (base, mult);  base is one of the defined
         # intervals such as A, Q, etc. Every five minutes would be, e.g.,
         # ('Min', 5) but may be passed in as a string like '5Min'
@@ -115,11 +131,8 @@ class Interval(object):
 
         self.ordinal = None
 
-        if freq is not None:
-            self.freq = freq
-
         if value is None:
-            if self.freq is None:
+            if freq is None:
                 raise ValueError("If value is None, freq cannot be None")
 
             if year is None:
@@ -128,23 +141,22 @@ class Interval(object):
             if quarter is not None:
                 month = (quarter - 1) * 3 + 1
 
-            base, mult = _get_freq_code(self.freq)
+            base, mult = _get_freq_code(freq)
 
             self.ordinal = lib.skts_ordinal(year, month, day, hour, minute,
                                             second, base, mult)
-            return
 
-        if isinstance(value, Interval):
+        elif isinstance(value, Interval):
             other = value
-            if self.freq is None or _gfc(self.freq) == _gfc(other.freq):
+            if freq is None or _gfc(freq) == _gfc(other.freq):
                 self.ordinal = other.ordinal
-                self.freq = other.freq
+                freq = other.freq
             else:
-                converted = other.resample(self.freq)
+                converted = other.resample(freq)
                 self.ordinal = converted.ordinal
-            return
 
-        if isinstance(value, basestring):
+        elif isinstance(value, basestring):
+            value = value.upper()
             dt, parsed, reso = parse_time_string(value)
 
             if freq is None:
@@ -164,23 +176,29 @@ class Interval(object):
                     freq = 'S'
                 else:
                     raise ValueError("Could not infer frequency for interval")
-                self.freq = freq
 
         elif isinstance(value, datetime):
             dt = value
+            if freq is None:
+                raise ValueError('Must supply freq for datetime value')
         elif isinstance(value, (int, long)):
             if value <= 0:
                 raise ValueError("Value must be positive")
             self.ordinal = value
+            if freq is None:
+                raise ValueError('Must supply freq for ordinal value')
         else:
-            raise ValueError("Value must be string or datetime")
+            msg = "Value must be Interval, string, integer, or datetime"
+            raise ValueError(msg)
 
-        base, mult = _gfc(self.freq)
+        base, mult = _gfc(freq)
 
         if self.ordinal is None:
             self.ordinal = lib.skts_ordinal(dt.year, dt.month, dt.day, dt.hour,
                                             dt.minute, dt.second, base, mult)
 
+        self.freq = _get_freq_str(base, mult)
+
     def __eq__(self, other):
         if isinstance(other, Interval):
             return (self.ordinal == other.ordinal
@@ -678,7 +696,19 @@ def _interval_group(freqstr):
 
 def _get_freq_code(freqstr):
     if isinstance(freqstr, tuple):
-        return freqstr
+        if (isinstance(freqstr[0], (int, long)) and
+            isinstance(freqstr[1], (int, long))):
+            #e.g., freqstr = (2000, 1)
+            return freqstr
+        else:
+            #e.g., freqstr = ('Min', 5)
+            try:
+                code = _interval_str_to_code(freqstr[0])
+                stride = freqstr[1]
+            except:
+                code = _interval_str_to_code(freqstr[1])
+                stride = freqstr[0]
+            return code, stride
 
     if isinstance(freqstr, (int, long)):
         return (freqstr, 1)
@@ -691,8 +721,8 @@ def _get_freq_code(freqstr):
 _skts_alias_dict = _skts_alias_dictionary()
 
 def _interval_str_to_code(freqstr):
-    freqstr = freqstr.upper()
     try:
+        freqstr = freqstr.upper()
         return _interval_code_map[freqstr]
     except:
         alias = _skts_alias_dict[freqstr]
@@ -703,6 +733,17 @@ def _interval_str_to_code(freqstr):
 
 _gfc = _get_freq_code
 
+def _get_freq_str(base, mult):
+    code = _reverse_interval_code_map.get(base)
+    if code is None:
+        return _unknown_freq
+    return str(mult) + code
+
+_gfs = _get_freq_str
+
+_unknown_freq = 'Unknown'
+
+
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
 
@@ -739,19 +780,30 @@ def parse_time_string(arg):
     """
     Try hard to parse datetime string, leveraging dateutil plus some extra
     goodies like quarter recognition.
+
+    Parameters
+    ----------
+    arg : basestring
+
+    Returns
+    -------
+    datetime, datetime/dateutil.parser._result, str
     """
     from pandas.core.format import print_config
 
     if not isinstance(arg, basestring):
         return arg
 
+    arg = arg.upper()
     try:
         default = datetime(1,1,1).replace(hour=0, minute=0,
                                           second=0, microsecond=0)
 
         # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
         if len(arg) in [4, 6]:
+            add_century = False
             if len(arg) == 4:
+                add_century = True
                 qpats = [(qpat1, 1), (qpat2, 0)]
             else:
                 qpats = [(qpat1full, 1), (qpat2full, 0)]
@@ -764,8 +816,9 @@ def parse_time_string(arg):
                     else:
                         yi, qi = 2, 1
                     q = int(qparse.group(yi))
-                    y = int(qparse.group(qi))
-                    if y < 2000:
+                    y_str = qparse.group(qi)
+                    y = int(y_str)
+                    if add_century:
                         y += 2000
                     ret = default.replace(year=y, month=(q-1)*3+1)
                     return ret, ret, 'quarter'
@@ -1843,10 +1896,7 @@ def to_offset(freqstr):
 
     name, stride = _base_and_stride(freqstr)
 
-    offset = _offset_map.get(name)
-
-    if offset is None:
-        raise ValueError('Bad offset request: %s' % name)
+    offset = getOffset(name)
 
     return offset * stride
 
@@ -1883,6 +1933,9 @@ def getOffset(name):
     -------
     getOffset('EOM') --> BMonthEnd(1)
     """
+    name = name.upper()
+    if name == 'MIN':
+        name = 'Min'
     offset = _offset_map.get(name)
 
     if offset is not None:
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 6b8f83f15..473a267ac 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1409,6 +1409,24 @@ class DatetimeIndex(Int64Index):
             self.offset = own_state[1]
             self.tz = own_state[2]
             np.ndarray.__setstate__(self, nd_state)
+        elif len(state) == 3:
+            # legacy format: daterange
+            offset = state[1]
+
+            if len(state) > 2:
+                tzinfo = state[2]
+            else: # pragma: no cover
+                tzinfo = None
+
+            self.offset = offset
+            self.tzinfo = tzinfo
+
+            # extract the raw datetime data, turn into datetime64
+            index_state = state[0]
+            raw_data = index_state[0][4]
+            raw_data = np.array(raw_data, dtype='M8[us]')
+            new_state = raw_data.__reduce__()
+            np.ndarray.__setstate__(self, new_state[2])
         else:  # pragma: no cover
             np.ndarray.__setstate__(self, state)
 
@@ -1949,29 +1967,49 @@ class IntervalIndex(Int64Index):
                 freq=None, start=None, end=None, periods=None,
                 copy=False, name=None):
 
-        if data is None and freq is None:
-            raise ValueError("Must provide freq argument if no data is "
-                             "supplied")
-
         if isinstance(freq, basestring):
             freq = freq.upper()
         elif isinstance(freq, (int, long)):
             freq = datetools._reverse_interval_code_map[freq]
 
         if data is None:
+            if start is None and end is None:
+                raise ValueError('Must specify start, end, or data')
+
             start = to_interval(start, freq)
             end = to_interval(end, freq)
 
-            if (start is not None and not isinstance(start, Interval)):
+            is_start_intv = isinstance(start, Interval)
+            is_end_intv = isinstance(end, Interval)
+            if (start is not None and not is_start_intv):
                 raise ValueError('Failed to convert %s to interval' % start)
 
-            if (end is not None and not isinstance(end, Interval)):
+            if (end is not None and not is_end_intv):
                 raise ValueError('Failed to convert %s to interval' % end)
 
+            if is_start_intv and is_end_intv and (start.freq != end.freq):
+                raise ValueError('Start and end must have same freq')
+
+            if freq is None:
+                if is_start_intv:
+                    freq = start.freq
+                elif is_end_intv:
+                    freq = end.freq
+                else:
+                    raise ValueError('Could not infer freq from start/end')
+
             if periods is not None:
-                data = np.arange(start.ordinal, start.ordinal + periods,
-                                 dtype=np.int64)
+                if start is None:
+                    data = np.arange(end.ordinal - periods + 1,
+                                     end.ordinal + 1,
+                                     dtype=np.int64)
+                else:
+                    data = np.arange(start.ordinal, start.ordinal + periods,
+                                     dtype=np.int64)
             else:
+                if start is None or end is None:
+                    msg = 'Must specify both start and end if periods is None'
+                    raise ValueError(msg)
                 data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
 
             subarr = data.view(cls)
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 258473a86..eafb8bede 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -3,11 +3,10 @@ from datetime import datetime
 
 import cPickle as pickle
 
-from pandas.core.index import DatetimeIndex, Index
+import pandas.core.datetools as dt
+from pandas.core.index import Index, DatetimeIndex, Int64Index
 from pandas.core.frame import DataFrame
 
-from pandas.core.index import Int64Index
-
 import unittest
 import numpy as np
 
@@ -551,6 +550,19 @@ class TestDatetime64(unittest.TestCase):
         for other in [idx2, idx3, idx4, idx5, idx6]:
             self.assert_( (idx1.values == other.values).all() )
 
+        sdate = datetime(1999, 12, 25)
+        edate = datetime(2000, 1, 1)
+        idx = DatetimeIndex(start=sdate, freq='B', periods=20)
+        self.assertEquals(len(idx), 20)
+        self.assertEquals(idx[0], sdate + 0 * dt.bday)
+
+        idx = DatetimeIndex(end=edate, freq='D', periods=20)
+        self.assertEquals(len(idx), 20)
+        self.assertEquals(idx[-1], edate)
+
+        idx1 = DatetimeIndex(start=sdate, end=edate, freq='W')
+
+
     def test_dti_slicing(self):
         dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
         dti2 = dti[[1,3,5]]
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index 5d931e733..c3796f3b3 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -8,7 +8,7 @@ from pandas.core.datetools import (
     DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second,
     WeekOfMonth, format, ole2datetime, QuarterEnd, to_datetime, normalize_date,
     getOffset, getOffsetName, inferTimeRule, hasOffsetName,
-    _dt_box, _dt_unbox)
+    _dt_box, _dt_unbox, parse_time_string)
 
 from nose.tools import assert_raises
 
@@ -1281,13 +1281,22 @@ def test_getOffset():
     assert_raises(Exception, getOffset, 'gibberish')
 
     assert getOffset('WEEKDAY') == BDay()
+    assert getOffset('weEkDaY') == BDay()
     assert getOffset('EOM') == BMonthEnd()
+    assert getOffset('eOM') == BMonthEnd()
     assert getOffset('W@MON') == Week(weekday=0)
     assert getOffset('W@TUE') == Week(weekday=1)
     assert getOffset('W@WED') == Week(weekday=2)
     assert getOffset('W@THU') == Week(weekday=3)
     assert getOffset('W@FRI') == Week(weekday=4)
-
+    assert getOffset('w@Sat') == Week(weekday=5)
+
+def test_parse_time_string():
+    (date, parsed, reso) = parse_time_string('4Q1984')
+    (date_lower, parsed_lower, reso_lower) = parse_time_string('4q1984')
+    assert date == date_lower
+    assert parsed == parsed_lower
+    assert reso == reso_lower
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tests/test_interval.py b/pandas/tests/test_interval.py
index e78ff5c93..ea1d5d3eb 100644
--- a/pandas/tests/test_interval.py
+++ b/pandas/tests/test_interval.py
@@ -32,22 +32,32 @@ class TestIntervalProperties(TestCase):
 
         i1 = Interval('2005', freq='A')
         i2 = Interval('2005')
+        i3 = Interval('2005', freq='a')
 
         self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
 
-        i3 = Interval('2005', freq='M')
-        self.assert_(i1 != i3)
+        i4 = Interval('2005', freq='M')
+        i5 = Interval('2005', freq='m')
+
+        self.assert_(i1 != i4)
+        self.assertEquals(i4, i5)
 
         i1 = Interval.now('Q')
         i2 = Interval(datetime.now(), freq='Q')
+        i3 = Interval.now('q')
 
         self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
 
         # Biz day construction, roll forward if non-weekday
         i1 = Interval('3/10/12', freq='B')
         i2 = Interval('3/12/12', freq='D')
         self.assertEquals(i1, i2.resample('B'))
 
+        i3 = Interval('3/10/12', freq='b')
+        self.assertEquals(i1, i3)
+
         i1 = Interval(year=2005, quarter=1, freq='Q')
         i2 = Interval('1/1/2005', freq='Q')
         self.assertEquals(i1, i2)
@@ -60,22 +70,44 @@ class TestIntervalProperties(TestCase):
         i2 = Interval('3/1/2005', freq='D')
         self.assertEquals(i1, i2)
 
+        i3 = Interval(year=2005, month=3, day=1, freq='d')
+        self.assertEquals(i1, i3)
+
         i1 = Interval(year=2012, month=3, day=10, freq='B')
         i2 = Interval('3/12/12', freq='B')
         self.assertEquals(i1, i2)
 
         i1 = Interval('2005Q1')
         i2 = Interval(year=2005, quarter=1, freq='Q')
+        i3 = Interval('2005q1')
         self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
 
         i1 = Interval('05Q1')
         self.assertEquals(i1, i2)
+        lower = Interval('05q1')
+        self.assertEquals(i1, lower)
 
         i1 = Interval('1Q2005')
         self.assertEquals(i1, i2)
+        lower = Interval('1q2005')
+        self.assertEquals(i1, lower)
 
         i1 = Interval('1Q05')
         self.assertEquals(i1, i2)
+        lower = Interval('1q05')
+        self.assertEquals(i1, lower)
+
+        i1 = Interval('4Q1984')
+        self.assertEquals(i1.year, 1984)
+        lower = Interval('4q1984')
+        self.assertEquals(i1, lower)
+
+        i1 = Interval('1982', freq='min')
+        i2 = Interval('1982', freq='MIN')
+        self.assertEquals(i1, i2)
+        i2 = Interval('1982', freq=('Min', 1))
+        self.assertEquals(i1, i2)
 
     def test_properties_annually(self):
         # Test properties on Intervals with annually frequency.
@@ -796,6 +828,45 @@ class TestIntervalIndex(TestCase):
         ii = IntervalIndex(freq='S', start='1/1/2001', end='1/1/2001 23:59:59')
         assert_equal(len(ii), 24 * 60 * 60)
 
+        start = Interval('02-Apr-2005', 'B')
+        i1 = IntervalIndex(start=start, periods=20)
+        assert_equal(len(i1), 20)
+        assert_equal(i1.freq, start.freq)
+        assert_equal(i1[0], start)
+
+        end_intv = Interval('2006-12-31', 'W')
+        i1 = IntervalIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), 10)
+        assert_equal(i1.freq, end_intv.freq)
+        assert_equal(i1[-1], end_intv)
+
+        end_intv = Interval('2006-12-31', 'w')
+        i2 = IntervalIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), len(i2))
+        self.assert_((i1 == i2).all())
+        assert_equal(i1.freq, i2.freq)
+
+        end_intv = Interval('2006-12-31', ('w', 1))
+        i2 = IntervalIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), len(i2))
+        self.assert_((i1 == i2).all())
+        assert_equal(i1.freq, i2.freq)
+
+        try:
+            IntervalIndex(start=start, end=end_intv)
+            raise AssertionError('Cannot allow mixed freq for start and end')
+        except ValueError:
+            pass
+
+        end_intv = Interval('2005-05-01', 'B')
+        i1 = IntervalIndex(start=start, end=end_intv)
+
+        try:
+            IntervalIndex(start=start)
+            raise AssertionError('Must specify periods if missing start or end')
+        except ValueError:
+            pass
+
     def test_shift(self):
         ii1 = IntervalIndex(freq='A', start='1/1/2001', end='12/1/2009')
         ii2 = IntervalIndex(freq='A', start='1/1/2002', end='12/1/2010')
diff --git a/pandas/tests/test_timeseries.py b/pandas/tests/test_timeseries.py
index f5af47ebf..0a3c3cb9a 100644
--- a/pandas/tests/test_timeseries.py
+++ b/pandas/tests/test_timeseries.py
@@ -48,6 +48,7 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
         uniques = self.dups.index.unique()
         self.assert_(uniques.dtype == 'M8') # sanity
 
+
     def test_duplicate_dates_indexing(self):
         ts = self.dups
 

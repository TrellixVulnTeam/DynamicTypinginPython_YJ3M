commit 145ade2a2f011dbfbe531347fd0dc563ee0b5642
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Tue Jan 29 12:37:42 2019 +0000

     STY: use pytest.raises context manager (indexes/datetimes) (#24995)

diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index d7a8417a7..f9aef2401 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -2058,7 +2058,7 @@ def validate_tz_from_dtype(dtype, tz):
             #  tz-naive dtype (i.e. datetime64[ns])
             if tz is not None and not timezones.tz_compare(tz, dtz):
                 raise ValueError("cannot supply both a tz and a "
-                                 "timezone-naive dtype (i.e. datetime64[ns]")
+                                 "timezone-naive dtype (i.e. datetime64[ns])")
 
     return tz
 
diff --git a/pandas/tests/indexes/common.py b/pandas/tests/indexes/common.py
index 499f01f0e..d72dccadf 100644
--- a/pandas/tests/indexes/common.py
+++ b/pandas/tests/indexes/common.py
@@ -30,7 +30,12 @@ class Base(object):
 
     def test_pickle_compat_construction(self):
         # need an object to create with
-        pytest.raises(TypeError, self._holder)
+        msg = (r"Index\(\.\.\.\) must be called with a collection of some"
+               r" kind, None was passed|"
+               r"__new__\(\) missing 1 required positional argument: 'data'|"
+               r"__new__\(\) takes at least 2 arguments \(1 given\)")
+        with pytest.raises(TypeError, match=msg):
+            self._holder()
 
     def test_to_series(self):
         # assert that we are creating a copy of the index
@@ -84,8 +89,11 @@ class Base(object):
 
         # GH8083 test the base class for shift
         idx = self.create_index()
-        pytest.raises(NotImplementedError, idx.shift, 1)
-        pytest.raises(NotImplementedError, idx.shift, 1, 2)
+        msg = "Not supported for type {}".format(type(idx).__name__)
+        with pytest.raises(NotImplementedError, match=msg):
+            idx.shift(1)
+        with pytest.raises(NotImplementedError, match=msg):
+            idx.shift(1, 2)
 
     def test_create_index_existing_name(self):
 
diff --git a/pandas/tests/indexes/datetimes/test_construction.py b/pandas/tests/indexes/datetimes/test_construction.py
index 7ebebbf6d..6893f635c 100644
--- a/pandas/tests/indexes/datetimes/test_construction.py
+++ b/pandas/tests/indexes/datetimes/test_construction.py
@@ -135,8 +135,10 @@ class TestDatetimeIndex(object):
         tm.assert_index_equal(i2, expected)
 
         # incompat tz/dtype
-        pytest.raises(ValueError, lambda: DatetimeIndex(
-            i.tz_localize(None).asi8, dtype=i.dtype, tz='US/Pacific'))
+        msg = "cannot supply both a tz and a dtype with a tz"
+        with pytest.raises(ValueError, match=msg):
+            DatetimeIndex(i.tz_localize(None).asi8,
+                          dtype=i.dtype, tz='US/Pacific')
 
     def test_construction_index_with_mixed_timezones(self):
         # gh-11488: no tz results in DatetimeIndex
@@ -439,14 +441,19 @@ class TestDatetimeIndex(object):
         tm.assert_index_equal(from_ints, expected)
 
         # non-conforming
-        pytest.raises(ValueError, DatetimeIndex,
-                      ['2000-01-01', '2000-01-02', '2000-01-04'], freq='D')
+        msg = ("Inferred frequency None from passed values does not conform"
+               " to passed frequency D")
+        with pytest.raises(ValueError, match=msg):
+            DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-04'], freq='D')
 
-        pytest.raises(ValueError, date_range, start='2011-01-01',
-                      freq='b')
-        pytest.raises(ValueError, date_range, end='2011-01-01',
-                      freq='B')
-        pytest.raises(ValueError, date_range, periods=10, freq='D')
+        msg = ("Of the four parameters: start, end, periods, and freq, exactly"
+               " three must be specified")
+        with pytest.raises(ValueError, match=msg):
+            date_range(start='2011-01-01', freq='b')
+        with pytest.raises(ValueError, match=msg):
+            date_range(end='2011-01-01', freq='B')
+        with pytest.raises(ValueError, match=msg):
+            date_range(periods=10, freq='D')
 
     @pytest.mark.parametrize('freq', ['AS', 'W-SUN'])
     def test_constructor_datetime64_tzformat(self, freq):
@@ -511,18 +518,20 @@ class TestDatetimeIndex(object):
         idx = DatetimeIndex(['2013-01-01', '2013-01-02'],
                             dtype='datetime64[ns, US/Eastern]')
 
-        pytest.raises(ValueError,
-                      lambda: DatetimeIndex(idx,
-                                            dtype='datetime64[ns]'))
+        msg = ("cannot supply both a tz and a timezone-naive dtype"
+               r" \(i\.e\. datetime64\[ns\]\)")
+        with pytest.raises(ValueError, match=msg):
+            DatetimeIndex(idx, dtype='datetime64[ns]')
 
         # this is effectively trying to convert tz's
-        pytest.raises(TypeError,
-                      lambda: DatetimeIndex(idx,
-                                            dtype='datetime64[ns, CET]'))
-        pytest.raises(ValueError,
-                      lambda: DatetimeIndex(
-                          idx, tz='CET',
-                          dtype='datetime64[ns, US/Eastern]'))
+        msg = ("data is already tz-aware US/Eastern, unable to set specified"
+               " tz: CET")
+        with pytest.raises(TypeError, match=msg):
+            DatetimeIndex(idx, dtype='datetime64[ns, CET]')
+        msg = "cannot supply both a tz and a dtype with a tz"
+        with pytest.raises(ValueError, match=msg):
+            DatetimeIndex(idx, tz='CET', dtype='datetime64[ns, US/Eastern]')
+
         result = DatetimeIndex(idx, dtype='datetime64[ns, US/Eastern]')
         tm.assert_index_equal(idx, result)
 
@@ -732,7 +741,9 @@ class TestTimeSeries(object):
 
     def test_datetimeindex_constructor_misc(self):
         arr = ['1/1/2005', '1/2/2005', 'Jn 3, 2005', '2005-01-04']
-        pytest.raises(Exception, DatetimeIndex, arr)
+        msg = r"(\(u?')?Unknown string format(:', 'Jn 3, 2005'\))?"
+        with pytest.raises(ValueError, match=msg):
+            DatetimeIndex(arr)
 
         arr = ['1/1/2005', '1/2/2005', '1/3/2005', '2005-01-04']
         idx1 = DatetimeIndex(arr)
diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index a9bece248..a38ee264d 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -346,8 +346,10 @@ class TestDateRanges(TestData):
     def test_catch_infinite_loop(self):
         offset = offsets.DateOffset(minute=5)
         # blow up, don't loop forever
-        pytest.raises(Exception, date_range, datetime(2011, 11, 11),
-                      datetime(2011, 11, 12), freq=offset)
+        msg = "Offset <DateOffset: minute=5> did not increment date"
+        with pytest.raises(ValueError, match=msg):
+            date_range(datetime(2011, 11, 11), datetime(2011, 11, 12),
+                       freq=offset)
 
     @pytest.mark.parametrize('periods', (1, 2))
     def test_wom_len(self, periods):
diff --git a/pandas/tests/indexes/datetimes/test_misc.py b/pandas/tests/indexes/datetimes/test_misc.py
index cec181161..fc6080e68 100644
--- a/pandas/tests/indexes/datetimes/test_misc.py
+++ b/pandas/tests/indexes/datetimes/test_misc.py
@@ -190,7 +190,9 @@ class TestDatetime64(object):
         # Ensure is_start/end accessors throw ValueError for CustomBusinessDay,
         bday_egypt = offsets.CustomBusinessDay(weekmask='Sun Mon Tue Wed Thu')
         dti = date_range(datetime(2013, 4, 30), periods=5, freq=bday_egypt)
-        pytest.raises(ValueError, lambda: dti.is_month_start)
+        msg = "Custom business days is not supported by is_month_start"
+        with pytest.raises(ValueError, match=msg):
+            dti.is_month_start
 
         dti = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'])
 
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 2a546af79..84085141f 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -37,15 +37,19 @@ class TestDatetimeIndexOps(Ops):
 
         # sanity check that the behavior didn't change
         # GH#7206
+        msg = "'Series' object has no attribute '{}'"
         for op in ['year', 'day', 'second', 'weekday']:
-            pytest.raises(TypeError, lambda x: getattr(self.dt_series, op))
+            with pytest.raises(AttributeError, match=msg.format(op)):
+                getattr(self.dt_series, op)
 
         # attribute access should still work!
         s = Series(dict(year=2000, month=1, day=10))
         assert s.year == 2000
         assert s.month == 1
         assert s.day == 10
-        pytest.raises(AttributeError, lambda: s.weekday)
+        msg = "'Series' object has no attribute 'weekday'"
+        with pytest.raises(AttributeError, match=msg):
+            s.weekday
 
     def test_repeat_range(self, tz_naive_fixture):
         tz = tz_naive_fixture
diff --git a/pandas/tests/indexes/datetimes/test_partial_slicing.py b/pandas/tests/indexes/datetimes/test_partial_slicing.py
index 1b2aab9d3..a0c9d9f02 100644
--- a/pandas/tests/indexes/datetimes/test_partial_slicing.py
+++ b/pandas/tests/indexes/datetimes/test_partial_slicing.py
@@ -170,7 +170,8 @@ class TestSlicing(object):
         result = s['2005-1-1']
         assert result == s.iloc[0]
 
-        pytest.raises(Exception, s.__getitem__, '2004-12-31')
+        with pytest.raises(KeyError, match=r"^'2004-12-31'$"):
+            s['2004-12-31']
 
     def test_partial_slice_daily(self):
         rng = date_range(freq='H', start=datetime(2005, 1, 31), periods=500)
@@ -179,7 +180,8 @@ class TestSlicing(object):
         result = s['2005-1-31']
         tm.assert_series_equal(result, s.iloc[:24])
 
-        pytest.raises(Exception, s.__getitem__, '2004-12-31 00')
+        with pytest.raises(KeyError, match=r"^'2004-12-31 00'$"):
+            s['2004-12-31 00']
 
     def test_partial_slice_hourly(self):
         rng = date_range(freq='T', start=datetime(2005, 1, 1, 20, 0, 0),
@@ -193,7 +195,8 @@ class TestSlicing(object):
         tm.assert_series_equal(result, s.iloc[:60])
 
         assert s['2005-1-1 20:00'] == s.iloc[0]
-        pytest.raises(Exception, s.__getitem__, '2004-12-31 00:15')
+        with pytest.raises(KeyError, match=r"^'2004-12-31 00:15'$"):
+            s['2004-12-31 00:15']
 
     def test_partial_slice_minutely(self):
         rng = date_range(freq='S', start=datetime(2005, 1, 1, 23, 59, 0),
@@ -207,7 +210,8 @@ class TestSlicing(object):
         tm.assert_series_equal(result, s.iloc[:60])
 
         assert s[Timestamp('2005-1-1 23:59:00')] == s.iloc[0]
-        pytest.raises(Exception, s.__getitem__, '2004-12-31 00:00:00')
+        with pytest.raises(KeyError, match=r"^'2004-12-31 00:00:00'$"):
+            s['2004-12-31 00:00:00']
 
     def test_partial_slice_second_precision(self):
         rng = date_range(start=datetime(2005, 1, 1, 0, 0, 59,
@@ -255,7 +259,9 @@ class TestSlicing(object):
                 result = df['a'][ts_string]
                 assert isinstance(result, np.int64)
                 assert result == expected
-                pytest.raises(KeyError, df.__getitem__, ts_string)
+                msg = r"^'{}'$".format(ts_string)
+                with pytest.raises(KeyError, match=msg):
+                    df[ts_string]
 
             # Timestamp with resolution less precise than index
             for fmt in formats[:rnum]:
@@ -282,15 +288,20 @@ class TestSlicing(object):
                 result = df['a'][ts_string]
                 assert isinstance(result, np.int64)
                 assert result == 2
-                pytest.raises(KeyError, df.__getitem__, ts_string)
+                msg = r"^'{}'$".format(ts_string)
+                with pytest.raises(KeyError, match=msg):
+                    df[ts_string]
 
             # Not compatible with existing key
             # Should raise KeyError
             for fmt, res in list(zip(formats, resolutions))[rnum + 1:]:
                 ts = index[1] + Timedelta("1 " + res)
                 ts_string = ts.strftime(fmt)
-                pytest.raises(KeyError, df['a'].__getitem__, ts_string)
-                pytest.raises(KeyError, df.__getitem__, ts_string)
+                msg = r"^'{}'$".format(ts_string)
+                with pytest.raises(KeyError, match=msg):
+                    df['a'][ts_string]
+                with pytest.raises(KeyError, match=msg):
+                    df[ts_string]
 
     def test_partial_slicing_with_multiindex(self):
 
@@ -316,11 +327,10 @@ class TestSlicing(object):
 
         # this is an IndexingError as we don't do partial string selection on
         # multi-levels.
-        def f():
+        msg = "Too many indexers"
+        with pytest.raises(IndexingError, match=msg):
             df_multi.loc[('2013-06-19', 'ACCT1', 'ABC')]
 
-        pytest.raises(IndexingError, f)
-
         # GH 4294
         # partial slice on a series mi
         s = pd.DataFrame(np.random.rand(1000, 1000), index=pd.date_range(
diff --git a/pandas/tests/indexes/datetimes/test_scalar_compat.py b/pandas/tests/indexes/datetimes/test_scalar_compat.py
index 680eddd27..42338a751 100644
--- a/pandas/tests/indexes/datetimes/test_scalar_compat.py
+++ b/pandas/tests/indexes/datetimes/test_scalar_compat.py
@@ -7,6 +7,8 @@ from datetime import datetime
 import numpy as np
 import pytest
 
+from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
+
 import pandas as pd
 from pandas import DatetimeIndex, Timestamp, date_range
 import pandas.util.testing as tm
@@ -27,10 +29,14 @@ class TestDatetimeIndexOps(object):
         expected = [t.date() for t in rng]
         assert (result == expected).all()
 
-    def test_dti_date_out_of_range(self):
+    @pytest.mark.parametrize('data', [
+        ['1400-01-01'],
+        [datetime(1400, 1, 1)]])
+    def test_dti_date_out_of_range(self, data):
         # GH#1475
-        pytest.raises(ValueError, DatetimeIndex, ['1400-01-01'])
-        pytest.raises(ValueError, DatetimeIndex, [datetime(1400, 1, 1)])
+        msg = "Out of bounds nanosecond timestamp: 1400-01-01 00:00:00"
+        with pytest.raises(OutOfBoundsDatetime, match=msg):
+            DatetimeIndex(data)
 
     @pytest.mark.parametrize('field', [
         'dayofweek', 'dayofyear', 'week', 'weekofyear', 'quarter',
@@ -74,9 +80,15 @@ class TestDatetimeIndexOps(object):
         result = dti.round('s')
         tm.assert_index_equal(result, dti)
 
-        # invalid
-        for freq in ['Y', 'M', 'foobar']:
-            pytest.raises(ValueError, lambda: dti.round(freq))
+    @pytest.mark.parametrize('freq, error_msg', [
+        ('Y', '<YearEnd: month=12> is a non-fixed frequency'),
+        ('M', '<MonthEnd> is a non-fixed frequency'),
+        ('foobar', 'Invalid frequency: foobar')])
+    def test_round_invalid(self, freq, error_msg):
+        dti = date_range('20130101 09:10:11', periods=5)
+        dti = dti.tz_localize('UTC').tz_convert('US/Eastern')
+        with pytest.raises(ValueError, match=error_msg):
+            dti.round(freq)
 
     def test_round(self, tz_naive_fixture):
         tz = tz_naive_fixture
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index bec2fa66c..38f5eab15 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -346,12 +346,16 @@ class TestToDatetime(object):
         for dt in in_bound_dts:
             assert pd.to_datetime(dt, cache=cache) == Timestamp(dt)
 
-        oob_dts = [np.datetime64('1000-01-01'), np.datetime64('5000-01-02'), ]
-
-        for dt in oob_dts:
-            pytest.raises(ValueError, pd.to_datetime, dt, errors='raise')
-            pytest.raises(ValueError, Timestamp, dt)
-            assert pd.to_datetime(dt, errors='coerce', cache=cache) is NaT
+    @pytest.mark.parametrize('dt', [np.datetime64('1000-01-01'),
+                                    np.datetime64('5000-01-02')])
+    @pytest.mark.parametrize('cache', [True, False])
+    def test_to_datetime_dt64s_out_of_bounds(self, cache, dt):
+        msg = "Out of bounds nanosecond timestamp: {}".format(dt)
+        with pytest.raises(OutOfBoundsDatetime, match=msg):
+            pd.to_datetime(dt, errors='raise')
+        with pytest.raises(OutOfBoundsDatetime, match=msg):
+            Timestamp(dt)
+        assert pd.to_datetime(dt, errors='coerce', cache=cache) is NaT
 
     @pytest.mark.parametrize('cache', [True, False])
     def test_to_datetime_array_of_dt64s(self, cache):
@@ -367,8 +371,9 @@ class TestToDatetime(object):
         # A list of datetimes where the last one is out of bounds
         dts_with_oob = dts + [np.datetime64('9999-01-01')]
 
-        pytest.raises(ValueError, pd.to_datetime, dts_with_oob,
-                      errors='raise')
+        msg = "Out of bounds nanosecond timestamp: 9999-01-01 00:00:00"
+        with pytest.raises(OutOfBoundsDatetime, match=msg):
+            pd.to_datetime(dts_with_oob, errors='raise')
 
         tm.assert_numpy_array_equal(
             pd.to_datetime(dts_with_oob, box=False, errors='coerce',
@@ -410,7 +415,10 @@ class TestToDatetime(object):
         # mixed tzs will raise
         arr = [pd.Timestamp('2013-01-01 13:00:00', tz='US/Pacific'),
                pd.Timestamp('2013-01-02 14:00:00', tz='US/Eastern')]
-        pytest.raises(ValueError, lambda: pd.to_datetime(arr, cache=cache))
+        msg = ("Tz-aware datetime.datetime cannot be converted to datetime64"
+               " unless utc=True")
+        with pytest.raises(ValueError, match=msg):
+            pd.to_datetime(arr, cache=cache)
 
     @pytest.mark.parametrize('cache', [True, False])
     def test_to_datetime_tz_pytz(self, cache):
@@ -1088,9 +1096,9 @@ class TestToDatetimeMisc(object):
     def test_to_datetime_with_space_in_series(self, cache):
         # GH 6428
         s = Series(['10/18/2006', '10/18/2008', ' '])
-        pytest.raises(ValueError, lambda: to_datetime(s,
-                                                      errors='raise',
-                                                      cache=cache))
+        msg = r"(\(u?')?String does not contain a date(:', ' '\))?"
+        with pytest.raises(ValueError, match=msg):
+            to_datetime(s, errors='raise', cache=cache)
         result_coerce = to_datetime(s, errors='coerce', cache=cache)
         expected_coerce = Series([datetime(2006, 10, 18),
                                   datetime(2008, 10, 18),
@@ -1111,13 +1119,12 @@ class TestToDatetimeMisc(object):
         assert_series_equal(result, expected)
 
         td = pd.Series(['May 04', 'Jun 02', ''], index=[1, 2, 3])
-        pytest.raises(ValueError,
-                      lambda: pd.to_datetime(td, format='%b %y',
-                                             errors='raise',
-                                             cache=cache))
-        pytest.raises(ValueError,
-                      lambda: td.apply(pd.to_datetime, format='%b %y',
-                                       errors='raise', cache=cache))
+        msg = r"time data '' does not match format '%b %y' \(match\)"
+        with pytest.raises(ValueError, match=msg):
+            pd.to_datetime(td, format='%b %y', errors='raise', cache=cache)
+        with pytest.raises(ValueError, match=msg):
+            td.apply(pd.to_datetime, format='%b %y',
+                     errors='raise', cache=cache)
         expected = pd.to_datetime(td, format='%b %y', errors='coerce',
                                   cache=cache)
 
@@ -1168,8 +1175,9 @@ class TestToDatetimeMisc(object):
         result = to_datetime([1, '1'], errors='ignore', cache=cache, box=box)
         expected = klass(np.array([1, '1'], dtype='O'))
         tm.assert_equal(result, expected)
-        pytest.raises(TypeError, to_datetime, [1, '1'], errors='raise',
-                      cache=cache, box=box)
+        msg = "invalid string coercion to datetime"
+        with pytest.raises(TypeError, match=msg):
+            to_datetime([1, '1'], errors='raise', cache=cache, box=box)
 
     def test_to_datetime_other_datetime64_units(self):
         # 5/25/2012
@@ -1225,17 +1233,18 @@ class TestToDatetimeMisc(object):
         malformed = np.array(['1/100/2000', np.nan], dtype=object)
 
         # GH 10636, default is now 'raise'
-        pytest.raises(ValueError,
-                      lambda: to_datetime(malformed, errors='raise',
-                                          cache=cache))
+        msg = (r"\(u?'Unknown string format:', '1/100/2000'\)|"
+               "day is out of range for month")
+        with pytest.raises(ValueError, match=msg):
+            to_datetime(malformed, errors='raise', cache=cache)
 
         result = to_datetime(malformed, errors='ignore', cache=cache)
         # GH 21864
         expected = Index(malformed)
         tm.assert_index_equal(result, expected)
 
-        pytest.raises(ValueError, to_datetime, malformed, errors='raise',
-                      cache=cache)
+        with pytest.raises(ValueError, match=msg):
+            to_datetime(malformed, errors='raise', cache=cache)
 
         idx = ['a', 'b', 'c', 'd', 'e']
         series = Series(['1/1/2000', np.nan, '1/3/2000', np.nan,
@@ -1414,14 +1423,24 @@ class TestDaysInMonth(object):
 
     @pytest.mark.parametrize('cache', [True, False])
     def test_day_not_in_month_raise(self, cache):
-        pytest.raises(ValueError, to_datetime, '2015-02-29',
-                      errors='raise', cache=cache)
-        pytest.raises(ValueError, to_datetime, '2015-02-29',
-                      errors='raise', format="%Y-%m-%d", cache=cache)
-        pytest.raises(ValueError, to_datetime, '2015-02-32',
-                      errors='raise', format="%Y-%m-%d", cache=cache)
-        pytest.raises(ValueError, to_datetime, '2015-04-31',
-                      errors='raise', format="%Y-%m-%d", cache=cache)
+        msg = "day is out of range for month"
+        with pytest.raises(ValueError, match=msg):
+            to_datetime('2015-02-29', errors='raise', cache=cache)
+
+        msg = "time data 2015-02-29 doesn't match format specified"
+        with pytest.raises(ValueError, match=msg):
+            to_datetime('2015-02-29', errors='raise', format="%Y-%m-%d",
+                        cache=cache)
+
+        msg = "time data 2015-02-32 doesn't match format specified"
+        with pytest.raises(ValueError, match=msg):
+            to_datetime('2015-02-32', errors='raise', format="%Y-%m-%d",
+                        cache=cache)
+
+        msg = "time data 2015-04-31 doesn't match format specified"
+        with pytest.raises(ValueError, match=msg):
+            to_datetime('2015-04-31', errors='raise', format="%Y-%m-%d",
+                        cache=cache)
 
     @pytest.mark.parametrize('cache', [True, False])
     def test_day_not_in_month_ignore(self, cache):
@@ -1656,7 +1675,9 @@ class TestDatetimeParsingWrappers(object):
             assert tools.to_time(time_string) == expected
 
         new_string = "14.15"
-        pytest.raises(ValueError, tools.to_time, new_string)
+        msg = r"Cannot convert arg \['14\.15'\] to a time"
+        with pytest.raises(ValueError, match=msg):
+            tools.to_time(new_string)
         assert tools.to_time(new_string, format="%H.%M") == expected
 
         arg = ["14:15", "20:20"]

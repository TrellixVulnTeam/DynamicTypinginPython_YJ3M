commit 7cc64d65ce5c4d15c82d14e95bf644b92dd9bf2c
Author: jreback <jeff@reback.net>
Date:   Thu Feb 28 00:15:39 2013 -0500

    ENH: added loc/at/iat indexers ....almost done

diff --git a/doc/source/conf.py b/doc/source/conf.py
index 76093d83b..43b7df6af 100644
--- a/doc/source/conf.py
+++ b/doc/source/conf.py
@@ -17,6 +17,7 @@ import os
 # add these directories to sys.path here. If the directory is relative to the
 # documentation root, use os.path.abspath to make it absolute, like shown here.
 # sys.path.append(os.path.abspath('.'))
+sys.path.insert(0,'/home/jreback/pandas')
 sys.path.insert(0, os.path.abspath('../sphinxext'))
 
 sys.path.extend([
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 1ddb4a828..11708f68d 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -53,7 +53,7 @@ indexing functionality:
 
 .. ipython:: python
 
-   dates = np.asarray(date_range('1/1/2000', periods=8))
+   dates = date_range('1/1/2000', periods=8)
    df = DataFrame(randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])
    df
    panel = Panel({'one' : df, 'two' : df - df.mean()})
@@ -81,21 +81,29 @@ Fast scalar value getting and setting
 Since indexing with ``[]`` must handle a lot of cases (single-label access,
 slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
 out what you're asking for. If you only want to access a scalar value, the
-fastest way is to use the ``get_value`` method, which is implemented on all of
-the data structures:
+fastest way is to use the ``at`` and ``iat`` methods, which are implemented on all of
+the data structures.
+
+Similary to ``loc`` and ``at`` provides **label** based lookups, while, ``iat`` provides
+**integer** based lookups analagously to ``iloc``
 
 .. ipython:: python
 
-   s.get_value(dates[5])
-   df.get_value(dates[5], 'A')
+   type(dates[5])
+   dates[5]
+   s.at[dates[5]]
+   s.iat[5]
+   df.at[dates[5], 'A']
+   df.iat[3, 0]
 
-There is an analogous ``set_value`` method which has the additional capability
+You can also set using these same indexers. These have the additional capability
 of enlarging an object. This method *always* returns a reference to the object
 it modified, which in the case of enlargement, will be a **new object**:
 
 .. ipython:: python
 
-   df.set_value(dates[5], 'E', 7)
+   df.at[dates[5], 'E'] = 7
+   df.iat[3, 0] = 7
 
 Additional Column Access
 ~~~~~~~~~~~~~~~~~~~~~~~~
@@ -177,8 +185,57 @@ largely as a convenience since it is such a common operation.
    df[:3]
    df[::-1]
 
-Location Based Indexing
-~~~~~~~~~~~~~~~~~~~~~~~
+Label Based Indexing
+~~~~~~~~~~~~~~~~~~~~
+
+Pandas provides a suite of methods in order to get **purely label based indexing**. 
+This is a strict inclusion based protocol. **ALL** of the labels for which you ask,
+must be in the index or a KeyError will be raised! When slicing, the start bounds is 
+*included*, **AND** the upper bound is *included*. Invalid selections will raise with 
+an ``KeyError``. Integers are valid indicies (and labels), but standard semantics
+**DO NOT APPLY**, labels must be **INCLUSIVE**. Valid selection include: *label, listlike 
+of labels, boolean indexers, and label slices*
+
+The ``.loc`` attribute is the primary access method.
+
+.. ipython:: python
+
+   s1 = Series(np.random.randn(6),index=list('abcdef'))
+   s1
+   s1.loc['c':]
+   s1.loc['b']
+
+Note that setting works as well:
+
+.. ipython:: python
+
+   s1.loc['c':] = 0
+   s1
+
+With a DataFrame
+
+.. ipython:: python
+
+   df1 = DataFrame(np.random.randn(6,4),index=list('abcdef'),columns=range(4))
+   df1
+   df1.loc[['a','b','d'],:]
+
+   # slices (this is an ok integer slice because it encompasses all of the labels)
+   df1.loc['d':,1:3]
+
+   # boolean
+   df1.loc[:,[True,True,False,False]]
+
+For getting a value explicity.
+
+.. ipython:: python
+
+   # this is equivalent to ``df1.at['a',1]``
+   df1.loc['a',1]
+
+
+Integer Based Indexing
+~~~~~~~~~~~~~~~~~~~~~~
 
 Pandas provides a suite of methods in order to get **purely integer based indexing**. 
 The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
@@ -224,22 +281,20 @@ For slicing rows explicitly.
 
 .. ipython:: python
 
-   # this is equivalent to ``df1.iloc[1:3,:]``
-   df1.irow(range(1,3))
+   df1.iloc[1:3,:]
 
 For slicing columns explicitly.
 
 .. ipython:: python
 
-   # this is equivalent to ``df1.iloc[:,1:3]``
-   df1.icol(range(1,3))
+   df1.iloc[:,1:3]
 
 For getting a value explicity.
 
 .. ipython:: python
 
-   # this is equivalent to ``df1.iloc[1,1]``
-   df1.iget_value(1,1)
+   # this is equivalent to ``df1.iat[1,1]``
+   df1.iloc[1,1]
 
 There is one signficant departure from standard python/numpy slicing semantics.
 python/numpy allow slicing past the end of an array without an associated error.
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index f2d4f299d..e21405b77 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,7 +1,7 @@
 # pylint: disable=W0223
 
 from pandas.core.common import _asarray_tuplesafe
-from pandas.core.index import Index, MultiIndex
+from pandas.core.index import Index, MultiIndex, _ensure_index
 import pandas.core.common as com
 import pandas.lib as lib
 
@@ -607,9 +607,10 @@ class _NDFrameIndexer(object):
 
 class _LocationIndexer(_NDFrameIndexer):
     _valid_types = None
+    _exception   = Exception
 
-    def _has_valid_type(self, k):
-        raise NotImplemented
+    def _has_valid_type(self, k, axis):
+        raise NotImplementedError()
 
     def __getitem__(self, key):
         if type(key) is tuple:
@@ -617,50 +618,107 @@ class _LocationIndexer(_NDFrameIndexer):
             for i, k in enumerate(key):
                 if i >= self.obj.ndim:
                     raise ValueError('Too many indexers')
-                if not self._has_valid_type(k):
+                if not self._has_valid_type(k,i):
                     raise ValueError("Location based indexing can only have [%s] types" % self._valid_types)
 
             return self._getitem_tuple(key)
         else:
             return self._getitem_axis(key, axis=0)
 
-    def _getitem_tuple(self, tup):
+    def _getitem_axis(self, key, axis=0):
+        raise NotImplementedError()
 
-        retval = self.obj
-        for i, key in enumerate(tup):
-            if _is_null_slice(key):
-                continue
+    def _getbool_axis(self, key, axis=0):
+            labels = self.obj._get_axis(axis)
+            key = _check_bool_indexer(labels, key)
+            inds, = key.nonzero()
+            try:
+                return self.obj.take(inds, axis=axis)
+            except (Exception), detail:
+                raise self._exception(detail)
 
-            retval = getattr(retval,self.name)._getitem_axis(key, axis=i)
+class _LocIndexer(_LocationIndexer):
+    """ purely label based location based indexing """
+    _valid_types = "labels (MUST BE INCLUSIVE), slices of labels, slices of integers if the index is integers, boolean"
+    _exception   = KeyError
 
-        return retval
+    def _has_valid_type(self, key, axis):
+        ax = self.obj._get_axis(axis)
 
-    def _get_slice_axis(self, slice_obj, axis=0):
-        raise NotImplemented
+        # valid for a label where all labels are in the index
+        # slice of lables (where start-end in labels)
+        # slice of integers (only if in the lables)
+        # boolean
 
-    def _getitem_axis(self, key, axis=0):
-        raise NotImplemented
+        if isinstance(key, slice):
 
-    def _convert_to_indexer(self, obj, axis=0):
-        """ much simpler as we only have to deal with our valid types """
-        if self._has_valid_type(obj):
-            return obj
+            if key.start is not None and key.start not in ax:
+                raise KeyError
+            if key.stop is not None and key.stop-1 not in ax:
+                raise KeyError
 
-        raise ValueError("Can only index by location with a [%s]" % self._valid_types)
+        elif com._is_bool_indexer(key):
+                return True
 
-class _LocIndexer(_LocationIndexer):
-    """ purely label based location based indexing """
-    _valid_types = None
+        elif _is_list_like(key):
+
+            # require all elements in the index
+            idx = _ensure_index(key)
+            if not idx.isin(ax).all():
+                raise KeyError
+
+            return True
+
+        else:
+
+            # if its empty we want a KeyError here
+            if not len(ax):
+                raise KeyError
+
+            if not key in ax:
+                raise KeyError
 
-    def _has_valid_type(self, k):
         return True
 
+    def _getitem_axis(self, key, axis=0):
+        labels = self.obj._get_axis(axis)
+
+        if isinstance(key, slice):
+            return self._get_slice_axis(key, axis=axis)
+        elif com._is_bool_indexer(key):
+            return self._getbool_axis(key, axis=axis)
+        elif _is_list_like(key) and not (isinstance(key, tuple) and
+                                         isinstance(labels, MultiIndex)):
+
+            if hasattr(key, 'ndim') and key.ndim > 1:
+                raise ValueError('Cannot index with multidimensional key')
+
+            return self._getitem_iterable(key, axis=axis)
+        else:
+            indexer = labels.get_loc(key)
+            return self._get_loc(indexer, axis=axis)
+
+    def _get_loc(self, key, axis=0):
+        return self.obj._ixs(key, axis=axis)
+
 class _iLocIndexer(_LocationIndexer):
     """ purely integer based location based indexing """
     _valid_types = "integer, integer slice, listlike of integers, boolean array"
+    _exception   = IndexError
 
-    def _has_valid_type(self, k):
-        return isinstance(k, slice) or com.is_integer(k) or _is_list_like(k) or com._is_bool_indexer(k)
+    def _has_valid_type(self, key, axis):
+        return isinstance(key, slice) or com.is_integer(key) or com._is_bool_indexer(key) or _is_list_like(key)
+
+    def _getitem_tuple(self, tup):
+
+        retval = self.obj
+        for i, key in enumerate(tup):
+            if _is_null_slice(key):
+                continue
+
+            retval = getattr(retval,self.name)._getitem_axis(key, axis=i)
+
+        return retval
 
     def _get_slice_axis(self, slice_obj, axis=0):
         obj = self.obj
@@ -679,11 +737,7 @@ class _iLocIndexer(_LocationIndexer):
             return self._get_slice_axis(key, axis=axis)
 
         elif com._is_bool_indexer(key):
-            
-            labels = self.obj._get_axis(axis)
-            key = _check_bool_indexer(labels, key)
-            inds, = key.nonzero()
-            return self.obj.take(inds, axis=axis)
+            return self._getbool_axis(key, axis=axis)
 
         # a single integer or a list of integers
         else:
@@ -693,6 +747,13 @@ class _iLocIndexer(_LocationIndexer):
 
             return self._get_loc(key,axis=axis)
 
+    def _convert_to_indexer(self, obj, axis=0):
+        """ much simpler as we only have to deal with our valid types """
+        if self._has_valid_type(obj,axis):
+            return obj
+
+        raise ValueError("Can only index by location with a [%s]" % self._valid_types)
+
 
 class _ScalarAccessIndexer(_NDFrameIndexer):
     """ access scalars quickly """
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 16d5f09aa..dd1aeed70 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -12,7 +12,7 @@ from pandas.core.common import (PandasError, _mut_exclusive,
 from pandas.core.categorical import Factor
 from pandas.core.index import (Index, MultiIndex, _ensure_index,
                                _get_combined_index)
-from pandas.core.indexing import _NDFrameIndexer, _maybe_droplevels
+from pandas.core.indexing import _maybe_droplevels, _is_list_like
 from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.series import Series
 from pandas.core.frame import DataFrame
@@ -1069,6 +1069,11 @@ class Panel(NDFrame):
         # for compatibility with .ix indexing
         # Won't work with hierarchical indexing yet
         key = self._get_axis(axis)[i]
+
+        # xs cannot handle a non-scalar key, so just reindex here
+        if _is_list_like(key):
+            return self.reindex(**{ self._get_axis_name(axis) : key })
+
         return self.xs(key, axis=axis)
 
     def groupby(self, function, axis='major'):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a3a0cfea9..74f96aff0 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -560,7 +560,31 @@ class Series(pa.Array, generic.PandasObject):
         return self._ix
 
     def _ixs(self, i, axis=0):
-        return self[self.index[i]]
+        """
+        Return the i-th value or values in the Series by location
+
+        Parameters
+        ----------
+        i : int, slice, or sequence of integers
+
+        Returns
+        -------
+        value : scalar (int) or Series (slice, sequence)
+        """
+        try:
+            return _index.get_value_at(self, i)
+        except IndexError:
+            raise
+        except:
+            if isinstance(i, slice):
+                return self[i]
+            else:
+                label = self.index[i]
+                if isinstance(label, Index):
+                    return self.reindex(label)
+                else:
+                    return _index.get_value_at(self, i)
+
 
     @property
     def _is_mixed_type(self):
@@ -924,34 +948,9 @@ class Series(pa.Array, generic.PandasObject):
         except KeyError:
             return default
 
-    def iget_value(self, i):
-        """
-        Return the i-th value or values in the Series by location
-
-        Parameters
-        ----------
-        i : int, slice, or sequence of integers
-
-        Returns
-        -------
-        value : scalar (int) or Series (slice, sequence)
-        """
-        try:
-            return _index.get_value_at(self, i)
-        except IndexError:
-            raise
-        except:
-            if isinstance(i, slice):
-                return self[i]
-            else:
-                label = self.index[i]
-                if isinstance(label, Index):
-                    return self.reindex(label)
-                else:
-                    return _index.get_value_at(self, i)
-
-    iget = iget_value
-    irow = iget_value
+    iget_value = _ixs
+    iget = _ixs
+    irow = _ixs
 
     def get_value(self, label):
         """
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index acb720cfc..105a12dd0 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -59,6 +59,12 @@ def _get_result(obj, method, key, axis):
     if isinstance(key, dict):
         key = key[axis]
 
+    # use an artifical conversion to map the key as integers to the labels
+    # so ix can work for comparisions
+    if method == 'indexer':
+        method = 'ix'
+        key    = obj._get_axis(axis)[key]
+
     # in case we actually want 0 index slicing
     try:
         xp  = getattr(obj, method).__getitem__(_axify(obj,key,axis))
@@ -95,14 +101,14 @@ class TestIndexing(unittest.TestCase):
 
         self.series_labels = Series(np.random.randn(4), index=list('abcd'))
         self.frame_labels  = DataFrame(np.random.randn(4, 4), index=list('abcd'), columns=list('ABCD'))
-        self.panel_labels  = Panel(np.random.randn(4,4,4), items=list('ZYXW'), major_axis=list('abcd'), minor_axis=list('ABCD'))
+        self.panel_labels  = Panel(np.random.randn(4,4,4), items=list('abcd'), major_axis=list('ABCD'), minor_axis=list('ZYXW'))
 
         self.series_mixed  = Series(np.random.randn(4), index=[2, 4, 'null', 8])
-        self.frame_mixed   = DataFrame(np.random.randn(4, 4), columns=[2, 4, 'null', 8])
+        self.frame_mixed   = DataFrame(np.random.randn(4, 4), index=[2, 4, 'null', 8])
         self.panel_mixed   = Panel(np.random.randn(4,4,4), items=[2,4,'null',8])
 
         self.series_ts     = Series(np.random.randn(4), index=date_range('20130101', periods=4))
-        self.frame_ts      = DataFrame(np.random.randn(4, 4), columns=date_range('20130101', periods=4))
+        self.frame_ts      = DataFrame(np.random.randn(4, 4), index=date_range('20130101', periods=4))
         self.panel_ts      = Panel(np.random.randn(4, 4, 4), items=date_range('20130101', periods=4))
 
         #self.series_floats = Series(np.random.randn(4), index=[1.00, 2.00, 3.00, 4.00])
@@ -142,7 +148,7 @@ class TestIndexing(unittest.TestCase):
             assert_almost_equal(result, expected)
 
 
-    def check_result(self, name, method1, key1, method2, key2, typs = None, objs = None, axis = None, empty = 'fail', fails = None):
+    def check_result(self, name, method1, key1, method2, key2, typs = None, objs = None, axes = None, fails = None):
 
 
         def _eq(t, o, a, obj, k1, k2):
@@ -154,12 +160,16 @@ class TestIndexing(unittest.TestCase):
             def _print(result, show = True,error = None):
                 if error is not None:
                     error = str(error)
-                v = "%-12.12s [%-10.10s]: [typ->%-8.8s,obj->%-8.8s,key1->(%-4.4s) %-20.20s,key2->(%-4.4s) %-20.20s,axis->%s] %s" % (name,result,t,o,method1,key1,method2,key2,a,error or '')
+                v = "%-16.16s [%-16.16s]: [typ->%-8.8s,obj->%-8.8s,key1->(%-4.4s),key2->(%-4.4s),axis->%s] %s" % (name,result,t,o,method1,method2,a,error or '')
                 if show:
                     print(v)
 
             try:
 
+                ### good debug location ###
+                #if name == 'bool' and t == 'empty' and o == 'series' and method1 == 'loc':
+                #    import pdb; pdb.set_trace()
+
                 rs  = getattr(obj, method1).__getitem__(_axify(obj,k1,a))
 
                 try:
@@ -200,15 +210,13 @@ class TestIndexing(unittest.TestCase):
             except (Exception), detail:
 
                 # if we are in fails, the ok, otherwise raise it
-                if isinstance(fails,(tuple,list)):
-                    if tuple(t,o) in fails or tuple(o,t) in fails:
+                if fails is not None:
+                    if fails == type(detail):
+                        result = 'ok (%s)' % type(detail).__name__
+                        _print(result)
                         return
                 
-                # empty fails are ok
-                if empty == 'fail' and t == 'empty':
-                    return
-
-                result = 'error'
+                result = type(detail).__name__
                 raise AssertionError(_print(result, error = detail))
 
         if typs is None:
@@ -217,12 +225,11 @@ class TestIndexing(unittest.TestCase):
         if objs is None:
             objs = self._objs
 
-        axes = []
-        if axis is not None:
-            if not isinstance(axis,(tuple,list)):
-                axes = [ axis ]
+        if axes is not None:
+            if not isinstance(axes,(tuple,list)):
+                axes = [ axes ]
             else:
-                axes = list(axis)
+                axes = list(axes)
         else:
             axes = [ 0, 1, 2]
 
@@ -242,10 +249,6 @@ class TestIndexing(unittest.TestCase):
                         obj = obj.copy()
                         
                         k2 = key2
-
-                        if name == 'list int' and o == 'panel':
-                            import pdb; pdb.set_trace()
-
                         _eq(t, o, a, obj, key1, k2)
 
     def test_at_and_iat_get(self):
@@ -301,33 +304,49 @@ class TestIndexing(unittest.TestCase):
             _check(d['ts'],    'at')
             _check(d['floats'],'at')
             
-    def test_iloc_getitem(self):
+    def test_iloc_getitem_int(self):
 
         # integer
         self.check_result('integer', 'iloc', 2, 'ix', { 0 : 4, 1: 6, 2: 8 }, typs = ['ints'])
-        self.check_result('integer', 'iloc', 2, 'ix', { 0 : 4, 1: 6, 2: 8 }, typs = ['labels','mixed','ts','floats','empty'], fails = True)
+        self.check_result('integer', 'iloc', 2, 'indexer', 2, typs = ['labels','mixed','ts','floats','empty'], fails = IndexError)
         
+    def test_iloc_getitem_neg_int(self):
+
         # neg integer
         self.check_result('neg int', 'iloc', -1, 'ix', { 0 : 6, 1: 9, 2: 12 }, typs = ['ints'])
-        self.check_result('neg int', 'iloc', -1, 'ix', { 0 : 6, 1: 9, 2: 12 }, typs = ['labels','mixed','ts','floats','empty'], fails = True)
+        self.check_result('neg int', 'iloc', -1, 'indexer', -1, typs = ['labels','mixed','ts','floats','empty'], fails = IndexError)
+
+    def test_iloc_getitem_list_int(self):
 
         # list of ints
-        self.check_result('list int', 'iloc', [0,1,3], 'ix', { 0 : [0,2,6], 1 : [0,3,9], 2: [0,4,12] }, typs = ['ints'])
-        self.check_result('list int', 'iloc', [0,1,3], 'ix', { 0 : [0,2,6], 1 : [0,3,9], 2: [0,4,12] }, typs = ['labels','mixed','ts','floats','empty'], fails = True)
-        self.check_result('list int (dups)', 'iloc', [0,1,1,3], 'ix', { 0 : [0,2,2,6], 1 : [0,3,3,9], 2: [0,4,4,12] }, typs = ['ints'])
+        self.check_result('list int', 'iloc', [0,1,2], 'ix', { 0 : [0,2,4], 1 : [0,3,6], 2: [0,4,8] }, typs = ['ints'])
+        self.check_result('list int', 'iloc', [0,1,2], 'indexer', [0,1,2], typs = ['labels','mixed','ts','floats','empty'], fails = IndexError)
+ 
+    def test_iloc_getitem_dups(self):
+
+        # no dups in panel (bug?)
+        self.check_result('list int (dups)', 'iloc', [0,1,1,3], 'ix', { 0 : [0,2,2,6], 1 : [0,3,3,9] }, objs = ['series','frame'], typs = ['ints'])
+
+    def test_iloc_getitem_array(self):
 
-        # series like
+        # array like
         s = Series(index=range(1,4))
-        self.check_result('array like', 'iloc', s.index, 'ix', [2,4,6], typs = ['ints'])
+        self.check_result('array like', 'iloc', s.index, 'ix', { 0 : [2,4,6], 1 : [3,6,9], 2: [4,8,12] }, typs = ['ints'])
+
+    def test_iloc_getitem_bool(self):
 
         # boolean indexers
         b = [True,False,True,False,]
         self.check_result('bool', 'iloc', b, 'ix', b, typs = ['ints'])
-        self.check_result('bool', 'iloc', b, 'ix', b, typs = ['labels','mixed','ts','floats','empty'], fails = True)
+        self.check_result('bool', 'iloc', b, 'ix', b, typs = ['labels','mixed','ts','floats','empty'], fails = IndexError)
+
+    def test_iloc_getitem_slice(self):
 
         # slices
-        self.check_result('slice', 'iloc', slice(1,3), 'ix', slice(2,4,2), typs = ['ints'])
-        self.check_result('slice', 'iloc', slice(1,3), 'ix', slice(2,4,2), typs = ['labels','mixed','ts','floats','empty'], fails = True)
+        self.check_result('slice', 'iloc', slice(1,3), 'ix', { 0 : [2,4], 1: [3,6], 2: [4,8] }, typs = ['ints'])
+        self.check_result('slice', 'iloc', slice(1,3), 'indexer', slice(1,3), typs = ['labels','mixed','ts','floats','empty'], fails = IndexError)
+
+    def test_iloc_getitem_out_of_bounds(self):
 
         # out-of-bounds slice
         self.assertRaises(IndexError, self.frame_ints.iloc.__getitem__, tuple([slice(None),slice(1,5,None)]))
@@ -364,6 +383,105 @@ class TestIndexing(unittest.TestCase):
         xp = df.values[2,2]
         self.assert_(rs == xp)
 
+    def test_loc_getitem_int(self):
+
+        # int label
+        self.check_result('int label', 'loc', 2, 'ix', 2, typs = ['ints'], axes = 0)
+        self.check_result('int label', 'loc', 3, 'ix', 3, typs = ['ints'], axes = 1)
+        self.check_result('int label', 'loc', 4, 'ix', 4, typs = ['ints'], axes = 2)
+        self.check_result('int label', 'loc', 2, 'ix', 2, typs = ['label'], fails = KeyError)
+
+    def test_loc_getitem_label(self):
+
+        # label
+        self.check_result('label', 'loc', 'c',    'ix', 'c',    typs = ['labels'], axes=0)
+        self.check_result('label', 'loc', 'null', 'ix', 'null', typs = ['mixed'] , axes=0)
+        self.check_result('label', 'loc', 8,      'ix', 8,      typs = ['mixed'] , axes=0)
+        self.check_result('label', 'loc', Timestamp('20130102'), 'ix', 1, typs = ['ts'], axes=0)
+        self.check_result('label', 'loc', 'c', 'ix', 'c', typs = ['empty'], fails = KeyError)
+
+    def test_loc_getitem_label_out_of_range(self):
+
+        # out of range label
+        self.check_result('label range', 'loc', 'f', 'ix', 'f', typs = ['ints','labels','mixed','ts','floats'], fails=KeyError)
+        
+    def test_loc_getitem_label_list(self):
+
+        # list of labels
+        self.check_result('list lbl', 'loc', [0,2,4], 'ix', [0,2,4], typs = ['ints'], axes=0)
+        self.check_result('list lbl', 'loc', [3,6,9], 'ix', [3,6,9], typs = ['ints'], axes=1)
+        self.check_result('list lbl', 'loc', [4,8,12], 'ix', [4,8,12], typs = ['ints'], axes=2)
+        self.check_result('list lbl', 'loc', ['a','b','d'], 'ix', ['a','b','d'], typs = ['labels'], axes=0)
+        self.check_result('list lbl', 'loc', ['A','B','C'], 'ix', ['A','B','C'], typs = ['labels'], axes=1)
+        self.check_result('list lbl', 'loc', ['Z','Y','W'], 'ix', ['Z','Y','W'], typs = ['labels'], axes=2)
+        self.check_result('list lbl', 'loc', [2,8,'null'], 'ix', [2,8,'null'], typs = ['mixed'], axes=0)
+        self.check_result('list lbl', 'loc', [Timestamp('20130102'),Timestamp('20130103')], 'ix', 
+                          [Timestamp('20130102'),Timestamp('20130103')], typs = ['ts'], axes=0)
+
+        # fails
+        self.check_result('list lbl', 'loc', [0,1,2], 'indexer', [0,1,2], typs = ['empty'], fails = KeyError)
+        self.check_result('list lbl', 'loc', [0,2,3], 'ix', [0,2,3], typs = ['ints'], axes=0, fails = KeyError)
+        self.check_result('list lbl', 'loc', [3,6,7], 'ix', [3,6,9], typs = ['ints'], axes=1, fails = KeyError)
+        self.check_result('list lbl', 'loc', [4,8,10], 'ix', [4,8,12], typs = ['ints'], axes=2, fails = KeyError)
+ 
+        # array like
+        self.check_result('array like', 'loc', Series(index=[0,2,4]).index, 'ix', [0,2,4], typs = ['ints'], axes=0)
+        self.check_result('array like', 'loc', Series(index=[3,6,9]).index, 'ix', [3,6,9], typs = ['ints'], axes=1)
+        self.check_result('array like', 'loc', Series(index=[4,8,12]).index, 'ix', [4,8,12], typs = ['ints'], axes=2)
+
+    def test_loc_getitem_bool(self):
+
+        # boolean indexers
+        b = [True,False,True,False]
+        self.check_result('bool', 'loc', b, 'ix', b, typs = ['ints','labels','mixed','ts','floats'])
+        self.check_result('bool', 'loc', b, 'ix', b, typs = ['empty'], fails = KeyError)
+
+    def test_loc_getitem_int_slice(self):
+
+        # int slices in int 
+        self.check_result('int slice1', 'loc', slice(1,3), 'ix', { 0 : [2,4], 1: [3,6], 2: [4,8] }, typs = ['ints'], fails=KeyError)
+
+        # ok 
+        self.check_result('int slice2', 'loc', slice(2,5), 'ix', [2,4], typs = ['ints'], axes = 0)
+        self.check_result('int slice2', 'loc', slice(3,7), 'ix', [3,6], typs = ['ints'], axes = 1)
+        self.check_result('int slice2', 'loc', slice(4,9), 'ix', [4,8], typs = ['ints'], axes = 2)
+
+    def test_loc_getitem_label_slice(self):
+
+        # label slices (with ints)
+        self.check_result('lab slice', 'loc', slice(1,3), 'ix', slice(1,3), typs = ['labels','mixed','ts','floats','empty'], fails=KeyError)
+
+        # real label slices
+        self.check_result('lab slice', 'loc', slice('a','c'), 'ix', slice('a','c'), typs = ['labels'], axes=0)
+        self.check_result('lab slice', 'loc', slice('A','C'), 'ix', slice('A','C'), typs = ['labels'], axes=1)
+        self.check_result('lab slice', 'loc', slice('W','Z'), 'ix', slice('W','Z'), typs = ['labels'], axes=2)
+
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=0)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2)
+
+        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=0)
+        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=1)
+        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=2)
+
+    def test_loc_setitem(self):
+        df = self.frame_labels
+
+        import pdb; pdb.set_trace()
+        result = df.iloc[0,0]
+
+        df.loc['a','A'] = 1
+        result = df.loc['a','A']
+        self.assert_(result == 1)
+
+        result = df.iloc[0,0]
+        self.assert_(result == 1)
+
+        df.loc[:,'B':'D'] = 0
+        expected = df.loc[:,'B':'D']
+        result = df.ix[:,2:3]
+        assert_frame_equal(result, expected)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],

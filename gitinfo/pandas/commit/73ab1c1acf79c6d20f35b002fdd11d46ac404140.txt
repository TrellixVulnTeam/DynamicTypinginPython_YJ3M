commit 73ab1c1acf79c6d20f35b002fdd11d46ac404140
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Nov 12 20:09:52 2011 -0500

    ENH: group by multiple levels, GH #103

diff --git a/RELEASE.rst b/RELEASE.rst
index 8e2f59f74..53b707384 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -52,6 +52,8 @@ pandas 0.5.1
   - Add `DataFrame.from_dict` with similar `orient` option
   - Can now pass list of tuples or list of lists to `DataFrame.from_records`
     for fast conversion to DataFrame (GH #357)
+  - Can pass multiple levels to groupby, e.g. `df.groupby(level=[0, 1])` (GH
+    #103)
 
 **Improvements to existing features**
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 90a3b1c2c..2f0deec34 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -86,9 +86,9 @@ class PandasObject(Picklable):
             If a dict or Series is passed, the Series or dict VALUES will be
             used to determine the groups
         axis : int, default 0
-        level : int, default None
+        level : int, level name, or sequence of such, default None
             If the axis is a MultiIndex (hierarchical), group by a particular
-            level
+            level or levels
         as_index : boolean, default True
             For aggregated output, return object with group labels as the
             index. Only relevant for DataFrame input. as_index=False is
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 00feb2517..40d01cc6b 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -608,25 +608,29 @@ def _get_groupings(obj, grouper=None, axis=0, level=None):
     if level is not None and not isinstance(group_axis, MultiIndex):
         raise ValueError('can only specify level with multi-level index')
 
+    if not isinstance(grouper, (tuple, list)):
+        groupers = [grouper]
+    else:
+        groupers = grouper
+
+    if isinstance(level, (tuple, list)):
+        if grouper is None:
+            groupers = [None] * len(level)
+        levels = level
+    else:
+        levels = [level] * len(groupers)
+
     groupings = []
     exclusions = []
-    if isinstance(grouper, (tuple, list)):
-        for i, arg in enumerate(grouper):
-            name = 'key_%d' % i
-            if isinstance(arg, basestring):
-                exclusions.append(arg)
-                name = arg
-                arg = obj[arg]
-
-            ping = Grouping(group_axis, arg, name=name, level=level)
-            groupings.append(ping)
-    else:
+    for i, (gpr, level) in enumerate(zip(groupers, levels)):
         name = None
-        if isinstance(grouper, basestring):
-            exclusions.append(grouper)
-            name = grouper
-            grouper = obj[grouper]
-        ping = Grouping(group_axis, grouper, name=name, level=level)
+        if isinstance(gpr, basestring):
+            exclusions.append(gpr)
+            name = gpr
+            gpr = obj[gpr]
+        ping = Grouping(group_axis, gpr, name=name, level=level)
+        if ping.name is None:
+            ping.name = 'key_%d' % i
         groupings.append(ping)
 
     return groupings, exclusions
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 30fd0cb8d..ed5e82801 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -597,6 +597,23 @@ class TestMultiLevel(unittest.TestCase):
                                            skipna=skipna)
             assert_frame_equal(leftside, rightside)
 
+    def test_groupby_multilevel(self):
+        result = self.ymd.groupby(level=[0, 1]).mean()
+
+        k1 = self.ymd.index.get_level_values(0)
+        k2 = self.ymd.index.get_level_values(1)
+
+        expected = self.ymd.groupby([k1, k2]).mean()
+
+        assert_frame_equal(result, expected)
+        self.assertEquals(result.index.names, self.ymd.index.names[:2])
+
+        result2 = self.ymd.groupby(level=self.ymd.index.names[:2]).mean()
+        assert_frame_equal(result, result2)
+
+    def test_groupby_multilevel_with_transform(self):
+        pass
+
 if __name__ == '__main__':
 
     # unittest.main()

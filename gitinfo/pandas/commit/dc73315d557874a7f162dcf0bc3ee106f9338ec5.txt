commit dc73315d557874a7f162dcf0bc3ee106f9338ec5
Author: jreback <jeff@reback.net>
Date:   Mon Aug 19 19:42:48 2013 -0400

    BUG: GH3317 Fix frequency inference to be automatic in a DatetimeIndex if freq is not specified during _ensure_index
    
    PERF: remove automatic downcasting, instead do on-demand via 'downcast=infer'
    
    TST: fix up failing tests
    
    CLN: reindex/fill in internals moved to core/internals/Block/reindex_items_from
    
    PERF: don't automatically downcast with a float block
    
    BUG: GH3317 reverse prior fix in tseries/offsets, to change slightly the multi reindex
    
    TST: identical index tests
    
    BUG: GH4618 provide automatic downcasting on a reindexed with method Series
         (in this case a shifted boolean then filled series)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index ec2117223..932b93a63 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -115,6 +115,8 @@ pandas 0.13
     - ``MultiIndex.astype()`` now only allows ``np.object_``-like dtypes and
       now returns a ``MultiIndex`` rather than an ``Index``. (:issue:`4039`)
 
+  - Infer and downcast dtype if ``downcast='infer'`` is passed to ``fillna/ffill/bfill`` (:issue:`4604`)
+
 **Internal Refactoring**
 
 In 0.13.0 there is a major refactor primarily to subclass ``Series`` from ``NDFrame``,
@@ -183,11 +185,9 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
 
 - Indexing with dtype conversions fixed (:issue:`4463`, :issue:`4204`)
 
-- Refactor Series.reindex to core/generic.py (:issue:`4604`), allow ``method=`` in reindexing
+- Refactor Series.reindex to core/generic.py (:issue:`4604`, :issue:`4618`), allow ``method=`` in reindexing
   on a Series to work
 
-- Infer and downcast dtype if appropriate on ``ffill/bfill`` (:issue:`4604`)
-
 **Experimental Features**
 
 **Bug Fixes**
@@ -259,6 +259,8 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
   - Fix bug in ``pd.read_clipboard`` on windows with PY3 (:issue:`4561`); not decoding properly
   - ``tslib.get_period_field()`` and ``tslib.get_period_field_arr()`` now raise
     if code argument out of range (:issue:`4519`, :issue:`4520`)
+  - Fix reindexing with multiple axes; if an axes match was not replacing the current axes, leading
+    to a possible lazay frequency inference issue (:issue:`3317`)
 
 pandas 0.12
 ===========
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 34733e03d..ffa71cbe9 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -96,6 +96,8 @@ API changes
         # and all methods take an inplace kwarg
         index.set_names(["bob", "cranberry"], inplace=True)
 
+  - Infer and downcast dtype if ``downcast='infer'`` is passed to ``fillna/ffill/bfill`` (:issue:`4604`)
+
 Enhancements
 ~~~~~~~~~~~~
 
@@ -237,11 +239,9 @@ and behaviors. Series formerly subclassed directly from ``ndarray``. (:issue:`40
 
 - Indexing with dtype conversions fixed (:issue:`4463`, :issue:`4204`)
 
-- Refactor Series.reindex to core/generic.py (:issue:`4604`), allow ``method=`` in reindexing
+- Refactor Series.reindex to core/generic.py (:issue:`4604`, :issue:`4618`), allow ``method=`` in reindexing
   on a Series to work
 
-- Infer and downcast dtype if appropriate on ``ffill/bfill`` (:issue:`4604`)
-
 Bug Fixes
 ~~~~~~~~~
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 2bfdaccb3..e46abb4aa 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -990,14 +990,20 @@ def _possibly_downcast_to_dtype(result, dtype):
         if issubclass(dtype.type, np.floating):
             return result.astype(dtype)
         elif dtype == np.bool_ or issubclass(dtype.type, np.integer):
+
+            # do a test on the first element, if it fails then we are done
+            r = result.ravel()
+            arr = np.array([ r[0] ])
+            if (arr != arr.astype(dtype)).item():
+                return result
+
+            # a comparable, e.g. a Decimal may slip in here
+            elif not isinstance(r[0], (np.integer,np.floating,np.bool,int,float,bool)):
+                return result
+
             if issubclass(result.dtype.type, (np.object_,np.number)) and notnull(result).all():
                 new_result = result.astype(dtype)
                 if (new_result == result).all():
-
-                    # a comparable, e.g. a Decimal may slip in here
-                    if not isinstance(result.ravel()[0], (np.integer,np.floating,np.bool,int,float,bool)):
-                        return result
-
                     return new_result
     except:
         pass
@@ -1174,7 +1180,7 @@ def backfill_2d(values, limit=None, mask=None):
         pass
     return values
 
-def interpolate_2d(values, method='pad', axis=0, limit=None, missing=None):
+def interpolate_2d(values, method='pad', axis=0, limit=None, fill_value=None):
     """ perform an actual interpolation of values, values will be make 2-d if needed
         fills inplace, returns the result """
 
@@ -1187,10 +1193,10 @@ def interpolate_2d(values, method='pad', axis=0, limit=None, missing=None):
             raise Exception("cannot interpolate on a ndim == 1 with axis != 0")
         values = values.reshape(tuple((1,) + values.shape))
 
-    if missing is None:
+    if fill_value is None:
         mask = None
     else:  # todo create faster fill func without masking
-        mask = mask_missing(transf(values), missing)
+        mask = mask_missing(transf(values), fill_value)
 
     method = _clean_fill_method(method)
     if method == 'pad':
@@ -1870,6 +1876,7 @@ def _astype_nansafe(arr, dtype, copy=True):
 
 
 def _clean_fill_method(method):
+    if method is None: return None
     method = method.lower()
     if method == 'ffill':
         method = 'pad'
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 200e4ce93..d032bbf66 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2280,12 +2280,9 @@ class DataFrame(NDFrame):
                                            fill_value=fill_value)
             return self._constructor(new_values, index=new_index,
                                      columns=new_columns)
-        elif row_indexer is not None:
-            return self._reindex_with_indexers({0: [new_index,   row_indexer]}, copy=copy, fill_value=fill_value)
-        elif col_indexer is not None:
-            return self._reindex_with_indexers({1: [new_columns, col_indexer]}, copy=copy, fill_value=fill_value)
         else:
-            return self.copy() if copy else self
+            return self._reindex_with_indexers({0: [new_index,   row_indexer],
+                                                1: [new_columns, col_indexer]}, copy=copy, fill_value=fill_value)
 
     def reindex_like(self, other, method=None, copy=True, limit=None,
                      fill_value=NA):
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index f84582457..dccf3c9b8 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -987,7 +987,7 @@ class NDFrame(PandasObject):
 
         # construct the args
         axes, kwargs = self._construct_axes_from_arguments(args, kwargs)
-        method = kwargs.get('method')
+        method = com._clean_fill_method(kwargs.get('method'))
         level = kwargs.get('level')
         copy = kwargs.get('copy', True)
         limit = kwargs.get('limit')
@@ -1082,6 +1082,7 @@ class NDFrame(PandasObject):
 
         axis_name = self._get_axis_name(axis)
         axis_values = self._get_axis(axis_name)
+        method = com._clean_fill_method(method)
         new_index, indexer = axis_values.reindex(labels, method, level,
                                                  limit=limit, copy_if_needed=True)
         return self._reindex_with_indexers({axis: [new_index, indexer]}, method=method, fill_value=fill_value,
@@ -1102,7 +1103,7 @@ class NDFrame(PandasObject):
             # reindex the axis
             if method is not None:
                 new_data = new_data.reindex_axis(
-                    index, method=method, axis=baxis,
+                    index, indexer=indexer, method=method, axis=baxis,
                     fill_value=fill_value, limit=limit, copy=copy)
 
             elif indexer is not None:
@@ -1419,7 +1420,8 @@ class NDFrame(PandasObject):
         limit : int, default None
             Maximum size gap to forward or backward fill
         downcast : dict, default is None, a dict of item->dtype of what to
-            downcast if possible
+            downcast if possible, or the string 'infer' which will try to
+            downcast to an appropriate equal type (e.g. float64 to int64 if possible)
 
         See also
         --------
@@ -1438,6 +1440,7 @@ class NDFrame(PandasObject):
         if axis + 1 > self._AXIS_LEN:
             raise ValueError(
                 "invalid axis passed for object type {0}".format(type(self)))
+        method = com._clean_fill_method(method)
 
         if value is None:
             if method is None:
@@ -1488,13 +1491,13 @@ class NDFrame(PandasObject):
         else:
             return self._constructor(new_data)
 
-    def ffill(self, axis=0, inplace=False, limit=None):
+    def ffill(self, axis=0, inplace=False, limit=None, downcast=None):
         return self.fillna(method='ffill', axis=axis, inplace=inplace,
-                           limit=limit, downcast='infer')
+                           limit=limit, downcast=downcast)
 
-    def bfill(self, axis=0, inplace=False, limit=None):
+    def bfill(self, axis=0, inplace=False, limit=None, downcast=None):
         return self.fillna(method='bfill', axis=axis, inplace=inplace,
-                           limit=limit, downcast='infer')
+                           limit=limit, downcast=downcast)
 
     def replace(self, to_replace=None, value=None, inplace=False, limit=None,
                 regex=False, method=None, axis=None):
@@ -2046,6 +2049,7 @@ class NDFrame(PandasObject):
             Aligned objects
         """
         from pandas import DataFrame, Series
+        method = com._clean_fill_method(method)
 
         if isinstance(other, DataFrame):
             return self._align_frame(other, join=join, axis=axis, level=level,
diff --git a/pandas/core/index.py b/pandas/core/index.py
index aea168654..22bd7f318 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -551,7 +551,7 @@ class Index(FrozenNDArray):
         Similar to equals, but check that other comparable attributes are also equal
         """
         return self.equals(other) and all(
-            [ getattr(self,c,None) == getattr(other,c,None) for c in self._comparables ])
+            ( getattr(self,c,None) == getattr(other,c,None) for c in self._comparables ))
 
     def asof(self, label):
         """
@@ -1555,6 +1555,7 @@ class MultiIndex(Index):
     _names = FrozenList()
     _levels = FrozenList()
     _labels = FrozenList()
+    _comparables = ['names']
 
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None,
                 copy=False):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index fb2776958..ecce50828 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -7,8 +7,8 @@ from collections import defaultdict
 import numpy as np
 from pandas.core.base import PandasObject
 
-from pandas.core.common import (_possibly_downcast_to_dtype, isnull, _NS_DTYPE,
-                                _TD_DTYPE, ABCSeries, ABCSparseSeries,
+from pandas.core.common import (_possibly_downcast_to_dtype, isnull, notnull,
+                                _NS_DTYPE, _TD_DTYPE, ABCSeries, ABCSparseSeries,
                                 is_list_like)
 from pandas.core.index import (Index, MultiIndex, _ensure_index,
                                _handle_legacy_indexes)
@@ -36,6 +36,9 @@ class Block(PandasObject):
     """
     __slots__ = ['items', 'ref_items', '_ref_locs', 'values', 'ndim']
     is_numeric = False
+    is_float = False
+    is_integer = False
+    is_complex = False
     is_bool = False
     is_object = False
     is_sparse = False
@@ -217,24 +220,38 @@ class Block(PandasObject):
         if indexer is None:
             new_ref_items, indexer = self.items.reindex(new_ref_items, limit=limit)
 
+        if fill_value is None:
+            fill_value = self.fill_value
+
         new_items = new_ref_items
         if indexer is None:
             new_values = self.values.copy() if copy else self.values
+
         else:
-            if fill_value is None:
-                fill_value = self.fill_value
 
             # single block reindex
             if self.ndim == 1:
-                new_values = com.take_nd(self.values, indexer, axis=0,
+                new_values = com.take_1d(self.values, indexer,
                                          fill_value=fill_value)
             else:
+
                 masked_idx = indexer[indexer != -1]
                 new_values = com.take_nd(self.values, masked_idx, axis=0,
                                          allow_fill=False)
                 new_items = self.items.take(masked_idx)
 
-        return make_block(new_values, new_items, new_ref_items, ndim=self.ndim, fastpath=True)
+        # fill if needed
+        fill_method = method is not None or limit is not None
+        if fill_method:
+            new_values = com.interpolate_2d(new_values, method=method, limit=limit, fill_value=fill_value)
+
+        block = make_block(new_values, new_items, new_ref_items, ndim=self.ndim, fastpath=True)
+
+        # down cast if needed
+        if not self.is_float and (fill_method or notnull(fill_value)):
+            block = block.downcast()
+
+        return block
 
     def get(self, item):
         loc = self.items.get_loc(item)
@@ -301,36 +318,49 @@ class Block(PandasObject):
         mask = com.isnull(self.values)
         value = self._try_fill(value)
         blocks = self.putmask(mask, value, inplace=inplace)
+        return self._maybe_downcast(blocks, downcast)
 
-        # possibily downcast the blocks
-        if not downcast:
+    def _maybe_downcast(self, blocks, downcast=None):
+
+        # no need to downcast our float
+        # unless indicated
+        if downcast is None and self.is_float:
             return blocks
 
         result_blocks = []
         for b in blocks:
-            result_blocks.extend(b.downcast())
+            result_blocks.extend(b.downcast(downcast))
 
         return result_blocks
 
     def downcast(self, dtypes=None):
         """ try to downcast each item to the dict of dtypes if present """
 
+        # turn it off completely
+        if dtypes is False:
+            return [ self ]
+
         values = self.values
 
         # single block handling
         if self._is_single_block:
+
+            # try to cast all non-floats here
             if dtypes is None:
-                return [ self ]
+                dtypes = 'infer'
 
             nv = _possibly_downcast_to_dtype(values, dtypes)
             return [ make_block(nv, self.items, self.ref_items, ndim=self.ndim, fastpath=True) ]
 
         # ndim > 1
         if dtypes is None:
-            dtypes = dict()
-        elif dtypes == 'infer':
-            pass
+            return [ self ]
+
+        if not (dtypes == 'infer' or isinstance(dtypes, dict)):
+            raise ValueError("downcast must have a dictionary or 'infer' as its argument")
 
+        # item-by-item
+        # this is expensive as it splits the blocks items-by-item
         blocks = []
         for i, item in enumerate(self.items):
 
@@ -618,13 +648,8 @@ class Block(PandasObject):
         values = self.values if inplace else self.values.copy()
         values = com.interpolate_2d(values, method, axis, limit, fill_value)
 
-        block = make_block(values, self.items, self.ref_items, ndim=self.ndim, klass=self.__class__, fastpath=True)
-
-        # try to downcast back to original dtype if we can
-        # as we could have reindexed then down a ffill
-        if downcast is None:
-            downcast = 'infer'
-        return block.downcast(downcast)
+        blocks = [ make_block(values, self.items, self.ref_items, ndim=self.ndim, klass=self.__class__, fastpath=True) ]
+        return self._maybe_downcast(blocks, downcast)
 
     def take(self, indexer, ref_items, axis=1):
         if axis < 1:
@@ -822,6 +847,7 @@ class NumericBlock(Block):
 
 
 class FloatBlock(NumericBlock):
+    is_float = True
     _downcast_dtype = 'int64'
 
     def _can_hold_element(self, element):
@@ -858,6 +884,7 @@ class FloatBlock(NumericBlock):
 
 
 class ComplexBlock(NumericBlock):
+    is_complex = True
 
     def _can_hold_element(self, element):
         return isinstance(element, complex)
@@ -873,6 +900,7 @@ class ComplexBlock(NumericBlock):
 
 
 class IntBlock(NumericBlock):
+    is_integer = True
     _can_hold_na = False
 
     def _can_hold_element(self, element):
@@ -1387,8 +1415,15 @@ class SparseBlock(Block):
         if indexer is None:
             indexer = np.arange(len(self.items))
 
-        # note that we DO NOT FILL HERE
-        return self.make_block(com.take_1d(self.values.values, indexer), items=new_ref_items, ref_items=new_ref_items, copy=copy)
+        new_values = com.take_1d(self.values.values, indexer)
+
+        # fill if needed
+        if method is not None or limit is not None:
+            if fill_value is None:
+                fill_value = self.fill_value
+            new_values = com.interpolate_2d(new_values, method=method, limit=limit, fill_value=fill_value)
+
+        return self.make_block(new_values, items=new_ref_items, ref_items=new_ref_items, copy=copy)
 
     def sparse_reindex(self, new_index):
         """ sparse reindex and return a new block
@@ -2531,7 +2566,7 @@ class BlockManager(PandasObject):
         if item not in self.items:
             raise KeyError('no item named %s' % com.pprint_thing(item))
 
-    def reindex_axis(self, new_axis, method=None, axis=0, fill_value=None, limit=None, copy=True):
+    def reindex_axis(self, new_axis, indexer=None, method=None, axis=0, fill_value=None, limit=None, copy=True):
         new_axis = _ensure_index(new_axis)
         cur_axis = self.axes[axis]
 
@@ -2552,14 +2587,15 @@ class BlockManager(PandasObject):
 
         if axis == 0:
             if method is not None or limit is not None:
-                return self.reindex_axis0_with_method(new_axis, method=method, fill_value=fill_value, limit=limit, copy=copy)
+                return self.reindex_axis0_with_method(new_axis, indexer=indexer,
+                                                      method=method, fill_value=fill_value, limit=limit, copy=copy)
             return self.reindex_items(new_axis, copy=copy, fill_value=fill_value)
 
         new_axis, indexer = cur_axis.reindex(
             new_axis, method, copy_if_needed=True)
         return self.reindex_indexer(new_axis, indexer, axis=axis, fill_value=fill_value)
 
-    def reindex_axis0_with_method(self, new_axis, method=None, fill_value=None, limit=None, copy=True):
+    def reindex_axis0_with_method(self, new_axis, indexer=None, method=None, fill_value=None, limit=None, copy=True):
         raise AssertionError('method argument not supported for '
                              'axis == 0')
 
@@ -2880,12 +2916,9 @@ class SingleBlockManager(BlockManager):
         # if we are the same and don't copy, just return
         if not copy and self.index.equals(new_axis):
             return self
+
         block = self._block.reindex_items_from(new_axis, indexer=indexer, method=method,
                                                fill_value=fill_value, limit=limit, copy=copy)
-
-        if method is not None or limit is not None:
-            block = block.interpolate(method=method, fill_value=fill_value, limit=limit, downcast=self.dtype)
-
         mgr = SingleBlockManager(block, new_axis)
         mgr._consolidate_inplace()
         return mgr
@@ -2894,8 +2927,10 @@ class SingleBlockManager(BlockManager):
         # equiv to a reindex
         return self.reindex(new_items, indexer=indexer, fill_value=fill_value, copy=False)
 
-    def reindex_axis0_with_method(self, new_axis, method=None, fill_value=None, limit=None, copy=True):
-        return self.reindex(new_axis, method=method, fill_value=fill_value, limit=limit, copy=copy)
+    def reindex_axis0_with_method(self, new_axis, indexer=None, method=None, fill_value=None, limit=None, copy=True):
+        if method is None:
+            indexer = None
+        return self.reindex(new_axis, indexer=indexer, method=method, fill_value=fill_value, limit=limit, copy=copy)
 
     def get_slice(self, slobj, raise_on_error=False):
         if raise_on_error:
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 41345352b..787682f34 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -774,7 +774,7 @@ c,4,5
 """
         rs = self.read_csv(
             StringIO(data), index_col='date', parse_dates='date')
-        idx = date_range('1/1/2009', periods=3).asobject
+        idx = date_range('1/1/2009', periods=3)
         idx.name = 'date'
         xp = DataFrame({'A': ['a', 'b', 'c'],
                         'B': [1, 3, 4],
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index ff6334b9f..dd7bd5207 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -471,7 +471,6 @@ class SparseDataFrame(DataFrame):
 
         for col, series in compat.iteritems(this):
             new_data[col] = func(series.values, other.values)
-            #new_data[col] = func(series.as_sparse_array(fill_value=np.nan), other.as_sparse_array(fill_value=np.nan))
 
         # fill_value is a function of our operator
         if isnull(other.fill_value) or isnull(self.default_fill_value):
@@ -576,8 +575,8 @@ class SparseDataFrame(DataFrame):
 
     def _reindex_with_indexers(self, reindexers, method=None, fill_value=np.nan, limit=None, copy=False):
 
-        if limit is not None:
-            raise NotImplementedError("cannot take limit with a sparse tyep")
+        if method is not None or limit is not None:
+            raise NotImplementedError("cannot reindex with a method or limit with sparse")
 
         index,   row_indexer = reindexers.get(0, (None, None))
         columns, col_indexer = reindexers.get(1, (None, None))
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index b84115bd3..1a65eec85 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -4218,8 +4218,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expected = Series([np.nan, True])
         assert_series_equal(result, expected)
 
+        # GH4604, automatic casting here
         result = d['a'].fillna(False) | d['b']
-        expected = Series([True, True], dtype=object)
+        expected = Series([True, True])
+        assert_series_equal(result, expected)
+
+        result = d['a'].fillna(False,downcast=False) | d['b']
+        expected = Series([True, True],dtype=object)
+        assert_series_equal(result, expected)
+
+        result = (d['a'].fillna(False,downcast=False) | d['b']).convert_objects()
+        expected = Series([True, True])
         assert_series_equal(result, expected)
 
     def test_neg(self):
@@ -7411,6 +7420,20 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         newFrame = self.frame.reindex(columns=[])
         self.assert_(newFrame.empty)
 
+    def test_reindex_axes(self):
+
+        # GH 3317, reindexing by both axes loses freq of the index
+        from datetime import datetime
+        df = DataFrame(np.ones((3, 3)), index=[datetime(2012, 1, 1), datetime(2012, 1, 2), datetime(2012, 1, 3)], columns=['a', 'b', 'c'])
+        time_freq = date_range('2012-01-01', '2012-01-03', freq='d')
+        some_cols = ['a', 'b']
+
+        index_freq = df.reindex(index=time_freq).index.freq
+        both_freq = df.reindex(index=time_freq, columns=some_cols).index.freq
+        seq_freq = df.reindex(index=time_freq).reindex(columns=some_cols).index.freq
+        self.assert_(index_freq == both_freq)
+        self.assert_(index_freq == seq_freq)
+
     def test_reindex_fill_value(self):
         df = DataFrame(np.random.randn(10, 4))
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index ae81752c1..16f302689 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -151,6 +151,21 @@ class TestIndex(unittest.TestCase):
         # Must also be an Index
         self.assertFalse(Index(['a', 'b', 'c']).equals(['a', 'b', 'c']))
 
+    def test_identical(self):
+
+        # index
+        i1 = Index(['a', 'b', 'c'])
+        i2 = Index(['a', 'b', 'c'])
+
+        self.assert_(i1.identical(i2))
+
+        i1 = i1.rename('foo')
+        self.assert_(i1.equals(i2))
+        self.assert_(not i1.identical(i2))
+
+        i2 = i2.rename('foo')
+        self.assert_(i1.identical(i2))
+
     def test_asof(self):
         d = self.dateIndex[0]
         self.assert_(self.dateIndex.asof(d) is d)
@@ -660,6 +675,20 @@ class TestInt64Index(unittest.TestCase):
         self.assert_(self.index.equals(same_values))
         self.assert_(same_values.equals(self.index))
 
+    def test_identical(self):
+
+        i = self.index.copy()
+        same_values = Index(i, dtype=object)
+        self.assert_(i.identical(same_values))
+
+        i = self.index.copy()
+        i = i.rename('foo')
+        same_values = Index(i, dtype=object)
+        self.assert_(same_values.identical(self.index))
+
+        self.assertFalse(i.identical(self.index))
+        self.assert_(Index(same_values, name='foo').identical(i))
+
     def test_get_indexer(self):
         target = Int64Index(np.arange(10))
         indexer = self.index.get_indexer(target)
@@ -1604,6 +1633,18 @@ class TestMultiIndex(unittest.TestCase):
                            labels=[major_labels, minor_labels])
         self.assert_(not self.index.equals(index))
 
+    def test_identical(self):
+        mi = self.index.copy()
+        mi2 = self.index.copy()
+        self.assert_(mi.identical(mi2))
+
+        mi = mi.set_names(['new1','new2'])
+        self.assert_(mi.equals(mi2))
+        self.assert_(not mi.identical(mi2))
+
+        mi2 = mi2.set_names(['new1','new2'])
+        self.assert_(mi.identical(mi2))
+
     def test_union(self):
         piece1 = self.index[:5][::-1]
         piece2 = self.index[3:]
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index a015eeb1c..410018575 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -4074,6 +4074,9 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
 
         # this changes dtype because the ffill happens after
         result = s.reindex(new_index).ffill()
+        assert_series_equal(result, expected.astype('float64'))
+
+        result = s.reindex(new_index).ffill(downcast='infer')
         assert_series_equal(result, expected)
 
         # this preserves dtype
@@ -4087,6 +4090,12 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         expected = Series([True,True,False],index=list(new_index))
         assert_series_equal(result, expected)
 
+        # GH4618 shifted series downcasting
+        s = Series(False,index=lrange(0,5))
+        result = s.shift(1).fillna(method='bfill')
+        expected = Series(False,index=lrange(0,5))
+        assert_series_equal(result, expected)
+
     def test_reindex_backfill(self):
         pass
 
diff --git a/pandas/tools/pivot.py b/pandas/tools/pivot.py
index 9bca698cd..c11ec9f33 100644
--- a/pandas/tools/pivot.py
+++ b/pandas/tools/pivot.py
@@ -129,7 +129,7 @@ def pivot_table(data, values=None, rows=None, cols=None, aggfunc='mean',
             table = table.sort_index(axis=1)
 
     if fill_value is not None:
-        table = table.fillna(value=fill_value, downcast=True)
+        table = table.fillna(value=fill_value, downcast='infer')
 
     if margins:
         table = _add_margins(table, data, values, rows=rows,
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 7e54d6ebc..1b5c9a8b5 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -155,6 +155,8 @@ class DatetimeIndex(Int64Index):
 
         freq_infer = False
         if not isinstance(freq, DateOffset):
+
+            # if a passed freq is None, don't infer automatically
             if freq != 'infer':
                 freq = to_offset(freq)
             else:
diff --git a/pandas/tseries/tests/test_daterange.py b/pandas/tseries/tests/test_daterange.py
index 536d718d7..d17b42c1e 100644
--- a/pandas/tseries/tests/test_daterange.py
+++ b/pandas/tseries/tests/test_daterange.py
@@ -316,6 +316,23 @@ class TestDateRange(unittest.TestCase):
     def test_equals(self):
         self.assertFalse(self.rng.equals(list(self.rng)))
 
+    def test_identical(self):
+        t1 = self.rng.copy()
+        t2 = self.rng.copy()
+        self.assert_(t1.identical(t2))
+
+        # name
+        t1 = t1.rename('foo')
+        self.assert_(t1.equals(t2))
+        self.assert_(not t1.identical(t2))
+        t2 = t2.rename('foo')
+        self.assert_(t1.identical(t2))
+
+        # freq
+        t2v = Index(t2.values)
+        self.assert_(t1.equals(t2v))
+        self.assert_(not t1.identical(t2v))
+
     def test_daterange_bug_456(self):
         # GH #456
         rng1 = bdate_range('12/5/2011', '12/5/2011')
diff --git a/vb_suite/reindex.py b/vb_suite/reindex.py
index acf8f6f04..de0f39733 100644
--- a/vb_suite/reindex.py
+++ b/vb_suite/reindex.py
@@ -51,7 +51,7 @@ reindex_multi = Benchmark(statement, setup,
 # Pad / backfill
 
 setup = common_setup + """
-rng = DateRange('1/1/2000', periods=10000, offset=datetools.Minute())
+rng = DateRange('1/1/2000', periods=100000, offset=datetools.Minute())
 
 ts = Series(np.random.randn(len(rng)), index=rng)
 ts2 = ts[::2]

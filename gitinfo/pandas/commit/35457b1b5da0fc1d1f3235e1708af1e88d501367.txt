commit 35457b1b5da0fc1d1f3235e1708af1e88d501367
Author: Jeff Reback <jeff@reback.net>
Date:   Sun Jan 3 11:10:36 2016 -0500

    PEP fixes, remove _add_time_format

diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index 528dd2e05..a24cee785 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -266,19 +266,20 @@ other anchored offsets like ``MonthBegin`` and ``YearBegin``.
 Other API Changes
 ^^^^^^^^^^^^^^^^^
 
-- ``DataFrame.between_time`` and ``Series.between_time`` now only parse a fixed set of time strings.  Parsing
-of date strings is no longer supported and raises a ValueError. (:issue:`11818`)
+- ``DataFrame.between_time`` and ``Series.between_time`` now only parse a fixed set of time strings. Parsing
+of date strings is no longer supported and raises a ``ValueError``. (:issue:`11818`)
 
-.. code-block:: python
+  .. ipython:: python
+
+     s = pd.Series(range(10), pd.date_range('2015-01-01', freq='H', periods=10))
+     s.between_time("7:00am", "9:00am")
 
-   In [3]: s = pd.Series(range(10), pd.date_range('2015-01-01', freq='H', periods=10))
+  This will now raise.
+
+  .. code-block:: python
 
-   In [4]: s.between_time("7:00am", "9:00am")
-   Out[4]:
-   2015-01-01 07:00:00    7
-   2015-01-01 08:00:00    8
-   2015-01-01 09:00:00    9
-   Freq: H, dtype: int64
+     In [2]: s.between_time('20150101 07:00:00','20150101 09:00:00')
+     ValueError: Cannot convert arg ['20150101 07:00:00'] to a time.
 
 
 
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 96aeb8b37..f2d0b5045 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -87,7 +87,7 @@ class TestTimeSeriesDuplicates(tm.TestCase):
         self.assertEqual(idx.nunique(dropna=False), 21)
 
         arr = [Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for
-               t in range(20) ] + [NaT]
+               t in range(20)] + [NaT]
         idx = DatetimeIndex(arr * 3)
         self.assertTrue(idx.unique().equals(DatetimeIndex(arr)))
         self.assertEqual(idx.nunique(), 20)
@@ -254,30 +254,30 @@ class TestTimeSeriesDuplicates(tm.TestCase):
         # GH3546 (not including times on the last day)
         idx = date_range(start='2013-05-31 00:00', end='2013-05-31 23:00',
                          freq='H')
-        ts  = Series(lrange(len(idx)), index=idx)
+        ts = Series(lrange(len(idx)), index=idx)
         expected = ts['2013-05']
         assert_series_equal(expected, ts)
 
         idx = date_range(start='2013-05-31 00:00', end='2013-05-31 23:59',
                          freq='S')
-        ts  = Series(lrange(len(idx)), index=idx)
+        ts = Series(lrange(len(idx)), index=idx)
         expected = ts['2013-05']
-        assert_series_equal(expected,ts)
+        assert_series_equal(expected, ts)
 
         idx = [Timestamp('2013-05-31 00:00'),
-               Timestamp(datetime(2013,5,31,23,59,59,999999))]
+               Timestamp(datetime(2013, 5, 31, 23, 59, 59, 999999))]
         ts = Series(lrange(len(idx)), index=idx)
         expected = ts['2013']
-        assert_series_equal(expected,ts)
+        assert_series_equal(expected, ts)
 
         # GH 3925, indexing with a seconds resolution string / datetime object
-        df = DataFrame(randn(5,5),
+        df = DataFrame(randn(5, 5),
                        columns=['open', 'high', 'low', 'close', 'volume'],
                        index=date_range('2012-01-02 18:01:00',
                                         periods=5, tz='US/Central', freq='s'))
         expected = df.loc[[df.index[2]]]
         result = df['2012-01-02 18:01:02']
-        assert_frame_equal(result,expected)
+        assert_frame_equal(result, expected)
 
         # this is a single date, so will raise
         self.assertRaises(KeyError, df.__getitem__, df.index[2],)
diff --git a/pandas/tseries/tests/test_tslib.py b/pandas/tseries/tests/test_tslib.py
index 111a848a2..ba43537ee 100644
--- a/pandas/tseries/tests/test_tslib.py
+++ b/pandas/tseries/tests/test_tslib.py
@@ -127,33 +127,37 @@ class TestTimestamp(tm.TestCase):
                 self.assertEqual(result.value, expected_utc)
                 self.assertEqual(tslib.pydt_to_i8(result), expected_utc)
 
-        # This should be 2013-11-01 05:00 in UTC -> converted to Chicago tz
+        # This should be 2013-11-01 05:00 in UTC
+        # converted to Chicago tz
         result = Timestamp('2013-11-01 00:00:00-0500', tz='America/Chicago')
         self.assertEqual(result.value, Timestamp('2013-11-01 05:00').value)
-        expected_repr = "Timestamp('2013-11-01 00:00:00-0500', tz='America/Chicago')"
-        self.assertEqual(repr(result), expected_repr)
+        expected = "Timestamp('2013-11-01 00:00:00-0500', tz='America/Chicago')"  # noqa
+        self.assertEqual(repr(result), expected)
         self.assertEqual(result, eval(repr(result)))
 
-        # This should be 2013-11-01 05:00 in UTC -> converted to Tokyo tz (+09:00)
+        # This should be 2013-11-01 05:00 in UTC
+        # converted to Tokyo tz (+09:00)
         result = Timestamp('2013-11-01 00:00:00-0500', tz='Asia/Tokyo')
         self.assertEqual(result.value, Timestamp('2013-11-01 05:00').value)
-        expected_repr = "Timestamp('2013-11-01 14:00:00+0900', tz='Asia/Tokyo')"
-        self.assertEqual(repr(result), expected_repr)
+        expected = "Timestamp('2013-11-01 14:00:00+0900', tz='Asia/Tokyo')"
+        self.assertEqual(repr(result), expected)
         self.assertEqual(result, eval(repr(result)))
-        
+
         # GH11708
-        # This should be 2015-11-18 10:00 in UTC -> converted to Asia/Katmandu tz
+        # This should be 2015-11-18 10:00 in UTC
+        # converted to Asia/Katmandu
         result = Timestamp("2015-11-18 15:45:00+05:45", tz="Asia/Katmandu")
         self.assertEqual(result.value, Timestamp("2015-11-18 10:00").value)
-        expected_repr = "Timestamp('2015-11-18 15:45:00+0545', tz='Asia/Katmandu')"
-        self.assertEqual(repr(result), expected_repr)
+        expected = "Timestamp('2015-11-18 15:45:00+0545', tz='Asia/Katmandu')"
+        self.assertEqual(repr(result), expected)
         self.assertEqual(result, eval(repr(result)))
-        
-        # This should be 2015-11-18 10:00 in UTC -> converted to Asia/Kolkata tz
+
+        # This should be 2015-11-18 10:00 in UTC
+        # converted to Asia/Kolkata
         result = Timestamp("2015-11-18 15:30:00+05:30", tz="Asia/Kolkata")
         self.assertEqual(result.value, Timestamp("2015-11-18 10:00").value)
-        expected_repr = "Timestamp('2015-11-18 15:30:00+0530', tz='Asia/Kolkata')"
-        self.assertEqual(repr(result), expected_repr)
+        expected = "Timestamp('2015-11-18 15:30:00+0530', tz='Asia/Kolkata')"
+        self.assertEqual(repr(result), expected)
         self.assertEqual(result, eval(repr(result)))
 
     def test_constructor_invalid(self):
@@ -629,8 +633,6 @@ class TestDatetimeParsingWrappers(tm.TestCase):
         new_string = "14.15"
         self.assertRaises(ValueError, tools.to_time, new_string)
         self.assertEqual(tools.to_time(new_string, format="%H.%M"), expected)
-        tools.add_time_format("%H.%M")
-        self.assertEqual(tools.to_time(new_string), expected)
 
         arg = ["14:15", "20:20"]
         expected_arr = [datetime.time(14, 15), datetime.time(20, 20)]
@@ -681,15 +683,17 @@ class TestDatetimeParsingWrappers(tm.TestCase):
             self.assertEqual(result, exp)
 
     def test_parsers_timezone_minute_offsets_roundtrip(self):
-        #GH11708
+        # GH11708
         base = to_datetime("2013-01-01 00:00:00")
-        dt_strings = [('2013-01-01 05:45+0545', 
-                       "Asia/Katmandu",
-                       "Timestamp('2013-01-01 05:45:00+0545', tz='Asia/Katmandu')"),
-                      ('2013-01-01 05:30+0530', 
-                       "Asia/Kolkata",
-                       "Timestamp('2013-01-01 05:30:00+0530', tz='Asia/Kolkata')")]
-        
+        dt_strings = [
+            ('2013-01-01 05:45+0545',
+             "Asia/Katmandu",
+             "Timestamp('2013-01-01 05:45:00+0545', tz='Asia/Katmandu')"),
+            ('2013-01-01 05:30+0530',
+             "Asia/Kolkata",
+             "Timestamp('2013-01-01 05:30:00+0530', tz='Asia/Kolkata')")
+        ]
+
         for dt_string, tz, dt_string_repr in dt_strings:
             dt_time = to_datetime(dt_string)
             self.assertEqual(base, dt_time)
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index f2233d19f..795e125da 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -365,11 +365,15 @@ def _to_datetime(arg, errors='raise', dayfirst=False, yearfirst=False,
 
             if result is None and (format is None or infer_datetime_format):
                 result = tslib.array_to_datetime(
-                            arg, errors=errors,
-                            utc=utc, dayfirst=dayfirst,
-                            yearfirst=yearfirst,
-                            freq=freq, unit=unit,
-                            require_iso8601=require_iso8601)
+                    arg,
+                    errors=errors,
+                    utc=utc,
+                    dayfirst=dayfirst,
+                    yearfirst=yearfirst,
+                    freq=freq,
+                    unit=unit,
+                    require_iso8601=require_iso8601
+                )
 
             if com.is_datetime64_dtype(result) and box:
                 result = DatetimeIndex(result,
@@ -413,9 +417,10 @@ def _attempt_YYYYMMDD(arg, errors):
     def calc(carg):
         # calculate the actual result
         carg = carg.astype(object)
-        return tslib.array_to_datetime(
-                lib.try_parse_year_month_day(carg/10000, carg/100 % 100,
-                                             carg % 100), errors=errors)
+        parsed = lib.try_parse_year_month_day(carg/10000,
+                                              carg/100 % 100,
+                                              carg % 100)
+        return tslib.array_to_datetime(parsed, errors=errors)
 
     def calc_with_mask(carg, mask):
         result = np.empty(carg.shape, dtype='M8[ns]')
@@ -494,10 +499,6 @@ _time_formats = ["%H:%M", "%H%M", "%I:%M%p", "%I%M%p",
                  "%H:%M:%S", "%H%M%S", "%I:%M:%S%p", "%I%M%S%p"]
 
 
-def add_time_format(time_format):
-    _time_formats.append(time_format)
-
-
 def _guess_time_format_for_array(arr):
     # Try to guess the format based on the first non-NaN element
     non_nan_elements = com.notnull(arr).nonzero()[0]
@@ -527,7 +528,7 @@ def to_time(arg, format=None, infer_time_format=False, errors='raise'):
     arg : string in time format, datetime.time, list, tuple, 1-d array,  Series
     format : str, default None
         Format used to convert arg into a time object.  If None, fixed formats
-        are used.  Use tools.add_time_format to add an additional fixed format.
+        are used.
     infer_time_format: bool, default False
         Infer the time format based on the first non-NaN element.  If all
         strings are in the same format, this will speed up conversion.
@@ -580,8 +581,8 @@ def to_time(arg, format=None, infer_time_format=False, errors='raise'):
                                                         time_format).time()
                         if not format_found:
                             # Put the found format in front
-                            formats.insert(0, formats.pop(
-                                              formats.index(time_format)))
+                            fmt = formats.pop(formats.index(time_format))
+                            formats.insert(0, fmt)
                             format_found = True
                         break
                     except (ValueError, TypeError):
@@ -590,8 +591,8 @@ def to_time(arg, format=None, infer_time_format=False, errors='raise'):
                 if time_object is not None:
                     times.append(time_object)
                 elif errors == 'raise':
-                    raise ValueError("Cannot convert arg %s to a time.  Pass "
-                                     "in format or add default format." % arg)
+                    raise ValueError("Cannot convert arg {arg} to "
+                                     "a time".format(arg=arg))
                 elif errors == 'ignore':
                     return arg
                 else:

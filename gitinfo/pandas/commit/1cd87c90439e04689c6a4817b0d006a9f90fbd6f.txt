commit 1cd87c90439e04689c6a4817b0d006a9f90fbd6f
Author: Christopher C. Aycock <christopher.aycock@twosigma.com>
Date:   Fri Feb 26 11:00:32 2016 -0500

    ENH: replace uses of np.isscalar with pd.lib.isscalar
    
    closes #8708
    closes #12459

diff --git a/pandas/computation/ops.py b/pandas/computation/ops.py
index 0d528de9f..b80823de6 100644
--- a/pandas/computation/ops.py
+++ b/pandas/computation/ops.py
@@ -10,6 +10,7 @@ import numpy as np
 import pandas as pd
 from pandas.compat import PY3, string_types, text_type
 import pandas.core.common as com
+import pandas.lib as lib
 from pandas.core.base import StringMixin
 from pandas.computation.common import _ensure_decoded, _result_type_many
 from pandas.computation.scope import _DEFAULT_GLOBALS
@@ -98,7 +99,7 @@ class Term(StringMixin):
 
     @property
     def isscalar(self):
-        return np.isscalar(self._value)
+        return lib.isscalar(self._value)
 
     @property
     def type(self):
diff --git a/pandas/computation/tests/test_eval.py b/pandas/computation/tests/test_eval.py
index 43d2faac3..b70252ed9 100644
--- a/pandas/computation/tests/test_eval.py
+++ b/pandas/computation/tests/test_eval.py
@@ -30,6 +30,7 @@ from pandas.computation.ops import (_binary_ops_dict,
 
 import pandas.computation.expr as expr
 import pandas.util.testing as tm
+import pandas.lib as lib
 from pandas.util.testing import (assert_frame_equal, randbool,
                                  assertRaisesRegexp, assert_numpy_array_equal,
                                  assert_produces_warning, assert_series_equal)
@@ -196,7 +197,7 @@ class TestEvalNumexprPandas(tm.TestCase):
         ex = '(lhs {cmp1} rhs) {binop} (lhs {cmp2} rhs)'.format(cmp1=cmp1,
                                                                 binop=binop,
                                                                 cmp2=cmp2)
-        scalar_with_in_notin = (np.isscalar(rhs) and (cmp1 in skip_these or
+        scalar_with_in_notin = (lib.isscalar(rhs) and (cmp1 in skip_these or
                                                       cmp2 in skip_these))
         if scalar_with_in_notin:
             with tm.assertRaises(TypeError):
@@ -327,7 +328,7 @@ class TestEvalNumexprPandas(tm.TestCase):
         expected = self.get_expected_pow_result(lhs, rhs)
         result = pd.eval(ex, engine=self.engine, parser=self.parser)
 
-        if (np.isscalar(lhs) and np.isscalar(rhs) and
+        if (lib.isscalar(lhs) and lib.isscalar(rhs) and
                 _is_py3_complex_incompat(result, expected)):
             self.assertRaises(AssertionError, tm.assert_numpy_array_equal,
                               result, expected)
@@ -360,16 +361,16 @@ class TestEvalNumexprPandas(tm.TestCase):
         skip_these = 'in', 'not in'
         ex = '~(lhs {0} rhs)'.format(cmp1)
 
-        if np.isscalar(rhs) and cmp1 in skip_these:
+        if lib.isscalar(rhs) and cmp1 in skip_these:
             self.assertRaises(TypeError, pd.eval, ex, engine=self.engine,
                               parser=self.parser, local_dict={'lhs': lhs,
                                                               'rhs': rhs})
         else:
             # compound
-            if np.isscalar(lhs) and np.isscalar(rhs):
+            if lib.isscalar(lhs) and lib.isscalar(rhs):
                 lhs, rhs = map(lambda x: np.array([x]), (lhs, rhs))
             expected = _eval_single_bin(lhs, cmp1, rhs, self.engine)
-            if np.isscalar(expected):
+            if lib.isscalar(expected):
                 expected = not expected
             else:
                 expected = ~expected
@@ -639,17 +640,17 @@ class TestEvalNumexprPandas(tm.TestCase):
         x = 1
         result = pd.eval('x', engine=self.engine, parser=self.parser)
         self.assertEqual(result, 1)
-        self.assertTrue(np.isscalar(result))
+        self.assertTrue(lib.isscalar(result))
 
         x = 1.5
         result = pd.eval('x', engine=self.engine, parser=self.parser)
         self.assertEqual(result, 1.5)
-        self.assertTrue(np.isscalar(result))
+        self.assertTrue(lib.isscalar(result))
 
         x = False
         result = pd.eval('x', engine=self.engine, parser=self.parser)
         self.assertEqual(result, False)
-        self.assertTrue(np.isscalar(result))
+        self.assertTrue(lib.isscalar(result))
 
         x = np.array([1])
         result = pd.eval('x', engine=self.engine, parser=self.parser)
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 2c70da413..ad1efa21e 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -468,7 +468,7 @@ def quantile(x, q, interpolation_method='fraction'):
 
         return score
 
-    if np.isscalar(q):
+    if lib.isscalar(q):
         return _get_score(q)
     else:
         q = np.asarray(q, np.float64)
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 23740f198..35fa06ce5 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -1901,7 +1901,7 @@ def _convert_to_list_like(list_like):
     if (is_sequence(list_like) or isinstance(list_like, tuple) or
             isinstance(list_like, types.GeneratorType)):
         return list(list_like)
-    elif np.isscalar(list_like):
+    elif lib.isscalar(list_like):
         return [list_like]
     else:
         # is this reached?
diff --git a/pandas/core/common.py b/pandas/core/common.py
index b95b44a03..05bcb53d8 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -333,7 +333,7 @@ def notnull(obj):
     pandas.isnull : boolean inverse of pandas.notnull
     """
     res = isnull(obj)
-    if np.isscalar(res):
+    if lib.isscalar(res):
         return not res
     return ~res
 
@@ -343,7 +343,7 @@ def is_null_datelike_scalar(other):
     but guard against passing a non-scalar """
     if other is pd.NaT or other is None:
         return True
-    elif np.isscalar(other):
+    elif lib.isscalar(other):
 
         # a timedelta
         if hasattr(other, 'dtype'):
@@ -489,7 +489,7 @@ def mask_missing(arr, values_to_mask):
 
             # if x is a string and arr is not, then we get False and we must
             # expand the mask to size arr.shape
-            if np.isscalar(mask):
+            if lib.isscalar(mask):
                 mask = np.zeros(arr.shape, dtype=bool)
         else:
 
@@ -1276,7 +1276,7 @@ def _maybe_upcast_putmask(result, mask, other):
 
             # we have a scalar or len 0 ndarray
             # and its nan and we are changing some values
-            if (np.isscalar(other) or
+            if (lib.isscalar(other) or
                     (isinstance(other, np.ndarray) and other.ndim < 1)):
                 if isnull(other):
                     return changeit()
@@ -1336,7 +1336,7 @@ def _possibly_downcast_to_dtype(result, dtype):
     or could be an astype of float64->float32
     """
 
-    if np.isscalar(result):
+    if lib.isscalar(result):
         return result
 
     def trans(x):
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index f850bfba4..13e4de0e2 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -898,7 +898,7 @@ class NDFrame(PandasObject):
         v = self.squeeze()
         if isinstance(v, (bool, np.bool_)):
             return bool(v)
-        elif np.isscalar(v):
+        elif lib.isscalar(v):
             raise ValueError("bool cannot act on a non-boolean single element "
                              "{0}".format(self.__class__.__name__))
 
@@ -1750,10 +1750,10 @@ class NDFrame(PandasObject):
                 else:
                     return self.take(loc, axis=axis, convert=True)
 
-            if not np.isscalar(loc):
+            if not lib.isscalar(loc):
                 new_index = self.index[loc]
 
-        if np.isscalar(loc):
+        if lib.isscalar(loc):
             from pandas import Series
             new_values = self._data.fast_xs(loc)
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 8c277568c..06f3e0409 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -712,7 +712,7 @@ class _GroupBy(PandasObject, SelectionMixin):
         else:
             dtype = obj.dtype
 
-        if not np.isscalar(result):
+        if not lib.isscalar(result):
             result = _possibly_downcast_to_dtype(result, dtype)
 
         return result
@@ -2384,7 +2384,8 @@ def _get_grouper(obj, key=None, axis=0, level=None, sort=True):
 
 
 def _is_label_like(val):
-    return isinstance(val, compat.string_types) or np.isscalar(val)
+    return (isinstance(val, compat.string_types) or
+            (val is not None and lib.isscalar(val)))
 
 
 def _convert_grouper(axis, grouper):
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 22185c567..f0f5507bc 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -4,6 +4,7 @@ from pandas.core.index import Index, MultiIndex
 from pandas.compat import range, zip
 import pandas.compat as compat
 import pandas.core.common as com
+import pandas.lib as lib
 from pandas.core.common import (is_bool_indexer, is_integer_dtype,
                                 _asarray_tuplesafe, is_list_like, isnull,
                                 is_null_slice, is_full_slice, ABCSeries,
@@ -67,7 +68,7 @@ class _NDFrameIndexer(object):
         if type(key) is tuple:
             try:
                 values = self.obj.get_value(*key)
-                if np.isscalar(values):
+                if lib.isscalar(values):
                     return values
             except Exception:
                 pass
@@ -677,7 +678,7 @@ class _NDFrameIndexer(object):
 
                     return ser
 
-        elif np.isscalar(indexer):
+        elif lib.isscalar(indexer):
             ax = self.obj._get_axis(1)
 
             if ser.index.equals(ax):
@@ -753,7 +754,7 @@ class _NDFrameIndexer(object):
                 val = df.reindex(index=ax)._values
             return val
 
-        elif np.isscalar(indexer) and is_panel:
+        elif lib.isscalar(indexer) and is_panel:
             idx = self.obj.axes[1]
             cols = self.obj.axes[2]
 
@@ -960,7 +961,7 @@ class _NDFrameIndexer(object):
             axis += 1
 
             # if we have a scalar, we are done
-            if np.isscalar(obj) or not hasattr(obj, 'ndim'):
+            if lib.isscalar(obj) or not hasattr(obj, 'ndim'):
                 break
 
             # has the dim of the obj changed?
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 8563481c8..4bc8e081a 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -665,7 +665,7 @@ class Block(PandasObject):
                 if arr_value.ndim == 1:
                     if not isinstance(indexer, tuple):
                         indexer = tuple([indexer])
-                    return all([np.isscalar(idx) for idx in indexer])
+                    return all([lib.isscalar(idx) for idx in indexer])
                 return False
 
             def _is_empty_indexer(indexer):
@@ -702,7 +702,7 @@ class Block(PandasObject):
                 values[indexer] = value
 
             # coerce and try to infer the dtypes of the result
-            if np.isscalar(value):
+            if lib.isscalar(value):
                 dtype, _ = _infer_dtype_from_scalar(value)
             else:
                 dtype = 'infer'
@@ -3209,7 +3209,7 @@ class BlockManager(PandasObject):
                 indexer = np.arange(len(self.items))[isnull(self.items)]
 
                 # allow a single nan location indexer
-                if not np.isscalar(indexer):
+                if not lib.isscalar(indexer):
                     if len(indexer) == 1:
                         loc = indexer.item()
                     else:
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index db6488b1f..f390e3f04 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -351,7 +351,7 @@ def _get_counts_nanvar(mask, axis, ddof, dtype=float):
     d = count - dtype.type(ddof)
 
     # always return NaN, never inf
-    if np.isscalar(count):
+    if lib.isscalar(count):
         if count <= ddof:
             count = np.nan
             d = np.nan
@@ -623,7 +623,7 @@ def _get_counts(mask, axis, dtype=float):
         return dtype.type(mask.size - mask.sum())
 
     count = mask.shape[axis] - mask.sum(axis)
-    if np.isscalar(count):
+    if lib.isscalar(count):
         return dtype.type(count)
     try:
         return count.astype(dtype)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index e0989574d..0abc154f4 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -576,7 +576,7 @@ class Panel(NDFrame):
                                  'object was {1}'.format(
                                      shape[1:], tuple(map(int, value.shape))))
             mat = np.asarray(value)
-        elif np.isscalar(value):
+        elif lib.isscalar(value):
             dtype, value = _infer_dtype_from_scalar(value)
             mat = np.empty(shape[1:], dtype=dtype)
             mat.fill(value)
@@ -703,7 +703,7 @@ class Panel(NDFrame):
             return self._combine_panel(other, func)
         elif isinstance(other, DataFrame):
             return self._combine_frame(other, func, axis=axis)
-        elif np.isscalar(other):
+        elif lib.isscalar(other):
             return self._combine_const(other, func)
         else:
             raise NotImplementedError("%s is not supported in combine "
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1e5e0f6fb..5eb1ab0f1 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -559,7 +559,7 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
         try:
             result = self.index.get_value(self, key)
 
-            if not np.isscalar(result):
+            if not lib.isscalar(result):
                 if is_list_like(result) and not isinstance(result, Series):
 
                     # we need to box if we have a non-unique index here
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index ad3975540..c1ab46956 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -331,7 +331,7 @@ def str_repeat(arr, repeats):
     -------
     repeated : Series/Index of objects
     """
-    if np.isscalar(repeats):
+    if lib.isscalar(repeats):
 
         def rep(x):
             try:
diff --git a/pandas/indexes/base.py b/pandas/indexes/base.py
index e6b5271d8..8a679b157 100644
--- a/pandas/indexes/base.py
+++ b/pandas/indexes/base.py
@@ -260,7 +260,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         elif hasattr(data, '__array__'):
             return Index(np.asarray(data), dtype=dtype, copy=copy, name=name,
                          **kwargs)
-        elif data is None or np.isscalar(data):
+        elif data is None or lib.isscalar(data):
             cls._scalar_data_error(data)
         else:
             if (tupleize_cols and isinstance(data, list) and data and
@@ -486,7 +486,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         """
 
         if not isinstance(data, (np.ndarray, Index)):
-            if data is None or np.isscalar(data):
+            if data is None or lib.isscalar(data):
                 cls._scalar_data_error(data)
 
             # other iterable of some kind
@@ -1269,7 +1269,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         getitem = self._data.__getitem__
         promote = self._shallow_copy
 
-        if np.isscalar(key):
+        if lib.isscalar(key):
             return getitem(key)
 
         if isinstance(key, slice):
@@ -1282,7 +1282,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
 
         key = _values_from_object(key)
         result = getitem(key)
-        if not np.isscalar(result):
+        if not lib.isscalar(result):
             return promote(result)
         else:
             return result
@@ -1941,7 +1941,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
                 raise e1
         except TypeError:
             # python 3
-            if np.isscalar(key):  # pragma: no cover
+            if lib.isscalar(key):  # pragma: no cover
                 raise IndexError(key)
             raise InvalidIndexError(key)
 
diff --git a/pandas/indexes/multi.py b/pandas/indexes/multi.py
index 8138f2deb..fea153b2d 100644
--- a/pandas/indexes/multi.py
+++ b/pandas/indexes/multi.py
@@ -978,7 +978,7 @@ class MultiIndex(Index):
         self._reset_identity()
 
     def __getitem__(self, key):
-        if np.isscalar(key):
+        if lib.isscalar(key):
             retval = []
             for lev, lab in zip(self.levels, self.labels):
                 if lab[key] == -1:
diff --git a/pandas/indexes/numeric.py b/pandas/indexes/numeric.py
index c18171291..0c102637a 100644
--- a/pandas/indexes/numeric.py
+++ b/pandas/indexes/numeric.py
@@ -295,7 +295,7 @@ class Float64Index(NumericIndex):
 
     def get_value(self, series, key):
         """ we always want to get an index value, never a value """
-        if not np.isscalar(key):
+        if not lib.isscalar(key):
             raise InvalidIndexError
 
         from pandas.core.indexing import maybe_droplevels
@@ -305,7 +305,7 @@ class Float64Index(NumericIndex):
         loc = self.get_loc(k)
         new_values = com._values_from_object(series)[loc]
 
-        if np.isscalar(new_values) or new_values is None:
+        if lib.isscalar(new_values) or new_values is None:
             return new_values
 
         new_index = self[loc]
diff --git a/pandas/indexes/range.py b/pandas/indexes/range.py
index ca12a06b4..0bed2ec23 100644
--- a/pandas/indexes/range.py
+++ b/pandas/indexes/range.py
@@ -10,6 +10,7 @@ from pandas.indexes.base import Index
 from pandas.util.decorators import Appender, cache_readonly
 import pandas.core.common as com
 import pandas.indexes.base as ibase
+import pandas.lib as lib
 
 from pandas.indexes.numeric import Int64Index
 
@@ -440,7 +441,7 @@ class RangeIndex(Int64Index):
         """
         super_getitem = super(RangeIndex, self).__getitem__
 
-        if np.isscalar(key):
+        if lib.isscalar(key):
             n = int(key)
             if n != key:
                 return super_getitem(key)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index d39540af2..f7b38c75a 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -856,7 +856,7 @@ class ParserBase(object):
             name = self.index_names[i]
             j = self.index_col[i]
 
-            if np.isscalar(self.parse_dates):
+            if lib.isscalar(self.parse_dates):
                 return (j == self.parse_dates) or (name == self.parse_dates)
             else:
                 return (j in self.parse_dates) or (name in self.parse_dates)
@@ -2144,7 +2144,7 @@ def _process_date_conversion(data_dict, converter, parse_spec,
     if isinstance(parse_spec, list):
         # list of column lists
         for colspec in parse_spec:
-            if np.isscalar(colspec):
+            if lib.isscalar(colspec):
                 if isinstance(colspec, int) and colspec not in data_dict:
                     colspec = orig_names[colspec]
                 if _isindex(colspec):
diff --git a/pandas/lib.pyx b/pandas/lib.pyx
index f7978c479..a6d6ea50c 100644
--- a/pandas/lib.pyx
+++ b/pandas/lib.pyx
@@ -312,6 +312,8 @@ def isscalar(object val):
     return (np.PyArray_IsAnyScalar(val)
             # As of numpy-1.9, PyArray_IsAnyScalar misses bytearrays on Py3.
             or PyBytes_Check(val)
+            # We differ from numpy (as of 1.10), which claims that None is
+            # not scalar in np.isscalar().
             or val is None
             or PyDate_Check(val)
             or PyDelta_Check(val)
diff --git a/pandas/sparse/array.py b/pandas/sparse/array.py
index a370bcf42..4d8ec61e8 100644
--- a/pandas/sparse/array.py
+++ b/pandas/sparse/array.py
@@ -37,7 +37,7 @@ def _arith_method(op, name, str_rep=None, default_axis=None, fill_zeros=None,
                 return _sparse_array_op(other, self, op, name[1:])
             else:
                 return _sparse_array_op(self, other, op, name)
-        elif np.isscalar(other):
+        elif lib.isscalar(other):
             new_fill_value = op(np.float64(self.fill_value), np.float64(other))
 
             return SparseArray(op(self.sp_values, other),
@@ -121,7 +121,7 @@ class SparseArray(PandasObject, np.ndarray):
         if index is not None:
             if data is None:
                 data = np.nan
-            if not np.isscalar(data):
+            if not lib.isscalar(data):
                 raise Exception("must only pass scalars with an index ")
             values = np.empty(len(index), dtype='float64')
             values.fill(data)
@@ -362,7 +362,7 @@ class SparseArray(PandasObject, np.ndarray):
             j = 0
         slobj = slice(i, j)  # noqa
 
-        # if not np.isscalar(value):
+        # if not lib.isscalar(value):
         #    raise Exception("SparseArray does not support seting non-scalars
         # via slices")
 
@@ -504,7 +504,7 @@ def make_sparse(arr, kind='block', fill_value=nan):
     if hasattr(arr, 'values'):
         arr = arr.values
     else:
-        if np.isscalar(arr):
+        if lib.isscalar(arr):
             arr = [arr]
         arr = np.asarray(arr)
 
diff --git a/pandas/sparse/list.py b/pandas/sparse/list.py
index bfc4ab9d3..6cfe1bc6a 100644
--- a/pandas/sparse/list.py
+++ b/pandas/sparse/list.py
@@ -4,6 +4,7 @@ from pandas.core.common import pprint_thing
 
 from pandas.sparse.array import SparseArray
 import pandas._sparse as splib
+import pandas.lib as lib
 
 
 class SparseList(PandasObject):
@@ -120,7 +121,7 @@ class SparseList(PandasObject):
         ----------
         value: scalar or array-like
         """
-        if np.isscalar(value):
+        if lib.isscalar(value):
             value = [value]
 
         sparr = SparseArray(value, fill_value=self.fill_value)
diff --git a/pandas/sparse/panel.py b/pandas/sparse/panel.py
index 524508b82..be4ce716a 100644
--- a/pandas/sparse/panel.py
+++ b/pandas/sparse/panel.py
@@ -18,6 +18,7 @@ from pandas.util.decorators import deprecate
 
 import pandas.core.common as com
 import pandas.core.ops as ops
+import pandas.lib as lib
 
 
 class SparsePanelAxis(object):
@@ -390,7 +391,7 @@ class SparsePanel(Panel):
             return self._combineFrame(other, func, axis=axis)
         elif isinstance(other, Panel):
             return self._combinePanel(other, func)
-        elif np.isscalar(other):
+        elif lib.isscalar(other):
             new_frames = dict((k, func(v, other))
                               for k, v in compat.iteritems(self))
             return self._new_like(new_frames)
diff --git a/pandas/sparse/series.py b/pandas/sparse/series.py
index 1a2fc9698..25a667159 100644
--- a/pandas/sparse/series.py
+++ b/pandas/sparse/series.py
@@ -19,6 +19,7 @@ from pandas.core import generic
 import pandas.core.common as com
 import pandas.core.ops as ops
 import pandas.index as _index
+import pandas.lib as lib
 
 from pandas.sparse.array import (make_sparse, _sparse_array_op, SparseArray)
 from pandas._sparse import BlockIndex, IntIndex
@@ -48,7 +49,7 @@ def _arith_method(op, name, str_rep=None, default_axis=None, fill_zeros=None,
             return _sparse_series_op(self, other, op, name)
         elif isinstance(other, DataFrame):
             return NotImplemented
-        elif np.isscalar(other):
+        elif lib.isscalar(other):
             if isnull(other) or isnull(self.fill_value):
                 new_fill_value = np.nan
             else:
diff --git a/pandas/tests/frame/test_indexing.py b/pandas/tests/frame/test_indexing.py
index 43509857c..264302866 100644
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -26,6 +26,7 @@ from pandas.util.testing import (assert_almost_equal,
 from pandas.core.indexing import IndexingError
 
 import pandas.util.testing as tm
+import pandas.lib as lib
 
 from pandas.tests.frame.common import TestData
 
@@ -2218,7 +2219,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
                 d = df[k].values
                 c = cond[k].reindex(df[k].index).fillna(False).values
 
-                if np.isscalar(other):
+                if lib.isscalar(other):
                     o = other
                 else:
                     if isinstance(other, np.ndarray):
diff --git a/pandas/tests/series/test_indexing.py b/pandas/tests/series/test_indexing.py
index c5ebbca67..058fb430b 100644
--- a/pandas/tests/series/test_indexing.py
+++ b/pandas/tests/series/test_indexing.py
@@ -15,6 +15,7 @@ from pandas.tseries.tdi import Timedelta
 import pandas.core.common as com
 
 import pandas.core.datetools as datetools
+import pandas.lib as lib
 
 from pandas.compat import lrange, range
 from pandas import compat
@@ -364,7 +365,7 @@ class TestSeriesIndexing(TestData, tm.TestCase):
 
     def test_getitem_unordered_dup(self):
         obj = Series(lrange(5), index=['c', 'a', 'a', 'b', 'b'])
-        self.assertTrue(np.isscalar(obj['c']))
+        self.assertTrue(lib.isscalar(obj['c']))
         self.assertEqual(obj['c'], 0)
 
     def test_getitem_dups_with_missing(self):
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index 4c7510783..a309d88e6 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -13,6 +13,7 @@ from pandas import (Index, Series, DataFrame, Panel, isnull,
 from pandas.core.index import MultiIndex
 
 import pandas.core.common as com
+import pandas.lib as lib
 
 from pandas.compat import range, zip
 from pandas import compat
@@ -60,7 +61,7 @@ class Generic(object):
         if isinstance(shape, int):
             shape = tuple([shape] * self._ndim)
         if value is not None:
-            if np.isscalar(value):
+            if lib.isscalar(value):
                 if value == 'empty':
                     arr = None
 
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 1c0986b02..6a904c67f 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -199,7 +199,7 @@ class TestIndexing(tm.TestCase):
                     return
 
                 try:
-                    if np.isscalar(rs) and np.isscalar(xp):
+                    if lib.isscalar(rs) and lib.isscalar(xp):
                         self.assertEqual(rs, xp)
                     elif xp.ndim == 1:
                         assert_series_equal(rs, xp)
diff --git a/pandas/tools/pivot.py b/pandas/tools/pivot.py
index b88aeb310..d699639c6 100644
--- a/pandas/tools/pivot.py
+++ b/pandas/tools/pivot.py
@@ -9,6 +9,7 @@ from pandas.tools.util import cartesian_product
 from pandas.compat import range, lrange, zip
 from pandas import compat
 import pandas.core.common as com
+import pandas.lib as lib
 import numpy as np
 
 
@@ -356,8 +357,8 @@ def _generate_marginal_results_without_values(
 def _convert_by(by):
     if by is None:
         by = []
-    elif (np.isscalar(by) or isinstance(by, (np.ndarray, Index,
-                                             Series, Grouper)) or
+    elif (lib.isscalar(by) or
+          isinstance(by, (np.ndarray, Index, Series, Grouper)) or
           hasattr(by, '__call__')):
         by = [by]
     else:
diff --git a/pandas/tools/tile.py b/pandas/tools/tile.py
index f66ace14c..b0bbf8ba7 100644
--- a/pandas/tools/tile.py
+++ b/pandas/tools/tile.py
@@ -7,6 +7,7 @@ from pandas.core.categorical import Categorical
 import pandas.core.algorithms as algos
 import pandas.core.common as com
 import pandas.core.nanops as nanops
+import pandas.lib as lib
 from pandas.compat import zip
 
 import numpy as np
@@ -79,7 +80,7 @@ def cut(x, bins, right=True, labels=None, retbins=False, precision=3,
     """
     # NOTE: this binning code is changed a bit from histogram for var(x) == 0
     if not np.iterable(bins):
-        if np.isscalar(bins) and bins < 1:
+        if lib.isscalar(bins) and bins < 1:
             raise ValueError("`bins` should be a positive integer.")
         try:  # for array-like
             sz = x.size
diff --git a/pandas/tseries/base.py b/pandas/tseries/base.py
index d82a229f4..62a7ad078 100644
--- a/pandas/tseries/base.py
+++ b/pandas/tseries/base.py
@@ -145,13 +145,13 @@ class DatetimeIndexOpsMixin(object):
     def __contains__(self, key):
         try:
             res = self.get_loc(key)
-            return np.isscalar(res) or type(res) == slice or np.any(res)
+            return lib.isscalar(res) or type(res) == slice or np.any(res)
         except (KeyError, TypeError, ValueError):
             return False
 
     def __getitem__(self, key):
         getitem = self._data.__getitem__
-        if np.isscalar(key):
+        if lib.isscalar(key):
             val = getitem(key)
             return self._box_func(val)
         else:
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 84a62cb5f..c745f1b2e 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -261,7 +261,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
                                  ambiguous=ambiguous)
 
         if not isinstance(data, (np.ndarray, Index, ABCSeries)):
-            if np.isscalar(data):
+            if lib.isscalar(data):
                 raise ValueError('DatetimeIndex() must be called with a '
                                  'collection of some kind, %s was passed'
                                  % repr(data))
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index a25bb525c..f34936f9c 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -211,7 +211,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
     def _from_arraylike(cls, data, freq, tz):
         if not isinstance(data, (np.ndarray, PeriodIndex,
                                  DatetimeIndex, Int64Index)):
-            if np.isscalar(data) or isinstance(data, Period):
+            if lib.isscalar(data) or isinstance(data, Period):
                 raise ValueError('PeriodIndex() must be called with a '
                                  'collection of some kind, %s was passed'
                                  % repr(data))
@@ -805,7 +805,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
 
     def __getitem__(self, key):
         getitem = self._data.__getitem__
-        if np.isscalar(key):
+        if lib.isscalar(key):
             val = getitem(key)
             return Period(ordinal=val, freq=self.freq)
         else:
diff --git a/pandas/tseries/tdi.py b/pandas/tseries/tdi.py
index e74879602..9759d13fe 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/tseries/tdi.py
@@ -165,7 +165,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
             data = to_timedelta(data, unit=unit, box=False)
 
         if not isinstance(data, (np.ndarray, Index, ABCSeries)):
-            if np.isscalar(data):
+            if lib.isscalar(data):
                 raise ValueError('TimedeltaIndex() must be called with a '
                                  'collection of some kind, %s was passed'
                                  % repr(data))
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index d434b1931..35a615db4 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -31,6 +31,7 @@ from pandas.core.common import (is_sequence, array_equivalent, is_list_like, is_
                                 needs_i8_conversion)
 
 import pandas.compat as compat
+import pandas.lib as lib
 from pandas.compat import(
     filter, map, zip, range, unichr, lrange, lmap, lzip, u, callable, Counter,
     raise_with_traceback, httplib, is_platform_windows, is_platform_32bit
@@ -885,7 +886,7 @@ def assert_numpy_array_equal(left, right,
     if err_msg is None:
         # show detailed error
 
-        if np.isscalar(left) and np.isscalar(right):
+        if lib.isscalar(left) and lib.isscalar(right):
             # show scalar comparison error
             assert_equal(left, right)
         elif is_list_like(left) and is_list_like(right):

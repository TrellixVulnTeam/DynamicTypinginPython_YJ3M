commit 3fd47fef4442a9a116e9bf37b607332551924179
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Mon Jan 28 22:15:37 2019 +0000

    STY: use pytest.raises context manager (resample) (#24977)

diff --git a/pandas/tests/resample/test_base.py b/pandas/tests/resample/test_base.py
index 911cd990a..48debfa28 100644
--- a/pandas/tests/resample/test_base.py
+++ b/pandas/tests/resample/test_base.py
@@ -95,7 +95,10 @@ def test_resample_interpolate_all_ts(frame):
 def test_raises_on_non_datetimelike_index():
     # this is a non datetimelike index
     xp = DataFrame()
-    pytest.raises(TypeError, lambda: xp.resample('A').mean())
+    msg = ("Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex,"
+           " but got an instance of 'Index'")
+    with pytest.raises(TypeError, match=msg):
+        xp.resample('A').mean()
 
 
 @pytest.mark.parametrize('freq', ['M', 'D', 'H'])
@@ -189,8 +192,10 @@ def test_resample_loffset_arg_type_all_ts(frame, create_index):
 
         # GH 13022, 7687 - TODO: fix resample w/ TimedeltaIndex
         if isinstance(expected.index, TimedeltaIndex):
-            with pytest.raises(AssertionError):
+            msg = "DataFrame are different"
+            with pytest.raises(AssertionError, match=msg):
                 assert_frame_equal(result_agg, expected)
+            with pytest.raises(AssertionError, match=msg):
                 assert_frame_equal(result_how, expected)
         else:
             assert_frame_equal(result_agg, expected)
diff --git a/pandas/tests/resample/test_datetime_index.py b/pandas/tests/resample/test_datetime_index.py
index 73995cbe7..74487052f 100644
--- a/pandas/tests/resample/test_datetime_index.py
+++ b/pandas/tests/resample/test_datetime_index.py
@@ -113,16 +113,18 @@ def test_resample_basic_grouper(series):
 @pytest.mark.parametrize(
     '_index_start,_index_end,_index_name',
     [('1/1/2000 00:00:00', '1/1/2000 00:13:00', 'index')])
-@pytest.mark.parametrize('kwargs', [
-    dict(label='righttt'),
-    dict(closed='righttt'),
-    dict(convention='starttt')
+@pytest.mark.parametrize('keyword,value', [
+    ('label', 'righttt'),
+    ('closed', 'righttt'),
+    ('convention', 'starttt')
 ])
-def test_resample_string_kwargs(series, kwargs):
+def test_resample_string_kwargs(series, keyword, value):
     # see gh-19303
     # Check that wrong keyword argument strings raise an error
-    with pytest.raises(ValueError, match='Unsupported value'):
-        series.resample('5min', **kwargs)
+    msg = "Unsupported value {value} for `{keyword}`".format(
+        value=value, keyword=keyword)
+    with pytest.raises(ValueError, match=msg):
+        series.resample('5min', **({keyword: value}))
 
 
 @pytest.mark.parametrize(
@@ -676,7 +678,7 @@ def test_asfreq_non_unique():
     ts = Series(np.random.randn(len(rng2)), index=rng2)
 
     msg = 'cannot reindex from a duplicate axis'
-    with pytest.raises(Exception, match=msg):
+    with pytest.raises(ValueError, match=msg):
         ts.asfreq('B')
 
 
diff --git a/pandas/tests/resample/test_period_index.py b/pandas/tests/resample/test_period_index.py
index c2fbb5bbb..8abdf9034 100644
--- a/pandas/tests/resample/test_period_index.py
+++ b/pandas/tests/resample/test_period_index.py
@@ -11,6 +11,7 @@ from pandas.compat import lrange, range, zip
 
 import pandas as pd
 from pandas import DataFrame, Series, Timestamp
+from pandas.core.indexes.base import InvalidIndexError
 from pandas.core.indexes.datetimes import date_range
 from pandas.core.indexes.period import Period, PeriodIndex, period_range
 from pandas.core.resample import _get_period_range_edges
@@ -72,17 +73,19 @@ class TestPeriodIndex(object):
 
     @pytest.mark.parametrize('freq', ['H', '12H', '2D', 'W'])
     @pytest.mark.parametrize('kind', [None, 'period', 'timestamp'])
-    def test_selection(self, index, freq, kind):
+    @pytest.mark.parametrize('kwargs', [dict(on='date'), dict(level='d')])
+    def test_selection(self, index, freq, kind, kwargs):
         # This is a bug, these should be implemented
         # GH 14008
         rng = np.arange(len(index), dtype=np.int64)
         df = DataFrame({'date': index, 'a': rng},
                        index=pd.MultiIndex.from_arrays([rng, index],
                                                        names=['v', 'd']))
-        with pytest.raises(NotImplementedError):
-            df.resample(freq, on='date', kind=kind)
-        with pytest.raises(NotImplementedError):
-            df.resample(freq, level='d', kind=kind)
+        msg = ("Resampling from level= or on= selection with a PeriodIndex is"
+               r" not currently supported, use \.set_index\(\.\.\.\) to"
+               " explicitly set index")
+        with pytest.raises(NotImplementedError, match=msg):
+            df.resample(freq, kind=kind, **kwargs)
 
     @pytest.mark.parametrize('month', MONTHS)
     @pytest.mark.parametrize('meth', ['ffill', 'bfill'])
@@ -110,13 +113,20 @@ class TestPeriodIndex(object):
         assert_series_equal(ts.resample('a-dec').mean(), result)
         assert_series_equal(ts.resample('a').mean(), result)
 
-    def test_not_subperiod(self, simple_period_range_series):
+    @pytest.mark.parametrize('rule,expected_error_msg', [
+        ('a-dec', '<YearEnd: month=12>'),
+        ('q-mar', '<QuarterEnd: startingMonth=3>'),
+        ('M', '<MonthEnd>'),
+        ('w-thu', '<Week: weekday=3>')
+    ])
+    def test_not_subperiod(
+            self, simple_period_range_series, rule, expected_error_msg):
         # These are incompatible period rules for resampling
         ts = simple_period_range_series('1/1/1990', '6/30/1995', freq='w-wed')
-        pytest.raises(ValueError, lambda: ts.resample('a-dec').mean())
-        pytest.raises(ValueError, lambda: ts.resample('q-mar').mean())
-        pytest.raises(ValueError, lambda: ts.resample('M').mean())
-        pytest.raises(ValueError, lambda: ts.resample('w-thu').mean())
+        msg = ("Frequency <Week: weekday=2> cannot be resampled to {}, as they"
+               " are not sub or super periods").format(expected_error_msg)
+        with pytest.raises(IncompatibleFrequency, match=msg):
+            ts.resample(rule).mean()
 
     @pytest.mark.parametrize('freq', ['D', '2D'])
     def test_basic_upsample(self, freq, simple_period_range_series):
@@ -212,8 +222,9 @@ class TestPeriodIndex(object):
         assert_series_equal(result, expected)
 
     def test_resample_incompat_freq(self):
-
-        with pytest.raises(IncompatibleFrequency):
+        msg = ("Frequency <MonthEnd> cannot be resampled to <Week: weekday=6>,"
+               " as they are not sub or super periods")
+        with pytest.raises(IncompatibleFrequency, match=msg):
             Series(range(3), index=pd.period_range(
                 start='2000', periods=3, freq='M')).resample('W').mean()
 
@@ -373,7 +384,9 @@ class TestPeriodIndex(object):
     def test_cant_fill_missing_dups(self):
         rng = PeriodIndex([2000, 2005, 2005, 2007, 2007], freq='A')
         s = Series(np.random.randn(5), index=rng)
-        pytest.raises(Exception, lambda: s.resample('A').ffill())
+        msg = "Reindexing only valid with uniquely valued Index objects"
+        with pytest.raises(InvalidIndexError, match=msg):
+            s.resample('A').ffill()
 
     @pytest.mark.parametrize('freq', ['5min'])
     @pytest.mark.parametrize('kind', ['period', None, 'timestamp'])
diff --git a/pandas/tests/resample/test_resample_api.py b/pandas/tests/resample/test_resample_api.py
index 69684daf0..a694942cc 100644
--- a/pandas/tests/resample/test_resample_api.py
+++ b/pandas/tests/resample/test_resample_api.py
@@ -113,16 +113,14 @@ def test_getitem():
                           test_frame.columns[[0, 1]])
 
 
-def test_select_bad_cols():
-
+@pytest.mark.parametrize('key', [['D'], ['A', 'D']])
+def test_select_bad_cols(key):
     g = test_frame.resample('H')
-    pytest.raises(KeyError, g.__getitem__, ['D'])
-
-    pytest.raises(KeyError, g.__getitem__, ['A', 'D'])
-    with pytest.raises(KeyError, match='^[^A]+$'):
-        # A should not be referenced as a bad column...
-        # will have to rethink regex if you change message!
-        g[['A', 'D']]
+    # 'A' should not be referenced as a bad column...
+    # will have to rethink regex if you change message!
+    msg = r"^\"Columns not found: 'D'\"$"
+    with pytest.raises(KeyError, match=msg):
+        g[key]
 
 
 def test_attribute_access():
@@ -216,7 +214,9 @@ def test_fillna():
     result = r.fillna(method='bfill')
     assert_series_equal(result, expected)
 
-    with pytest.raises(ValueError):
+    msg = (r"Invalid fill method\. Expecting pad \(ffill\), backfill"
+           r" \(bfill\) or nearest\. Got 0")
+    with pytest.raises(ValueError, match=msg):
         r.fillna(0)
 
 
@@ -437,12 +437,11 @@ def test_agg_misc():
 
     # errors
     # invalid names in the agg specification
+    msg = "\"Column 'B' does not exist!\""
     for t in cases:
-        with pytest.raises(KeyError):
-            with tm.assert_produces_warning(FutureWarning,
-                                            check_stacklevel=False):
-                t[['A']].agg({'A': ['sum', 'std'],
-                              'B': ['mean', 'std']})
+        with pytest.raises(KeyError, match=msg):
+            t[['A']].agg({'A': ['sum', 'std'],
+                          'B': ['mean', 'std']})
 
 
 def test_agg_nested_dicts():
@@ -464,11 +463,11 @@ def test_agg_nested_dicts():
         df.groupby(pd.Grouper(freq='2D'))
     ]
 
+    msg = r"cannot perform renaming for r(1|2) with a nested dictionary"
     for t in cases:
-        def f():
+        with pytest.raises(pd.core.base.SpecificationError, match=msg):
             t.aggregate({'r1': {'A': ['mean', 'sum']},
                          'r2': {'B': ['mean', 'sum']}})
-            pytest.raises(ValueError, f)
 
     for t in cases:
         expected = pd.concat([t['A'].mean(), t['A'].std(), t['B'].mean(),
@@ -499,7 +498,8 @@ def test_try_aggregate_non_existing_column():
     df = DataFrame(data).set_index('dt')
 
     # Error as we don't have 'z' column
-    with pytest.raises(KeyError):
+    msg = "\"Column 'z' does not exist!\""
+    with pytest.raises(KeyError, match=msg):
         df.resample('30T').agg({'x': ['mean'],
                                 'y': ['median'],
                                 'z': ['sum']})
@@ -517,23 +517,29 @@ def test_selection_api_validation():
     df_exp = DataFrame({'a': rng}, index=index)
 
     # non DatetimeIndex
-    with pytest.raises(TypeError):
+    msg = ("Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex,"
+           " but got an instance of 'Int64Index'")
+    with pytest.raises(TypeError, match=msg):
         df.resample('2D', level='v')
 
-    with pytest.raises(ValueError):
+    msg = "The Grouper cannot specify both a key and a level!"
+    with pytest.raises(ValueError, match=msg):
         df.resample('2D', on='date', level='d')
 
-    with pytest.raises(TypeError):
+    msg = "unhashable type: 'list'"
+    with pytest.raises(TypeError, match=msg):
         df.resample('2D', on=['a', 'date'])
 
-    with pytest.raises(KeyError):
+    msg = r"\"Level \['a', 'date'\] not found\""
+    with pytest.raises(KeyError, match=msg):
         df.resample('2D', level=['a', 'date'])
 
     # upsampling not allowed
-    with pytest.raises(ValueError):
+    msg = ("Upsampling from level= or on= selection is not supported, use"
+           r" \.set_index\(\.\.\.\) to explicitly set index to datetime-like")
+    with pytest.raises(ValueError, match=msg):
         df.resample('2D', level='d').asfreq()
-
-    with pytest.raises(ValueError):
+    with pytest.raises(ValueError, match=msg):
         df.resample('2D', on='date').asfreq()
 
     exp = df_exp.resample('2D').sum()
diff --git a/pandas/tests/resample/test_time_grouper.py b/pandas/tests/resample/test_time_grouper.py
index ec29b55ac..a4eb79337 100644
--- a/pandas/tests/resample/test_time_grouper.py
+++ b/pandas/tests/resample/test_time_grouper.py
@@ -112,7 +112,7 @@ def test_fails_on_no_datetime_index(name, func):
     df = DataFrame({'a': np.random.randn(n)}, index=index)
 
     msg = ("Only valid with DatetimeIndex, TimedeltaIndex "
-           "or PeriodIndex, but got an instance of %r" % name)
+           "or PeriodIndex, but got an instance of '{}'".format(name))
     with pytest.raises(TypeError, match=msg):
         df.groupby(TimeGrouper('D'))
 

commit d635f31c038336e7a55795c4294acc9d294c6952
Author: Adam Klein <adamklein@gmail.com>
Date:   Sun Feb 12 19:50:18 2012 -0500

    Added relative monthly range, cleaned up here and there

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 1b7621253..b38d9922d 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -56,20 +56,6 @@ def _dt_box(key, freq=None, offset=-1):
                                         freq=freq, offset=offset)
         return _box_cache[key]
 
-#dtdtype = [('Y', '>i4'), # year
-#           ('M', '>i4'), # month
-#           ('D', '>i4'), # day
-#           ('h', '>i4'), # hour
-#           ('m', '>i4'), # min
-#           ('s', '>i4'), # second
-#           ('u', '>i4')] # microsecond
-
-#def _dt_arr_to_sarr(arr):
-#    return np.array(map(lambda x: (x.year, x.month, x.day, x.hour,
-#                                   x.minute, x.second, x.microsecond),
-#                        arr),
-#                    dtype=dtdtype)
-
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
 
@@ -88,23 +74,23 @@ def ole2datetime(oledt):
     if val < 61:
         raise Exception("Value is outside of acceptable range: %s " % val)
 
-    return lib.Timestamp(OLE_TIME_ZERO + timedelta(days=val))
+    return OLE_TIME_ZERO + timedelta(days=val)
 
 def to_datetime(arg):
     """Attempts to convert arg to datetime"""
     if arg is None:
         return arg
     elif isinstance(arg, datetime):
-        return lib.Timestamp(arg)
+        return arg
     try:
-        return lib.Timestamp(parser.parse(arg))
+        return parser.parse(arg)
     except Exception:
         return arg
 
 def normalize_date(dt):
     if isinstance(dt, np.datetime64):
         dt = _dt_box(dt)
-    return lib.Timestamp(datetime(dt.year, dt.month, dt.day))
+    return datetime(dt.year, dt.month, dt.day)
 
 #-------------------------------------------------------------------------------
 # DateOffset
@@ -276,37 +262,11 @@ class DateOffset(object):
         # Default (slow) method for determining if some date is a
         # member of the DateRange generated by this offset. Subclasses
         # may have this re-implemented in a nicer way.
-        a = lib.Timestamp(someDate) 
-        b = lib.Timestamp(((someDate + self) - self))
+        a = someDate
+        b = ((someDate + self) - self)
         return a == b
 
 
-class BDay2():
-    def __init__(self, n=1):
-        if 'BDay' not in _timestamp_cache:
-            per = lib.count_daily_range(_CACHE_START, _CACHE_END, biz=1)
-            rng = lib.generate_daily_range(_CACHE_START, per + 1, biz=1) 
-            _timestamp_cache['BDay'] = rng
-
-        self.rng = _timestamp_cache['BDay']
-        self.n = n
-
-    def apply(self, other):
-        other = Timestamp(other)
-
-        absn = abs(self.n) 
-        if (other.value < self.rng[absn] or
-            other.value > self.rng[-absn-1]):
-            raise NotImplementedError("Out of range: needs fix")
-
-        idx = self.rng.searchsorted(other.value,
-                                    'left' if self.n > 0 else 'right')
-
-        return Timestamp(self.rng[idx + self.n])
-
-
-
-
 class BDay(DateOffset, CacheableOffset):
     """
     DateOffset subclass representing possibly n business days
@@ -356,8 +316,7 @@ class BDay(DateOffset, CacheableOffset):
                     n -= k
 
             if self.normalize:
-                result = lib.Timestamp(datetime(result.year, result.month, 
-                                                result.day))
+                result = datetime(result.year, result.month, result.day)
 
             if self.offset:
                 result = result + self.offset
@@ -529,7 +488,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
 
     def getOffsetOfMonth(self, someDate):
         w = Week(weekday=self.weekday)
-        d = lib.Timestamp(datetime(someDate.year, someDate.month, 1))
+        d = datetime(someDate.year, someDate.month, 1)
 
         d = w.rollforward(d)
 
@@ -539,7 +498,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
         return d
 
     def onOffset(self, someDate):
-        return lib.Timestamp(someDate) == self.getOffsetOfMonth(someDate)
+        return someDate == self.getOffsetOfMonth(someDate)
 
 class BQuarterEnd(DateOffset, CacheableOffset):
     """DateOffset increments between business Quarter dates
@@ -669,7 +628,7 @@ class BYearEnd(DateOffset, CacheableOffset):
         other = other + lib.Delta(years=years)
 
         _, days_in_month = calendar.monthrange(other.year, self.month)
-        result = lib.Timestamp(datetime(other.year, self.month, days_in_month))
+        result = datetime(other.year, self.month, days_in_month)
 
         if result.weekday() > 4:
             result = result - BDay()
@@ -683,7 +642,7 @@ class YearEnd(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
         if other.month != 12 or other.day != 31:
-            other = lib.Timestamp(datetime(other.year - 1, 12, 31))
+            other = datetime(other.year - 1, 12, 31)
             if n <= 0:
                 n = n + 1
         other = other + lib.Delta(years=n)
@@ -701,7 +660,7 @@ class YearBegin(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
         if other.month != 1 or other.day != 1:
-            other = lib.Timestamp(datetime(other.year, 1, 1))
+            other = datetime(other.year, 1, 1)
             if n <= 0:
                 n = n + 1
         other = other + lib.Delta(years = n, day=1)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index ec8eb8a7e..e09ac0692 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -321,22 +321,6 @@ class Index(np.ndarray):
     def sort(self, *args, **kwargs):
         raise Exception('Cannot sort an Index object')
 
-    def shift(self, periods, offset):
-        """
-        Shift Index containing datetime objects by input number of periods and
-        DateOffset
-
-        Returns
-        -------
-        shifted : Index
-        """
-        if periods == 0:
-            # OK because immutable
-            return self
-
-        offset = periods * offset
-        return Index([idx + offset for idx in self])
-
     def argsort(self, *args, **kwargs):
         """
         See docstring for ndarray.argsort
@@ -1073,16 +1057,6 @@ class DatetimeIndex(Int64Index):
             cached, first, last = lib._get_freq(freq, start, end, n)
             dti = cls._construct_from_cache(name, freq, cached, first, last+1)
             return dti
-        else:
-            # hmm prob want to move this to bottom after data
-            # is constructed
-            if freq is not None:
-                failure = lib.conformity_check(data.view('i8'), freq)
-                if failure is not None:
-                    raise ValueError("%s does not satisfy %s"
-                                     % (np.datetime64(failure), freq))
-
-        # TODO: check if data conforms to freq
 
         if not isinstance(data, np.ndarray):
             if np.isscalar(data):
@@ -1116,6 +1090,12 @@ class DatetimeIndex(Int64Index):
                     raise TypeError('Unsafe NumPy casting, you must '
                                     'explicitly cast')
 
+        if freq is not None:
+            failure = lib.conformity_check(subarr.view('i8'), freq)
+            if failure is not None:
+                raise ValueError("%s does not satisfy frequency %s"
+                                  % (np.datetime64(failure), freq))
+
         subarr = subarr.view(cls)
         subarr.freq = None
         subarr.name = name
@@ -1158,6 +1138,7 @@ class DatetimeIndex(Int64Index):
                 key = _dt_unbox(key)
             val = arr_idx[key]
             if self.freq:
+                print self.freq
                 # suffer another cache lookup? how to avoid?
                 return _dt_box(val, self.freq,
                                self.first + self._engine.get_loc(val))
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 809c769b0..53a8703c0 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -249,6 +249,8 @@ cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
 cdef:
     int64_t us_in_day = conversion_factor(r_microsecond, r_day)
 
+# TODO: refactor count/generate logic, too much code duplication
+
 def generate_annual_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
                           int64_t biz=0):
     """
@@ -332,7 +334,8 @@ def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0
         ndarray[int64_t] dtindex
         _TSObject ts
 
-    assert(stride > 0, "Stride must be positive")
+    if stride <= 0:
+        raise ValueError("Stride must be positive")
 
     ts = convert_to_tsobject(start)
 
@@ -365,8 +368,8 @@ def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0
         for j in range(0, stride):
             if m >= 12:
                 m -= 12
-            y += 1
-            ly = is_leapyear(y)
+                y += 1
+                ly = is_leapyear(y)
             days += _days_per_month_table[ly][m]
             m += 1
 
@@ -380,6 +383,72 @@ def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0
 
     return dtindex # .view(np.datetime64)
 
+def generate_relativemonthly_range(object start, Py_ssize_t periods,
+                                   int64_t week=0, int64_t day=0):
+    """
+    Generate relative monthly timestamps using the month & year of provided
+    start time. For example, fridays of the third week of each month (week=3,
+    day=4); or, thursdays of the last week of each month (week=-1, day=3).
+
+    Parameters
+    ----------
+    start : timestamp-like
+    periods : int
+    week : int
+    day : int, 0 to 6
+
+    Returns
+    -------
+    Array of datetime64
+    """
+    cdef:
+        Py_ssize_t i, m, y, ly
+        int64_t days, adj, dow
+        ndarray[int64_t] dtindex
+        _TSObject ts
+
+    if day < 0 or day > 6:
+        raise ValueError("Day offset must be 0 to 6")
+
+    ts = convert_to_tsobject(start)
+
+    dtindex = np.empty(periods, np.int64)
+
+    # rewind to beginning of month
+    dtindex[0] = ts.value - (ts.dtval.day - 1) * us_in_day
+
+    # apply adjustment: week of month, plus to particular day of week
+    dow = dayofweek(ts.dtval.year, ts.dtval.month, 1)
+    adj = (week * 7) + (day - dow) % 7
+    dtindex[0] += adj * us_in_day
+
+    # for day counting
+    m = ts.dtval.month - 1
+    y = ts.dtval.year
+    ly = is_leapyear(y)
+
+    for i in range(1, periods):
+        # reverse prev adjustment
+        dtindex[i] = dtindex[i-1] - adj * us_in_day
+
+        if m >= 12:
+            m -= 12
+            y += 1
+            ly = is_leapyear(y)
+
+        # move to next month start
+        days = _days_per_month_table[ly][m]
+        dtindex[i] += days * us_in_day
+
+        # apply new adjustment
+        dow = (dow + days) % 7
+        adj = (week * 7) + (day - dow) % 7
+        dtindex[i] += adj * us_in_day
+
+        m += 1
+
+    return dtindex # .view(np.datetime64)
+
 def generate_daily_range(object start, Py_ssize_t periods, int64_t stride=1,
                          int64_t biz=0):
     """
@@ -404,7 +473,8 @@ def generate_daily_range(object start, Py_ssize_t periods, int64_t stride=1,
         ndarray[int64_t] dtindex
         _TSObject ts
 
-    assert(stride > 0, "Stride must be positive")
+    if stride <= 0:
+        raise ValueError("Stride must be positive")
 
     ts = convert_to_tsobject(start)
 
@@ -520,7 +590,8 @@ def count_monthly_range(object start, object end, int64_t dayoffset=0,
         int64_t i=0, t, days, dow, adj
         _TSObject s, e
 
-    assert(stride > 0, "Stride must be positive")
+    if stride <= 0:
+        raise ValueError("Stride must be positive")
 
     s = convert_to_tsobject(start)
     e = convert_to_tsobject(end)
@@ -568,6 +639,71 @@ def count_monthly_range(object start, object end, int64_t dayoffset=0,
 
     return i
 
+def count_relativemonthly_range(object start, object end,
+                                int64_t week=0, int64_t day=0):
+    """
+    Count relative monthly timestamps using the month & year of start time.
+    For example, friday in the third week of each month (week=3, day=4); or,
+    thursday of last week of each month (week=-1, day=3).
+
+    Parameters
+    ----------
+    start : timestamp-like
+    end : timestamp-like
+    week : int
+    day : int, 0 to 6
+
+    Returns
+    -------
+    Array of datetime64
+    """
+    cdef:
+        Py_ssize_t i=0, m, y, ly
+        int64_t days, adj, dow, t
+        _TSObject s, e
+
+    if day < 0 or day > 6:
+        raise ValueError("Day offset must be 0 to 6")
+
+    s = convert_to_tsobject(start)
+    e = convert_to_tsobject(end)
+
+    # rewind to beginning of month
+    t = s.value - (s.dtval.day - 1) * us_in_day
+
+    # apply adjustment: week of month, plus to particular day of week
+    dow = dayofweek(s.dtval.year, s.dtval.month, 1)
+    adj = (week * 7) + (day - dow) % 7
+    t += adj * us_in_day
+
+    # for day counting
+    m = s.dtval.month - 1
+    y = s.dtval.year
+    ly = is_leapyear(y)
+
+    while t < e.value:
+        i += 1
+        # reverse prev adjustment
+        t = t - adj * us_in_day
+
+        if m >= 12:
+            m -= 12
+            y += 1
+            ly = is_leapyear(y)
+
+        # move to next month start
+        days = _days_per_month_table[ly][m]
+        t += days * us_in_day
+
+        # apply new adjustment
+        dow = (dow + days) % 7
+        adj = (week * 7) + (day - dow) % 7
+        t += adj * us_in_day
+
+        m += 1
+
+    return i
+
 def count_daily_range(object start, object end, stride=1, int64_t biz=0):
     """
     Count number of periods from first conforming date on or after start,
@@ -588,7 +724,8 @@ def count_daily_range(object start, object end, stride=1, int64_t biz=0):
         int64_t i=0, t, dow, adj
         _TSObject s, e
 
-    assert(stride > 0, "Stride must be positive")
+    if stride <= 0:
+        raise ValueError("Stride must be positive")
 
     s = convert_to_tsobject(start)
     e = convert_to_tsobject(end)
@@ -626,25 +763,34 @@ def count_daily_range(object start, object end, stride=1, int64_t biz=0):
 # Here's some frequency caching logic
 # ----------------------------------------------------------------------------------
 
-_CACHE_START = Timestamp(datetime(1950, 1, 1))
-_CACHE_END   = Timestamp(datetime(2030, 1, 1))
+# daily 1850-2050 takes up 73049 x 8bytes / 2**20bytes => 0.56Mb of cache. seems ok
+
+_CACHE_START = Timestamp(datetime(1850, 1, 1))
+_CACHE_END   = Timestamp(datetime(2050, 1, 1))
 
 _fcache = {}
 
 def _get_freq(freq, start, end=None, n=None):
-    # TODO: need some logic to auto-(re)size cache
+    """
+    Retrieve from cache (or generate, first time through) an array of times
+    that correspond to the frequency we care about.
+    """
+
+    # TODO: need some logic to auto-(re)size cache?
 
     if freq not in _fcache:
         #  generate range to cache
         if freq == 'WEEKDAY':
             per = count_daily_range(_CACHE_START, _CACHE_END, biz=1)
-            rng = generate_daily_range(_CACHE_START, per + 1, biz=1)
+            rng = generate_daily_range(_CACHE_START, per, biz=1)
         elif freq == 'DAILY':
             per = count_daily_range(_CACHE_START, _CACHE_END, biz=0)
-            rng = generate_daily_range(_CACHE_START, per + 1, biz=0)
+            rng = generate_daily_range(_CACHE_START, per, biz=0)
         elif freq == 'EOM':
-            per = count_monthly_range(_CACHE_START, _CACHE_END, dayoffset=-1, biz=-1)
-            rng = generate_monthly_range(_CACHE_START, per + 1, dayoffset=-1, biz=-1)
+            per = count_monthly_range(_CACHE_START, _CACHE_END, dayoffset=-1,
+                                      biz=-1)
+            rng = generate_monthly_range(_CACHE_START, per, dayoffset=-1,
+                                         biz=-1)
         elif freq.startswith('W@'):
             begin = _CACHE_START
             offset = _CACHE_START.weekday()
@@ -663,7 +809,69 @@ def _get_freq(freq, start, end=None, n=None):
             begin += timedelta(days=offset)
 
             per = count_daily_range(begin, _CACHE_END, stride=7, biz=1)
-            rng = generate_daily_range(begin, per + 1, stride=7, biz=1)
+            rng = generate_daily_range(begin, per, stride=7, biz=1)
+        elif freq.startswith('Q@'):
+            begin = _CACHE_START
+            if freq.endswith('JAN'):
+                begin += Delta(months=1)
+            elif freq.endswith('FEB'):
+                begin += Delta(months=2)
+            elif freq.endswith('MAR'):
+                begin += Delta(months=3)
+            else:
+                raise ValueError('Bad quarter month %s' % freq)
+
+            per = count_monthly_range(begin, _CACHE_END, dayoffset=-1,
+                                      stride=3, biz=-1)
+            rng = generate_monthly_range(begin, per, dayoffset=-1,
+                                         stride=3, biz=-1)
+        elif freq.startswith('A@'):
+            begin = _CACHE_START
+            if freq.endswith('JAN'):
+                begin += Delta(months=1)
+            elif freq.endswith('FEB'):
+                begin += Delta(months=2)
+            elif freq.endswith('MAR'):
+                begin += Delta(months=3)
+            elif freq.endswith('APR'):
+                begin += Delta(months=4)
+            elif freq.endswith('MAY'):
+                begin += Delta(months=5)
+            elif freq.endswith('JUN'):
+                begin += Delta(months=6)
+            elif freq.endswith('JUL'):
+                begin += Delta(months=7)
+            elif freq.endswith('AUG'):
+                begin += Delta(months=8)
+            elif freq.endswith('SEP'):
+                begin += Delta(months=9)
+            elif freq.endswith('OCT'):
+                begin += Delta(months=10)
+            elif freq.endswith('NOV'):
+                begin += Delta(months=11)
+            elif freq.endswith('DEC'):
+                pass
+            else:
+                raise ValueError('Bad annual month %s' % freq)
+
+            per = count_annual_range(begin, _CACHE_END, dayoffset=-1, biz=-1)
+            rng = generate_annual_range(begin, per, dayoffset=-1, biz=-1)
+        elif freq.startswith('WOM@'):
+            begin = _CACHE_START
+            offset = freq.split('@')[1]
+            dlist = ['MON', 'TUE', 'WED', 'THU', 'FRI']
+            week = int(offset[:-3])
+            dow = offset[-3:]
+            if dow not in dlist:
+                raise ValueError('Bad weekday in %s' % freq)
+            dow = dlist.index(dow)
+
+            per = count_relativemonthly_range(begin, _CACHE_END,
+                                              week=week, day=dow)
+
+            rng = generate_relativemonthly_range(begin, per,
+                                                 week=week, day=dow)
+
         else:
             raise ValueError('Supplied frequency %s not implemented' % freq)
 
@@ -1365,6 +1573,4 @@ def monthrange(int64_t year, int64_t month):
     return (dayofweek(year, month, 1), days)
 
 cdef inline int64_t ts_dayofweek(_TSObject ts):
-    cdef npy_datetimestruct dts
-    PyArray_DatetimeToDatetimeStruct(ts.value, NPY_FR_us, &dts)
-    return dayofweek(dts.year, dts.month, dts.day)
+    return dayofweek(ts.dtval.year, ts.dtval.month, ts.dtval.day)

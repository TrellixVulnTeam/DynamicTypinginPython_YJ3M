commit 08f8b57ab39b627b2262584b615e709df01dae97
Author: Chang She <chang@lambdafoundry.com>
Date:   Wed Nov 28 16:19:17 2012 -0500

    BUG: intercept NumPy median in groupby #1989. Also some doc fixes

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 5004195db..3f555c800 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -3947,9 +3947,9 @@ class DataFrame(NDFrame):
         >>> df.apply(numpy.sum, axis=0) # equiv to df.sum(0)
         >>> df.apply(numpy.sum, axis=1) # equiv to df.sum(1)
 
-        Notes
-        -----
-        To apply a function elementwise, use applymap
+        See also
+        --------
+        DataFrame.applymap: For elementwise operations
 
         Returns
         -------
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 91e0bf8a7..3ff663e2e 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -11,10 +11,31 @@ from pandas.core.series import Series
 from pandas.core.panel import Panel
 from pandas.util.decorators import cache_readonly, Appender
 from pandas.util.compat import OrderedDict
+from pandas.util.decorators import Appender
 import pandas.core.algorithms as algos
 import pandas.core.common as com
 import pandas.lib as lib
 
+_agg_doc = """Aggregate using input function or dict of {column -> function}
+
+Parameters
+----------
+arg : function or dict
+    Function to use for aggregating groups. If a function, must either
+    work when passed a DataFrame or when passed to DataFrame.apply. If
+    pass a dict, the keys must be DataFrame column names
+
+Notes
+-----
+Numpy functions mean/median/prod/sum/std/var are special cased so the
+default behavior is applying the function along axis=0
+(e.g., np.mean(arr_2d, axis=0)) as opposed to
+mimicking the default Numpy behavior (e.g., np.mean(arr_2d)).
+
+Returns
+-------
+aggregated : DataFrame
+"""
 
 class GroupByError(Exception):
     pass
@@ -298,10 +319,8 @@ class GroupBy(object):
     def aggregate(self, func, *args, **kwargs):
         raise NotImplementedError
 
+    @Appender(_agg_doc)
     def agg(self, func, *args, **kwargs):
-        """
-        See docstring for aggregate
-        """
         return self.aggregate(func, *args, **kwargs)
 
     def _iterate_slices(self):
@@ -1508,21 +1527,8 @@ class NDFrameGroupBy(GroupBy):
         else:
             return self.obj
 
+    @Appender(_agg_doc)
     def aggregate(self, arg, *args, **kwargs):
-        """
-        Aggregate using input function or dict of {column -> function}
-
-        Parameters
-        ----------
-        arg : function or dict
-            Function to use for aggregating groups. If a function, must either
-            work when passed a DataFrame or when passed to DataFrame.apply. If
-            pass a dict, the keys must be DataFrame column names
-
-        Returns
-        -------
-        aggregated : DataFrame
-        """
         if isinstance(arg, basestring):
             return getattr(self, arg)(*args, **kwargs)
 
@@ -2238,10 +2244,10 @@ _cython_table = {
     np.mean: 'mean',
     np.prod: 'prod',
     np.std: 'std',
-    np.var: 'var'
+    np.var: 'var',
+    np.median: 'median'
 }
 
-
 def _is_numeric_dtype(dt):
     typ = dt.type
     return (issubclass(typ, (np.number, np.bool_))
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 4f840ef1a..4bb7cb871 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2214,11 +2214,6 @@ copy : boolean, default False
         --------
         Series.map: For element-wise operations
 
-        Notes
-        -----
-        func is applied to the entire Series at once first. If an exception
-        is raised, then apply to each value.
-
         Returns
         -------
         y : Series or DataFrame if func returns a Series
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index 775225565..cb52bf13f 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -238,7 +238,8 @@ class TestDataFramePlots(unittest.TestCase):
         ax = df.plot(x=1, y=2, title='Test', figsize=(16, 8))
 
         self.assert_(ax.title.get_text() == 'Test')
-        self.assert_((np.round(ax.figure.get_size_inches()) == np.array((16., 8.))).all())
+        self.assert_((np.round(ax.figure.get_size_inches())
+                      == np.array((16., 8.))).all())
 
         # columns.inferred_type == 'mixed'
         # TODO add MultiIndex test
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index c948fc28c..1a7e38b4f 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -2052,6 +2052,11 @@ class TestGroupBy(unittest.TestCase):
         exp = df.groupby(labels).agg(nanops.nanmedian)
         assert_frame_equal(result, exp)
 
+        df = DataFrame(np.random.randn(1000, 5))
+        rs = df.groupby(labels).agg(np.median)
+        xp = df.groupby(labels).median()
+        assert_frame_equal(rs, xp)
+
     def test_groupby_categorical_no_compress(self):
         data = Series(np.random.randn(9))
 
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 77c8392f5..2013020ec 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -1202,6 +1202,7 @@ class BarPlot(MPLPlot):
             self.tickoffset = 0.25
         else:
             self.tickoffset = 0.375
+        self.bar_width = 0.5
         MPLPlot.__init__(self, data, **kwargs)
 
     def _args_adjust(self):
@@ -1241,12 +1242,12 @@ class BarPlot(MPLPlot):
 
             if self.subplots:
                 ax = self._get_ax(i)  # self.axes[i]
-                rect = bar_f(ax, self.ax_pos, y, 0.5, start=pos_prior, **kwds)
+                rect = bar_f(ax, self.ax_pos, y, self.bar_width, start=pos_prior, **kwds)
                 ax.set_title(label)
             elif self.stacked:
                 mask = y > 0
                 start = np.where(mask, pos_prior, neg_prior)
-                rect = bar_f(ax, self.ax_pos, y, 0.5, start=start,
+                rect = bar_f(ax, self.ax_pos, y, self.bar_width, start=start,
                              label=label, **kwds)
                 pos_prior = pos_prior + np.where(mask, y, 0)
                 neg_prior = neg_prior + np.where(mask, 0, y)

commit 70245909cb875f381342dd467abeb5fac1f4e128
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Mar 5 12:17:36 2012 -0500

    ENH: fancing time indexing working, cleaned variables per compiler warnings

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 8d5c06160..77948e514 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1620,8 +1620,10 @@ class DataFrame(NDFrame):
         index = self.index
         if isinstance(index, MultiIndex):
             loc, new_index = self.index.get_loc_level(key)
-        #elif isinstance(index, DatetimeIndex):
-        #    loc, new_index = self.index.get_loc(key)
+        elif isinstance(index, DatetimeIndex):
+            loc = self.index.get_loc(key)
+            if not np.isscalar(loc):
+                new_index = self.index[loc]
         else:
             loc = self.index.get_loc(key)
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 8ffc1b49d..11b9d10ad 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1490,6 +1490,21 @@ class DatetimeIndex(Int64Index):
             left_chunk = left.values[lslice]
             return self._view_like(left_chunk)
 
+    def _partial_date_slice(self, reso, parsed):
+        if reso == 'year':
+            t1 = to_timestamp(datetime(parsed.year, 1, 1))
+            t2 = to_timestamp(datetime(parsed.year, 12, 31))
+            i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            return slice(i1, i2+1)
+        elif reso == 'month':
+            d = lib.monthrange(parsed.year, parsed.month)[1]
+            t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
+            t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
+            i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            return slice(i1, i2+1)
+
+        raise KeyError
+
     def get_value(self, series, key):
         """
         Fast lookup of value from 1-dimensional ndarray. Only use this if you
@@ -1498,25 +1513,16 @@ class DatetimeIndex(Int64Index):
         try:
             return super(DatetimeIndex, self).get_value(series, key)
         except KeyError:
-            #try:
-            #    asdt, parsed, reso = datetools.parse_time_string(key)
-            #    if reso == 'year':
-            #        t1 = to_timestamp(datetime(parsed.year, 1, 1))
-            #        t2 = to_timestamp(datetime(parsed.year, 12, 31))
-            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
-            #        return series[slice(i1, i2+1)]
-            #    elif reso == 'month':
-            #        d = lib.monthrange(parsed.year, parsed.month)[1]
-            #        t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
-            #        t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
-            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
-            #        return series[slice(i1, i2+1)]
-            #    else:
-                    #return self._engine.get_value(series, to_timestamp(asdt))
-            #except datetools.DateParseError:
-            #    raise KeyError(key)
-            #except KeyError:
-            #    raise
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                key = asdt
+                loc = self._partial_date_slice(reso, parsed)
+                return series[loc]
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+
             return self._engine.get_value(series, to_timestamp(key))
 
     def get_loc(self, key):
@@ -1530,25 +1536,16 @@ class DatetimeIndex(Int64Index):
         try:
             return self._engine.get_loc(key)
         except KeyError:
-            #try:
-            #    asdt, parsed, reso = datetools.parse_time_string(key)
-            #    if reso == 'year':
-            #        t1 = to_timestamp(datetime(parsed.year, 1, 1))
-            #        t2 = to_timestamp(datetime(parsed.year, 12, 31))
-            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
-            #        return slice(i1, i2+1), self[i1:i2+1]
-            #    elif reso == 'month':
-            #        d = lib.monthrange(parsed.year, parsed.month)[1]
-            #        t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
-            #        t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
-            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
-            #        return slice(i1, i2+1), self[i1:i2+1]
-            #    else:
-            #        return self._engine.get_loc(to_timestamp(asdt)), None
-            #except datetools.DateParseError:
-            #    raise KeyError(key)
-            #except KeyError:
-            #    raise
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                key = asdt
+                loc = self._partial_date_slice(reso, parsed)
+                return loc
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+
             return self._engine.get_loc(to_timestamp(key))
 
     def __getitem__(self, key):
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 95fbed759..c0a90831a 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -75,7 +75,6 @@ cdef extern from "np_datetime.h":
                                              NPY_DATETIMEUNIT *out_bestunit,
                                              int apply_tzinfo)
     int _days_per_month_table[2][12]
-    int _month_offset[2][13]
 
     int dayofweek(int y, int m, int d)
     int is_leapyear(int64_t year)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 013430526..48a0879ab 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1731,6 +1731,7 @@ def build_field_sarray(ndarray[int64_t] dtindex):
                   dts.us)
     return out
 
+@cython.wraparound(False)
 def fast_field_accessor(ndarray[int64_t] dtindex, object field):
     '''
     Given a int64-based datetime index, extract the year, month, etc.,
@@ -1740,9 +1741,15 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
         _TSObject ts
         Py_ssize_t i, count = 0
         ndarray[int32_t] out
+        ndarray[int32_t, ndim=2] _month_offset
         int isleap
         npy_datetimestruct dts
 
+    _month_offset = np.array( 
+        [[ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 ],
+         [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 ]],
+         dtype=np.int32 )
+
     count = len(dtindex)
     out = np.empty(count, dtype='i4')
 
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index cf1bf2fee..29598e926 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -15,37 +15,13 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
                                          NPY_DATETIMEUNIT *out_bestunit,
                                          int apply_tzinfo);
 
-
 int dayofweek(int y, int m, int d);
 
-/* Exported as DATETIMEUNITS in multiarraymodule.c */
-static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
-    NPY_STR_Y,
-    NPY_STR_M,
-    NPY_STR_W,
-    NPY_STR_D,
-    NPY_STR_h,
-    NPY_STR_m,
-    NPY_STR_s,
-    NPY_STR_ms,
-    NPY_STR_us,
-    NPY_STR_ns,
-    NPY_STR_ps,
-    NPY_STR_fs,
-    NPY_STR_as,
-    "generic"
-};
-
 static int _days_per_month_table[2][12] = {
     { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
     { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
 };
 
-static int _month_offset[2][13] = {
-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
-};
-
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
diff --git a/pandas/src/np_datetime_strings.c b/pandas/src/np_datetime_strings.c
index d6f680037..d377ced94 100644
--- a/pandas/src/np_datetime_strings.c
+++ b/pandas/src/np_datetime_strings.c
@@ -42,6 +42,37 @@ npy_casting_to_string(NPY_CASTING casting)
 /* Platform-specific time_t typedef */
 typedef time_t NPY_TIME_T;
 
+/*// We *do* want these symbols, but for cython, not for C. fine in mac osx,*/
+/*// linux complains.*/
+/*static void _suppress_unused_variable_warning(void)*/
+/*{*/
+/*    int x = _days_per_month_table[0][0];*/
+/*    x = x;*/
+
+/*    int y = _month_offset[0][0];*/
+/*    y = y;*/
+
+/*    char *z = _datetime_strings[0];*/
+/*    z = z;*/
+/*}*/
+
+/* Exported as DATETIMEUNITS in multiarraymodule.c */
+static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
+    NPY_STR_Y,
+    NPY_STR_M,
+    NPY_STR_W,
+    NPY_STR_D,
+    NPY_STR_h,
+    NPY_STR_m,
+    NPY_STR_s,
+    NPY_STR_ms,
+    NPY_STR_us,
+    NPY_STR_ns,
+    NPY_STR_ps,
+    NPY_STR_fs,
+    NPY_STR_as,
+    "generic"
+};
 /*
  * Wraps `localtime` functionality for multiple platforms. This
  * converts a time value to a time structure in the local timezone.

commit cd7c784aabc81eafa93d681f892a6256def9aa9e
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Jan 20 09:21:24 2020 -0800

    CLN: fix wrong types getting passed to TDI._get_string_slice (#30874)

diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 404c65ea0..c158bdfba 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -4902,7 +4902,7 @@ class Index(IndexOpsMixin, PandasObject):
             self._validate_index_level(level)
         return algos.isin(self, values)
 
-    def _get_string_slice(self, key, use_lhs=True, use_rhs=True):
+    def _get_string_slice(self, key: str_t, use_lhs: bool = True, use_rhs: bool = True):
         # this is for partial string indexing,
         # overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex
         raise NotImplementedError
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index d9d3e934a..9d501b260 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -684,7 +684,8 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
             raise KeyError(reso)
         return (t1.asfreq(self.freq, how="start"), t1.asfreq(self.freq, how="end"))
 
-    def _get_string_slice(self, key):
+    def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):
+        # TODO: Check for non-True use_lhs/use_rhs
         if not self.is_monotonic:
             raise ValueError("Partial indexing only valid for ordered time series")
 
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 007714a1c..1dd5c065e 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -237,25 +237,18 @@ class TimedeltaIndex(
         know what you're doing
         """
 
-        if _is_convertible_to_td(key):
+        if isinstance(key, str):
+            try:
+                key = Timedelta(key)
+            except ValueError:
+                raise KeyError(key)
+
+        if isinstance(key, self._data._recognized_scalars) or key is NaT:
             key = Timedelta(key)
             return self.get_value_maybe_box(series, key)
 
-        try:
-            value = Index.get_value(self, series, key)
-        except KeyError:
-            try:
-                loc = self._get_string_slice(key)
-                return series[loc]
-            except (TypeError, ValueError, KeyError):
-                pass
-
-            try:
-                return self.get_value_maybe_box(series, key)
-            except (TypeError, ValueError, KeyError):
-                raise KeyError(key)
-        else:
-            return com.maybe_box(self, value, series, key)
+        value = Index.get_value(self, series, key)
+        return com.maybe_box(self, value, series, key)
 
     def get_value_maybe_box(self, series, key: Timedelta):
         loc = self.get_loc(key)
@@ -288,19 +281,7 @@ class TimedeltaIndex(
             key = Timedelta(key)
             return Index.get_loc(self, key, method, tolerance)
 
-        try:
-            return Index.get_loc(self, key, method, tolerance)
-        except (KeyError, ValueError, TypeError):
-            try:
-                return self._get_string_slice(key)
-            except (TypeError, KeyError, ValueError):
-                pass
-
-            try:
-                stamp = Timedelta(key)
-                return Index.get_loc(self, stamp, method, tolerance)
-            except (KeyError, ValueError):
-                raise KeyError(key)
+        return Index.get_loc(self, key, method, tolerance)
 
     def _maybe_cast_slice_bound(self, label, side, kind):
         """
@@ -330,18 +311,10 @@ class TimedeltaIndex(
 
         return label
 
-    def _get_string_slice(self, key):
-        if is_integer(key) or is_float(key) or key is NaT:
-            self._invalid_indexer("slice", key)
-        loc = self._partial_td_slice(key)
-        return loc
-
-    def _partial_td_slice(self, key):
-
+    def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):
+        # TODO: Check for non-True use_lhs/use_rhs
+        assert isinstance(key, str), type(key)
         # given a key, try to figure out a location for a partial slice
-        if not isinstance(key, str):
-            return key
-
         raise NotImplementedError
 
     def is_type_compatible(self, typ) -> bool:

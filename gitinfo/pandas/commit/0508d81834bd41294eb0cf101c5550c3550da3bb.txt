commit 0508d81834bd41294eb0cf101c5550c3550da3bb
Author: Matthew Roeschke <emailformattr@gmail.com>
Date:   Sat Feb 9 09:42:05 2019 -0800

    CLN: For loops, boolean conditions, misc. (#25206)

diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 52fc7d259..ab58f86e0 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -2167,8 +2167,7 @@ class Categorical(ExtensionArray, PandasObject):
         r, counts = libalgos.groupsort_indexer(self.codes.astype('int64'),
                                                categories.size)
         counts = counts.cumsum()
-        result = [r[counts[indexer]:counts[indexer + 1]]
-                  for indexer in range(len(counts) - 1)]
+        result = (r[start:end] for start, end in zip(counts, counts[1:]))
         result = dict(zip(categories, result))
         return result
 
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index f9aef2401..1b2a4da38 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -128,7 +128,7 @@ def _dt_array_cmp(cls, op):
     Wrap comparison operations to convert datetime-like to datetime64
     """
     opname = '__{name}__'.format(name=op.__name__)
-    nat_result = True if opname == '__ne__' else False
+    nat_result = opname == '__ne__'
 
     def wrapper(self, other):
         if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index a6a4a49d3..fd90aec3b 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -561,7 +561,7 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
             else:
                 mask = self._mask | mask
 
-            result[mask] = True if op_name == 'ne' else False
+            result[mask] = op_name == 'ne'
             return result
 
         name = '__{name}__'.format(name=op.__name__)
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index e0c71b560..3ddceb8c2 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -46,7 +46,7 @@ def _period_array_cmp(cls, op):
     Wrap comparison operations to convert Period-like to PeriodDtype
     """
     opname = '__{name}__'.format(name=op.__name__)
-    nat_result = True if opname == '__ne__' else False
+    nat_result = opname == '__ne__'
 
     def wrapper(self, other):
         op = getattr(self.asi8, opname)
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 4f0c96f79..06e2bf76f 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -62,7 +62,7 @@ def _td_array_cmp(cls, op):
     Wrap comparison operations to convert timedelta-like to timedelta64
     """
     opname = '__{name}__'.format(name=op.__name__)
-    nat_result = True if opname == '__ne__' else False
+    nat_result = opname == '__ne__'
 
     def wrapper(self, other):
         if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
diff --git a/pandas/core/computation/pytables.py b/pandas/core/computation/pytables.py
index 678c1e678..18f13e17c 100644
--- a/pandas/core/computation/pytables.py
+++ b/pandas/core/computation/pytables.py
@@ -252,7 +252,7 @@ class FilterBinOp(BinOp):
                              .format(slf=self))
 
         rhs = self.conform(self.rhs)
-        values = [TermValue(v, v, self.kind) for v in rhs]
+        values = [TermValue(v, v, self.kind).value for v in rhs]
 
         if self.is_in_table:
 
@@ -263,7 +263,7 @@ class FilterBinOp(BinOp):
                 self.filter = (
                     self.lhs,
                     filter_op,
-                    pd.Index([v.value for v in values]))
+                    pd.Index(values))
 
                 return self
             return None
@@ -275,7 +275,7 @@ class FilterBinOp(BinOp):
             self.filter = (
                 self.lhs,
                 filter_op,
-                pd.Index([v.value for v in values]))
+                pd.Index(values))
 
         else:
             raise TypeError("passing a filterable condition to a non-table "
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index ad62146dd..f6561948d 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -1111,11 +1111,9 @@ def find_common_type(types):
     # this is different from numpy, which casts bool with float/int as int
     has_bools = any(is_bool_dtype(t) for t in types)
     if has_bools:
-        has_ints = any(is_integer_dtype(t) for t in types)
-        has_floats = any(is_float_dtype(t) for t in types)
-        has_complex = any(is_complex_dtype(t) for t in types)
-        if has_ints or has_floats or has_complex:
-            return np.object
+        for t in types:
+            if is_integer_dtype(t) or is_float_dtype(t) or is_complex_dtype(t):
+                return np.object
 
     return np.find_common_type(types, [])
 
diff --git a/pandas/core/dtypes/concat.py b/pandas/core/dtypes/concat.py
index aada777de..10e903acb 100644
--- a/pandas/core/dtypes/concat.py
+++ b/pandas/core/dtypes/concat.py
@@ -123,8 +123,6 @@ def _concat_compat(to_concat, axis=0):
         except Exception:
             return True
 
-    nonempty = [x for x in to_concat if is_nonempty(x)]
-
     # If all arrays are empty, there's nothing to convert, just short-cut to
     # the concatenation, #3121.
     #
@@ -148,11 +146,11 @@ def _concat_compat(to_concat, axis=0):
     elif 'sparse' in typs:
         return _concat_sparse(to_concat, axis=axis, typs=typs)
 
-    extensions = [is_extension_array_dtype(x) for x in to_concat]
-    if any(extensions) and axis == 1:
+    all_empty = all(not is_nonempty(x) for x in to_concat)
+    if any(is_extension_array_dtype(x) for x in to_concat) and axis == 1:
         to_concat = [np.atleast_2d(x.astype('object')) for x in to_concat]
 
-    if not nonempty:
+    if all_empty:
         # we have all empties, but may need to coerce the result dtype to
         # object if we have non-numeric type operands (numpy would otherwise
         # cast this to float)
diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index f9eea8c63..8b9ac6804 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -414,8 +414,7 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
             cat_array = hash_tuples(categories)
         else:
             if categories.dtype == 'O':
-                types = [type(x) for x in categories]
-                if not len(set(types)) == 1:
+                if len({type(x) for x in categories}) != 1:
                     # TODO: hash_array doesn't handle mixed types. It casts
                     # everything to a str first, which means we treat
                     # {'1', '2'} the same as {'1', 2}
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 19da8ba5c..5ceb9db39 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1535,8 +1535,8 @@ class DataFrame(NDFrame):
                     result_index = Index([], name=index)
             else:
                 try:
-                    to_remove = [arr_columns.get_loc(field) for field in index]
-                    index_data = [arrays[i] for i in to_remove]
+                    index_data = [arrays[arr_columns.get_loc(field)]
+                                  for field in index]
                     result_index = ensure_index_from_sequences(index_data,
                                                                names=index)
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index bb5c0e49e..ef629361c 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1564,14 +1564,14 @@ class NDFrame(PandasObject, SelectionMixin):
         -------
         is_label: bool
         """
-        axis = self._get_axis_number(axis)
-        other_axes = [ax for ax in range(self._AXIS_LEN) if ax != axis]
-
         if self.ndim > 2:
             raise NotImplementedError(
                 "_is_label_reference is not implemented for {type}"
                 .format(type=type(self)))
 
+        axis = self._get_axis_number(axis)
+        other_axes = (ax for ax in range(self._AXIS_LEN) if ax != axis)
+
         return (key is not None and
                 is_hashable(key) and
                 any(key in self.axes[ax] for ax in other_axes))
@@ -1623,15 +1623,14 @@ class NDFrame(PandasObject, SelectionMixin):
         ------
         ValueError: `key` is ambiguous
         """
-
-        axis = self._get_axis_number(axis)
-        other_axes = [ax for ax in range(self._AXIS_LEN) if ax != axis]
-
         if self.ndim > 2:
             raise NotImplementedError(
                 "_check_label_or_level_ambiguity is not implemented for {type}"
                 .format(type=type(self)))
 
+        axis = self._get_axis_number(axis)
+        other_axes = (ax for ax in range(self._AXIS_LEN) if ax != axis)
+
         if (key is not None and
                 is_hashable(key) and
                 key in self.axes[axis].names and
@@ -1689,15 +1688,14 @@ class NDFrame(PandasObject, SelectionMixin):
             if `key` is ambiguous. This will become an ambiguity error in a
             future version
         """
-
-        axis = self._get_axis_number(axis)
-        other_axes = [ax for ax in range(self._AXIS_LEN) if ax != axis]
-
         if self.ndim > 2:
             raise NotImplementedError(
                 "_get_label_or_level_values is not implemented for {type}"
                 .format(type=type(self)))
 
+        axis = self._get_axis_number(axis)
+        other_axes = [ax for ax in range(self._AXIS_LEN) if ax != axis]
+
         if self._is_label_reference(key, axis=axis):
             self._check_label_or_level_ambiguity(key, axis=axis)
             values = self.xs(key, axis=other_axes[0])._values
@@ -1753,14 +1751,13 @@ class NDFrame(PandasObject, SelectionMixin):
         ValueError
             if any `keys` match neither a label nor a level
         """
-
-        axis = self._get_axis_number(axis)
-
         if self.ndim > 2:
             raise NotImplementedError(
                 "_drop_labels_or_levels is not implemented for {type}"
                 .format(type=type(self)))
 
+        axis = self._get_axis_number(axis)
+
         # Validate keys
         keys = com.maybe_make_list(keys)
         invalid_keys = [k for k in keys if not
@@ -8579,7 +8576,7 @@ class NDFrame(PandasObject, SelectionMixin):
             cond = self._constructor(cond, **self._construct_axes_dict())
 
         # make sure we are boolean
-        fill_value = True if inplace else False
+        fill_value = bool(inplace)
         cond = cond.fillna(fill_value)
 
         msg = "Boolean array expected for the condition, not {dtype}"
@@ -10243,8 +10240,8 @@ class NDFrame(PandasObject, SelectionMixin):
 
 def _doc_parms(cls):
     """Return a tuple of the doc parms."""
-    axis_descr = "{%s}" % ', '.join(["{0} ({1})".format(a, i)
-                                     for i, a in enumerate(cls._AXIS_ORDERS)])
+    axis_descr = "{%s}" % ', '.join("{0} ({1})".format(a, i)
+                                    for i, a in enumerate(cls._AXIS_ORDERS))
     name = (cls._constructor_sliced.__name__
             if cls._AXIS_LEN > 1 else 'scalar')
     name2 = cls.__name__
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index c8ea9ce68..27e13e86a 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -1462,8 +1462,8 @@ class DataFrameGroupBy(NDFrameGroupBy):
         # reindex `result`, and then reset the in-axis grouper columns.
 
         # Select in-axis groupers
-        in_axis_grps = [(i, ping.name) for (i, ping)
-                        in enumerate(groupings) if ping.in_axis]
+        in_axis_grps = ((i, ping.name) for (i, ping)
+                        in enumerate(groupings) if ping.in_axis)
         g_nums, g_names = zip(*in_axis_grps)
 
         result = result.drop(labels=list(g_names), axis=1)
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index c8f1a75b2..c7f1aa697 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -443,12 +443,12 @@ class _GroupBy(PandasObject, SelectionMixin):
                     raise ValueError(msg)
 
             converters = [get_converter(s) for s in index_sample]
-            names = [tuple(f(n) for f, n in zip(converters, name))
-                     for name in names]
+            names = (tuple(f(n) for f, n in zip(converters, name))
+                     for name in names)
 
         else:
             converter = get_converter(index_sample)
-            names = [converter(name) for name in names]
+            names = (converter(name) for name in names)
 
         return [self.indices.get(name, []) for name in names]
 
diff --git a/pandas/core/groupby/grouper.py b/pandas/core/groupby/grouper.py
index b0d7cf9d4..edba9439a 100644
--- a/pandas/core/groupby/grouper.py
+++ b/pandas/core/groupby/grouper.py
@@ -195,9 +195,9 @@ class Grouper(object):
         return self.grouper.groups
 
     def __repr__(self):
-        attrs_list = ["{}={!r}".format(attr_name, getattr(self, attr_name))
+        attrs_list = ("{}={!r}".format(attr_name, getattr(self, attr_name))
                       for attr_name in self._attributes
-                      if getattr(self, attr_name) is not None]
+                      if getattr(self, attr_name) is not None)
         attrs = ", ".join(attrs_list)
         cls_name = self.__class__.__name__
         return "{}({})".format(cls_name, attrs)
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index 0a5536854..c6d31339f 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -780,8 +780,8 @@ class CategoricalIndex(Index, accessor.PandasDelegate):
         Concatenate to_concat which has the same class
         ValueError if other is not in the categories
         """
-        to_concat = [self._is_dtype_compat(c) for c in to_concat]
-        codes = np.concatenate([c.codes for c in to_concat])
+        codes = np.concatenate([self._is_dtype_compat(c).codes
+                                for c in to_concat])
         result = self._create_from_codes(codes, name=name)
         # if name is None, _create_from_codes sets self.name
         result.name = name
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index bbcde8f3b..539da0bea 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -347,10 +347,10 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
                         # must have all defined axes if we have a scalar
                         # or a list-like on the non-info axes if we have a
                         # list-like
-                        len_non_info_axes = [
+                        len_non_info_axes = (
                             len(_ax) for _i, _ax in enumerate(self.obj.axes)
                             if _i != i
-                        ]
+                        )
                         if any(not l for l in len_non_info_axes):
                             if not is_list_like_indexer(value):
                                 raise ValueError("cannot set a frame with no "
diff --git a/pandas/core/internals/construction.py b/pandas/core/internals/construction.py
index c05a9a0f8..7e9751268 100644
--- a/pandas/core/internals/construction.py
+++ b/pandas/core/internals/construction.py
@@ -197,18 +197,12 @@ def init_dict(data, index, columns, dtype=None):
             arrays.loc[missing] = [val] * missing.sum()
 
     else:
-
-        for key in data:
-            if (isinstance(data[key], ABCDatetimeIndex) and
-                    data[key].tz is not None):
-                # GH#24096 need copy to be deep for datetime64tz case
-                # TODO: See if we can avoid these copies
-                data[key] = data[key].copy(deep=True)
-
         keys = com.dict_keys_to_ordered_list(data)
         columns = data_names = Index(keys)
-        arrays = [data[k] for k in keys]
-
+        # GH#24096 need copy to be deep for datetime64tz case
+        # TODO: See if we can avoid these copies
+        arrays = [data[k] if not is_datetime64tz_dtype(data[k]) else
+                  data[k].copy(deep=True) for k in keys]
     return arrays_to_mgr(arrays, data_names, index, columns, dtype=dtype)
 
 
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index e26176cff..ff4dd7da1 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -83,9 +83,9 @@ class Resampler(_GroupBy):
         """
         Provide a nice str repr of our rolling object.
         """
-        attrs = ["{k}={v}".format(k=k, v=getattr(self.groupby, k))
+        attrs = ("{k}={v}".format(k=k, v=getattr(self.groupby, k))
                  for k in self._attributes if
-                 getattr(self.groupby, k, None) is not None]
+                 getattr(self.groupby, k, None) is not None)
         return "{klass} [{attrs}]".format(klass=self.__class__.__name__,
                                           attrs=', '.join(attrs))
 
diff --git a/pandas/core/reshape/pivot.py b/pandas/core/reshape/pivot.py
index c7c447d18..54f11646f 100644
--- a/pandas/core/reshape/pivot.py
+++ b/pandas/core/reshape/pivot.py
@@ -88,9 +88,9 @@ def pivot_table(data, values=None, index=None, columns=None, aggfunc='mean',
         # the original values are ints
         # as we grouped with a NaN value
         # and then dropped, coercing to floats
-        for v in [v for v in values if v in data and v in agged]:
-            if (is_integer_dtype(data[v]) and
-                    not is_integer_dtype(agged[v])):
+        for v in values:
+            if (v in data and is_integer_dtype(data[v]) and
+                    v in agged and not is_integer_dtype(agged[v])):
                 agged[v] = maybe_downcast_to_dtype(agged[v], data[v].dtype)
 
     table = agged
diff --git a/pandas/core/reshape/tile.py b/pandas/core/reshape/tile.py
index 7ad2549bd..2a654fec3 100644
--- a/pandas/core/reshape/tile.py
+++ b/pandas/core/reshape/tile.py
@@ -372,14 +372,6 @@ def _bins_to_cuts(x, bins, right=True, labels=None,
     return result, bins
 
 
-def _trim_zeros(x):
-    while len(x) > 1 and x[-1] == '0':
-        x = x[:-1]
-    if len(x) > 1 and x[-1] == '.':
-        x = x[:-1]
-    return x
-
-
 def _coerce_to_type(x):
     """
     if the passed data is of datetime/timedelta type,
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index bfa36cb4b..183a91c95 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -1872,7 +1872,7 @@ class StringMethods(NoNewAttributesMixin):
 
         if expand is None:
             # infer from ndim if expand is not specified
-            expand = False if result.ndim == 1 else True
+            expand = result.ndim != 1
 
         elif expand is True and not isinstance(self._orig, Index):
             # required when expand=True is explicitly specified
diff --git a/pandas/core/tools/numeric.py b/pandas/core/tools/numeric.py
index bfe78b929..b8a7eb5b0 100644
--- a/pandas/core/tools/numeric.py
+++ b/pandas/core/tools/numeric.py
@@ -138,7 +138,7 @@ def to_numeric(arg, errors='raise', downcast=None):
             values = values.astype(np.int64)
         else:
             values = ensure_object(values)
-            coerce_numeric = False if errors in ('ignore', 'raise') else True
+            coerce_numeric = errors not in ('ignore', 'raise')
             values = lib.maybe_convert_numeric(values, set(),
                                                coerce_numeric=coerce_numeric)
 
diff --git a/pandas/core/window.py b/pandas/core/window.py
index 5f3ea7db5..fb37d790f 100644
--- a/pandas/core/window.py
+++ b/pandas/core/window.py
@@ -164,9 +164,9 @@ class _Window(PandasObject, SelectionMixin):
         Provide a nice str repr of our rolling object.
         """
 
-        attrs = ["{k}={v}".format(k=k, v=getattr(self, k))
+        attrs = ("{k}={v}".format(k=k, v=getattr(self, k))
                  for k in self._attributes
-                 if getattr(self, k, None) is not None]
+                 if getattr(self, k, None) is not None)
         return "{klass} [{attrs}]".format(klass=self._window_type,
                                           attrs=','.join(attrs))
 
diff --git a/pandas/tests/arrays/test_integer.py b/pandas/tests/arrays/test_integer.py
index 09298bb5c..67e7db546 100644
--- a/pandas/tests/arrays/test_integer.py
+++ b/pandas/tests/arrays/test_integer.py
@@ -339,7 +339,7 @@ class TestComparisonOps(BaseOpsUtil):
         expected = pd.Series(op(data._data, other))
 
         # fill the nan locations
-        expected[data._mask] = True if op_name == '__ne__' else False
+        expected[data._mask] = op_name == '__ne__'
 
         tm.assert_series_equal(result, expected)
 
@@ -351,7 +351,7 @@ class TestComparisonOps(BaseOpsUtil):
         expected = op(expected, other)
 
         # fill the nan locations
-        expected[data._mask] = True if op_name == '__ne__' else False
+        expected[data._mask] = op_name == '__ne__'
 
         tm.assert_series_equal(result, expected)
 

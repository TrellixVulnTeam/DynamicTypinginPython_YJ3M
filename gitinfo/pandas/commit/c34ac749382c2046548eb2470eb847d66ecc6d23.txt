commit c34ac749382c2046548eb2470eb847d66ecc6d23
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 4 04:09:32 2010 +0000

    more unit test coverage for DataFrame etc.
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@101 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index cacd7af01..d46343807 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -12,7 +12,7 @@ import numpy as np
 from pandas.core.daterange import DateRange
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.mixins import Picklable, Groupable
-from pandas.core.series import Series, remove_na
+from pandas.core.series import Series
 from pandas.lib.tseries import isnull, notnull
 import pandas.core.datetools as datetools
 import pandas.lib.tseries as tseries
@@ -534,14 +534,13 @@ class DataFrame(Picklable, Groupable):
         return DataMatrix(self._series, index=self.index)
 
     def toString(self, buffer=sys.stdout, verbose=False,
-                 colSpace=15, nanRep=None, formatters=None,
+                 colSpace=15, nanRep='NaN', formatters=None,
                  float_format=None):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
         columns = sorted(series.keys())
         formatters = formatters or {}
 
-
         # TODO
 
         float_format = float_format or str
@@ -570,15 +569,15 @@ class DataFrame(Picklable, Groupable):
 
     def info(self, buffer=sys.stdout):
         """Concise summary of a DataFrame, used in __repr__ when very large."""
-        if len(self._series) == 0:
-            print >> buffer, 'DataFrame is empty!'
-            print >> buffer, repr(self.index)
-
         print >> buffer, 'Index: %s entries, %s to %s' % (len(self.index),
                                                           min(self.index),
                                                           max(self.index))
         print >> buffer, 'Data columns:'
 
+        if len(self._series) == 0:
+            print >> buffer, 'DataFrame is empty!'
+            return
+
         series = self._series
         columns = sorted(self.cols())
         space = max([len(str(k)) for k in columns]) + 4
@@ -978,16 +977,18 @@ class DataFrame(Picklable, Groupable):
         return DataFrame(newSeries, index=index)
 
     def _reindex_columns(self, columns):
-        if len(columns) == 0:
-            return DataFrame(index=self.index)
+        result = DataFrame(index=self.index)
 
-        newFrame = self.filterItems(columns)
+        if len(columns) == 0:
+            return result
 
         for col in columns:
-            if col not in newFrame:
-                newFrame[col] = NaN
+            if col in self:
+                result[col] = self[col]
+            else:
+                result[col] = NaN
 
-        return newFrame
+        return result
 
     @property
     def T(self):
@@ -1117,7 +1118,16 @@ class DataFrame(Picklable, Groupable):
 
     def tgroupby(self, keyfunc, applyfunc):
         """
-        Call groupby on transposed frame
+        Aggregate columns based on passed function
+
+        Parameters
+        ----------
+        keyfunc : function
+        applyfunc : function
+
+        Returns
+        -------
+        y : DataFrame
         """
         return self.T.groupby(keyfunc).aggregate(applyfunc).T
 
@@ -1125,18 +1135,18 @@ class DataFrame(Picklable, Groupable):
         """
         TODO
         """
+        import re
+
         if items:
             data = dict([(r, self[r]) for r in items if r in self])
             return DataFrame(data=data, index=self.index)
         elif like:
-            mycopy = self.copy()
-            for col in mycopy._series.keys():
-                series = mycopy._series.pop(col)
-                if like in col:
-                    mycopy._series[col] = series
-            return mycopy
+            columns = [c for c in self.cols() if like in c]
+            return self.reindex(columns=columns)
         elif regex:
-            pass
+            matcher = re.compile(regex)
+            columns = [c for c in self.cols() if matcher.match(c)]
+            return self.reindex(columns=columns)
 
     def filterItems(self, items):
         """
@@ -1196,124 +1206,132 @@ class DataFrame(Picklable, Groupable):
             newIndex = self.index[idx.astype(int)]
             return self.reindex(newIndex)
 
-    def combineFirst(self, otherFrame):
+    def combine(self, other, func, fill_value=None):
         """
-        Combine two DataFrame / DataMatrix objects and default to value
-        in frame calling the method.
+        Add two DataFrame / DataMatrix objects and do not propagate NaN values,
+        so if for a (column, time) one frame is missing a value, it will
+        default to the other frame's value (which might be NaN as well)
 
         Parameters
         ----------
-        otherFrame : DataFrame / Matrix
-
-        Examples
-        --------
-        a.combineFirst(b)
-            a's values prioritized, use values from b to fill holes
+        other : DataFrame / Matrix
 
         Returns
         -------
         DataFrame
         """
-        if not otherFrame:
+        if not other:
             return self
 
         if not self:
-            return otherFrame
+            return other
 
-        if self.index is not otherFrame.index:
-            unionIndex = self.index + otherFrame.index
+        if self.index is not other.index:
+            unionIndex = self.index + other.index
             frame = self.reindex(unionIndex)
-            otherFrame = otherFrame.reindex(unionIndex)
+            other = other.reindex(unionIndex)
         else:
             unionIndex = self.index
             frame = self
 
+        do_fill = fill_value is not None
+        unionCols = sorted(set(frame.cols() + other.cols()))
+
         result = {}
-        for col, series in frame.iteritems():
-            otherSeries = otherFrame[col] if col in otherFrame else None
-            if otherSeries is not None:
-                result[col] = series.__class__(np.where(isnull(series),
-                                                        otherSeries, series),
-                                               index=unionIndex)
-            else:
-                result[col] = series
+        for col in unionCols:
+            if col in frame and col in other:
+                series = frame[col].values()
+                otherSeries = other[col].values()
 
-        for col, series in otherFrame.iteritems():
-            if col not in self:
-                result[col] = series
+                if do_fill:
+                    this_mask = isnull(series)
+                    other_mask = isnull(otherSeries)
+                    series = series.copy()
+                    otherSeries = otherSeries.copy()
+                    series[this_mask] = fill_value
+                    otherSeries[other_mask] = fill_value
 
-        return DataFrame(result, index=unionIndex)
+                result[col] = func(series, otherSeries)
 
-    def combine(self, func, fill_value=np.NaN):
-        pass
+                if do_fill:
+                    result[col][this_mask & other_mask] = np.NaN
+
+            elif col in frame:
+                result[col] = frame[col]
+            elif col in other:
+                result[col] = other[col]
+
+        return DataFrame(result, index = unionIndex)
 
-    def combineAdd(self, otherFrame):
+    def combineFirst(self, other):
         """
-        Add two DataFrame / DataMatrix objects and do not propagate NaN values,
-        so if for a (column, time) one frame is missing a value, it will
-        default to the other frame's value (which might be NaN as well)
+        Combine two DataFrame / DataMatrix objects and default to value
+        in frame calling the method.
 
         Parameters
         ----------
         otherFrame : DataFrame / Matrix
 
+        Examples
+        --------
+        a.combineFirst(b)
+            a's values prioritized, use values from b to fill holes
+
         Returns
         -------
         DataFrame
         """
-        if not otherFrame:
-            return self
+        combiner = lambda x, y: np.where(isnull(x), y, x)
+        return self.combine(other, combiner)
 
-        if not self:
-            return otherFrame
-
-        if self.index is not otherFrame.index:
-            unionIndex = self.index + otherFrame.index
-            frame = self.reindex(unionIndex)
-            otherFrame = otherFrame.reindex(unionIndex)
-        else:
-            unionIndex = self.index
-            frame = self
-
-        unionCols = sorted(set(frame.cols() + otherFrame.cols()))
+    def combineAdd(self, other):
+        """
+        Add two DataFrame / DataMatrix objects and do not propagate
+        NaN values, so if for a (column, time) one frame is missing a
+        value, it will default to the other frame's value (which might
+        be NaN as well)
 
-        result = {}
-        for col in unionCols:
-            if col in frame and col in otherFrame:
-                series = frame[col].view(np.ndarray)
-                otherSeries = otherFrame[col].view(np.ndarray)
-                sok = np.isfinite(series)
-                ook = np.isfinite(otherSeries)
+        Parameters
+        ----------
+        other : DataFrame / Matrix
 
-                result[col] = np.where(sok & ook, series + otherSeries,
-                                       np.where(sok, series, otherSeries))
+        Returns
+        -------
+        DataFrame
+        """
+        return self.combine(other, np.add, fill_value=0.)
 
-            elif col in frame:
-                result[col] = frame[col]
-            elif col in otherFrame:
-                result[col] = otherFrame[col]
-            else:
-                raise Exception('Phantom column, be very afraid')
+    def combineMult(self, other):
+        """
+        Multiply two DataFrame / DataMatrix objects and do not
+        propagate NaN values, so if for a (column, time) one frame is
+        missing a value, it will default to the other frame's value
+        (which might be NaN as well)
 
-        return DataFrame(result, index = unionIndex)
+        Parameters
+        ----------
+        other : DataFrame / Matrix
 
-    def combineMult(self, otherFrame):
-        return (self * otherFrame).combineFirst(self)
+        Returns
+        -------
+        DataFrame
+        """
+        return self.combine(other, np.multiply, fill_value=1.)
 
     def outerJoin(self, *frames):
-        mergedSeries = self._series.copy()
-
         unionIndex = self.index
         for frame in frames:
             unionIndex  = unionIndex + frame.index
 
+        joined = self.reindex(unionIndex)
         for frame in frames:
+            frame = frame.reindex(unionIndex)
             for col, series in frame.iteritems():
-                if col in mergedSeries:
+                if col in joined:
                     raise Exception('Overlapping columns!')
-                mergedSeries[col] = series
+                joined[col] = series
 
-        return DataFrame.fromDict(mergedSeries)
+        return joined
 
     def leftJoin(self, *frames):
         """
@@ -1330,16 +1348,15 @@ class DataFrame(Picklable, Groupable):
         -------
         DataFrame
         """
-        mergedSeries = DataFrame(index=self.index)
-        mergedSeries._series = self._series.copy()
+        joined = self.copy()
 
         for frame in frames:
             for col, series in frame.iteritems():
-                if col in mergedSeries:
+                if col in joined:
                     raise Exception('Overlapping columns!')
-                mergedSeries[col] = series
+                joined[col] = series.copy()
 
-        return mergedSeries
+        return joined
 
     def merge(self, other, on=None):
         """
@@ -1387,7 +1404,7 @@ class DataFrame(Picklable, Groupable):
 
         return DataFrame(newSeries, index=self.index)
 
-    def plot(self, kind='line', **kwds):
+    def plot(self, kind='line', **kwds): # pragma: no cover
         """
         Plot the DataFrame's series with the index on the x-axis using
         matplotlib / pylab.
@@ -1430,10 +1447,7 @@ class DataFrame(Picklable, Groupable):
             theCount = np.isfinite(self.values).sum(axis)
         except Exception:
             f = lambda s: notnull(s).sum()
-            if axis == 0:
-                theCount = self.apply(f)
-            elif axis == 1:
-                theCount = self.tapply(f)
+            theCount = self.apply(f, axis=axis)
 
         if asarray:
             return theCount
@@ -1542,7 +1556,7 @@ class DataFrame(Picklable, Groupable):
             if axis == 0:
                 theProd = self.apply(np.prod)
             else:
-                theProd = self.tapply(np.prod)
+                theProd = self.apply(np.prod, axis=1)
 
         if asarray:
             return theProd
@@ -1582,10 +1596,10 @@ class DataFrame(Picklable, Groupable):
         Series or TimeSeries
         """
         if axis == 0:
-            med = [np.median(remove_na(self[col])) for col in self.columns]
+            med = [np.median(self[col].valid()) for col in self.columns]
             return Series(med, index=self.columns)
         elif axis == 1:
-            med = [np.median(remove_na(self.getXS(k))) for k in self.index]
+            med = [np.median(self.getXS(k).valid()) for k in self.index]
             return Series(med, index=self.index)
         else:
             raise Exception('Must have 0<= axis <= 1')
@@ -1604,10 +1618,10 @@ class DataFrame(Picklable, Groupable):
         Series or TimeSeries
         """
         if axis == 0:
-            med = [np.min(remove_na(self[col])) for col in self.columns]
+            med = [np.min(self[col].valid()) for col in self.columns]
             return Series(med, index=self.columns)
         elif axis == 1:
-            med = [np.min(remove_na(self.getXS(k))) for k in self.index]
+            med = [np.min(self.getXS(k).valid()) for k in self.index]
             return Series(med, index=self.index)
         else:
             raise Exception('Must have 0<= axis <= 1')
@@ -1626,10 +1640,10 @@ class DataFrame(Picklable, Groupable):
         Series or TimeSeries
         """
         if axis == 0:
-            med = [np.max(remove_na(self[col])) for col in self.columns]
+            med = [np.max(self[col].valid()) for col in self.columns]
             return Series(med, index=self.columns)
         elif axis == 1:
-            med = [np.max(remove_na(self.getXS(k))) for k in self.index]
+            med = [np.max(self.getXS(k).valid()) for k in self.index]
             return Series(med, index=self.index)
         else:
             raise Exception('Must have 0<= axis <= 1')
@@ -1660,13 +1674,15 @@ class DataFrame(Picklable, Groupable):
         if not issubclass(y.dtype.type, np.int_):
             y[np.isnan(y)] = 0
 
+        result = np.abs(y).mean(axis=axis)
+
         if asarray:
-            return np.sum(np.abs(y), axis)
+            return result
 
         if axis == 0:
-            return Series(np.sum(np.abs(y), axis), self.cols())
+            return Series(result, demeaned.cols())
         else:
-            return Series(np.sum(np.abs(y), axis), self.index)
+            return Series(result, demeaned.index)
 
     def var(self, axis=0, asarray=False):
         """
@@ -1758,6 +1774,7 @@ def _pfixed(s, space, nanRep=None):
         fstring = '%-' + str(space-4) + 'g'
         if nanRep is not None and isnull(s):
             return nanRep.ljust(space)
+
         return (fstring % s).ljust(space)
     else:
         return str(s)[:space-4].ljust(space)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 0998ec0cb..3e6bc4e98 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -149,6 +149,7 @@ class DataMatrix(DataFrame):
 
             values = np.empty((N, K), dtype=dtype)
             values[:] = NaN
+
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
@@ -293,7 +294,7 @@ class DataMatrix(DataFrame):
 #-------------------------------------------------------------------------------
 # Outputting
 
-    def toCSV(self, path=None, nanRep='', writeMode='wb', index=True,
+    def toCSV(self, path, nanRep='', writeMode='wb', index=True,
               header=True, cols=None, verbose=False):
         """
         Write the DataMatrix to a CSV file
@@ -312,34 +313,34 @@ class DataMatrix(DataFrame):
             Prints the values in order specified by cols.
             By default, prints all columns in lexicographical order.
         """
-        if path is None:
-            f = sys.stdout
-        else:
-            f = open(path, writeMode)
+        f = open(path, writeMode)
+
         if cols is None:
             cols = self.cols()
-        serDict = self._series
+        series = self._series
 
         if header:
             if index:
                 f.write(',')
             f.write(','.join([str(c) for c in cols]))
             f.write('\n')
+
         for idx in self.index:
             if index:
                 f.write(str(idx) + ',')
+
             for col in cols:
-                val = serDict[col].get(idx)
-                if isinstance(val, float) and np.isnan(val) == True:
+                val = series[col][idx]
+                if isnull(val):
                     val = nanRep
                 else:
                     val = str(val)
                 f.write(val + ',')
             f.write('\n')
-        if path is not None:
-            f.close()
 
-        if verbose:
+        f.close()
+
+        if verbose: # pragma: no cover
             print 'CSV file written successfully: %s' % path
 
     def toString(self, buffer=sys.stdout, verbose=False,
@@ -388,16 +389,17 @@ class DataMatrix(DataFrame):
         """
         Concise summary of a DataMatrix, used in __repr__ when very large.
         """
-        if len(self.columns) == 0:
-            print >> buffer, 'DataMatrix is empty!'
-            print >> buffer, repr(self.index)
-
         print >> buffer, 'Index: %s entries' % len(self.index),
         if len(self.index) > 0:
             print >> buffer, ', %s to %s' % (self.index[0], self.index[-1])
         else:
             print >> buffer, ''
 
+        if len(self.columns) == 0:
+            print >> buffer, 'DataMatrix is empty!'
+            print >> buffer, repr(self.index)
+            return
+
         print >> buffer, 'Data columns:'
         space = max([len(str(k)) for k in self.cols()]) + 4
 
@@ -485,20 +487,14 @@ class DataMatrix(DataFrame):
 # "Magic methods"
 
     def __nonzero__(self):
-        if self.values is not None:
-            N, K = self.values.shape
-            if N == 0 or K == 0:
-                if self.objects is None:
-                    return False
-                else:
-                    return self.objects.__nonzero__()
-            else:
-                return True
-        else:
+        N, K = self.values.shape
+        if N == 0 or K == 0:
             if self.objects is None:
                 return False
             else:
                 return self.objects.__nonzero__()
+        else:
+            return True
 
     def __neg__(self):
         mycopy = self.copy()
@@ -592,7 +588,7 @@ class DataMatrix(DataFrame):
         if value.dtype not in self._dataTypes:
             isObject = True
 
-        if self.values is None:
+        if len(self.columns) == 0:
             if isObject:
                 if self.objects is None:
                     self.objects = DataMatrix({key : value},
@@ -600,7 +596,7 @@ class DataMatrix(DataFrame):
                 else:
                     self.objects[key] = value
             else:
-                self.values = value.reshape((len(value), 1))
+                self.values = value.reshape((len(value), 1)).copy()
                 self.columns = Index([key])
             return
 
@@ -609,13 +605,14 @@ class DataMatrix(DataFrame):
                 loc = self.columns.indexMap[key]
                 self.values[:, loc] = value
             elif len(self.columns) == 0:
-                self.values = value.reshape((len(value), 1))
+                self.values = value.reshape((len(value), 1)).copy()
                 self.columns = Index([key])
             else:
                 try:
                     loc = bisect.bisect_right(self.columns, key)
                 except TypeError:
                     loc = len(self.columns)
+
                 if loc == self.values.shape[1]:
                     newValues = np.c_[self.values, value]
                     newColumns = Index(np.concatenate((self.columns, [key])))
diff --git a/pandas/core/series.py b/pandas/core/series.py
index c45063f9f..b66d819e4 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1000,7 +1000,7 @@ class Series(np.ndarray, Picklable, Groupable):
         if isinstance(other, dict):
             other = Series.fromDict(other)
 
-        if not isinstance(other, Series):
+        if not isinstance(other, Series): # pragma: no cover
             raise Exception('Argument must be a Series!')
 
         fillVec, mask = tseries.getMergeVec(self, other.index.indexMap)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 916ddc7e4..842d5d3df 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1,14 +1,14 @@
 # pylint: disable-msg=W0612
 
 from copy import deepcopy
+from cStringIO import StringIO
 import os
 import unittest
 
 from numpy import random
 import numpy as np
 
-from pandas.core.api import DataFrame, Index, Series
-from pandas.core.datetools import bday
+from pandas.core.api import DataFrame, Index, Series, notnull
 import pandas.core.datetools as datetools
 
 from pandas.core.tests.common import (assert_almost_equal,
@@ -45,10 +45,13 @@ class TestDataFrame(unittest.TestCase):
             'col3' : self.ts3,
             'col4' : self.ts4,
         }
-        self.empty = DataFrame({})
+        self.empty = self.klass({})
 
     def test_constructor(self):
-        df = DataFrame()
+        df = self.klass()
+        self.assert_(len(df.index) == 0)
+
+        df = self.klass(data={})
         self.assert_(len(df.index) == 0)
 
     def test_constructor_mixed(self):
@@ -139,8 +142,23 @@ class TestDataFrame(unittest.TestCase):
         self.assertFalse(self.empty)
 
         self.assert_(self.frame)
+        self.assert_(self.mixed_frame)
+
+        # corner case
+        df = self.klass({'A' : [1., 2., 3.],
+                         'B' : ['a', 'b', 'c']},
+                        index=np.arange(3))
+        del df['A']
+        self.assert_(df)
 
     def test_repr(self):
+        # empty
+        foo = repr(self.empty)
+
+        # empty with index
+        frame = self.klass(index=np.arange(1000))
+        foo = repr(frame)
+
         # small one
         foo = repr(self.frame)
 
@@ -156,8 +174,17 @@ class TestDataFrame(unittest.TestCase):
         biggie = self.klass({'A' : randn(1000),
                              'B' : common.makeStringIndex(1000)},
                             index=range(1000))
+        biggie['A'][:20] = np.NaN
+        biggie['B'][:20] = np.NaN
+
         foo = repr(biggie)
 
+        buf = StringIO()
+        biggie.toString(buffer=buf)
+
+    def test_toString(self):
+        pass
+
     def test_getitem(self):
         # slicing
 
@@ -199,13 +226,6 @@ class TestDataFrame(unittest.TestCase):
         common.assert_dict_equal(series, self.frame['col6'],
                                  compare_keys=False)
 
-        # set value
-        self.frame['col7'] = 5
-        assert((self.frame['col7'] == 5).all())
-
-        self.frame['col8'] = 'foo'
-        assert((self.frame['col8'] == 'foo').all())
-
         self.assertRaises(Exception, self.frame.__setitem__,
                           randn(len(self.frame) + 1))
 
@@ -214,6 +234,13 @@ class TestDataFrame(unittest.TestCase):
         self.frame['col9'] = arr
         self.assert_((self.frame['col9'] == arr).all())
 
+        # set value, do out of order for DataMatrix
+        self.frame['col7'] = 5
+        assert((self.frame['col7'] == 5).all())
+
+        self.frame['col8'] = 'foo'
+        assert((self.frame['col8'] == 'foo').all())
+
     def test_delitem(self):
         del self.frame['A']
         self.assert_('A' not in self.frame)
@@ -268,7 +295,7 @@ class TestDataFrame(unittest.TestCase):
         mat[:5] = np.NaN
         mat[-5:] = np.NaN
 
-        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        frame = self.klass({'foo' : mat}, index=self.frame.index)
         index = frame._firstTimeWithValue()
 
         self.assert_(index == frame.index[5])
@@ -291,7 +318,7 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(np.isnan(added['D']).all())
 
         self_added = self.frame + self.frame
-        self.assert_(self_added.index is self.frame.index)
+        self.assert_(self_added.index.equals(self.frame.index))
 
         added_rev = frame_copy + self.frame
         self.assert_(np.isnan(added['D']).all())
@@ -358,9 +385,6 @@ class TestDataFrame(unittest.TestCase):
     def test_toDataMatrix(self):
         dm = self.frame.toDataMatrix()
 
-    def test_toString(self):
-        pass
-
     def test_info(self):
         pass
 
@@ -442,24 +466,27 @@ class TestDataFrame(unittest.TestCase):
         mat = randn(N)
         mat[:5] = np.NaN
 
-        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        frame = self.klass({'foo' : mat}, index=self.frame.index)
 
         smaller_frame = frame.dropEmptyRows()
         self.assert_(np.array_equal(smaller_frame['foo'], mat[5:]))
 
+        smaller_frame = frame.dropEmptyRows(['foo'])
+        self.assert_(np.array_equal(smaller_frame['foo'], mat[5:]))
+
     def test_dropIncompleteRows(self):
         N = len(self.frame.index)
         mat = randn(N)
         mat[:5] = np.NaN
 
-        frame = DataFrame({'foo' : mat}, index=self.frame.index)
+        frame = self.klass({'foo' : mat}, index=self.frame.index)
         frame['bar'] = 5
 
         smaller_frame = frame.dropIncompleteRows()
         self.assert_(np.array_equal(smaller_frame['foo'], mat[5:]))
 
         samesize_frame = frame.dropIncompleteRows(specificColumns=['bar'])
-        self.assert_(samesize_frame.index is self.frame.index)
+        self.assert_(samesize_frame.index.equals(self.frame.index))
 
     def test_fill(self):
         self.tsframe['A'][:5] = np.NaN
@@ -610,6 +637,14 @@ class TestDataFrame(unittest.TestCase):
                 else:
                     self.assertEqual(value, frame[col][idx])
 
+        # mixed type
+        index, data = common.getMixedTypeDict()
+        mixed = self.klass(data, index=index)
+
+        mixed_T = mixed.T
+        for col, s in mixed_T.iteritems():
+            self.assert_(s.dtype == np.object_)
+
     def test_diff(self):
         pass
 
@@ -660,8 +695,34 @@ class TestDataFrame(unittest.TestCase):
 
         assert_frame_equal(applied, self.frame * 2)
 
+    def test_groupby(self):
+        grouped = self.tsframe.groupby(lambda x: x.weekday())
+
+        # aggregate
+        aggregated = grouped.aggregate(np.mean)
+        self.assertEqual(len(aggregated), 5)
+        self.assertEqual(len(aggregated.cols()), 4)
+
+        # transform
+        transformed = grouped.transform(lambda x: x - x.mean())
+        self.assertEqual(len(aggregated), 5)
+        self.assertEqual(len(aggregated.cols()), 4)
+
+        # iterate
+        for weekday, group in grouped:
+            self.assert_(group.index[0].weekday() == weekday)
+
     def test_tgroupby(self):
-        pass
+        grouping = {
+            'A' : 0,
+            'B' : 1,
+            'C' : 0,
+            'D' : 1
+        }
+
+        grouped = self.frame.tgroupby(grouping.get, np.mean)
+        self.assertEqual(len(grouped), len(self.frame.index))
+        self.assertEqual(len(grouped.cols()), 2)
 
     def test_filter(self):
         # items
@@ -679,6 +740,9 @@ class TestDataFrame(unittest.TestCase):
         self.assert_('AA' in filtered)
 
         # regex
+        filterd = fcopy.filter(regex='[A]+')
+        self.assertEqual(len(filtered.cols()), 2)
+        self.assert_('AA' in filtered)
 
     def test_sortUp(self):
         # what to do?
@@ -742,7 +806,6 @@ class TestDataFrame(unittest.TestCase):
 
         assert_frame_equal(comb, self.frame * 2)
 
-
         # corner cases
         comb = self.frame.combineAdd(self.empty)
         self.assert_(comb is self.frame)
@@ -751,21 +814,47 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(comb is self.frame)
 
     def test_combineMult(self):
-        pass
+        # trivial
+        comb = self.frame.combineMult(self.frame)
 
-    def test_outerJoin(self):
-        pass
+        assert_frame_equal(comb, self.frame ** 2)
+
+        # corner cases
+        comb = self.frame.combineMult(self.empty)
+        self.assert_(comb is self.frame)
+
+        comb = self.empty.combineMult(self.frame)
+        self.assert_(comb is self.frame)
 
     def test_leftJoin(self):
-        pass
+        f = self.frame.reindex(columns=['A', 'B'])[:10]
+        f2 = self.frame.reindex(columns=['C', 'D'])
+
+        joined = f.leftJoin(f2)
+        self.assert_(f.index.equals(joined.index))
+        self.assertEqual(len(joined.cols()), 4)
+
+        # corner case
+        self.assertRaises(Exception, self.frame.leftJoin, self.frame)
+
+    def test_outerJoin(self):
+        f = self.frame.reindex(columns=['A', 'B'])[:10]
+        f2 = self.frame.reindex(columns=['C', 'D'])
+
+        joined = f.outerJoin(f2)
+        self.assert_(common.equalContents(self.frame.index, joined.index))
+        self.assertEqual(len(joined.cols()), 4)
+
+        # corner case
+        self.assertRaises(Exception, self.frame.outerJoin, self.frame)
 
     def test_merge(self):
         index, data = common.getMixedTypeDict()
-        target = DataFrame(data, index=index)
+        target = self.klass(data, index=index)
 
         # Merge on string value
-        source = DataFrame({'MergedA' : data['A'], 'MergedD' : data['D']},
-                           index=data['C'])
+        source = self.klass({'MergedA' : data['A'], 'MergedD' : data['D']},
+                            index=data['C'])
         merged = target.merge(source, on='C')
 
         self.assert_(np.array_equal(merged['MergedA'], target['A']))
@@ -773,46 +862,103 @@ class TestDataFrame(unittest.TestCase):
 
         # Test when some are missing
 
+        # corner case
+
     def test_statistics(self):
         sumFrame = self.frame.apply(np.sum)
         for col, series in self.frame.iteritems():
             self.assertEqual(sumFrame[col], series.sum())
 
+    def _check_statistic(self, frame, name, alternative):
+        f = getattr(frame, name)
+
+        result = f(axis=0)
+        assert_series_equal(result, frame.apply(alternative))
+
+        result = f(axis=1)
+        comp = frame.apply(alternative, axis=1).reindex(result.index)
+        assert_series_equal(result, comp)
+
+        self.assertRaises(Exception, f, axis=2)
+
     def test_count(self):
-        pass
+        f = lambda s: notnull(s).sum()
+
+        self._check_statistic(self.frame, 'count', f)
 
     def test_sum(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].sum()
+
+        self._check_statistic(self.frame, 'sum', f)
 
     def test_product(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return np.prod(x[notnull(x)])
+
+        self._check_statistic(self.frame, 'product', f)
 
     def test_mean(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].mean()
+
+        self._check_statistic(self.frame, 'mean', f)
 
     def test_median(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return np.median(x[notnull(x)])
+
+        self._check_statistic(self.frame, 'median', f)
 
     def test_min(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].min()
+
+        self._check_statistic(self.frame, 'min', f)
 
     def test_max(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].max()
+
+        self._check_statistic(self.frame, 'max', f)
 
     def test_mad(self):
-        pass
+        f = lambda x: np.abs(x - x.mean()).mean()
+
+        self._check_statistic(self.frame, 'mad', f)
 
     def test_var(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].var(ddof=1)
+
+        self._check_statistic(self.frame, 'var', f)
 
     def test_std(self):
-        pass
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].std(ddof=1)
+
+        self._check_statistic(self.frame, 'std', f)
 
     def test_skew(self):
-        pass
+        from scipy.stats import skew
+        def f(x):
+            x = np.asarray(x)
+            return skew(x[notnull(x)], bias=False)
 
-    def testGroupBy(self):
-        pass
+        self._check_statistic(self.frame, 'skew', f)
+
+    def test_cumsum(self):
+        cumsum = self.tsframe.cumsum()
+
+        assert_series_equal(cumsum['A'], np.cumsum(self.tsframe['A'].fill(0)))
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 3e386b4f8..560014b03 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -16,7 +16,43 @@ class TestDataMatrix(test_frame.TestDataFrame):
     klass = DataMatrix
 
     def test_more_constructor(self):
-        pass
+        arr = randn(10)
+        dm = self.klass(arr, columns=['A'], index=np.arange(10))
+        self.assertEqual(dm.values.ndim, 2)
+
+        arr = randn(0)
+        dm = self.klass(arr)
+        self.assertEqual(dm.values.ndim, 2)
+        self.assertEqual(dm.values.ndim, 2)
+
+        # no data specified
+        dm = self.klass(columns=['A', 'B'], index=np.arange(10))
+        self.assertEqual(dm.values.shape, (10, 2))
+
+        dm = self.klass(columns=['A', 'B'])
+        self.assertEqual(dm.values.shape, (0, 2))
+
+        dm = self.klass(index=np.arange(10))
+        self.assertEqual(dm.values.shape, (10, 0))
+
+        # corner, silly
+        self.assertRaises(Exception, self.klass, (1, 2, 3))
+
+    def test_setitem_corner(self):
+        # corner case
+        df = self.klass({'B' : [1., 2., 3.],
+                         'C' : ['a', 'b', 'c']},
+                        index=np.arange(3))
+        del df['B']
+        df['B'] = [1., 2., 3.]
+        self.assert_('B' in df)
+        self.assertEqual(len(df.columns), 1)
+
+        df['A'] = 'beginning'
+        df['E'] = 'foo'
+        df['D'] = 'bar'
+        df[datetime.now()] = 'date'
+        df[datetime.now()] = 5.
 
     def test_more_fromDict(self):
         pass

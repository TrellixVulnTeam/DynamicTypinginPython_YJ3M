commit fbf197738d0e2d90d69da9a9c636c5d53a5fc4f4
Author: jreback <jeff@reback.net>
Date:   Sat Mar 2 16:41:31 2013 -0500

    DOC: added 10min newbie intro to pandas
         changes in indexing suggested by Jan Schulz, and nehalecky
    
    DOC: added plotting,reshaping, more examples in setting to 10min.rst
    
    DOC: more doc updates, added more examples in selection
         added join to 10min
    
    DOC: release notes and whatsnew updates for 10min

diff --git a/RELEASE.rst b/RELEASE.rst
index e4e708777..3ed6d71ce 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -29,6 +29,7 @@ pandas 0.11.0
 
 **New features**
 
+  - New documentation section, ``10 Minutes to Pandas``
   - Allow mixed dtypes (e.g ``float32/float64/int32/int16/int8``) to coexist in
     DataFrames and propogate in operations
   - Add function to pandas.io.data for retrieving stock index components from
diff --git a/doc/source/10min.rst b/doc/source/10min.rst
new file mode 100644
index 000000000..d73ff600e
--- /dev/null
+++ b/doc/source/10min.rst
@@ -0,0 +1,540 @@
+.. _10min:
+
+.. currentmodule:: pandas
+
+.. ipython:: python
+   :suppress:
+
+   import numpy as np
+   import random
+   np.random.seed(123456)
+   from pandas import *
+   import pandas as pd
+   randn = np.random.randn
+   randint = np.random.randint
+   np.set_printoptions(precision=4, suppress=True)
+
+   #### portions of this were borrowed from the
+   #### Pandas cheatsheet  
+   #### created during the PyData Workshop-Sprint 2012 
+   #### Hannah Chen, Henry Chow, Eric Cox, Robert Mauriello 
+
+
+********************
+10 Minutes to Pandas
+********************
+
+This is a short introduction to pandas, geared mainly for new users.
+
+Customarily, we import as follows
+
+.. ipython:: python
+
+   import pandas as pd
+   import numpy as np
+
+Object Creation
+---------------
+
+See the :ref:`Data Structure Intro section <dsintro>`
+
+Creating a ``Series`` by passing a list of values, letting pandas create a default 
+integer index
+
+.. ipython:: python
+
+   s = pd.Series([1,3,5,np.nan,6,8])
+   s
+
+Creating a ``DataFrame`` by passing a numpy array, with a datetime index and labeled columns.
+
+.. ipython:: python
+
+   dates = pd.date_range('20130101',periods=6)
+   dates
+   df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))
+   df
+
+Creating a ``DataFrame`` by passing a dict of objects that can be converted to series-like.
+
+.. ipython:: python
+
+   df2 = pd.DataFrame({ 'A' : 1., 
+                        'B' : pd.Timestamp('20130102'), 
+                        'C' : pd.Series(1,index=range(4),dtype='float32'),
+                        'D' : np.array([3] * 4,dtype='int32'), 
+                        'E' : 'foo' })
+   df2
+
+Having specific dtypes
+
+.. ipython:: python
+
+   df2.dtypes
+
+Viewing Data
+------------
+
+See the :ref:`Basics section <basics>`
+
+See the top & bottom rows of the frame
+
+.. ipython:: python
+
+   df.head()
+   df.tail()
+
+Display the index,columns, and the underlying numpy data
+
+.. ipython:: python
+
+   df.index
+   df.columns
+   df.values
+
+Describe shows a quick statistic summary of your data
+
+.. ipython:: python
+
+   df.describe()
+
+Selection
+---------
+
+See the :ref:`Indexing section <indexing>`
+
+
+Getting
+~~~~~~~
+
+Selecting a single column, which yields a ``Series``
+
+.. ipython:: python
+
+   df['A']
+
+Selecting via ``[]``, which slices the rows.
+
+.. ipython:: python
+
+   df[0:3]
+   df['20130102':'20130104']
+
+Selection by Label
+~~~~~~~~~~~~~~~~~~
+
+For getting a cross section using a label
+
+.. ipython:: python
+
+   df.loc[dates[0]]
+
+Selecting on a multi-axis by label
+
+.. ipython:: python
+
+   df.loc[:,['A','B']]
+
+Showing label slicing, both endpoints are *included*
+
+.. ipython:: python
+
+   df.loc['20130102':'20130104',['A','B']]
+
+Reduction in the dimensions of the returned object
+
+.. ipython:: python
+
+   df.loc['20130102',['A','B']]
+
+For getting a scalar value
+
+.. ipython:: python
+
+   df.loc[dates[0],'A']
+
+For getting fast access to a scalar (equiv to the prior method)
+
+.. ipython:: python
+
+   df.at[dates[0],'A']
+
+Selection by Position
+~~~~~~~~~~~~~~~~~~~~~
+
+Select via the position of the passed integers
+
+.. ipython:: python
+
+   # this is a cross-section of the object
+   df.iloc[3]
+
+By integer slices, acting similar to numpy/python
+
+.. ipython:: python
+
+   df.iloc[3:5,0:2]
+
+By lists of integer position locations, similar to the numpy/python style
+
+.. ipython:: python
+
+   df.iloc[[1,2,4],[0,2]]
+
+For slicing rows explicitly
+
+.. ipython:: python
+
+   df.iloc[1:3,:]
+
+For slicing columns explicitly
+
+.. ipython:: python
+
+   df.iloc[:,1:3]
+
+For getting a value explicity
+
+.. ipython:: python
+
+   df.iloc[1,1]
+
+For getting fast access to a scalar (equiv to the prior method)
+
+.. ipython:: python
+
+   df.iat[1,1]
+
+There is one signficant departure from standard python/numpy slicing semantics.
+python/numpy allow slicing past the end of an array without an associated error.
+
+.. ipython:: python
+
+    # these are allowed in python/numpy.
+    x = list('abcdef')
+    x[4:10]
+    x[8:10]
+
+Pandas will detect this and raise ``IndexError``, rather than return an empty structure.
+
+::
+
+    >>> df.iloc[:,3:6]
+    IndexError: out-of-bounds on slice (end)
+
+Boolean Indexing
+~~~~~~~~~~~~~~~~
+
+Using a single column's values to select data.
+
+.. ipython:: python
+
+   df[df.A > 0]
+
+A ``where`` operation.
+
+.. ipython:: python
+
+   df[df > 0]
+
+
+Setting
+~~~~~~~
+
+Setting a new column automatically aligns the data
+by the indexes
+
+.. ipython:: python
+
+   s1 = pd.Series([1,2,3,4,5,6],index=date_range('20130102',periods=6))
+   s1
+   df['F'] = s1
+
+Setting values by label
+
+.. ipython:: python
+
+   df.at[dates[0],'A'] = 0
+
+Setting values by position
+
+.. ipython:: python
+
+   df.iat[0,1] = 0
+
+Setting by assigning with a numpy array
+
+.. ipython:: python
+
+   df.loc[:,'D'] = np.array([5] * len(df))
+   df
+
+Missing Data
+------------
+
+Pandas primarily uses the value ``np.nan`` to represent missing data. It
+is by default not included in computations. See the :ref:`Missing Data section <missing_data>`
+
+Reindexing allows you to change/add/delete the index on a specified axis. This
+returns a copy of the data.
+
+.. ipython:: python
+
+   df1 = df.reindex(index=dates[0:4],columns=list(df.columns) + ['E'])
+   df1.loc[dates[0]:dates[1],'E'] = 1
+   df1
+
+To drop any rows that have missing data.
+
+.. ipython:: python
+
+   df1.dropna(how='any')
+
+Filling missing data
+
+.. ipython:: python
+
+   df1.fillna(value=5)
+
+
+Operations
+----------
+
+See the :ref:`Basic section on Binary Ops <basics.binop>`
+
+Stats
+~~~~~
+
+Performing a descriptive statistic
+
+.. ipython:: python
+
+   df.mean()
+
+Same operation on the other axis
+
+.. ipython:: python
+
+   df.mean(1)
+
+Operations on missing data, exclude the data
+
+.. ipython:: python
+
+  df1.mean()
+
+Apply
+~~~~~
+
+Applying functions to the data
+
+.. ipython:: python
+
+   df.apply(np.cumsum)
+   df.apply(lambda x: x.max() - x.min())
+
+Merge
+-----
+
+Concat
+~~~~~~
+
+Pandas provides various facilities for easily combining together Series,
+DataFrame, and Panel objects with various kinds of set logic for the indexes
+and relational algebra functionality in the case of join / merge-type
+operations.
+
+See the :ref:`Merging section <merging>`
+
+Concatenating pandas objects together 
+
+.. ipython:: python
+
+   df = pd.DataFrame(np.random.randn(10, 4))
+   df
+
+   # break it into pieces
+   pieces = [df[:3], df[3:7], df[7:]]
+
+   concat(pieces)
+
+Join
+~~~~
+
+SQL style merges. See the :ref:`Database style joining <merging.join>`
+
+.. ipython:: python
+
+   left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
+   right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})
+   left
+   right
+   merge(left, right, on='key')
+
+Append
+~~~~~~
+
+Append rows to a dataframe. See the :ref:`Appending <merging.concatenation>`
+
+.. ipython:: python
+
+   df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])
+   df
+   s = df.iloc[3]
+   df.append(s, ignore_index=True)
+   df
+
+
+Grouping
+--------
+
+By "group by" we are referring to a process involving one or more of the following
+steps
+
+ - **Splitting** the data into groups based on some criteria
+ - **Applying** a function to each group independently
+ - **Combining** the results into a data structure
+
+See the :ref:`Grouping section <groupby>`
+
+.. ipython:: python
+
+   df = pd.DataFrame({'A' : ['foo', 'bar', 'foo', 'bar',
+                            'foo', 'bar', 'foo', 'foo'],
+                      'B' : ['one', 'one', 'two', 'three',
+                            'two', 'two', 'one', 'three'],
+                      'C' : randn(8), 'D' : randn(8)})
+   df
+
+Grouping and then applying a function ``sum`` to the resulting groups.
+
+.. ipython:: python
+
+   df.groupby('A').sum()
+
+Grouping by multiple columns forms a hierarchical index, which we then apply the function.
+
+.. ipython:: python
+
+   df.groupby(['A','B']).sum()
+
+Reshaping
+---------
+
+See the section on :ref:`Hierarchical Indexing <indexing.hierarchical>` and
+see the section on :ref:`Reshaping <reshaping.stacking>`).
+
+.. ipython:: python
+
+   tuples = zip(*[['bar', 'bar', 'baz', 'baz',
+                   'foo', 'foo', 'qux', 'qux'],
+                  ['one', 'two', 'one', 'two',
+                   'one', 'two', 'one', 'two']])
+   index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])
+   df = pd.DataFrame(randn(8, 2), index=index, columns=['A', 'B'])
+   df2 = df[:4]
+   df2
+
+The ``stack`` function "compresses" a level in the DataFrame's columns. to
+
+.. ipython:: python
+
+   stacked = df2.stack()
+   stacked
+
+With a "stacked" DataFrame or Series (having a ``MultiIndex`` as the
+``index``), the inverse operation of ``stack`` is ``unstack``, which by default
+unstacks the **last level**:
+
+.. ipython:: python
+
+   stacked.unstack()
+   stacked.unstack(1)
+   stacked.unstack(0)
+
+Time Series
+-----------
+
+Pandas has simple, powerful, and efficient functionality for
+performing resampling operations during frequency conversion (e.g., converting
+secondly data into 5-minutely data). This is extremely common in, but not
+limited to, financial applications. See the :ref:`Time Series section <timeseries>`
+
+.. ipython:: python
+
+   rng = pd.date_range('1/1/2012', periods=100, freq='S')
+   ts = pd.Series(randint(0, 500, len(rng)), index=rng)
+   ts.resample('5Min', how='sum')
+
+Plotting
+--------
+
+.. ipython:: python
+   :suppress:
+
+   import matplotlib.pyplot as plt
+   plt.close('all')
+
+.. ipython:: python
+
+   ts = pd.Series(randn(1000), index=pd.date_range('1/1/2000', periods=1000))
+   ts = ts.cumsum()
+
+   @savefig series_plot_basic.png width=4.5in
+   ts.plot()
+
+On DataFrame, ``plot`` is a convenience to plot all of the columns with labels:
+
+.. ipython:: python
+
+   df = pd.DataFrame(randn(1000, 4), index=ts.index,
+                     columns=['A', 'B', 'C', 'D'])
+   df = df.cumsum()
+
+   @savefig frame_plot_basic.png width=4.5in
+   plt.figure(); df.plot(); plt.legend(loc='best')
+
+Getting Data In/Out
+-------------------
+
+CSV
+~~~
+
+:ref:`Writing to a csv file <io.store_in_csv>`
+
+.. ipython:: python
+
+   df.to_csv('foo.csv')
+
+:ref:`Reading from a csv file <io.read_csv_table>`
+
+.. ipython:: python
+
+   pd.read_csv('foo.csv')
+
+HDF5
+~~~~
+
+Reading and writing to :ref:`HDFStores <io.hdf5>`
+
+Writing to a HDF5 Store
+
+.. ipython:: python
+
+   store = pd.HDFStore('foo.h5')
+   store['df'] = df
+
+Reading from a HDF5 Store
+
+.. ipython:: python
+
+   store['df']
+
+.. ipython:: python
+   :suppress:
+   :okexcept:
+
+   store.close()
+   os.remove('foo.h5')
+   os.remove('foo.csv')
+
diff --git a/doc/source/index.rst b/doc/source/index.rst
index bc51f1b13..d59cb6d7a 100644
--- a/doc/source/index.rst
+++ b/doc/source/index.rst
@@ -112,6 +112,7 @@ See the package overview for more detail about what's in the library.
     install
     faq
     overview
+    10min
     dsintro
     basics
     indexing
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 75fa4803f..02aa00b7e 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -14,9 +14,9 @@
    randint = np.random.randint
    np.set_printoptions(precision=4, suppress=True)
 
-***************************
-Indexing and selecting data
-***************************
+**************
+Selecting Data
+**************
 
 The axis labeling information in pandas objects serves many purposes:
 
@@ -44,14 +44,14 @@ three types of multi-axis indexing.
 
     - A single label, e.g. ``5`` or ``'a'``
 
-      (note that ``5`` when used as a *label* of an integer based index)
+      (note that ``5`` is interpreted as a *label* of the index. This use is **not** an integer position along the index)
     - A list or array of labels ``['a', 'b', 'c']``
     - A slice object with labels ``'a':'f'``
 
       (note that contrary to usual python slices, **both** the start and the stop are included!)
     - A boolean array
 
-    See more at :ref:`Label indexing <indexing.label>`
+    See more at :ref:`Selection by Label <indexing.label>`
 
   - ``.iloc`` is strictly integer position based (from 0 to length-1 of the axis), will 
     raise ``IndexError`` when the requested indicies are out of bounds. Allowed inputs are:
@@ -61,16 +61,19 @@ three types of multi-axis indexing.
     - A slice object with ints ``1:7``
     - A boolean array
 
-    See more at :ref:`Integer indexing <indexing.integer>` 
+    See more at :ref:`Selection by Position <indexing.integer>` 
 
   - ``.ix`` supports mixed integer and label based access. It is primarily label based, but
     will fallback to integer positional access. ``.ix`` is the most general and will support 
-    any of the inputsx to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+    any of the inputs to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+
     As using integer slices with ``.ix`` have different behavior depending on whether the slice 
     is interpreted as integer location based or label position based, it's usually better to be 
     explicit and use ``.iloc`` (integer location) or ``.loc`` (label location).
 
-    See more at :ref:`Advanced indexing <indexing.advanced>`
+    ``.ix`` is especially useful when dealing with mixed positional and label based hierarchial indexes. 
+
+    See more at :ref:`Advanced Indexing <indexing.advanced>` and :ref:`Advanced Hierarchical <indexing.advanced_hierarchical>`
 
 Getting values from object with multi-axes uses the following notation (using ``.loc`` as an 
 example, but applies to ``.iloc`` and ``.ix`` as well) Any of the axes accessors may be the null 
@@ -86,23 +89,28 @@ slice ``:``. Axes left out of the specification are assumed to be ``:``.
     DataFrame; ``df.loc[row_indexer,column_indexer]``
     Panel; ``p.loc[item_indexer,major_indexer,minor_indexer]``
 
-Indexing Deprecations
-~~~~~~~~~~~~~~~~~~~~~
+Deprecations
+~~~~~~~~~~~~
 
-Starting in version 0.11.0, the methods may be deprecated in future versions.
+Starting in version 0.11.0, these methods may be deprecated in future versions.
 
   - ``irow``
   - ``icol``
   - ``iget_value``
 
-See the section :ref:`Integer indexing <indexing.integer>` for substitutes.
+See the section :ref:`Selection by Position <indexing.integer>` for substitutes.
 
 .. _indexing.xs:
 
-Cross-sectional slices on non-hierarchical indices are now easily
-performed using ``.loc`` and/or ``.loc``. The methods ``xs`` (for DataFrame),
-``minor_xs`` and ``major_xs`` (for Panel), exist primarily for backward
-compatibility.
+Cross-sectional slices on non-hierarchical indices are now easily performed using
+``.loc`` and/or ``.loc``. The methods:
+
+  - ``xs`` (for DataFrame),
+  - ``minor_xs`` and ``major_xs`` (for Panel)
+
+now exist primarily for backward compatibility.
+
+See the section at :ref:`Selection by Label <indexing.label>` for substitutes.
 
 .. _indexing.basics:
 
@@ -114,11 +122,14 @@ As mentioned when introducing the data structures in the :ref:`last section
 for those familiar with implementing class behavior in Python) is selecting out
 lower-dimensional slices. Thus,
 
-  - **Series**: ``series[label]`` returns a scalar value
-  - **DataFrame**: ``frame[colname]`` returns a Series corresponding to the
-    passed column name
-  - **Panel**: ``panel[itemname]`` returns a DataFrame corresponding to the
-    passed item name
+.. csv-table::
+    :header: "Object Type", "Selection", "Return Value Type"
+    :widths: 30, 30, 60
+    :delim: ;
+
+    Series; ``series[label]``; scalar value
+    DataFrame; ``frame[colname]``; ``Series`` corresponding to colname
+    Panel; ``panel[itemname]``; ``DataFrame`` corresponing to the itemname
 
 Here we construct a simple time series data set to use for illustrating the
 indexing functionality:
@@ -144,21 +155,22 @@ Thus, as per above, we have the most basic indexing using ``[]``:
    s[dates[5]]
    panel['two']
 
-Additional Column Access
-~~~~~~~~~~~~~~~~~~~~~~~~
+Attribute Access
+~~~~~~~~~~~~~~~~
 
 .. _indexing.columns.multiple:
 
 .. _indexing.df_cols:
 
-You may access a column on a dataframe directly as an attribute:
+You may access a column on a ``DataFrame``, and a item on a ``Panel`` directly as an attribute:
 
 .. ipython:: python
 
    df.A
+   panel.one
 
 If you are using the IPython environment, you may also use tab-completion to
-see the accessible columns of a DataFrame.
+see these accessable attributes.
 
 You can pass a list of columns to ``[]`` to select columns in that order:
 If a column is not contained in the DataFrame, an exception will be
@@ -177,7 +189,7 @@ Slicing ranges
 ~~~~~~~~~~~~~~
 
 The most robust and consistent way of slicing ranges along arbitrary axes is
-described in the :ref:`Integer indexing <indexing.integer>` section detailing
+described in the :ref:`Selection by Position <indexing.integer>` section detailing
 the ``.iloc`` method. For now, we explain the semantics of slicing using the
 ``[]`` operator.
 
@@ -208,8 +220,8 @@ largely as a convenience since it is such a common operation.
 
 .. _indexing.label:
 
-Label Based Indexing
-~~~~~~~~~~~~~~~~~~~~
+Selection By Label
+~~~~~~~~~~~~~~~~~~
 
 Pandas provides a suite of methods in order to have **purely label based indexing**. 
 This is a strict inclusion based protocol. **ALL** of the labels for which you ask,
@@ -224,7 +236,7 @@ The following are valid inputs:
 
     - A single label, e.g. ``5`` or ``'a'``
 
-      (note that ``5`` when used as a *label* of an integer based index)
+      (note that ``5`` is interpreted as a *label* of the index. This use is **not** an integer position along the index)
     - A list or array of labels ``['a', 'b', 'c']``
     - A slice object with labels ``'a':'f'``
 
@@ -253,7 +265,10 @@ With a DataFrame
    df1
    df1.loc[['a','b','d'],:]
 
-   # slices
+Accessing via label slices
+
+.. ipython:: python
+
    df1.loc['d':,'A':'C']
 
 For getting a cross section using a label (equiv to deprecated ``df.xs('a')``)
@@ -262,7 +277,10 @@ For getting a cross section using a label (equiv to deprecated ``df.xs('a')``)
 
    df1.loc['a']
 
-   # boolean
+For getting values with a boolean array
+
+.. ipython:: python
+
    df1.loc['a']>0
    df1.loc[:,df1.loc['a']>0]
 
@@ -275,8 +293,8 @@ For getting a value explicity (equiv to deprecated ``df.get_value('a','A')``)
 
 .. _indexing.integer:
 
-Integer Based Indexing
-~~~~~~~~~~~~~~~~~~~~~~
+Selection By Position
+~~~~~~~~~~~~~~~~~~~~~
 
 Pandas provides a suite of methods in order to get **purely integer based indexing**. 
 The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
@@ -314,17 +332,23 @@ With a DataFrame
    df1 = DataFrame(np.random.randn(6,4),index=range(0,12,2),columns=range(0,8,2))
    df1
 
-   # integer access
-   df1.iloc[5,2]
+Select via integer slicing
+
+.. ipython:: python
 
-   # slices
    df1.iloc[:3]
    df1.iloc[1:5,2:4]
 
-   # integer lists
+Select via integer list
+
+.. ipython:: python
+
    df1.iloc[[1,3,5],[1,3]]
 
-   # boolean
+Select via boolean array
+
+.. ipython:: python
+
    df1.iloc[:,df1.iloc[0]>0]
 
 For slicing rows explicitly (equiv to deprecated ``df.irow(slice(1,3))``).
@@ -339,7 +363,7 @@ For slicing columns explicitly (equiv to deprecated ``df.icol(slice(1,3))``).
 
    df1.iloc[:,1:3]
 
-For getting a value explicity (equiv to deprecated ``df.get_value(1,1)``)
+For getting a scalar via integer position (equiv to deprecated ``df.get_value(1,1)``)
 
 .. ipython:: python
 
@@ -449,8 +473,8 @@ more complex criteria:
    df2[criterion & (df2['b'] == 'x')]
 
 
-Note, with the choice methods :ref:`Label indexing <indexing.label>`, :ref:`Integer indexing <indexing.integer>`,
-and :ref:`Advanced indexing <indexing.advanced>` may select along more than one axis using boolean vectors combined with other
+Note, with the choice methods :ref:`Selection by Label <indexing.label>`, :ref:`Selection by Position <indexing.integer>`,
+and :ref:`Advanced Indexing <indexing.advanced>` may select along more than one axis using boolean vectors combined with other
 indexing expressions.
 
 Where and Masking
@@ -645,8 +669,8 @@ Advanced Indexing with ``.ix``
    to use any passed *integer* as *label* locations first (like what ``.loc``
    would do, then to fall back on *positional* indexing, like what ``.iloc`` would do).
 
-The syntax of using ``.ix`` is identical to ``.loc``, in :ref:`Label indexing <indexing.label>`,
-and ``.iloc`` in :ref:`Integer indexing <indexing.integer>`.
+The syntax of using ``.ix`` is identical to ``.loc``, in :ref:`Selection by Label <indexing.label>`,
+and ``.iloc`` in :ref:`Selection by Position <indexing.integer>`.
 
 The ``.ix`` attribute takes the following inputs:
 
@@ -980,6 +1004,8 @@ of tuples:
    s.reindex(index[:3])
    s.reindex([('foo', 'two'), ('bar', 'one'), ('qux', 'one'), ('baz', 'one')])
 
+.. _indexing.advanced_hierarchical:
+
 Advanced indexing with hierarchical index
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 86d590965..e2b66d3d5 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -970,7 +970,7 @@ one can use the ExcelWriter class, as in the following example:
    df2.to_excel(writer, sheet_name='sheet2')
    writer.save()
 
-.. _io-hdf5:
+.. _io.hdf5:
 
 HDF5 (PyTables)
 ---------------
@@ -1058,6 +1058,7 @@ These stores are **not** appendable once written (though you can simply
 remove them and rewrite). Nor are they **queryable**; they must be
 retrieved in their entirety.
 
+.. _io.hdf5-table:
 
 Storing in Table format
 ~~~~~~~~~~~~~~~~~~~~~~~
@@ -1091,6 +1092,8 @@ supported.
    # the type of stored data
    store.root.df._v_attrs.pandas_type
 
+.. _io.hdf5-keys:
+
 Hierarchical Keys
 ~~~~~~~~~~~~~~~~~
 
@@ -1115,6 +1118,8 @@ everying in the sub-store and BELOW, so be *careful*.
    store.remove('food')
    store
 
+.. _io.hdf5-types:
+
 Storing Mixed Types in a Table
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -1170,6 +1175,8 @@ storing/selecting from homogeneous index DataFrames.
         store.select('df_mi', Term('foo=bar'))
 
 
+.. _io.hdf5-query:
+
 Querying a Table
 ~~~~~~~~~~~~~~~~
 
@@ -1372,6 +1379,7 @@ table (optional) to let it have the remaining columns. The argument
    store.select_as_multiple(['df1_mt', 'df2_mt'], where=['A>0', 'B>0'],
                              selector = 'df1_mt')
 
+.. _io.hdf5-delete:
 
 Delete from a Table
 ~~~~~~~~~~~~~~~~~~~
diff --git a/doc/source/v0.10.0.txt b/doc/source/v0.10.0.txt
index c220d2cbb..0c5497868 100644
--- a/doc/source/v0.10.0.txt
+++ b/doc/source/v0.10.0.txt
@@ -217,7 +217,7 @@ The width of each line can be changed via 'line_width' (80 by default):
 Updated PyTables Support
 ~~~~~~~~~~~~~~~~~~~~~~~~
 
-:ref:`Docs <io-hdf5>` for PyTables ``Table`` format & several enhancements to the api. Here is a taste of what to expect.
+:ref:`Docs <io.hdf5>` for PyTables ``Table`` format & several enhancements to the api. Here is a taste of what to expect.
 
 .. ipython:: python
    :suppress:
diff --git a/doc/source/v0.11.0.txt b/doc/source/v0.11.0.txt
index 8ea49d107..f4c9d13c0 100644
--- a/doc/source/v0.11.0.txt
+++ b/doc/source/v0.11.0.txt
@@ -4,15 +4,19 @@ v0.11.0 (March ??, 2013)
 ------------------------
 
 This is a major release from 0.10.1 and includes many new features and
-enhancements along with a large number of bug fixes. There are also a number of
-important API changes that long-time pandas users should pay close attention
-to.
+enhancements along with a large number of bug fixes. The methods of Selecting
+Data have had quite a number of additions, and Dtype support is now full-fledged.
+There are also a number of important API changes that long-time pandas users should 
+pay close attention to.
+
+There is a new section in the documentation, :ref:`10 Minutes to Pandas <10min>`,
+primarily geared to new users.
 
 API changes
 ~~~~~~~~~~~
 
-Indexing Choice
-~~~~~~~~~~~~~~~
+Selection Choices
+~~~~~~~~~~~~~~~~~
 
 Starting in 0.11.0, object selection has had a number of user-requested additions in
 order to support more explicit location based indexing. Pandas now supports
@@ -23,14 +27,14 @@ three types of multi-axis indexing.
 
     - A single label, e.g. ``5`` or ``'a'``
 
-      (note that ``5`` when used as a *label* of an integer based index)
+      (note that ``5`` is interpreted as a *label* of the index. This use is **not** an integer position along the index)
     - A list or array of labels ``['a', 'b', 'c']``
     - A slice object with labels ``'a':'f'``
 
       (note that contrary to usual python slices, **both** the start and the stop are included!)
     - A boolean array
 
-    See more at :ref:`Label indexing <indexing.label>`
+    See more at :ref:`Selection by Label <indexing.label>`
 
   - ``.iloc`` is strictly integer position based (from 0 to length-1 of the axis), will 
     raise ``IndexError`` when the requested indicies are out of bounds. Allowed inputs are:
@@ -40,20 +44,23 @@ three types of multi-axis indexing.
     - A slice object with ints ``1:7``
     - A boolean array
 
-    See more at :ref:`Integer indexing <indexing.integer>` 
+    See more at :ref:`Selection by Position <indexing.integer>` 
 
   - ``.ix`` supports mixed integer and label based access. It is primarily label based, but
     will fallback to integer positional access. ``.ix`` is the most general and will support 
-    any of the inputsx to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+    any of the inputs to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+
     As using integer slices with ``.ix`` have different behavior depending on whether the slice 
     is interpreted as integer location based or label position based, it's usually better to be 
     explicit and use ``.iloc`` (integer location) or ``.loc`` (label location).
 
-    See more at :ref:`Advanced indexing <indexing.advanced>`
+    ``.ix`` is especially usefull when dealing with mixed positional/label based hierarchial indexes. 
+
+    See more at :ref:`Advanced Indexing <indexing.advanced>` and :ref:`Advanced Hierarchical <indexing.advanced_hierarchical>`
 
 
-Indexing Deprecations
-~~~~~~~~~~~~~~~~~~~~~
+Selection Deprecations
+~~~~~~~~~~~~~~~~~~~~~~
 
 Starting in version 0.11.0, the methods may be deprecated in future versions.
 
@@ -61,13 +68,17 @@ Starting in version 0.11.0, the methods may be deprecated in future versions.
   - ``icol``
   - ``iget_value``
 
-See the section :ref:`Integer indexing <indexing.integer>` for substitutes.
+See the section :ref:`Selection by Position <indexing.integer>` for substitutes.
+
+Cross-sectional slices on non-hierarchical indices are now easily performed using
+``.loc`` and/or ``.loc``. The methods:
+
+  - ``xs`` (for DataFrame),
+  - ``minor_xs`` and ``major_xs`` (for Panel)
 
-Cross-sectional slices on non-hierarchical indices are now easily
-performed using ``.loc`` and/or ``.loc``. The methods ``xs`` (for DataFrame),
-``minor_xs`` and ``major_xs`` (for Panel), exist primarily for backward
-compatibility
+now exist primarily for backward compatibility.
 
+See the section :ref:`Selection by Label <indexing.label>` for substitutes.
 
 Dtypes
 ~~~~~~
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 0b4474f7a..b1da18709 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -643,7 +643,7 @@ class _LocationIndexer(_NDFrameIndexer):
 
 class _LocIndexer(_LocationIndexer):
     """ purely label based location based indexing """
-    _valid_types = "labels (MUST BE INCLUSIVE), slices of labels (BOTH endpoints included! Can be slices of integers if the index is integers), listlike of labels, boolean"
+    _valid_types = "labels (MUST BE IN THE INDEX), slices of labels (BOTH endpoints included! Can be slices of integers if the index is integers), listlike of labels, boolean"
     _exception   = KeyError
 
     def _has_valid_type(self, key, axis):

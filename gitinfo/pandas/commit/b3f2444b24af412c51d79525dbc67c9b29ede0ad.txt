commit b3f2444b24af412c51d79525dbc67c9b29ede0ad
Author: jreback <jeff@reback.net>
Date:   Tue Aug 27 10:54:31 2013 -0400

    API: provide automatic dtype conversions on _reduce operations
    API: exclude non-numerics if mixed types in _reduce operations
    
    BUG: timedelta fixes
    
    CLN: small cleaning in nanops.py
    
    BUG: allow _reduce to call .apply for certain operations when the who block fails
         via a reduce exception

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 5becc26a5..c24ff6ab0 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -157,6 +157,8 @@ pandas 0.13
   - Remove undocumented/unused ``kind`` keyword argument from ``read_excel``, and ``ExcelFile``. (:issue:`4713`, :issue:`4712`)
   - The ``method`` argument of ``NDFrame.replace()`` is valid again, so that a
     a list can be passed to ``to_replace`` (:issue:`4743`).
+  - provide automatic dtype conversions on _reduce operations (:issue:`3371`)
+  - exclude non-numerics if mixed types with datelike in _reduce operations (:issue:`3371`)
 
 **Internal Refactoring**
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 8b9ba4d5e..54197e86c 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -705,6 +705,54 @@ def diff(arr, n, axis=0):
     return out_arr
 
 
+def _coerce_scalar_to_timedelta_type(r):
+    # kludgy here until we have a timedelta scalar
+    # handle the numpy < 1.7 case
+
+    if is_integer(r):
+        r = timedelta(microseconds=r/1000)
+
+    if _np_version_under1p7:
+        if not isinstance(r, timedelta):
+            raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
+        if compat.PY3:
+            # convert to microseconds in timedelta64
+            r = np.timedelta64(int(r.total_seconds()*1e9 + r.microseconds*1000))
+        else:
+            return r
+
+    if isinstance(r, timedelta):
+        r = np.timedelta64(r)
+    elif not isinstance(r, np.timedelta64):
+        raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
+    return r.astype('timedelta64[ns]')
+
+def _coerce_to_dtypes(result, dtypes):
+    """ given a dtypes and a result set, coerce the result elements to the dtypes """
+    if len(result) != len(dtypes):
+        raise AssertionError("_coerce_to_dtypes requires equal len arrays")
+
+    def conv(r,dtype):
+        try:
+            if isnull(r):
+                pass
+            elif dtype == _NS_DTYPE:
+                r = Timestamp(r)
+            elif dtype == _TD_DTYPE:
+                r = _coerce_scalar_to_timedelta_type(r)
+            elif dtype == np.bool_:
+                r = bool(r)
+            elif dtype.kind == 'f':
+                r = float(r)
+            elif dtype.kind == 'i':
+                r = int(r)
+        except:
+            pass
+
+        return r
+
+    return np.array([ conv(r,dtype) for r, dtype in zip(result,dtypes) ])
+
 def _infer_dtype_from_scalar(val):
     """ interpret the dtype from a scalar, upcast floats and ints
         return the new value and the dtype """
@@ -1288,7 +1336,7 @@ def _possibly_cast_to_timedelta(value, coerce=True):
     # coercion compatability
     if coerce == 'compat' and _np_version_under1p7:
 
-        def convert(td, type):
+        def convert(td, dtype):
 
             # we have an array with a non-object dtype
             if hasattr(td,'item'):
@@ -1317,6 +1365,7 @@ def _possibly_cast_to_timedelta(value, coerce=True):
         # < 1.7 coercion
         if not is_list_like(value):
             value = np.array([ value ])
+
         dtype = value.dtype
         return np.array([ convert(v,dtype) for v in value ], dtype='m8[ns]')
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a3eb3ea54..52d3a15d8 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -23,7 +23,8 @@ import numpy.ma as ma
 
 from pandas.core.common import (isnull, notnull, PandasError, _try_sort,
                                 _default_index, _maybe_upcast, _is_sequence,
-                                _infer_dtype_from_scalar, _values_from_object)
+                                _infer_dtype_from_scalar, _values_from_object,
+                                _coerce_to_dtypes, _DATELIKE_DTYPES)
 from pandas.core.generic import NDFrame
 from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas.core.indexing import (_NDFrameIndexer, _maybe_droplevels,
@@ -4235,11 +4236,24 @@ class DataFrame(NDFrame):
         axis = self._get_axis_number(axis)
         f = lambda x: op(x, axis=axis, skipna=skipna, **kwds)
         labels = self._get_agg_axis(axis)
+
+        # exclude timedelta/datetime unless we are uniform types
+        if axis == 1 and self._is_mixed_type and len(set(self.dtypes) & _DATELIKE_DTYPES):
+            numeric_only = True
+
         if numeric_only is None:
             try:
                 values = self.values
                 result = f(values)
             except Exception as e:
+
+                # try by-column first
+                if filter_type is None and axis == 0:
+                    try:
+                        return self.apply(f).iloc[0]
+                    except:
+                        pass
+
                 if filter_type is None or filter_type == 'numeric':
                     data = self._get_numeric_data()
                 elif filter_type == 'bool':
@@ -4273,9 +4287,11 @@ class DataFrame(NDFrame):
                     result = result.astype(np.float64)
                 elif filter_type == 'bool' and notnull(result).all():
                     result = result.astype(np.bool_)
-                # otherwise, accept it
             except (ValueError, TypeError):
-                pass
+
+                # try to coerce to the original dtypes item by item if we can
+                if axis == 0:
+                    result = com._coerce_to_dtypes(result, self.dtypes)
 
         return Series(result, index=labels)
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 3bdfd9812..58e1fbc4f 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -20,12 +20,9 @@ from pandas.core.common import (isnull, notnull, is_list_like,
                                 _infer_dtype_from_scalar, _maybe_promote,
                                 ABCSeries)
 
-
-
 def is_dictlike(x):
     return isinstance(x, (dict, com.ABCSeries))
 
-
 def _single_replace(self, to_replace, method, inplace, limit):
     orig_dtype = self.dtype
     result = self if inplace else self.copy()
@@ -1906,7 +1903,21 @@ class NDFrame(PandasObject):
         abs: type of caller
         """
         obj = np.abs(self)
-        obj = com._possibly_cast_to_timedelta(obj, coerce=False)
+
+        # suprimo numpy 1.6 hacking
+        if com._np_version_under1p7:
+            if self.ndim == 1:
+                if obj.dtype == 'm8[us]':
+                    obj = obj.astype('m8[ns]')
+            elif self.ndim == 2:
+                def f(x):
+                    if x.dtype == 'm8[us]':
+                        x = x.astype('m8[ns]')
+                    return x
+
+                if 'm8[us]' in obj.dtypes.values:
+                    obj = obj.apply(f)
+
         return obj
 
     def groupby(self, by=None, axis=0, level=None, as_index=True, sort=True,
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 683867233..171698081 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -1021,6 +1021,7 @@ class IntBlock(NumericBlock):
 class TimeDeltaBlock(IntBlock):
     is_timedelta = True
     _can_hold_na = True
+    is_numeric = False
 
     def _try_fill(self, value):
         """ if we are a NaT, return the actual fill value """
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 3e247caae..3a185ca83 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -287,8 +287,7 @@ def nanmin(values, axis=None, skipna=True):
     values, mask, dtype = _get_values(values, skipna, fill_value_typ = '+inf')
 
     # numpy 1.6.1 workaround in Python 3.x
-    if (values.dtype == np.object_
-            and sys.version_info[0] >= 3):  # pragma: no cover
+    if (values.dtype == np.object_ and compat.PY3):
         if values.ndim > 1:
             apply_ax = axis if axis is not None else 0
             result = np.apply_along_axis(builtins.min, apply_ax, values)
@@ -311,8 +310,7 @@ def nanmax(values, axis=None, skipna=True):
     values, mask, dtype = _get_values(values, skipna, fill_value_typ ='-inf')
 
     # numpy 1.6.1 workaround in Python 3.x
-    if (values.dtype == np.object_
-            and sys.version_info[0] >= 3):  # pragma: no cover
+    if (values.dtype == np.object_ and compat.PY3):
 
         if values.ndim > 1:
             apply_ax = axis if axis is not None else 0
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 39334e95e..e0bbc1a4e 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -480,6 +480,9 @@ def maybe_convert_objects(ndarray[object] objects, bint try_float=0,
                 seen_object = 1
                 # objects[i] = val.astype('O')
                 break
+        elif util.is_timedelta64_object(val):
+            seen_object = 1
+            break
         elif util.is_integer_object(val):
             seen_int = 1
             floats[i] = <float64_t> val
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index bb76547da..cefe15952 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3232,25 +3232,43 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         result = diffs.max(axis=1)
         self.assert_((result == diffs['A']).all() == True)
 
-        # abs ###### THIS IS BROKEN NOW ###### (results are dtype=timedelta64[us]
-        # even though fixed in series
-        #result = np.abs(df['A']-df['B'])
-        #result = diffs.abs()
-        #expected = DataFrame(dict(A = df['A']-df['C'],
-        #                          B = df['B']-df['A']))
-        #assert_frame_equal(result,expected)
+        # abs
+        result = diffs.abs()
+        expected = DataFrame(dict(A = df['A']-df['C'],
+                                  B = df['B']-df['A']))
+        assert_frame_equal(result,expected)
 
         # mixed frame
         mixed = diffs.copy()
         mixed['C'] = 'foo'
         mixed['D'] = 1
         mixed['E'] = 1.
+        mixed['F'] = Timestamp('20130101')
 
-        # this is ok
+        # results in an object array
         result = mixed.min()
+        expected = Series([com._coerce_scalar_to_timedelta_type(timedelta(seconds=5*60+5)),
+                           com._coerce_scalar_to_timedelta_type(timedelta(days=-1)),
+                           'foo',
+                           1,
+                           1.0,
+                           Timestamp('20130101')],
+                          index=mixed.columns)
+        assert_series_equal(result,expected)
 
-        # this is not
+        # excludes numeric
         result = mixed.min(axis=1)
+        expected = Series([1, 1, 1.],index=[0, 1, 2])
+        assert_series_equal(result,expected)
+
+        # works when only those columns are selected
+        result = mixed[['A','B']].min(1)
+        expected = Series([ timedelta(days=-1) ] * 3)
+        assert_series_equal(result,expected)
+
+        result = mixed[['A','B']].min()
+        expected = Series([ timedelta(seconds=5*60+5), timedelta(days=-1) ],index=['A','B'])
+        assert_series_equal(result,expected)
 
         # GH 3106
         df = DataFrame({'time' : date_range('20130102',periods=5),
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index a4bfcc1a4..b0911ed10 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -4277,16 +4277,14 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
 
     def test_reindex_pad(self):
 
-        s = Series(np.arange(10), np.arange(10))
+        s = Series(np.arange(10))
         s2 = s[::2]
 
         reindexed = s2.reindex(s.index, method='pad')
         reindexed2 = s2.reindex(s.index, method='ffill')
         assert_series_equal(reindexed, reindexed2)
 
-        # used platform int above, need to pass int explicitly here per #1219
-        expected = Series([0, 0, 2, 2, 4, 4, 6, 6, 8, 8], dtype=int,
-                          index=np.arange(10))
+        expected = Series([0, 0, 2, 2, 4, 4, 6, 6, 8, 8], index=np.arange(10))
         assert_series_equal(reindexed, expected)
 
         # GH4604
@@ -4696,7 +4694,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(s, ser)
 
     def test_replace_mixed_types(self):
-        s = Series(np.arange(5))
+        s = Series(np.arange(5),dtype='int64')
 
         def check_replace(to_rep, val, expected):
             sc = s.copy()

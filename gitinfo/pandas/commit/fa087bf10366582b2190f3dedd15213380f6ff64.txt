commit fa087bf10366582b2190f3dedd15213380f6ff64
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun May 27 12:31:26 2012 -0400

    ENH: NaT type and integration throughout, NA handling. #1286

diff --git a/pandas/__init__.py b/pandas/__init__.py
index 7ef0ba10c..98393e93d 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -25,6 +25,7 @@ from pandas.core.api import *
 from pandas.sparse.api import *
 from pandas.stats.api import *
 from pandas.tseries.api import *
+from pandas._tseries import NaT
 
 from pandas.core.format import (set_printoptions, reset_printoptions,
                                 set_eng_float_format)
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 5417ddde4..515bc21ac 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -52,7 +52,7 @@ def isnull(obj):
     -------
     boolean ndarray or boolean
     '''
-    if np.isscalar(obj) or obj is None:
+    if lib.isscalar(obj):
         return lib.checknull(obj)
 
     from pandas.core.generic import PandasObject
@@ -69,7 +69,7 @@ def isnull(obj):
                 result = Series(result, index=obj.index, copy=False)
         elif obj.dtype == np.dtype('M8[ns]'):
             # this is the NaT pattern
-            result = np.array(obj).view('i8') == lib.NaT
+            result = np.array(obj).view('i8') == lib.iNaT
         else:
             result = -np.isfinite(obj)
         return result
@@ -157,7 +157,7 @@ _take1d_dict = {
     'object' : _algos.take_1d_object,
     'bool' : _view_wrapper(_algos.take_1d_bool, np.uint8),
     'datetime64[ns]' : _view_wrapper(_algos.take_1d_int64, np.int64,
-                                     na_override=lib.NaT),
+                                     na_override=lib.iNaT),
 }
 
 _take2d_axis0_dict = {
@@ -167,7 +167,7 @@ _take2d_axis0_dict = {
     'object' : _algos.take_2d_axis0_object,
     'bool' : _view_wrapper(_algos.take_2d_axis0_bool, np.uint8),
     'datetime64[ns]' : _view_wrapper(_algos.take_2d_axis0_int64, np.int64,
-                                     na_override=lib.NaT),
+                                     na_override=lib.iNaT),
 }
 
 _take2d_axis1_dict = {
@@ -177,7 +177,7 @@ _take2d_axis1_dict = {
     'object' : _algos.take_2d_axis1_object,
     'bool' : _view_wrapper(_algos.take_2d_axis1_bool, np.uint8),
     'datetime64[ns]' : _view_wrapper(_algos.take_2d_axis1_int64, np.int64,
-                                     na_override=lib.NaT),
+                                     na_override=lib.iNaT),
 }
 
 _take2d_multi_dict = {
@@ -187,7 +187,7 @@ _take2d_multi_dict = {
     'object' : _algos.take_2d_multi_object,
     'bool' : _view_wrapper(_algos.take_2d_multi_bool, np.uint8),
     'datetime64[ns]' : _view_wrapper(_algos.take_2d_multi_int64, np.int64,
-                                     na_override=lib.NaT),
+                                     na_override=lib.iNaT),
 }
 
 def _get_take2d_function(dtype_str, axis=0):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 98e8cb385..a8906f7c1 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -371,7 +371,7 @@ class DataFrame(NDFrame):
             mask = ma.getmaskarray(data)
             datacopy = ma.copy(data)
             if issubclass(data.dtype.type, np.datetime64):
-                datacopy[mask] = lib.NaT
+                datacopy[mask] = lib.iNaT
             else:
                 datacopy = com._maybe_upcast(datacopy)
                 datacopy[mask] = np.nan
@@ -808,7 +808,7 @@ class DataFrame(NDFrame):
             if orient == "columns":
                 df = DataFrame(loads(json), dtype=dtype)
             elif orient == "split":
-                decoded = dict((str(k), v) 
+                decoded = dict((str(k), v)
                                for k, v in loads(json).iteritems())
                 df = DataFrame(dtype=dtype, **decoded)
             elif orient == "index":
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 64752e34a..3da598e15 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -118,6 +118,10 @@ def _comp_method(op, name):
         else:
             values = self.values
             other = lib.convert_scalar(values, other)
+
+            if issubclass(values.dtype.type, np.datetime64):
+                values = values.view('i8')
+
             # scalars
             res = na_op(values, other)
             if np.isscalar(res):
@@ -569,11 +573,8 @@ copy : boolean, default False
         self._set_values(indexer, value)
 
     def _set_values(self, key, value):
-        if issubclass(self.dtype.type, (np.integer, np.bool_)):
-            if np.isscalar(value) and isnull(value):
-                raise ValueError('Cannot assign nan to integer series')
-
-        self.values[key] = value
+        values = self.values
+        values[key] = lib.convert_scalar(values, value)
 
     # help out SparseSeries
     _get_val_at = ndarray.__getitem__
@@ -604,11 +605,12 @@ copy : boolean, default False
 
     def __setslice__(self, i, j, value):
         """Set slice equal to given value(s)"""
-        if issubclass(self.dtype.type, (np.integer, np.bool_)):
-            if np.isscalar(value) and isnull(value):
-                raise ValueError('Cannot assign nan to integer series')
-
-        ndarray.__setslice__(self, i, j, value)
+        if i < 0:
+            i = 0
+        if j < 0:
+            j = 0
+        slobj = slice(i, j)
+        return self.__setitem__(slobj, value)
 
     def astype(self, dtype):
         """
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 835b8a067..1658383ef 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -37,6 +37,9 @@ cdef extern from "datetime.h":
     object PyDateTime_FromDateAndTime(int year, int month, int day, int hour,
                                       int minute, int second, int us)
 
+cdef extern from "datetime_helper.h":
+    void mangle_nat(object o)
+
 cdef extern from "numpy/ndarrayobject.h":
 
     ctypedef int64_t npy_timedelta
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 18f28c9f5..0f25e44a1 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -79,10 +79,13 @@ class Timestamp(_Timestamp):
 
         ts = convert_to_tsobject(ts_input, tz)
 
+        if ts.value == NPY_NAT:
+            return NaT
+
         # make datetime happy
-        ts_base = _Timestamp.__new__(
-            cls, ts.dts.year, ts.dts.month, ts.dts.day,
-            ts.dts.hour, ts.dts.min, ts.dts.sec, ts.dts.us, ts.tzinfo)
+        ts_base = _Timestamp.__new__(cls, ts.dts.year, ts.dts.month,
+                                     ts.dts.day, ts.dts.hour, ts.dts.min,
+                                     ts.dts.sec, ts.dts.us, ts.tzinfo)
 
         # fill out rest of data
         ts_base.value = ts.value
@@ -160,6 +163,24 @@ class Timestamp(_Timestamp):
         return Timestamp(datetime.replace(self, **kwds),
                          offset=self.offset)
 
+class NaTType(_NaT):
+
+    def __new__(cls):
+        cdef _NaT base
+
+        base = _NaT.__new__(cls, 1, 1, 1)
+        mangle_nat(base)
+        base.value = NPY_NAT
+
+        return base
+
+    def __repr__(self):
+        return 'NaT'
+
+NaT = NaTType()
+
+iNaT = util.get_nat()
+
 
 cdef inline bint is_timestamp(object o):
     return isinstance(o, Timestamp)
@@ -214,6 +235,7 @@ def apply_offset(ndarray[object] values, object offset):
     new_values = result.view('i8')
     pass
 
+
 # This is PITA. Because we inherit from datetime, which has very specific
 # construction requirements, we need to do object instantiation in python
 # (see Timestamp class above). This will serve as a C extension type that
@@ -287,6 +309,28 @@ cdef class _Timestamp(datetime):
                                   field)
         return out[0]
 
+
+cdef class _NaT(_Timestamp):
+
+    def __richcmp__(_NaT self, object other, int op):
+        # if not isinstance(other, (_NaT, _Timestamp)):
+        #     raise TypeError('Cannot compare %s with NaT' % type(other))
+
+        if op == 2: # ==
+            return False
+        elif op == 3: # !=
+            return True
+        elif op == 0: # <
+            return False
+        elif op == 1: # <=
+            return False
+        elif op == 4: # >
+            return False
+        elif op == 5: # >=
+            return False
+
+
+
 def _delta_to_nanoseconds(delta):
     try:
         delta = delta.delta
@@ -819,7 +863,7 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False):
         for i in range(n):
             val = values[i]
             if util._checknull(val):
-                iresult[i] = NaT
+                iresult[i] = iNaT
             elif PyDateTime_Check(val):
                 result[i] = val
             elif PyDate_Check(val):
@@ -830,7 +874,7 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False):
                 iresult[i] = val
             else:
                 if len(val) == 0:
-                    iresult[i] = NaT
+                    iresult[i] = iNaT
                     continue
                 try:
                     result[i] = parse(val, dayfirst=dayfirst)
@@ -846,6 +890,7 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False):
                 oresult[i] = val
             else:
                 if len(val) == 0:
+                    # TODO: ??
                     oresult[i] = 'NaT'
                     continue
                 try:
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 6b180f4d5..289260b45 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -101,6 +101,8 @@ cdef class IndexEngine:
             void* data_ptr
 
         loc = self.get_loc(key)
+        value = convert_scalar(arr, value)
+
         if PySlice_Check(loc) or cnp.PyArray_Check(loc):
             arr[loc] = value
         else:
@@ -435,12 +437,20 @@ cdef class DatetimeEngine(Int64Engine):
                                      limit=limit)
 
 
-cpdef convert_scalar(ndarray arr, object scalar):
+cpdef convert_scalar(ndarray arr, object value):
     if arr.descr.type_num == NPY_DATETIME:
-        if not isinstance(scalar, _Timestamp):
-            scalar = Timestamp(scalar)
-        return scalar.asm8
-    return scalar
+        if isinstance(value, _Timestamp):
+            return (<_Timestamp> value).value
+        elif value is None or value != value:
+            return iNaT
+        else:
+            return Timestamp(value).value
+
+    if issubclass(arr.dtype.type, (np.integer, np.bool_)):
+        if util.is_float_object(value) and value != value:
+            raise ValueError('Cannot assign nan to integer series')
+
+    return value
 
 cdef inline _to_i8(object val):
     cdef pandas_datetimestruct dts
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 28e8f4394..7cfae8053 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -271,7 +271,7 @@ def maybe_convert_numeric(ndarray[object] values, set na_values):
         return ints
 
 def maybe_convert_objects(ndarray[object] objects, bint try_float=0,
-                          bint safe=0, bint convert_datetime=1):
+                          bint safe=0, bint convert_datetime=0):
     '''
     Type inference function-- convert object array to proper dtype
     '''
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 35d2b6591..a769fcef5 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -46,6 +46,8 @@ from datetime import datetime as pydatetime
 # this is our datetime.pxd
 from datetime cimport *
 
+cdef int64_t NPY_NAT = util.get_nat()
+
 from khash cimport *
 
 cdef inline int int_max(int a, int b): return a if a >= b else b
@@ -90,8 +92,6 @@ cpdef map_indices_list(list index):
 
 from libc.stdlib cimport malloc, free
 
-NaT = util.get_nat()
-
 def ismember(ndarray arr, set values):
     '''
     Checks whether
@@ -184,12 +184,17 @@ cpdef checknull(object val):
     if util.is_float_object(val) or util.is_complex_object(val):
         return val != val or val == INF or val == NEGINF
     elif util.is_datetime64_object(val):
-        return val.view('i8') == NaT
+        return get_datetime64_value(val) == NPY_NAT
+    elif isinstance(val, _NaT):
+        return True
     elif is_array(val):
         return False
     else:
         return util._checknull(val)
 
+def isscalar(object val):
+    return np.isscalar(val) or val is None or isinstance(val, _Timestamp)
+
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 3d3ffe7a7..c11886162 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -50,7 +50,7 @@ def test_isnull_datetime():
 
     import pandas._tseries as lib
     idx = np.asarray(idx)
-    idx[0] = lib.NaT
+    idx[0] = lib.iNaT
     idx = DatetimeIndex(idx)
     mask = isnull(idx)
     assert(mask[0])
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 941f2fef2..cc9a7ad11 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -33,7 +33,7 @@ import pandas.util.py3compat as py3compat
 from pandas.core.datetools import BDay
 import pandas.core.common as com
 
-NaT = lib.NaT
+iNaT = lib.iNaT
 
 
 class TestTimeSeriesDuplicates(unittest.TestCase):
@@ -353,7 +353,7 @@ class TestTimeSeries(unittest.TestCase):
         self.assert_(not mask[:-5].any())
 
     def test_series_repr_nat(self):
-        series = Series([0, 1000, 2000, NaT], dtype='M8[ns]')
+        series = Series([0, 1000, 2000, iNaT], dtype='M8[ns]')
 
         result = repr(series)
         expected = ('0          1970-01-01 00:00:00\n'
@@ -363,7 +363,7 @@ class TestTimeSeries(unittest.TestCase):
         self.assertEquals(result, expected)
 
     def test_fillna_nat(self):
-        series = Series([0, 1, 2, NaT], dtype='M8[ns]')
+        series = Series([0, 1, 2, iNaT], dtype='M8[ns]')
 
         filled = series.fillna(method='pad')
         filled2 = series.fillna(value=series.values[2])
@@ -382,7 +382,7 @@ class TestTimeSeries(unittest.TestCase):
         assert_frame_equal(filled2, expected)
 
 
-        series = Series([NaT, 0, 1, 2], dtype='M8[ns]')
+        series = Series([iNaT, 0, 1, 2], dtype='M8[ns]')
 
         filled = series.fillna(method='bfill')
         filled2 = series.fillna(value=series[1])
@@ -411,7 +411,7 @@ class TestTimeSeries(unittest.TestCase):
         expected = np.empty(4, dtype='M8[ns]')
         for i, val in enumerate(strings):
             if com.isnull(val):
-                expected[i] = NaT
+                expected[i] = iNaT
             else:
                 expected[i] = parse(val)
 
@@ -443,7 +443,7 @@ class TestTimeSeries(unittest.TestCase):
         for i in range(5):
             x = series[i]
             if isnull(x):
-                expected[i] = NaT
+                expected[i] = iNaT
             else:
                 expected[i] = to_datetime(x)
 
@@ -1260,7 +1260,11 @@ class TestDatetime64(unittest.TestCase):
 class TestSeriesDatetime64(unittest.TestCase):
 
     def setUp(self):
-        self.series = Series(list(date_range('1/1/2000', periods=10)))
+        self.series = Series(date_range('1/1/2000', periods=10))
+
+    def test_auto_conversion(self):
+        series = Series(list(date_range('1/1/2000', periods=10)))
+        self.assert_(series.dtype == object)
 
     def test_series_comparison_scalars(self):
         val = datetime(2000, 1, 4)
@@ -1283,6 +1287,28 @@ class TestSeriesDatetime64(unittest.TestCase):
     #----------------------------------------------------------------------
     # NaT support
 
+    def test_NaT_scalar(self):
+        series = Series([0, 1000, 2000, iNaT], dtype='M8[ns]')
+
+        val = series[3]
+        self.assert_(com.isnull(val))
+
+        series[2] = val
+        self.assert_(com.isnull(series[2]))
+
+    def test_set_none_nan(self):
+        self.series[3] = None
+        self.assert_(self.series[3] is lib.NaT)
+
+        self.series[3:5] = None
+        self.assert_(self.series[4] is lib.NaT)
+
+        self.series[5] = np.nan
+        self.assert_(self.series[5] is lib.NaT)
+
+        self.series[5:7] = np.nan
+        self.assert_(self.series[6] is lib.NaT)
+
 
 class TestTimestamp(unittest.TestCase):
 
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 6b41fbe48..6b3b3dba1 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -33,8 +33,6 @@ import pandas.util.py3compat as py3compat
 from pandas.core.datetools import BDay
 import pandas.core.common as com
 
-NaT = lib.NaT
-
 
 def _skip_if_no_pytz():
     try:

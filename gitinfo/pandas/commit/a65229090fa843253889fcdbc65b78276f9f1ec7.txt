commit a65229090fa843253889fcdbc65b78276f9f1ec7
Author: Nicolas Bonnotte <nicolas.bonnotte@gmail.com>
Date:   Wed Feb 24 13:52:09 2016 +0100

    BUG: to_sql with datetime.time values with sqlite
    
    I'm proposing a solution to #8341    As @jorisvandenbossche suggested,
    I use a sqlite3 adapter to transform `datetime.time` objects into
    string (`hh:mm:ss.ffffff`, as this what sqlalchemy... I think?)    I
    added a test in the class `_TestSQLApi`, so that the solution is
    tested with both sqlalchemy and the sqlite3 fallback. Thus, the result
    should be consistent.
    
    Author: Nicolas Bonnotte <nicolas.bonnotte@gmail.com>
    
    Closes #11547 from nbonnotte/sqlite-to_sql-time and squashes the following commits:
    
    8d449c5 [Nicolas Bonnotte] BUG: to_sql with datetime.time values with sqlite, #8341

diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index 51fa0482a..c51150fd2 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -1097,7 +1097,7 @@ Bug Fixes
 
 - Bug in ``.plot`` potentially modifying the ``colors`` input when the number of columns didn't match the number of series provided (:issue:`12039`).
 - Bug in ``Series.plot`` failing when index has a ``CustomBusinessDay`` frequency (:issue:`7222`).
-
+- Bug in ``.to_sql`` for ``datetime.time`` values with sqlite fallback (:issue:`8341`)
 - Bug in ``read_excel`` failing to read data with one column when ``squeeze=True`` (:issue:`12157`)
 - Bug in ``.groupby`` where a ``KeyError`` was not raised for a wrong column if there was only one row in the dataframe (:issue:`11741`)
 - Bug in ``.read_csv`` with dtype specified on empty data producing an error (:issue:`12048`)
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index c29286016..addc88beb 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -5,7 +5,7 @@ retrieval and to reduce dependency on DB-specific API.
 """
 
 from __future__ import print_function, division
-from datetime import datetime, date
+from datetime import datetime, date, time
 
 import warnings
 import traceback
@@ -1403,6 +1403,15 @@ class SQLiteTable(SQLTable):
     Instead of a table variable just use the Create Table statement.
     """
 
+    def __init__(self, *args, **kwargs):
+        # GH 8341
+        # register an adapter callable for datetime.time object
+        import sqlite3
+        # this will transform time(12,34,56,789) into '12:34:56.000789'
+        # (this is what sqlalchemy does)
+        sqlite3.register_adapter(time, lambda _: _.strftime("%H:%M:%S.%f"))
+        super(SQLiteTable, self).__init__(*args, **kwargs)
+
     def sql_schema(self):
         return str(";\n".join(self.table))
 
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index c2d6f5af4..b72258cbf 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -1429,6 +1429,22 @@ class _TestSQLAlchemy(SQLAlchemyMixIn, PandasSQLTest):
         res = read_sql_table('test_time', self.conn)
         tm.assert_frame_equal(res, df)
 
+        # GH8341
+        # first, use the fallback to have the sqlite adapter put in place
+        sqlite_conn = TestSQLiteFallback.connect()
+        sql.to_sql(df, "test_time2", sqlite_conn, index=False)
+        res = sql.read_sql_query("SELECT * FROM test_time2", sqlite_conn)
+        ref = df.applymap(lambda _: _.strftime("%H:%M:%S.%f"))
+        tm.assert_frame_equal(ref, res)  # check if adapter is in place
+        # then test if sqlalchemy is unaffected by the sqlite adapter
+        sql.to_sql(df, "test_time3", self.conn, index=False)
+        if self.flavor == 'sqlite':
+            res = sql.read_sql_query("SELECT * FROM test_time3", self.conn)
+            ref = df.applymap(lambda _: _.strftime("%H:%M:%S.%f"))
+            tm.assert_frame_equal(ref, res)
+        res = sql.read_sql_table("test_time3", self.conn)
+        tm.assert_frame_equal(df, res)
+
     def test_mixed_dtype_insert(self):
         # see GH6509
         s1 = Series(2**25 + 1, dtype=np.int32)
@@ -1957,12 +1973,14 @@ class TestSQLiteFallback(SQLiteMixIn, PandasSQLTest):
             tm.assert_frame_equal(res, df)
 
     def test_datetime_time(self):
-        # test support for datetime.time
+        # test support for datetime.time, GH #8341
         df = DataFrame([time(9, 0, 0), time(9, 1, 30)], columns=["a"])
-        # test it raises an error and not fails silently (GH8341)
+        df.to_sql('test_time', self.conn, index=False, flavor=self.flavor)
+        res = read_sql_query('SELECT * FROM test_time', self.conn)
         if self.flavor == 'sqlite':
-            self.assertRaises(sqlite3.InterfaceError, sql.to_sql, df,
-                              'test_time', self.conn)
+            # comes back as strings
+            expected = df.applymap(lambda _: _.strftime("%H:%M:%S.%f"))
+            tm.assert_frame_equal(res, expected)
 
     def _get_index_columns(self, tbl_name):
         ixs = sql.read_sql_query(

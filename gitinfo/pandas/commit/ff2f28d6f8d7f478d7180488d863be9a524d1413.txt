commit ff2f28d6f8d7f478d7180488d863be9a524d1413
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Oct 2 18:37:20 2011 -0400

    TST: test coverage for index.py, minor refactoring

diff --git a/bench/zoo_bench.py b/bench/zoo_bench.py
index 6605269cb..3d58672f8 100644
--- a/bench/zoo_bench.py
+++ b/bench/zoo_bench.py
@@ -14,11 +14,18 @@ def sample(values, k):
 
 subsample_size = 90000
 
-x = Series(np.random.randn(100000), indices)
-y = Series(np.random.randn(subsample_size),
-           index=sample(indices, subsample_size))
+# x = Series(np.random.randn(100000), indices)
+# y = Series(np.random.randn(subsample_size),
+#            index=sample(indices, subsample_size))
 
 
-lx = larry(np.random.randn(100000), [list(indices)])
-ly = larry(np.random.randn(subsample_size), [list(y.index)])
+# lx = larry(np.random.randn(100000), [list(indices)])
+# ly = larry(np.random.randn(subsample_size), [list(y.index)])
 
+stamps = np.random.randint(1000000000, 1000000000000, 2000000)
+
+idx1 = np.sort(sample(stamps, 1000000))
+idx2 = np.sort(sample(stamps, 1000000))
+
+ts1 = Series(np.random.randn(1000000), idx1)
+ts2 = Series(np.random.randn(1000000), idx2)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index a25cd358d..dea96477c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -59,7 +59,7 @@ class Index(np.ndarray):
 
     @property
     def dtype(self):
-        return np.dtype('object')
+        return self.values.dtype
 
     def summary(self):
         if len(self) > 0:
@@ -544,18 +544,33 @@ class Index(np.ndarray):
 class Int64Index(Index):
 
     def __new__(cls, data, dtype=None, copy=False):
-        if isinstance(data, np.ndarray):
-            subarr = np.array(data, dtype=np.int64, copy=copy)
-        elif np.isscalar(data):
-            raise ValueError('Index(...) must be called with a collection '
-                             'of some kind, %s was passed' % repr(data))
-        else:
+        if not isinstance(data, np.ndarray):
+            if np.isscalar(data):
+                raise ValueError('Index(...) must be called with a collection '
+                                 'of some kind, %s was passed' % repr(data))
+
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
                 data = list(data)
-            subarr = np.asarray(data, dtype=np.int64)
+            data= np.asarray(data)
+
+        if issubclass(data.dtype.type, basestring):
+            raise TypeError('String dtype not supported, you may need '
+                            'to explicitly cast to int')
+        elif issubclass(data.dtype.type, np.integer):
+            subarr = np.array(data, dtype=np.int64, copy=copy)
+        else:
+            subarr = np.array(data, dtype=np.int64, copy=copy)
+            if len(data) > 0:
+                if (subarr != data).any():
+                    raise TypeError('Unsafe NumPy casting, you must explicitly '
+                                    'cast')
+
         return subarr.view(cls)
 
+    def astype(self, dtype):
+        return Index(self.values.astype(dtype))
+
     @property
     def dtype(self):
         return np.dtype('int64')
@@ -609,17 +624,17 @@ class Int64Index(Index):
                                          target.indexMap)
         elif method is None:
             indexer = lib.merge_indexer_int64(target, self.indexMap)
-        else:
+        else:  # pragma: no cover
             raise ValueError('unrecognized method: %s' % method)
         return indexer
     get_indexer.__doc__ = Index.get_indexer.__doc__
 
     def join(self, other, how='left', return_indexers=False):
         if not isinstance(other, Int64Index):
-            return Index.join(self, other, how=how,
+            self_as_index = Index(self, dtype=object)
+            return Index.join(self_as_index, other, how=how,
                               return_indexers=return_indexers)
 
-
         if self.is_monotonic and other.is_monotonic:
             return self._join_monotonic(other, how=how,
                                         return_indexers=return_indexers)
@@ -761,6 +776,10 @@ class MultiIndex(Index):
         else:
             self.sortorder = sortorder
 
+    @property
+    def dtype(self):
+        return np.dtype('O')
+
     def __iter__(self):
         values = [np.asarray(lev).take(lab)
                   for lev, lab in zip(self.levels, self.labels)]
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 6442560c7..3af043b56 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -126,9 +126,6 @@ def test_groupby():
 
 class TestTake(unittest.TestCase):
 
-    def setUp(self):
-        pass
-
     def test_1d_with_out(self):
         def _test_dtype(dtype):
             out = np.empty(5, dtype=dtype)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index fb2116c7c..678d12a3c 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -1,3 +1,5 @@
+# pylint: disable=E1101,E1103,W0232
+
 from datetime import datetime, timedelta
 import operator
 import pickle
@@ -5,7 +7,8 @@ import unittest
 
 import numpy as np
 
-from pandas.core.index import Index, Factor, MultiIndex, NULL_INDEX
+from pandas.core.index import (Index, Int64Index, Factor,
+                               MultiIndex, NULL_INDEX)
 from pandas.util.testing import assert_almost_equal
 import pandas.util.testing as tm
 import pandas._tseries as tseries
@@ -315,6 +318,207 @@ class TestIndex(unittest.TestCase):
         self.assert_(union_idx.ndim == 1)
         self.assert_(union_idx.equals(expected))
 
+
+class TestInt64Index(unittest.TestCase):
+
+    def setUp(self):
+        self.index = Int64Index(np.arange(0, 20, 2))
+
+    def test_constructor(self):
+        # pass list, coerce fine
+        index = Int64Index([-5, 0, 1, 2])
+        expected = np.array([-5, 0, 1, 2], dtype=np.int64)
+        self.assert_(np.array_equal(index, expected))
+
+        # from iterable
+        index = Int64Index(iter([-5, 0, 1, 2]))
+        self.assert_(np.array_equal(index, expected))
+
+        # scalar raise Exception
+        self.assertRaises(ValueError, Int64Index, 5)
+
+    def test_constructor_corner(self):
+        arr = np.array([1, 2, 3, 4], dtype=object)
+        index = Int64Index(arr)
+        self.assert_(index.values.dtype == np.int64)
+        self.assert_(index.equals(arr))
+
+        # preventing casting
+        arr = np.array([1, '2', 3, '4'], dtype=object)
+        self.assertRaises(TypeError, Int64Index, arr)
+
+    def test_dtype(self):
+        self.assert_(self.index.dtype == np.int64)
+
+    def test_is_monotonic(self):
+        self.assert_(self.index.is_monotonic)
+
+        index = Int64Index([4, 3, 2, 1])
+        self.assert_(not index.is_monotonic)
+
+    def test_equals(self):
+        same_values = Index(self.index, dtype=object)
+        self.assert_(self.index.equals(same_values))
+        self.assert_(same_values.equals(self.index))
+
+    def test_get_indexer(self):
+        target = Int64Index(np.arange(10))
+        indexer = self.index.get_indexer(target)
+        expected = np.array([0, -1, 1, -1, 2, -1, 3, -1, 4, -1])
+        self.assert_(np.array_equal(indexer, expected))
+
+    def test_get_indexer_pad(self):
+        target = Int64Index(np.arange(10))
+        indexer = self.index.get_indexer(target, method='pad')
+        expected = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4])
+        self.assert_(np.array_equal(indexer, expected))
+
+    def test_get_indexer_backfill(self):
+        target = Int64Index(np.arange(10))
+        indexer = self.index.get_indexer(target, method='backfill')
+        expected = np.array([0, 1, 1, 2, 2, 3, 3, 4, 4, 5])
+        self.assert_(np.array_equal(indexer, expected))
+
+    def test_join_outer(self):
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        # guarantee of sortedness
+        res, lidx, ridx = self.index.join(other, how='outer',
+                                          return_indexers=True)
+        eres = Int64Index([0, 1, 2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 25])
+        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1],
+                         dtype='i4')
+        eridx = np.array([-1, 3, 4, -1, 5, -1, 0, -1, -1, 1, -1, -1, -1, 2],
+                         dtype='i4')
+
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(np.array_equal(lidx, elidx))
+        self.assert_(np.array_equal(ridx, eridx))
+
+        # monotonic
+        res, lidx, ridx = self.index.join(other_mono, how='outer',
+                                          return_indexers=True)
+        eridx = np.array([-1, 0, 1, -1, 2, -1, 3, -1, -1, 4, -1, -1, -1, 5],
+                         dtype='i4')
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(np.array_equal(lidx, elidx))
+        self.assert_(np.array_equal(ridx, eridx))
+
+    def test_join_inner(self):
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = self.index.join(other, how='inner',
+                                          return_indexers=True)
+
+        # no guarantee of sortedness, so sort for comparison purposes
+        ind = res.argsort()
+        res = res.take(ind)
+        lidx = lidx.take(ind)
+        ridx = ridx.take(ind)
+
+        eres = Int64Index([2, 12])
+        elidx = np.array([1, 6])
+        eridx = np.array([4, 1])
+
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(np.array_equal(lidx, elidx))
+        self.assert_(np.array_equal(ridx, eridx))
+
+        # monotonic
+        res, lidx, ridx = self.index.join(other_mono, how='inner',
+                                          return_indexers=True)
+        eridx = np.array([1, 4])
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(np.array_equal(lidx, elidx))
+        self.assert_(np.array_equal(ridx, eridx))
+
+    def test_join_left(self):
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = self.index.join(other, how='left',
+                                          return_indexers=True)
+        eres = self.index
+        eridx = np.array([-1, 4, -1, -1, -1, -1, 1, -1, -1, -1],
+                         dtype='i4')
+
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(lidx is None)
+        self.assert_(np.array_equal(ridx, eridx))
+
+        # monotonic
+        res, lidx, ridx = self.index.join(other_mono, how='left',
+                                          return_indexers=True)
+        eridx = np.array([-1, 1, -1, -1, -1, -1, 4, -1, -1, -1],
+                         dtype='i4')
+        self.assert_(isinstance(res, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(lidx is None)
+        self.assert_(np.array_equal(ridx, eridx))
+
+    def test_join_right(self):
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = self.index.join(other, how='right',
+                                          return_indexers=True)
+        eres = other
+        elidx = np.array([-1, 6, -1, -1, 1, -1],
+                         dtype='i4')
+
+        self.assert_(isinstance(other, Int64Index))
+        self.assert_(res.equals(eres))
+        self.assert_(np.array_equal(lidx, elidx))
+        self.assert_(ridx is None)
+
+    def test_join_corner(self):
+        pass
+
+    def test_join_non_int_index(self):
+        other = Index([3, 6, 7, 8, 10], dtype=object)
+
+        outer = self.index.join(other, how='outer')
+        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14,
+                          16, 18], dtype=object)
+        self.assert_(outer.equals(expected))
+
+        inner = self.index.join(other, how='inner')
+        expected = Index([6, 8, 10], dtype=object)
+        self.assert_(inner.equals(expected))
+
+        left = self.index.join(other, how='left')
+        self.assert_(left.equals(self.index))
+
+        right = self.index.join(other, how='right')
+        self.assert_(right.equals(other))
+
+    def test_cant_or_shouldnt_cast(self):
+        # can't
+        data = ['foo', 'bar', 'baz']
+        self.assertRaises(TypeError, Int64Index, data)
+
+        # shouldn't
+        data = ['0', '1', '2']
+        self.assertRaises(TypeError, Int64Index, data)
+
+    def test_view_Index(self):
+        self.index.view(Index)
+
+    def test_prevent_casting(self):
+        result = self.index.astype('O')
+        self.assert_(result.dtype == np.object_)
+
 class TestMultiIndex(unittest.TestCase):
 
     def setUp(self):
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index cda6ecd98..d57927939 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -595,8 +595,8 @@ class TestSeries(unittest.TestCase):
             _check_fill(op, equiv_op, a, b, fill_value=fv)
 
     def test_combine_first(self):
-        series = Series(common.makeIntIndex(20).astype(float),
-                        index=common.makeIntIndex(20))
+        values = common.makeIntIndex(20).values.astype(float)
+        series = Series(values, index=common.makeIntIndex(20))
 
         series_copy = series * 2
         series_copy[::2] = np.NaN

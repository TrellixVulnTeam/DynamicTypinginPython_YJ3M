commit c5f2084160f765f6b7495b987a198f9db5e972cd
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Dec 3 10:38:36 2019 -0800

    CLN: test code no longer shared with sparse (#30007)

diff --git a/pandas/tests/frame/test_api.py b/pandas/tests/frame/test_api.py
index a86e1dfe8..60befe5e7 100644
--- a/pandas/tests/frame/test_api.py
+++ b/pandas/tests/frame/test_api.py
@@ -6,35 +6,11 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import (
-    Categorical,
-    DataFrame,
-    Series,
-    SparseDtype,
-    compat,
-    date_range,
-    timedelta_range,
-)
+from pandas import Categorical, DataFrame, Series, compat, date_range, timedelta_range
 import pandas.util.testing as tm
 
 
-class SharedWithSparse:
-    """
-    A collection of tests DataFrame and SparseDataFrame can share.
-
-    In generic tests on this class, use ``self._assert_frame_equal()`` and
-    ``self._assert_series_equal()`` which are implemented in sub-classes
-    and dispatch correctly.
-    """
-
-    def _assert_frame_equal(self, left, right):
-        """Dispatch to frame class dependent assertion"""
-        raise NotImplementedError
-
-    def _assert_series_equal(self, left, right):
-        """Dispatch to series class dependent assertion"""
-        raise NotImplementedError
-
+class TestDataFrameMisc:
     def test_copy_index_name_checking(self, float_frame):
         # don't want to be able to modify the index stored elsewhere after
         # making a copy
@@ -141,16 +117,16 @@ class SharedWithSparse:
     def test_not_hashable(self):
         empty_frame = DataFrame()
 
-        df = self.klass([1])
-        msg = "'(Sparse)?DataFrame' objects are mutable, thus they cannot be hashed"
+        df = DataFrame([1])
+        msg = "'DataFrame' objects are mutable, thus they cannot be hashed"
         with pytest.raises(TypeError, match=msg):
             hash(df)
         with pytest.raises(TypeError, match=msg):
             hash(empty_frame)
 
     def test_new_empty_index(self):
-        df1 = self.klass(np.random.randn(0, 3))
-        df2 = self.klass(np.random.randn(0, 3))
+        df1 = DataFrame(np.random.randn(0, 3))
+        df2 = DataFrame(np.random.randn(0, 3))
         df1.index.name = "foo"
         assert df2.index.name is None
 
@@ -161,7 +137,7 @@ class SharedWithSparse:
         assert result.index is float_frame.index
         assert result.columns is float_frame.columns
 
-        self._assert_frame_equal(result, float_frame.apply(np.sqrt))
+        tm.assert_frame_equal(result, float_frame.apply(np.sqrt))
 
     def test_get_agg_axis(self, float_frame):
         cols = float_frame._get_agg_axis(0)
@@ -187,9 +163,9 @@ class SharedWithSparse:
         assert not df.empty
 
     def test_iteritems(self):
-        df = self.klass([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
+        df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["a", "a", "b"])
         for k, v in df.items():
-            assert isinstance(v, self.klass._constructor_sliced)
+            assert isinstance(v, DataFrame._constructor_sliced)
 
     def test_items(self):
         # GH 17213, GH 13918
@@ -206,15 +182,15 @@ class SharedWithSparse:
     def test_iterrows(self, float_frame, float_string_frame):
         for k, v in float_frame.iterrows():
             exp = float_frame.loc[k]
-            self._assert_series_equal(v, exp)
+            tm.assert_series_equal(v, exp)
 
         for k, v in float_string_frame.iterrows():
             exp = float_string_frame.loc[k]
-            self._assert_series_equal(v, exp)
+            tm.assert_series_equal(v, exp)
 
     def test_iterrows_iso8601(self):
         # GH 19671
-        s = self.klass(
+        s = DataFrame(
             {
                 "non_iso8601": ["M1701", "M1802", "M1903", "M2004"],
                 "iso8601": date_range("2000-01-01", periods=4, freq="M"),
@@ -222,7 +198,7 @@ class SharedWithSparse:
         )
         for k, v in s.iterrows():
             exp = s.loc[k]
-            self._assert_series_equal(v, exp)
+            tm.assert_series_equal(v, exp)
 
     def test_iterrows_corner(self):
         # gh-12222
@@ -248,19 +224,19 @@ class SharedWithSparse:
 
     def test_itertuples(self, float_frame):
         for i, tup in enumerate(float_frame.itertuples()):
-            s = self.klass._constructor_sliced(tup[1:])
+            s = DataFrame._constructor_sliced(tup[1:])
             s.name = tup[0]
             expected = float_frame.iloc[i, :].reset_index(drop=True)
-            self._assert_series_equal(s, expected)
+            tm.assert_series_equal(s, expected)
 
-        df = self.klass(
+        df = DataFrame(
             {"floats": np.random.randn(5), "ints": range(5)}, columns=["floats", "ints"]
         )
 
         for tup in df.itertuples(index=False):
             assert isinstance(tup[1], int)
 
-        df = self.klass(data={"a": [1, 2, 3], "b": [4, 5, 6]})
+        df = DataFrame(data={"a": [1, 2, 3], "b": [4, 5, 6]})
         dfaa = df[["a", "a"]]
 
         assert list(dfaa.itertuples()) == [(0, 1, 1), (1, 2, 2), (2, 3, 3)]
@@ -315,7 +291,7 @@ class SharedWithSparse:
     def test_len(self, float_frame):
         assert len(float_frame) == len(float_frame.index)
 
-    def test_values(self, float_frame, float_string_frame):
+    def test_values_mixed_dtypes(self, float_frame, float_string_frame):
         frame = float_frame
         arr = frame.values
 
@@ -332,7 +308,7 @@ class SharedWithSparse:
         arr = float_string_frame[["foo", "A"]].values
         assert arr[0, 0] == "bar"
 
-        df = self.klass({"complex": [1j, 2j, 3j], "real": [1, 2, 3]})
+        df = DataFrame({"complex": [1j, 2j, 3j], "real": [1, 2, 3]})
         arr = df.values
         assert arr[0, 0] == 1j
 
@@ -372,17 +348,17 @@ class SharedWithSparse:
 
         # mixed type
         index, data = tm.getMixedTypeDict()
-        mixed = self.klass(data, index=index)
+        mixed = DataFrame(data, index=index)
 
         mixed_T = mixed.T
         for col, s in mixed_T.items():
             assert s.dtype == np.object_
 
     def test_swapaxes(self):
-        df = self.klass(np.random.randn(10, 5))
-        self._assert_frame_equal(df.T, df.swapaxes(0, 1))
-        self._assert_frame_equal(df.T, df.swapaxes(1, 0))
-        self._assert_frame_equal(df, df.swapaxes(0, 0))
+        df = DataFrame(np.random.randn(10, 5))
+        tm.assert_frame_equal(df.T, df.swapaxes(0, 1))
+        tm.assert_frame_equal(df.T, df.swapaxes(1, 0))
+        tm.assert_frame_equal(df, df.swapaxes(0, 0))
         msg = (
             "No axis named 2 for object type"
             r" <class 'pandas.core(.sparse)?.frame.(Sparse)?DataFrame'>"
@@ -413,7 +389,7 @@ class SharedWithSparse:
         assert values.shape[1] == len(float_string_frame.columns)
 
     def test_repr_with_mi_nat(self, float_string_frame):
-        df = self.klass(
+        df = DataFrame(
             {"X": [1, 2]}, index=[[pd.NaT, pd.Timestamp("20130101")], ["a", "b"]]
         )
         result = repr(df)
@@ -430,18 +406,18 @@ class SharedWithSparse:
             assert v.name == k
 
     def test_empty_nonzero(self):
-        df = self.klass([1, 2, 3])
+        df = DataFrame([1, 2, 3])
         assert not df.empty
-        df = self.klass(index=[1], columns=[1])
+        df = DataFrame(index=[1], columns=[1])
         assert not df.empty
-        df = self.klass(index=["a", "b"], columns=["c", "d"]).dropna()
+        df = DataFrame(index=["a", "b"], columns=["c", "d"]).dropna()
         assert df.empty
         assert df.T.empty
         empty_frames = [
-            self.klass(),
-            self.klass(index=[1]),
-            self.klass(columns=[1]),
-            self.klass({1: []}),
+            DataFrame(),
+            DataFrame(index=[1]),
+            DataFrame(columns=[1]),
+            DataFrame({1: []}),
         ]
         for df in empty_frames:
             assert df.empty
@@ -449,7 +425,7 @@ class SharedWithSparse:
 
     def test_with_datetimelikes(self):
 
-        df = self.klass(
+        df = DataFrame(
             {
                 "A": date_range("20130101", periods=10),
                 "B": timedelta_range("1 day", periods=10),
@@ -458,20 +434,9 @@ class SharedWithSparse:
         t = df.T
 
         result = t.dtypes.value_counts()
-        if self.klass is DataFrame:
-            expected = Series({np.dtype("object"): 10})
-        else:
-            expected = Series({SparseDtype(dtype=object): 10})
+        expected = Series({np.dtype("object"): 10})
         tm.assert_series_equal(result, expected)
 
-
-class TestDataFrameMisc(SharedWithSparse):
-
-    klass = DataFrame
-    # SharedWithSparse tests use generic, klass-agnostic assertion
-    _assert_frame_equal = staticmethod(tm.assert_frame_equal)
-    _assert_series_equal = staticmethod(tm.assert_series_equal)
-
     def test_values(self, float_frame):
         float_frame.values[:, 0] = 5.0
         assert (float_frame.values[:, 0] == 5).all()
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index 1e4757ffe..42b2c3763 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -24,18 +24,7 @@ import pandas.util.testing as tm
 import pandas.io.formats.printing as printing
 
 
-class SharedWithSparse:
-    """
-    A collection of tests Series and SparseSeries can share.
-
-    In generic tests on this class, use ``self._assert_series_equal()``
-    which is implemented in sub-classes.
-    """
-
-    def _assert_series_equal(self, left, right):
-        """Dispatch to series class dependent assertion"""
-        raise NotImplementedError
-
+class TestSeriesMisc:
     def test_scalarop_preserve_name(self, datetime_series):
         result = datetime_series * 2
         assert result.name == datetime_series.name
@@ -132,19 +121,19 @@ class SharedWithSparse:
 
     def test_constructor_dict(self):
         d = {"a": 0.0, "b": 1.0, "c": 2.0}
-        result = self.series_klass(d)
-        expected = self.series_klass(d, index=sorted(d.keys()))
-        self._assert_series_equal(result, expected)
+        result = Series(d)
+        expected = Series(d, index=sorted(d.keys()))
+        tm.assert_series_equal(result, expected)
 
-        result = self.series_klass(d, index=["b", "c", "d", "a"])
-        expected = self.series_klass([1, 2, np.nan, 0], index=["b", "c", "d", "a"])
-        self._assert_series_equal(result, expected)
+        result = Series(d, index=["b", "c", "d", "a"])
+        expected = Series([1, 2, np.nan, 0], index=["b", "c", "d", "a"])
+        tm.assert_series_equal(result, expected)
 
     def test_constructor_subclass_dict(self):
         data = tm.TestSubDict((x, 10.0 * x) for x in range(10))
-        series = self.series_klass(data)
-        expected = self.series_klass(dict(data.items()))
-        self._assert_series_equal(series, expected)
+        series = Series(data)
+        expected = Series(dict(data.items()))
+        tm.assert_series_equal(series, expected)
 
     def test_constructor_ordereddict(self):
         # GH3283
@@ -152,44 +141,44 @@ class SharedWithSparse:
             ("col{i}".format(i=i), np.random.random()) for i in range(12)
         )
 
-        series = self.series_klass(data)
-        expected = self.series_klass(list(data.values()), list(data.keys()))
-        self._assert_series_equal(series, expected)
+        series = Series(data)
+        expected = Series(list(data.values()), list(data.keys()))
+        tm.assert_series_equal(series, expected)
 
         # Test with subclass
         class A(OrderedDict):
             pass
 
-        series = self.series_klass(A(data))
-        self._assert_series_equal(series, expected)
+        series = Series(A(data))
+        tm.assert_series_equal(series, expected)
 
     def test_constructor_dict_multiindex(self):
         d = {("a", "a"): 0.0, ("b", "a"): 1.0, ("b", "c"): 2.0}
         _d = sorted(d.items())
-        result = self.series_klass(d)
-        expected = self.series_klass(
+        result = Series(d)
+        expected = Series(
             [x[1] for x in _d], index=pd.MultiIndex.from_tuples([x[0] for x in _d])
         )
-        self._assert_series_equal(result, expected)
+        tm.assert_series_equal(result, expected)
 
         d["z"] = 111.0
         _d.insert(0, ("z", d["z"]))
-        result = self.series_klass(d)
-        expected = self.series_klass(
+        result = Series(d)
+        expected = Series(
             [x[1] for x in _d], index=pd.Index([x[0] for x in _d], tupleize_cols=False)
         )
         result = result.reindex(index=expected.index)
-        self._assert_series_equal(result, expected)
+        tm.assert_series_equal(result, expected)
 
     def test_constructor_dict_timedelta_index(self):
         # GH #12169 : Resample category data with timedelta index
         # construct Series from dict as data and TimedeltaIndex as index
         # will result NaN in result Series data
-        expected = self.series_klass(
+        expected = Series(
             data=["A", "B", "C"], index=pd.to_timedelta([0, 10, 20], unit="s")
         )
 
-        result = self.series_klass(
+        result = Series(
             data={
                 pd.to_timedelta(0, unit="s"): "A",
                 pd.to_timedelta(10, unit="s"): "B",
@@ -197,20 +186,13 @@ class SharedWithSparse:
             },
             index=pd.to_timedelta([0, 10, 20], unit="s"),
         )
-        self._assert_series_equal(result, expected)
+        tm.assert_series_equal(result, expected)
 
     def test_sparse_accessor_updates_on_inplace(self):
         s = pd.Series([1, 1, 2, 3], dtype="Sparse[int]")
         s.drop([0, 1], inplace=True)
         assert s.sparse.density == 1.0
 
-
-class TestSeriesMisc(SharedWithSparse):
-
-    series_klass = Series
-    # SharedWithSparse tests use generic, series_klass-agnostic assertion
-    _assert_series_equal = staticmethod(tm.assert_series_equal)
-
     def test_tab_completion(self):
         # GH 9910
         s = Series(list("abcd"))

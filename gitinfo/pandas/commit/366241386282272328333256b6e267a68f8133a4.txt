commit 366241386282272328333256b6e267a68f8133a4
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Dec 31 11:41:30 2016 -0500

    CLN: rework apply_loffset a bit to make it applied only once
    
    xref #13218

diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index cf96a688f..e6d500144 100755
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -319,15 +319,11 @@ class Resampler(_GroupBy):
         self._set_binner()
         result, how = self._aggregate(arg, *args, **kwargs)
         if result is None:
-            return self._groupby_and_aggregate(arg,
-                                               *args,
-                                               **kwargs)
-
-        # if arg was a string, _aggregate called resampler's _downsample or
-        # _groupby_and_agg methods, which would've already applied the loffset
-        if not isinstance(arg, compat.string_types):
-            result = self._apply_loffset(result)
+            result = self._groupby_and_aggregate(arg,
+                                                 *args,
+                                                 **kwargs)
 
+        result = self._apply_loffset(result)
         return result
 
     agg = aggregate
@@ -410,31 +406,31 @@ class Resampler(_GroupBy):
             result = grouped.apply(how, *args, **kwargs)
 
         result = self._apply_loffset(result)
-
         return self._wrap_result(result)
 
     def _apply_loffset(self, result):
         """
         if loffset is set, offset the result index
 
+        This is NOT an idempotent routine, it will be applied
+        exactly once to the result.
+
         Parameters
         ----------
         result : Series or DataFrame
             the result of resample
         """
-        loffset = self.loffset
-        if isinstance(loffset, compat.string_types):
-            loffset = to_offset(self.loffset)
 
         needs_offset = (
-            isinstance(loffset, (DateOffset, timedelta)) and
+            isinstance(self.loffset, (DateOffset, timedelta)) and
             isinstance(result.index, DatetimeIndex) and
             len(result.index) > 0
         )
 
         if needs_offset:
-            result.index = result.index + loffset
+            result.index = result.index + self.loffset
 
+        self.loffset = None
         return result
 
     def _get_resampler_for_grouping(self, groupby, **kwargs):
@@ -445,6 +441,7 @@ class Resampler(_GroupBy):
         """ potentially wrap any results """
         if isinstance(result, com.ABCSeries) and self._selection is not None:
             result.name = self._selection
+
         return result
 
     def pad(self, limit=None):
@@ -706,7 +703,6 @@ class DatetimeIndexResampler(Resampler):
             self.grouper, axis=self.axis).aggregate(how, **kwargs)
 
         result = self._apply_loffset(result)
-
         return self._wrap_result(result)
 
     def _adjust_binner_for_upsample(self, binner):
@@ -810,11 +806,7 @@ class PeriodIndexResampler(DatetimeIndexResampler):
         if result is None:
             result = self._downsample(arg, *args, **kwargs)
 
-        # if arg was a string, _aggregate called resamplers' _downsample or
-        # _groupby_and_agg methods, which would've already applied the loffset
-        if not isinstance(arg, compat.string_types):
-            result = self._apply_loffset(result)
-
+        result = self._apply_loffset(result)
         return result
 
     agg = aggregate
@@ -1022,7 +1014,10 @@ class TimeGrouper(Grouper):
         self.convention = convention or 'E'
         self.convention = self.convention.lower()
 
+        if isinstance(loffset, compat.string_types):
+            loffset = to_offset(loffset)
         self.loffset = loffset
+
         self.how = how
         self.fill_method = fill_method
         self.limit = limit
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 8f1c65321..26c311b4a 100755
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -777,19 +777,26 @@ class Base(object):
         expected_index = self.create_index(df.index[0],
                                            periods=len(df.index) / 2,
                                            freq='2D')
+
         # loffset coreces PeriodIndex to DateTimeIndex
         if isinstance(expected_index, PeriodIndex):
             expected_index = expected_index.to_timestamp()
+
         expected_index += timedelta(hours=2)
         expected = DataFrame({'value': expected_means}, index=expected_index)
+
         for arg in ['mean', {'value': 'mean'}, ['mean']]:
+
             result_agg = df.resample('2D', loffset='2H').agg(arg)
+
             with tm.assert_produces_warning(FutureWarning,
                                             check_stacklevel=False):
                 result_how = df.resample('2D', how=arg, loffset='2H')
+
             if isinstance(arg, list):
                 expected.columns = pd.MultiIndex.from_tuples([('value',
                                                                'mean')])
+
             # GH 13022, 7687 - TODO: fix resample w/ TimedeltaIndex
             if isinstance(expected.index, TimedeltaIndex):
                 with tm.assertRaises(AssertionError):

commit 07257a0333bfa292b7b76c96422fa3ec617e5089
Author: Hatem Nassrat <hnassrat@gmail.com>
Date:   Mon Apr 13 12:23:41 2015 -0400

    BUG: Fixing == __eq__ operator for MultiIndex ... closes (GH9785)

diff --git a/doc/source/whatsnew/v0.16.1.txt b/doc/source/whatsnew/v0.16.1.txt
index 9f55257d2..74c01d0ef 100644
--- a/doc/source/whatsnew/v0.16.1.txt
+++ b/doc/source/whatsnew/v0.16.1.txt
@@ -125,7 +125,7 @@ Bug Fixes
 - Bug in ``read_csv`` and ``read_table`` when using ``skip_rows`` parameter if blank lines are present. (:issue:`9832`)
 
 - Bug in ``read_csv()`` interprets ``index_col=True`` as ``1`` (:issue:`9798`)
-
+- Bug in index equality comparisons using ``==`` failing on Index/MultiIndex type incompatibility (:issue:`9875`)
 - Bug in which ``SparseDataFrame`` could not take `nan` as a column name (:issue:`8822`)
 
 - Bug in ``Series.quantile`` on empty Series of type ``Datetime`` or ``Timedelta`` (:issue:`9675`)
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 5587ba5f9..c10f220c8 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -2444,7 +2444,10 @@ def _get_dtype_type(arr_or_dtype):
         return np.dtype(arr_or_dtype).type
     elif isinstance(arr_or_dtype, CategoricalDtype):
         return CategoricalDtypeType
-    return arr_or_dtype.dtype.type
+    try:
+        return arr_or_dtype.dtype.type
+    except AttributeError:
+        raise ValueError('%r is not a dtype' % arr_or_dtype)
 
 
 def is_any_int_dtype(arr_or_dtype):
@@ -2515,7 +2518,11 @@ def is_floating_dtype(arr_or_dtype):
 
 
 def is_bool_dtype(arr_or_dtype):
-    tipo = _get_dtype_type(arr_or_dtype)
+    try:
+        tipo = _get_dtype_type(arr_or_dtype)
+    except ValueError:
+        # this isn't even a dtype
+        return False
     return issubclass(tipo, np.bool_)
 
 def is_categorical(array):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3d11979cc..0a3adbd19 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -49,9 +49,8 @@ def _indexOp(opname):
     Wrapper function for index comparison operations, to avoid
     code duplication.
     """
-
     def wrapper(self, other):
-        func = getattr(self._data.view(np.ndarray), opname)
+        func = getattr(self.values, opname)
         result = func(np.asarray(other))
 
         # technically we could support bool dtyped Index
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index e378e2ed4..336340dd9 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -1320,6 +1320,24 @@ class TestIndex(Base, tm.TestCase):
         exp = {1: [0, 1], 2: [2, 3, 4]}
         tm.assert_dict_equal(groups, exp)
 
+    def test_equals_op(self):
+        # For issue #9785
+        index_a = Index(['foo', 'bar', 'baz'])
+        index_b = Index(['foo', 'bar', 'baz', 'qux'])
+        # Testing Numpy Results Equivelent
+        assert_array_equal(
+            index_a.equals(index_a),
+            index_a == index_a
+        )
+        assert_array_equal(
+            index_a.equals(index_b),
+            index_a == index_b,
+        )
+        assert_array_equal(
+            index_b.equals(index_a),
+            index_b == index_a,
+        )
+
 
 class Numeric(Base):
 
@@ -4088,6 +4106,48 @@ class TestMultiIndex(Base, tm.TestCase):
         df_expected = df_expected.set_index('z')
         tm.assert_frame_equal(result, df_expected)
 
+    def test_equals_operator(self):
+        # For issue #9785
+        self.assertTrue((self.index == self.index).all())
+
+    def test_index_compare(self):
+        # For issue #9785
+        index_unequal = Index(['foo', 'bar', 'baz'])
+        index_equal = Index([
+            ('foo', 'one'), ('foo', 'two'), ('bar', 'one'),
+            ('baz', 'two'), ('qux', 'one'), ('qux', 'two')
+        ], tupleize_cols=False)
+        # Testing Numpy Results Equivelent
+        assert_array_equal(
+            index_unequal.equals(self.index),
+            index_unequal == self.index,
+            err_msg = 'Index compared with MultiIndex failed',
+        )
+        assert_array_equal(
+            self.index.equals(index_unequal),
+            self.index == index_unequal,
+            err_msg = 'MultiIndex compared with Index failed',
+        )
+        assert_array_equal(
+            self.index.equals(index_equal),
+            self.index == index_equal,
+            err_msg = 'MultiIndex compared with Similar Index failed',
+        )
+        assert_array_equal(
+            index_equal.equals(self.index),
+            index_equal == self.index,
+            err_msg = 'Index compared with Similar MultiIndex failed',
+        )
+        # Testing that the result is true for the index_equal case
+        self.assertTrue(
+            (self.index == index_equal).all(),
+            msg='Assert Index compared with Similar MultiIndex match'
+        )
+        self.assertTrue(
+            (index_equal == self.index).all(),
+            msg='Assert MultiIndex compared with Similar Index match'
+        )
+
 
 def test_get_combined_index():
     from pandas.core.index import _get_combined_index

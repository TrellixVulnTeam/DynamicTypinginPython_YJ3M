commit 3b8156ab0f4ebd442251819fda26691e236d44c4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 7 19:29:13 2011 +0200

    i like where this is going

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3d88daeb9..05962677e 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -433,16 +433,16 @@ class DataFrame(PandasGeneric):
             return self._series[item]
         except (TypeError, KeyError):
             if isinstance(item, slice):
-                dateRange = self.index[item]
-                return self.reindex(dateRange)
+                new_index = self.index[item]
+                return self.reindex(new_index)
 
             elif isinstance(item, np.ndarray):
 
                 if len(item) != len(self.index):
                     raise Exception('Item wrong length %d instead of %d!' %
                                     (len(item), len(self.index)))
-                newIndex = self.index[item]
-                return self.reindex(newIndex)
+                new_index = self.index[item]
+                return self.reindex(new_index)
             else:
                 raise
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index bc5000b16..f6ae22660 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -304,7 +304,7 @@ class DataMatrix(DataFrame):
             return DataMatrix(index=self.index, columns=columns,
                               objects=objects)
 
-        indexer, mask = common.get_indexer(self.columns, columns, None)
+        indexer, mask = self.columns.get_indexer(columns)
         mat = self.values.take(indexer, axis=1)
 
         notmask = -mask
diff --git a/pandas/core/proto.py b/pandas/core/proto.py
index a04425c2f..e2817d8e1 100644
--- a/pandas/core/proto.py
+++ b/pandas/core/proto.py
@@ -5,16 +5,23 @@ import numpy as np
 
 from pandas.core.index import Index
 from pandas.core.common import _ensure_index
+from pandas.core.series import Series
+import pandas.core.common as common
 import pandas.lib.tseries as tseries
 
-class _Block(object):
+class Block(object):
+    """
+    Canonical unit of homogeneous dtype contained in DataMatrix
+    """
 
     def __init__(self, values, columns):
-        if values.ndim == 1:
-            values = np.atleast_2d(values).T
+        values = _convert_if_1d(values)
         self.values = values
         self.columns = _ensure_index(columns)
 
+    def __contains__(self, col):
+        return col in self.columns
+
     def __len__(self):
         return len(self.values)
 
@@ -22,10 +29,192 @@ class _Block(object):
     def dtype(self):
         return self.values.dtype
 
+    def merge(self, other):
+        return _merge_blocks([self, other])
+
     def reindex(self, new_columns):
+        indexer, mask = self.columns.get_indexer(columns)
+        new_values = self.values.take(indexer, axis=1)
+
+        notmask = -mask
+        if len(mask) > 0 and notmask.any():
+            if issubclass(mat.dtype.type, np.int_):
+                mat = mat.astype(float)
+            elif issubclass(mat.dtype.type, np.bool_):
+                mat = mat.astype(object)
+
+            common.null_out_axis(mat, notmask, 1)
+
+        return Block(new_values, columns)
+
+    def insert(self, col, value, loc=None):
+        """
+        Insert new column into Block, return new Block
+
+        Returns
+        -------
+        y : Block (new object)
+        """
+        assert(col not in self.columns)
+        if loc is None:
+            loc = len(columns)
+
+        new_columns = _insert_into_columns(self.columns, col, loc)
+        new_values = _insert_into_values(self.values, value, loc)
+
+        return Block(new_values, new_columns)
+
+    def set(self, col, value):
+        """
+        Modify Block in-place with new column value
+
+        Returns
+        -------
+        None
+        """
+        pass
+
+    def delete(self, loc):
+        """
+        Returns
+        -------
+        y : Block (new object)
+        """
+        pass
+
+def _insert_into_columns(columns, col, loc):
+    pass
+
+def _convert_if_1d(values):
+    if values.ndim == 1:
+        values = np.atleast_2d(values).T
+
+    return values
+
+class FloatBlock(Block):
+    pass
+
+class ObjectBlock(Block):
+    pass
+
+def make_block(values, columns):
+    pass
+
+class BlockManager(object):
+    """
+    Manage a bunch of 2D mixed-type ndarrays
+    """
+    def __init__(self, columns, blocks):
+        self.columns = columns
+        self.blocks = blocks
+
+    def _verify_integrity(self):
+        _ = _union_block_columns(self.columns)
+        length = self.block_length
+        for block in self.blocks:
+            assert(len(block) == length)
+
+    @property
+    def block_length(self):
+        return len(self.blocks[0])
+
+    def __len__(self):
+        # number of blocks
+        return len(self.blocks)
+
+    @classmethod
+    def from_blocks(cls, blocks):
+        # also checks for overlap
+        columns = _union_block_columns(blocks)
+
+    def __contains__(self, column):
+        return column in self.columns
+
+    @property
+    def nblocks(self):
+        return len(self.blocks)
+
+    def as_matrix(self, columns=None):
+        if columns is None:
+            if self.nblocks == 0:
+                return self.blocks.values[0]
+            return _interleave(self.blocks, self.columns)
+        else:
+            return _interleave(self.blocks, columns)
+
+    def xs(self, i, copy=True):
+        return np.concatenate([b[i] for b in blocks])
+
+    def consolidate(self):
+        new_blocks = _consolidate(self.blocks)
+        return BlockManager(new_blocks, self.columns)
+
+    def get(self, col):
+        _, block = self._find_block(col)
+        return block.get(col)
+
+    def delete(self, col):
+        i, block = self._find_block(col)
+        new_block = block.delete(col)
+        self.blocks[i] = new_block
+
+    def set(self, col, value):
+        assert(len(value) == self.block_length)
+        if col in self.columns:
+            i, block = self._find_block(col)
+            _needs_other_dtype
+        else:
+            # new block
+            pass
+
+    def _find_block(self, col):
+        self._check_have(col)
+        for i, block in enumerate(self.blocks):
+            if col in block:
+                return i, block
+
+        raise Exception('technically unreachable code')
+
+    def _check_have(self, col):
+        if col not in self.columns:
+            raise KeyError('no column named %s' % col)
+
+    def _chunk_index(self, col):
         pass
 
+def _needs_other_dtype(block, to_insert):
+    pass
+
+def _blocks_to_series_dict(blocks, index=None):
+    series_dict = {}
+
+    if index is None:
+        index = Index(np.arange(len(blocks[0])))
+
+    for block in blocks:
+        for col, vec in zip(block.columns, block.values.T):
+            series_dict[col] = Series(vec, index=index)
+    return series_dict
+
+def _insert_column(blocks, column, value):
+    """
+    Default: new block
+    """
+    pass
+
+def _set_column(blocks, column, value):
+    pass
+
+def _delete_column(blocks, columns):
+    pass
+
+def _reindex_blocks(blocks, old_columns, new_columns):
+    pass
+
 def _interleave(blocks, columns):
+    """
+    Return ndarray from blocks with specified column order
+    """
     dtype = _interleaved_dtype(blocks)
     columns = _ensure_index(columns)
 
@@ -42,25 +231,34 @@ def _interleave(blocks, columns):
 
     return result
 
+def _interleaved_dtype(blocks):
+    for block in blocks:
+        if not issubclass(block.dtype.type, np.floating):
+            return object
+    return np.float64
+
 def _consolidate(blocks):
     """
     Merge blocks having same dtype
     """
     get_dtype = lambda x: x.dtype
+
+    # sort by dtype
     grouper = itertools.groupby(sorted(blocks, key=get_dtype),
                                 lambda x: x.dtype)
 
     new_blocks = []
     for dtype, group_blocks in grouper:
-        group_blocks = list(group_blocks)
-        new_values = np.hstack([b.values for b in group_blocks])
-        new_columns = np.concatenate([b.columns for b in group_blocks])
-        new_blocks.append(_Block(new_values, new_columns))
+        new_block = _merge_blocks(list(group_blocks))
+        new_blocks.append(new_block)
 
     return new_blocks
 
-# def _merge_blocks(blocks):
-#     return np.hstack([b.values for b in blocks])
+def _merge_blocks(blocks):
+    new_values = np.hstack([b.values for b in blocks])
+    new_columns = np.concatenate([b.columns for b in blocks])
+    new_block = Block(new_values, new_columns)
+    return new_block
 
 def _xs(blocks, i, copy=True):
     if copy:
@@ -71,59 +269,16 @@ def _xs(blocks, i, copy=True):
         else:
             raise Exception('cannot get view with mixed-type data')
 
-def _interleaved_dtype(blocks):
-    for block in blocks:
-        if not issubclass(block.dtype.type, np.floating):
-            return object
-    return np.float64
-
-class _MixedTypeData(object):
-
-    def __init__(self, floats, objects, float_cols, object_cols):
-        pass
-
-    def as_matrix(self, columns=None):
-        if columns is None:
-            if self.nblocks == 0:
-                return self.blocks[0]
-
-            return self.hstack(self.blocks)
-        else:
-            pass
-
-class _BlockedData(object):
-
-    def __init__(self, columns, blocks, block_cols):
-
-        self.columns = columns
-        self.blocks = blocks
-        self.block_cols = block_cols
-        self.block_widths = np.asarray([len(cols) for cols in block_cols])
-
-    @property
-    def nblocks(self):
-        return len(self.blocks)
+def _union_block_columns(blocks):
+    seen = Index([])
 
-    def as_matrix(self, columns=None):
-        if columns is None:
-            if self.nblocks == 0:
-                return self.blocks.values[0]
-            return _interleave(self.blocks, self.columns)
-        else:
-            pass
-
-    def xs(self, i, copy=True):
-        return np.concatenate([b[i] for b in blocks])
-
-    def get(self, col):
-        for block in self.blocks:
-            pass
+    for block in blocks:
+        len_before = len(seen)
+        seen = seen.union(block.columns)
+        if len(seen) != len_before + len(block.columns):
+            raise Exception('column names overlap')
 
-    def set(self, key, value):
-        pass
-
-    def _chunk_index(self, col):
-        pass
+    return seen
 
 import unittest
 class TestBlockOperations(unittest.TestCase):
@@ -148,9 +303,11 @@ if __name__ == '__main__':
     columns = Index(sorted(float_cols + object_cols))
     new_columns = Index(['a', 'c', 'e', 'b', 'd'])
 
-    fblock = _Block(floats, float_cols)
-    oblock = _Block(objects, object_cols)
+    fblock = Block(floats, float_cols)
+    oblock = Block(objects, object_cols)
 
     blocks = [fblock, oblock]
 
     interleaved = _interleave(blocks, columns)
+
+    manager = BlockManager(blocks, columns)

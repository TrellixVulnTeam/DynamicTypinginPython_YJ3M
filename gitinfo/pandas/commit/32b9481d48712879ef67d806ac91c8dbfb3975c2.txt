commit 32b9481d48712879ef67d806ac91c8dbfb3975c2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 21 11:58:22 2011 -0400

    mixed-type fixes in DataFrame statistical methods

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 086aa4ab0..3a8f1e5c6 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1270,7 +1270,6 @@ class DataFrame(PandasGeneric):
         if not self:
             return self
 
-        # TODO: deal with objects
         return DataFrame(func(self.values, other), index=self.index,
                          columns=self.columns, copy=False)
 
@@ -1904,7 +1903,7 @@ class DataFrame(PandasGeneric):
     #----------------------------------------------------------------------
     # ndarray-like stats methods
 
-    def count(self, axis=0):
+    def count(self, axis=0, numeric_only=False):
         """
         Return array or Series of # observations over requested axis.
 
@@ -1912,6 +1911,8 @@ class DataFrame(PandasGeneric):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        numeric_only : boolean, default False
+            Include only float, int, boolean data
 
         Notes
         -----
@@ -1922,16 +1923,9 @@ class DataFrame(PandasGeneric):
         Series or TimeSeries
         """
         try:
-            cols = self.columns
-            values = self.as_matrix(cols)
-
-            if axis == 0:
-                axis_labels = cols
-            else:
-                axis_labels = self.index
-
-            mask = np.empty(values.shape, dtype=bool)
-            mask.flat = notnull(values.ravel())
+            y, axis_labels = self._get_agg_data(axis, numeric_only=numeric_only)
+            mask = np.empty(y.shape, dtype=bool)
+            mask.flat = notnull(y.ravel())
             return Series(mask.sum(axis), index=axis_labels)
         except Exception:
             f = lambda s: notnull(s).sum()
@@ -1945,6 +1939,8 @@ class DataFrame(PandasGeneric):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        numeric_only : boolean, default False
+            Include only float, int, boolean data
 
         Returns
         -------
@@ -1963,14 +1959,7 @@ class DataFrame(PandasGeneric):
         c1    4
         c2    6
         """
-        num_cols = self._get_numeric_columns()
-
-        if len(num_cols) < len(self.columns) and numeric_only:
-            y = self.as_matrix(num_cols)
-            axis_labels = num_cols
-        else:
-            y = self.values.copy()
-            axis_labels = self._get_agg_axis(axis)
+        y, axis_labels = self._get_agg_data(axis, numeric_only=numeric_only)
 
         if len(axis_labels) == 0:
             return Series([], index=[])
@@ -1987,21 +1976,6 @@ class DataFrame(PandasGeneric):
 
         return Series(the_sum, index=axis_labels)
 
-    def _get_agg_axis(self, axis_num):
-        if axis_num == 0:
-            return self.columns
-        elif axis_num == 1:
-            return self.index
-        else:
-            raise Exception('Must have 0<= axis <= 1')
-
-    def _get_numeric_columns(self):
-        return [col for col in self.columns
-                if issubclass(self[col].dtype.type, np.number)]
-
-    def _get_object_columns(self):
-        return [col for col in self.columns if self[col].dtype == np.object_]
-
     def cumsum(self, axis=0):
         """
         Return DataFrame of cumulative sums over requested axis.
@@ -2120,12 +2094,15 @@ class DataFrame(PandasGeneric):
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
 
+        Notes
+        -----
+
         Returns
         -------
         Series or TimeSeries
         """
         summed = self.sum(axis, numeric_only=True)
-        count = self.count(axis).astype(float)
+        count = self.count(axis, numeric_only=True).astype(float)
 
         if not count.index.equals(summed.index):
             count = count.reindex(summed.index)
@@ -2234,7 +2211,8 @@ class DataFrame(PandasGeneric):
         -------
         Series or TimeSeries
         """
-        y = np.asarray(self.values)
+        y, axis_labels = self._get_agg_data(axis, numeric_only=True)
+
         mask = np.isnan(y)
         count = (y.shape[axis] - mask.sum(axis)).astype(float)
         y[mask] = 0
@@ -2244,7 +2222,7 @@ class DataFrame(PandasGeneric):
 
         theVar = (XX - X**2 / count) / (count - 1)
 
-        return Series(theVar, index=self._get_agg_axis(axis))
+        return Series(theVar, index=axis_labels)
 
     def std(self, axis=0):
         """
@@ -2287,6 +2265,39 @@ class DataFrame(PandasGeneric):
 
         return Series(theSkew, index=self._get_agg_axis(axis))
 
+    def _get_agg_data(self, axis, numeric_only=True):
+        num_cols = self._get_numeric_columns()
+
+        if len(num_cols) < len(self.columns) and numeric_only:
+            y = self.as_matrix(num_cols)
+            if axis == 0:
+                axis_labels = num_cols
+            else:
+                axis_labels = self.index
+        else:
+            y = self.values.copy()
+            axis_labels = self._get_agg_axis(axis)
+
+        return y, axis_labels
+
+    def _get_agg_axis(self, axis_num):
+        if axis_num == 0:
+            return self.columns
+        elif axis_num == 1:
+            return self.index
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    def _get_numeric_columns(self):
+        from pandas.core.internals import ObjectBlock
+
+        cols = []
+        for col, blk in zip(self.columns, self._data.block_id_vector):
+            if not isinstance(self._data.blocks[blk], ObjectBlock):
+                cols.append(col)
+
+        return cols
+
     def clip(self, upper=None, lower=None):
         """
         Trim values at input threshold(s)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index bd481eab0..6fbcc0e79 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -44,10 +44,10 @@ class Block(object):
         self.ref_columns = ref_columns
 
     def __repr__(self):
-        x, y = self.shape
+        shape = ' x '.join([str(s) for s in self.shape])
         name = type(self).__name__
-        return '%s: %s, %d x %d, dtype %s' % (name, self.columns,
-                                              x, y, self.dtype)
+        return '%s: %s, %s, dtype %s' % (name, self.columns,
+                                         shape, self.dtype)
 
     def __contains__(self, col):
         return col in self.columns
@@ -58,8 +58,7 @@ class Block(object):
     def __getstate__(self):
         # should not pickle generally (want to share ref_columns), but here for
         # completeness
-        return (np.asarray(self.columns),
-                np.asarray(self.ref_columns),
+        return (np.asarray(self.columns), np.asarray(self.ref_columns),
                 self.values)
 
     def __setstate__(self, state):
@@ -335,17 +334,20 @@ class BlockManager(object):
         return BlockManager(copy_blocks, self.index, self.columns)
 
     def as_matrix(self, columns=None):
-        if columns is None:
-            columns = self.columns
-
         if len(self.blocks) == 0:
-            return np.empty((len(self.index), 0), dtype=float)
+            mat = np.empty((len(self.index), 0), dtype=float)
         elif len(self.blocks) == 1:
             blk = self.blocks[0]
-            if blk.columns.equals(columns):
+            if columns is None or blk.columns.equals(columns):
                 # if not, then just call interleave per below
-                return blk.values
-        return _interleave(self.blocks, columns)
+                mat = blk.values
+        else:
+            if columns is None:
+                mat = _interleave(self.blocks, self.columns)
+            else:
+                mat = self.reindex_columns(columns).as_matrix()
+
+        return mat
 
     def xs(self, i, copy=True):
         # TODO: fix this mess
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 674b56da5..aef903340 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -619,6 +619,10 @@ class SparseDataFrame(DataFrame):
         self.columns = columns
         self.index = index
 
+    def _get_numeric_columns(self):
+        # everything is necessarily float64
+        return self.columns
+
     def _consolidate_inplace(self):
         # do nothing when DataFrame calls this method
         pass
@@ -1029,7 +1033,7 @@ class SparseDataFrame(DataFrame):
                                default_kind=self.default_kind)
     T = property(transpose)
 
-    def count(self, axis=0):
+    def count(self, axis=0, **kwds):
         """
         Return array or Series of # observations over requested axis.
 
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 7b56218bb..6b5d575ed 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1791,7 +1791,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
                          'e' : [3.14, 0.577, 2.773]})
 
         self.assertEquals(df._get_numeric_columns(), ['a', 'e'])
-        self.assertEquals(df._get_object_columns(), ['c', 'd'])
+        # self.assertEquals(df._get_object_columns(), ['c', 'd'])
 
     def test_statistics(self):
         # unnecessary?
@@ -1860,6 +1860,16 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(the_sum.index.equals(the_mean.index))
         self.assert_(len(the_mean.index) < len(self.mixed_frame.columns))
 
+        # xs sum mixed type, just want to know it works...
+        the_mean = self.mixed_frame.mean(axis=1)
+        the_sum = self.mixed_frame.sum(axis=1, numeric_only=True)
+        self.assert_(the_sum.index.equals(the_mean.index))
+
+        # take mean of boolean column
+        self.frame['bool'] = self.frame['A'] > 0
+        means = self.frame.mean(0)
+        self.assertEqual(means['bool'], self.frame['bool'].values.mean())
+
     def test_median(self):
         def f(x):
             x = np.asarray(x)
@@ -2041,6 +2051,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
     #----------------------------------------------------------------------
     # Tests to cope with refactored internals
 
+    def test_as_matrix_numeric_cols(self):
+        self.frame['foo'] = 'bar'
+
+        values = self.frame.as_matrix(['A', 'B', 'C', 'D'])
+        self.assert_(values.dtype == np.float64)
+
     def test_constructor_frame_copy(self):
         cop = DataFrame(self.frame, copy=True)
         cop['A'] = 5

commit a609574deeb3ceb63c685d75dc4bb3575964fa72
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Dec 27 17:08:36 2011 -0500

    ENH: more refactoring for LongPanel removal, Index._join_level method, DataFrame.reindex_axis, #108

diff --git a/TODO.rst b/TODO.rst
index 55546e3cb..da4c480fb 100644
--- a/TODO.rst
+++ b/TODO.rst
@@ -1,3 +1,11 @@
+LongPanel removal
+=================
+
+- level to flex methods
+- level to reindex
+- fast take for items
+
+
 DONE
 ----
 - SparseSeries name integration + tests
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ee846711b..a1f122092 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1295,12 +1295,13 @@ class DataFrame(NDFrame):
         if axis is None or axis == 0:
             if not self.index.equals(other.index):
                 join_index, ilidx, iridx = \
-                    self.index.join(other.index, how=join, return_indexers=True)
+                    self.index.join(other.index, how=join, level=level,
+                                    return_indexers=True)
 
         if axis is None or axis == 1:
             if not self.columns.equals(other.columns):
                 join_columns, clidx, cridx = \
-                    self.columns.join(other.columns, how=join,
+                    self.columns.join(other.columns, how=join, level=level,
                                       return_indexers=True)
 
         def _align(frame, row_idx, col_idx):
@@ -1310,7 +1311,8 @@ class DataFrame(NDFrame):
 
             if col_idx is not None:
                 # TODO: speed up on homogeneous DataFrame objects
-                new_data = new_data.reindex_items(join_columns)
+                new_data = new_data.reindex_indexer(join_columns, col_idx,
+                                                    axis=0)
 
             if copy and new_data is frame._data:
                 new_data = new_data.copy()
@@ -1321,6 +1323,15 @@ class DataFrame(NDFrame):
         right = _align(other, iridx, cridx)
         return left, right
 
+    def _align_level(self, multi_index, level, axis=0, copy=True):
+        levnum = multi_index._get_level_number(level)
+        data = self.reindex_axis(multi_index.levels[levnum], axis=axis,
+                                 copy=False)._data
+        mgr_axis = 0 if axis == 1 else 1
+        new_data = data.reindex_indexer(multi_index, multi_index.labels[levnum],
+                                        axis=mgr_axis)
+        return DataFrame(new_data)
+
     def _align_series(self, other, join='outer', axis=None, level=None,
                       copy=True):
         fdata = self._data
@@ -1337,11 +1348,12 @@ class DataFrame(NDFrame):
             join_index = self.columns
             lidx, ridx = None, None
             if not self.columns.equals(other.index):
-                join_index, lidx, ridx = self.columns.join(other.index, how=join,
-                                                           return_indexers=True)
+                join_index, lidx, ridx = \
+                    self.columns.join(other.index, how=join,
+                                      return_indexers=True)
 
             if lidx is not None:
-                fdata = fdata.reindex_items(join_index)
+                fdata = fdata.reindex_indexer(join_index, lidx, axis=0)
         else:
             raise ValueError('Must specify axis=0 or 1')
 
@@ -1354,7 +1366,7 @@ class DataFrame(NDFrame):
 
     def reindex(self, index=None, columns=None, method=None, level=None,
                 copy=True):
-        """Conform Series to new index with optional filling logic, placing
+        """Conform DataFrame to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
         copy=False
@@ -1385,33 +1397,65 @@ class DataFrame(NDFrame):
         frame = self
 
         if index is not None:
-            index = _ensure_index(index)
             frame = frame._reindex_index(index, method, copy, level)
 
         if columns is not None:
-            columns = _ensure_index(columns)
             frame = frame._reindex_columns(columns, copy, level)
 
         return frame
 
+    def reindex_axis(self, labels, axis=0, method=None, level=None, copy=True):
+        """Conform DataFrame to new index with optional filling logic, placing
+        NA/NaN in locations having no value in the previous index. A new object
+        is produced unless the new index is equivalent to the current one and
+        copy=False
+
+        Parameters
+        ----------
+        index : array-like, optional
+            New labels / index to conform to. Preferably an Index object to
+            avoid duplicating data
+        axis : {0, 1}
+            0 -> index (rows)
+            1 -> columns
+        method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None
+            Method to use for filling holes in reindexed DataFrame
+            pad / ffill: propagate last valid observation forward to next valid
+            backfill / bfill: use NEXT valid observation to fill gap
+        copy : boolean, default True
+            Return a new object, even if the passed indexes are the same
+
+        Examples
+        --------
+        >>> df.reindex(['A', 'B', 'C'], axis=1)
+
+        See also
+        --------
+        DataFrame.reindex, DataFrame.reindex_like
+
+        Returns
+        -------
+        reindexed : same type as calling instance
+        """
+        self._consolidate_inplace()
+        if axis == 0:
+            return self._reindex_index(labels, method, copy, level)
+        elif axis == 1:
+            return self._reindex_columns(labels, copy, level)
+        else:  # pragma: no cover
+            raise ValueError('Must specify axis=0 or 1')
+
     def _reindex_index(self, new_index, method, copy, level):
-        if new_index.equals(self.index):
-            if copy:
-                result = self.copy()
-                result.index = new_index
-                return result
-            else:
-                return self
-        new_data = self._data.reindex_axis(new_index, method, axis=1)
+        if level is not None:
+            return self._align_level(new_index, level, axis=0, copy=copy)
+        new_data = self._data.reindex_axis(new_index, method, axis=1,
+                                           copy=copy)
         return self._constructor(new_data)
 
-    def _reindex_columns(self, new_columns, copy):
-        if new_columns.equals(self.columns):
-            if copy:
-                return self.copy()
-            else:
-                return self
-        new_data = self._data.reindex_axis(new_columns, axis=0)
+    def _reindex_columns(self, new_columns, copy, level):
+        if level is not None:
+            return self._align_level(new_columns, level, axis=1, copy=copy)
+        new_data = self._data.reindex_axis(new_columns, axis=0, copy=copy)
         return self._constructor(new_data)
 
     def reindex_like(self, other, method=None, copy=True):
@@ -1948,7 +1992,8 @@ class DataFrame(NDFrame):
         same_columns = self.columns.equals(other.columns)
         return same_index and same_columns
 
-    def _combine_series(self, other, func, fill_value=None, axis=None):
+    def _combine_series(self, other, func, fill_value=None, axis=None,
+                        level=None):
         if axis is not None:
             axis = self._get_axis_name(axis)
             if axis == 'index':
@@ -3659,16 +3704,6 @@ def _is_sequence(x):
     except Exception:
         return False
 
-def _align_level(frame, multi_index, level, axis=0):
-    levnum = multi_index._get_level_number(level)
-
-    data = frame.reindex(multi_index.levels[levnum], copy=False)._data
-
-    mgr_axis = 0 if axis == 1 else 1
-    new_data = data.reindex_indexer(multi_index, multi_index.labels[levnum],
-                                    axis=mgr_axis)
-    return DataFrame(new_data)
-
 def install_ipython_completers():  # pragma: no cover
     """Register the DataFrame type with IPython's tab completion machinery, so
     that it knows about accessing column names as attributes."""
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index cb06553c6..5fbb73a69 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -370,17 +370,13 @@ class NDFrame(PandasObject):
         return len(self._data.blocks) > 1
 
     def _reindex_axis(self, new_index, fill_method, axis, copy):
-        new_index = _ensure_index(new_index)
-        cur_axis = self._data.axes[axis]
-        if cur_axis.equals(new_index) and not copy:
-            return self
+        new_data = self._data.reindex_axis(new_index, axis=axis,
+                                           method=fill_method, copy=copy)
 
-        if axis == 0:
-            new_data = self._data.reindex_items(new_index)
+        if new_data is self._data and not copy:
+            return self
         else:
-            new_data = self._data.reindex_axis(new_index, axis=axis,
-                                               method=fill_method)
-        return self._constructor(new_data)
+            return self._constructor(new_data)
 
     def cumsum(self, axis=None, skipna=True):
         """
@@ -586,7 +582,7 @@ class NDFrame(PandasObject):
         if axis == 0:
             labels = self._get_axis(axis)
             new_items = labels.take(indices)
-            new_data = self._data.reindex_items(new_items)
+            new_data = self._data.reindex_axis(new_items, axis=0)
         else:
             new_data = self._data.take(indices, axis=axis)
         return self._constructor(new_data)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 0f0230a7f..10a92287b 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -559,11 +559,32 @@ class Index(np.ndarray):
         indexer = self.get_indexer(target, method=method)
         return target, indexer
 
-    def join(self, other, how='left', return_indexers=False):
+    def join(self, other, how='left', level=None, return_indexers=False):
+        """
+        Internal API method. Compute join_index and indexers to conform data
+        structures to the new index.
+
+        Parameters
+        ----------
+        other : Index
+        how : {'left', 'right', 'inner', 'outer'}
+        level :
+        return_indexers : boolean, default False
+
+        Returns
+        -------
+        join_index, (left_indexer, right_indexer)
+        """
+        if (level is not None and (isinstance(self, MultiIndex) or
+                                   isinstance(other, MultiIndex))):
+            return self._join_level(other, level, how=how,
+                                    return_indexers=return_indexers)
+
         if self.dtype != other.dtype:
             this = self.astype('O')
             other = other.astype('O')
-            return this.join(other, how=how, return_indexers=return_indexers)
+            return this.join(other, how=how,
+                             return_indexers=return_indexers)
 
         if self.is_monotonic and other.is_monotonic:
             return self._join_monotonic(other, how=how,
@@ -593,6 +614,61 @@ class Index(np.ndarray):
         else:
             return join_index
 
+    def _join_level(self, other, level, how='left', return_indexers=False):
+        """
+        The join method *only* affects the level of the resulting
+        MultiIndex. Otherwise it just exactly aligns the Index data to the
+        labels of the level in the MultiIndex. The order of the data indexed by
+        the MultiIndex will not be changed (currently)
+        """
+
+        if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):
+            raise Exception('Join on level between two MultiIndex objects '
+                            'is ambiguous')
+
+        left, right = self, other
+
+        flip_order = not isinstance(self, MultiIndex)
+        if flip_order:
+            left, right = right, left
+
+        level = left._get_level_number(level)
+
+        old_level = left.levels[level]
+
+        new_level, left_lev_indexer, right_lev_indexer = \
+            old_level.join(right, how=how, return_indexers=True)
+
+        if left_lev_indexer is not None:
+            rev_indexer = lib.get_reverse_indexer(left_lev_indexer,
+                                                  len(old_level))
+
+            new_labels = list(left.labels)
+            new_labels[level] = rev_indexer.take(left.labels[level])
+
+            new_levels = list(left.levels)
+            new_levels[level] = new_level
+
+            join_index = MultiIndex(levels=new_levels, labels=new_labels,
+                                    names=left.names)
+        else:
+            join_index = left
+
+        left_indexer = None
+
+        if right_lev_indexer is not None:
+            right_indexer = right_lev_indexer.take(join_index.labels[level])
+        else:
+            right_indexer = join_index.labels[level]
+
+        if flip_order:
+            left_indexer, right_indexer = right_indexer, left_indexer
+
+        if return_indexers:
+            return join_index, left_indexer, right_indexer
+        else:
+            return join_index
+
     def _join_monotonic(self, other, how='left', return_indexers=False):
         if how == 'left':
             join_index = self
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index ac6c06e92..f99d08781 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -392,7 +392,7 @@ class BlockManager(object):
                                   new_items)
                 new_blocks = [newb]
             else:
-                return self.reindex_items(new_items)
+                return self._reindex_items(new_items)
         else:
             new_blocks = self._slice_blocks(slobj, axis)
 
@@ -443,7 +443,7 @@ class BlockManager(object):
         """
         copy_blocks = [block.copy(deep=deep) for block in self.blocks]
         # copy_axes = [ax.copy() for ax in self.axes]
-        copy_axes = self.axes
+        copy_axes = list(self.axes)
         return BlockManager(copy_blocks, copy_axes)
 
     def as_matrix(self, items=None):
@@ -455,12 +455,12 @@ class BlockManager(object):
                 # if not, then just call interleave per below
                 mat = blk.values
             else:
-                mat = self.reindex_items(items).as_matrix()
+                mat = self._reindex_items(items).as_matrix()
         else:
             if items is None:
                 mat = self._interleave(self.items)
             else:
-                mat = self.reindex_items(items).as_matrix()
+                mat = self._reindex_items(items).as_matrix()
 
         return mat
 
@@ -644,15 +644,32 @@ class BlockManager(object):
         if item not in self.items:
             raise KeyError('no item named %s' % str(item))
 
-    def reindex_axis(self, new_axis, method=None, axis=0):
-        if axis == 0:
-            assert(method is None)
-            return self.reindex_items(new_axis)
-
+    def reindex_axis(self, new_axis, method=None, axis=0, copy=True):
         new_axis = _ensure_index(new_axis)
         cur_axis = self.axes[axis]
 
+        if new_axis.equals(cur_axis):
+            if copy:
+                result = self.copy(deep=True)
+                result.axes[axis] = new_axis
+                return result
+            else:
+                return self
+
+        if axis == 0:
+            assert(method is None)
+            return self._reindex_items(new_axis)
+
         new_axis, indexer = cur_axis.reindex(new_axis, method)
+        return self.reindex_indexer(new_axis, indexer, axis=axis)
+
+    def reindex_indexer(self, new_axis, indexer, axis=1):
+        """
+        pandas-indexer with -1's only
+        """
+        if axis == 0:
+            return self._reindex_indexer_items(new_axis, indexer)
+
         mask = indexer == -1
 
         # TODO: deal with length-0 case? or does it fall out?
@@ -668,36 +685,36 @@ class BlockManager(object):
         new_axes[axis] = new_axis
         return BlockManager(new_blocks, new_axes)
 
-    def reindex_indexer(self, new_axis, indexer, axis=1):
-        """
-        pandas-indexer with -1's only
-        """
-        if axis == 0:
-            raise NotImplementedError
-
-        new_axes = list(self.axes)
-        new_axes[axis] = new_axis
-        new_blocks = []
-        for blk in self.blocks:
-            new_values = com.take_fast(blk.values, indexer, None,
-                                       False, axis=axis)
-            newb = make_block(new_values, blk.items, self.items)
-            new_blocks.append(newb)
-
-        return BlockManager(new_blocks, new_axes)
+    def _reindex_indexer_items(self, new_items, indexer):
+        # TODO: less efficient than I'd like
 
-    def _reindex_indexer_items(new_axis, indexer):
-        from collections import defaultdict
+        item_order = com.take_1d(self.items.values, indexer)
 
-        dtypes = self.item_dtypes
-        result_dtypes = dtypes.take(indexer)
-        counts = defaultdict(int)
-        for t in result_dtypes:
-            counts[t] += 1
+        # keep track of what items aren't found anywhere
+        mask = np.zeros(len(item_order), dtype=bool)
 
+        new_blocks = []
+        for blk in self.blocks:
+            blk_indexer = blk.items.get_indexer(item_order)
+            selector = blk_indexer != -1
+            # update with observed items
+            mask |= selector
+
+            new_block_items = new_items.take(selector.nonzero()[0])
+            new_values = com.take_fast(blk.values, blk_indexer[selector],
+                                       None, False, axis=0)
+            new_blocks.append(make_block(new_values, new_block_items,
+                                         new_items))
+
+        if not mask.all():
+            na_items = new_items[-mask]
+            na_block = self._make_na_block(na_items, new_items)
+            new_blocks.append(na_block)
+            new_blocks = _consolidate(new_blocks, new_items)
 
+        return BlockManager(new_blocks, [new_items] + self.axes[1:])
 
-    def reindex_items(self, new_items):
+    def _reindex_items(self, new_items):
         """
 
         """
@@ -705,7 +722,7 @@ class BlockManager(object):
         data = self
         if not data.is_consolidated():
             data = data.consolidate()
-            return data.reindex_items(new_items)
+            return data._reindex_items(new_items)
 
         # TODO: this part could be faster (!)
         new_items, indexer = self.items.reindex(new_items)
@@ -719,20 +736,20 @@ class BlockManager(object):
 
         if mask.any():
             extra_items = new_items[mask]
-
-            block_shape = list(self.shape)
-            block_shape[0] = len(extra_items)
-            block_values = np.empty(block_shape, dtype=np.float64)
-            block_values.fill(nan)
-            na_block = make_block(block_values, extra_items, new_items,
-                                  do_integrity_check=True)
+            na_block = self._make_na_block(extra_items, new_items)
             new_blocks.append(na_block)
             new_blocks = _consolidate(new_blocks, new_items)
 
-        new_axes = list(self.axes)
-        new_axes[0] = new_items
+        return BlockManager(new_blocks, [new_items] + self.axes[1:])
 
-        return BlockManager(new_blocks, new_axes)
+    def _make_na_block(self, items, ref_items):
+        block_shape = list(self.shape)
+        block_shape[0] = len(items)
+        block_values = np.empty(block_shape, dtype=np.float64)
+        block_values.fill(nan)
+        na_block = make_block(block_values, items, ref_items,
+                              do_integrity_check=True)
+        return na_block
 
     def take(self, indexer, axis=1):
         if axis == 0:
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 64fd952df..c6d392a27 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1158,22 +1158,12 @@ class Panel(NDFrame):
         return join_major, join_minor
 
 WidePanel = Panel
-
-#-------------------------------------------------------------------------------
-# LongPanel and friends
-
+LongPanel = DataFrame
 
 def panel_is_consistent(panel):
     offset = max(len(panel.major_axis), len(panel.minor_axis))
-
-    major_labels = panel.major_labels
-    minor_labels = panel.minor_labels
-
-    # overflow risk
-    if (offset + 1) ** 2 > 2**32:  # pragma: no cover
-        major_labels = major_labels.astype(np.int64)
-        minor_labels = minor_labels.astype(np.int64)
-
+    major_labels = panel.major_labels.astype('i8')
+    minor_labels = panel.minor_labels.astype('i8')
     keys = major_labels * offset + minor_labels
     unique_keys = np.unique(keys)
 
@@ -1227,27 +1217,6 @@ def _to_wide_mixed(lp, mask):
 def _wide_shape(lp):
     return (len(lp.columns), len(lp.index.levels[0]), len(lp.index.levels[1]))
 
-def panel_from_records(data, major_field, minor_field, exclude=None):
-    """
-    Create LongPanel from DataFrame or record / structured ndarray
-    object
-
-    Parameters
-    ----------
-    data : DataFrame, structured or record array, or dict
-    major_field : string
-    minor_field : string
-        Name of field
-    exclude : list-like, default None
-
-    Returns
-    -------
-    LongPanel
-    """
-    return DataFrame.from_records(data, [major_field, minor_field],
-                                  exclude=exclude)
-
-
 def long_swapaxes(frame):
     """
     Swap major and minor axes and reorder values to be grouped by
@@ -1357,29 +1326,6 @@ def make_axis_dummies(frame, axis='minor'):
 
     return DataFrame(values, columns=items, index=frame.index)
 
-
-class LongPanel(DataFrame):
-    """
-    Represents long or "stacked" format panel data
-
-    Parameters
-    ----------
-    values : ndarray (N x K)
-    items : sequence
-    index : MultiIndex
-
-    Note
-    ----
-    LongPanel will likely disappear in a future release in favor of just using
-    DataFrame objects with hierarchical indexes. You should be careful about
-    writing production code depending on LongPanel
-    """
-
-    @property
-    def items(self):
-        return self.columns
-
-
 def _prep_ndarray(values, copy=True):
     if not isinstance(values, np.ndarray):
         values = np.asarray(values)
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index a168e516a..0873fe2eb 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -13,7 +13,6 @@ from pandas.core.index import Index, MultiIndex, NULL_INDEX, _ensure_index
 from pandas.core.series import Series
 from pandas.core.frame import (DataFrame, extract_index, _prep_ndarray,
                                _default_index)
-from pandas.core.panel import LongPanel
 import pandas.core.datetools as datetools
 
 from pandas.sparse.series import SparseSeries
@@ -682,7 +681,7 @@ def stack_sparse_frame(frame):
     index = MultiIndex(levels=[frame.index, frame.columns],
                        labels=[major_labels, minor_labels])
 
-    lp = LongPanel(stacked_values.reshape((nobs, 1)), index=index,
+    lp = DataFrame(stacked_values.reshape((nobs, 1)), index=index,
                    columns=['foo'])
     return lp.sortlevel(level=0)
 
diff --git a/pandas/src/internals.pyx b/pandas/src/internals.pyx
index d8a262398..ebf47b9e3 100644
--- a/pandas/src/internals.pyx
+++ b/pandas/src/internals.pyx
@@ -1,11 +1,11 @@
 def get_reverse_indexer(ndarray[int32_t] indexer, Py_ssize_t length):
     cdef:
-        Py_ssize_t i
+        Py_ssize_t i, n = len(indexer)
         ndarray[int32_t] rev_indexer
         int32_t idx
 
     rev_indexer = np.empty(length, dtype='i4')
-    for i in range(len(indexer)):
+    for i in range(n):
         idx = indexer[i]
         if idx != -1:
             rev_indexer[idx] = i
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index dd7a1d251..4875215d7 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -499,3 +499,4 @@ include "reduce.pyx"
 include "stats.pyx"
 include "properties.pyx"
 include "inference.pyx"
+include "internals.pyx"
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 7b4a46747..94e21a496 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -79,7 +79,7 @@ class PanelOLS(OLS):
             x_filtered = x_filtered.filter(x_filtered.items - self._x_effects)
 
         if self._time_effects:
-            x_regressor = x.subtract(x.mean('minor', broadcast=True))
+            x_regressor = x.sub(x.mean(level=1), level=1)
 
             unstacked_y = y.unstack()
             y_regressor = unstacked_y.sub(unstacked_y.mean(1), axis=0).stack()
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index c87428264..46a0d9a7e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2620,7 +2620,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         # pivot multiple columns
         wp = tm.makePanel()
         lp = wp.to_long()
-        df = DataFrame.from_records(lp.toRecords())
+        df = lp.reset_index()
         assert_frame_equal(df.pivot('major', 'minor'), lp.unstack())
 
     def test_pivot_duplicates(self):
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 7e304d797..374a82ad3 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -1168,6 +1168,31 @@ class TestMultiIndex(unittest.TestCase):
         taken = self.index.take([3,0,1])
         self.assertEqual(taken.names, self.index.names)
 
+    def test_join_level(self):
+        other = Index(['three', 'one', 'two'])
+
+        def _check_how(how):
+            join_index, lidx, ridx = other.join(self.index, how=how,
+                                                level='second',
+                                                return_indexers=True)
+
+            join_index2, ridx2, lidx2 = self.index.join(other, how=how,
+                                                        level='second',
+                                                        return_indexers=True)
+
+            self.assert_(join_index.equals(join_index2))
+            self.assert_(np.array_equal(lidx, lidx2))
+            self.assert_(np.array_equal(ridx, ridx2))
+
+            exp_level = self.index.levels[1].join(other, how=how)
+            self.assert_(join_index.levels[0].equals(self.index.levels[0]))
+            self.assert_(join_index.levels[1].equals(exp_level))
+
+        _check_how('outer')
+        _check_how('inner')
+        _check_how('left')
+        _check_how('right')
+
 class TestFactor(unittest.TestCase):
 
     def setUp(self):
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 2eac32fd6..b87067522 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -55,7 +55,31 @@ class TestMultiLevel(unittest.TestCase):
         tm.assert_series_equal(result, self.frame['A'])
 
     def test_align_level(self):
-        pass
+        # axis=0
+        month_sums = self.ymd.sum(level='month')
+        result = month_sums.reindex(self.ymd.index, level=1)
+        expected = self.ymd.groupby(level='month').transform(np.sum)
+
+        assert_frame_equal(result, expected)
+
+        # axis=1
+        month_sums = self.ymd.T.sum(axis=1, level='month')
+        result = month_sums.reindex(columns=self.ymd.index, level=1)
+        expected = self.ymd.groupby(level='month').transform(np.sum).T
+        assert_frame_equal(result, expected)
+
+    def test_binops_level(self):
+        def _check_op(opname):
+            op = getattr(DataFrame, opname)
+            result = op(self.ymd, self.ymd.sum(level='month'), level='month')
+            broadcasted = self.ymd.groupby(level='month').transform(np.sum)
+            expected = op(self.ymd, broadcasted)
+            assert_frame_equal(result, expected)
+
+        _check_op('sub')
+        _check_op('add')
+        _check_op('mul')
+        _check_op('div')
 
     def test_pickle(self):
         import cPickle
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index db38e93c4..59297a132 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -201,6 +201,11 @@ def test_rank():
     _check(np.array([nan, nan, 5., 5., 5., nan, 1, 2, 3, nan]))
     _check(np.array([4., nan, 5., 5., 5., nan, 1, 2, 4., nan]))
 
+def test_get_reverse_indexer():
+    indexer = np.array([-1, -1, 1, 2, 0, -1, 3, 4], dtype='i4')
+    result = lib.get_reverse_indexer(indexer, 5)
+    expected = np.array([4, 2, 3, 6, 7], dtype='i4')
+    assert(np.array_equal(result, expected))
 
 class TestMoments(unittest.TestCase):
     pass

commit d8626fb9354aff400aa1e28bdb388b1926dc5fee
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jun 20 01:02:54 2012 -0400

    BUG: test coverage and misc bug fixes, cruft deletion in period.py #1245

diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 3f1cb2860..1d2c7ea18 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -14,6 +14,7 @@ import pandas.core.common as com
 from pandas.lib import Timestamp
 import pandas.lib as lib
 import pandas._period as plib
+import pandas._algos as _algos
 
 
 #---------------
@@ -157,7 +158,8 @@ class Period(object):
     def __add__(self, other):
         if com.is_integer(other):
             return Period(ordinal=self.ordinal + other, freq=self.freq)
-        raise ValueError("Cannot add with non-integer value")
+        else:  # pragma: no cover
+            raise TypeError(other)
 
     def __sub__(self, other):
         if com.is_integer(other):
@@ -167,7 +169,8 @@ class Period(object):
                 raise ValueError("Cannot do arithmetic with "
                                  "non-conforming periods")
             return self.ordinal - other.ordinal
-        raise ValueError("Cannot sub with non-integer value")
+        else:  # pragma: no cover
+            raise TypeError(other)
 
     def asfreq(self, freq=None, how='E'):
         """
@@ -188,9 +191,6 @@ class Period(object):
         if mult2 != 1:
             raise ValueError('Only mult == 1 supported')
 
-        if how not in ('S', 'E'):
-            raise ValueError('relation argument must be one of S or E')
-
         end = how == 'E'
         new_ordinal = plib.period_asfreq(self.ordinal, base1, base2, end)
 
@@ -441,18 +441,10 @@ def _period_unbox(key, check=None):
     return np.int64(key.ordinal)
 
 def _period_unbox_array(arr, check=None):
-    if arr is None:
-        return arr
     unboxer = np.frompyfunc(lambda x: _period_unbox(x, check=check), 1, 1)
     return unboxer(arr)
 
 def _period_box_array(arr, freq):
-    if arr is None:
-        return arr
-
-    if not isinstance(arr, np.ndarray):
-        return arr
-
     boxfunc = lambda x: Period(ordinal=x, freq=freq)
     boxer = np.frompyfunc(boxfunc, 1, 1)
     return boxer(arr)
@@ -461,14 +453,7 @@ def dt64arr_to_periodarr(data, freq):
     if data.dtype != np.dtype('M8[ns]'):
         raise ValueError('Wrong dtype: %s' % data.dtype)
 
-    if data is None:
-        return data
-
-    if isinstance(freq, basestring):
-        base, mult = _gfc(freq)
-    else:
-        base, mult = freq
-
+    base, mult = _gfc(freq)
     return plib.dt64arr_to_periodarr(data.view('i8'), base)
 
 # --- Period index sketch
@@ -490,12 +475,11 @@ def _period_index_cmp(opname):
             other = Period(other, freq=self.freq)
             func = getattr(self.values, opname)
             result = func(other.ordinal)
-        try:
-            return result.view(np.ndarray)
-        except:
-            return result
+
+        return result
     return wrapper
 
+_INT64_DTYPE = np.dtype(np.int64)
 
 class PeriodIndex(Int64Index):
     """
@@ -560,10 +544,7 @@ class PeriodIndex(Int64Index):
                 year=None, month=None, quarter=None, day=None,
                 hour=None, minute=None, second=None):
 
-        if isinstance(freq, Period):
-            freq = freq.freq
-        else:
-            freq = _freq_mod.get_standard_freq(freq)
+        freq = _freq_mod.get_standard_freq(freq)
 
         if periods is not None:
             if com.is_float(periods):
@@ -598,9 +579,9 @@ class PeriodIndex(Int64Index):
                                  'or endpoints, but not both')
             subarr, freq = _get_ordinal_range(start, end, periods, freq)
         elif field_count > 0:
-            y, m, q, d, h, m, s = fields
-            subarr, freq = _range_from_fields(year=y, month=m, quarter=q,
-                                              day=d, hour=h, minute=m,
+            y, mth, q, d, h, minute, s = fields
+            subarr, freq = _range_from_fields(year=y, month=mth, quarter=q,
+                                              day=d, hour=h, minute=minute,
                                               second=s, freq=freq)
         else:
             raise ValueError('Not enough parameters to construct '
@@ -611,15 +592,11 @@ class PeriodIndex(Int64Index):
     @classmethod
     def _from_arraylike(cls, data, freq):
         if not isinstance(data, np.ndarray):
-            if np.isscalar(data):
+            if np.isscalar(data) or isinstance(data, Period):
                 raise ValueError('PeriodIndex() must be called with a '
                                  'collection of some kind, %s was passed'
                                  % repr(data))
 
-            elif isinstance(data, Period):
-                raise ValueError('Data must be array of dates, strings, '
-                                 'or Period objects')
-
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
                 data = list(data)
@@ -648,7 +625,7 @@ class PeriodIndex(Int64Index):
                     data = plib.period_asfreq_arr(data.values, base1, base2, 1)
             else:
                 if freq is None and len(data) > 0:
-                    freq = getattr(data[0], 'freq')
+                    freq = getattr(data[0], 'freq', None)
 
                 if freq is None:
                     raise ValueError(('freq not specified and cannot be '
@@ -684,7 +661,10 @@ class PeriodIndex(Int64Index):
             result = np.empty(len(self), dtype=dtype)
             result[:] = [x for x in self]
             return result
-        return np.ndarray.astype(self.values, dtype)
+        elif dtype == _INT64_DTYPE:
+            return self.values.copy()
+        else:  # pragma: no cover
+            raise ValueError('Cannot cast PeriodIndex to dtype %s' % dtype)
 
     def __iter__(self):
         for val in self.values:
@@ -717,18 +697,11 @@ class PeriodIndex(Int64Index):
         freq = _freq_mod.get_standard_freq(freq)
 
         base1, mult1 = _gfc(self.freq)
-
-        if isinstance(freq, basestring):
-            base2, mult2 = _gfc(freq)
-        else:
-            base2, mult2 = freq
+        base2, mult2 = _gfc(freq)
 
         if mult2 != 1:
             raise ValueError('Only mult == 1 supported')
 
-        if how not in ('S', 'E'):
-            raise ValueError('relation argument must be one of S or E')
-
         end = how == 'E'
         new_data = plib.period_asfreq_arr(self.values, base1, base2, end)
 
@@ -753,11 +726,12 @@ class PeriodIndex(Int64Index):
 
     # Try to run function on index first, and then on elements of index
     # Especially important for group-by functionality
-    def map(self, func_to_map):
+    def map(self, f):
         try:
-            return func_to_map(self)
+            return f(self)
         except:
-            return super(PeriodIndex, self).map(func_to_map)
+            values = np.asarray(list(self), dtype=object)
+            return _algos.arrmap_object(values, f)
 
     def _mpl_repr(self):
         # how to represent ourselves to matplotlib
@@ -810,19 +784,10 @@ class PeriodIndex(Int64Index):
         return PeriodIndex(data=self.values + n, freq=self.freq)
 
     def __add__(self, other):
-        if com.is_integer(other):
-            return PeriodIndex(ordinal=self.values + other, freq=self.freq)
-        return super(PeriodIndex, self).__add__(other)
+        return PeriodIndex(ordinal=self.values + other, freq=self.freq)
 
     def __sub__(self, other):
-        if com.is_integer(other):
-            return PeriodIndex(ordinal=self.values - other, freq=self.freq)
-        if isinstance(other, Period):
-            if other.freq != self.freq:
-                raise ValueError("Cannot do arithmetic with "
-                                 "non-conforming periods")
-            return PeriodIndex(self.values - other.ordinal)
-        return super(PeriodIndex, self).__sub__(other)
+        return PeriodIndex(ordinal=self.values - other, freq=self.freq)
 
     @property
     def inferred_type(self):
@@ -843,11 +808,17 @@ class PeriodIndex(Int64Index):
                 grp = _freq_mod._infer_period_group(reso)
                 freqn = _freq_mod._period_group(self.freq)
 
+                vals = self.values
+
                 # if our data is higher resolution than requested key, slice
                 if grp < freqn:
                     iv = Period(asdt, freq=(grp,1))
                     ord1 = iv.asfreq(self.freq, how='S').ordinal
                     ord2 = iv.asfreq(self.freq, how='E').ordinal
+
+                    if ord2 < vals[0] or ord1 > vals[-1]:
+                        raise KeyError(key)
+
                     pos = np.searchsorted(self.values, [ord1, ord2])
                     key = slice(pos[0], pos[1]+1)
                     return series[key]
@@ -858,9 +829,6 @@ class PeriodIndex(Int64Index):
                 pass
             except KeyError:
                 pass
-            except IndexError:
-                ival = Period(key, freq=self.freq)
-                raise IndexError("%s is out of bounds" % ival)
 
             key = to_period(key, self.freq)
             return self._engine.get_value(series, key.ordinal)
@@ -881,8 +849,6 @@ class PeriodIndex(Int64Index):
                 key = asdt
             except TypeError:
                 pass
-            except KeyError:
-                pass
 
             key = to_period(key, self.freq).ordinal
             return self._engine.get_loc(key)
@@ -904,7 +870,7 @@ class PeriodIndex(Int64Index):
 
     def _assert_can_do_setop(self, other):
         if not isinstance(other, PeriodIndex):
-            raise TypeError('can only call with other PeriodIndex-ed objects')
+            raise ValueError('can only call with other PeriodIndex-ed objects')
 
         if self.freq != other.freq:
             raise ValueError('Only like-indexed PeriodIndexes compatible '
@@ -933,7 +899,10 @@ class PeriodIndex(Int64Index):
 
             result = arr_idx[key]
             if result.ndim > 1:
-                return PeriodIndex(result, name=self.name, freq=self.freq)
+                values = PeriodIndex(result.squeeze(), name=self.name,
+                                     freq=self.freq)
+                values = np.asarray(list(values), dtype=object)
+                return values.reshape(result.shape)
 
             return PeriodIndex(result, name=self.name, freq=self.freq)
 
@@ -948,12 +917,6 @@ class PeriodIndex(Int64Index):
 
         return header + ['%s' % Period(x, freq=self.freq) for x in self]
 
-    def _view_like(self, ndarray):
-        result = ndarray.view(type(self))
-        result.freq = self.freq
-        result.name = self.name
-        return result
-
     def __array_finalize__(self, obj):
         if self.ndim == 0: # pragma: no cover
             return self.item()
@@ -988,11 +951,6 @@ def _get_ordinal_range(start, end, periods, freq):
 
     is_start_per = isinstance(start, Period)
     is_end_per = isinstance(end, Period)
-    if (start is not None and not is_start_per):
-        raise ValueError('Failed to convert %s to period' % start)
-
-    if (end is not None and not is_end_per):
-        raise ValueError('Failed to convert %s to period' % end)
 
     if is_start_per and is_end_per and (start.freq != end.freq):
         raise ValueError('Start and end must have same freq')
@@ -1002,7 +960,7 @@ def _get_ordinal_range(start, end, periods, freq):
             freq = start.freq
         elif is_end_per:
             freq = end.freq
-        else:
+        else:  # pragma: no cover
             raise ValueError('Could not infer freq from start/end')
 
     if periods is not None:
@@ -1014,9 +972,6 @@ def _get_ordinal_range(start, end, periods, freq):
             data = np.arange(start.ordinal, start.ordinal + periods,
                              dtype=np.int64)
     else:
-        if start is None or end is None:
-            msg = 'Must specify both start and end if periods is None'
-            raise ValueError(msg)
         data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
 
     return data, freq
@@ -1055,8 +1010,8 @@ def _range_from_fields(year=None, month=None, quarter=None, day=None,
             raise ValueError('Only mult == 1 supported')
 
         arrays = _make_field_arrays(year, month, day, hour, minute, second)
-        for y, m, d, h, m, s in zip(*arrays):
-            ordinals.append(plib.period_ordinal(y, m, d, h, m, s, base))
+        for y, mth, d, h, mn, s in zip(*arrays):
+            ordinals.append(plib.period_ordinal(y, mth, d, h, mn, s, base))
 
     return np.array(ordinals, dtype=np.int64), freq
 
@@ -1066,6 +1021,8 @@ def _make_field_arrays(*fields):
         if isinstance(x, (list, np.ndarray)):
             if length is not None and len(x) != length:
                 raise ValueError('Mismatched Period array lengths')
+            elif length is None:
+                length = len(x)
 
     arrays = [np.asarray(x) if isinstance(x, (np.ndarray, list))
               else np.repeat(x, length) for x in fields]
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index c73d68b31..f94eafef7 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -16,6 +16,7 @@ from pandas.tseries.frequencies import MONTHS, DAYS
 from pandas.tseries.period import Period, PeriodIndex, period_range
 from pandas.tseries.index import DatetimeIndex, date_range
 from pandas.tseries.tools import to_datetime
+import pandas.tseries.period as pmod
 
 import pandas.core.datetools as datetools
 import numpy as np
@@ -182,6 +183,10 @@ class TestPeriodProperties(TestCase):
         self.assert_(p.strftime('%Y-%m-%d %H:%M:%S') ==
                      '2000-01-01 12:34:12')
 
+    def test_sub_delta(self):
+        result = Period('2011', freq='A') - Period('2007', freq='A')
+        self.assertEqual(result, 4)
+
     def test_to_timestamp(self):
         p = Period('1982', freq='A')
         start_ts = p.to_timestamp(how='S')
@@ -338,6 +343,17 @@ class TestPeriodProperties(TestCase):
         assert_equal(s_date.minute, 0)
         assert_equal(s_date.second, 0)
 
+    def test_pnow(self):
+        dt = datetime.now()
+
+        val = pmod.pnow('D')
+        exp = Period(dt, freq='D')
+        self.assertEquals(val, exp)
+
+    def test_constructor_corner(self):
+        self.assertRaises(ValueError, Period, year=2007, month=1,
+                          freq='2M')
+
 def noWrap(item):
     return item
 
@@ -932,6 +948,12 @@ class TestPeriodIndex(TestCase):
         series = Series(1, index=index)
         self.assert_(isinstance(series, TimeSeries))
 
+    def test_astype(self):
+        idx = period_range('1990', '2009', freq='A')
+
+        result = idx.astype('i8')
+        self.assert_(np.array_equal(result, idx.values))
+
     def test_constructor_use_start_freq(self):
         # GH #1118
         p = Period('4/2/2012', freq='B')
@@ -949,9 +971,27 @@ class TestPeriodIndex(TestCase):
         expected = period_range('1990Q3', '2009Q2', freq='Q-DEC')
         self.assert_(index.equals(expected))
 
+        self.assertRaises(ValueError, PeriodIndex, year=years, quarter=quarters,
+                          freq='2Q-DEC')
+
         index = PeriodIndex(year=years, quarter=quarters)
         self.assert_(index.equals(expected))
 
+        years = [2007, 2007, 2007]
+        months = [1, 2]
+        self.assertRaises(ValueError, PeriodIndex, year=years, month=months,
+                          freq='M')
+        self.assertRaises(ValueError, PeriodIndex, year=years, month=months,
+                          freq='2M')
+        self.assertRaises(ValueError, PeriodIndex, year=years, month=months,
+                          freq='M', start=Period('2007-01', freq='M'))
+
+        years = [2007, 2007, 2007]
+        months = [1, 2, 3]
+        idx = PeriodIndex(year=years, month=months, freq='M')
+        exp = period_range('2007-01', periods=3, freq='M')
+        self.assert_(idx.equals(exp))
+
     def test_constructor_arrays_negative_year(self):
         years = np.arange(1960, 2000).repeat(4)
         quarters = np.tile(range(1, 5), 40)
@@ -965,6 +1005,67 @@ class TestPeriodIndex(TestCase):
         self.assertRaises(ValueError, PeriodIndex, year=range(2000, 2004),
                           quarter=range(4), freq='Q-DEC')
 
+    def test_constructor_corner(self):
+        self.assertRaises(ValueError, PeriodIndex, periods=10, freq='A')
+
+        start = Period('2007', freq='A-JUN')
+        end = Period('2010', freq='A-DEC')
+        self.assertRaises(ValueError, PeriodIndex, start=start, end=end)
+        self.assertRaises(ValueError, PeriodIndex, start=start)
+        self.assertRaises(ValueError, PeriodIndex, end=end)
+
+        result = period_range('2007-01', periods=10.5, freq='M')
+        exp = period_range('2007-01', periods=10, freq='M')
+        self.assert_(result.equals(exp))
+
+    def test_constructor_fromarraylike(self):
+        idx = period_range('2007-01', periods=20, freq='M')
+
+        self.assertRaises(ValueError, PeriodIndex, idx.values)
+        self.assertRaises(ValueError, PeriodIndex, list(idx.values))
+        self.assertRaises(ValueError, PeriodIndex,
+                          data=Period('2007', freq='A'))
+
+        result = PeriodIndex(iter(idx))
+        self.assert_(result.equals(idx))
+
+        result = PeriodIndex(idx)
+        self.assert_(result.equals(idx))
+
+        result = PeriodIndex(idx, freq='M')
+        self.assert_(result.equals(idx))
+
+        result = PeriodIndex(idx, freq='D')
+        exp = idx.asfreq('D', 'e')
+        self.assert_(result.equals(exp))
+
+    def test_comp_period(self):
+        idx = period_range('2007-01', periods=20, freq='M')
+
+        result = idx < idx[10]
+        exp = idx.values < idx.values[10]
+        self.assert_(np.array_equal(result, exp))
+
+    def test_getitem_ndim2(self):
+        idx = period_range('2007-01', periods=3, freq='M')
+
+        result = idx[:, None]
+        self.assert_(type(result) == np.ndarray)
+        self.assert_(isinstance(result[0, 0], Period))
+
+    def test_getitem_partial(self):
+        rng = period_range('2007-01', periods=50)
+        ts = Series(np.random.randn(len(rng)), rng)
+
+        self.assertRaises(KeyError, ts.__getitem__, '2006')
+
+    def test_sub(self):
+        rng = period_range('2007-01', periods=50)
+
+        result = rng - 5
+        exp = rng + (-5)
+        self.assert_(result.equals(exp))
+
     def test_periods_number_check(self):
         self.assertRaises(ValueError, period_range, '2011-1-1', '2012-1-1', 'B')
 
@@ -1001,6 +1102,8 @@ class TestPeriodIndex(TestCase):
         exp_index = _get_with_delta(delta)
         self.assert_(result.index.equals(exp_index))
 
+        self.assertRaises(ValueError, index.to_timestamp, '5t')
+
     def test_to_timestamp_quarterly_bug(self):
         years = np.arange(1960, 2000).repeat(4)
         quarters = np.tile(range(1, 5), 40)
@@ -1217,6 +1320,9 @@ class TestPeriodIndex(TestCase):
     def test_shift(self):
         pi1 = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
         pi2 = PeriodIndex(freq='A', start='1/1/2002', end='12/1/2010')
+
+        self.assert_(pi1.shift(0).equals(pi1))
+
         assert_equal(len(pi1), len(pi2))
         assert_equal(pi1.shift(1).values, pi2.values)
 
@@ -1304,7 +1410,8 @@ class TestPeriodIndex(TestCase):
         self.assertEquals(pi7.asfreq('H', 'S'), pi5)
         self.assertEquals(pi7.asfreq('Min', 'S'), pi6)
 
-        #self.assertEquals(pi7.asfreq('A', 'E'), i_end)
+        self.assertRaises(ValueError, pi7.asfreq, 'T', 'foo')
+        self.assertRaises(ValueError, pi1.asfreq, '5t')
 
     def test_ts_repr(self):
         index = PeriodIndex(freq='A', start='1/1/2001', end='12/31/2010')
@@ -1487,6 +1594,8 @@ class TestPeriodIndex(TestCase):
         index2 = period_range('1/1/2000', '1/20/2000', freq='W-WED')
         self.assertRaises(Exception, index.union, index2)
 
+        self.assertRaises(ValueError, index.join, index.to_timestamp())
+
     def test_intersection(self):
         index = period_range('1/1/2000', '1/20/2000', freq='D')
 
@@ -1574,6 +1683,10 @@ class TestPeriodIndex(TestCase):
         expected = index + 1
         self.assert_(result.equals(expected))
 
+        result = index.map(lambda x: x.ordinal)
+        exp = [x.ordinal for x in index]
+        self.assert_(np.array_equal(result, exp))
+
 def _permute(obj):
     return obj.take(np.random.permutation(len(obj)))
 
@@ -1589,8 +1702,8 @@ class TestMethods(TestCase):
         dt2 = Period(freq='D', year=2008, month=1, day=2)
         assert_equal(dt1 + 1, dt2)
         #
-        self.assertRaises(ValueError, dt1.__add__, "str")
-        self.assertRaises(ValueError, dt1.__add__, dt2)
+        self.assertRaises(TypeError, dt1.__add__, "str")
+        self.assertRaises(TypeError, dt1.__add__, dt2)
 
 
 class TestPeriodRepresentation(unittest.TestCase):
diff --git a/test.sh b/test.sh
index 324ac68d6..4ecb27dad 100755
--- a/test.sh
+++ b/test.sh
@@ -2,8 +2,8 @@
 coverage erase
 # nosetests pandas/tests/test_index.py --with-coverage --cover-package=pandas.core --pdb-failure --pdb
 #nosetests -w pandas --with-coverage --cover-package=pandas --pdb-failure --pdb #--cover-inclusive
-#nosetests -A "not slow" -w pandas/tseries --with-coverage --cover-package=pandas.tseries $* #--cover-inclusive
-nosetests -w pandas --with-coverage --cover-package=pandas $*
+nosetests -A "not slow" -w pandas/tseries --with-coverage --cover-package=pandas.tseries $* #--cover-inclusive
+# nosetests -w pandas --with-coverage --cover-package=pandas $*
 # nosetests -w pandas/io --with-coverage --cover-package=pandas.io --pdb-failure --pdb
 # nosetests -w pandas/core --with-coverage --cover-package=pandas.core --pdb-failure --pdb
 # nosetests -w pandas/stats --with-coverage --cover-package=pandas.stats

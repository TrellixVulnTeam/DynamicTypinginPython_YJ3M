commit 31ae3f04667a0ff21ff293118fd074530cc80aa4
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Sep 26 08:12:02 2019 -0700

    CLN+TST: Catch specific exception in equals (#28532)

diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 5dff1f932..0335058a6 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -1918,6 +1918,9 @@ def sequence_to_dt64ns(
     tz = validate_tz_from_dtype(dtype, tz)
 
     if isinstance(data, ABCIndexClass):
+        if data.nlevels > 1:
+            # Without this check, data._data below is None
+            raise TypeError("Cannot create a DatetimeArray from a MultiIndex.")
         data = data._data
 
     # By this point we are assured to have either a numpy array or Index
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index c7664d977..bf89bbbdf 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -192,7 +192,11 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         elif not isinstance(other, type(self)):
             try:
                 other = type(self)(other)
-            except Exception:
+            except (ValueError, TypeError, OverflowError):
+                # e.g.
+                #  ValueError -> cannot parse str entry, or OutOfBoundsDatetime
+                #  TypeError  -> trying to convert IntervalIndex to DatetimeIndex
+                #  OverflowError -> Index([very_large_timedeltas])
                 return False
 
         if not is_dtype_equal(self.dtype, other.dtype):
diff --git a/pandas/tests/arrays/test_datetimes.py b/pandas/tests/arrays/test_datetimes.py
index d749d9bb4..c3cda2249 100644
--- a/pandas/tests/arrays/test_datetimes.py
+++ b/pandas/tests/arrays/test_datetimes.py
@@ -15,6 +15,11 @@ import pandas.util.testing as tm
 
 
 class TestDatetimeArrayConstructor:
+    def test_from_sequence_invalid_type(self):
+        mi = pd.MultiIndex.from_product([np.arange(5), np.arange(5)])
+        with pytest.raises(TypeError, match="Cannot create a DatetimeArray"):
+            DatetimeArray._from_sequence(mi)
+
     def test_only_1dim_accepted(self):
         arr = np.array([0, 1, 2, 3], dtype="M8[h]").astype("M8[ns]")
 
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index d4dff2cbc..2ec267c66 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -393,6 +393,18 @@ class TestDatetimeIndexOps(Ops):
         assert not idx.equals(list(idx3))
         assert not idx.equals(pd.Series(idx3))
 
+        # check that we do not raise when comparing with OutOfBounds objects
+        oob = pd.Index([datetime(2500, 1, 1)] * 3, dtype=object)
+        assert not idx.equals(oob)
+        assert not idx2.equals(oob)
+        assert not idx3.equals(oob)
+
+        # check that we do not raise when comparing with OutOfBounds dt64
+        oob2 = oob.map(np.datetime64)
+        assert not idx.equals(oob2)
+        assert not idx2.equals(oob2)
+        assert not idx3.equals(oob2)
+
     @pytest.mark.parametrize("values", [["20180101", "20180103", "20180105"], []])
     @pytest.mark.parametrize("freq", ["2D", Day(2), "2B", BDay(2), "48H", Hour(48)])
     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index d7d8b1034..54ed5058b 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -1,3 +1,5 @@
+from datetime import timedelta
+
 import numpy as np
 import pytest
 
@@ -266,6 +268,17 @@ class TestTimedeltaIndexOps(Ops):
         assert not idx.equals(list(idx2))
         assert not idx.equals(pd.Series(idx2))
 
+        # Check that we dont raise OverflowError on comparisons outside the
+        #  implementation range
+        oob = pd.Index([timedelta(days=10 ** 6)] * 3, dtype=object)
+        assert not idx.equals(oob)
+        assert not idx2.equals(oob)
+
+        # FIXME: oob.apply(np.timedelta64) incorrectly overflows
+        oob2 = pd.Index([np.timedelta64(x) for x in oob], dtype=object)
+        assert not idx.equals(oob2)
+        assert not idx2.equals(oob2)
+
     @pytest.mark.parametrize("values", [["0 days", "2 days", "4 days"], []])
     @pytest.mark.parametrize("freq", ["2D", Day(2), "48H", Hour(48)])
     def test_freq_setter(self, values, freq):

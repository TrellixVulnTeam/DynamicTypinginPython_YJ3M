commit 5828578301a7044e7d1dab7eaa8d3b4c99d6f1b5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jul 29 17:32:15 2011 -0400

    ENH: multilevel index in groupby. tests do not pass yet

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 1998f19ca..5d45640a6 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -4,6 +4,7 @@ import numpy as np
 
 from pandas.core.frame import DataFrame
 from pandas.core.generic import NDFrame
+from pandas.core.index import Factor, MultiIndex
 from pandas.core.internals import BlockManager
 from pandas.core.series import Series
 from pandas.core.panel import WidePanel
@@ -133,11 +134,11 @@ class GroupBy(object):
     def agg(self, func):
         return self.aggregate(func)
 
-    def _get_name_dict(self):
-        axes = [ping.names for ping in self.groupings]
+    def _get_names(self):
+        axes = [ping.levels for ping in self.groupings]
         grouping_names = [ping.name for ping in self.groupings]
         shape = self._result_shape
-        return dict(zip(grouping_names, _ravel_names(axes, shape)))
+        return zip(grouping_names, _ravel_names(axes, shape))
 
     def _iterate_columns(self):
         name = self.name
@@ -189,20 +190,20 @@ class GroupBy(object):
             mask = counts.ravel() > 0
             output[name] = result[mask]
 
-        # do I want a warning message or silently exclude?
-        # if cannot_agg:
-        #     print ('Note: excluded %s which could not '
-        #            'be aggregated' % cannot_agg)
-
-        name_dict = self._get_name_dict()
+        name_list = self._get_names()
 
         if len(self.groupings) > 1:
-            for name, raveled in name_dict.iteritems():
-                output[name] = raveled[mask]
-
-            return DataFrame(output)
+            levels = []
+            labels = []
+            for name, raveled in name_list:
+                factor = Factor.fromarray(raveled)
+                levels.append(factor.levels)
+                labels.append(factor.labels)
+
+            index = MultiIndex(levels=levels, labels=labels)
+            return DataFrame(output, index=index)
         else:
-            return DataFrame(output, index=name_dict.values()[0])
+            return DataFrame(output, index=name_list[0][1])
 
     def _python_aggregate(self, func):
         pass
@@ -240,11 +241,20 @@ class GroupBy(object):
 
             result.fill(np.nan)
 
-        name_dict = self._get_name_dict()
-        for name, raveled in name_dict.iteritems():
-            output[name] = raveled[mask]
+        name_list = self._get_names()
 
-        return DataFrame(output)
+        if len(self.groupings) > 1:
+            levels = []
+            labels = []
+            for name, raveled in name_list:
+                factor = Factor.fromarray(raveled)
+                levels.append(factor.levels)
+                labels.append(factor.labels)
+
+            index = MultiIndex(levels=levels, labels=labels)
+            return DataFrame(output, index=index)
+        else:
+            return DataFrame(output, index=name_list[0][1])
 
     @property
     def _generator_factory(self):
@@ -315,7 +325,7 @@ class Grouping(object):
         return self._ids
 
     @property
-    def names(self):
+    def levels(self):
         return [self.ids[k] for k in sorted(self.ids)]
 
     @property
diff --git a/pandas/core/index.py b/pandas/core/index.py
index c29dfb82c..409fb1f98 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -259,7 +259,7 @@ class Index(np.ndarray):
         theDiff = sorted(set(self) - set(otherArr))
         return Index(theDiff)
 
-    __sub__ = diff
+    __sub__ = lambda self, other: self.diff(other)
 
     def take(self, *args, **kwargs):
         taken = self.view(np.ndarray).take(*args, **kwargs)
@@ -399,11 +399,13 @@ class MultiIndex(Index):
         arr = np.empty(len(labels[0]), dtype=object)
         arr[:] = zip(*labels)
         arr = arr.view(cls)
-        arr.levels = [_ensure_index(lev) for lev in levels]
-        arr.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
-        arr._verify_integrity()
         return arr
 
+    def __init__(self, levels, labels):
+        self.levels = [_ensure_index(lev) for lev in levels]
+        self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
+        self._verify_integrity()
+
     def __array_finalize__(self, obj):
         pass
         # self.labels = getattr(obj, 'labels', None)
@@ -411,7 +413,7 @@ class MultiIndex(Index):
 
     @property
     def nlevels(self):
-        return len(levels)
+        return len(self.levels)
 
     @property
     def levshape(self):
@@ -487,18 +489,6 @@ class MultiIndex(Index):
         labels = []
         return cls(levels, labels)
 
-    def equals(self, other):
-        """
-        Determines if two Index objects contain the same elements.
-        """
-        if self is other:
-            return True
-
-        if not isinstance(other, Index):
-            return False
-
-        return np.array_equal(self, other)
-
     def get_loc(self, key):
         if isinstance(key, tuple):
             return self._get_tuple_loc(key)
@@ -603,6 +593,72 @@ class MultiIndex(Index):
 
         return MultiIndex(levels=new_levels, labels=new_labels)
 
+    def equals(self, other):
+        """
+        Determines if two Index objects contain the same elements.
+        """
+        if self is other:
+            return True
+
+        if not isinstance(other, MultiIndex):
+            return False
+
+        return np.array_equal(self, other)
+
+    def union(self, other):
+        """
+        Form the union of two Index objects and sorts if possible
+
+        Parameters
+        ----------
+        other : Index or array-like
+
+        Returns
+        -------
+        Index
+        """
+        self._assert_can_do_setop(other)
+
+        if len(other) == 0 or self.equals(other):
+            return self
+
+        new_seq = np.concatenate((self, other))
+        try:
+            new_seq = np.unique(new_seq)
+        except Exception:
+            # Not sortable / multiple types
+            pass
+
+        return MultiIndex(new_seq)
+
+    def intersection(self, other):
+        """
+        Form the intersection of two Index objects and sorts if possible
+
+        Parameters
+        ----------
+        other : Index or array-like
+
+        Returns
+        -------
+        Index
+        """
+        self._assert_can_do_setop(other)
+
+        if self.equals(other):
+            return self
+
+        theIntersection = sorted(set(self) & set(other))
+        return Index(theIntersection)
+
+    def _assert_can_do_setop(self, other):
+        if not hasattr(other, '__iter__'):
+            raise Exception('Input must be iterable!')
+
+        if not isinstance(other, MultiIndex):
+            raise TypeError('can only call with other hierarchical '
+                            'index objects')
+
     def get_major_bounds(self, begin=None, end=None):
         """
         Return index bounds for slicing LongPanel labels and / or
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 61cb79c88..c2e27a906 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1325,8 +1325,6 @@ class LongPanel(Panel, DataFrame):
 
         return np.concatenate((np.diff(bounds), [N - bounds[-1]]))
 
-    leftJoin = DataFrame.join
-
     def addPrefix(self, prefix=None):
         """
         Concatenate prefix string with panel items names.
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index a11323219..784080eda 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -262,7 +262,7 @@ class PanelOLS(OLS):
             dummies = dummies.filter(dummies.items - [to_exclude])
 
         dummies = dummies.addPrefix('FE_')
-        panel = panel.leftJoin(dummies)
+        panel = panel.join(dummies)
 
         return panel
 
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index ab7c7f235..423e9be9e 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -904,15 +904,15 @@ class TestLongPanel(unittest.TestCase):
         for i, idx in enumerate(index.levels[1]):
             self.assertEqual(minor_count[i], (labels == i).sum())
 
-    def test_leftJoin(self):
+    def test_join(self):
         lp1 = self.panel.filter(['ItemA', 'ItemB'])
         lp2 = self.panel.filter(['ItemC'])
 
-        joined = lp1.leftJoin(lp2)
+        joined = lp1.join(lp2)
 
         self.assertEqual(len(joined.items), 3)
 
-        self.assertRaises(Exception, lp1.leftJoin,
+        self.assertRaises(Exception, lp1.join,
                           self.panel.filter(['ItemB', 'ItemC']))
 
     def test_merge(self):

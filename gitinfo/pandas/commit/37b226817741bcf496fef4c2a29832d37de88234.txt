commit 37b226817741bcf496fef4c2a29832d37de88234
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Jul 3 04:43:23 2019 -0700

    CLN: more blocks code out from try/excepts (#27200)

diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 6cfeb62ef..a9b2c0491 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -593,22 +593,21 @@ class Block(PandasObject):
                         values = self.get_values(dtype=dtype)
 
                     # _astype_nansafe works fine with 1-d only
-                    values = astype_nansafe(
-                        values.ravel(), dtype, copy=True, **kwargs)
+                    vals1d = values.ravel()
+                    values = astype_nansafe(vals1d, dtype, copy=True, **kwargs)
 
                 # TODO(extension)
                 # should we make this attribute?
-                try:
+                if isinstance(values, np.ndarray):
                     values = values.reshape(self.shape)
-                except AttributeError:
-                    pass
 
-            newb = make_block(values, placement=self.mgr_locs,
-                              ndim=self.ndim)
         except Exception:  # noqa: E722
             if errors == 'raise':
                 raise
             newb = self.copy() if copy else self
+        else:
+            newb = make_block(values, placement=self.mgr_locs,
+                              ndim=self.ndim)
 
         if newb.is_numeric and self.is_numeric:
             if newb.shape != self.shape:
@@ -1311,10 +1310,6 @@ class Block(PandasObject):
 
         # our where function
         def func(cond, values, other):
-            if cond.ravel().all():
-                return values
-
-            values = self._coerce_values(values)
             other = self._try_coerce_args(other)
 
             try:
@@ -1331,20 +1326,24 @@ class Block(PandasObject):
                     result.fill(np.nan)
                     return result
 
-        # see if we can operate on the entire block, or need item-by-item
-        # or if we are a single block (ndim == 1)
-        try:
-            result = func(cond, values, other)
-        except TypeError:
-
-            # we cannot coerce, return a compat dtype
-            # we are explicitly ignoring errors
-            block = self.coerce_to_target_dtype(other)
-            blocks = block.where(orig_other, cond, align=align,
-                                 errors=errors,
-                                 try_cast=try_cast, axis=axis,
-                                 transpose=transpose)
-            return self._maybe_downcast(blocks, 'infer')
+        if cond.ravel().all():
+            result = values
+        else:
+            # see if we can operate on the entire block, or need item-by-item
+            # or if we are a single block (ndim == 1)
+            values = self._coerce_values(values)
+            try:
+                result = func(cond, values, other)
+            except TypeError:
+
+                # we cannot coerce, return a compat dtype
+                # we are explicitly ignoring errors
+                block = self.coerce_to_target_dtype(other)
+                blocks = block.where(orig_other, cond, align=align,
+                                     errors=errors,
+                                     try_cast=try_cast, axis=axis,
+                                     transpose=transpose)
+                return self._maybe_downcast(blocks, 'infer')
 
         if self._can_hold_na or self.ndim == 1:
 
@@ -1456,7 +1455,8 @@ class Block(PandasObject):
                                                     len(qs))
         else:
             # asarray needed for Sparse, see GH#24600
-            # TODO: Why self.values and not values?
+            # Note: we use self.values below instead of values because the
+            #  `asi8` conversion above will behave differently under `isna`
             mask = np.asarray(isna(self.values))
             result = nanpercentile(values, np.array(qs) * 100,
                                    axis=axis, na_value=self.fill_value,
@@ -2652,10 +2652,9 @@ class ObjectBlock(Block):
         def f(m, v, i):
             shape = v.shape
             values = fn(v.ravel(), **fn_kwargs)
-            try:
+            if isinstance(values, np.ndarray):
+                # TODO: allow EA once reshape is supported
                 values = values.reshape(shape)
-            except (AttributeError, NotImplementedError):
-                pass
 
             values = _block_shape(values, ndim=self.ndim)
             return values
@@ -2669,26 +2668,6 @@ class ObjectBlock(Block):
 
         return blocks
 
-    def set(self, locs, values):
-        """
-        Modify Block in-place with new item value
-
-        Returns
-        -------
-        None
-        """
-        try:
-            self.values[locs] = values
-        except (ValueError):
-
-            # broadcasting error
-            # see GH6171
-            new_shape = list(values.shape)
-            new_shape[0] = len(self.items)
-            self.values = np.empty(tuple(new_shape), dtype=self.dtype)
-            self.values.fill(np.nan)
-            self.values[locs] = values
-
     def _maybe_downcast(self, blocks, downcast=None):
 
         if downcast is not None:
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index 5494b75ff..b02d40d23 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -1214,7 +1214,7 @@ class BlockManager(PandasObject):
             elif not allow_fill or self.ndim == 1:
                 if allow_fill and fill_tuple[0] is None:
                     _, fill_value = maybe_promote(blk.dtype)
-                    fill_tuple = (fill_value, )
+                    fill_tuple = (fill_value,)
 
                 return [blk.take_nd(slobj, axis=0,
                                     new_mgr_locs=slice(0, sllen),
@@ -1579,7 +1579,7 @@ def create_block_manager_from_blocks(blocks, axes):
         mgr._consolidate_inplace()
         return mgr
 
-    except (ValueError) as e:
+    except ValueError as e:
         blocks = [getattr(b, 'values', b) for b in blocks]
         tot_items = sum(b.shape[0] for b in blocks)
         construction_error(tot_items, blocks[0].shape[1:], axes, e)

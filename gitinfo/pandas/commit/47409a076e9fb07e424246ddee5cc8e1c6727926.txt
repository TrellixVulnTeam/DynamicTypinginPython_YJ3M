commit 47409a076e9fb07e424246ddee5cc8e1c6727926
Author: jreback <jeff@reback.net>
Date:   Fri Apr 25 12:57:19 2014 -0400

    COMPAT: fix array_to_datetime on comparison of NaT

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 813d64704..d7a7c1d79 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -285,7 +285,17 @@ def notnull(obj):
 def _is_null_datelike_scalar(other):
     """ test whether the object is a null datelike, e.g. Nat
     but guard against passing a non-scalar """
-    return (np.isscalar(other) and (isnull(other) or other == tslib.iNaT)) or other is pd.NaT or other is None
+    if other is pd.NaT or other is None:
+        return True
+    elif np.isscalar(other):
+
+        # a timedelta
+        if hasattr(other,'dtype'):
+            return other.view('i8') == tslib.iNaT
+        elif is_integer(other) and other == tslib.iNaT:
+            return True
+        return isnull(other)
+    return False
 
 def array_equivalent(left, right):
     """
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 43eb0e890..0a4f65b6b 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -1861,7 +1861,7 @@ def _get_format_timedelta64(values):
     def impl(x):
         if x is None or lib.checknull(x):
             return 'NaT'
-        elif format_short and x == 0:
+        elif format_short and com.is_integer(x) and x.view('int64') == 0:
             return "0 days" if even_days else "00:00:00"
         else:
             return lib.repr_timedelta64(x, format=format)
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index eac1e0373..34060d0c5 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -152,7 +152,18 @@ def infer_dtype_list(list values):
 
 
 cdef inline bint is_null_datetimelike(v):
-    return util._checknull(v) or (util.is_integer_object(v) and v == iNaT) or v is NaT
+    # determine if we have a null for a timedelta/datetime (or integer versions)x
+    if util._checknull(v):
+        return True
+    elif util.is_timedelta64_object(v):
+        return v.view('int64') == iNaT
+    elif util.is_datetime64_object(v):
+        return v.view('int64') == iNaT
+    elif util.is_integer_object(v):
+        return v == iNaT
+    elif v is NaT:
+        return True
+    return False
 
 cdef inline bint is_datetime(object o):
     return PyDateTime_Check(o)
diff --git a/pandas/tseries/tests/test_timedeltas.py b/pandas/tseries/tests/test_timedeltas.py
index 215e6e62c..5585233f4 100644
--- a/pandas/tseries/tests/test_timedeltas.py
+++ b/pandas/tseries/tests/test_timedeltas.py
@@ -122,8 +122,8 @@ class TestTimedeltas(tm.TestCase):
     def test_nat_converters(self):
         _skip_if_numpy_not_friendly()
 
-        self.assertEqual(to_timedelta('nat',box=False), tslib.iNaT)
-        self.assertEqual(to_timedelta('nan',box=False), tslib.iNaT)
+        self.assertEqual(to_timedelta('nat',box=False).astype('int64'), tslib.iNaT)
+        self.assertEqual(to_timedelta('nan',box=False).astype('int64'), tslib.iNaT)
 
     def test_to_timedelta(self):
         _skip_if_numpy_not_friendly()
@@ -137,7 +137,7 @@ class TestTimedeltas(tm.TestCase):
 
         # empty string
         result = to_timedelta('',box=False)
-        self.assertEqual(result, tslib.iNaT)
+        self.assertEqual(result.astype('int64'), tslib.iNaT)
 
         result = to_timedelta(['', ''])
         self.assert_(isnull(result).all())
@@ -302,10 +302,10 @@ class TestTimedeltas(tm.TestCase):
         assert_series_equal(actual, expected)
 
         actual = pd.to_timedelta(np.nan)
-        self.assertEqual(actual, timedelta_NaT)
+        self.assertEqual(actual.astype('int64'), timedelta_NaT.astype('int64'))
 
         actual = pd.to_timedelta(pd.NaT)
-        self.assertEqual(actual, timedelta_NaT)
+        self.assertEqual(actual.astype('int64'), timedelta_NaT.astype('int64'))
 
     def test_timedelta_ops_with_missing_values(self):
         _skip_if_numpy_not_friendly()
diff --git a/pandas/tseries/util.py b/pandas/tseries/util.py
index 664a42543..72b12ea49 100644
--- a/pandas/tseries/util.py
+++ b/pandas/tseries/util.py
@@ -52,7 +52,7 @@ def pivot_annual(series, freq=None):
         offset = index.dayofyear - 1
 
         # adjust for leap year
-        offset[(-isleapyear(year)) & (offset >= 59)] += 1
+        offset[(~isleapyear(year)) & (offset >= 59)] += 1
 
         columns = lrange(1, 367)
         # todo: strings like 1/1, 1/25, etc.?
@@ -66,7 +66,7 @@ def pivot_annual(series, freq=None):
         defaulted = grouped.apply(lambda x: x.reset_index(drop=True))
         defaulted.index = defaulted.index.droplevel(0)
         offset = np.asarray(defaulted.index)
-        offset[-isleapyear(year) & (offset >= 1416)] += 24
+        offset[~isleapyear(year) & (offset >= 1416)] += 24
         columns = lrange(1, 8785)
     else:
         raise NotImplementedError(freq)
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index ba6f03fd9..e76a2d0cb 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -402,17 +402,17 @@ class Timestamp(_Timestamp):
         if month <= 2:
             year -= 1
             month += 12
-        return (day + 
-                np.fix((153*month - 457)/5) + 
-                365*year + 
-                np.floor(year / 4) - 
-                np.floor(year / 100) + 
-                np.floor(year / 400) + 
-                1721118.5 + 
-                (self.hour + 
-                 self.minute/60.0 + 
-                 self.second/3600.0 + 
-                 self.microsecond/3600.0/1e+6 + 
+        return (day +
+                np.fix((153*month - 457)/5) +
+                365*year +
+                np.floor(year / 4) -
+                np.floor(year / 100) +
+                np.floor(year / 400) +
+                1721118.5 +
+                (self.hour +
+                 self.minute/60.0 +
+                 self.second/3600.0 +
+                 self.microsecond/3600.0/1e+6 +
                  self.nanosecond/3600.0/1e+9
                 )/24.0)
 
@@ -1114,7 +1114,7 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False,
                         continue
                     raise
             elif util.is_datetime64_object(val):
-                if val == np_NaT:
+                if val is np_NaT or val.view('i8') == iNaT:
                     iresult[i] = iNaT
                 else:
                     try:
@@ -1190,7 +1190,11 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False,
         oresult = np.empty(n, dtype=object)
         for i in range(n):
             val = values[i]
-            if util.is_datetime64_object(val):
+
+            # set as nan if is even a datetime NaT
+            if _checknull_with_nat(val) or val is np_NaT:
+                oresult[i] = np.nan
+            elif util.is_datetime64_object(val):
                 oresult[i] = val.item()
             else:
                 oresult[i] = val

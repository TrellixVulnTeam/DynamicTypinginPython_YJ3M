commit ba17598da1e8c5578398d76fcf941c16aa75669d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Apr 27 16:14:42 2012 -0400

    ENH: can pass datetime.time to get values at time, close #1130

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 358956c6e..40492cb09 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1705,10 +1705,12 @@ class DataFrame(NDFrame):
         if np.isscalar(loc):
             new_values = self._data.fast_2d_xs(loc, copy=copy)
             return Series(new_values, index=self.columns, name=key)
-        else:
+        elif isinstance(loc, slice) or loc.dtype == np.bool_:
             result = self[loc]
             result.index = new_index
             return result
+        else:
+            return self.take(loc)
 
     def lookup(self, row_labels, col_labels):
         """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 246541e8c..4ef92da83 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2517,6 +2517,24 @@ class TimeSeries(Series):
         namestr = "Name: %s, " % str(self.name) if self.name else ""
         return '%s%sLength: %d' % (freqstr, namestr, len(self))
 
+    def at_time(self, time, tz=None, asof=False):
+        """
+        Select values at particular time of day (e.g. 9:30AM)
+
+        Parameters
+        ----------
+        time : datetime.time or string
+        tz : string or pytz.timezone
+            Time zone for time. Corresponding timestamps would be converted to
+            time zone of the TimeSeries
+
+        Returns
+        -------
+        values_at_time : TimeSeries
+        """
+        from pandas.tseries.resample import values_at_time
+        return values_at_time(self, time, tz=tz, asof=asof)
+
     def tz_convert(self, tz, copy=True):
         """
         Convert TimeSeries to target time zone. If it is time zone naive, it
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 9dd7bda7a..c49ab9f42 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -887,6 +887,7 @@ def tz_localize(ndarray[int64_t] vals, object tz):
 
     return vals
 
+
 # Accessors
 #----------------------------------------------------------------------
 
@@ -1016,6 +1017,48 @@ cdef inline int m8_weekday(int64_t val):
     ts = convert_to_tsobject(val)
     return ts_dayofweek(ts)
 
+cdef int64_t DAY_US = 24 * 60 * 60 * 1000000
+
+def values_at_time(ndarray[int64_t] stamps, int64_t time):
+    cdef:
+        Py_ssize_t i, j, count, n = len(stamps)
+        ndarray[int64_t] indexer, times
+        int64_t last, cur
+
+    # Assumes stamps is sorted
+
+    if len(stamps) == 0:
+        return np.empty(0, dtype=np.int64)
+
+    # is this OK?
+    # days = stamps // DAY_US
+    times = stamps % DAY_US
+
+    # Microsecond resolution
+    count = 0
+    for i in range(1, n):
+        if times[i] == time:
+            count += 1
+        # cur = days[i]
+        # if cur > last:
+        #     count += 1
+        #     last = cur
+
+    indexer = np.empty(count, dtype=np.int64)
+
+    j = 0
+    # last = days[0]
+    for i in range(n):
+        if times[i] == time:
+            indexer[j] = i
+            j += 1
+
+        # cur = days[i]
+        # if cur > last:
+        #     j += 1
+        #     last = cur
+
+    return indexer
 
 # Some general helper functions
 #----------------------------------------------------------------------
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index fac41f391..04c0d94ac 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -789,6 +789,10 @@ class DatetimeIndex(Int64Index):
             except (TypeError, ValueError, KeyError):
                 pass
 
+            if isinstance(key, time):
+                locs = self._indices_at_time(key)
+                return series.take(locs)
+
             stamp = Timestamp(key)
             try:
                 return self._engine.get_value(series, stamp)
@@ -811,12 +815,24 @@ class DatetimeIndex(Int64Index):
             except (TypeError, KeyError):
                 pass
 
+            if isinstance(key, time):
+                return self._indices_at_time(key)
+
             stamp = Timestamp(key)
             try:
                 return self._engine.get_loc(stamp)
             except KeyError:
                 raise KeyError(stamp)
 
+    def _indices_at_time(self, key):
+        from dateutil.parser import parse
+
+        # TODO: time object with tzinfo?
+
+        mus = _time_to_microsecond(key)
+        indexer = lib.values_at_time(self.asi8, mus)
+        return com._ensure_platform_int(indexer)
+
     def _get_string_slice(self, key):
         asdt, parsed, reso = parse_time_string(key)
         key = asdt
@@ -1184,3 +1200,7 @@ def _naive_in_cache_range(start, end):
 
 def _in_range(start, end, rng_start, rng_end):
     return start > rng_start and end < rng_end
+
+def _time_to_microsecond(time):
+    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
+    return 1000000 * seconds + time.microsecond
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 10ff34a9a..5409b2294 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -183,3 +183,42 @@ def asfreq(obj, freq, method=None, how=None):
             return obj.copy()
         dti = date_range(obj.index[0], obj.index[-1], freq=freq)
         return obj.reindex(dti, method=method)
+
+def values_at_time(obj, time, tz=None, asof=False):
+    """
+    Select values at particular time of day (e.g. 9:30AM)
+
+    Parameters
+    ----------
+    time : datetime.time or string
+    tz : string or pytz.timezone
+        Time zone for time. Corresponding timestamps would be converted to
+        time zone of the TimeSeries
+
+    Returns
+    -------
+    values_at_time : TimeSeries
+    """
+    from dateutil.parser import parse
+
+    if asof:
+        raise NotImplementedError
+    if tz:
+        raise NotImplementedError
+
+    if not isinstance(obj.index, DatetimeIndex):
+        raise NotImplementedError
+
+    if isinstance(time, basestring):
+        time = parse(time).time()
+
+    # TODO: time object with tzinfo?
+
+    mus = _time_to_microsecond(time)
+    indexer = lib.values_at_time(obj.index.asi8, mus)
+    indexer = com._ensure_platform_int(indexer)
+    return obj.take(indexer)
+
+def _time_to_microsecond(time):
+    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
+    return 1000000 * seconds + time.microsecond
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 206e93a94..97eaaa3ac 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -480,6 +480,20 @@ class TestTimeSeries(unittest.TestCase):
         self.assert_(result.freq is None)
         self.assert_(len(result) == 5 * len(rng))
 
+    def test_at_time(self):
+        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        df = DataFrame(np.random.randn(len(rng), 3), index=rng)
+
+        result = ts[time(9, 30)]
+        result_df = df.ix[time(9, 30)]
+        expected = ts[(rng.hour == 9) & (rng.minute == 30)]
+        exp_df = df[(rng.hour == 9) & (rng.minute == 30)]
+
+        # expected.index = date_range('1/1/2000', '1/4/2000')
+
+        assert_series_equal(result, expected)
+        tm.assert_frame_equal(result_df, exp_df)
 
 def _simple_ts(start, end, freq='D'):
     rng = date_range(start, end, freq=freq)

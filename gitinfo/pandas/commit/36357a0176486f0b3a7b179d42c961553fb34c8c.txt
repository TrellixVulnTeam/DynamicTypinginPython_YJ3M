commit 36357a0176486f0b3a7b179d42c961553fb34c8c
Author: Dale Jung <dale@dalejung.com>
Date:   Mon Mar 31 23:45:13 2014 -0400

    PRF: Optimize 2d take operations.
    
    Use memory views

diff --git a/pandas/core/common.py b/pandas/core/common.py
index d7a7c1d79..c8c614754 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -675,6 +675,17 @@ def take_nd(arr, indexer, axis=0, out=None, fill_value=np.nan,
                     # to crash when trying to cast it to dtype)
                     dtype, fill_value = arr.dtype, arr.dtype.type()
 
+    flip_order = False
+    if arr.ndim == 2:
+        if arr.flags.f_contiguous:
+            flip_order = True
+
+    if flip_order:
+        arr = arr.T
+        axis = arr.ndim - axis - 1
+        if out is not None:
+            out = out.T
+
     # at this point, it's guaranteed that dtype can hold both the arr values
     # and the fill_value
     if out is None:
@@ -692,7 +703,11 @@ def take_nd(arr, indexer, axis=0, out=None, fill_value=np.nan,
 
     func = _get_take_nd_function(arr.ndim, arr.dtype, out.dtype,
                                  axis=axis, mask_info=mask_info)
+
     func(arr, indexer, out, fill_value)
+
+    if flip_order:
+        out = out.T
     return out
 
 
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 45c40ee7b..6d45a82fb 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -80,9 +80,9 @@ def take_1d_%(name)s_%(dest)s(ndarray[%(c_type_in)s] values,
 
 take_2d_axis0_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
+def take_2d_axis0_%(name)s_%(dest)s(%(c_type_in)s[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[%(c_type_out)s, ndim=2] out,
+                                    %(c_type_out)s[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -127,9 +127,9 @@ def take_2d_axis0_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
 
 take_2d_axis1_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
+def take_2d_axis1_%(name)s_%(dest)s(%(c_type_in)s[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[%(c_type_out)s, ndim=2] out,
+                                    %(c_type_out)s[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -143,34 +143,12 @@ def take_2d_axis1_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
 
     fv = fill_value
 
-    IF %(can_copy)s:
-        cdef:
-            %(c_type_out)s *v
-            %(c_type_out)s *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(%(c_type_out)s) and
-            sizeof(%(c_type_out)s) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(%(c_type_out)s) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = %(preval)svalues[i, idx]%(postval)s
 
 """
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 22f56ef14..68bda2957 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -2581,9 +2581,9 @@ def take_1d_object_object(ndarray[object] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_bool_bool(ndarray[uint8_t, ndim=2] values,
+def take_2d_axis0_bool_bool(uint8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[uint8_t, ndim=2] out,
+                                    uint8_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2626,9 +2626,9 @@ def take_2d_axis0_bool_bool(ndarray[uint8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_bool_object(ndarray[uint8_t, ndim=2] values,
+def take_2d_axis0_bool_object(uint8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[object, ndim=2] out,
+                                    object[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2671,9 +2671,9 @@ def take_2d_axis0_bool_object(ndarray[uint8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int8_int8(ndarray[int8_t, ndim=2] values,
+def take_2d_axis0_int8_int8(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int8_t, ndim=2] out,
+                                    int8_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2716,9 +2716,9 @@ def take_2d_axis0_int8_int8(ndarray[int8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int8_int32(ndarray[int8_t, ndim=2] values,
+def take_2d_axis0_int8_int32(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2761,9 +2761,9 @@ def take_2d_axis0_int8_int32(ndarray[int8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int8_int64(ndarray[int8_t, ndim=2] values,
+def take_2d_axis0_int8_int64(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2806,9 +2806,9 @@ def take_2d_axis0_int8_int64(ndarray[int8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int8_float64(ndarray[int8_t, ndim=2] values,
+def take_2d_axis0_int8_float64(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2851,9 +2851,9 @@ def take_2d_axis0_int8_float64(ndarray[int8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int16_int16(ndarray[int16_t, ndim=2] values,
+def take_2d_axis0_int16_int16(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int16_t, ndim=2] out,
+                                    int16_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2896,9 +2896,9 @@ def take_2d_axis0_int16_int16(ndarray[int16_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int16_int32(ndarray[int16_t, ndim=2] values,
+def take_2d_axis0_int16_int32(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2941,9 +2941,9 @@ def take_2d_axis0_int16_int32(ndarray[int16_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int16_int64(ndarray[int16_t, ndim=2] values,
+def take_2d_axis0_int16_int64(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -2986,9 +2986,9 @@ def take_2d_axis0_int16_int64(ndarray[int16_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int16_float64(ndarray[int16_t, ndim=2] values,
+def take_2d_axis0_int16_float64(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3031,9 +3031,9 @@ def take_2d_axis0_int16_float64(ndarray[int16_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int32_int32(ndarray[int32_t, ndim=2] values,
+def take_2d_axis0_int32_int32(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3076,9 +3076,9 @@ def take_2d_axis0_int32_int32(ndarray[int32_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int32_int64(ndarray[int32_t, ndim=2] values,
+def take_2d_axis0_int32_int64(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3121,9 +3121,9 @@ def take_2d_axis0_int32_int64(ndarray[int32_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int32_float64(ndarray[int32_t, ndim=2] values,
+def take_2d_axis0_int32_float64(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3166,9 +3166,9 @@ def take_2d_axis0_int32_float64(ndarray[int32_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int64_int64(ndarray[int64_t, ndim=2] values,
+def take_2d_axis0_int64_int64(int64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3211,9 +3211,9 @@ def take_2d_axis0_int64_int64(ndarray[int64_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int64_float64(ndarray[int64_t, ndim=2] values,
+def take_2d_axis0_int64_float64(int64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3256,9 +3256,9 @@ def take_2d_axis0_int64_float64(ndarray[int64_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_float32_float32(ndarray[float32_t, ndim=2] values,
+def take_2d_axis0_float32_float32(float32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float32_t, ndim=2] out,
+                                    float32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3301,9 +3301,9 @@ def take_2d_axis0_float32_float32(ndarray[float32_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_float32_float64(ndarray[float32_t, ndim=2] values,
+def take_2d_axis0_float32_float64(float32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3346,9 +3346,9 @@ def take_2d_axis0_float32_float64(ndarray[float32_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_float64_float64(ndarray[float64_t, ndim=2] values,
+def take_2d_axis0_float64_float64(float64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3391,9 +3391,9 @@ def take_2d_axis0_float64_float64(ndarray[float64_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_object_object(ndarray[object, ndim=2] values,
+def take_2d_axis0_object_object(object[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[object, ndim=2] out,
+                                    object[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3437,9 +3437,9 @@ def take_2d_axis0_object_object(ndarray[object, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_bool_bool(ndarray[uint8_t, ndim=2] values,
+def take_2d_axis1_bool_bool(uint8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[uint8_t, ndim=2] out,
+                                    uint8_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3453,41 +3453,19 @@ def take_2d_axis1_bool_bool(ndarray[uint8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            uint8_t *v
-            uint8_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(uint8_t) and
-            sizeof(uint8_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(uint8_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_bool_object(ndarray[uint8_t, ndim=2] values,
+def take_2d_axis1_bool_object(uint8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[object, ndim=2] out,
+                                    object[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3501,41 +3479,19 @@ def take_2d_axis1_bool_object(ndarray[uint8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            object *v
-            object *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(object) and
-            sizeof(object) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(object) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = True if values[i, idx] > 0 else False
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int8_int8(ndarray[int8_t, ndim=2] values,
+def take_2d_axis1_int8_int8(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int8_t, ndim=2] out,
+                                    int8_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3549,41 +3505,19 @@ def take_2d_axis1_int8_int8(ndarray[int8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            int8_t *v
-            int8_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int8_t) and
-            sizeof(int8_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int8_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int8_int32(ndarray[int8_t, ndim=2] values,
+def take_2d_axis1_int8_int32(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3597,41 +3531,19 @@ def take_2d_axis1_int8_int32(ndarray[int8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            int32_t *v
-            int32_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int32_t) and
-            sizeof(int32_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int8_int64(ndarray[int8_t, ndim=2] values,
+def take_2d_axis1_int8_int64(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3645,41 +3557,19 @@ def take_2d_axis1_int8_int64(ndarray[int8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            int64_t *v
-            int64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int64_t) and
-            sizeof(int64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int8_float64(ndarray[int8_t, ndim=2] values,
+def take_2d_axis1_int8_float64(int8_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3693,41 +3583,19 @@ def take_2d_axis1_int8_float64(ndarray[int8_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int16_int16(ndarray[int16_t, ndim=2] values,
+def take_2d_axis1_int16_int16(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int16_t, ndim=2] out,
+                                    int16_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3741,41 +3609,19 @@ def take_2d_axis1_int16_int16(ndarray[int16_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            int16_t *v
-            int16_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int16_t) and
-            sizeof(int16_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int16_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int16_int32(ndarray[int16_t, ndim=2] values,
+def take_2d_axis1_int16_int32(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3789,41 +3635,19 @@ def take_2d_axis1_int16_int32(ndarray[int16_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            int32_t *v
-            int32_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int32_t) and
-            sizeof(int32_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int16_int64(ndarray[int16_t, ndim=2] values,
+def take_2d_axis1_int16_int64(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3837,41 +3661,19 @@ def take_2d_axis1_int16_int64(ndarray[int16_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            int64_t *v
-            int64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int64_t) and
-            sizeof(int64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int16_float64(ndarray[int16_t, ndim=2] values,
+def take_2d_axis1_int16_float64(int16_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3885,41 +3687,19 @@ def take_2d_axis1_int16_float64(ndarray[int16_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int32_int32(ndarray[int32_t, ndim=2] values,
+def take_2d_axis1_int32_int32(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int32_t, ndim=2] out,
+                                    int32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3933,41 +3713,19 @@ def take_2d_axis1_int32_int32(ndarray[int32_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            int32_t *v
-            int32_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int32_t) and
-            sizeof(int32_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int32_int64(ndarray[int32_t, ndim=2] values,
+def take_2d_axis1_int32_int64(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -3981,41 +3739,19 @@ def take_2d_axis1_int32_int64(ndarray[int32_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            int64_t *v
-            int64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int64_t) and
-            sizeof(int64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int32_float64(ndarray[int32_t, ndim=2] values,
+def take_2d_axis1_int32_float64(int32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4029,41 +3765,19 @@ def take_2d_axis1_int32_float64(ndarray[int32_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int64_int64(ndarray[int64_t, ndim=2] values,
+def take_2d_axis1_int64_int64(int64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[int64_t, ndim=2] out,
+                                    int64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4077,41 +3791,19 @@ def take_2d_axis1_int64_int64(ndarray[int64_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            int64_t *v
-            int64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(int64_t) and
-            sizeof(int64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_int64_float64(ndarray[int64_t, ndim=2] values,
+def take_2d_axis1_int64_float64(int64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4125,41 +3817,19 @@ def take_2d_axis1_int64_float64(ndarray[int64_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_float32_float32(ndarray[float32_t, ndim=2] values,
+def take_2d_axis1_float32_float32(float32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float32_t, ndim=2] out,
+                                    float32_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4173,41 +3843,19 @@ def take_2d_axis1_float32_float32(ndarray[float32_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            float32_t *v
-            float32_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float32_t) and
-            sizeof(float32_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float32_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_float32_float64(ndarray[float32_t, ndim=2] values,
+def take_2d_axis1_float32_float64(float32_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4221,41 +3869,19 @@ def take_2d_axis1_float32_float64(ndarray[float32_t, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_float64_float64(ndarray[float64_t, ndim=2] values,
+def take_2d_axis1_float64_float64(float64_t[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[float64_t, ndim=2] out,
+                                    float64_t[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4269,41 +3895,19 @@ def take_2d_axis1_float64_float64(ndarray[float64_t, ndim=2] values,
 
     fv = fill_value
 
-    IF True:
-        cdef:
-            float64_t *v
-            float64_t *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(float64_t) and
-            sizeof(float64_t) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_object_object(ndarray[object, ndim=2] values,
+def take_2d_axis1_object_object(object[:, :] values,
                                     ndarray[int64_t] indexer,
-                                    ndarray[object, ndim=2] out,
+                                    object[:, :] out,
                                     fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
@@ -4317,34 +3921,12 @@ def take_2d_axis1_object_object(ndarray[object, ndim=2] values,
 
     fv = fill_value
 
-    IF False:
-        cdef:
-            object *v
-            object *o
-
-        #GH3130
-        if (values.strides[0] == out.strides[0] and
-            values.strides[0] == sizeof(object) and
-            sizeof(object) * n >= 256):
-
-            for j from 0 <= j < k:
-                idx = indexer[j]
-                if idx == -1:
-                    for i from 0 <= i < n:
-                        out[i, j] = fv
-                else:
-                    v = &values[0, idx]
-                    o = &out[0, j]
-                    memmove(o, v, <size_t>(sizeof(object) * n))
-            return
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-        if idx == -1:
-            for i from 0 <= i < n:
+    for i from 0 <= i < n:
+        for j from 0 <= j < k:
+            idx = indexer[j]
+            if idx == -1:
                 out[i, j] = fv
-        else:
-            for i from 0 <= i < n:
+            else:
                 out[i, j] = values[i, idx]
 
 

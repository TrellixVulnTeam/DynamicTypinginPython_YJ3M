commit 04cdbfc729dbaf9f1fe13f089bbd2a9d21616200
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Apr 11 23:43:49 2010 +0000

    test coverage
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@154 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 63a3546ac..b67e89169 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -1,6 +1,7 @@
 # pylint: disable-msg=E1101,E1103
 
 from datetime import datetime
+import operator
 
 import numpy as np
 
@@ -40,7 +41,7 @@ class XDateRange(object):
     _cacheStart = {}
     _cacheEnd = {}
     def __init__(self, fromDate=None, toDate=None, nPeriods=None,
-                 offset = datetools.BDay(), timeRule=None):
+                 offset=datetools.BDay(), timeRule=None):
 
         if timeRule is not None:
             offset = datetools.getOffset(timeRule)
@@ -87,16 +88,15 @@ class XDateRange(object):
 CACHE_START = datetime(1950, 1, 1)
 CACHE_END   = datetime(2030, 1, 1)
 
-def _getIndexLoc(index, date):
-    if date in index.indexMap:
-        return index.indexMap[date]
-    else:
-        asOf = index.asOfDate(date)
-        return index.indexMap[asOf] + 1
-
 #-------------------------------------------------------------------------------
 # DateRange class
 
+def _bin_op(op):
+    def f(self, other):
+        return op(self.view(np.ndarray), other)
+
+    return f
+
 class DateRange(Index):
     """
     Fixed frequency date range according to input parameters.
@@ -117,6 +117,7 @@ class DateRange(Index):
     timeRule : timeRule to use
     """
     _cache = {}
+    _parent = None
     def __new__(cls, fromDate=None, toDate=None, periods=None,
                 offset=datetools.bday, timeRule=None, **kwds):
 
@@ -164,10 +165,6 @@ class DateRange(Index):
     @property
     def _allDates(self):
         return True
-        # if not hasattr(self, '_cache_allDates'):
-        #     self._cache_allDates = isAllDates(self)
-
-        # return self._cache_allDates
 
     @classmethod
     def getCachedRange(cls, start=None, end=None, periods=None, offset=None,
@@ -180,12 +177,6 @@ class DateRange(Index):
         if offset is None:
             raise Exception('Must provide a DateOffset!')
 
-        if start is not None and not isinstance(start, datetime):
-            raise Exception('%s is not a valid date!' % start)
-
-        if end is not None and not isinstance(end, datetime):
-            raise Exception('%s is not a valid date!' % end)
-
         if offset not in cls._cache:
             xdr = XDateRange(CACHE_START, CACHE_END, offset=offset)
             arr = np.array(list(xdr), dtype=object, copy=False)
@@ -203,25 +194,27 @@ class DateRange(Index):
             if periods is None:
                 raise Exception('Must provide number of periods!')
 
-            if end not in cachedRange:
-                endLoc = _getIndexLoc(cachedRange, end)
-            else:
-                endLoc = cachedRange.indexMap[end] + 1
+            assert(isinstance(end, datetime))
+
+            end = offset.rollback(end)
 
+            endLoc = cachedRange.indexMap[end] + 1
             startLoc = endLoc - periods
         elif end is None:
-            startLoc = _getIndexLoc(cachedRange, start)
+            assert(isinstance(start, datetime))
+            start = offset.rollforward(start)
+
+            startLoc = cachedRange.indexMap[start]
             if periods is None:
                 raise Exception('Must provide number of periods!')
 
             endLoc = startLoc + periods
         else:
-            startLoc = _getIndexLoc(cachedRange, start)
+            start = offset.rollforward(start)
+            end = offset.rollback(end)
 
-            if end not in cachedRange:
-                endLoc = _getIndexLoc(cachedRange, end)
-            else:
-                endLoc = cachedRange.indexMap[end] + 1
+            startLoc = cachedRange.indexMap[start]
+            endLoc = cachedRange.indexMap[end] + 1
 
         indexSlice = cachedRange[startLoc:endLoc]
         indexSlice._parent = cachedRange
@@ -234,48 +227,33 @@ class DateRange(Index):
         return index
 
     def __array_finalize__(self, obj):
-        if self.ndim == 0:
+        if self.ndim == 0: # pragma: no cover
             return self.item()
 
-        # if len(self) > 0:
-        #     self.indexMap = map_indices(self)
-        # else:
-        #     self.indexMap = {}
-
         self.offset = getattr(obj, 'offset', None)
         self._parent = getattr(obj, '_parent',  None)
-        # self._allDates = True
-
-    def __lt__(self, other):
-        return self.view(np.ndarray) < other
 
-    def __le__(self, other):
-        return self.view(np.ndarray) <= other
+    __lt__ = _bin_op(operator.lt)
+    __le__ = _bin_op(operator.le)
+    __gt__ = _bin_op(operator.gt)
+    __ge__ = _bin_op(operator.ge)
+    __eq__ = _bin_op(operator.eq)
 
-    def __gt__(self, other):
-        return self.view(np.ndarray) > other
-
-    def __ge__(self, other):
-        return self.view(np.ndarray) >= other
-
-    def __eq__(self, other):
-        return self.view(np.ndarray) == other
+    def __getslice__(self, i, j):
+        return self.__getitem__(slice(i, j))
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
         if isinstance(key, (int, np.int32)):
             return self.view(np.ndarray)[key]
         elif isinstance(key, slice):
-            if self.offset is None:
-                return Index.__getitem__(self, key)
+            newIndex = self.view(np.ndarray)[key].view(DateRange)
 
             if key.step is not None:
-                newOffset = key.step * self.offset
-                newRule = None
+                newIndex.offset = key.step * self.offset
             else:
-                newOffset = self.offset
-            newIndex = Index(self.view(np.ndarray)[key]).view(DateRange)
-            newIndex.offset = newOffset
+                newIndex.offset = self.offset
+
             return newIndex
         else:
             return Index(self.view(np.ndarray)[key])
@@ -287,8 +265,7 @@ class DateRange(Index):
         output += 'length: %d' % len(self)
         return output
 
-    def __str__(self):
-        return self.__repr__()
+    __str__ = __repr__
 
     def shift(self, n):
         if n > 0:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9d372e811..ebd0d701e 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -72,23 +72,6 @@ class DataFrame(Picklable, Groupable):
                                                       columns, dtype)
 
         elif isinstance(data, (np.ndarray, list)):
-            if not isinstance(data, np.ndarray):
-                arr = np.array(data)
-                if issubclass(arr.dtype.type, basestring):
-                    arr = np.array(data, dtype=object, copy=True)
-
-                data = arr
-
-            if data.ndim == 1:
-                data = data.reshape((len(data), 1))
-            elif data.ndim != 2:
-                raise Exception('Must pass 2-d input!')
-
-            if columns is None:
-                raise Exception('Must pass column names with array!')
-            if index is None:
-                raise Exception('Must pass index with array!')
-
             self._series, self.index = self._initMatrix(data, index,
                                                         columns, dtype)
 
@@ -176,6 +159,23 @@ class DataFrame(Picklable, Groupable):
         return index
 
     def _initMatrix(self, data, index, columns, dtype):
+        if not isinstance(data, np.ndarray):
+            arr = np.array(data)
+            if issubclass(arr.dtype.type, basestring):
+                arr = np.array(data, dtype=object, copy=True)
+
+            data = arr
+
+        if data.ndim == 1:
+            data = data.reshape((len(data), 1))
+        elif data.ndim != 2:
+            raise Exception('Must pass 2-d input!')
+
+        if columns is None:
+            raise Exception('Must pass column names')
+        if index is None:
+            raise Exception('Must pass index')
+
         N, K = data.shape
 
         if len(index) != N:
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 4bb34e558..94201b554 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -49,7 +49,7 @@ class DataMatrix(DataFrame):
             (index, columns,
              values, objects) = self._initDict(data, index, columns, objects,
                                                dtype)
-        elif isinstance(data, np.ndarray):
+        elif isinstance(data, (np.ndarray, list)):
             (index, columns, values) = self._initMatrix(data, index,
                                                         columns, dtype)
 
@@ -169,19 +169,20 @@ class DataMatrix(DataFrame):
 
         return index, columns, values, objects
 
-    def _initMatrix(self, data, index, columns, dtype):
-        if data.ndim == 1:
-            N = data.shape[0]
+    def _initMatrix(self, values, index, columns, dtype):
+        if not isinstance(values, np.ndarray):
+            arr = np.array(values)
+            if issubclass(arr.dtype.type, basestring):
+                arr = np.array(values, dtype=object, copy=True)
+
+            values = arr
+
+        if values.ndim == 1:
+            N = values.shape[0]
             if N == 0:
-                data = data.reshape((data.shape[0], 0))
+                values = values.reshape((values.shape[0], 0))
             else:
-                data = data.reshape((data.shape[0], 1))
-
-        if issubclass(data.dtype.type, (np.str_, np.object_)):
-            values = np.asarray(data, dtype=object)
-        else:
-            # We're allowing things to be boolean
-            values = np.asarray(data)
+                values = values.reshape((values.shape[0], 1))
 
         if dtype is not None:
             try:
@@ -190,13 +191,13 @@ class DataMatrix(DataFrame):
                 pass
 
         if index is None:
-            if data.shape[0] == 0:
+            if values.shape[0] == 0:
                 index = NULL_INDEX
             else:
                 raise Exception('Must pass index!')
 
         if columns is None:
-            if data.shape[1] == 0:
+            if values.shape[1] == 0:
                 columns = NULL_INDEX
             else:
                 raise Exception('Must pass columns!')
diff --git a/pandas/core/series.py b/pandas/core/series.py
index def5445c0..cff289a86 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -3,7 +3,7 @@ Data structure for 1-dimensional cross-sectional and time series data
 """
 
 # pylint: disable-msg=E1101,E1103
-# pylint: disable-msg=W0703
+# pylint: disable-msg=W0703,W0622
 
 import itertools
 import sys
diff --git a/pandas/core/tests/test_daterange.py b/pandas/core/tests/test_daterange.py
index 68122ae90..99aca3e1c 100644
--- a/pandas/core/tests/test_daterange.py
+++ b/pandas/core/tests/test_daterange.py
@@ -3,7 +3,7 @@ import unittest
 
 import numpy as np
 
-from pandas.core.datetools import bday
+import pandas.core.datetools as datetools
 from pandas.core.daterange import DateRange, XDateRange
 from pandas.util.testing import assert_almost_equal
 
@@ -32,17 +32,78 @@ def testXDateRange3():
                       toDate = datetime(2008, 1, 6)),
                  [])
 
+START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
+
+class TestXDateRange(unittest.TestCase):
+    def test_constructor(self):
+        rng = XDateRange(START, END, offset=datetools.bday)
+        self.assertEquals(rng.timeRule, 'WEEKDAY')
+
+        rng = XDateRange(START, END, timeRule='WEEKDAY')
+        self.assertEquals(rng.offset, datetools.bday)
 
 class TestDateRange(unittest.TestCase):
-    pass
+    def setUp(self):
+        self.rng = DateRange(START, END, offset=datetools.bday)
+
+    def test_constructor(self):
+        rng = DateRange(START, END, offset=datetools.bday)
+
+        rng = DateRange(START, periods=20, offset=datetools.bday)
+
+        rng = DateRange(toDate=START, periods=20, offset=datetools.bday)
+
+    def test_getCachedRange(self):
+        rng = DateRange.getCachedRange(START, END, offset=datetools.bday)
+
+        rng = DateRange.getCachedRange(START, periods=20, offset=datetools.bday)
+
+        rng = DateRange.getCachedRange(end=START, periods=20,
+                                       offset=datetools.bday)
+
+        self.assertRaises(Exception, DateRange.getCachedRange, START, END)
+
+        self.assertRaises(Exception, DateRange.getCachedRange, START,
+                          offset=datetools.bday)
+
+        self.assertRaises(Exception, DateRange.getCachedRange, end=END,
+                          offset=datetools.bday)
+
+        self.assertRaises(Exception, DateRange.getCachedRange, periods=20,
+                          offset=datetools.bday)
+
+    def test_comparison(self):
+        d = self.rng[10]
+
+        comp = self.rng > d
+        self.assert_(comp[11])
+        self.assert_(not comp[9])
+
+    def test_repr(self):
+        foo = repr(self.rng)
+
+    def test_getitem(self):
+        sliced = self.rng[10:20]
+
+        sliced = self.rng[::5]
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        self.assertEquals(len(fancy_indexed), 5)
+        self.assert_(not isinstance(fancy_indexed, DateRange))
+
+    def test_shift(self):
+        shifted = self.rng.shift(5)
+
+        shifted = self.rng.shift(-5)
 
+        shifted = self.rng.shift(0)
 
 # DateRange test
 
 def testDateRange1():
     toDate = datetime(2009, 5, 13)
     dr = DateRange(toDate=toDate, periods=20)
-    firstDate = toDate - 19 * bday
+    firstDate = toDate - 19 * datetools.bday
 
     assert len(dr) == 20
     assert dr[0] == firstDate
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index b8916b200..a1186e585 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -2,6 +2,7 @@
 from copy import deepcopy
 from datetime import datetime, timedelta
 from cStringIO import StringIO
+import cPickle as pickle
 import os
 import unittest
 
@@ -159,6 +160,9 @@ class TestDataFrame(unittest.TestCase):
         self.assertEqual(len(frame.index), 3)
         self.assertEqual(len(frame.cols()), 1)
 
+        frame = self.klass(['foo', 'bar'], index=[0, 1], columns=['A'])
+        self.assertEqual(len(frame), 2)
+
         # higher dim raise exception
         self.assertRaises(Exception, self.klass, np.zeros((3, 3, 3)),
                           columns=['A', 'B', 'C'], index=[1])
@@ -174,12 +178,7 @@ class TestDataFrame(unittest.TestCase):
         self.assertRaises(Exception, self.klass, mat, index=[1])
         self.assertRaises(Exception, self.klass, mat, columns=['A', 'B', 'C'])
 
-        # weird case that used to succeed
-        self.assertRaises(Exception, self.klass, [], [])
-
     def test_pickle(self):
-        import cPickle as pickle
-
         unpickled = pickle.loads(pickle.dumps(self.mixed_frame))
         assert_frame_equal(self.mixed_frame, unpickled)
 
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 57d2d1cf5..011d152f5 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -189,6 +189,10 @@ class TestSeries(unittest.TestCase):
         self.series[5:7] = np.NaN
         str(self.series)
 
+    def test_toString(self):
+        from cStringIO import StringIO
+        self.ts.toString(buffer=StringIO())
+
     def test_iter(self):
         for i, val in enumerate(self.series):
             self.assertEqual(val, self.series[i])

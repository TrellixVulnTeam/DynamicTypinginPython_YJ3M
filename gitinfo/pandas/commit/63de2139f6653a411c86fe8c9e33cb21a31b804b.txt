commit 63de2139f6653a411c86fe8c9e33cb21a31b804b
Author: PKEuS <philipp.kloke@web.de>
Date:   Fri Aug 23 21:51:04 2013 +0200

    Updated docs
    Fixed docstring of read_stata
    Removed unused imports
    Fixed some bugs in Stata format 117 parsing
    Added unit testing for Stata 13 format

diff --git a/doc/source/io.rst b/doc/source/io.rst
index e2f114a1f..546925cc8 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -2754,7 +2754,7 @@ Writing to STATA format
 .. _io.stata_writer:
 
 The method :func:`~pandas.core.frame.DataFrame.to_stata` will write a DataFrame
-into a .dta file. The format version of this file is always the latest one, 115.
+into a .dta file. The format version of this file is always 115 (Stata 12).
 
 .. ipython:: python
 
@@ -2786,7 +2786,7 @@ read and used to create a ``Categorical`` variable from them. Value labels can
 also be retrieved by the function ``variable_labels``, which requires data to be
 called before (see ``pandas.io.stata.StataReader``).
 
-The StataReader supports .dta Formats 104, 105, 108, 113-115.
+The StataReader supports .dta Formats 104, 105, 108, 113-115 and 117.
 Alternatively, the function :func:`~pandas.io.stata.read_stata` can be used
 
 .. ipython:: python
diff --git a/doc/source/release.rst b/doc/source/release.rst
index 322c4541b..630538e74 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -123,6 +123,7 @@ Improvements to existing features
     without ``MultiIndex`` raises ``ValueError`` (:issue:`4759`, :issue:`4837`)
   - ``read_json`` now raises a (more informative) ``ValueError`` when the dict
     contains a bad key and ``orient='split'`` (:issue:`4730`, :issue:`4838`)
+  - Accept Stata 13 format for reading (:issue:`4291`)
 
 API Changes
 ~~~~~~~~~~~
diff --git a/pandas/io/stata.py b/pandas/io/stata.py
index d5973af16..1d0d1d17e 100644
--- a/pandas/io/stata.py
+++ b/pandas/io/stata.py
@@ -20,22 +20,29 @@ from pandas.core.series import Series
 from pandas.core.categorical import Categorical
 import datetime
 from pandas import compat
-from pandas import compat
-from pandas.compat import StringIO, long, lrange, lmap, lzip
+from pandas.compat import long, lrange, lmap, lzip
 from pandas import isnull
-from pandas.io.parsers import _parser_params, Appender
-from pandas.io.common import get_filepath_or_buffer, maybe_read_encoded_stream
-
-
-_read_stata_doc = """
-Read Stata file into DataFrame
-
-%s
-""" % (_parser_params)
+from pandas.io.common import get_filepath_or_buffer
 
 
-@Appender(_read_stata_doc)
 def read_stata(filepath_or_buffer, convert_dates=True, convert_categoricals=True, encoding=None, index=None):
+    """
+    Read Stata file into DataFrame
+
+    Parameters
+    ----------
+    filepath_or_buffer : string or file-like object
+        Path to .dta file or object implementing a binary read() functions
+    convert_dates : boolean, defaults to True
+        Convert date variables to DataFrame time values
+    convert_categoricals : boolean, defaults to True
+        Read value labels and convert columns to Categorical/Factor variables
+    encoding : string, None or encoding
+        Encoding used to parse the files. Note that Stata doesn't
+        support unicode. None defaults to cp1252.
+    index : identifier of index column
+        identifier of column that should be used as index of the DataFrame
+    """
     reader = StataReader(filepath_or_buffer, encoding)
 
     return reader.data(convert_dates, convert_categoricals, index)
@@ -206,7 +213,7 @@ class StataMissingValue(StringMixin):
 class StataParser(object):
     _default_encoding = 'cp1252'
 
-    def __init__(self, encoding=None):
+    def __init__(self, encoding):
         self._encoding = encoding
 
         #type          code.
@@ -316,7 +323,7 @@ class StataReader(StataParser):
         self._data_read = False
         self._value_labels_read = False
         if isinstance(path_or_buf, str):
-            path_or_buf, encoding = get_filepath_or_buffer(path_or_buf, encoding='cp1252')
+            path_or_buf, encoding = get_filepath_or_buffer(path_or_buf, encoding=self._default_encoding)
 
         if isinstance(path_or_buf, (str, compat.text_type, bytes)):
             self.path_or_buf = open(path_or_buf, 'rb')
@@ -327,13 +334,13 @@ class StataReader(StataParser):
 
     def _read_header(self):
         first_char = self.path_or_buf.read(1)
-        if struct.unpack('c', first_char)[0] is b'<':  # format 117 or higher (XML like)
+        if struct.unpack('c', first_char)[0] == b'<':  # format 117 or higher (XML like)
             self.path_or_buf.read(27)  # stata_dta><header><release>
             self.format_version = int(self.path_or_buf.read(3))
             if self.format_version not in [117]:
                 raise ValueError("Version of given Stata file is not 104, 105, 108, 113 (Stata 8/9), 114 (Stata 10/11), 115 (Stata 12) or 117 (Stata 13)")
             self.path_or_buf.read(21)  # </release><byteorder>
-            self.byteorder = self.path_or_buf.read(3) == "LSF" and '>' or '<'
+            self.byteorder = self.path_or_buf.read(3) == "MSF" and '>' or '<'
             self.path_or_buf.read(15)  # </byteorder><K>
             self.nvar = struct.unpack(self.byteorder + 'H', self.path_or_buf.read(2))[0]
             self.path_or_buf.read(7)  # </K><N>
@@ -566,7 +573,7 @@ class StataReader(StataParser):
 
         while True:
             if self.format_version >= 117:
-                if self._decode_bytes(self.path_or_buf.read(5), self._encoding) == '</val':  # <lbl>
+                if self.path_or_buf.read(5) == b'</val':  # <lbl>
                     break  # end o f variable lable table
 
             slength = self.path_or_buf.read(4)
@@ -596,7 +603,7 @@ class StataReader(StataParser):
         self.path_or_buf.seek(self.seek_strls)
         self.GSO = dict()
         while True:
-            if self.path_or_buf.read(3) is not 'GSO':
+            if self.path_or_buf.read(3) != b'GSO':
                 break
 
             v_o = struct.unpack(self.byteorder + 'L', self.path_or_buf.read(8))[0]
diff --git a/pandas/io/tests/data/stata1_v13.dta b/pandas/io/tests/data/stata1_v13.dta
new file mode 100644
index 000000000..18014cec7
Binary files /dev/null and b/pandas/io/tests/data/stata1_v13.dta differ
diff --git a/pandas/io/tests/data/stata2_v13.dta b/pandas/io/tests/data/stata2_v13.dta
new file mode 100644
index 000000000..5e507b38a
Binary files /dev/null and b/pandas/io/tests/data/stata2_v13.dta differ
diff --git a/pandas/io/tests/data/stata3_v13.dta b/pandas/io/tests/data/stata3_v13.dta
new file mode 100644
index 000000000..27e38bbed
Binary files /dev/null and b/pandas/io/tests/data/stata3_v13.dta differ
diff --git a/pandas/io/tests/data/stata4_v13.dta b/pandas/io/tests/data/stata4_v13.dta
new file mode 100644
index 000000000..412c2c0d7
Binary files /dev/null and b/pandas/io/tests/data/stata4_v13.dta differ
diff --git a/pandas/io/tests/test_stata.py b/pandas/io/tests/test_stata.py
index ef0773616..0a87ada70 100644
--- a/pandas/io/tests/test_stata.py
+++ b/pandas/io/tests/test_stata.py
@@ -33,6 +33,11 @@ class StataTests(unittest.TestCase):
         self.dta9 = os.path.join(self.dirpath, 'lbw.dta')
         self.csv9 = os.path.join(self.dirpath, 'lbw.csv')
         self.dta_encoding = os.path.join(self.dirpath, 'stata1_encoding.dta')
+        self.dta1_13 = os.path.join(self.dirpath, 'stata1_v13.dta')
+        self.dta2_13 = os.path.join(self.dirpath, 'stata2_v13.dta')
+        self.dta3_13 = os.path.join(self.dirpath, 'stata3_v13.dta')
+        self.dta4_13 = os.path.join(self.dirpath, 'stata4_v13.dta')
+
     def read_dta(self, file):
         return read_stata(file, convert_dates=True)
 
@@ -42,6 +47,8 @@ class StataTests(unittest.TestCase):
     def test_read_dta1(self):
         reader = StataReader(self.dta1)
         parsed = reader.data()
+        reader_13 = StataReader(self.dta1_13)
+        parsed_13 = reader_13.data()
         # Pandas uses np.nan as missing value.
         # Thus, all columns will be of type float, regardless of their name.
         expected = DataFrame([(np.nan, np.nan, np.nan, np.nan, np.nan)],
@@ -51,7 +58,9 @@ class StataTests(unittest.TestCase):
         # this is an oddity as really the nan should be float64, but
         # the casting doesn't fail so need to match stata here
         expected['float_miss'] = expected['float_miss'].astype(np.float32)
+
         tm.assert_frame_equal(parsed, expected)
+        tm.assert_frame_equal(parsed_13, expected)
 
     def test_read_dta2(self):
         expected = DataFrame.from_records(
@@ -94,25 +103,29 @@ class StataTests(unittest.TestCase):
 
         with warnings.catch_warnings(record=True) as w:
             parsed = self.read_dta(self.dta2)
+            parsed_13 = self.read_dta(self.dta2_13)
             np.testing.assert_equal(
                 len(w), 1)  # should get a warning for that format.
 
         tm.assert_frame_equal(parsed, expected)
+        tm.assert_frame_equal(parsed_13, expected)
 
     def test_read_dta3(self):
-
         parsed = self.read_dta(self.dta3)
+        parsed_13 = self.read_dta(self.dta3_13)
 
         # match stata here
         expected = self.read_csv(self.csv3)
         expected = expected.astype(np.float32)
         expected['year'] = expected['year'].astype(np.int32)
-        expected['quarter']= expected['quarter'].astype(np.int16)
+        expected['quarter'] = expected['quarter'].astype(np.int16)
 
-        tm.assert_frame_equal(parsed,expected)
+        tm.assert_frame_equal(parsed, expected)
+        tm.assert_frame_equal(parsed_13, expected)
 
     def test_read_dta4(self):
         parsed = self.read_dta(self.dta4)
+        parsed_13 = self.read_dta(self.dta4_13)
         expected = DataFrame.from_records(
             [
                 ["one", "ten", "one", "one", "one"],
@@ -130,6 +143,7 @@ class StataTests(unittest.TestCase):
                      'labeled_with_missings', 'float_labelled'])
 
         tm.assert_frame_equal(parsed, expected)
+        tm.assert_frame_equal(parsed_13, expected)
 
     def test_read_write_dta5(self):
         if not is_little_endian():
@@ -177,7 +191,7 @@ class StataTests(unittest.TestCase):
     def test_read_dta9(self):
         expected = read_csv(self.csv9, parse_dates=True, sep='\t')
         parsed = self.read_dta(self.dta9)
-        assert_frame_equal(parsed, expected)
+        tm.assert_frame_equal(parsed, expected)
 
     def test_read_write_dta10(self):
         if not is_little_endian():
@@ -197,17 +211,6 @@ class StataTests(unittest.TestCase):
             tm.assert_frame_equal(written_and_read_again.set_index('index'),
                                   original)
 
-    def test_read_dta11(self):
-        reader = StataReader(self.dta11)
-        parsed = reader.data()
-        # Pandas uses np.nan as missing value.
-        # Thus, all columns will be of type float, regardless of their name.
-        expected = DataFrame([(np.nan, np.nan, np.nan, np.nan, np.nan)],
-                             columns=['float_miss', 'double_miss', 'byte_miss',
-                                      'int_miss', 'long_miss'])
-
-        tm.assert_frame_equal(parsed, expected)
-
     def test_stata_doc_examples(self):
         with tm.ensure_clean() as path:
             df = DataFrame(np.random.randn(10, 2), columns=list('AB'))
@@ -223,11 +226,11 @@ class StataTests(unittest.TestCase):
         if compat.PY3:
             expected = raw.kreis1849[0]
             self.assert_(result == expected)
-            self.assert_(isinstance(result,compat.string_types))
+            self.assert_(isinstance(result, compat.string_types))
         else:
             expected = raw.kreis1849.str.decode("latin-1")[0]
             self.assert_(result == expected)
-            self.assert_(isinstance(result,unicode))
+            self.assert_(isinstance(result, unicode))
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],

commit 6bc1cf4b5518b4cd909ea1f3b1663bf35ed2ec0f
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Jul 7 09:13:39 2019 -0500

    Remove unused SparseArray code (#27269)

diff --git a/pandas/core/arrays/sparse.py b/pandas/core/arrays/sparse.py
index 2332da465..65976021f 100644
--- a/pandas/core/arrays/sparse.py
+++ b/pandas/core/arrays/sparse.py
@@ -1774,7 +1774,6 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
             else:
                 other = np.asarray(other)
                 with np.errstate(all="ignore"):
-                    # TODO: delete sparse stuff in core/ops.py
                     # TODO: look into _wrap_result
                     if len(self) != len(other):
                         raise AssertionError(
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index df2907bf5..545f98a02 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -1401,12 +1401,6 @@ def _get_method_wrappers(cls):
         arith_special = _arith_method_SERIES
         comp_special = _comp_method_SERIES
         bool_special = _bool_method_SERIES
-    elif issubclass(cls, ABCSparseArray):
-        arith_flex = None
-        comp_flex = None
-        arith_special = _arith_method_SPARSE_ARRAY
-        comp_special = _arith_method_SPARSE_ARRAY
-        bool_special = _arith_method_SPARSE_ARRAY
     elif issubclass(cls, ABCDataFrame):
         # Same for DataFrame and SparseDataFrame
         arith_flex = _arith_method_FRAME
@@ -2336,47 +2330,6 @@ def _sparse_series_op(left, right, op, name):
     return left._constructor(result, index=new_index, name=new_name)
 
 
-def _arith_method_SPARSE_ARRAY(cls, op, special):
-    """
-    Wrapper function for Series arithmetic operations, to avoid
-    code duplication.
-    """
-    op_name = _get_op_name(op, special)
-
-    def wrapper(self, other):
-        from pandas.core.arrays.sparse.array import (
-            SparseArray,
-            _sparse_array_op,
-            _wrap_result,
-            _get_fill,
-        )
-
-        if isinstance(other, np.ndarray):
-            if len(self) != len(other):
-                raise AssertionError(
-                    "length mismatch: {self} vs. {other}".format(
-                        self=len(self), other=len(other)
-                    )
-                )
-            if not isinstance(other, SparseArray):
-                dtype = getattr(other, "dtype", None)
-                other = SparseArray(other, fill_value=self.fill_value, dtype=dtype)
-            return _sparse_array_op(self, other, op, op_name)
-        elif is_scalar(other):
-            with np.errstate(all="ignore"):
-                fill = op(_get_fill(self), np.asarray(other))
-                result = op(self.sp_values, other)
-
-            return _wrap_result(op_name, result, self.sp_index, fill)
-        else:  # pragma: no cover
-            raise TypeError(
-                "operation with {other} not supported".format(other=type(other))
-            )
-
-    wrapper.__name__ = op_name
-    return wrapper
-
-
 def maybe_dispatch_ufunc_to_dunder_op(
     self: ArrayLike, ufunc: Callable, method: str, *inputs: ArrayLike, **kwargs: Any
 ):

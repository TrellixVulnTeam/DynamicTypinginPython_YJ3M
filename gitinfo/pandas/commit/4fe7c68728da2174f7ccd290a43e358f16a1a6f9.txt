commit 4fe7c68728da2174f7ccd290a43e358f16a1a6f9
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Jul 11 09:36:37 2015 -0500

    ERR: Boolean comparisons of a Series vs None will now be equivalent of to null comparisions, rather than raise TypeError, xref, #1079

diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index 45f1412c6..b2ed1d41b 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -231,7 +231,7 @@ Other API Changes
 - Enable serialization of lists and dicts to strings in ExcelWriter (:issue:`8188`)
 - Allow passing `kwargs` to the interpolation methods (:issue:`10378`).
 - Serialize metadata properties of subclasses of pandas objects (:issue:`10553`).
-
+- Boolean comparisons of a ``Series`` vs None will now be equivalent to comparing with np.nan, rather than raise ``TypeError``, xref (:issue:`1079`).
 
 .. _whatsnew_0170.deprecations:
 
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index 0b62eb1e5..0a0cf9817 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -13,8 +13,11 @@ import pandas.index as _index
 from pandas.util.decorators import Appender
 import pandas.core.common as com
 import pandas.computation.expressions as expressions
+from pandas.lib import isscalar
+from pandas.tslib import iNaT
 from pandas.core.common import(bind_method, is_list_like, notnull, isnull,
-                               _values_from_object, _maybe_match_name)
+                               _values_from_object, _maybe_match_name,
+                               needs_i8_conversion, is_integer_dtype)
 
 # -----------------------------------------------------------------------------
 # Functions that add arithmetic methods to objects, given arithmetic factory
@@ -257,7 +260,7 @@ class _TimeOp(object):
     Generally, you should use classmethod ``maybe_convert_for_time_op`` as an
     entry point.
     """
-    fill_value = tslib.iNaT
+    fill_value = iNaT
     wrap_results = staticmethod(lambda x: x)
     dtype = None
 
@@ -346,7 +349,7 @@ class _TimeOp(object):
             if (other is not None and other.dtype == 'timedelta64[ns]' and
                     all(isnull(v) for v in values)):
                 values = np.empty(values.shape, dtype=other.dtype)
-                values[:] = tslib.iNaT
+                values[:] = iNaT
 
             # a datelike
             elif isinstance(values, pd.DatetimeIndex):
@@ -381,7 +384,7 @@ class _TimeOp(object):
             # all nan, so ok, use the other dtype (e.g. timedelta or datetime)
             if isnull(values).all():
                 values = np.empty(values.shape, dtype=other.dtype)
-                values[:] = tslib.iNaT
+                values[:] = iNaT
             else:
                 raise TypeError(
                     'incompatible type [{0}] for a datetime/timedelta '
@@ -549,12 +552,12 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
         elif com.is_categorical_dtype(y) and not lib.isscalar(y):
             return op(y,x)
 
-        if x.dtype == np.object_:
+        if com.is_object_dtype(x.dtype):
             if isinstance(y, list):
                 y = lib.list_to_object_array(y)
 
             if isinstance(y, (np.ndarray, pd.Series)):
-                if y.dtype != np.object_:
+                if not com.is_object_dtype(y.dtype):
                     result = lib.vec_compare(x, y.astype(np.object_), op)
                 else:
                     result = lib.vec_compare(x, y, op)
@@ -562,13 +565,46 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
                 result = lib.scalar_compare(x, y, op)
         else:
 
+            # numpy does not like comparisons vs None
+            if lib.isscalar(y) and isnull(y):
+                y = np.nan
+
+            # we want to compare like types
+            # we only want to convert to integer like if
+            # we are not NotImplemented, otherwise
+            # we would allow datetime64 (but viewed as i8) against
+            # integer comparisons
+            if needs_i8_conversion(x) and (not isscalar(y) and is_integer_dtype(y)):
+                raise TypeError("invalid type comparison")
+            elif (not isscalar(y) and needs_i8_conversion(y)) and is_integer_dtype(x):
+                raise TypeError("invalid type comparison")
+
+            # we have a datetime/timedelta and may need to convert
+            mask = None
+            if needs_i8_conversion(x) or (not isscalar(y) and needs_i8_conversion(y)):
+
+                if isscalar(y):
+                    y = _index.convert_scalar(x,_values_from_object(y))
+                else:
+                    y = y.view('i8')
+
+                if name == '__ne__':
+                    mask = notnull(x)
+                else:
+                    mask = isnull(x)
+
+                x = x.view('i8')
+
             try:
                 result = getattr(x, name)(y)
                 if result is NotImplemented:
                     raise TypeError("invalid type comparison")
-            except (AttributeError):
+            except AttributeError:
                 result = op(x, y)
 
+            if mask is not None and mask.any():
+                result[mask] = False
+
         return result
 
     def wrapper(self, other, axis=None):
@@ -596,8 +632,6 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
                 raise TypeError(msg.format(op=op,typ=self.dtype))
 
 
-        mask = isnull(self)
-
         if com.is_categorical_dtype(self):
             # cats are a special case as get_values() would return an ndarray, which would then
             # not take categories ordering into account
@@ -605,14 +639,11 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
             res = op(self.values, other)
         else:
             values = self.get_values()
-            other = _index.convert_scalar(values,_values_from_object(other))
-
-            if issubclass(values.dtype.type, (np.datetime64, np.timedelta64)):
-                values = values.view('i8')
+            if is_list_like(other):
+                other = np.asarray(other)
 
-            # scalars
             res = na_op(values, other)
-            if np.isscalar(res):
+            if lib.isscalar(res):
                 raise TypeError('Could not compare %s type with Series'
                                 % type(other))
 
@@ -621,11 +652,6 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
 
         res = pd.Series(res, index=self.index, name=self.name,
                         dtype='bool')
-
-        # mask out the invalids
-        if mask.any():
-            res[mask] = masker
-
         return res
     return wrapper
 
@@ -643,8 +669,7 @@ def _bool_method_SERIES(op, name, str_rep):
                 y = lib.list_to_object_array(y)
 
             if isinstance(y, (np.ndarray, pd.Series)):
-                if (x.dtype == np.bool_ and
-                        y.dtype == np.bool_):  # pragma: no cover
+                if (com.is_bool_dtype(x.dtype) and com.is_bool_dtype(y.dtype)):
                     result = op(x, y)  # when would this be hit?
                 else:
                     x = com._ensure_object(x)
@@ -1046,7 +1071,7 @@ def _arith_method_PANEL(op, name, str_rep=None, fill_zeros=None,
 
     # work only for scalars
     def f(self, other):
-        if not np.isscalar(other):
+        if not lib.isscalar(other):
             raise ValueError('Simple arithmetic with %s can only be '
                              'done with scalar values' %
                              self._constructor.__name__)
diff --git a/pandas/lib.pyx b/pandas/lib.pyx
index 44be74b78..4805a33e5 100644
--- a/pandas/lib.pyx
+++ b/pandas/lib.pyx
@@ -378,7 +378,7 @@ def isnullobj2d_old(ndarray[object, ndim=2] arr):
 @cython.boundscheck(False)
 cpdef ndarray[object] list_to_object_array(list obj):
     '''
-    Convert list to object ndarray. Seriously can't believe I had to write this
+    Convert list to object ndarray. Seriously can\'t believe I had to write this
     function
     '''
     cdef:
@@ -682,6 +682,7 @@ def scalar_compare(ndarray[object] values, object val, object op):
     cdef:
         Py_ssize_t i, n = len(values)
         ndarray[uint8_t, cast=True] result
+        bint isnull_val
         int flag
         object x
 
@@ -701,12 +702,15 @@ def scalar_compare(ndarray[object] values, object val, object op):
         raise ValueError('Unrecognized operator')
 
     result = np.empty(n, dtype=bool).view(np.uint8)
+    isnull_val = _checknull(val)
 
     if flag == cpython.Py_NE:
         for i in range(n):
             x = values[i]
             if _checknull(x):
                 result[i] = True
+            elif isnull_val:
+                result[i] = True
             else:
                 try:
                     result[i] = cpython.PyObject_RichCompareBool(x, val, flag)
@@ -717,6 +721,8 @@ def scalar_compare(ndarray[object] values, object val, object op):
             x = values[i]
             if _checknull(x):
                 result[i] = False
+            elif isnull_val:
+                result[i] = False
             else:
                 try:
                     result[i] = cpython.PyObject_RichCompareBool(x, val, flag)
@@ -728,6 +734,8 @@ def scalar_compare(ndarray[object] values, object val, object op):
             x = values[i]
             if _checknull(x):
                 result[i] = False
+            elif isnull_val:
+                result[i] = False
             else:
                 result[i] = cpython.PyObject_RichCompareBool(x, val, flag)
 
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index e17910a2e..db23b13ed 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -12,6 +12,7 @@ from pandas.util.testing import assertRaisesRegexp, assertIsInstance
 from pandas.tseries.common import is_datetimelike
 from pandas import Series, Index, Int64Index, DatetimeIndex, TimedeltaIndex, PeriodIndex, Timedelta
 import pandas.tslib as tslib
+from pandas import _np_version_under1p9
 import nose
 
 import pandas.util.testing as tm
@@ -273,6 +274,45 @@ class TestIndexOps(Ops):
         self.is_valid_objs  = [ o for o in self.objs if o._allow_index_ops ]
         self.not_valid_objs = [ o for o in self.objs if not o._allow_index_ops ]
 
+    def test_none_comparison(self):
+
+        # bug brought up by #1079
+        # changed from TypeError in 0.17.0
+        for o in self.is_valid_objs:
+            if isinstance(o, Series):
+
+                o[0] = np.nan
+
+                result = o == None
+                self.assertFalse(result.iat[0])
+                self.assertFalse(result.iat[1])
+
+                result = o != None
+                self.assertTrue(result.iat[0])
+                self.assertTrue(result.iat[1])
+
+                result = None == o
+                self.assertFalse(result.iat[0])
+                self.assertFalse(result.iat[1])
+
+                if _np_version_under1p9:
+                    # fails as this tries not __eq__ which
+                    # is not valid for numpy
+                    pass
+                else:
+                    result = None != o
+                    self.assertTrue(result.iat[0])
+                    self.assertTrue(result.iat[1])
+
+                result = None > o
+                self.assertFalse(result.iat[0])
+                self.assertFalse(result.iat[1])
+
+                result = o < None
+                self.assertFalse(result.iat[0])
+                self.assertFalse(result.iat[1])
+
+
     def test_ndarray_compat_properties(self):
 
         for o in self.objs:
@@ -513,7 +553,7 @@ class TestIndexOps(Ops):
             expected = Series([4, 3, 2], index=['b', 'a', 'd'])
             tm.assert_series_equal(s.value_counts(), expected)
 
-            self.assert_numpy_array_equal(s.unique(), np.array(['a', 'b', np.nan, 'd'], dtype='O'))
+            self.assert_numpy_array_equivalent(s.unique(), np.array(['a', 'b', np.nan, 'd'], dtype='O'))
             self.assertEqual(s.nunique(), 3)
 
             s = klass({})
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 3d901837f..569f7d848 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -10,14 +10,13 @@ import warnings
 import os
 
 import numpy as np
-from numpy.testing import assert_array_equal
 
 from pandas import (period_range, date_range, Categorical, Series,
                     Index, Float64Index, Int64Index, MultiIndex,
                     CategoricalIndex, DatetimeIndex, TimedeltaIndex, PeriodIndex)
 from pandas.core.index import InvalidIndexError, NumericIndex
 from pandas.util.testing import (assert_almost_equal, assertRaisesRegexp,
-                                 assert_copy)
+                                 assert_copy, assert_numpy_array_equivalent, assert_numpy_array_equal)
 from pandas import compat
 from pandas.compat import long, is_platform_windows
 
@@ -101,7 +100,7 @@ class Base(object):
         expected = np.arange(idx.size)
 
         actual = idx.get_indexer(idx)
-        assert_array_equal(expected, actual)
+        assert_numpy_array_equivalent(expected, actual)
 
         with tm.assertRaisesRegexp(ValueError, 'Invalid fill method'):
             idx.get_indexer(idx, method='invalid')
@@ -449,7 +448,7 @@ class TestIndex(Base, tm.TestCase):
         index = Index(arr, copy=True, name='name')
         tm.assertIsInstance(index, Index)
         self.assertEqual(index.name, 'name')
-        assert_array_equal(arr, index)
+        assert_numpy_array_equivalent(arr, index)
         arr[0] = "SOMEBIGLONGSTRING"
         self.assertNotEqual(index[0], "SOMEBIGLONGSTRING")
 
@@ -506,7 +505,7 @@ class TestIndex(Base, tm.TestCase):
     def test_index_ctor_infer_periodindex(self):
         xp = period_range('2012-1-1', freq='M', periods=3)
         rs = Index(xp)
-        assert_array_equal(rs, xp)
+        assert_numpy_array_equivalent(rs, xp)
         tm.assertIsInstance(rs, PeriodIndex)
 
     def test_constructor_simple_new(self):
@@ -1111,11 +1110,11 @@ class TestIndex(Base, tm.TestCase):
         all_methods = ['pad', 'backfill', 'nearest']
         for method in all_methods:
             actual = idx.get_indexer([0, 5, 9], method=method)
-            self.assert_array_equal(actual, [0, 5, 9])
+            self.assert_numpy_array_equivalent(actual, [0, 5, 9])
 
         for method, expected in zip(all_methods, [[0, 1, 8], [1, 2, 9], [0, 2, 9]]):
             actual = idx.get_indexer([0.2, 1.8, 8.5], method=method)
-            self.assert_array_equal(actual, expected)
+            self.assert_numpy_array_equivalent(actual, expected)
 
         with tm.assertRaisesRegexp(ValueError, 'limit argument'):
             idx.get_indexer([1, 0], method='nearest', limit=1)
@@ -1126,22 +1125,22 @@ class TestIndex(Base, tm.TestCase):
         all_methods = ['pad', 'backfill', 'nearest']
         for method in all_methods:
             actual = idx.get_indexer([0, 5, 9], method=method)
-            self.assert_array_equal(actual, [9, 4, 0])
+            self.assert_numpy_array_equivalent(actual, [9, 4, 0])
 
         for method, expected in zip(all_methods, [[8, 7, 0], [9, 8, 1], [9, 7, 0]]):
             actual = idx.get_indexer([0.2, 1.8, 8.5], method=method)
-            self.assert_array_equal(actual, expected)
+            self.assert_numpy_array_equivalent(actual, expected)
 
     def test_get_indexer_strings(self):
         idx = pd.Index(['b', 'c'])
 
         actual = idx.get_indexer(['a', 'b', 'c', 'd'], method='pad')
         expected = [-1, 0, 1, 1]
-        self.assert_array_equal(actual, expected)
+        self.assert_numpy_array_equivalent(actual, expected)
 
         actual = idx.get_indexer(['a', 'b', 'c', 'd'], method='backfill')
         expected = [0, 0, 1, -1]
-        self.assert_array_equal(actual, expected)
+        self.assert_numpy_array_equivalent(actual, expected)
 
         with tm.assertRaises(TypeError):
             idx.get_indexer(['a', 'b', 'c', 'd'], method='nearest')
@@ -1447,7 +1446,7 @@ class TestIndex(Base, tm.TestCase):
         # test boolean case, should return np.array instead of boolean Index
         idx = Index(['a1', 'a2', 'b1', 'b2'])
         expected = np.array([True, True, False, False])
-        self.assert_array_equal(idx.str.startswith('a'), expected)
+        self.assert_numpy_array_equivalent(idx.str.startswith('a'), expected)
         self.assertIsInstance(idx.str.startswith('a'), np.ndarray)
         s = Series(range(4), index=idx)
         expected = Series(range(2), index=['a1', 'a2'])
@@ -1557,8 +1556,8 @@ class TestIndex(Base, tm.TestCase):
         index_d = Index(['foo'])
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
             index_a == index_b
-        assert_array_equal(index_a == index_a, np.array([True, True, True]))
-        assert_array_equal(index_a == index_c, np.array([True, True, False]))
+        assert_numpy_array_equivalent(index_a == index_a, np.array([True, True, True]))
+        assert_numpy_array_equivalent(index_a == index_c, np.array([True, True, False]))
 
         # test comparisons with numpy arrays
         array_a = np.array(['foo', 'bar', 'baz'])
@@ -1567,8 +1566,8 @@ class TestIndex(Base, tm.TestCase):
         array_d = np.array(['foo'])
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
             index_a == array_b
-        assert_array_equal(index_a == array_a, np.array([True, True, True]))
-        assert_array_equal(index_a == array_c, np.array([True, True, False]))
+        assert_numpy_array_equivalent(index_a == array_a, np.array([True, True, True]))
+        assert_numpy_array_equivalent(index_a == array_c, np.array([True, True, False]))
 
         # test comparisons with Series
         series_a = Series(['foo', 'bar', 'baz'])
@@ -1577,8 +1576,8 @@ class TestIndex(Base, tm.TestCase):
         series_d = Series(['foo'])
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
             index_a == series_b
-        assert_array_equal(index_a == series_a, np.array([True, True, True]))
-        assert_array_equal(index_a == series_c, np.array([True, True, False]))
+        assert_numpy_array_equivalent(index_a == series_a, np.array([True, True, True]))
+        assert_numpy_array_equivalent(index_a == series_c, np.array([True, True, False]))
 
         # cases where length is 1 for one of them
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
@@ -1593,27 +1592,26 @@ class TestIndex(Base, tm.TestCase):
             series_a == array_d
 
         # comparing with scalar should broadcast
-        assert_array_equal(index_a == 'foo', np.array([True, False, False]))
-        assert_array_equal(series_a == 'foo', np.array([True, False, False]))
-        assert_array_equal(array_a == 'foo', np.array([True, False, False]))
+        assert_numpy_array_equivalent(index_a == 'foo', np.array([True, False, False]))
+        assert_numpy_array_equivalent(series_a == 'foo', np.array([True, False, False]))
+        assert_numpy_array_equivalent(array_a == 'foo', np.array([True, False, False]))
 
         # GH9785
         # test comparisons of multiindex
         from pandas.compat import StringIO
         df = pd.read_csv(StringIO('a,b,c\n1,2,3\n4,5,6'), index_col=[0, 1])
-        assert_array_equal(df.index == df.index, np.array([True, True]))
+        assert_numpy_array_equivalent(df.index == df.index, np.array([True, True]))
 
         mi1 = MultiIndex.from_tuples([(1, 2), (4, 5)])
-        assert_array_equal(df.index == mi1, np.array([True, True]))
+        assert_numpy_array_equivalent(df.index == mi1, np.array([True, True]))
         mi2 = MultiIndex.from_tuples([(1, 2), (4, 6)])
-        assert_array_equal(df.index == mi2, np.array([True, False]))
+        assert_numpy_array_equivalent(df.index == mi2, np.array([True, False]))
         mi3 = MultiIndex.from_tuples([(1, 2), (4, 5), (8, 9)])
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
             df.index == mi3
         with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
             df.index == index_a
-        assert_array_equal(index_a == mi3, np.array([False, False, False]))
-
+        assert_numpy_array_equivalent(index_a == mi3, np.array([False, False, False]))
 
 class TestCategoricalIndex(Base, tm.TestCase):
     _holder = CategoricalIndex
@@ -1868,7 +1866,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
         expected = np.array([4,0,1,5,2,3])
 
         actual = idx.get_indexer(idx)
-        assert_array_equal(expected, actual)
+        assert_numpy_array_equivalent(expected, actual)
 
         with tm.assertRaisesRegexp(ValueError, 'Invalid fill method'):
             idx.get_indexer(idx, method='invalid')
@@ -1883,7 +1881,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
             expected = oidx.get_indexer_non_unique(finder)[0]
 
             actual = ci.get_indexer(finder)
-            assert_array_equal(expected, actual)
+            assert_numpy_array_equivalent(expected, actual)
 
     def test_duplicates(self):
 
@@ -2184,12 +2182,12 @@ class TestFloat64Index(Numeric, tm.TestCase):
 
     def test_get_indexer(self):
         idx = Float64Index([0.0, 1.0, 2.0])
-        self.assert_array_equal(idx.get_indexer(idx), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(idx), [0, 1, 2])
 
         target = [-0.1, 0.5, 1.1]
-        self.assert_array_equal(idx.get_indexer(target, 'pad'), [-1, 0, 1])
-        self.assert_array_equal(idx.get_indexer(target, 'backfill'), [0, 1, 2])
-        self.assert_array_equal(idx.get_indexer(target, 'nearest'), [0, 1, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'pad'), [-1, 0, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'backfill'), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'nearest'), [0, 1, 1])
 
     def test_get_loc(self):
         idx = Float64Index([0.0, 1.0, 2.0])
@@ -2227,15 +2225,15 @@ class TestFloat64Index(Numeric, tm.TestCase):
 
     def test_nan_multiple_containment(self):
         i = Float64Index([1.0, np.nan])
-        np.testing.assert_array_equal(i.isin([1.0]), np.array([True, False]))
-        np.testing.assert_array_equal(i.isin([2.0, np.pi]),
+        assert_numpy_array_equivalent(i.isin([1.0]), np.array([True, False]))
+        assert_numpy_array_equivalent(i.isin([2.0, np.pi]),
                                       np.array([False, False]))
-        np.testing.assert_array_equal(i.isin([np.nan]),
+        assert_numpy_array_equivalent(i.isin([np.nan]),
                                       np.array([False, True]))
-        np.testing.assert_array_equal(i.isin([1.0, np.nan]),
+        assert_numpy_array_equivalent(i.isin([1.0, np.nan]),
                                       np.array([True, True]))
         i = Float64Index([1.0, 2.0])
-        np.testing.assert_array_equal(i.isin([np.nan]),
+        assert_numpy_array_equivalent(i.isin([np.nan]),
                                       np.array([False, False]))
 
     def test_astype_from_object(self):
@@ -2784,19 +2782,19 @@ class TestDatetimeIndex(DatetimeLike, tm.TestCase):
 
         # time indexing
         idx = pd.date_range('2000-01-01', periods=24, freq='H')
-        assert_array_equal(idx.get_loc(time(12)), [12])
-        assert_array_equal(idx.get_loc(time(12, 30)), [])
+        assert_numpy_array_equivalent(idx.get_loc(time(12)), [12])
+        assert_numpy_array_equivalent(idx.get_loc(time(12, 30)), [])
         with tm.assertRaises(NotImplementedError):
             idx.get_loc(time(12, 30), method='pad')
 
     def test_get_indexer(self):
         idx = pd.date_range('2000-01-01', periods=3)
-        self.assert_array_equal(idx.get_indexer(idx), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(idx), [0, 1, 2])
 
         target = idx[0] + pd.to_timedelta(['-1 hour', '12 hours', '1 day 1 hour'])
-        self.assert_array_equal(idx.get_indexer(target, 'pad'), [-1, 0, 1])
-        self.assert_array_equal(idx.get_indexer(target, 'backfill'), [0, 1, 2])
-        self.assert_array_equal(idx.get_indexer(target, 'nearest'), [0, 1, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'pad'), [-1, 0, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'backfill'), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'nearest'), [0, 1, 1])
 
     def test_roundtrip_pickle_with_tz(self):
 
@@ -2826,7 +2824,7 @@ class TestDatetimeIndex(DatetimeLike, tm.TestCase):
             ts = pd.Series(np.random.randn(n), index=idx)
             i = np.arange(start, n, step)
 
-            tm.assert_array_equal(ts.index.get_loc(key), i)
+            tm.assert_numpy_array_equivalent(ts.index.get_loc(key), i)
             tm.assert_series_equal(ts[key], ts.iloc[i])
 
             left, right = ts.copy(), ts.copy()
@@ -2906,13 +2904,13 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
 
     def test_get_indexer(self):
         idx = pd.period_range('2000-01-01', periods=3).asfreq('H', how='start')
-        self.assert_array_equal(idx.get_indexer(idx), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(idx), [0, 1, 2])
 
         target = pd.PeriodIndex(['1999-12-31T23', '2000-01-01T12',
                                  '2000-01-02T01'], freq='H')
-        self.assert_array_equal(idx.get_indexer(target, 'pad'), [-1, 0, 1])
-        self.assert_array_equal(idx.get_indexer(target, 'backfill'), [0, 1, 2])
-        self.assert_array_equal(idx.get_indexer(target, 'nearest'), [0, 1, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'pad'), [-1, 0, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'backfill'), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'nearest'), [0, 1, 1])
 
         with self.assertRaisesRegexp(ValueError, 'different freq'):
             idx.asfreq('D').get_indexer(idx)
@@ -2950,12 +2948,12 @@ class TestTimedeltaIndex(DatetimeLike, tm.TestCase):
 
     def test_get_indexer(self):
         idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
-        self.assert_array_equal(idx.get_indexer(idx), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(idx), [0, 1, 2])
 
         target = pd.to_timedelta(['-1 hour', '12 hours', '1 day 1 hour'])
-        self.assert_array_equal(idx.get_indexer(target, 'pad'), [-1, 0, 1])
-        self.assert_array_equal(idx.get_indexer(target, 'backfill'), [0, 1, 2])
-        self.assert_array_equal(idx.get_indexer(target, 'nearest'), [0, 1, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'pad'), [-1, 0, 1])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'backfill'), [0, 1, 2])
+        self.assert_numpy_array_equivalent(idx.get_indexer(target, 'nearest'), [0, 1, 1])
 
     def test_numeric_compat(self):
 
@@ -3535,7 +3533,7 @@ class TestMultiIndex(Base, tm.TestCase):
                   ('buz', 'a'), ('buz', 'b'), ('buz', 'c')]
         expected = MultiIndex.from_tuples(tuples, names=names)
 
-        assert_array_equal(result, expected)
+        assert_numpy_array_equivalent(result, expected)
         self.assertEqual(result.names, names)
 
     def test_from_product_datetimeindex(self):
@@ -3545,7 +3543,7 @@ class TestMultiIndex(Base, tm.TestCase):
                                               (1, pd.Timestamp('2000-01-02')),
                                               (2, pd.Timestamp('2000-01-01')),
                                               (2, pd.Timestamp('2000-01-02'))])
-        assert_array_equal(mi.values, etalon)
+        assert_numpy_array_equivalent(mi.values, etalon)
 
     def test_values_boxed(self):
         tuples = [(1, pd.Timestamp('2000-01-01')),
@@ -3555,9 +3553,9 @@ class TestMultiIndex(Base, tm.TestCase):
                   (2, pd.Timestamp('2000-01-02')),
                   (3, pd.Timestamp('2000-01-03'))]
         mi = pd.MultiIndex.from_tuples(tuples)
-        assert_array_equal(mi.values, pd.lib.list_to_object_array(tuples))
+        assert_numpy_array_equivalent(mi.values, pd.lib.list_to_object_array(tuples))
         # Check that code branches for boxed values produce identical results
-        assert_array_equal(mi.values[:4], mi[:4].values)
+        assert_numpy_array_equivalent(mi.values[:4], mi[:4].values)
 
     def test_append(self):
         result = self.index[:3].append(self.index[3:])
@@ -3597,28 +3595,28 @@ class TestMultiIndex(Base, tm.TestCase):
         index = pd.MultiIndex.from_arrays(arrays)
         values = index.get_level_values(1)
         expected = [1, np.nan, 2]
-        assert_array_equal(values.values.astype(float), expected)
+        assert_numpy_array_equivalent(values.values.astype(float), expected)
 
         arrays = [['a', 'b', 'b'], [np.nan, np.nan, 2]]
         index = pd.MultiIndex.from_arrays(arrays)
         values = index.get_level_values(1)
         expected = [np.nan, np.nan, 2]
-        assert_array_equal(values.values.astype(float), expected)
+        assert_numpy_array_equivalent(values.values.astype(float), expected)
 
         arrays = [[np.nan, np.nan, np.nan], ['a', np.nan, 1]]
         index = pd.MultiIndex.from_arrays(arrays)
         values = index.get_level_values(0)
         expected = [np.nan, np.nan, np.nan]
-        assert_array_equal(values.values.astype(float), expected)
+        assert_numpy_array_equivalent(values.values.astype(float), expected)
         values = index.get_level_values(1)
         expected = np.array(['a', np.nan, 1],dtype=object)
-        assert_array_equal(values.values, expected)
+        assert_numpy_array_equivalent(values.values, expected)
 
         arrays = [['a', 'b', 'b'], pd.DatetimeIndex([0, 1, pd.NaT])]
         index = pd.MultiIndex.from_arrays(arrays)
         values = index.get_level_values(1)
         expected = pd.DatetimeIndex([0, 1, pd.NaT])
-        assert_array_equal(values.values, expected.values)
+        assert_numpy_array_equivalent(values.values, expected.values)
 
         arrays = [[], []]
         index = pd.MultiIndex.from_arrays(arrays)
@@ -4644,14 +4642,14 @@ class TestMultiIndex(Base, tm.TestCase):
         for take_last in [False, True]:
             left = mi.duplicated(take_last=take_last)
             right = pd.lib.duplicated(mi.values, take_last=take_last)
-            tm.assert_array_equal(left, right)
+            tm.assert_numpy_array_equivalent(left, right)
 
         # GH5873
         for a in [101, 102]:
             mi = MultiIndex.from_arrays([[101, a], [3.5, np.nan]])
             self.assertFalse(mi.has_duplicates)
             self.assertEqual(mi.get_duplicates(), [])
-            self.assert_array_equal(mi.duplicated(), np.zeros(2, dtype='bool'))
+            self.assert_numpy_array_equivalent(mi.duplicated(), np.zeros(2, dtype='bool'))
 
         for n in range(1, 6):  # 1st level shape
             for m in range(1, 5):  # 2nd level shape
@@ -4662,7 +4660,7 @@ class TestMultiIndex(Base, tm.TestCase):
                 self.assertEqual(len(mi), (n + 1) * (m + 1))
                 self.assertFalse(mi.has_duplicates)
                 self.assertEqual(mi.get_duplicates(), [])
-                self.assert_array_equal(mi.duplicated(),
+                self.assert_numpy_array_equivalent(mi.duplicated(),
                                         np.zeros(len(mi), dtype='bool'))
 
     def test_duplicate_meta_data(self):
@@ -4866,7 +4864,6 @@ class TestMultiIndex(Base, tm.TestCase):
         # GH9785
         self.assertTrue((self.index == self.index).all())
 
-
 def test_get_combined_index():
     from pandas.core.index import _get_combined_index
     result = _get_combined_index([])
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 7326d7a9d..361cf4aba 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -504,11 +504,6 @@ class TestNanops(tm.TestCase):
         s == s2
         s2 == s
 
-    def test_none_comparison(self):
-        # bug brought up by #1079
-        s = Series(np.random.randn(10), index=lrange(0, 20, 2))
-        self.assertRaises(TypeError, s.__eq__, None)
-
     def test_sum_zero(self):
         arr = np.array([])
         self.assertEqual(nanops.nansum(arr), 0)
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 7378e3504..8328e1a86 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -59,7 +59,6 @@ def reset_testing_mode():
 
 set_testing_mode()
 
-
 class TestCase(unittest.TestCase):
 
     @classmethod
@@ -634,7 +633,7 @@ def assert_categorical_equal(res, exp):
         raise AssertionError("name not the same")
 
 
-def assert_numpy_array_equal(np_array, assert_equal):
+def assert_numpy_array_equal(np_array, assert_equal, err_msg=None):
     """Checks that 'np_array' is equal to 'assert_equal'
 
     Note that the expected array should not contain `np.nan`!
@@ -646,11 +645,12 @@ def assert_numpy_array_equal(np_array, assert_equal):
     """
     if np.array_equal(np_array, assert_equal):
         return
-    raise AssertionError(
-        '{0} is not equal to {1}.'.format(np_array, assert_equal))
+    if err_msg is None:
+        err_msg = '{0} is not equal to {1}.'.format(np_array, assert_equal)
+    raise AssertionError(err_msg)
 
 
-def assert_numpy_array_equivalent(np_array, assert_equal, strict_nan=False):
+def assert_numpy_array_equivalent(np_array, assert_equal, strict_nan=False, err_msg=None):
     """Checks that 'np_array' is equivalent to 'assert_equal'
 
     Two numpy arrays are equivalent if the arrays have equal non-NaN elements,
@@ -664,8 +664,9 @@ def assert_numpy_array_equivalent(np_array, assert_equal, strict_nan=False):
     """
     if array_equivalent(np_array, assert_equal, strict_nan=strict_nan):
         return
-    raise AssertionError(
-        '{0} is not equivalent to {1}.'.format(np_array, assert_equal))
+    if err_msg is None:
+        err_msg = '{0} is not equivalent to {1}.'.format(np_array, assert_equal)
+    raise AssertionError(err_msg)
 
 
 # This could be refactored to use the NDFrame.equals method

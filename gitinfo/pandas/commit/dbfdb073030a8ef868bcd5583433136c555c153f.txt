commit dbfdb073030a8ef868bcd5583433136c555c153f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 3 22:16:32 2012 -0400

    BUG: fix issue calling sort on result of Series.unique, close #1807

diff --git a/RELEASE.rst b/RELEASE.rst
index d0b89cc84..2518669fe 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -97,6 +97,7 @@ pandas 0.8.2
   - Fix conversion of array of tz-aware datetime.datetime to DatetimeIndex with
     right time zone (#1777)
   - Fix DST issues with generating anchored date ranges (#1778)
+  - Fix issue calling sort on result of Series.unique (#1807)
 
 pandas 0.8.1
 ============
diff --git a/pandas/src/hashtable.pyx b/pandas/src/hashtable.pyx
index b1b254d0f..8fa18e372 100644
--- a/pandas/src/hashtable.pyx
+++ b/pandas/src/hashtable.pyx
@@ -47,44 +47,73 @@ cdef extern from "kvec.h":
 cdef class ObjectVector:
 
     cdef:
+        bint owndata
         kv_object_t vec
 
-    def __array__(self):
+    def __cinit__(self):
+        self.owndata = 1
+
+    def to_array(self, xfer_data=True):
         """ Here we use the __array__ method, that is called when numpy
             tries to get an array from the object."""
-        cdef npy_intp shape[1]
+        cdef:
+            npy_intp shape[1]
+            ndarray result
+
         shape[0] = <npy_intp> self.vec.n
 
         # Create a 1D array, of length 'size'
-        return PyArray_SimpleNewFromData(1, shape, np.NPY_OBJECT, self.vec.a)
+        result = PyArray_SimpleNewFromData(1, shape,
+                                           np.NPY_OBJECT, self.vec.a)
+        if xfer_data:
+            self.owndata = 0
+            util.set_array_owndata(result)
+
+        return result
+
 
     cdef inline append(self, object o):
         kv_object_push(&self.vec, <PyObject*> o)
 
     def __dealloc__(self):
-        kv_object_destroy(&self.vec)
+        if self.owndata:
+            kv_object_destroy(&self.vec)
 
 
 cdef class Int64Vector:
 
     cdef:
+        bint owndata
         kv_int64_t vec
 
-    def __array__(self):
+    def __cinit__(self):
+        self.owndata = 1
+
+    def to_array(self, xfer_data=True):
         """ Here we use the __array__ method, that is called when numpy
             tries to get an array from the object."""
-        cdef npy_intp shape[1]
+        cdef:
+            npy_intp shape[1]
+            ndarray result
+
         shape[0] = <npy_intp> self.vec.n
 
         # Create a 1D array, of length 'size'
-        return PyArray_SimpleNewFromData(1, shape, np.NPY_INT64,
-                                         self.vec.a)
+        result = PyArray_SimpleNewFromData(1, shape, np.NPY_INT64,
+                                           self.vec.a)
+
+        if xfer_data:
+            self.owndata = 0
+            util.set_array_owndata(result)
+
+        return result
 
     cdef inline append(self, int64_t x):
         kv_int64_push(&self.vec, x)
 
     def __dealloc__(self):
-        free(self.vec.a)
+        if self.owndata:
+            free(self.vec.a)
 
 
 cdef class HashTable:
@@ -522,9 +551,11 @@ cdef class Int64HashTable(HashTable):
                 uniques.append(val)
                 count += 1
 
-        result = np.array(uniques, copy=False)
-        result.base = <PyObject*> uniques
-        Py_INCREF(uniques)
+        result = uniques.to_array(xfer_data=True)
+
+        # result = np.array(uniques, copy=False)
+        # result.base = <PyObject*> uniques
+        # Py_INCREF(uniques)
 
         return result
 
@@ -797,9 +828,11 @@ cdef class PyObjectHashTable(HashTable):
                 seen_na = 1
                 uniques.append(ONAN)
 
-        result = np.array(uniques, copy=False)
-        result.base = <PyObject*> uniques
-        Py_INCREF(uniques)
+        result = uniques.to_array(xfer_data=True)
+
+        # result = np.array(uniques, copy=False)
+        # result.base = <PyObject*> uniques
+        # Py_INCREF(uniques)
 
         return result
 
diff --git a/pandas/src/numpy_helper.h b/pandas/src/numpy_helper.h
index 053cd8aea..a643a9061 100644
--- a/pandas/src/numpy_helper.h
+++ b/pandas/src/numpy_helper.h
@@ -144,6 +144,11 @@ PANDAS_INLINE PyObject* floatify(PyObject* str) {
 }
 
 
+void set_array_owndata(PyArrayObject *ao) {
+    ao->flags |= NPY_OWNDATA;
+}
+
+
 // PANDAS_INLINE PyObject*
 // get_base_ndarray(PyObject* ap) {
 //   // if (!ap || (NULL == ap)) {
diff --git a/pandas/src/util.pxd b/pandas/src/util.pxd
index f25f7b55c..fe6e4391c 100644
--- a/pandas/src/util.pxd
+++ b/pandas/src/util.pxd
@@ -2,6 +2,8 @@ from numpy cimport ndarray
 cimport numpy as cnp
 
 cdef extern from "numpy_helper.h":
+    inline void set_array_owndata(ndarray ao)
+
     inline int is_integer_object(object)
     inline int is_float_object(object)
     inline int is_complex_object(object)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 2f1f0e745..a7e0d4f0b 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -3081,6 +3081,7 @@ class TestSeriesNonUnique(unittest.TestCase):
         self.assert_((ser[:5] == -1).all())
         self.assert_((ser[6:10] == -1).all())
         self.assert_((ser[20:30] == -1).all())
+
     def test_repeat(self):
         s = Series(np.random.randn(3), index=['a', 'b', 'c'])
 
@@ -3094,6 +3095,11 @@ class TestSeriesNonUnique(unittest.TestCase):
                      index=s.index.values.repeat(to_rep))
         assert_series_equal(reps, exp)
 
+    def test_unique_data_ownership(self):
+        # it works! #1807
+        Series(Series(["a","c","b"]).unique()).sort()
+
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)

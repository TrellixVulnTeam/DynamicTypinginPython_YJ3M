commit cb96f776dd4b1d1d243046cd74b64c9a84232aa3
Author: jreback <jeff@reback.net>
Date:   Sun Feb 24 22:46:00 2013 -0500

    ENH: add .loc attribute to provide location-based indexing
    
    TST: added multi-index tests
    
    DOC: changed loc -> iloc
         added more docs
    
    ENH: added integer lists as indexers to iloc
    
    ENH: raise correctly on out-of-bounds slicing
         support negative indexing in iloc and icol
    
    CLN: move all indexings (ix/iloc) to PandasObject in generic.py
         (except _SeriesIndexer in series.py)
         add name parameter to Indexer creation, makes indexers independent
         of their external names

diff --git a/RELEASE.rst b/RELEASE.rst
index cf3fd598a..32cbddf6b 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -35,6 +35,7 @@ pandas 0.11.0
     Yahoo! finance (GH2795_)
   - Add ``squeeze`` function to reduce dimensionality of 1-len objects
   - Support slicing with time objects (GH2681_)
+  - Add ``.iloc`` attribute, to support location-based indexing, analagous to ``.ix``
 
 **Improvements to existing features**
 
@@ -127,6 +128,7 @@ pandas 0.11.0
   - Bug on in-place putmasking on an ``integer`` series that needs to be converted to ``float`` (GH2746_)
   - Bug in argsort of ``datetime64[ns]`` Series with ``NaT`` (GH2967_)
   - Bug in idxmin/idxmax of ``datetime64[ns]`` Series with ``NaT`` (GH2982__)
+  - ``icol`` with negative indicies was return ``nan`` (see GH2922_)
 
 .. _GH622: https://github.com/pydata/pandas/issues/622
 .. _GH797: https://github.com/pydata/pandas/issues/797
@@ -145,6 +147,7 @@ pandas 0.11.0
 .. _GH2849: https://github.com/pydata/pandas/issues/2849
 .. _GH2898: https://github.com/pydata/pandas/issues/2898
 .. _GH2909: https://github.com/pydata/pandas/issues/2909
+.. _GH2922: https://github.com/pydata/pandas/issues/2922
 .. _GH2931: https://github.com/pydata/pandas/issues/2931
 .. _GH2973: https://github.com/pydata/pandas/issues/2973
 .. _GH2967: https://github.com/pydata/pandas/issues/2967
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 8c18d9f69..1ddb4a828 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -177,6 +177,86 @@ largely as a convenience since it is such a common operation.
    df[:3]
    df[::-1]
 
+Location Based Indexing
+~~~~~~~~~~~~~~~~~~~~~~~
+
+Pandas provides a suite of methods in order to get **purely integer based indexing**. 
+The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
+When slicing, the start bounds is *included*, while the upper bound is *excluded*.
+Invalid selections will raise with an ``IndexError``. Trying to use a non-integer,
+even a **valid** label will raise a ``ValueError``. Integers, lists of integers, and slices
+are allowed indexers.
+
+The ``.iloc`` attribute is the primary access method .
+
+.. ipython:: python
+
+   s1 = Series(np.random.randn(5),index=range(0,10,2))
+   s1
+   s1.iloc[:3]
+   s1.iloc[3]
+
+Note that setting works as well:
+
+.. ipython:: python
+
+   s1.iloc[:3] = 0
+   s1
+
+With a DataFrame
+
+.. ipython:: python
+
+   df1 = DataFrame(np.random.randn(6,4),index=range(0,12,2),columns=range(0,8,2))
+   df1
+
+   # integer access
+   df1.iloc[5,2]
+
+   # slices
+   df1.iloc[:3]
+   df1.iloc[1:5,2:4]
+
+   # integer lists
+   df1.iloc[[1,3,5],[1,3]]
+
+For slicing rows explicitly.
+
+.. ipython:: python
+
+   # this is equivalent to ``df1.iloc[1:3,:]``
+   df1.irow(range(1,3))
+
+For slicing columns explicitly.
+
+.. ipython:: python
+
+   # this is equivalent to ``df1.iloc[:,1:3]``
+   df1.icol(range(1,3))
+
+For getting a value explicity.
+
+.. ipython:: python
+
+   # this is equivalent to ``df1.iloc[1,1]``
+   df1.iget_value(1,1)
+
+There is one signficant departure from standard python/numpy slicing semantics.
+python/numpy allow slicing past the end of an array without an associated error.
+
+.. ipython:: python
+
+    # these are allowed in python/numpy.
+    x = list('abcdef')
+    x[4:10]
+    x[8:10]
+
+::
+
+    >>> df.iloc[:,3:6]
+    IndexError: out-of-bounds on slice (end)
+
+
 Boolean indexing
 ~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/v0.11.0.txt b/doc/source/v0.11.0.txt
index cc3b39dd2..76f7ffae7 100644
--- a/doc/source/v0.11.0.txt
+++ b/doc/source/v0.11.0.txt
@@ -11,11 +11,68 @@ to.
 API changes
 ~~~~~~~~~~~
 
-Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the ``dtype`` keyword, a passed ``ndarray``, or a passed ``Series``, then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will **NOT** be combined. The following example will give you a taste.
+Location Based Indexing
+~~~~~~~~~~~~~~~~~~~~~~~
+
+Pandas provides a suite of methods in order to get **purely integer based indexing**. 
+The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
+When slicing, the start bounds is *included*, while the upper bound is *excluded*.
+Invalid selections will raise with an ``IndexError``. Trying to use a non-integer,
+even a **valid** label will raise a ``ValueError``. Integers, lists of integers, and slices
+are allowed indexers.
+
+The ``.iloc`` attribute is the primary access method .
+
+.. ipython:: python
+
+   s1 = Series(np.random.randn(5),index=range(0,10,2))
+   s1
+   s1.iloc[:3]
+   s1.iloc[3]
+
+Note that setting works as well:
+
+.. ipython:: python
+
+   s1.iloc[:3] = 0
+   s1
+
+With a DataFrame
+
+.. ipython:: python
+
+   df1 = DataFrame(np.random.randn(8,4),index=range(0,16,2),columns=range(0,8,2))
+
+   # integer access
+   df1.iloc[5,2]
+
+   # slices
+   df1.iloc[:3]
+   df1.iloc[1:5,2:4]
+
+   # integer lists
+   df1.iloc[[1,3,5],[1,3]]
+
+There is one signficant departure from standard python/numpy slicing semantics.
+python/numpy allow slicing past the end of an array without an associated error.
+
+.. ipython:: python
+
+    # these are allowed in python/numpy.
+    x = list('abcdef')
+    x[4:10]
+    x[8:10]
+
+::
+
+    >>> df.iloc[:,3:6]
+    IndexError: out-of-bounds on slice (end)
 
 Dtype Specification
 ~~~~~~~~~~~~~~~~~~~
 
+Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the ``dtype`` keyword, a passed ``ndarray``, or a passed ``Series``, then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will **NOT** be combined. The following example will give you a taste.
+
 .. ipython:: python
 
    df1 = DataFrame(randn(8, 1), columns = ['A'], dtype = 'float32')
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c0449faf4..b3770cb79 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -568,16 +568,6 @@ class DataFrame(NDFrame):
     def _constructor(self):
         return DataFrame
 
-    # Fancy indexing
-    _ix = None
-
-    @property
-    def ix(self):
-        if self._ix is None:
-            self._ix = _NDFrameIndexer(self)
-
-        return self._ix
-
     @property
     def shape(self):
         return (len(self.index), len(self.columns))
@@ -1947,6 +1937,12 @@ class DataFrame(NDFrame):
         else:
             label = self.columns[i]
             if isinstance(label, Index):
+
+                # if we have negative indicies, translate to postive here 
+                # (take doesen't deal properly with these)
+                l = len(self.columns)
+                i = [ v if v >= 0 else l+v for v in i ]
+
                 return self.take(i, axis=1)
 
             values = self._data.iget(i)
@@ -2054,13 +2050,13 @@ class DataFrame(NDFrame):
             raise ValueError('Must pass DataFrame with boolean values only')
         return self.where(key)
 
-    def _slice(self, slobj, axis=0):
+    def _slice(self, slobj, axis=0, raise_on_error=False):
         if axis == 0:
             mgr_axis = 1
         else:
             mgr_axis = 0
 
-        new_data = self._data.get_slice(slobj, axis=mgr_axis)
+        new_data = self._data.get_slice(slobj, axis=mgr_axis, raise_on_error=raise_on_error)
         return self._constructor(new_data)
 
     def _box_item_values(self, key, values):
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index afe7f8775..511fb8976 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from pandas.core.index import MultiIndex
+from pandas.core.indexing import _NDFrameIndexer, _NDFrameLocIndexer
 from pandas.tseries.index import DatetimeIndex
 import pandas.core.common as com
 import pandas.lib as lib
@@ -70,6 +71,29 @@ class PandasObject(object):
         """
         return np.abs(self)
 
+
+    #----------------------------------------------------------------------
+    # integer indexing
+    _iloc = None
+
+    @property
+    def iloc(self):
+        if self._iloc is None:
+            self._iloc = _NDFrameLocIndexer(self, 'iloc')
+
+        return self._iloc
+
+    #----------------------------------------------------------------------
+    # Fancy indexing
+    _ix = None
+
+    @property
+    def ix(self):
+        if self._ix is None:
+            self._ix = _NDFrameIndexer(self, 'ix')
+
+        return self._ix
+
     def get(self, key, default=None):
         """
         Get item from object for given key (DataFrame column, Panel slice,
@@ -396,10 +420,6 @@ class PandasObject(object):
         new_axis = labels.take(sort_index)
         return self.reindex(**{axis_name: new_axis})
 
-    @property
-    def ix(self):
-        raise NotImplementedError
-
     def reindex(self, *args, **kwds):
         raise NotImplementedError
 
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 8f8122521..0d80f54f6 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -17,9 +17,10 @@ class IndexingError(Exception):
 
 class _NDFrameIndexer(object):
 
-    def __init__(self, obj):
+    def __init__(self, obj, name):
         self.obj = obj
         self.ndim = obj.ndim
+        self.name = name
 
     def __iter__(self):
         raise NotImplementedError('ix is not iterable')
@@ -50,8 +51,8 @@ class _NDFrameIndexer(object):
     def _get_loc(self, key, axis=0):
         return self.obj._ixs(key, axis=axis)
 
-    def _slice(self, obj, axis=0):
-        return self.obj._slice(obj, axis=axis)
+    def _slice(self, obj, axis=0, raise_on_error=False):
+        return self.obj._slice(obj, axis=axis, raise_on_error=raise_on_error)
 
     def __setitem__(self, key, value):
         # kludgetastic
@@ -221,7 +222,7 @@ class _NDFrameIndexer(object):
             if _is_null_slice(key):
                 continue
 
-            retval = retval.ix._getitem_axis(key, axis=i)
+            retval = getattr(retval,self.name)._getitem_axis(key, axis=i)
 
         return retval
 
@@ -325,7 +326,7 @@ class _NDFrameIndexer(object):
                     if len(new_key) == 1:
                         new_key, = new_key
 
-                return section.ix[new_key]
+                return getattr(section,self.name)[new_key]
 
         raise IndexingError('not applicable')
 
@@ -593,6 +594,64 @@ class _NDFrameIndexer(object):
         else:
             return self.obj.take(indexer, axis=axis)
 
+class _NDFrameLocIndexer(_NDFrameIndexer):
+    """ purely location based indexing """
+
+    def __getitem__(self, key):
+        if type(key) is tuple:
+
+            for i, k in enumerate(key):
+                if i >= self.obj.ndim:
+                    raise ValueError('Too many indexers')
+                if not (isinstance(k, slice) or com.is_integer(k) or _is_list_like(k)):
+                    raise ValueError("Location based indexing can only have slice or integer indexers")
+
+            return self._getitem_tuple(key)
+        else:
+            return self._getitem_axis(key, axis=0)
+
+    def _getitem_tuple(self, tup):
+
+        retval = self.obj
+        for i, key in enumerate(tup):
+            if _is_null_slice(key):
+                continue
+
+            retval = getattr(retval,self.name)._getitem_axis(key, axis=i)
+
+        return retval
+
+    def _get_slice_axis(self, slice_obj, axis=0):
+        obj = self.obj
+
+        if not _need_slice(slice_obj):
+            return obj
+
+        if isinstance(slice_obj, slice):
+            return self._slice(slice_obj, axis=axis, raise_on_error=True)
+        else:
+            return self.obj.take(slice_obj, axis=axis)
+
+    def _getitem_axis(self, key, axis=0):
+
+        if isinstance(key, slice):
+            return self._get_slice_axis(key, axis=axis)
+
+        # a single integer
+        else:
+
+            if not (com.is_integer(key) or _is_list_like(key)):
+                raise ValueError("Cannot index by location index with a non-integer key")
+
+            return self._get_loc(key,axis=axis)
+
+    def _convert_to_indexer(self, obj, axis=0):
+        """ much simpler as we only have to deal with slice/integer """
+        if isinstance(obj, slice) or com.is_integer(obj):
+            return obj
+
+        raise ValueError("Can only index by location with a slice or integer key")
+
 # 32-bit floating point machine epsilon
 _eps = np.finfo('f4').eps
 
@@ -737,6 +796,17 @@ def _need_slice(obj):
             (obj.step is not None and obj.step != 1))
 
 
+def _check_slice_bounds(slobj, values):
+    l = len(values)
+    start = slobj.start
+    if start is not None:
+        if start < -l or start > l-1:
+            raise IndexError("out-of-bounds on slice (start)")
+    stop = slobj.stop
+    if stop is not None:
+        if stop < -l-1 or stop > l:
+            raise IndexError("out-of-bounds on slice (end)")
+
 def _maybe_droplevels(index, key):
     # drop levels
     if isinstance(key, tuple):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 159393be3..5bf918aff 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -5,6 +5,7 @@ from numpy import nan
 import numpy as np
 
 from pandas.core.index import Index, _ensure_index, _handle_legacy_indexes
+from pandas.core.indexing import _check_slice_bounds
 import pandas.core.common as com
 import pandas.lib as lib
 import pandas.tslib as tslib
@@ -1034,8 +1035,12 @@ class BlockManager(object):
         return self.get_numeric_data(copy=copy, type_list=(BoolBlock,),
                                      as_blocks=as_blocks)
 
-    def get_slice(self, slobj, axis=0):
+    def get_slice(self, slobj, axis=0, raise_on_error=False):
         new_axes = list(self.axes)
+
+        if raise_on_error:
+            _check_slice_bounds(slobj, new_axes[axis])
+
         new_axes[axis] = new_axes[axis][slobj]
 
         if axis == 0:
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index b418995ce..16d5f09aa 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -540,16 +540,6 @@ class Panel(NDFrame):
 
         return index, columns
 
-    # Fancy indexing
-    _ix = None
-
-    @property
-    def ix(self):
-        if self._ix is None:
-            self._ix = _NDFrameIndexer(self)
-
-        return self._ix
-
     def _wrap_array(self, arr, axes, copy=False):
         d = self._construct_axes_dict_from(self, axes, copy=copy)
         return self._constructor(arr, **d)
@@ -679,8 +669,8 @@ class Panel(NDFrame):
         raise AttributeError("'%s' object has no attribute '%s'" %
                              (type(self).__name__, name))
 
-    def _slice(self, slobj, axis=0):
-        new_data = self._data.get_slice(slobj, axis=axis)
+    def _slice(self, slobj, axis=0, raise_on_error=False):
+        new_data = self._data.get_slice(slobj, axis=axis, raise_on_error=raise_on_error)
         return self._constructor(new_data)
 
     def __setitem__(self, key, value):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index b349dd65f..788752020 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -20,7 +20,7 @@ from pandas.core.common import (isnull, notnull, _is_bool_indexer,
                                 _infer_dtype_from_scalar, is_list_like)
 from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index, _handle_legacy_indexes)
-from pandas.core.indexing import _SeriesIndexer, _check_bool_indexer
+from pandas.core.indexing import _SeriesIndexer, _check_bool_indexer, _check_slice_bounds
 from pandas.tseries.index import DatetimeIndex
 from pandas.tseries.period import PeriodIndex, Period
 from pandas.util import py3compat
@@ -547,15 +547,27 @@ class Series(pa.Array, generic.PandasObject):
         self.index = _handle_legacy_indexes([index])[0]
         self.name = name
 
-    _ix = None
-
+    # indexers
     @property
     def ix(self):
         if self._ix is None:
-            self._ix = _SeriesIndexer(self)
+            self._ix = _SeriesIndexer(self, 'ix')
 
         return self._ix
 
+    def _ixs(self, i, axis=0):
+        return self.values[i]
+
+    @property
+    def _is_mixed_type(self):
+        return False
+
+    def _slice(self, slobj, axis=0, raise_on_error=False):
+        if raise_on_error:
+            _check_slice_bounds(slobj, self.values)
+            
+        return self._constructor(self.values[slobj], index=self.index[slobj])
+
     def __getitem__(self, key):
         try:
             return self.index.get_value(self, key)
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index bf978c322..f142b3653 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -10,6 +10,7 @@ import numpy as np
 
 from pandas.core.common import _pickle_array, _unpickle_array, _try_sort
 from pandas.core.index import Index, MultiIndex, _ensure_index
+from pandas.core.indexing import _check_slice_bounds
 from pandas.core.series import Series
 from pandas.core.frame import (DataFrame, extract_index, _prep_ndarray,
                                _default_index)
@@ -416,11 +417,15 @@ class SparseDataFrame(DataFrame):
         return dense.to_sparse(kind=self.default_kind,
                                fill_value=self.default_fill_value)
 
-    def _slice(self, slobj, axis=0):
+    def _slice(self, slobj, axis=0, raise_on_error=False):
         if axis == 0:
+            if raise_on_error:
+                _check_slice_bounds(slobj, self.index)
             new_index = self.index[slobj]
             new_columns = self.columns
         else:
+            if raise_on_error:
+                _check_slice_bounds(slobj, self.columns)
             new_index = self.index
             new_columns = self.columns[slobj]
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 304072acc..3968371f8 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1451,6 +1451,108 @@ class CheckIndexing(object):
         result = self.frame.ix[self.frame.index[5], 'E']
         self.assert_(com.is_integer(result))
 
+    def test_iloc_getitem(self):
+        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0,8,2))
+
+        result = df.iloc[2]
+        exp = df.ix[4]
+        assert_series_equal(result, exp)
+
+        result = df.iloc[2,2]
+        exp = df.ix[4,4]
+        self.assert_(result == exp)
+
+        # slice
+        result = df.iloc[4:8]
+        expected = df.ix[8:14]
+        assert_frame_equal(result, expected)
+
+        result = df.iloc[:,2:3]
+        expected = df.ix[:,4:5]
+        assert_frame_equal(result, expected)
+
+        # list of integers
+        result = df.iloc[[0,1,3]]
+        expected = df.ix[[0,2,6]]
+        assert_frame_equal(result, expected)
+
+        result = df.iloc[[0,1,3],[0,1]]
+        expected = df.ix[[0,2,6],[0,2]]
+        assert_frame_equal(result, expected)
+
+        # neg indicies
+        result = df.iloc[[-1,1,3],[-1,1]]
+        expected = df.ix[[18,2,6],[6,2]]
+        assert_frame_equal(result, expected)
+
+        # dups indicies
+        result = df.iloc[[-1,-1,1,3],[-1,1]]
+        expected = df.ix[[18,18,2,6],[6,2]]
+        assert_frame_equal(result, expected)
+
+        # with index-like
+        s = Series(index=range(1,5))
+        result = df.iloc[s.index]
+        expected = df.ix[[2,4,6,8]]
+        assert_frame_equal(result, expected)
+        
+        # out-of-bounds slice
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(1,5,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(-5,3,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(1,11,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(-11,3,None)]))
+
+        # try with labelled frame
+        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
+
+        result = df.iloc[1,1]
+        exp = df.ix['b','B']
+        self.assert_(result == exp)
+
+        result = df.iloc[:,2:3]
+        expected = df.ix[:,['C']]
+        assert_frame_equal(result, expected)
+
+        # negative indexing
+        result = df.iloc[-1,-1]
+        exp = df.ix['j','D']
+        self.assert_(result == exp)
+
+        # out-of-bounds exception
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([10,5]))
+
+        # trying to use a label
+        self.assertRaises(ValueError, df.iloc.__getitem__, tuple(['j','D']))
+
+    def test_iloc_setitem(self):
+        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
+
+        df.iloc[1,1] = 1
+        result = df.iloc[1,1]
+        self.assert_(result == 1)
+
+        df.iloc[:,2:3] = 0
+        expected = df.iloc[:,2:3]
+        result = df.iloc[:,2:3]
+        assert_frame_equal(result, expected)
+
+    def test_iloc_multiindex(self):
+        df = DataFrame(np.random.randn(3, 3), 
+                       columns=[[2,2,4],[6,8,10]],
+                       index=[[4,4,8],[8,10,12]])
+
+        rs = df.iloc[2]
+        xp = df.irow(2)
+        assert_series_equal(rs, xp)
+
+        rs = df.iloc[:,2]
+        xp = df.icol(2)
+        assert_series_equal(rs, xp)
+
+        rs = df.iloc[2,2]
+        xp = df.values[2,2]
+        self.assert_(rs == xp)
+
     def test_irow(self):
         df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2))
 
@@ -6305,7 +6407,6 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             econd = cond.reindex_like(df).fillna(True)
             expected = dfi.mask(~econd)
 
-            #import pdb; pdb.set_trace()
             dfi.where(cond, np.nan, inplace=True)
             assert_frame_equal(dfi, expected)
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index ee288fda1..eab956fb5 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1000,6 +1000,40 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertRaises(Exception, s.__setitem__, inds_notfound, 0)
         self.assertRaises(Exception, s.__setitem__, arr_inds_notfound, 0)
 
+    def test_iloc_getitem(self):
+        s = Series(np.random.randn(10), index=list('abcdefghij'))
+
+        result = s.iloc[1]
+        exp = s.ix['b']
+        self.assert_(result == exp)
+
+        result = s.iloc[2:4]
+        expected = s.ix['c':'d']
+        assert_series_equal(result, expected)
+
+        # negative indexing
+        result = s.iloc[-1]
+        exp = s.ix['j']
+        self.assert_(result == exp)
+
+        # out-of-bounds exception
+        self.assertRaises(IndexError, s.iloc.__getitem__, tuple([12]))
+
+        # trying to use a label
+        self.assertRaises(ValueError, s.iloc.__getitem__, tuple(['j']))
+
+    def test_iloc_setitem(self):
+        s = Series(np.random.randn(10), index=range(0,20,2))
+
+        s.iloc[1] = 1
+        result = s.iloc[1]
+        self.assert_(result == 1)
+
+        s.iloc[:4] = 0
+        expected = s.iloc[:4]
+        result = s.iloc[:4]
+        assert_series_equal(result, expected)
+
     def test_ix_getitem(self):
         inds = self.series.index[[3, 4, 7]]
         assert_series_equal(self.series.ix[inds], self.series.reindex(inds))

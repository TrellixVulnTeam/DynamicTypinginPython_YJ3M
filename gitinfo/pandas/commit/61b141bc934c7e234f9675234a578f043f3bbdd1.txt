commit 61b141bc934c7e234f9675234a578f043f3bbdd1
Author: DSM <dsm054@gmail.com>
Date:   Sat Mar 1 10:01:02 2014 -0500

    ENH: add method='dense' to rank

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 3c6d2643e..08bfcbe42 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -127,6 +127,7 @@ Improvements to existing features
 - Performance improvement in indexing into a multi-indexed Series (:issue:`5567`)
 - Testing statements updated to use specialized asserts (:issue:`6175`)
 - ``Series.rank()`` now has a percentage rank option (:issue:`5971`)
+- ``Series.rank()`` and ``DataFrame.rank()`` now accept ``method='dense'`` for ranks without gaps (:issue:`6514`)
 - ``quotechar``, ``doublequote``, and ``escapechar`` can now be specified when
   using ``DataFrame.to_csv`` (:issue:`5414`, :issue:`4528`)
 - perf improvements in DataFrame construction with certain offsets, by removing faulty caching
diff --git a/pandas/algos.pyx b/pandas/algos.pyx
index 7f406611c..14c9ec2f3 100644
--- a/pandas/algos.pyx
+++ b/pandas/algos.pyx
@@ -68,12 +68,14 @@ cdef:
     int TIEBREAK_MAX = 2
     int TIEBREAK_FIRST = 3
     int TIEBREAK_FIRST_DESCENDING = 4
+    int TIEBREAK_DENSE = 5
 
 tiebreakers = {
     'average' : TIEBREAK_AVERAGE,
     'min' : TIEBREAK_MIN,
     'max' : TIEBREAK_MAX,
-    'first' : TIEBREAK_FIRST
+    'first' : TIEBREAK_FIRST,
+    'dense' : TIEBREAK_DENSE,
 }
 
 
@@ -137,7 +139,7 @@ def rank_1d_float64(object in_arr, ties_method='average', ascending=True,
     """
 
     cdef:
-        Py_ssize_t i, j, n, dups = 0
+        Py_ssize_t i, j, n, dups = 0, total_tie_count = 0
         ndarray[float64_t] sorted_data, ranks, values
         ndarray[int64_t] argsorted
         float64_t val, nan_value
@@ -200,6 +202,10 @@ def rank_1d_float64(object in_arr, ties_method='average', ascending=True,
             elif tiebreak == TIEBREAK_FIRST_DESCENDING:
                 for j in range(i - dups + 1, i + 1):
                     ranks[argsorted[j]] = 2 * i - j - dups + 2
+            elif tiebreak == TIEBREAK_DENSE:
+                total_tie_count += 1
+                for j in range(i - dups + 1, i + 1):
+                    ranks[argsorted[j]] = total_tie_count
             sum_ranks = dups = 0
     if pct:
         return ranks / count
@@ -214,7 +220,7 @@ def rank_1d_int64(object in_arr, ties_method='average', ascending=True,
     """
 
     cdef:
-        Py_ssize_t i, j, n, dups = 0
+        Py_ssize_t i, j, n, dups = 0, total_tie_count = 0
         ndarray[int64_t] sorted_data, values
         ndarray[float64_t] ranks
         ndarray[int64_t] argsorted
@@ -265,6 +271,10 @@ def rank_1d_int64(object in_arr, ties_method='average', ascending=True,
             elif tiebreak == TIEBREAK_FIRST_DESCENDING:
                 for j in range(i - dups + 1, i + 1):
                     ranks[argsorted[j]] = 2 * i - j - dups + 2
+            elif tiebreak == TIEBREAK_DENSE:
+                total_tie_count += 1
+                for j in range(i - dups + 1, i + 1):
+                    ranks[argsorted[j]] = total_tie_count
             sum_ranks = dups = 0
     if pct:
         return ranks / count
@@ -279,7 +289,7 @@ def rank_2d_float64(object in_arr, axis=0, ties_method='average',
     """
 
     cdef:
-        Py_ssize_t i, j, z, k, n, dups = 0
+        Py_ssize_t i, j, z, k, n, dups = 0, total_tie_count = 0
         ndarray[float64_t, ndim=2] ranks, values
         ndarray[int64_t, ndim=2] argsorted
         float64_t val, nan_value
@@ -324,6 +334,7 @@ def rank_2d_float64(object in_arr, axis=0, ties_method='average',
 
     for i in range(n):
         dups = sum_ranks = 0
+        total_tie_count = 0
         for j in range(k):
             sum_ranks += j + 1
             dups += 1
@@ -347,6 +358,10 @@ def rank_2d_float64(object in_arr, axis=0, ties_method='average',
                 elif tiebreak == TIEBREAK_FIRST_DESCENDING:
                     for z in range(j - dups + 1, j + 1):
                         ranks[i, argsorted[i, z]] = 2 * j - z - dups + 2
+                elif tiebreak == TIEBREAK_DENSE:
+                    total_tie_count += 1
+                    for z in range(j - dups + 1, j + 1):
+                        ranks[i, argsorted[i, z]] = total_tie_count
                 sum_ranks = dups = 0
 
     if axis == 0:
@@ -362,7 +377,7 @@ def rank_2d_int64(object in_arr, axis=0, ties_method='average',
     """
 
     cdef:
-        Py_ssize_t i, j, z, k, n, dups = 0
+        Py_ssize_t i, j, z, k, n, dups = 0, total_tie_count = 0
         ndarray[float64_t, ndim=2] ranks
         ndarray[int64_t, ndim=2] argsorted
         ndarray[int64_t, ndim=2, cast=True] values
@@ -395,6 +410,7 @@ def rank_2d_int64(object in_arr, axis=0, ties_method='average',
 
     for i in range(n):
         dups = sum_ranks = 0
+        total_tie_count = 0
         for j in range(k):
             sum_ranks += j + 1
             dups += 1
@@ -415,6 +431,10 @@ def rank_2d_int64(object in_arr, axis=0, ties_method='average',
                 elif tiebreak == TIEBREAK_FIRST_DESCENDING:
                     for z in range(j - dups + 1, j + 1):
                         ranks[i, argsorted[i, z]] = 2 * j - z - dups + 2
+                elif tiebreak == TIEBREAK_DENSE:
+                    total_tie_count += 1
+                    for z in range(j - dups + 1, j + 1):
+                        ranks[i, argsorted[i, z]] = total_tie_count
                 sum_ranks = dups = 0
 
     if axis == 0:
@@ -430,7 +450,7 @@ def rank_1d_generic(object in_arr, bint retry=1, ties_method='average',
     """
 
     cdef:
-        Py_ssize_t i, j, n, dups = 0
+        Py_ssize_t i, j, n, dups = 0, total_tie_count = 0
         ndarray[float64_t] ranks
         ndarray sorted_data, values
         ndarray[int64_t] argsorted
@@ -502,6 +522,10 @@ def rank_1d_generic(object in_arr, bint retry=1, ties_method='average',
                     ranks[argsorted[j]] = i + 1
             elif tiebreak == TIEBREAK_FIRST:
                 raise ValueError('first not supported for non-numeric data')
+            elif tiebreak == TIEBREAK_DENSE:
+                total_tie_count += 1
+                for j in range(i - dups + 1, i + 1):
+                    ranks[argsorted[j]] = total_tie_count
             sum_ranks = dups = 0
     if pct:
         ranks / count
@@ -545,6 +569,7 @@ def rank_2d_generic(object in_arr, axis=0, ties_method='average',
 
     cdef:
         Py_ssize_t i, j, z, k, n, infs, dups = 0
+        Py_ssize_t total_tie_count = 0
         ndarray[float64_t, ndim=2] ranks
         ndarray[object, ndim=2] values
         ndarray[int64_t, ndim=2] argsorted
@@ -600,6 +625,7 @@ def rank_2d_generic(object in_arr, axis=0, ties_method='average',
 
     for i in range(n):
         dups = sum_ranks = infs = 0
+        total_tie_count = 0
         for j in range(k):
             val = values[i, j]
             if val is nan_value and keep_na:
@@ -621,6 +647,10 @@ def rank_2d_generic(object in_arr, axis=0, ties_method='average',
                 elif tiebreak == TIEBREAK_FIRST:
                     raise ValueError('first not supported for '
                                      'non-numeric data')
+                elif tiebreak == TIEBREAK_DENSE:
+                    total_tie_count += 1
+                    for z in range(j - dups + 1, j + 1):
+                        ranks[i, argsorted[i, z]] = total_tie_count
                 sum_ranks = dups = 0
 
     if axis == 0:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 228fa1fd0..6c1037f01 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -4182,11 +4182,12 @@ class DataFrame(NDFrame):
             Ranks over columns (0) or rows (1)
         numeric_only : boolean, default None
             Include only float, int, boolean data
-        method : {'average', 'min', 'max', 'first'}
+        method : {'average', 'min', 'max', 'first', 'dense'}
             * average: average rank of group
             * min: lowest rank in group
             * max: highest rank in group
             * first: ranks assigned in order they appear in the array
+            * dense: like 'min', but rank always increases by 1 between groups
         na_option : {'keep', 'top', 'bottom'}
             * keep: leave NA values where they are
             * top: smallest rank if ascending
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 5d6115b0e..9e6c0bd93 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1720,11 +1720,12 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
         Parameters
         ----------
-        method : {'average', 'min', 'max', 'first'}
+        method : {'average', 'min', 'max', 'first', 'dense'}
             * average: average rank of group
             * min: lowest rank in group
             * max: highest rank in group
             * first: ranks assigned in order they appear in the array
+            * dense: like 'min', but rank always increases by 1 between groups
         na_option : {'keep'}
             keep: leave NA values where they are
         ascending : boolean, default True
diff --git a/pandas/tests/test_stats.py b/pandas/tests/test_stats.py
index 7e2144e80..cb3fdcafd 100644
--- a/pandas/tests/test_stats.py
+++ b/pandas/tests/test_stats.py
@@ -12,7 +12,6 @@ from pandas.util.testing import (assert_frame_equal,
                                  assert_almost_equal)
 import pandas.util.testing as tm
 
-
 class TestRank(tm.TestCase):
     _multiprocess_can_split_ = True
     s = Series([1, 3, 4, 2, nan, 2, 1, 5, nan, 3])
@@ -23,7 +22,8 @@ class TestRank(tm.TestCase):
                              3.5, 1.5, 8.0, nan, 5.5]),
         'min': np.array([1, 5, 7, 3, nan, 3, 1, 8, nan, 5]),
         'max': np.array([2, 6, 7, 4, nan, 4, 2, 8, nan, 6]),
-        'first': np.array([1, 5, 7, 3, nan, 4, 2, 8, nan, 6])
+        'first': np.array([1, 5, 7, 3, nan, 4, 2, 8, nan, 6]),
+        'dense': np.array([1, 3, 4, 2, nan, 2, 1, 5, nan, 3]),
     }
 
     def test_rank_tie_methods(self):
@@ -43,6 +43,24 @@ class TestRank(tm.TestCase):
             series = s if dtype is None else s.astype(dtype)
             _check(series, results[method], method=method)
 
+    def test_rank_dense_method(self):
+        dtypes = ['O', 'f8', 'i8']
+        in_out = [([1], [1]),
+                  ([2], [1]),
+                  ([0], [1]),
+                  ([2,2], [1,1]),
+                  ([1,2,3], [1,2,3]),
+                  ([4,2,1], [3,2,1],),
+                  ([1,1,5,5,3], [1,1,3,3,2]),
+                  ([-5,-4,-3,-2,-1], [1,2,3,4,5])]
+
+        for ser, exp in in_out:
+            for dtype in dtypes:
+                s = Series(ser).astype(dtype)
+                result = s.rank(method='dense')
+                expected = Series(exp).astype(result.dtype)
+                assert_series_equal(result, expected)
+
     def test_rank_descending(self):
         dtypes = ['O', 'f8', 'i8']
 

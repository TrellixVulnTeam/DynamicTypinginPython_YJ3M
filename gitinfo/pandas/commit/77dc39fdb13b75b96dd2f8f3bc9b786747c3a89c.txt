commit 77dc39fdb13b75b96dd2f8f3bc9b786747c3a89c
Author: Adam Klein <adamklein@gmail.com>
Date:   Fri Feb 10 18:15:22 2012 -0500

    Work on frequency logic and integration with DatetimeIndex

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index b8162ae77..cac499816 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -5,6 +5,8 @@ import sys
 import numpy as np
 import pandas._tseries as lib
 
+from pandas._tseries import Timestamp
+
 try:
     import dateutil
     from dateutil import parser
@@ -43,14 +45,15 @@ def _dt_box_array(arr):
     return boxer(arr)
 
 _box_cache = dict()
-def _dt_box(key):
+def _dt_box(key, freq, offset):
     '''
     Box datetime64 to Timestamp
     '''
     try:
         return _box_cache[key]
     except KeyError:
-        _box_cache[key] = lib.Timestamp(key.view('i8'))
+        _box_cache[key] = lib.Timestamp(key.view('i8'), 
+                                        freq=freq, offset=offset)
         return _box_cache[key]
 
 #dtdtype = [('Y', '>i4'), # year
@@ -278,6 +281,32 @@ class DateOffset(object):
         return a == b
 
 
+class BDay2():
+    def __init__(self, n=1):
+        if 'BDay' not in _timestamp_cache:
+            per = lib.count_daily_range(_CACHE_START, _CACHE_END, biz=1)
+            rng = lib.generate_daily_range(_CACHE_START, per + 1, biz=1) 
+            _timestamp_cache['BDay'] = rng
+
+        self.rng = _timestamp_cache['BDay']
+        self.n = n
+
+    def apply(self, other):
+        other = Timestamp(other)
+
+        absn = abs(self.n) 
+        if (other.value < self.rng[absn] or
+            other.value > self.rng[-absn-1]):
+            raise NotImplementedError("Out of range: needs fix")
+
+        idx = self.rng.searchsorted(other.value,
+                                    'left' if self.n > 0 else 'right')
+
+        return Timestamp(self.rng[idx + self.n])
+
+
+
+
 class BDay(DateOffset, CacheableOffset):
     """
     DateOffset subclass representing possibly n business days
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3f69e9faa..467c2d91c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -8,8 +8,8 @@ import numpy as np
 from pandas.core.common import (adjoin as _adjoin, _stringify, _try_sort,
                                 _is_bool_indexer, _asarray_tuplesafe,
                                 is_iterator)
-from pandas.core.datetools import (_dt_box, _dt_unbox,
-                                   _dt_box_array, _dt_unbox_array)
+from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
+                                  _dt_unbox_array)
 from pandas.util.decorators import cache_readonly
 import pandas._tseries as lib
 import pandas._engines as _gin
@@ -100,10 +100,6 @@ class Index(np.ndarray):
         return Index(self.values.astype(dtype), name=self.name,
                      dtype=dtype)
 
-    @property
-    def year(self):
-        return lib.fast_field_accessor2(self.values, 'Y')
-
     @property
     def dtype(self):
         return self.values.dtype
@@ -1033,6 +1029,9 @@ def _dt_index_op(opname):
             return func(other)
     return wrapper
 
+# TODO: there is too much view/M8us stuff going on. better to just
+# have as integer internals probably
+
 class DatetimeIndex(Int64Index):
 
     _is_monotonic  = _wrap_i8_function(lib.is_monotonic_int64)
@@ -1060,38 +1059,28 @@ class DatetimeIndex(Int64Index):
     __sub__ = _dt_index_op('__sub__')
 
     def __new__(cls, data=None,
-                start=None, end=None, freq=None, n=None,
+                freq=None, start=None, end=None, n=None,
                 dtype=None, copy=False, name=None):
 
-        conforms = False
-
         if data is None:
-            if start and freq and n and n > 0:
-                # generate timestamps via offsets
-                starts = [start]
-                idx = start
-                for i in range(n-1):
-                    idx += freq
-                    starts.append(_dt_unbox(idx))
-                data = np.array(starts, dtype='M8[us]')
-                conforms = True
-            elif start and freq and end:
-                starts = [start]
-                idx = start
-                while idx <= end:
-                    idx += freq
-                    starts.append(_dt_unbox(idx))
-                data = np.array(starts, dtype='M8[us]')
-                conforms = True
-            else:
-                raise ValueError("Must pass array of times or "
-                                 "start, freq, and end/n keywords.")
+            if freq is None:
+                raise ValueError("No data, must supply freq")
+            if start is None:
+                raise ValueError("No data, must supply start")
+            if end is None and n is None:
+                raise ValueError("No data, must supply end or n")
+
+            cached, first, last = lib._get_freq(freq, start, end, n)
+            dti = cls._construct_from_cache(name, freq, cached, first, last+1)
+            return dti
+
+        # TODO: check if data conforms to freq
 
         if not isinstance(data, np.ndarray):
             if np.isscalar(data):
                 raise ValueError('DatetimeIndex() must be called with a '
-                                 'collection of some kind, %s was passed'
-                                 % repr(data))
+                                'collection of some kind, %s was passed'
+                                % repr(data))
 
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
@@ -1120,25 +1109,52 @@ class DatetimeIndex(Int64Index):
                                     'explicitly cast')
 
         subarr = subarr.view(cls)
+        subarr.freq = None
         subarr.name = name
-        subarr.freq = freq
-
-        if freq is not None and not conforms:
-            conforming = subarr.map(freq.onOffset).astype(np.bool)
-            if not conforming.all():
-                bad = np.arange(len(subarr))[~conforming]
-                raise ValueError("Non-conforming DatetimeIndex, has invalid "
-                                            "value at positions %s" % bad)
 
         return subarr
 
+    @classmethod
+    def _construct_from_cache(cls, name, freq, cache, first, last):
+        if first < 0:
+            raise ValueError('Fell outside freq cache (first)')
+
+        if last > len(cache):
+            raise ValueError('Fell outside freq cache (last)')
+
+        subarr = cache[first:last]
+
+        newdti = subarr.view(cls)
+
+        newdti.cache = cache
+        newdti.name = name
+        newdti.freq = freq
+
+        newdti.first = first
+        newdti.last = last
+
+        return newdti
+
+    def shift(self, n=1):
+        if self.freq is None:
+            raise ValueError("Cannot shift, frequency of index is empty")
+
+        return self._construct_from_cache(self.name, self.freq, self.cache,
+                                          self.first+n, self.last+n)
+
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
         arr_idx = self.view(np.ndarray)
         if np.isscalar(key):
             if type(key) == datetime:
                 key = _dt_unbox(key)
-            return _dt_box(arr_idx[key])
+            val = arr_idx[key]
+            if self.freq:
+                # suffer another cache lookup? how to avoid?
+                return _dt_box(val, self.freq, 
+                               self.first + self._engine.get_loc(val))
+            else:
+                return _dt_box(val)
         else:
             if _is_bool_indexer(key):
                 key = np.asarray(key)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 2da23e210..22b7140f0 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -36,7 +36,7 @@ ctypedef enum time_res:
 # Python front end to C extension type _Timestamp
 # This serves as the box for datetime64
 class Timestamp(_Timestamp):
-    def __new__(cls, object ts_input, object freq=None):
+    def __new__(cls, object ts_input, object freq=None, object offset=None):
         ts = convert_to_tsobject(ts_input)
 
         # make datetime happy
@@ -54,6 +54,7 @@ class Timestamp(_Timestamp):
         # fill out rest of data
         ts_base.freq = freq
         ts_base.value = ts.value
+        ts_base.offset = -1 if offset is None else offset
 
         return ts_base
 
@@ -64,7 +65,28 @@ class Timestamp(_Timestamp):
 cdef class _Timestamp(datetime):
     cdef:
         int64_t value       # numpy int64
-        object freq         # dateoffset object
+        object freq         # frequency reference
+        int64_t offset      # offset into frequency cache
+
+    def __add__(self, other):
+        if (is_integer_object(other) or PyInt_Check(other) or
+            PyLong_Check(other)):
+            if self.freq is None or self.offset == -1:
+                msg = ("Cannot add integral value to Timestamp "
+                       "without both freq and offset.")
+                raise ValueError(msg)
+            else:
+                cached = _fcache[self.freq]
+                return Timestamp(cached[self.offset + other])
+        else:
+            return super(_Timestamp, self).__add__(other)
+
+    def __sub__(self, other):
+        if (is_integer_object(other) or PyInt_Check(other) or
+            PyLong_Check(other)):
+            return self.__add__(-other)
+        else:
+            return super(_Timestamp, self).__sub__(other)
 
 # lightweight C object to hold datetime & int64 pair
 cdef class _TSObject:
@@ -224,38 +246,50 @@ cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
             return (7 - dow)
     return 0
 
+cdef:
+    int64_t us_in_day = conversion_factor(r_microsecond, r_day)
+
 def generate_annual_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
                           int64_t biz=0):
     """
-    Generate yearly timestamps beginning with start time. Apply dayoffset to
-    each timestamp, which allows you to for instance generate month ends. If
-    biz > 0, we choose the next business day; previous if < 0.
+    Generate annual timestamps beginning with start time, and apply dayoffset to
+    each timestamp. If biz > 0, we choose the next business day at each time;
+    previous if < 0.
+
+    Parameters
+    ----------
+    start : timestamp-like
+    periods : int
+    dayoffset : int
+    biz : boolean
+
+    Returns
+    -------
+    Array of datetime64
     """
     cdef:
-        Py_ssize_t i, ly, dow
-        int64_t us_in_day, adj, days, y
+        Py_ssize_t i, ly
+        int64_t adj, days, y, dow
         ndarray[int64_t] dtindex
         _TSObject ts
-        npy_datetimestruct dts
 
     ts = convert_to_tsobject(start)
-    us_in_day = conversion_factor(r_microsecond, r_day)
     dtindex = np.empty(periods, np.int64)
 
     dayoffset *= us_in_day
 
-    # applies offset to first element, propogates through array
+    # apply offset to first element, propogates through array
     dtindex[0] = ts.value + dayoffset
-    PyArray_DatetimeToDatetimeStruct(dtindex[0], NPY_FR_us, &dts)
-    dow = dayofweek(dts.year, dts.month, dts.day)
+    dow = ts_dayofweek(ts)
 
     # need bday adjustment?
     if biz != 0:
         adj = weekend_adjustment(dow, biz < 0)
-        dtindex[0] += adj * us_in_day
     else:
         adj = 0
 
+    dtindex[0] += adj * us_in_day
+
     # do we count days in year in y or y+1? ignore offset!
     ly = ts.dtval.month > 2 or (ts.dtval.month == 2 and ts.dtval.day == 29)
     y  = ts.dtval.year
@@ -271,25 +305,36 @@ def generate_annual_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
             adj = weekend_adjustment(dow, biz < 0)
             dtindex[i] += adj * us_in_day
 
-    return dtindex.view(np.datetime64)
+    return dtindex # .view(np.datetime64)
 
-def generate_quarterly_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
-                             int64_t biz=0):
+def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
+                           int64_t stride=1, int64_t biz=0):
     """
-    Generate quarterly timestamps beginning with start time. Apply dayoffset to
-    each timestamp, which allows you to for instance generate month ends. If
-    biz > 0, we choose the next business day; previous if < 0.
+    Generate monthly timestamps beginning with start time, and apply dayoffset to
+    each timestamp. Stride, to construct strided timestamps (eg quarterly). If
+    biz > 0, we choose the next business day at each time; previous if < 0.
+
+    Parameters
+    ----------
+    start : timestamp-like
+    periods : int
+    dayoffset : int
+    stride : int, > 0
+    biz : boolean
+
+    Returns
+    -------
+    Array of datetime64
     """
     cdef:
-        Py_ssize_t i, m1, m2, m3, y1, y2, y3, l1, l2, l3
-        int64_t us_in_day, days, dow, adj
+        Py_ssize_t i, j, m, y, ly
+        int64_t days, dow, adj
         ndarray[int64_t] dtindex
         _TSObject ts
-        npy_datetimestruct dts
 
-    ts = convert_to_tsobject(start)
+    assert(stride > 0, "Stride must be positive")
 
-    us_in_day = conversion_factor(r_microsecond, r_day)
+    ts = convert_to_tsobject(start)
 
     dtindex = np.empty(periods, np.int64)
 
@@ -297,46 +342,35 @@ def generate_quarterly_range(object start, Py_ssize_t periods, int64_t dayoffset
 
     # applies offset to first element, propogates through array
     dtindex[0] = ts.value + dayoffset
-    PyArray_DatetimeToDatetimeStruct(dtindex[0], NPY_FR_us, &dts)
-    dow = dayofweek(dts.year, dts.month, dts.day)
+    dow = ts_dayofweek(ts)
 
     # need bday adjustment?
     if biz != 0:
         adj = weekend_adjustment(dow, biz < 0)
-        dtindex[0] += adj * us_in_day
     else:
         adj = 0
 
+    dtindex[0] += adj * us_in_day
+
     # for day counting. ignore offset
-    m1 = ts.dtval.month - 1
-    m2 = m1 + 1
-    m3 = m2 + 1
-    y3 = y2 = y1 = ts.dtval.year
-    l3 = l2 = l1 = is_leapyear(y1)
+    m = ts.dtval.month - 1
+    y = ts.dtval.year
+    ly = is_leapyear(y)
 
     for i in range(1, periods):
-        if m3 >= 12:
-            m3 -= 12
-            y3 += 1
-            l3 = is_leapyear(y3)
-        if m2 >= 12:
-            m2 -= 12
-            y2 += 1
-            l2 = is_leapyear(y2)
-        if m1 >= 12:
-            m1 -= 12
-            y1 += 1
-            l1 = is_leapyear(y1)
-
-        days = (_days_per_month_table[l1][m1] + _days_per_month_table[l2][m2] +
-                _days_per_month_table[l3][m3])
-
         # reverse prev b-day adjustment
-        dtindex[i] = dtindex[i-1] + us_in_day * (days - adj)
+        dtindex[i] = dtindex[i-1] - adj * us_in_day
 
-        m1 += 3
-        m2 += 3
-        m3 += 3
+        days = 0
+        for j in range(0, stride):
+            if m >= 12:
+                m -= 12
+            y += 1
+            ly = is_leapyear(y)
+            days += _days_per_month_table[ly][m]
+            m += 1
+
+        dtindex[i] += days * us_in_day
 
         # apply new b-day adjustment
         if biz != 0:
@@ -344,111 +378,317 @@ def generate_quarterly_range(object start, Py_ssize_t periods, int64_t dayoffset
             adj = weekend_adjustment(dow, biz < 0)
             dtindex[i] += adj * us_in_day
 
-    return dtindex.view(np.datetime64)
+    return dtindex # .view(np.datetime64)
 
-def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
-                           int64_t biz=0):
+def generate_daily_range(object start, Py_ssize_t periods, int64_t stride=1,
+                         int64_t biz=0):
     """
-    Generate monthly timestamps beginning with start time. Apply dayoffset to
-    each timestamp, which allows you to for instance generate month ends. If
-    biz > 0, we choose the next business day; previous if < 0.
+    Generate daily timestamps beginning with start time. If biz != 0, we skip
+    weekends. Stride, to construct weekly timestamps.
+
+
+    Parameters
+    ----------
+    start : timestamp-like
+    periods : int
+    stride : int, > 0
+    biz : boolean
+
+    Returns
+    -------
+    Array of datetime64
     """
     cdef:
-        Py_ssize_t i, m, y, ly
-        int64_t us_in_day, days, dow, adj
+        Py_ssize_t i
+        int64_t dow, adj
         ndarray[int64_t] dtindex
         _TSObject ts
-        npy_datetimestruct dts
 
-    ts = convert_to_tsobject(start)
+    assert(stride > 0, "Stride must be positive")
 
-    us_in_day = conversion_factor(r_microsecond, r_day)
+    ts = convert_to_tsobject(start)
 
     dtindex = np.empty(periods, np.int64)
 
+    dtindex[0] = ts.value
+    dow = ts_dayofweek(ts)
+
+    # need bday adjustment?
+    if biz != 0:
+        adj = weekend_adjustment(dow, 0)
+        if adj != 0:
+            dow = 0
+    else:
+        adj = 0
+
+    dtindex[0] += adj * us_in_day
+
+    # generate weekdays
+    for i in range(1, periods):
+        dtindex[i] = dtindex[i-1] + (stride * us_in_day)
+        if biz != 0:
+            dow += stride
+            dow %= 7
+            # skip sat., sun.
+            if dow == 5:
+                dtindex[i] += 2 * us_in_day
+                dow = 0
+            elif dow == 6:
+                dtindex[i] += us_in_day
+                dow = 0
+
+    return dtindex #.view(np.datetime64)
+
+# counting logic, helps working with ranges as above
+
+def count_annual_range(object start, object end, int64_t dayoffset=0,
+                       int64_t biz=0):
+    """
+    Count number of periods from first conforming date on or after start,
+    up to but not including end.
+
+    Parameters
+    ----------
+    start : timestamp-like
+    end : timestamp-like
+    dayoffset : int
+    biz : boolean
+
+    Returns
+    -------
+    int
+    """
+    cdef:
+        int64_t i=0, ly, adj, days, y, dow
+        _TSObject s, e
+
+    s = convert_to_tsobject(start)
+    e = convert_to_tsobject(end)
+
+    dayoffset *= us_in_day
+
+    # apply offset to first element, propogates through array
+    t = s.value + dayoffset
+    dow = ts_dayofweek(s)
+
+    # need bday adjustment?
+    if biz != 0:
+        adj = weekend_adjustment(dow, biz < 0)
+    else:
+        adj = 0
+
+    t += adj * us_in_day
+
+    # do we count days in year in y or y+1? ignore offset!
+    ly = s.dtval.month > 2 or (s.dtval.month == 2 and s.dtval.day == 29)
+    y  = s.dtval.year
+
+    while t < e.value:
+        i += 1
+        days = 365 + is_leapyear(y + ly)
+        # reverse prior b-day adjustment
+        t = t + (days - adj) * us_in_day
+        y += 1
+        # apply new b-day adjustment
+        if biz != 0:
+            dow = (dow + days) % 7
+            adj = weekend_adjustment(dow, biz < 0)
+            t += adj * us_in_day
+
+    return i
+
+def count_monthly_range(object start, object end, int64_t dayoffset=0,
+                        int64_t stride=1, int64_t biz=0):
+    """
+    Count number of periods from first conforming date on or after start,
+    up to but not including end.
+
+    Parameters
+    ----------
+    start : timestamp-like
+    end : timestamp-like
+    dayoffset : int
+    stride : int, > 0
+    biz : boolean
+
+    Returns
+    -------
+    int
+    """
+    cdef:
+        Py_ssize_t j, m, y, ly
+        int64_t i=0, t, days, dow, adj
+        _TSObject s, e
+
+    assert(stride > 0, "Stride must be positive")
+
+    s = convert_to_tsobject(start)
+    e = convert_to_tsobject(end)
+
     dayoffset *= us_in_day
 
     # applies offset to first element, propogates through array
-    dtindex[0] = ts.value + dayoffset
-    PyArray_DatetimeToDatetimeStruct(dtindex[0], NPY_FR_us, &dts)
-    dow = dayofweek(dts.year, dts.month, dts.day)
+    t = s.value + dayoffset
+    dow = ts_dayofweek(s)
 
     # need bday adjustment?
     if biz != 0:
         adj = weekend_adjustment(dow, biz < 0)
-        dtindex[0] += adj * us_in_day
     else:
         adj = 0
 
-    # for day counting. ignore offset
-    m = ts.dtval.month - 1
-    y = ts.dtval.year
+    t += adj * us_in_day
+
+    # for day counting
+    m = s.dtval.month - 1
+    y = s.dtval.year
     ly = is_leapyear(y)
 
-    for i in range(1, periods):
-        if m >= 12:
-            m -= 12
+    while t < e.value:
+        i += 1
+        # reverse prev b-day adjustment
+        t = t - adj * us_in_day
+
+        days = 0
+        for j in range(0, stride):
+            if m >= 12:
+                m -= 12
             y += 1
             ly = is_leapyear(y)
+            days += _days_per_month_table[ly][m]
+            m += 1
 
-        days = _days_per_month_table[ly][m]
-
-        # reverse prev b-day adjustment
-        dtindex[i] = dtindex[i-1] + us_in_day * (days - adj)
-
-        m += 1
+        t += days * us_in_day
 
         # apply new b-day adjustment
         if biz != 0:
             dow = (dow + days) % 7
             adj = weekend_adjustment(dow, biz < 0)
-            dtindex[i] += adj * us_in_day
+            t += adj * us_in_day
 
-    return dtindex.view(np.datetime64)
+    return i
 
-def generate_daily_range(object start, Py_ssize_t periods,
-                         int64_t biz=0, int64_t stride=1):
+def count_daily_range(object start, object end, stride=1, int64_t biz=0):
     """
-    Generate daily timestamps beginning with start time. If biz != 0, we choose
-    the next business day. Stride, to construct weekly timestamps.
+    Count number of periods from first conforming date on or after start,
+    up to but not including end.
+
+    Parameters
+    ----------
+    start : timestamp-like
+    end : timestamp-like
+    stride : int, > 0
+    biz : boolean
+
+    Returns
+    -------
+    int
     """
     cdef:
-        Py_ssize_t i
-        int64_t us_in_day, dow, adj
-        ndarray[int64_t] dtindex
-        _TSObject ts
-        npy_datetimestruct dts
-
-    ts = convert_to_tsobject(start)
+        int64_t i=0, t, dow, adj
+        _TSObject s, e
 
-    us_in_day = conversion_factor(r_microsecond, r_day)
+    assert(stride > 0, "Stride must be positive")
 
-    dtindex = np.empty(periods, np.int64)
+    s = convert_to_tsobject(start)
+    e = convert_to_tsobject(end)
 
-    # applies offset to first element, propogates through array
-    dtindex[0] = ts.value
-    dow = dayofweek(ts.dtval.year, ts.dtval.month, ts.dtval.day)
+    t = s.value
+    dow = ts_dayofweek(s)
 
     # need bday adjustment?
     if biz != 0:
         adj = weekend_adjustment(dow, 0)
         if adj != 0:
-            dtindex[0] += adj * us_in_day
             dow = 0
+    else:
+        adj = 0
+
+    t += adj * us_in_day
 
     # generate weekdays
-    for i in range(1, periods):
-        dtindex[i] = dtindex[i-1] + (stride * us_in_day)
+    while t < e.value:
+        i += 1
+        t = t + (stride * us_in_day)
         if biz != 0:
             dow += stride
             dow %= 7
             # skip sat., sun.
-            if dow >= 5:
-                dtindex[i] += 2 * us_in_day
+            if dow == 5:
+                t += 2 * us_in_day
+                dow = 0
+            elif dow == 6:
+                t += us_in_day
                 dow = 0
 
-    return dtindex.view(np.datetime64)
+    return i
+
+# Here's some frequency caching logic
+# ----------------------------------------------------------------------------------
+
+_CACHE_START = Timestamp(datetime(1950, 1, 1))
+_CACHE_END   = Timestamp(datetime(2030, 1, 1))
+
+_fcache = {}
+
+def _get_freq(freq, start, end=None, n=None):
+    # TODO: need some logic to auto-(re)size cache
+
+    if freq not in _fcache:
+        #  generate range to cache
+        if freq == 'WEEKDAY':
+            per = count_daily_range(_CACHE_START, _CACHE_END, biz=1)
+            rng = generate_daily_range(_CACHE_START, per + 1, biz=1)
+        elif freq == 'DAILY':
+            per = count_daily_range(_CACHE_START, _CACHE_END, biz=0)
+            rng = generate_daily_range(_CACHE_START, per + 1, biz=0)
+        elif freq == 'EOM':
+            per = count_monthly_range(_CACHE_START, _CACHE_END, dayoffset=-1, biz=-1)
+            rng = generate_monthly_range(_CACHE_START, per + 1, dayoffset=-1, biz=-1)
+        elif freq.startswith('W@'):
+            begin = _CACHE_START
+            offset = _CACHE_START.weekday()
+            if freq.endswith('MON'):
+                offset = (0 - offset) % 7
+            elif freq.endswith('TUE'):
+                offset = (1 - offset) % 7
+            elif freq.endswith('WED'):
+                offset = (2 - offset) % 7
+            elif freq.endswith('THU'):
+                offset = (3 - offset) % 7
+            elif freq.endswith('FRI'):
+                offset = (4 - offset) % 7
+            else:
+                raise ValueError('Bad weekday %s' % freq)
+            begin += timedelta(days=offset)
+
+            per = count_daily_range(begin, _CACHE_END, stride=7, biz=1)
+            rng = generate_daily_range(begin, per + 1, stride=7, biz=1)
+        else:
+            raise ValueError('Supplied frequency %s not implemented' % freq)
+
+        # cache range
+        _fcache[freq] = rng
+
+    rng = _fcache[freq]
+    start = Timestamp(start)
+
+    if start.value < rng[0]:
+        raise ValueError('Fell off cache, expand timestamp cache')
+
+    first = rng.searchsorted(start.value)
+
+    if n is not None:
+        if n >= len(rng):
+            raise ValueError('Fell off cache, expand timestamp cache')
+        last = first + n - 1
+    else:
+        endval = Timestamp(end).value
+        if endval > rng[-1]:
+            raise ValueError('Fell off cache, expand timestamp cache')
+        last = rng.searchsorted(endval)
 
+    return (rng, first, last)
 
 # The following is derived from relativedelta.py in dateutil package
 # ------------------------------------------------------------------------------
@@ -1103,3 +1343,7 @@ def monthrange(int64_t year, int64_t month):
 
     return (dayofweek(year, month, 1), days)
 
+cdef inline int64_t ts_dayofweek(_TSObject ts):
+    cdef npy_datetimestruct dts
+    PyArray_DatetimeToDatetimeStruct(ts.value, NPY_FR_us, &dts)
+    return dayofweek(dts.year, dts.month, dts.day)
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index 3d5a62d9a..ba2193005 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -10,6 +10,8 @@ from pandas.core.daterange import DateRange, generate_range
 import pandas.core.daterange as daterange
 import pandas.util.testing as tm
 
+import pandas._tseries as lib
+
 try:
     import pytz
 except ImportError:
@@ -351,6 +353,108 @@ class TestDateRange(unittest.TestCase):
         result = rng1.union(rng2)
         self.assert_(type(result) == DateRange)
 
+class TestDatetimePyx(unittest.TestCase):
+
+    def test_gen_ann_range(self):
+        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=0)
+
+        self.assert_(len(rng) == 12)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1)
+            self.assert_(t.year == 2002 + i)
+
+        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
+                dayoffset=-1, biz=0)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.day == 31)
+            self.assert_(t.month == 12)
+            self.assert_(t.year == 2001 + i)
+
+        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=-1)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() < 5)
+
+        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=1)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() < 5)
+
+    def test_gen_mth_range(self):
+        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=0)
+
+        self.assert_(len(rng) == 12)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1 + i)
+            self.assert_(t.year == 2002)
+
+        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
+                dayoffset=-1, biz=0)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.day >= 28)
+            self.assert_(t.month == (12 if i == 0 else i))
+            self.assert_(t.year == 2001 + (i != 0))
+
+        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=-1)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() < 5)
+
+        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
+                dayoffset=0, biz=1)
+
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() < 5)
+
+        for i in (-2, -1, 1, 2):
+            for j in (-1, 0, 1):
+                rng1 = lib.generate_annual_range(datetime(2002,1,1),
+                        periods=12, dayoffset=i, biz=j)
+                rng2 = lib.generate_monthly_range(datetime(2002,1,1),
+                        periods=12, dayoffset=i, biz=j, stride=12)
+                self.assert_((rng1 == rng2).all())
+
+    def test_gen_dly_range(self):
+        rng = lib.generate_daily_range(datetime(2002,1,1), periods=365, biz=0)
+        self.assert_(len(rng) == 365)
+
+        ts = lib.Timestamp(rng[-1])
+        self.assert_(ts.day == 31)
+        self.assert_(ts.month == 12)
+        self.assert_(ts.year == 2002)
+
+        rng = lib.generate_daily_range(datetime(2004,1,1), periods=366, biz=0)
+        self.assert_(len(rng) == 366)
+
+        ts = lib.Timestamp(rng[-1])
+        self.assert_(ts.day == 31)
+        self.assert_(ts.month == 12)
+        self.assert_(ts.year == 2004)
+
+        rng = lib.generate_daily_range(datetime(2002,1,1), periods=365, biz=1)
+        for i, t in enumerate(rng):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() < 5)
+
 if tm.PERFORM_DATETIME64_TESTS:
     class TestDatetime64Range(TestDateRange):
         def setUp(self):

commit 6cdea33d0b384ecb8bdc694fd8388618d32bca63
Author: jreback <jeff@reback.net>
Date:   Wed Feb 13 08:32:02 2013 -0500

    CLN: cleaned up _possibly_convert_platform

diff --git a/RELEASE.rst b/RELEASE.rst
index 11b047e4f..253505553 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -53,9 +53,9 @@ pandas 0.11.0
 
   - Do not automatically upcast numeric specified dtypes to ``int64`` or
     ``float64`` (GH622_ and GH797_)
-  - DataFrame construction of lists will no longer be platform dependent when
-    dtype is NOT specified, e.g. DataFrame([1,2]) will be ``int64``
-    like DataFrame({'a' : [1,2]})
+  - DataFrame construction of lists and scalars, with no dtype present, will
+    result in casting to ``int64`` or ``float64``, regardless of platform.
+    This is not an apparent change in the API, but noting it.
   - Guarantee that ``convert_objects()`` for Series/DataFrame always returns a
     copy
   - groupby operations will respect dtypes for numeric float operations
diff --git a/doc/source/v0.11.0.txt b/doc/source/v0.11.0.txt
index a03cfcbad..fd78ba7cf 100644
--- a/doc/source/v0.11.0.txt
+++ b/doc/source/v0.11.0.txt
@@ -57,11 +57,17 @@ Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passe
 
 **Platform Gotchas**
 
-In versions prior to 0.11.0, DataFrame construction with lists was platform dependent (meaning 32-bit vs 64-bit). 
-``DataFrame([1,2],columns=['a'])`` would have a dtype of ``int32``, 
-while ``DataFrame({'a' : [1,2] })`` would be ``int64``. 
-Now construction dtype defaults will be handled in a platform independent manor, 
-resulting in defaults for integers of ``int64`` and floats of ``float64`` dtypes.
+Starting in 0.11.0, construction of DataFrame/Series will use default dtypes of ``int64`` and ``float64``,
+*regardless of platform*. This is not an apparent change from earlier versions of pandas. If you specify
+dtypes, they *WILL* be respected, however.
+
+The following will all result in ``int64`` dtypes
+
+.. ipython:: python
+
+    DataFrame([1,2],columns=['a']).dtypes
+    DataFrame({'a' : [1,2] }.dtypes
+    DataFrame({'a' : 1).dtypes
 
 Keep in mind that ``DataFrame(np.array([1,2]))`` **WILL** result in ``int32`` on 32-bit platforms!
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index b791fa4f6..51e14b054 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -643,6 +643,21 @@ def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None,
     take_f(arr, indexer, out=out, fill_value=fill_value)
     return out
 
+def _dtype_from_scalar(val):
+    """ interpret the dtype from a scalar, upcast floats and ints """
+    if isinstance(val, np.datetime64):
+        # ugly hacklet
+        val = lib.Timestamp(val).value
+        return val, np.dtype('M8[ns]')
+
+    # provide implicity upcast on scalars
+    elif is_integer(val):
+        if not is_bool(val):
+            return val, np.int64
+    elif is_float(val):
+        return val, np.float64
+
+    return val, type(val)
 
 def _maybe_promote(dtype, fill_value=np.nan):
     if issubclass(dtype.type, np.datetime64):
@@ -654,7 +669,7 @@ def _maybe_promote(dtype, fill_value=np.nan):
         if issubclass(dtype.type, np.bool_):
             return np.object_
         elif issubclass(dtype.type, np.integer):
-            return np.float_
+            return np.float64
         return dtype
     elif is_bool(fill_value):
         if issubclass(dtype.type, np.bool_):
@@ -682,7 +697,7 @@ def _maybe_promote(dtype, fill_value=np.nan):
 def _maybe_upcast(values):
     # TODO: convert remaining usage of _maybe_upcast to _maybe_promote
     if issubclass(values.dtype.type, np.integer):
-        values = values.astype(np.float_)
+        values = values.astype(np.float64)
     elif issubclass(values.dtype.type, np.bool_):
         values = values.astype(np.object_)
     return values
@@ -805,11 +820,11 @@ def _consensus_name_attr(objs):
 # Lots of little utilities
 
 
-def _possibly_convert_objects(values, convert_dates=True, convert_numeric=True, convert_platform=False):
+def _possibly_convert_objects(values, convert_dates=True, convert_numeric=True):
     """ if we have an object dtype, try to coerce dates and/or numers """
 
     # convert dates
-    if convert_dates and getattr(values,'dtype',None) == np.object_:
+    if convert_dates and values.dtype == np.object_:
 
         # we take an aggressive stance and convert to datetime64[ns]
         if convert_dates == 'coerce':
@@ -823,7 +838,7 @@ def _possibly_convert_objects(values, convert_dates=True, convert_numeric=True,
             values = lib.maybe_convert_objects(values, convert_datetime=convert_dates)
 
     # convert to numeric
-    if convert_numeric and getattr(values,'dtype',None) == np.object_:
+    if convert_numeric and values.dtype == np.object_:
         try:
             new_values = lib.maybe_convert_numeric(values,set(),coerce_numeric=True)
             
@@ -834,13 +849,15 @@ def _possibly_convert_objects(values, convert_dates=True, convert_numeric=True,
         except:
             pass
 
-    # platform conversion
-    #   allow ndarray or list here
-    if convert_platform:
-        if isinstance(values, (list,tuple)):
-            values = lib.list_to_object_array(values)
-        if values.dtype == np.object_:
-            values = lib.maybe_convert_objects(values)
+    return values
+
+def _possibly_convert_platform(values):
+    """ try to do platform conversion, allow ndarray or list here """
+
+    if isinstance(values, (list,tuple)):
+        values = lib.list_to_object_array(values)
+    if values.dtype == np.object_:
+        values = lib.maybe_convert_objects(values)
 
     return values
 
@@ -887,12 +904,13 @@ def _possibly_cast_to_datetime(value, dtype, coerce = False):
 
 
 def _infer_dtype(value):
+    # provide upcasting here for floats/ints
     if isinstance(value, (float, np.floating)):
-        return np.float_
+        return np.float64
     elif isinstance(value, (bool, np.bool_)):
         return np.bool_
     elif isinstance(value, (int, long, np.integer)):
-        return np.int_
+        return np.int64
     elif isinstance(value, (complex, np.complexfloating)):
         return np.complex_
     else:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ebf4fe39b..d60ae4477 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -23,13 +23,13 @@ import numpy as np
 import numpy.ma as ma
 
 from pandas.core.common import (isnull, notnull, PandasError, _try_sort,
-                                _default_index, _is_sequence)
+                                _default_index, _is_sequence, _dtype_from_scalar)
 from pandas.core.generic import NDFrame
 from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas.core.indexing import (_NDFrameIndexer, _maybe_droplevels,
                                   _is_index_slice, _check_bool_indexer)
 from pandas.core.internals import BlockManager, make_block, form_blocks
-from pandas.core.series import Series, _radd_compat, _dtype_from_scalar
+from pandas.core.series import Series, _radd_compat
 from pandas.compat.scipy import scoreatpercentile as _quantile
 from pandas.util.compat import OrderedDict
 from pandas.util import py3compat
@@ -2207,6 +2207,9 @@ class DataFrame(NDFrame):
             if key in self.columns:
                 existing_piece = self[key]
 
+                # upcast the scalar
+                value, dtype = _dtype_from_scalar(value)
+
                 # transpose hack
                 if isinstance(existing_piece, DataFrame):
                     shape = (len(existing_piece.columns), len(self.index))
@@ -2214,14 +2217,19 @@ class DataFrame(NDFrame):
                 else:
                     value = np.repeat(value, len(self.index))
 
-                    # special case for now
+                    # special case for now (promotion)
                     if (com.is_float_dtype(existing_piece) and
                             com.is_integer_dtype(value)):
-                        value = value.astype(np.float64)
+                        dtype = np.float64
+                        
+                value = value.astype(dtype)
 
             else:
-                value = np.repeat(value, len(self.index))
+                # upcast the scalar
+                value, dtype = _dtype_from_scalar(value)
+                value = np.array(np.repeat(value, len(self.index)), dtype=dtype)
 
+            value = com._possibly_cast_to_datetime(value, dtype)
         return np.atleast_2d(np.asarray(value))
 
     def pop(self, item):
@@ -5461,11 +5469,7 @@ def _prep_ndarray(values, copy=True):
             return np.empty((0, 0), dtype=object)
 
         def convert(v):
-            return com._possibly_convert_objects(v,
-                                                 convert_dates=False,
-                                                 convert_numeric=False,
-                                                 convert_platform=True)
-
+            return com._possibly_convert_platform(v)
 
         # we could have a 1-dim or 2-dim list here
         # this is equiv of np.asarray, but does object conversion
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 14e3dacb5..64b90fddf 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -3113,10 +3113,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                 subarr = lib.maybe_convert_objects(subarr)
             
         else:
-            subarr = com._possibly_convert_objects(data,
-                                                   convert_dates=False,
-                                                   convert_numeric=False,
-                                                   convert_platform=True)
+            subarr = com._possibly_convert_platform(data)
 
         subarr = com._possibly_cast_to_datetime(subarr, dtype)
 
@@ -3145,7 +3142,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                     dtype = value.dtype
                     value = value.item()
                 else:
-                    value, dtype = _dtype_from_scalar(value)
+                    value, dtype = com._dtype_from_scalar(value)
 
                 subarr = pa.empty(len(index), dtype=dtype)
             else:
@@ -3180,14 +3177,6 @@ def _sanitize_array(data, index, dtype=None, copy=False,
     return subarr
 
 
-def _dtype_from_scalar(val):
-    if isinstance(val, np.datetime64):
-        # ugly hacklet
-        val = lib.Timestamp(val).value
-        return val, np.dtype('M8[ns]')
-    return val, type(val)
-
-
 def _get_rename_function(mapper):
     if isinstance(mapper, (dict, Series)):
         def f(x):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 9b46c6eac..424d6e2e6 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -372,6 +372,11 @@ class CheckIndexing(object):
         self.assertEqual(smaller['col10'].dtype, np.object_)
         self.assert_((smaller['col10'] == ['1', '2']).all())
 
+        # with a dtype
+        for dtype in ['int32','int64','float32','float64']:
+            self.frame[dtype] = np.array(arr,dtype=dtype)
+            self.assert_(self.frame[dtype].dtype.name == dtype)
+
     def test_setitem_tuple(self):
         self.frame['A', 'B'] = self.frame['A']
         assert_series_equal(self.frame['A', 'B'], self.frame['A'])
@@ -437,7 +442,7 @@ class CheckIndexing(object):
 
         # #669, should not cast?
         self.frame['B'] = 0
-        self.assert_(self.frame['B'].dtype == np.float_)
+        self.assert_(self.frame['B'].dtype == np.float64)
 
         # cast if pass array of course
         self.frame['B'] = np.arange(len(self.frame))
@@ -445,18 +450,18 @@ class CheckIndexing(object):
 
         self.frame['foo'] = 'bar'
         self.frame['foo'] = 0
-        self.assert_(self.frame['foo'].dtype == np.int_)
+        self.assert_(self.frame['foo'].dtype == np.int64)
 
         self.frame['foo'] = 'bar'
         self.frame['foo'] = 2.5
-        self.assert_(self.frame['foo'].dtype == np.float_)
+        self.assert_(self.frame['foo'].dtype == np.float64)
 
         self.frame['something'] = 0
-        self.assert_(self.frame['something'].dtype == np.int_)
+        self.assert_(self.frame['something'].dtype == np.int64)
         self.frame['something'] = 2
-        self.assert_(self.frame['something'].dtype == np.int_)
+        self.assert_(self.frame['something'].dtype == np.int64)
         self.frame['something'] = 2.5
-        self.assert_(self.frame['something'].dtype == np.float_)
+        self.assert_(self.frame['something'].dtype == np.float64)
 
     def test_setitem_boolean_column(self):
         expected = self.frame.copy()
@@ -490,8 +495,12 @@ class CheckIndexing(object):
         self.assertEqual(len(dm.columns), 2)
         self.assertEqual(dm.values.dtype, np.object_)
 
+        # upcast
         dm['C'] = 1
-        self.assertEqual(dm['C'].dtype, np.int_)
+        self.assertEqual(dm['C'].dtype, np.int64)
+
+        dm['E'] = 1.
+        self.assertEqual(dm['E'].dtype, np.float64)
 
         # set existing column
         dm['A'] = 'bar'
@@ -2369,9 +2378,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                 'float': 3., 'complex': 4j, 'object': 'foo'}
         df = DataFrame(data, index=np.arange(10))
 
-        self.assert_(df['int'].dtype == np.int_)
+        self.assert_(df['int'].dtype == np.int64)
         self.assert_(df['bool'].dtype == np.bool_)
-        self.assert_(df['float'].dtype == np.float_)
+        self.assert_(df['float'].dtype == np.float64)
         self.assert_(df['complex'].dtype == np.complex128)
         self.assert_(df['object'].dtype == np.object_)
 
@@ -2689,9 +2698,16 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                           columns=['b', 'a', 'a'])
 
     def test_constructor_single_value(self):
+
+        # expecting single value upcasting here 
         df = DataFrame(0., index=[1, 2, 3], columns=['a', 'b', 'c'])
-        assert_frame_equal(df, DataFrame(np.zeros(df.shape), df.index,
+        assert_frame_equal(df, DataFrame(np.zeros(df.shape).astype('float64'), df.index,
+                                         df.columns))
+ 
+        df = DataFrame(0, index=[1, 2, 3], columns=['a', 'b', 'c'])
+        assert_frame_equal(df, DataFrame(np.zeros(df.shape).astype('int64'), df.index,
                                          df.columns))
+ 
 
         df = DataFrame('a', index=[1, 2], columns=['a', 'c'])
         assert_frame_equal(df, DataFrame(np.array([['a', 'a'],
@@ -2705,6 +2721,136 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(
             com.PandasError, DataFrame, 'a', [1, 2], ['a', 'c'], float)
 
+
+    def test_constructor_with_datetimes(self):
+        intname = np.dtype(np.int_).name
+        floatname = np.dtype(np.float_).name
+        datetime64name = np.dtype('M8[ns]').name
+        objectname = np.dtype(np.object_).name
+
+        # single item
+        df = DataFrame({'A' : 1, 'B' : 'foo', 'C' : 'bar', 'D' : Timestamp("20010101"), 'E' : datetime(2001,1,2,0,0) },
+                       index=np.arange(10))
+        result = df.get_dtype_counts()
+        expected = Series({'int64': 1, datetime64name: 2, objectname : 2})
+        result.sort()
+        expected.sort()
+        assert_series_equal(result, expected)
+
+        # check with ndarray construction ndim==0 (e.g. we are passing a ndim 0 ndarray with a dtype specified)
+        df = DataFrame({'a': 1., 'b': 2, 'c': 'foo', floatname : np.array(1.,dtype=floatname),
+                        intname : np.array(1,dtype=intname)}, index=np.arange(10))
+        result = df.get_dtype_counts()
+        expected = { objectname : 1 }
+        if intname == 'int64':
+            expected['int64'] = 2
+        else:
+            expected['int64'] = 1
+            expected[intname] = 1
+        if floatname == 'float64':
+            expected['float64'] = 2
+        else:
+            expected['float64'] = 1
+            expected[floatname] = 1
+
+        result.sort()
+        expected = Series(expected)
+        expected.sort()
+        assert_series_equal(result, expected)
+
+        # check with ndarray construction ndim>0
+        df = DataFrame({'a': 1., 'b': 2, 'c': 'foo', floatname : np.array([1.]*10,dtype=floatname),
+                        intname : np.array([1]*10,dtype=intname)}, index=np.arange(10))
+        result = df.get_dtype_counts()
+        result.sort()
+        assert_series_equal(result, expected)
+
+        # GH 2809
+        from pandas import date_range
+        ind = date_range(start="2000-01-01", freq="D", periods=10)
+        datetimes = [ts.to_pydatetime() for ts in ind]
+        datetime_s = Series(datetimes)
+        self.assert_(datetime_s.dtype == 'M8[ns]')
+        df = DataFrame({'datetime_s':datetime_s})
+        result = df.get_dtype_counts()
+        expected = Series({ datetime64name : 1 })
+        result.sort()
+        expected.sort()
+        assert_series_equal(result, expected)
+
+        # GH 2810
+        ind = date_range(start="2000-01-01", freq="D", periods=10)
+        datetimes = [ts.to_pydatetime() for ts in ind]
+        dates = [ts.date() for ts in ind]
+        df = DataFrame({'datetimes': datetimes, 'dates':dates})
+        result = df.get_dtype_counts()
+        expected = Series({ datetime64name : 1, objectname : 1 })
+        result.sort()
+        expected.sort()
+        assert_series_equal(result, expected)
+
+    def test_constructor_for_list_with_dtypes(self):
+        intname = np.dtype(np.int_).name
+        floatname = np.dtype(np.float_).name
+        datetime64name = np.dtype('M8[ns]').name
+        objectname = np.dtype(np.object_).name
+
+        # test list of lists/ndarrays
+        df = DataFrame([np.arange(5) for x in range(5)])
+        result = df.get_dtype_counts()
+        expected = Series({'int64' : 5})
+
+        df = DataFrame([np.array(np.arange(5),dtype='int32') for x in range(5)])
+        result = df.get_dtype_counts()
+        expected = Series({'int32' : 5})
+
+        # overflow issue? (we always expecte int64 upcasting here)
+        df = DataFrame({'a' : [2**31,2**31+1]})
+        result = df.get_dtype_counts()
+        expected = Series({'int64' : 1 })
+        assert_series_equal(result, expected)
+
+        # GH #2751 (construction with no index specified), make sure we cast to platform values
+        df = DataFrame([1, 2])
+        result = df.get_dtype_counts()
+        expected = Series({'int64': 1 })
+        assert_series_equal(result, expected)
+
+        df = DataFrame([1.,2.])
+        result = df.get_dtype_counts()
+        expected = Series({'float64' : 1 })
+        assert_series_equal(result, expected)
+
+        df = DataFrame({'a' : [1, 2]})
+        result = df.get_dtype_counts()
+        expected = Series({'int64' : 1})
+        assert_series_equal(result, expected)
+
+        df = DataFrame({'a' : [1., 2.]})
+        result = df.get_dtype_counts()
+        expected = Series({'float64' : 1})
+        assert_series_equal(result, expected)
+
+        df = DataFrame({'a' : 1 }, index=range(3))
+        result = df.get_dtype_counts()
+        expected = Series({'int64': 1})
+        assert_series_equal(result, expected)
+
+        df = DataFrame({'a' : 1. }, index=range(3))
+        result = df.get_dtype_counts()
+        expected = Series({'float64': 1 })
+        assert_series_equal(result, expected)
+
+        # with object list
+        df = DataFrame({'a':[1,2,4,7], 'b':[1.2, 2.3, 5.1, 6.3], 
+                        'c':list('abcd'), 'd':[datetime(2000,1,1) for i in range(4)],
+                        'e' : [1.,2,4.,7]})
+        result = df.get_dtype_counts()
+        expected = Series({'int64': 1, 'float64' : 2, datetime64name: 1, objectname : 1})
+        result.sort()
+        expected.sort()
+        assert_series_equal(result, expected)
+
     def test_new_empty_index(self):
         df1 = DataFrame(randn(0, 3))
         df2 = DataFrame(randn(0, 3))
@@ -2757,8 +2903,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         casted = mn.astype('float32')
         _check_cast(casted, 'float32')
 
-        casted = mn.astype('int32')
-        _check_cast(casted, 'int32')
+        # this is platform dependent overflow
+        if np.int_ == np.int32:
+            self.assertRaises(OverflowError, mn.astype, 'int32')
+        else:
+            casted = mn.astype('int32')
+            _check_cast(casted, 'int32')
 
         # to object
         casted = mn.astype('O')
@@ -7156,7 +7306,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         df = DataFrame({'a': 1., 'b': 2, 'c': 'foo', 'f' : Timestamp('20010102')},
                        index=np.arange(10))
         result = df.get_dtype_counts()
-        expected = Series({intname: 1, floatname : 1, datetime64name: 1, objectname : 1})
+        expected = Series({'int64': 1, 'float64' : 1, datetime64name: 1, objectname : 1})
         result.sort()
         expected.sort()
         assert_series_equal(result, expected)
@@ -8099,105 +8249,6 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         values = self.mixed_int.as_matrix(['C'])
         self.assert_(values.dtype == np.uint8)
 
-
-    def test_constructor_with_datetimes(self):
-        intname = np.dtype(np.int_).name
-        floatname = np.dtype(np.float_).name
-        datetime64name = np.dtype('M8[ns]').name
-        objectname = np.dtype(np.object_).name
-
-        # single item
-        df = DataFrame({'A' : 1, 'B' : 'foo', 'C' : 'bar', 'D' : Timestamp("20010101"), 'E' : datetime(2001,1,2,0,0) },
-                       index=np.arange(10))
-        result = df.get_dtype_counts()
-        expected = Series({intname: 1, datetime64name: 2, objectname : 2})
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
-        # check with ndarray construction ndim==0 (e.g. we are passing a ndim 0 ndarray with a dtype specified)
-        df = DataFrame({'a': 1., 'b': 2, 'c': 'foo', floatname : np.array(1.,dtype=floatname),
-                        intname : np.array(1,dtype=intname)}, index=np.arange(10))
-        result = df.get_dtype_counts()
-        expected = Series({intname: 2, floatname : 2, objectname : 1})
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
-        # check with ndarray construction ndim>0
-        df = DataFrame({'a': 1., 'b': 2, 'c': 'foo', floatname : np.array([1.]*10,dtype=floatname),
-                        intname : np.array([1]*10,dtype=intname)}, index=np.arange(10))
-        result = df.get_dtype_counts()
-        expected = Series({intname: 2, floatname : 2, objectname : 1})
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
-    def test_constructor_for_list_with_dtypes(self):
-        intname = np.dtype(np.int_).name
-        floatname = np.dtype(np.float_).name
-        datetime64name = np.dtype('M8[ns]').name
-        objectname = np.dtype(np.object_).name
-
-        # test list of lists/ndarrays
-        df = DataFrame([np.arange(5) for x in range(5)])
-        result = df.get_dtype_counts()
-        expected = Series({'int64' : 5})
-
-        df = DataFrame([np.array(np.arange(5),dtype='int32') for x in range(5)])
-        result = df.get_dtype_counts()
-        expected = Series({'int32' : 5})
-
-        # overflow issue? (we always expecte int64 upcasting here)
-        df = DataFrame({'a' : [2**31,2**31+1]})
-        result = df.get_dtype_counts()
-        expected = Series({'int64' : 1 })
-        assert_series_equal(result, expected)
-
-        # GH #2751 (construction with no index specified), make sure we cast to platform values
-        df = DataFrame([1, 2])
-        result = df.get_dtype_counts()
-        expected = Series({'int64': 1 })
-        assert_series_equal(result, expected)
-
-        df = DataFrame({'a' : [1, 2]})
-        result = df.get_dtype_counts()
-        expected = Series({'int64': 1 })
-        assert_series_equal(result, expected)
-
-        df = DataFrame({'a':[1,2,4,7], 'b':[1.2, 2.3, 5.1, 6.3], 
-                        'c':list('abcd'), 'd':[datetime(2000,1,1) for i in range(4)],
-                        'e' : [1.,2,4.,7]})
-        result = df.get_dtype_counts()
-        expected = Series({'int64': 1, 'float64' : 2, datetime64name: 1, objectname : 1})
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
-        # GH 2809
-        from pandas import date_range
-        ind = date_range(start="2000-01-01", freq="D", periods=10)
-        datetimes = [ts.to_pydatetime() for ts in ind]
-        datetime_s = Series(datetimes)
-        self.assert_(datetime_s.dtype == 'M8[ns]')
-        df = DataFrame({'datetime_s':datetime_s})
-        result = df.get_dtype_counts()
-        expected = Series({ datetime64name : 1 })
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
-        # GH 2810
-        ind = date_range(start="2000-01-01", freq="D", periods=10)
-        datetimes = [ts.to_pydatetime() for ts in ind]
-        dates = [ts.date() for ts in ind]
-        df = DataFrame({'datetimes': datetimes, 'dates':dates})
-        result = df.get_dtype_counts()
-        expected = Series({ datetime64name : 1, objectname : 1 })
-        result.sort()
-        expected.sort()
-        assert_series_equal(result, expected)
-
     def test_constructor_frame_copy(self):
         cop = DataFrame(self.frame, copy=True)
         cop['A'] = 5
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 07a02f18d..da7a0f68b 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -418,7 +418,7 @@ class CheckIndexing(object):
         # scalar
         self.panel['ItemG'] = 1
         self.panel['ItemE'] = True
-        self.assert_(self.panel['ItemG'].values.dtype == np.int_)
+        self.assert_(self.panel['ItemG'].values.dtype == np.int64)
         self.assert_(self.panel['ItemE'].values.dtype == np.bool_)
 
         # object dtype
diff --git a/pandas/tests/test_panel4d.py b/pandas/tests/test_panel4d.py
index 87bfba7c5..5bb452deb 100644
--- a/pandas/tests/test_panel4d.py
+++ b/pandas/tests/test_panel4d.py
@@ -358,7 +358,7 @@ class CheckIndexing(object):
         # scalar
         self.panel4d['lG'] = 1
         self.panel4d['lE'] = True
-        self.assert_(self.panel4d['lG'].values.dtype == np.int_)
+        self.assert_(self.panel4d['lG'].values.dtype == np.int64)
         self.assert_(self.panel4d['lE'].values.dtype == np.bool_)
 
         # object dtype
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 8820d4397..d1c4710c1 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -287,7 +287,7 @@ class TestMerge(unittest.TestCase):
         df1 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
                         index=np.arange(10),
                         columns=['A', 'B', 'C', 'D'])
-        self.assert_(df1['B'].dtype == np.int)
+        self.assert_(df1['B'].dtype == np.int64)
         self.assert_(df1['D'].dtype == np.bool_)
 
         df2 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},

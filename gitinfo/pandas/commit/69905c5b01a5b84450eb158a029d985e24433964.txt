commit 69905c5b01a5b84450eb158a029d985e24433964
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Sat Mar 9 16:29:32 2019 +0000

    STY: use pytest.raises context manager (generic) (#25603)

diff --git a/pandas/tests/generic/test_generic.py b/pandas/tests/generic/test_generic.py
index c2f6cbf4c..6f2707f76 100644
--- a/pandas/tests/generic/test_generic.py
+++ b/pandas/tests/generic/test_generic.py
@@ -7,7 +7,7 @@ from warnings import catch_warnings, simplefilter
 import numpy as np
 import pytest
 
-from pandas.compat import PY3, range, zip
+from pandas.compat import PY2, PY3, range, zip
 
 from pandas.core.dtypes.common import is_scalar
 
@@ -16,8 +16,6 @@ from pandas import DataFrame, MultiIndex, Panel, Series, date_range
 import pandas.util.testing as tm
 from pandas.util.testing import assert_frame_equal, assert_series_equal
 
-import pandas.io.formats.printing as printing
-
 # ----------------------------------------------------------------------
 # Generic types test cases
 
@@ -135,37 +133,51 @@ class Generic(object):
         # GH 4633
         # look at the boolean/nonzero behavior for objects
         obj = self._construct(shape=4)
-        pytest.raises(ValueError, lambda: bool(obj == 0))
-        pytest.raises(ValueError, lambda: bool(obj == 1))
-        pytest.raises(ValueError, lambda: bool(obj))
+        msg = "The truth value of a {} is ambiguous".format(
+            self._typ.__name__)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 0)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 1)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj)
 
         obj = self._construct(shape=4, value=1)
-        pytest.raises(ValueError, lambda: bool(obj == 0))
-        pytest.raises(ValueError, lambda: bool(obj == 1))
-        pytest.raises(ValueError, lambda: bool(obj))
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 0)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 1)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj)
 
         obj = self._construct(shape=4, value=np.nan)
-        pytest.raises(ValueError, lambda: bool(obj == 0))
-        pytest.raises(ValueError, lambda: bool(obj == 1))
-        pytest.raises(ValueError, lambda: bool(obj))
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 0)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj == 1)
+        with pytest.raises(ValueError, match=msg):
+            bool(obj)
 
         # empty
         obj = self._construct(shape=0)
-        pytest.raises(ValueError, lambda: bool(obj))
+        with pytest.raises(ValueError, match=msg):
+            bool(obj)
 
         # invalid behaviors
 
         obj1 = self._construct(shape=4, value=1)
         obj2 = self._construct(shape=4, value=1)
 
-        def f():
+        with pytest.raises(ValueError, match=msg):
             if obj1:
-                printing.pprint_thing("this works and shouldn't")
+                pass
 
-        pytest.raises(ValueError, f)
-        pytest.raises(ValueError, lambda: obj1 and obj2)
-        pytest.raises(ValueError, lambda: obj1 or obj2)
-        pytest.raises(ValueError, lambda: not obj1)
+        with pytest.raises(ValueError, match=msg):
+            obj1 and obj2
+        with pytest.raises(ValueError, match=msg):
+            obj1 or obj2
+        with pytest.raises(ValueError, match=msg):
+            not obj1
 
     def test_downcast(self):
         # test close downcasting
@@ -200,9 +212,10 @@ class Generic(object):
         def f(dtype):
             return self._construct(shape=3, value=1, dtype=dtype)
 
-        pytest.raises(NotImplementedError, f, [("A", "datetime64[h]"),
-                                               ("B", "str"),
-                                               ("C", "int32")])
+        msg = ("compound dtypes are not implemented in the {} constructor"
+               .format(self._typ.__name__))
+        with pytest.raises(NotImplementedError, match=msg):
+            f([("A", "datetime64[h]"), ("B", "str"), ("C", "int32")])
 
         # these work (though results may be unexpected)
         f('int64')
@@ -725,6 +738,7 @@ class TestNDFrame(object):
         with pytest.raises(ValueError):
             df.sample(1, weights=s4)
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_squeeze(self):
         # noop
         for s in [tm.makeFloatSeries(), tm.makeStringSeries(),
@@ -755,8 +769,14 @@ class TestNDFrame(object):
         tm.assert_series_equal(df.squeeze(axis=1), df.iloc[:, 0])
         tm.assert_series_equal(df.squeeze(axis='columns'), df.iloc[:, 0])
         assert df.squeeze() == df.iloc[0, 0]
-        pytest.raises(ValueError, df.squeeze, axis=2)
-        pytest.raises(ValueError, df.squeeze, axis='x')
+        msg = ("No axis named 2 for object type <class"
+               " 'pandas.core.frame.DataFrame'>")
+        with pytest.raises(ValueError, match=msg):
+            df.squeeze(axis=2)
+        msg = ("No axis named x for object type <class"
+               " 'pandas.core.frame.DataFrame'>")
+        with pytest.raises(ValueError, match=msg):
+            df.squeeze(axis='x')
 
         df = tm.makeTimeDataFrame(3)
         tm.assert_frame_equal(df.squeeze(axis=0), df)
diff --git a/pandas/tests/generic/test_series.py b/pandas/tests/generic/test_series.py
index 10430ebde..b7d42e452 100644
--- a/pandas/tests/generic/test_series.py
+++ b/pandas/tests/generic/test_series.py
@@ -102,23 +102,34 @@ class TestSeries(Generic):
         s = Series([False])
         assert not s.bool()
 
+        msg = "The truth value of a Series is ambiguous"
         # single item nan to raise
         for s in [Series([np.nan]), Series([pd.NaT]), Series([True]),
                   Series([False])]:
-            pytest.raises(ValueError, lambda: bool(s))
+            with pytest.raises(ValueError, match=msg):
+                bool(s)
 
+        msg = "bool cannot act on a non-boolean single element Series"
         for s in [Series([np.nan]), Series([pd.NaT])]:
-            pytest.raises(ValueError, lambda: s.bool())
+            with pytest.raises(ValueError, match=msg):
+                s.bool()
 
         # multiple bool are still an error
+        msg = "The truth value of a Series is ambiguous"
         for s in [Series([True, True]), Series([False, False])]:
-            pytest.raises(ValueError, lambda: bool(s))
-            pytest.raises(ValueError, lambda: s.bool())
+            with pytest.raises(ValueError, match=msg):
+                bool(s)
+            with pytest.raises(ValueError, match=msg):
+                s.bool()
 
         # single non-bool are an error
         for s in [Series([1]), Series([0]), Series(['a']), Series([0.0])]:
-            pytest.raises(ValueError, lambda: bool(s))
-            pytest.raises(ValueError, lambda: s.bool())
+            msg = "The truth value of a Series is ambiguous"
+            with pytest.raises(ValueError, match=msg):
+                bool(s)
+            msg = "bool cannot act on a non-boolean single element Series"
+            with pytest.raises(ValueError, match=msg):
+                s.bool()
 
     def test_metadata_propagation_indiv(self):
         # check that the metadata matches up on the resulting ops

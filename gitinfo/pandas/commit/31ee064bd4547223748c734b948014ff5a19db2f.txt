commit 31ee064bd4547223748c734b948014ff5a19db2f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jul 19 15:07:29 2012 -0400

    BUG: support dateutil 2.1, fix scatter_matrix axis labels. #1637 #1625

diff --git a/RELEASE.rst b/RELEASE.rst
index 7e8f5d9ae..b31e94173 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -85,6 +85,9 @@ pandas 0.8.1
   - Better handle errors with non-existing objects in HDFStore (#1254)
   - Don't copy int64 array data in DatetimeIndex when copy=False (#1624)
   - Fix resampling of conforming periods quarterly to annual (#1622)
+  - Don't lose index name on resampling (#1631)
+  - Support python-dateutil version 2.1 (#1637)
+  - Fix broken scatter_matrix axis labeling, esp. with time series (#1625)
 
 pandas 0.8.0
 ============
diff --git a/TODO.rst b/TODO.rst
index b3f9d65ee..fc87174fd 100644
--- a/TODO.rst
+++ b/TODO.rst
@@ -57,4 +57,7 @@ Performance blog
 - Take
 
 git log v0.6.1..master --pretty=format:%aN | sort | uniq -c | sort -rn
-git log a8c2f88..master --pretty=format:%aN | sort | uniq -c | sort -rn
+
+git log 7ddfbd4..master --pretty=format:%aN | sort | uniq -c | sort -rn
+git log a0257f5..master --pretty=format:%aN | sort | uniq -c | sort -rn
+
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 8900a1eb3..050ad8287 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -46,6 +46,8 @@ def scatter_matrix(frame, alpha=0.5, figsize=None, ax=None, grid=False,
     >>> df = DataFrame(np.random.randn(1000, 4), columns=['A','B','C','D'])
     >>> scatter_matrix(df, alpha=0.2)
     """
+    from matplotlib.artist import setp
+
     df = frame._get_numeric_data()
     n = df.columns.size
     fig, axes = _subplots(nrows=n, ncols=n, figsize=figsize, ax=ax,
@@ -60,76 +62,74 @@ def scatter_matrix(frame, alpha=0.5, figsize=None, ax=None, grid=False,
 
     for i, a in zip(range(n), df.columns):
         for j, b in zip(range(n), df.columns):
+            ax = axes[i, j]
+
             if i == j:
                 values = df[a].values[mask[a].values]
 
                 # Deal with the diagonal by drawing a histogram there.
                 if diagonal == 'hist':
-                    axes[i, j].hist(values)
+                    ax.hist(values)
                 elif diagonal in ('kde', 'density'):
                     from scipy.stats import gaussian_kde
                     y = values
                     gkde = gaussian_kde(y)
                     ind = np.linspace(y.min(), y.max(), 1000)
-                    axes[i, j].plot(ind, gkde.evaluate(ind), **kwds)
+                    ax.plot(ind, gkde.evaluate(ind), **kwds)
             else:
                 common = (mask[a] & mask[b]).values
 
-                axes[i, j].scatter(df[b][common], df[a][common],
+                ax.scatter(df[b][common], df[a][common],
                                    marker=marker, alpha=alpha, **kwds)
 
-            axes[i, j].set_xlabel('')
-            axes[i, j].set_ylabel('')
-            axes[i, j].set_xticklabels([])
-            axes[i, j].set_yticklabels([])
-            ticks = df.index
-
-            is_datetype = ticks.inferred_type in ('datetime', 'date',
-                                              'datetime64')
+            ax.set_xlabel('')
+            ax.set_ylabel('')
 
-            if ticks.is_numeric() or is_datetype:
-                """
-                Matplotlib supports numeric values or datetime objects as
-                xaxis values. Taking LBYL approach here, by the time
-                matplotlib raises exception when using non numeric/datetime
-                values for xaxis, several actions are already taken by plt.
-                """
-                ticks = ticks._mpl_repr()
+            ax.xaxis.set_visible(False)
+            ax.yaxis.set_visible(False)
 
             # setup labels
             if i == 0 and j % 2 == 1:
-                axes[i, j].set_xlabel(b, visible=True)
-                #axes[i, j].xaxis.set_visible(True)
-                axes[i, j].set_xlabel(b)
-                axes[i, j].set_xticklabels(ticks)
-                axes[i, j].xaxis.set_ticks_position('top')
-                axes[i, j].xaxis.set_label_position('top')
-            if i == n - 1 and j % 2 == 0:
-                axes[i, j].set_xlabel(b, visible=True)
-                #axes[i, j].xaxis.set_visible(True)
-                axes[i, j].set_xlabel(b)
-                axes[i, j].set_xticklabels(ticks)
-                axes[i, j].xaxis.set_ticks_position('bottom')
-                axes[i, j].xaxis.set_label_position('bottom')
-            if j == 0 and i % 2 == 0:
-                axes[i, j].set_ylabel(a, visible=True)
-                #axes[i, j].yaxis.set_visible(True)
-                axes[i, j].set_ylabel(a)
-                axes[i, j].set_yticklabels(ticks)
-                axes[i, j].yaxis.set_ticks_position('left')
-                axes[i, j].yaxis.set_label_position('left')
-            if j == n - 1 and i % 2 == 1:
-                axes[i, j].set_ylabel(a, visible=True)
-                #axes[i, j].yaxis.set_visible(True)
-                axes[i, j].set_ylabel(a)
-                axes[i, j].set_yticklabels(ticks)
-                axes[i, j].yaxis.set_ticks_position('right')
-                axes[i, j].yaxis.set_label_position('right')
-
-            axes[i, j].grid(b=grid)
+                ax.set_xlabel(b, visible=True)
+                ax.xaxis.set_visible(True)
+                ax.set_xlabel(b)
+                ax.xaxis.set_ticks_position('top')
+                ax.xaxis.set_label_position('top')
+                setp(ax.get_xticklabels(), rotation=90)
+            elif i == n - 1 and j % 2 == 0:
+                ax.set_xlabel(b, visible=True)
+                ax.xaxis.set_visible(True)
+                ax.set_xlabel(b)
+                ax.xaxis.set_ticks_position('bottom')
+                ax.xaxis.set_label_position('bottom')
+                setp(ax.get_xticklabels(), rotation=90)
+            elif j == 0 and i % 2 == 0:
+                ax.set_ylabel(a, visible=True)
+                ax.yaxis.set_visible(True)
+                ax.set_ylabel(a)
+                ax.yaxis.set_ticks_position('left')
+                ax.yaxis.set_label_position('left')
+            elif j == n - 1 and i % 2 == 1:
+                ax.set_ylabel(a, visible=True)
+                ax.yaxis.set_visible(True)
+                ax.set_ylabel(a)
+                ax.yaxis.set_ticks_position('right')
+                ax.yaxis.set_label_position('right')
+
+            # ax.grid(b=grid)
+
+    axes[0, 0].yaxis.set_visible(False)
+    axes[n-1, n-1].xaxis.set_visible(False)
+    axes[n-1, n-1].yaxis.set_visible(False)
+    axes[0, n - 1].yaxis.tick_right()
+
+    for ax in axes.flat:
+        setp(ax.get_xticklabels(), fontsize=8)
+        setp(ax.get_yticklabels(), fontsize=8)
 
     return axes
 
+
 def _gca():
     import matplotlib.pyplot as plt
     return plt.gca()
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tseries/tests/test_plotting.py
index 5e94ec97c..414285fe1 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tseries/tests/test_plotting.py
@@ -334,7 +334,7 @@ class TestTSPlot(unittest.TestCase):
     @slow
     def test_finder_monthly(self):
         import matplotlib.pyplot as plt
-        xp = Period('1988-1').ordinal
+        xp = Period('Jan 1988').ordinal
         yrs = [1.15, 2.5, 4, 11]
         plt.close('all')
         for n in yrs:
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index b60c219bc..4f461ac1b 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -9,14 +9,14 @@ import pandas.core.common as com
 
 try:
     import dateutil
-    from dateutil.parser import parser
+    from dateutil.parser import parse
     from dateutil.relativedelta import relativedelta
 
     # raise exception if dateutil 2.0 install on 2.x platform
     if (sys.version_info[0] == 2 and
-        dateutil.__version__ >= '2.0'):  # pragma: no cover
+        dateutil.__version__ == '2.0'):  # pragma: no cover
         raise Exception('dateutil 2.0 incompatible with Python 2.x, you must '
-                        'install version 1.5!')
+                        'install version 1.5 or 2.1+!')
 except ImportError: # pragma: no cover
     print 'Please install python-dateutil via easy_install or some method!'
     raise # otherwise a 2nd import won't show the message
@@ -98,7 +98,7 @@ def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
     try:
         if not arg:
             return arg
-        return _dtparser.parse(arg, dayfirst=dayfirst)
+        return parse(arg, dayfirst=dayfirst)
     except Exception:
         if errors == 'raise':
             raise
@@ -109,15 +109,13 @@ class DateParseError(ValueError):
     pass
 
 
-_dtparser = parser()
-
 
 # patterns for quarters like '4Q2005', '05Q1'
 qpat1full = re.compile(r'(\d)Q(\d\d\d\d)')
 qpat2full = re.compile(r'(\d\d\d\d)Q(\d)')
 qpat1 = re.compile(r'(\d)Q(\d\d)')
 qpat2 = re.compile(r'(\d\d)Q(\d)')
-
+ypat = re.compile(r'(\d\d\d\d)$')
 
 def parse_time_string(arg, freq=None):
     """
@@ -149,6 +147,11 @@ def parse_time_string(arg, freq=None):
 
     # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
     if len(arg) in [4, 6]:
+        m = ypat.match(arg)
+        if m:
+            ret = default.replace(year=int(m.group(1)))
+            return ret, ret, 'year'
+
         add_century = False
         if len(arg) == 4:
             add_century = True
@@ -192,11 +195,30 @@ def parse_time_string(arg, freq=None):
             except Exception:
                 pass
 
+    # f7u12
+    try:
+        ret = datetime.strptime(arg, '%Y-%m')
+        return ret, ret, 'month'
+    except Exception:
+        pass
+
+    try:
+        ret = datetime.strptime(arg, '%b %Y')
+        return ret, ret, 'month'
+    except Exception:
+        pass
+
+    try:
+        ret = datetime.strptime(arg, '%b-%Y')
+        return ret, ret, 'month'
+    except Exception:
+        pass
+
     dayfirst = print_config.date_dayfirst
     yearfirst = print_config.date_yearfirst
 
     try:
-        parsed = _dtparser._parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
+        parsed = parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
     except Exception, e:
         raise DateParseError(e)
 

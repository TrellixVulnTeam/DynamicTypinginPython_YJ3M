commit 39551f923db9f2025bdd6803034d9860c0ce2d43
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu May 24 15:36:13 2012 -0400

    BLD: MSVC fixes, passes on 64-bit

diff --git a/pandas/src/ujson/lib/ultrajsonenc.c b/pandas/src/ujson/lib/ultrajsonenc.c
index fc3eed021..d2af89e23 100644
--- a/pandas/src/ujson/lib/ultrajsonenc.c
+++ b/pandas/src/ujson/lib/ultrajsonenc.c
@@ -604,9 +604,13 @@ Perhaps implement recursion detection */
 
 void encode(JSOBJ obj, JSONObjectEncoder *enc, const char *name, size_t cbName)
 {
+    const char *value;
+    char *objName;
+	int count;
+    JSOBJ iterObj;
+    size_t szlen;
     JSONTypeContext tc;
     tc.encoder = enc;
-    size_t szlen;
 
     if (enc->level > enc->recursionMax)
     {
@@ -664,8 +668,7 @@ void encode(JSOBJ obj, JSONObjectEncoder *enc, const char *name, size_t cbName)
 
         case JT_ARRAY:
         {
-            int count = 0;
-            JSOBJ iterObj;
+            count = 0;
             enc->iterBegin(obj, &tc);
 
             Buffer_AppendCharUnchecked (enc, '[');
@@ -694,10 +697,7 @@ void encode(JSOBJ obj, JSONObjectEncoder *enc, const char *name, size_t cbName)
 
         case JT_OBJECT:
         {
-            int count = 0;
-            JSOBJ iterObj;
-            char *objName;
-
+            count = 0;
             enc->iterBegin(obj, &tc);
 
             Buffer_AppendCharUnchecked (enc, '{');
@@ -779,7 +779,7 @@ void encode(JSOBJ obj, JSONObjectEncoder *enc, const char *name, size_t cbName)
 
         case JT_UTF8:
         {
-            const char *value = enc->getStringValue(obj, &tc, &szlen);
+            value = enc->getStringValue(obj, &tc, &szlen);
             Buffer_Reserve(enc, ((szlen / 4) + 1) * 12);
             Buffer_AppendCharUnchecked (enc, '\"');
 
diff --git a/pandas/src/ujson/python/JSONtoObj.c b/pandas/src/ujson/python/JSONtoObj.c
index 8455839e2..71fd5e2d1 100644
--- a/pandas/src/ujson/python/JSONtoObj.c
+++ b/pandas/src/ujson/python/JSONtoObj.c
@@ -8,7 +8,7 @@
 typedef struct __PyObjectDecoder
 {
     JSONObjectDecoder dec;
-
+	
     void* npyarr;       // Numpy context buffer
     npy_intp curdim;    // Current array dimension 
 
@@ -81,9 +81,9 @@ void Npy_releaseContext(NpyArrContext* npyarr)
 
 JSOBJ Object_npyNewArray(void* _decoder)
 {
-    PRINTMARK();
-    PyObjectDecoder* decoder = (PyObjectDecoder*) _decoder;
     NpyArrContext* npyarr;
+    PyObjectDecoder* decoder = (PyObjectDecoder*) _decoder;
+    PRINTMARK();
     if (decoder->curdim <= 0)
     {
         // start of array - initialise the context buffer
@@ -123,17 +123,19 @@ JSOBJ Object_npyNewArray(void* _decoder)
 
 JSOBJ Object_npyEndArray(JSOBJ obj)
 {
-    PRINTMARK();
+    PyObject *ret;
+    char* new_data;
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    int emptyType = NPY_DEFAULT_TYPE;
+    npy_intp i;
+    PRINTMARK();
     if (!npyarr)
     {
         return NULL;
     }
 
-    PyObject* ret = npyarr->ret;
-    int emptyType = NPY_DEFAULT_TYPE;
-    npy_intp i = npyarr->i;
-    char* new_data;
+    ret = npyarr->ret;
+    i = npyarr->i;
 
     npyarr->dec->curdim--;
 
@@ -195,17 +197,18 @@ JSOBJ Object_npyEndArray(JSOBJ obj)
 
 int Object_npyArrayAddItem(JSOBJ obj, JSOBJ value)
 {
-    PRINTMARK();
+    PyObject* type;
+    PyArray_Descr* dtype;
+    npy_intp i;
+    char *new_data, *item;
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    PRINTMARK();
     if (!npyarr)
     {
         return 0;
     }
 
-    PyObject* type;
-    PyArray_Descr* dtype;
-    npy_intp i = npyarr->i;
-    char *new_data, *item;
+    i = npyarr->i;
 
     npyarr->shape.ptr[npyarr->dec->curdim-1]++;
 
@@ -308,8 +311,8 @@ fail:
 
 JSOBJ Object_npyNewArrayList(void* _decoder)
 {
-    PRINTMARK();
     PyObjectDecoder* decoder = (PyObjectDecoder*) _decoder;
+    PRINTMARK();
     PyErr_SetString(PyExc_ValueError, "nesting not supported for object or variable length dtypes");
     Npy_releaseContext(decoder->npyarr);
     return NULL;
@@ -317,16 +320,17 @@ JSOBJ Object_npyNewArrayList(void* _decoder)
 
 JSOBJ Object_npyEndArrayList(JSOBJ obj)
 {
-    PRINTMARK();
+    PyObject *list, *ret;
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    PRINTMARK();
     if (!npyarr)
     {
         return NULL;
     }
 
     // convert decoded list to numpy array
-    PyObject* list = (PyObject *) npyarr->ret;
-    PyObject* ret = PyArray_FROM_O(list);
+    list = (PyObject *) npyarr->ret;
+    ret = PyArray_FROM_O(list);
 
     ((JSONObjectDecoder*)npyarr->dec)->newArray = Object_npyNewArray;
     ((JSONObjectDecoder*)npyarr->dec)->arrayAddItem = Object_npyArrayAddItem;
@@ -337,8 +341,8 @@ JSOBJ Object_npyEndArrayList(JSOBJ obj)
 
 int Object_npyArrayListAddItem(JSOBJ obj, JSOBJ value)
 {
-    PRINTMARK();
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    PRINTMARK();
     if (!npyarr)
     {
         return 0;
@@ -351,8 +355,8 @@ int Object_npyArrayListAddItem(JSOBJ obj, JSOBJ value)
 
 JSOBJ Object_npyNewObject(void* _decoder)
 {
-    PRINTMARK();
     PyObjectDecoder* decoder = (PyObjectDecoder*) _decoder;
+    PRINTMARK();
     if (decoder->curdim > 1)
     {
         PyErr_SetString(PyExc_ValueError, "labels only supported up to 2 dimensions");
@@ -364,16 +368,18 @@ JSOBJ Object_npyNewObject(void* _decoder)
 
 JSOBJ Object_npyEndObject(JSOBJ obj)
 {
-    PRINTMARK();
+    PyObject *list;
+    npy_intp labelidx;
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    PRINTMARK();
     if (!npyarr)
     {
         return NULL;
     }
 
-    npy_intp labelidx = npyarr->dec->curdim-1;
+    labelidx = npyarr->dec->curdim-1;
 
-    PyObject* list = npyarr->labels[labelidx];
+    list = npyarr->labels[labelidx];
     if (list)
     {
         npyarr->labels[labelidx] = PyArray_FROM_O(list);
@@ -385,16 +391,18 @@ JSOBJ Object_npyEndObject(JSOBJ obj)
 
 int Object_npyObjectAddKey(JSOBJ obj, JSOBJ name, JSOBJ value)
 {
-    PRINTMARK();
-    // add key to label array, value to values array
+    PyObject *label;
+	npy_intp labelidx;
+	// add key to label array, value to values array
     NpyArrContext* npyarr = (NpyArrContext*) obj;
+    PRINTMARK();
     if (!npyarr)
     {
         return 0;
     }
 
-    PyObject* label = (PyObject*) name;
-    npy_intp labelidx = npyarr->dec->curdim-1;
+    label = (PyObject*) name;
+    labelidx = npyarr->dec->curdim-1;
 
     if (!npyarr->labels[labelidx])
     {
@@ -498,17 +506,16 @@ static void Object_releaseObject(JSOBJ obj, void* _decoder)
 
 PyObject* JSONToObj(PyObject* self, PyObject *args, PyObject *kwargs)
 {
-    PRINTMARK();
-    static char *kwlist[] = { "obj", "numpy", "labelled", "dtype", NULL};
-
     PyObject *ret;
     PyObject *sarg;
+    JSONObjectDecoder *decoder;
+	PyObjectDecoder pyDecoder;
     PyArray_Descr *dtype = NULL;
+    static char *kwlist[] = { "obj", "numpy", "labelled", "dtype", NULL};
     int numpy = 0, labelled = 0, decref = 0;
-
-    PyObjectDecoder pyDecoder =
-    {
-        {
+    // PRINTMARK();
+	
+    JSONObjectDecoder dec = {
             Object_newString,
             Object_objectAddKey,
             Object_arrayAddItem,
@@ -526,13 +533,12 @@ PyObject* JSONToObj(PyObject* self, PyObject *args, PyObject *kwargs)
             PyObject_Malloc,
             PyObject_Free,
             PyObject_Realloc,
-        }
     };
-
+    pyDecoder.dec = dec;
     pyDecoder.curdim = 0;
     pyDecoder.npyarr = NULL;
 
-    JSONObjectDecoder* decoder = (JSONObjectDecoder*) &pyDecoder;
+    decoder = (JSONObjectDecoder*) &pyDecoder;
 
     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|iiO&", kwlist, &sarg, &numpy, &labelled, PyArray_DescrConverter, &dtype))
     {
diff --git a/pandas/src/ujson/python/objToJSON.c b/pandas/src/ujson/python/objToJSON.c
index 0b90b3145..8340436df 100644
--- a/pandas/src/ujson/python/objToJSON.c
+++ b/pandas/src/ujson/python/objToJSON.c
@@ -8,6 +8,8 @@
 
 #define EPOCH_ORD 719163
 
+#define NPY_JSON_BUFSIZE 32768
+
 static PyObject* cls_dataframe;
 static PyObject* cls_series;
 static PyObject* cls_index;
@@ -400,9 +402,9 @@ JSOBJ NpyArr_iterGetValue(JSOBJ obj, JSONTypeContext *tc)
 char *NpyArr_iterGetName(JSOBJ obj, JSONTypeContext *tc, size_t *outLen)
 {
     NpyArrContext* npyarr;
+    npy_intp idx;
     PRINTMARK();
     npyarr = GET_TC(tc)->npyarr;
-    npy_intp idx;
     if (GET_TC(tc)->iterNext == NpyArr_iterNextItem)
     {
         idx = npyarr->index[npyarr->stridedim] - 1;
@@ -903,16 +905,16 @@ void NpyArr_freeLabels(char** labels, npy_intp len)
 char** NpyArr_encodeLabels(PyArrayObject* labels, JSONObjectEncoder* enc, npy_intp num)
 {
     // NOTE this function steals a reference to labels.
-    PRINTMARK();
     PyArray_Descr *dtype = NULL;
     PyArrayObject* labelsTmp = NULL;
     PyObject* item = NULL;
     npy_intp i, stride, len;
-    npy_intp bufsize = 32768;
+    // npy_intp bufsize = 32768;
     char** ret;
     char *dataptr, *cLabel, *origend, *origst, *origoffset;
-    char labelBuffer[bufsize];
+    char labelBuffer[NPY_JSON_BUFSIZE];
     PyArray_GetItemFunc* getitem;
+    PRINTMARK();
 
     if (PyArray_SIZE(labels) < num)
     {
@@ -959,7 +961,7 @@ char** NpyArr_encodeLabels(PyArrayObject* labels, JSONObjectEncoder* enc, npy_in
             break;
         }
 
-        cLabel = JSON_EncodeObject(item, enc, labelBuffer, bufsize);
+        cLabel = JSON_EncodeObject(item, enc, labelBuffer, NPY_JSON_BUFSIZE);
         Py_DECREF(item);
 
         if (PyErr_Occurred() || enc->errorMsg)
@@ -1001,18 +1003,21 @@ char** NpyArr_encodeLabels(PyArrayObject* labels, JSONObjectEncoder* enc, npy_in
 
 void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
 {
+    PyObject *obj, *exc, *toDictFunc;
+    TypeContext *pc;
+    PyObjectEncoder *enc;
+	int i;
+	double val;
     PRINTMARK();
     if (!_obj) {
         tc->type = JT_INVALID;
         return;
     }
 
-    PyObject* obj = (PyObject*) _obj;
-    TypeContext *pc = (TypeContext *) tc->prv;
-    PyObjectEncoder* enc = (PyObjectEncoder*) tc->encoder;
-    PyObject *toDictFunc;
+    obj = (PyObject*) _obj;
+    pc = (TypeContext *) tc->prv;
+    enc = (PyObjectEncoder*) tc->encoder;
 
-    int i;
     for (i = 0; i < 32; i++)
     {
         tc->prv[i] = 0;
@@ -1043,8 +1048,6 @@ void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
     else
     if (PyLong_Check(obj))
     {
-        PyObject *exc;
-
         PRINTMARK();
         pc->PyTypeToJSON = PyLongToINT64;
         tc->type = JT_LONG;
@@ -1064,12 +1067,10 @@ void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
     else
     if (PyArray_IsScalar(obj, Integer))
     {
-        PyObject *exc;
-
         PRINTMARK();
         pc->PyTypeToJSON = PyLongToINT64;
         tc->type = JT_LONG;
-        PyArray_CastScalarToCtype(obj, &(GET_TC(tc)->longValue), PyArray_DescrFromType(NPY_LONG));
+        PyArray_CastScalarToCtype(obj, &(GET_TC(tc)->longValue), PyArray_DescrFromType(NPY_INT64));
 
         exc = PyErr_Occurred();
 
@@ -1100,7 +1101,7 @@ void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
     if (PyFloat_Check(obj))
     {
         PRINTMARK();
-        double val = PyFloat_AS_DOUBLE (obj);
+        val = PyFloat_AS_DOUBLE (obj);
         if (npy_isnan(val) || npy_isinf(val))
         {
             tc->type = JT_NULL;
diff --git a/setup.py b/setup.py
index 1576eaf34..22d9a59a9 100755
--- a/setup.py
+++ b/setup.py
@@ -74,7 +74,7 @@ if np.__version__ < '1.6.1':
     msg = "pandas requires NumPy >= 1.6 due to datetime64 dependency"
     sys.exit(msg)
 
-from numpy.distutils.misc_util import get_pkg_info
+from numpy.distutils.misc_util import get_pkg_info, get_info
 
 from distutils.extension import Extension
 from distutils.command.build import build
@@ -386,6 +386,8 @@ sparse_ext = Extension('pandas._sparse',
                        sources=[srcpath('sparse', suffix=suffix)],
                        include_dirs=[np.get_include()])
 
+npymath_info = get_info('npymath')
+                       
 ujson_ext = Extension('pandas._ujson',
                       sources=['pandas/src/ujson/python/ujson.c',
                                'pandas/src/ujson/python/objToJSON.c',
@@ -395,7 +397,11 @@ ujson_ext = Extension('pandas._ujson',
                       include_dirs=['pandas/src/ujson/python',
                                     'pandas/src/ujson/lib',
                                     np.get_include()],
-                      extra_link_args=[get_pkg_info('npymath').libs()])
+                      libraries=['npymath'],
+                      library_dirs=npymath_info['library_dirs'],
+                      #extra_link_args=[get_info('npymath').libs()]
+                      #extra_info=get_info('npymath')
+                      )
 
 sandbox_ext = Extension('pandas._sandbox',
                         sources=[srcpath('sandbox', suffix=suffix),

commit 3924300178c6a1fb8e594fffd9294ac6c5408ebb
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jun 8 03:25:41 2011 +0200

    starting toward reindex methods in new prototype

diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 11443a334..f4d84d41a 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -11,8 +11,9 @@ import pandas.core.common as common
 class Block(object):
     """
     Canonical unit of homogeneous dtype contained in DataMatrix
-    """
 
+    Index-ignorant; let the container take care of that
+    """
     def __init__(self, values, columns):
         values = _convert_if_1d(values)
         self.values = values
@@ -43,7 +44,10 @@ class Block(object):
     def merge(self, other):
         return _merge_blocks([self, other])
 
-    def reindex(self, new_columns):
+    def reindex_index(self, indexer, notmask, need_masking):
+        pass
+
+    def reindex_columns(self, new_columns):
         indexer, mask = self.columns.get_indexer(columns)
         new_values = self.values.take(indexer, axis=1)
 
@@ -118,9 +122,18 @@ def _convert_if_1d(values):
 
     return values
 
+#-------------------------------------------------------------------------------
+# Is this even possible?
+
 class FloatBlock(Block):
     pass
 
+class IntBlock(Block):
+    pass
+
+class BoolBlock(Block):
+    pass
+
 class ObjectBlock(Block):
     pass
 
@@ -158,6 +171,13 @@ class BlockManager(object):
         for block in self.blocks:
             assert(len(block) == length)
 
+    def is_consolidated(self):
+        """
+        Return True if more than one block with the same dtype
+        """
+        dtypes = [blk.dtype for blk in self.blocks]
+        return len(dtypes) == len(set(dtypes))
+
     def get_slice(self, slice_obj):
         new_blocks = _slice_blocks(self.blocks, slice_obj)
         new_index = self.index[slice_obj]
@@ -205,11 +225,14 @@ class BlockManager(object):
 
     def consolidate(self):
         """
+        Join together blocks having same dtype
 
         Returns
         -------
-
+        y : BlockManager
         """
+        if self.is_consolidated():
+            return self
 
         new_blocks = _consolidate(self.blocks)
         return BlockManager(new_blocks, self.columns)
@@ -269,10 +292,26 @@ class BlockManager(object):
     def rename(self, mapper):
         pass
 
-    def reindex_index(self, indexer, mask):
-        mat = self.values.take(indexer, axis=0)
+    def reindex_index(self, new_index, method):
+        indexer, mask = self.index.get_indexer(new_index, method)
 
+        # TODO: deal with length-0 case? or does it fall out?
         notmask = -mask
+        needs_masking = len(index) > 0 and notmask.any()
+
+        new_blocks = []
+        for block in self.blocks:
+            values = block.values.take(indexer, axis=0)
+            if needs_masking:
+                if issubclass(values.dtype.type, np.int_):
+                    values = values.astype(float)
+                elif issubclass(values_.dtype.type, np.bool_):
+                    values = values.astype(object)
+                common.null_out_axis(values, notmask, 0)
+
+            newb = Block(new_values, block.columns)
+            new_blocks.append(newb)
+
         if len(index) > 0:
             if notmask.any():
                 if issubclass(mat.dtype.type, np.int_):
@@ -283,7 +322,13 @@ class BlockManager(object):
                 common.null_out_axis(mat, notmask, 0)
 
     def reindex_columns(self, new_columns):
-        pass
+        data = self
+        if not data.is_consolidated():
+            data = data.consolidate()
+            return data.reindex_columns(new_columns)
+
+        # will put these in the float bucket
+        extra_columns = new_columns - self.columns
 
 def _slice_blocks(blocks, slice_obj):
     new_blocks = []
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 4b9d2f150..23fa1e083 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -139,43 +139,33 @@ class DataMatrix(DataFrame):
     def _reindex_index(self, new_index, method):
         if new_index is self.index:
             return self.copy()
-        if len(self.index) == 0:
-            return DataMatrix(index=new_index, columns=self.columns)
-        indexer, mask = self.index.get_indexer(new_index, method)
-        new_data = self._data.reindex(indexer, mask)
-        return DataMatrix(new_data, index=new_index, columns=self.columns)
 
-    def _reindex_columns(self, columns):
+        # TODO: want to preserve dtypes though...
+        new_data = self._data.reindex_index(new_index, method)
+        return DataMatrix(new_data)
+
+    def _reindex_columns(self, new_columns):
         if len(columns) == 0:
             return DataMatrix(index=self.index)
 
-        if self.objects is not None:
-            object_columns = columns.intersection(self.objects.columns)
-            columns = columns - object_columns
-
-            objects = self.objects._reindex_columns(object_columns)
-        else:
-            objects = None
-
-        if len(columns) > 0 and len(self.columns) == 0:
-            return DataMatrix(index=self.index, columns=columns,
-                              objects=objects)
+        new_data = self._data.reindex_columns(new_columns)
+        return DataMatrix(new_data, index=new_index, columns=self.columns)
 
-        indexer, mask = self.columns.get_indexer(columns)
-        mat = self.values.take(indexer, axis=1)
+        # indexer, mask = self.columns.get_indexer(columns)
+        # mat = self.values.take(indexer, axis=1)
 
-        notmask = -mask
-        if len(mask) > 0:
-            if notmask.any():
-                if issubclass(mat.dtype.type, np.int_):
-                    mat = mat.astype(float)
-                elif issubclass(mat.dtype.type, np.bool_):
-                    mat = mat.astype(float)
+        # notmask = -mask
+        # if len(mask) > 0:
+        #     if notmask.any():
+        #         if issubclass(mat.dtype.type, np.int_):
+        #             mat = mat.astype(float)
+        #         elif issubclass(mat.dtype.type, np.bool_):
+        #             mat = mat.astype(float)
 
-                common.null_out_axis(mat, notmask, 1)
+        #         common.null_out_axis(mat, notmask, 1)
 
-        return DataMatrix(mat, index=self.index, columns=columns,
-                          objects=objects)
+        # return DataMatrix(mat, index=self.index, columns=columns,
+        #                   objects=objects)
 
     def _rename_columns_inplace(self, mapper):
         self.columns = [mapper(x) for x in self.columns]

commit 4694a428fd63e971159fffea4559e589088881e9
Author: Kerby Shedden <kshedden@umich.edu>
Date:   Fri Aug 14 04:03:38 2015 -0400

    Minor changes following code review

diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index fe01a79f0..1df8ddc22 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -20,7 +20,7 @@ Highlights include:
   if they are all ``NaN``, see :ref:`here <whatsnew_0170.api_breaking.hdf_dropna>`
 - Support for ``Series.dt.strftime`` to generate formatted strings for datetime-likes, see :ref:`here <whatsnew_0170.strftime>`
 - Development installed versions of pandas will now have ``PEP440`` compliant version strings (:issue:`9518`)
-- Support for reading SAS xport files, see :meth:`~pandas.io.read_sas`.
+- Support for reading SAS xport files, see :ref:`here <whatsnew_0170.enhancements.sas_xport>`
 
 Check the :ref:`API Changes <whatsnew_0170.api>` and :ref:`deprecations <whatsnew_0170.deprecations>` before updating.
 
@@ -85,6 +85,18 @@ We are now supporting a ``Series.dt.strftime`` method for datetime-likes to gene
 
 The string format is as the python standard library and details can be found `here <https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior>`_
 
+.. _whatsnew_0170.enhancements.sas_xport:
+
+Support for SAS XPORT files
+^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+:meth:`~pandas.io.read_sas` provides support for reading SAS XPORT format files:
+
+    df = pd.read_sas('sas_xport.xpt')
+
+It is also possible to obtain an iterator and read an XPORT file
+incrementally.
+
 .. _whatsnew_0170.enhancements.other:
 
 Other enhancements
@@ -94,13 +106,6 @@ Other enhancements
 
 - Enable `read_hdf` to be used without specifying a key when the HDF file contains a single dataset (:issue:`10443`)
 
-- :meth:`~pandas.io.read_sas` provides support for reading SAS XPORT format files:
-
-    df = pd.read_sas('sas_xport.xpt')
-
-It is also possible to obtain an iterator and read an XPORT file
-incrementally.
-
 - ``DatetimeIndex`` can be instantiated using strings contains ``NaT`` (:issue:`7599`)
 - The string parsing of ``to_datetime``, ``Timestamp`` and ``DatetimeIndex`` has been made consistent. (:issue:`7599`)
 
diff --git a/pandas/io/tests/test_sas.py b/pandas/io/tests/test_sas.py
index 9dcdc173b..0e08252fd 100644
--- a/pandas/io/tests/test_sas.py
+++ b/pandas/io/tests/test_sas.py
@@ -2,10 +2,19 @@ import pandas as pd
 import pandas.util.testing as tm
 from pandas import compat
 from pandas.io.sas import XportReader, read_sas
+import numpy as np
 import os
 
 # CSV versions of test XPT files were obtained using the R foreign library
 
+# Numbers in a SAS xport file are always float64, so need to convert
+# before making comparisons.
+def numeric_as_float(data):
+    for v in data.columns:
+        if data[v].dtype is np.dtype('int64'):
+            data[v] = data[v].astype(np.float64)
+
+
 class TestXport(tm.TestCase):
 
     def setUp(self):
@@ -20,24 +29,25 @@ class TestXport(tm.TestCase):
 
         # Compare to this
         data_csv = pd.read_csv(self.file01.replace(".XPT", ".csv"))
+        numeric_as_float(data_csv)
 
         # Read full file
         data = XportReader(self.file01).read()
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
         # Test incremental read with `read` method.
         reader = XportReader(self.file01)
         data = reader.read(10)
-        tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_dtype=False)
+        tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
 
         # Test incremental read with `get_chunk` method.
         reader = XportReader(self.file01, chunksize=10)
         data = reader.get_chunk()
-        tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_dtype=False)
+        tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
 
         # Read full file with `read_sas` method
         data = read_sas(self.file01)
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
 
     def test1_index(self):
@@ -46,20 +56,21 @@ class TestXport(tm.TestCase):
         # Compare to this
         data_csv = pd.read_csv(self.file01.replace(".XPT", ".csv"))
         data_csv = data_csv.set_index("SEQN")
+        numeric_as_float(data_csv)
 
         # Read full file
         data = XportReader(self.file01, index="SEQN").read()
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
         # Test incremental read with `read` method.
         reader = XportReader(self.file01, index="SEQN")
         data = reader.read(10)
-        tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_dtype=False)
+        tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
 
         # Test incremental read with `get_chunk` method.
         reader = XportReader(self.file01, index="SEQN", chunksize=10)
         data = reader.get_chunk()
-        tm.assert_frame_equal(data, data_csv.iloc[0:10, :], check_dtype=False)
+        tm.assert_frame_equal(data, data_csv.iloc[0:10, :])
 
 
     def test1_incremental(self):
@@ -67,13 +78,14 @@ class TestXport(tm.TestCase):
 
         data_csv = pd.read_csv(self.file01.replace(".XPT", ".csv"))
         data_csv = data_csv.set_index("SEQN")
+        numeric_as_float(data_csv)
 
         reader = XportReader(self.file01, index="SEQN", chunksize=1000)
 
         all_data = [x for x in reader]
         data = pd.concat(all_data, axis=0)
 
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
 
     def test2(self):
@@ -81,9 +93,10 @@ class TestXport(tm.TestCase):
 
         # Compare to this
         data_csv = pd.read_csv(self.file02.replace(".XPT", ".csv"))
+        numeric_as_float(data_csv)
 
         data = XportReader(self.file02).read()
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
 
     def test3(self):
@@ -93,7 +106,7 @@ class TestXport(tm.TestCase):
         data_csv = pd.read_csv(self.file03.replace(".XPT", ".csv"))
 
         data = XportReader(self.file03).read()
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)
 
         data = read_sas(self.file03)
-        tm.assert_frame_equal(data, data_csv, check_dtype=False)
+        tm.assert_frame_equal(data, data_csv)

commit a4482db46535b018053b4351689ccc3c79257d8c
Author: Licht Takeuchi <licht-t@outlook.jp>
Date:   Tue Oct 9 21:54:02 2018 +0900

    BUG: Fix combine_first converts other columns type into floats unexpectedly (#20965)

diff --git a/doc/source/whatsnew/v0.24.0.txt b/doc/source/whatsnew/v0.24.0.txt
index 56dd6c826..ca4ea8e36 100644
--- a/doc/source/whatsnew/v0.24.0.txt
+++ b/doc/source/whatsnew/v0.24.0.txt
@@ -909,3 +909,4 @@ Other
 - :meth:`DataFrame.nlargest` and :meth:`DataFrame.nsmallest` now returns the correct n values when keep != 'all' also when tied on the first columns (:issue:`22752`)
 - :meth:`~pandas.io.formats.style.Styler.bar` now also supports tablewise application (in addition to rowwise and columnwise) with ``axis=None`` and setting clipping range with ``vmin`` and ``vmax`` (:issue:`21548` and :issue:`21526`). ``NaN`` values are also handled properly.
 - Logical operations ``&, |, ^`` between :class:`Series` and :class:`Index` will no longer raise ``ValueError`` (:issue:`22092`)
+- Bug in :meth:`DataFrame.combine_first` in which column types were unexpectedly converted to float (:issue:`20699`)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 986fe3478..fba27e8e4 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -5095,9 +5095,17 @@ class DataFrame(NDFrame):
                 series[this_mask] = fill_value
                 otherSeries[other_mask] = fill_value
 
-            # if we have different dtypes, possibly promote
-            new_dtype = this_dtype
-            if not is_dtype_equal(this_dtype, other_dtype):
+            if col not in self.columns:
+                # If self DataFrame does not have col in other DataFrame,
+                # try to promote series, which is all NaN, as other_dtype.
+                new_dtype = other_dtype
+                try:
+                    series = series.astype(new_dtype, copy=False)
+                except ValueError:
+                    # e.g. new_dtype is integer types
+                    pass
+            else:
+                # if we have different dtypes, possibly promote
                 new_dtype = find_common_type([this_dtype, other_dtype])
                 if not is_dtype_equal(this_dtype, new_dtype):
                     series = series.astype(new_dtype)
@@ -5176,6 +5184,11 @@ class DataFrame(NDFrame):
             else:
                 mask = isna(x_values)
 
+            # If the column y in other DataFrame is not in first DataFrame,
+            # just return y_values.
+            if y.name not in self.columns:
+                return y_values
+
             return expressions.where(mask, y_values, x_values)
 
         return self.combine(other, combiner, overwrite=False)
diff --git a/pandas/tests/frame/test_combine_concat.py b/pandas/tests/frame/test_combine_concat.py
index 15ca65395..d1f921bc5 100644
--- a/pandas/tests/frame/test_combine_concat.py
+++ b/pandas/tests/frame/test_combine_concat.py
@@ -4,6 +4,7 @@ from __future__ import print_function
 
 from datetime import datetime
 
+import pytest
 import numpy as np
 from numpy import nan
 
@@ -750,6 +751,17 @@ class TestDataFrameCombineFirst(TestData):
         tm.assert_frame_equal(res, df1)
         assert res['a'].dtype == 'int64'
 
+    @pytest.mark.parametrize("val", [1, 1.0])
+    def test_combine_first_with_asymmetric_other(self, val):
+        # see gh-20699
+        df1 = pd.DataFrame({'isNum': [val]})
+        df2 = pd.DataFrame({'isBool': [True]})
+
+        res = df1.combine_first(df2)
+        exp = pd.DataFrame({'isBool': [True], 'isNum': [val]})
+
+        tm.assert_frame_equal(res, exp)
+
     def test_concat_datetime_datetime64_frame(self):
         # #2624
         rows = []

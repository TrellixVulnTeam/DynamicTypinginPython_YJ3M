commit eabf89d174ed8164a09ae28c80e03e1fe5bf14c5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Nov 12 15:38:26 2019 -0800

    CLN: annotations in core.dtypes (#29503)

diff --git a/pandas/core/dtypes/base.py b/pandas/core/dtypes/base.py
index 2cc7c44cc..d9d3b0d45 100644
--- a/pandas/core/dtypes/base.py
+++ b/pandas/core/dtypes/base.py
@@ -87,7 +87,8 @@ class ExtensionDtype:
         return self.name
 
     def __eq__(self, other):
-        """Check whether 'other' is equal to self.
+        """
+        Check whether 'other' is equal to self.
 
         By default, 'other' is considered equal if either
 
@@ -115,7 +116,7 @@ class ExtensionDtype:
             )
         return False
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         return hash(tuple(getattr(self, attr) for attr in self._metadata))
 
     def __ne__(self, other):
@@ -171,7 +172,8 @@ class ExtensionDtype:
 
     @property
     def names(self) -> Optional[List[str]]:
-        """Ordered list of field names, or None if there are no fields.
+        """
+        Ordered list of field names, or None if there are no fields.
 
         This is for compatibility with NumPy arrays, and may be removed in the
         future.
@@ -233,16 +235,19 @@ class ExtensionDtype:
         ...                         "'{}'".format(cls.__name__, string))
         """
         if not isinstance(string, str):
-            raise TypeError("Expects a string, got {}".format(type(string)))
+            raise TypeError("Expects a string, got {typ}".format(typ=type(string)))
         if string != cls.name:
             raise TypeError(
-                "Cannot construct a '{}' from '{}'".format(cls.__name__, string)
+                "Cannot construct a '{cls}' from '{string}'".format(
+                    cls=cls.__name__, string=string
+                )
             )
         return cls()
 
     @classmethod
     def is_dtype(cls, dtype) -> bool:
-        """Check if we match 'dtype'.
+        """
+        Check if we match 'dtype'.
 
         Parameters
         ----------
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index 637c42eef..acf8b6ca4 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -72,7 +72,7 @@ def maybe_convert_platform(values):
     return values
 
 
-def is_nested_object(obj):
+def is_nested_object(obj) -> bool:
     """
     return a boolean if we have a nested object, e.g. a Series with 1 or
     more Series elements
@@ -500,11 +500,11 @@ def _ensure_dtype_type(value, dtype):
 
 def infer_dtype_from(val, pandas_dtype: bool = False):
     """
-    interpret the dtype from a scalar or array. This is a convenience
-    routines to infer dtype from a scalar or an array
+    Interpret the dtype from a scalar or array.
 
     Parameters
     ----------
+    val : object
     pandas_dtype : bool, default False
         whether to infer dtype including pandas extension types.
         If False, scalar/array belongs to pandas extension types is inferred as
@@ -517,7 +517,7 @@ def infer_dtype_from(val, pandas_dtype: bool = False):
 
 def infer_dtype_from_scalar(val, pandas_dtype: bool = False):
     """
-    interpret the dtype from a scalar
+    Interpret the dtype from a scalar.
 
     Parameters
     ----------
@@ -592,7 +592,7 @@ def infer_dtype_from_scalar(val, pandas_dtype: bool = False):
 
 def infer_dtype_from_array(arr, pandas_dtype: bool = False):
     """
-    infer the dtype from a scalar or array
+    Infer the dtype from a scalar or array.
 
     Parameters
     ----------
@@ -647,7 +647,8 @@ def infer_dtype_from_array(arr, pandas_dtype: bool = False):
 
 
 def maybe_infer_dtype_type(element):
-    """Try to infer an object's dtype, for use in arithmetic ops
+    """
+    Try to infer an object's dtype, for use in arithmetic ops.
 
     Uses `element.dtype` if that's available.
     Objects implementing the iterator protocol are cast to a NumPy array,
@@ -679,8 +680,9 @@ def maybe_infer_dtype_type(element):
     return tipo
 
 
-def maybe_upcast(values, fill_value=np.nan, dtype=None, copy=False):
-    """ provide explicit type promotion and coercion
+def maybe_upcast(values, fill_value=np.nan, dtype=None, copy: bool = False):
+    """
+    Provide explicit type promotion and coercion.
 
     Parameters
     ----------
@@ -759,7 +761,7 @@ def coerce_to_dtypes(result, dtypes):
     return [conv(r, dtype) for r, dtype in zip(result, dtypes)]
 
 
-def astype_nansafe(arr, dtype, copy=True, skipna=False):
+def astype_nansafe(arr, dtype, copy: bool = True, skipna: bool = False):
     """
     Cast the elements of an array to a given dtype a nan-safe manner.
 
@@ -982,7 +984,7 @@ def soft_convert_objects(
     return values
 
 
-def maybe_castable(arr):
+def maybe_castable(arr) -> bool:
     # return False to force a non-fastpath
 
     # check datetime64[ns]/timedelta64[ns] are valid
@@ -996,7 +998,7 @@ def maybe_castable(arr):
     return arr.dtype.name not in _POSSIBLY_CAST_DTYPES
 
 
-def maybe_infer_to_datetimelike(value, convert_dates=False):
+def maybe_infer_to_datetimelike(value, convert_dates: bool = False):
     """
     we might have a array (or single object) that is datetime like,
     and no dtype is passed don't change the value unless we find a
@@ -1103,7 +1105,7 @@ def maybe_infer_to_datetimelike(value, convert_dates=False):
     return value
 
 
-def maybe_cast_to_datetime(value, dtype, errors="raise"):
+def maybe_cast_to_datetime(value, dtype, errors: str = "raise"):
     """ try to cast the array/value to a datetimelike dtype, converting float
     nan to iNaT
     """
@@ -1292,7 +1294,7 @@ def find_common_type(types):
 
 def cast_scalar_to_array(shape, value, dtype=None):
     """
-    create np.ndarray of specified shape and dtype, filled with values
+    Create np.ndarray of specified shape and dtype, filled with values.
 
     Parameters
     ----------
@@ -1318,7 +1320,7 @@ def cast_scalar_to_array(shape, value, dtype=None):
     return values
 
 
-def construct_1d_arraylike_from_scalar(value, length, dtype):
+def construct_1d_arraylike_from_scalar(value, length: int, dtype):
     """
     create a np.ndarray / pandas type of specified shape and dtype
     filled with values
@@ -1383,7 +1385,7 @@ def construct_1d_object_array_from_listlike(values):
     return result
 
 
-def construct_1d_ndarray_preserving_na(values, dtype=None, copy=False):
+def construct_1d_ndarray_preserving_na(values, dtype=None, copy: bool = False):
     """
     Construct a new ndarray, coercing `values` to `dtype`, preserving NA.
 
@@ -1424,7 +1426,7 @@ def construct_1d_ndarray_preserving_na(values, dtype=None, copy=False):
     return subarr
 
 
-def maybe_cast_to_integer_array(arr, dtype, copy=False):
+def maybe_cast_to_integer_array(arr, dtype, copy: bool = False):
     """
     Takes any dtype and returns the casted version, raising for when data is
     incompatible with integer/unsigned integer dtypes.
diff --git a/pandas/core/dtypes/common.py b/pandas/core/dtypes/common.py
index 4f9481ecc..1ed54c12f 100644
--- a/pandas/core/dtypes/common.py
+++ b/pandas/core/dtypes/common.py
@@ -222,7 +222,7 @@ def classes_and_not_datetimelike(*klasses) -> Callable:
     )
 
 
-def is_object_dtype(arr_or_dtype):
+def is_object_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of the object dtype.
 
@@ -252,7 +252,7 @@ def is_object_dtype(arr_or_dtype):
     return _is_dtype_type(arr_or_dtype, classes(np.object_))
 
 
-def is_sparse(arr):
+def is_sparse(arr) -> bool:
     """
     Check whether an array-like is a 1-D pandas sparse array.
 
@@ -304,7 +304,7 @@ def is_sparse(arr):
     return isinstance(dtype, SparseDtype)
 
 
-def is_scipy_sparse(arr):
+def is_scipy_sparse(arr) -> bool:
     """
     Check whether an array-like is a scipy.sparse.spmatrix instance.
 
@@ -339,6 +339,7 @@ def is_scipy_sparse(arr):
         except ImportError:
             _is_scipy_sparse = lambda _: False
 
+    assert _is_scipy_sparse is not None
     return _is_scipy_sparse(arr)
 
 
@@ -375,7 +376,7 @@ def is_categorical(arr) -> bool:
     return isinstance(arr, ABCCategorical) or is_categorical_dtype(arr)
 
 
-def is_datetimetz(arr):
+def is_datetimetz(arr) -> bool:
     """
     Check whether an array-like is a datetime array-like with a timezone
     component in its dtype.
@@ -425,7 +426,7 @@ def is_datetimetz(arr):
     return is_datetime64tz_dtype(arr)
 
 
-def is_offsetlike(arr_or_obj):
+def is_offsetlike(arr_or_obj) -> bool:
     """
     Check if obj or all elements of list-like is DateOffset
 
@@ -456,7 +457,7 @@ def is_offsetlike(arr_or_obj):
     return False
 
 
-def is_period(arr):
+def is_period(arr) -> bool:
     """
     Check whether an array-like is a periodical index.
 
@@ -493,7 +494,7 @@ def is_period(arr):
     return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)
 
 
-def is_datetime64_dtype(arr_or_dtype):
+def is_datetime64_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of the datetime64 dtype.
 
@@ -524,7 +525,7 @@ def is_datetime64_dtype(arr_or_dtype):
     return _is_dtype_type(arr_or_dtype, classes(np.datetime64))
 
 
-def is_datetime64tz_dtype(arr_or_dtype):
+def is_datetime64tz_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of a DatetimeTZDtype dtype.
 
@@ -562,7 +563,7 @@ def is_datetime64tz_dtype(arr_or_dtype):
     return DatetimeTZDtype.is_dtype(arr_or_dtype)
 
 
-def is_timedelta64_dtype(arr_or_dtype):
+def is_timedelta64_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of the timedelta64 dtype.
 
@@ -593,7 +594,7 @@ def is_timedelta64_dtype(arr_or_dtype):
     return _is_dtype_type(arr_or_dtype, classes(np.timedelta64))
 
 
-def is_period_dtype(arr_or_dtype):
+def is_period_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of the Period dtype.
 
@@ -627,7 +628,7 @@ def is_period_dtype(arr_or_dtype):
     return PeriodDtype.is_dtype(arr_or_dtype)
 
 
-def is_interval_dtype(arr_or_dtype):
+def is_interval_dtype(arr_or_dtype) -> bool:
     """
     Check whether an array-like or dtype is of the Interval dtype.
 
@@ -696,7 +697,7 @@ def is_categorical_dtype(arr_or_dtype) -> bool:
     return CategoricalDtype.is_dtype(arr_or_dtype)
 
 
-def is_string_dtype(arr_or_dtype):
+def is_string_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of the string dtype.
 
@@ -732,7 +733,7 @@ def is_string_dtype(arr_or_dtype):
     return _is_dtype(arr_or_dtype, condition)
 
 
-def is_period_arraylike(arr):
+def is_period_arraylike(arr) -> bool:
     """
     Check whether an array-like is a periodical array-like or PeriodIndex.
 
@@ -764,7 +765,7 @@ def is_period_arraylike(arr):
     return getattr(arr, "inferred_type", None) == "period"
 
 
-def is_datetime_arraylike(arr):
+def is_datetime_arraylike(arr) -> bool:
     """
     Check whether an array-like is a datetime array-like or DatetimeIndex.
 
@@ -799,7 +800,7 @@ def is_datetime_arraylike(arr):
     return getattr(arr, "inferred_type", None) == "datetime"
 
 
-def is_dtype_equal(source, target):
+def is_dtype_equal(source, target) -> bool:
     """
     Check if two dtypes are equal.
 
@@ -889,7 +890,7 @@ def is_any_int_dtype(arr_or_dtype) -> bool:
     return _is_dtype_type(arr_or_dtype, classes(np.integer, np.timedelta64))
 
 
-def is_integer_dtype(arr_or_dtype):
+def is_integer_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of an integer dtype.
 
@@ -944,7 +945,7 @@ def is_integer_dtype(arr_or_dtype):
     return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.integer))
 
 
-def is_signed_integer_dtype(arr_or_dtype):
+def is_signed_integer_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of a signed integer dtype.
 
@@ -1001,7 +1002,7 @@ def is_signed_integer_dtype(arr_or_dtype):
     return _is_dtype_type(arr_or_dtype, classes_and_not_datetimelike(np.signedinteger))
 
 
-def is_unsigned_integer_dtype(arr_or_dtype):
+def is_unsigned_integer_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of an unsigned integer dtype.
 
@@ -1050,7 +1051,7 @@ def is_unsigned_integer_dtype(arr_or_dtype):
     )
 
 
-def is_int64_dtype(arr_or_dtype):
+def is_int64_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of the int64 dtype.
 
@@ -1141,7 +1142,7 @@ def is_datetime64_any_dtype(arr_or_dtype) -> bool:
     return is_datetime64_dtype(arr_or_dtype) or is_datetime64tz_dtype(arr_or_dtype)
 
 
-def is_datetime64_ns_dtype(arr_or_dtype):
+def is_datetime64_ns_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of the datetime64[ns] dtype.
 
@@ -1191,7 +1192,7 @@ def is_datetime64_ns_dtype(arr_or_dtype):
     return tipo == _NS_DTYPE or getattr(tipo, "base", None) == _NS_DTYPE
 
 
-def is_timedelta64_ns_dtype(arr_or_dtype):
+def is_timedelta64_ns_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of the timedelta64[ns] dtype.
 
@@ -1222,7 +1223,7 @@ def is_timedelta64_ns_dtype(arr_or_dtype):
     return _is_dtype(arr_or_dtype, lambda dtype: dtype == _TD_DTYPE)
 
 
-def is_datetime_or_timedelta_dtype(arr_or_dtype):
+def is_datetime_or_timedelta_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of
     a timedelta64 or datetime64 dtype.
@@ -1285,7 +1286,7 @@ def _is_unorderable_exception(e: TypeError) -> bool:
     return "unorderable" in str(e)
 
 
-def needs_i8_conversion(arr_or_dtype):
+def needs_i8_conversion(arr_or_dtype) -> bool:
     """
     Check whether the array or dtype should be converted to int64.
 
@@ -1329,7 +1330,7 @@ def needs_i8_conversion(arr_or_dtype):
     )
 
 
-def is_numeric_dtype(arr_or_dtype):
+def is_numeric_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of a numeric dtype.
 
@@ -1372,7 +1373,7 @@ def is_numeric_dtype(arr_or_dtype):
     )
 
 
-def is_string_like_dtype(arr_or_dtype):
+def is_string_like_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of a string-like dtype.
 
@@ -1404,7 +1405,7 @@ def is_string_like_dtype(arr_or_dtype):
     return _is_dtype(arr_or_dtype, lambda dtype: dtype.kind in ("S", "U"))
 
 
-def is_float_dtype(arr_or_dtype):
+def is_float_dtype(arr_or_dtype) -> bool:
     """
     Check whether the provided array or dtype is of a float dtype.
 
diff --git a/pandas/core/dtypes/concat.py b/pandas/core/dtypes/concat.py
index a62d3d0f4..768272e17 100644
--- a/pandas/core/dtypes/concat.py
+++ b/pandas/core/dtypes/concat.py
@@ -69,7 +69,7 @@ def get_dtype_kinds(l):
     return typs
 
 
-def concat_compat(to_concat, axis=0):
+def concat_compat(to_concat, axis: int = 0):
     """
     provide concatenation of an array of arrays each of which is a single
     'normalized' dtypes (in that for example, if it's object, then it is a
@@ -137,7 +137,7 @@ def concat_compat(to_concat, axis=0):
     return np.concatenate(to_concat, axis=axis)
 
 
-def concat_categorical(to_concat, axis=0):
+def concat_categorical(to_concat, axis: int = 0):
     """Concatenate an object/categorical array of arrays, each of which is a
     single dtype
 
@@ -183,7 +183,9 @@ def concat_categorical(to_concat, axis=0):
     return result
 
 
-def union_categoricals(to_union, sort_categories=False, ignore_order=False):
+def union_categoricals(
+    to_union, sort_categories: bool = False, ignore_order: bool = False
+):
     """
     Combine list-like of Categorical-like, unioning categories.
 
@@ -355,7 +357,7 @@ def union_categoricals(to_union, sort_categories=False, ignore_order=False):
     return Categorical(new_codes, categories=categories, ordered=ordered, fastpath=True)
 
 
-def _concatenate_2d(to_concat, axis):
+def _concatenate_2d(to_concat, axis: int):
     # coerce to 2d if needed & concatenate
     if axis == 1:
         to_concat = [np.atleast_2d(x) for x in to_concat]
diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index 4a4ad076f..a0712a0df 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -416,12 +416,12 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
             return hash(self) == hash(other)
 
     def __repr__(self) -> str_type:
-        tpl = "CategoricalDtype(categories={}ordered={})"
+        tpl = "CategoricalDtype(categories={data}ordered={ordered})"
         if self.categories is None:
             data = "None, "
         else:
             data = self.categories._format_data(name=self.__class__.__name__)
-        return tpl.format(data, self._ordered)
+        return tpl.format(data=data, ordered=self._ordered)
 
     @staticmethod
     def _hash_categories(categories, ordered: Ordered = True) -> int:
@@ -719,7 +719,7 @@ class DatetimeTZDtype(PandasExtensionDtype):
         return DatetimeArray
 
     @classmethod
-    def construct_from_string(cls, string):
+    def construct_from_string(cls, string: str_type):
         """
         Construct a DatetimeTZDtype from a string.
 
@@ -736,7 +736,7 @@ class DatetimeTZDtype(PandasExtensionDtype):
         datetime64[ns, UTC]
         """
         if isinstance(string, str):
-            msg = "Could not construct DatetimeTZDtype from '{}'"
+            msg = "Could not construct DatetimeTZDtype from '{string}'"
             match = cls._match.match(string)
             if match:
                 d = match.groupdict()
@@ -747,8 +747,8 @@ class DatetimeTZDtype(PandasExtensionDtype):
                     #  pytz timezone (actually pytz.UnknownTimeZoneError).
                     # TypeError if we pass a nonsense tz;
                     # ValueError if we pass a unit other than "ns"
-                    raise TypeError(msg.format(string)) from err
-            raise TypeError(msg.format(string))
+                    raise TypeError(msg.format(string=string)) from err
+            raise TypeError(msg.format(string=string))
 
         raise TypeError("Could not construct DatetimeTZDtype")
 
@@ -756,11 +756,11 @@ class DatetimeTZDtype(PandasExtensionDtype):
         return "datetime64[{unit}, {tz}]".format(unit=self.unit, tz=self.tz)
 
     @property
-    def name(self):
+    def name(self) -> str_type:
         """A string representation of the dtype."""
         return str(self)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         # make myself hashable
         # TODO: update this.
         return hash(str(self))
@@ -893,14 +893,14 @@ class PeriodDtype(PandasExtensionDtype):
         return self.name
 
     @property
-    def name(self):
+    def name(self) -> str_type:
         return "period[{freq}]".format(freq=self.freq.freqstr)
 
     @property
     def na_value(self):
         return NaT
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         # make myself hashable
         return hash(str(self))
 
@@ -917,7 +917,7 @@ class PeriodDtype(PandasExtensionDtype):
         self._freq = state["freq"]
 
     @classmethod
-    def is_dtype(cls, dtype):
+    def is_dtype(cls, dtype) -> bool:
         """
         Return a boolean if we if the passed type is an actual dtype that we
         can match (via string or type)
@@ -1073,7 +1073,7 @@ class IntervalDtype(PandasExtensionDtype):
             return "interval"
         return "interval[{subtype}]".format(subtype=self.subtype)
 
-    def __hash__(self):
+    def __hash__(self) -> int:
         # make myself hashable
         return hash(str(self))
 
@@ -1097,7 +1097,7 @@ class IntervalDtype(PandasExtensionDtype):
         self._subtype = state["subtype"]
 
     @classmethod
-    def is_dtype(cls, dtype):
+    def is_dtype(cls, dtype) -> bool:
         """
         Return a boolean if we if the passed type is an actual dtype that we
         can match (via string or type)
diff --git a/pandas/core/dtypes/generic.py b/pandas/core/dtypes/generic.py
index 2518f330b..aa0f7d2ab 100644
--- a/pandas/core/dtypes/generic.py
+++ b/pandas/core/dtypes/generic.py
@@ -5,7 +5,7 @@
 # objects
 def create_pandas_abc_type(name, attr, comp):
     @classmethod
-    def _check(cls, inst):
+    def _check(cls, inst) -> bool:
         return getattr(inst, attr, "_typ") in comp
 
     dct = dict(__instancecheck__=_check, __subclasscheck__=_check)
@@ -74,7 +74,7 @@ ABCPandasArray = create_pandas_abc_type("ABCPandasArray", "_typ", ("npy_extensio
 
 
 class _ABCGeneric(type):
-    def __instancecheck__(cls, inst):
+    def __instancecheck__(cls, inst) -> bool:
         return hasattr(inst, "_data")
 
 
diff --git a/pandas/core/dtypes/inference.py b/pandas/core/dtypes/inference.py
index 61fa7940c..9e9278052 100644
--- a/pandas/core/dtypes/inference.py
+++ b/pandas/core/dtypes/inference.py
@@ -26,7 +26,7 @@ is_interval = lib.is_interval
 is_list_like = lib.is_list_like
 
 
-def is_number(obj):
+def is_number(obj) -> bool:
     """
     Check if the object is a number.
 
@@ -67,7 +67,7 @@ def is_number(obj):
     return isinstance(obj, (Number, np.number))
 
 
-def _iterable_not_string(obj):
+def _iterable_not_string(obj) -> bool:
     """
     Check if the object is an iterable but not a string.
 
@@ -93,7 +93,7 @@ def _iterable_not_string(obj):
     return isinstance(obj, abc.Iterable) and not isinstance(obj, str)
 
 
-def is_iterator(obj):
+def is_iterator(obj) -> bool:
     """
     Check if the object is an iterator.
 
@@ -127,7 +127,7 @@ def is_iterator(obj):
     return hasattr(obj, "__next__")
 
 
-def is_file_like(obj):
+def is_file_like(obj) -> bool:
     """
     Check if the object is a file-like object.
 
@@ -165,7 +165,7 @@ def is_file_like(obj):
     return True
 
 
-def is_re(obj):
+def is_re(obj) -> bool:
     """
     Check if the object is a regex pattern instance.
 
@@ -188,7 +188,7 @@ def is_re(obj):
     return isinstance(obj, Pattern)
 
 
-def is_re_compilable(obj):
+def is_re_compilable(obj) -> bool:
     """
     Check if the object can be compiled into a regex pattern instance.
 
@@ -217,7 +217,7 @@ def is_re_compilable(obj):
         return True
 
 
-def is_array_like(obj):
+def is_array_like(obj) -> bool:
     """
     Check if the object is array-like.
 
@@ -250,7 +250,7 @@ def is_array_like(obj):
     return is_list_like(obj) and hasattr(obj, "dtype")
 
 
-def is_nested_list_like(obj):
+def is_nested_list_like(obj) -> bool:
     """
     Check if the object is list-like, and that all of its elements
     are also list-like.
@@ -296,7 +296,7 @@ def is_nested_list_like(obj):
     )
 
 
-def is_dict_like(obj):
+def is_dict_like(obj) -> bool:
     """
     Check if the object is dict-like.
 
@@ -328,7 +328,7 @@ def is_dict_like(obj):
     )
 
 
-def is_named_tuple(obj):
+def is_named_tuple(obj) -> bool:
     """
     Check if the object is a named tuple.
 
@@ -355,7 +355,7 @@ def is_named_tuple(obj):
     return isinstance(obj, tuple) and hasattr(obj, "_fields")
 
 
-def is_hashable(obj):
+def is_hashable(obj) -> bool:
     """
     Return True if hash(obj) will succeed, False otherwise.
 
@@ -392,7 +392,7 @@ def is_hashable(obj):
         return True
 
 
-def is_sequence(obj):
+def is_sequence(obj) -> bool:
     """
     Check if the object is a sequence of objects.
     String types are not included as sequences here.
diff --git a/pandas/core/dtypes/missing.py b/pandas/core/dtypes/missing.py
index 0a8f636b4..df89bd374 100644
--- a/pandas/core/dtypes/missing.py
+++ b/pandas/core/dtypes/missing.py
@@ -157,7 +157,8 @@ def _isna_new(obj):
 
 
 def _isna_old(obj):
-    """Detect missing values. Treat None, NaN, INF, -INF as null.
+    """
+    Detect missing values, treating None, NaN, INF, -INF as null.
 
     Parameters
     ----------
@@ -190,7 +191,9 @@ _isna = _isna_new
 
 
 def _use_inf_as_na(key):
-    """Option change callback for na/inf behaviour
+    """
+    Option change callback for na/inf behaviour.
+
     Choose which replacement for numpy.isnan / -numpy.isfinite is used.
 
     Parameters
@@ -389,7 +392,7 @@ def _isna_compat(arr, fill_value=np.nan):
     return True
 
 
-def array_equivalent(left, right, strict_nan=False):
+def array_equivalent(left, right, strict_nan: bool = False):
     """
     True if two arrays, left and right, have equal non-NaN elements, and NaNs
     in corresponding locations.  False otherwise. It is assumed that left and
@@ -508,7 +511,7 @@ def _maybe_fill(arr, fill_value=np.nan):
     return arr
 
 
-def na_value_for_dtype(dtype, compat=True):
+def na_value_for_dtype(dtype, compat: bool = True):
     """
     Return a dtype compat na value
 
@@ -566,7 +569,7 @@ def remove_na_arraylike(arr):
         return arr[notna(lib.values_from_object(arr))]
 
 
-def is_valid_nat_for_dtype(obj, dtype):
+def is_valid_nat_for_dtype(obj, dtype) -> bool:
     """
     isna check that excludes incompatible dtypes
 

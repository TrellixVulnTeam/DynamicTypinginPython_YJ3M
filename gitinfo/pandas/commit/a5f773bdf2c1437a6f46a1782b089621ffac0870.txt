commit a5f773bdf2c1437a6f46a1782b089621ffac0870
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 4 16:08:03 2012 -0400

    BUG: cast other datetime64 units to nanos from Index constructor, properly handle Index.astype(datetime64-unit), close #1384

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 1debdd03e..d06d89f88 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -73,19 +73,20 @@ class Index(np.ndarray):
 
     def __new__(cls, data, dtype=None, copy=False, name=None):
         if isinstance(data, np.ndarray):
-            if dtype is None:
-                if issubclass(data.dtype.type, np.datetime64):
-                    from pandas.tseries.index import DatetimeIndex
-                    return DatetimeIndex(data, copy=copy, name=name)
+            if dtype is not None:
+                try:
+                    data = np.array(data, dtype=dtype, copy=copy)
+                except TypeError:
+                    pass
 
-                if issubclass(data.dtype.type, np.integer):
-                    return Int64Index(data, copy=copy, name=name)
+            if issubclass(data.dtype.type, np.datetime64):
+                from pandas.tseries.index import DatetimeIndex
+                return DatetimeIndex(data, copy=copy, name=name)
 
-            if not copy:
-                subarr = com._ensure_object(data)
-            else:
-                subarr = data.astype(object)
-            # subarr = np.array(data, dtype=object, copy=copy)
+            if issubclass(data.dtype.type, np.integer):
+                return Int64Index(data, copy=copy, name=name)
+
+            subarr = com._ensure_object(data)
         elif np.isscalar(data):
             raise ValueError('Index(...) must be called with a collection '
                              'of some kind, %s was passed' % repr(data))
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index 673d759de..8304b6fd3 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -29,6 +29,9 @@ class _SparseMockBlockManager(object):
     def get(self, item):
         return self.sp_frame[item].values
 
+    def iget(self, i):
+        return self.get(self.sp_frame.columns[i])
+
     @property
     def shape(self):
         x, y = self.sp_frame.shape
@@ -184,16 +187,24 @@ class SparseDataFrame(DataFrame):
     def __getstate__(self):
         series = dict((k, (v.sp_index, v.sp_values))
                       for k, v in self.iteritems())
-        columns = _pickle_array(self.columns)
-        index = _pickle_array(self.index)
+        columns = self.columns
+        index = self.index
 
         return (series, columns, index, self.default_fill_value,
                 self.default_kind)
 
     def __setstate__(self, state):
         series, cols, idx, fv, kind = state
-        columns = _unpickle_array(cols)
-        index = _unpickle_array(idx)
+
+        if not isinstance(cols, Index):  # pragma: no cover
+            columns = _unpickle_array(cols)
+        else:
+            columns = cols
+
+        if not isinstance(idx, Index):  # pragma: no cover
+            index = _unpickle_array(idx)
+        else:
+            index = idx
 
         series_dict = {}
         for col, (sp_index, sp_values) in series.iteritems():
diff --git a/pandas/sparse/tests/test_sparse.py b/pandas/sparse/tests/test_sparse.py
index 87b1f398c..be19b9574 100644
--- a/pandas/sparse/tests/test_sparse.py
+++ b/pandas/sparse/tests/test_sparse.py
@@ -752,6 +752,8 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         # assert level parameter breaks reindex
         self.assertRaises(Exception, self.frame.reindex, idx, level=0)
 
+        repr(self.frame)
+
     def test_constructor_ndarray(self):
         # no index or columns
         sp = SparseDataFrame(self.frame.values)
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 4e8f75b55..73c79c54e 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -120,6 +120,7 @@ class TimeSeriesError(Exception):
 
 
 _midnight = time(0, 0)
+_NS_DTYPE = np.dtype('M8[ns]')
 
 class DatetimeIndex(Int64Index):
     """
@@ -239,9 +240,12 @@ class DatetimeIndex(Int64Index):
                 offset = data.offset
                 verify_integrity = False
             else:
-                subarr = np.array(data, dtype='M8[ns]', copy=copy)
+                if data.dtype != _NS_DTYPE:
+                    subarr = lib.cast_to_nanoseconds(data)
+                else:
+                    subarr = data
         elif issubclass(data.dtype.type, np.integer):
-            subarr = np.array(data, dtype='M8[ns]', copy=copy)
+            subarr = np.array(data, dtype=_NS_DTYPE, copy=copy)
         else:
             subarr = tools.to_datetime(data)
             if not np.issubdtype(subarr.dtype, np.datetime64):
@@ -254,7 +258,7 @@ class DatetimeIndex(Int64Index):
             ints = subarr.view('i8')
             lib.tz_localize_check(ints, tz)
             subarr = lib.tz_convert(ints, tz, _utc())
-            subarr = subarr.view('M8[ns]')
+            subarr = subarr.view(_NS_DTYPE)
 
         subarr = subarr.view(cls)
         subarr.name = name
@@ -319,7 +323,7 @@ class DatetimeIndex(Int64Index):
             ints = index.view('i8')
             lib.tz_localize_check(ints, tz)
             index = lib.tz_convert(ints, tz, _utc())
-            index = index.view('M8[ns]')
+            index = index.view(_NS_DTYPE)
 
         index = index.view(cls)
         index.name = name
@@ -361,7 +365,7 @@ class DatetimeIndex(Int64Index):
                                  end=_CACHE_END)
 
             arr = np.array(_to_m8_array(list(xdr)),
-                           dtype='M8[ns]', copy=False)
+                           dtype=_NS_DTYPE, copy=False)
 
             cachedRange = arr.view(DatetimeIndex)
             cachedRange.offset = offset
@@ -462,7 +466,7 @@ class DatetimeIndex(Int64Index):
             # extract the raw datetime data, turn into datetime64
             index_state = state[0]
             raw_data = index_state[0][4]
-            raw_data = np.array(raw_data, dtype='M8[ns]')
+            raw_data = np.array(raw_data, dtype=_NS_DTYPE)
             new_state = raw_data.__reduce__()
             np.ndarray.__setstate__(self, new_state[2])
         else:  # pragma: no cover
@@ -491,7 +495,7 @@ class DatetimeIndex(Int64Index):
     def _add_delta(self, delta):
         if isinstance(delta, (Tick, timedelta)):
             inc = offsets._delta_to_nanoseconds(delta)
-            new_values = (self.asi8 + inc).view('M8[ns]')
+            new_values = (self.asi8 + inc).view(_NS_DTYPE)
         else:
             new_values = self.astype('O') + delta
         return DatetimeIndex(new_values, tz=self.tz, freq='infer')
@@ -510,6 +514,44 @@ class DatetimeIndex(Int64Index):
 
         return result
 
+    def append(self, other):
+        """
+        Append a collection of Index options together
+
+        Parameters
+        ----------
+        other : Index or list/tuple of indices
+
+        Returns
+        -------
+        appended : Index
+        """
+        from pandas.core.index import _ensure_compat_concat
+
+        name = self.name
+        to_concat = [self]
+
+        if isinstance(other, (list, tuple)):
+            to_concat = to_concat + list(other)
+        else:
+            to_concat.append(other)
+
+        for obj in to_concat:
+            if isinstance(obj, Index) and obj.name != name:
+                name = None
+                break
+
+        to_concat = _ensure_compat_concat(to_concat)
+        to_concat = [x.values if isinstance(x, Index) else x
+                     for x in to_concat]
+
+        if all(x.dtype == _NS_DTYPE for x in to_concat):
+            # work around NumPy 1.6 bug
+            new_values = np.concatenate([x.view('i8') for x in to_concat])
+            return Index(new_values.view(_NS_DTYPE), name=name)
+        else:
+            return Index(np.concatenate(to_concat), name=name)
+
     def astype(self, dtype):
         dtype = np.dtype(dtype)
 
@@ -590,7 +632,7 @@ class DatetimeIndex(Int64Index):
         # Superdumb, punting on any optimizing
         freq = to_offset(freq)
 
-        snapped = np.empty(len(self), dtype='M8[ns]')
+        snapped = np.empty(len(self), dtype=_NS_DTYPE)
 
         for i, v in enumerate(self):
             s = v
@@ -1030,7 +1072,7 @@ class DatetimeIndex(Int64Index):
 
     def searchsorted(self, key, side='left'):
         if isinstance(key, np.ndarray):
-            key = np.array(key, dtype='M8[ns]', copy=False)
+            key = np.array(key, dtype=_NS_DTYPE, copy=False)
         else:
             key = _to_m8(key)
 
@@ -1055,7 +1097,7 @@ class DatetimeIndex(Int64Index):
 
     @property
     def dtype(self):
-        return np.dtype('M8[ns]')
+        return _NS_DTYPE
 
     @property
     def is_all_dates(self):
@@ -1147,7 +1189,7 @@ class DatetimeIndex(Int64Index):
 
         # Convert to UTC
         new_dates = lib.tz_convert(self.asi8, tz, _utc())
-        new_dates = new_dates.view('M8[ns]')
+        new_dates = new_dates.view(_NS_DTYPE)
         return self._simple_new(new_dates, self.name, self.offset, tz)
 
     def tz_validate(self):
@@ -1193,12 +1235,12 @@ def _generate_regular_range(start, end, periods, offset):
             raise NotImplementedError
 
         data = np.arange(b, e, stride, dtype=np.int64)
-        data = data.view('M8[ns]')
+        data = data.view(_NS_DTYPE)
     else:
         xdr = generate_range(start=start, end=end,
             periods=periods, offset=offset)
 
-        data = np.array(list(xdr), dtype='M8[ns]')
+        data = np.array(list(xdr), dtype=_NS_DTYPE)
 
     return data
 
@@ -1267,7 +1309,7 @@ def _to_m8(key):
         # this also converts strings
         key = Timestamp(key)
 
-    return np.int64(lib.pydt_to_i8(key)).view('M8[ns]')
+    return np.int64(lib.pydt_to_i8(key)).view(_NS_DTYPE)
 
 
 def _to_m8_array(arr):
@@ -1283,7 +1325,7 @@ def _str_to_dt_array(arr, offset=None):
 
     p_ufunc = np.frompyfunc(parser, 1, 1)
     data = p_ufunc(arr)
-    return np.array(data, dtype='M8[ns]')
+    return np.array(data, dtype=_NS_DTYPE)
 
 
 _CACHE_START = Timestamp(datetime(1950, 1, 1))
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 0f412055c..42db2c73e 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -381,7 +381,6 @@ class TestTimeSeries(unittest.TestCase):
 
             self.assert_((tmp['dates'].values == ex_vals).all())
 
-
     def test_series_ctor_datetime64(self):
         rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50',
                          freq='10s')
@@ -390,6 +389,21 @@ class TestTimeSeries(unittest.TestCase):
         series = Series(dates)
         self.assert_(np.issubdtype(series.dtype, np.dtype('M8[ns]')))
 
+    def test_index_cast_datetime64_other_units(self):
+        arr = np.arange(0, 100, 10, dtype=np.int64).view('M8[D]')
+
+        idx = Index(arr)
+
+        self.assert_((idx.values == lib.cast_to_nanoseconds(arr)).all())
+
+    def test_index_astype_datetime64(self):
+        idx = Index([datetime(2012, 1, 1)], dtype=object)
+
+        casted = idx.astype(np.dtype('M8[D]'))
+        expected = DatetimeIndex(idx.values)
+        self.assert_(isinstance(casted, DatetimeIndex))
+        self.assert_(casted.equals(expected))
+
     def test_reindex_series_add_nat(self):
         rng = date_range('1/1/2000 00:00:00', periods=10, freq='10s')
         series = Series(rng)

commit b35406abda6803dc1c37b1375f73c07254fea551
Author: jreback <jeff@reback.net>
Date:   Sun Jul 14 15:00:53 2013 -0400

    ENH: add automatic query via frame.__getitem__

diff --git a/doc/source/api.rst b/doc/source/api.rst
index 538965d0b..837afb899 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -155,6 +155,17 @@ Top-level dealing with datetimes
    to_datetime
 
 
+Top-level evaluation
+~~~~~~~~~~~~~~~~~~~~
+
+.. currentmodule:: pandas.computation.eval
+
+.. autosummary::
+   :toctree: generated/
+
+   eval
+
+
 Standard moving window functions
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -452,6 +463,7 @@ Indexing, iteration
    DataFrame.tail
    DataFrame.xs
    DataFrame.isin
+   DataFrame.query
 
 Binary operator functions
 ~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/doc/source/enhancingperf.rst b/doc/source/enhancingperf.rst
index 95428bd27..3f3a31879 100644
--- a/doc/source/enhancingperf.rst
+++ b/doc/source/enhancingperf.rst
@@ -225,8 +225,8 @@ the rows, applying our ``integrate_f_typed``, and putting this in the zeros arra
 
 .. note::
 
-    Loop like this would be *extremely* slow in python, but in cython looping over
-    numpy arrays is *fast*.
+    Loops like this would be *extremely* slow in python, but in Cython looping
+    over numpy arrays is *fast*.
 
 .. ipython:: python
 
@@ -289,3 +289,154 @@ Further topics
 - Loading C modules into cython.
 
 Read more in the `cython docs <http://docs.cython.org/>`__.
+
+.. _enhancingperf.eval:
+
+Expression Evaluation via :func:`~pandas.computation.eval.eval`
+---------------------------------------------------------------
+
+New in pandas v0.13 a top-level function :func:`~pandas.computation.eval.eval`
+implements expression evaluation of expressions containing
+:class:`~pandas.core.series.Series` and :class:`~pandas.core.frame.DataFrame`
+objects.
+
+.. note::
+
+   To benefit from using :func:`~pandas.computation.eval.eval` you need to
+   install ``numexpr``. See the :ref:`recommended dependencies section
+   <install.recommended_dependencies>` for more details.
+
+The major benefit of using :func:`~pandas.computation.eval.eval` for expression
+evaluation rather than just straight-up Python is two-fold: large
+:class:`~pandas.core.frame.DataFrame` objects are evaluated more efficiently
+and large expressions are evaluated all at once by the underlying engine (by
+default ``numexpr`` is used for evaluation).
+
+.. note::
+
+   You should not use :func:`~pandas.computation.eval.eval` for simple
+   expressions or for expressions involving small DataFrames. In fact,
+   :func:`~pandas.computation.eval.eval` is many orders of magnitude slower for
+   smaller expressions/objects than plain ole' Python. A good rule of thumb is
+   to only use :func:`~pandas.computation.eval.eval` when you have a
+   :class:`~pandas.core.frame.DataFrame` with more than 10,000 rows.
+
+
+:func:`~pandas.computation.eval.eval` supports all arithmetic expressions
+supported by the engine (by default the engine is ``numexpr``). The ``numexpr``
+engine uses ``numexpr`` under the hood to evaluate expressions efficiently,
+while allowing a slightly modified, and we think more intuitive syntax for
+expressions.
+
+
+.. note::
+
+   The larger the frame and the larger the expression the more speedup you will
+   see from using :func:`~pandas.computation.eval.eval`.
+
+
+:func:`~pandas.computation.eval.eval` Examples
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:func:`~pandas.computation.eval.eval` works wonders for expressions containing
+large arrays
+
+First let's create 4 decent-sized arrays to play with:
+
+.. ipython:: python
+
+   import pandas as pd
+   from pandas import DataFrame, Series
+   from numpy.random import randn
+   import numpy as np
+   nrows, ncols = 20000, 100
+   df1, df2, df3, df4 = [DataFrame(randn(nrows, ncols)) for _ in xrange(4)]
+
+
+Now let's compare adding them together using plain ol' Python versus
+:func:`~pandas.computation.eval.eval`:
+
+
+.. ipython:: python
+
+   %timeit df1 + df2 + df3 + df4
+
+.. ipython:: python
+
+   %timeit pd.eval('df1 + df2 + df3 + df4')
+
+
+Now let's do the same thing but with comparisons:
+
+.. ipython:: python
+
+   %timeit (df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)
+
+.. ipython:: python
+
+   %timeit pd.eval('(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)')
+
+
+:func:`~pandas.computation.eval.eval` also works with "unaligned" pandas
+objects:
+
+
+.. ipython:: python
+
+   s = Series(randn(50))
+   %timeit df1 + df2 + df3 + df4 + s
+
+.. ipython:: python
+
+   %timeit pd.eval('df1 + df2 + df3 + df4 + s')
+
+There are also two different flavors of parsers and and two different engines
+to use as the backend.
+
+:func:`~pandas.computation.eval.eval` Parsers
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The default ``"pandas"`` parser allows a bit more intuitive (we think) syntax
+for expressing query-like operations (comparisons, conjunctions and
+disjunctions). In particular, the precedence of the ``&`` and ``|`` operators
+is made equal to the precedence of the corresponding boolean operations ``and``
+and ``or``.
+
+For example, the above conjunction can be written without
+parentheses. Alternatively, you can use the ``'python'`` parser to enforce
+strict Python semantics.
+
+.. ipython:: python
+
+   expr = '(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)'
+   x = pd.eval(expr, parser='python')
+   expr_no_parens = 'df1 > 0 & df2 > 0 & df3 > 0 & df4 > 0'
+   y = pd.eval(expr_no_parens, parser='pandas')
+   np.all(x == y)
+
+
+:func:`~pandas.computation.eval.eval` Backends
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+There's also the option to make :func:`~pandas.computation.eval.eval` operate
+identical to plain ol' Python.
+
+.. note::
+
+   Using the ``'python'`` engine is generally *not* useful, except for
+   comparing performance and testing other
+   :func:`~pandas.computation.eval.eval` engines against it. You will acheive
+   **no** performance benefits using :func:`~pandas.computation.eval.eval` with
+   ``engine='python'``.
+
+You can see this by using :func:`~pandas.computation.eval.eval` with the
+``'python'`` engine is actually a bit slower (not by much) than evaluating the
+same expression in Python:
+
+.. ipython:: python
+
+   %timeit df1 + df2 + df3 + df4
+
+.. ipython:: python
+
+   %timeit pd.eval('df1 + df2 + df3 + df4', engine='python')
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index d2fd11ee4..47bf5fe29 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -1006,6 +1006,77 @@ convert to an integer index:
     df_new[(df_new['index'] >= 1.0) & (df_new['index'] < 2)]
 
 
+.. _indexing.query:
+
+The ``query`` Method
+~~~~~~~~~~~~~~~~~~~~
+New in pandas v0.13, :class:`~pandas.core.frame.DataFrame` objects have a
+:meth:`~pandas.core.frame.DataFrame.query` method that allows selection using a
+string consisting of columns of the calling
+:class:`~pandas.core.frame.DataFrame`.
+
+
+
+.. _indexing.class:
+
+Index objects
+-------------
+
+The pandas Index class and its subclasses can be viewed as implementing an
+*ordered set* in addition to providing the support infrastructure necessary for
+lookups, data alignment, and reindexing. The easiest way to create one directly
+is to pass a list or other sequence to ``Index``:
+
+.. ipython:: python
+
+   index = Index(['e', 'd', 'a', 'b'])
+   index
+   'd' in index
+
+You can also pass a ``name`` to be stored in the index:
+
+
+.. ipython:: python
+
+   index = Index(['e', 'd', 'a', 'b'], name='something')
+   index.name
+
+Starting with pandas 0.5, the name, if set, will be shown in the console
+display:
+
+.. ipython:: python
+
+   index = Index(list(range(5)), name='rows')
+   columns = Index(['A', 'B', 'C'], name='cols')
+   df = DataFrame(np.random.randn(5, 3), index=index, columns=columns)
+   df
+   df['A']
+
+
+Set operations on Index objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. _indexing.set_ops:
+
+The three main operations are ``union (|)``, ``intersection (&)``, and ``diff
+(-)``. These can be directly called as instance methods or used via overloaded
+operators:
+
+.. ipython:: python
+
+   a = Index(['c', 'b', 'a'])
+   b = Index(['c', 'e', 'd'])
+   a.union(b)
+   a | b
+   a & b
+   a - b
+
+``isin`` method of Index objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+One additional operation is the ``isin`` method that works analogously to the
+``Series.isin`` method found :ref:`here <indexing.boolean>`.
+
 .. _indexing.hierarchical:
 
 Hierarchical indexing (MultiIndex)
@@ -1354,65 +1425,6 @@ not check (or care) whether the levels themselves are sorted. Fortunately, the
 constructors ``from_tuples`` and ``from_arrays`` ensure that this is true, but
 if you compute the levels and labels yourself, please be careful.
 
-.. _indexing.class:
-
-Index objects
--------------
-
-The pandas Index class and its subclasses can be viewed as implementing an
-*ordered set* in addition to providing the support infrastructure necessary for
-lookups, data alignment, and reindexing. The easiest way to create one directly
-is to pass a list or other sequence to ``Index``:
-
-.. ipython:: python
-
-   index = Index(['e', 'd', 'a', 'b'])
-   index
-   'd' in index
-
-You can also pass a ``name`` to be stored in the index:
-
-
-.. ipython:: python
-
-   index = Index(['e', 'd', 'a', 'b'], name='something')
-   index.name
-
-Starting with pandas 0.5, the name, if set, will be shown in the console
-display:
-
-.. ipython:: python
-
-   index = Index(list(range(5)), name='rows')
-   columns = Index(['A', 'B', 'C'], name='cols')
-   df = DataFrame(np.random.randn(5, 3), index=index, columns=columns)
-   df
-   df['A']
-
-
-Set operations on Index objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. _indexing.set_ops:
-
-The three main operations are ``union (|)``, ``intersection (&)``, and ``diff
-(-)``. These can be directly called as instance methods or used via overloaded
-operators:
-
-.. ipython:: python
-
-   a = Index(['c', 'b', 'a'])
-   b = Index(['c', 'e', 'd'])
-   a.union(b)
-   a | b
-   a & b
-   a - b
-
-``isin`` method of Index objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-One additional operation is the ``isin`` method that works analogously to the
-``Series.isin`` method found :ref:`here <indexing.boolean>`.
 
 Setting index metadata (``name(s)``, ``levels``, ``labels``)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/computation/align.py b/pandas/computation/align.py
index 65840bb68..09606fc41 100644
--- a/pandas/computation/align.py
+++ b/pandas/computation/align.py
@@ -166,8 +166,15 @@ def _filter_terms(flat):
 
 def _align(terms):
     """Align a set of terms"""
-    # flatten the parse tree (a nested list, really)
-    terms = list(flatten(terms))
+    try:
+        # flatten the parse tree (a nested list, really)
+        terms = list(flatten(terms))
+    except TypeError:
+        # can't iterate so it must just be a constant or single variable
+        if isinstance(terms.value, (pd.Series, pd.core.generic.NDFrame)):
+            typ = type(terms.value)
+            return typ, _zip_axes_from_type(typ, terms.value.axes)
+        return np.result_type(terms.type), None
 
     # if all resolved variables are numeric scalars
     if all(term.isscalar for term in terms):
diff --git a/pandas/computation/engines.py b/pandas/computation/engines.py
index ea296ad0e..d4f23324b 100644
--- a/pandas/computation/engines.py
+++ b/pandas/computation/engines.py
@@ -76,4 +76,4 @@ class PythonEngine(AbstractEngine):
         pass
 
 
-_engines = {'numexpr': NumExprEngine, 'python': PythonEngine }
+_engines = {'numexpr': NumExprEngine, 'python': PythonEngine}
diff --git a/pandas/computation/eval.py b/pandas/computation/eval.py
index 04e17e3e4..5f234b786 100644
--- a/pandas/computation/eval.py
+++ b/pandas/computation/eval.py
@@ -4,27 +4,49 @@ import numbers
 
 import numpy as np
 
-import six
-
-from pandas.computation.expr import Expr, Scope
+from pandas.computation.expr import Expr, Scope, _parsers
 from pandas.computation.engines import _engines
 
 
-def eval(expr, engine='numexpr', truediv=True, local_dict=None,
-         global_dict=None, resolvers=None):
+def _check_engine(engine):
+    if engine not in _engines:
+        raise KeyError('Invalid engine {0!r} passed, valid engines are'
+                       ' {1}'.format(engine, _engines.keys()))
+    if engine == 'numexpr':
+        try:
+            import numexpr
+        except ImportError:
+            raise ImportError("'numexpr' not found. Cannot use "
+                              "engine='numexpr' if 'numexpr' is not installed")
+
+
+def _check_parser(parser):
+    if parser not in _parsers:
+        raise KeyError('Invalid parser {0!r} passed, valid parsers are'
+                       ' {1}'.format(parser, _parsers.keys()))
+
+
+
+def eval(expr, parser='pandas', engine='numexpr', truediv=True,
+         local_dict=None, global_dict=None, resolvers=None):
     """Evaluate a Python expression as a string using various backends.
 
     The following arithmetic operations are supported: +, -, *, /, **, %, //
     (python engine only) along with the following boolean operations: | (or), &
-    (and), and ~ (not). All Pandas objects are supported and behave as they
-    would with in-Python evaluation.
+    (and), and ~ (not). Series and DataFrame objects are supported and behave
+    as they would with in-Python evaluation.
 
     Parameters
     ----------
     expr : string or Expr object
         The expression to evaluate. This can be either a string or an ``Expr``
         object.
-    engine : string, optional, default 'numexpr', {'python', 'numexpr' }
+    parser : str, optional, default 'pandas', {'pandas', 'python'}
+        The parser to use to construct the syntax tree from the expression. The
+        default of 'pandas' parses code slightly different than standard
+        Python. See the :ref:`enhancing performance <enhancingperf.eval>`
+        documentation for more details.
+    engine : string, optional, default 'numexpr', {'python', 'numexpr'}
         The engine used to evaluate the expression. Supported engines are
 
         - 'numexpr': This default engine evaluates pandas objects using numexpr
@@ -32,7 +54,6 @@ def eval(expr, engine='numexpr', truediv=True, local_dict=None,
                      frames.
         - 'python': Performs operations as if you had eval'd in top level
                     python
-
     truediv : bool, optional, default True
         Whether to use true division, like in Python >= 3
     local_dict : dict or None, optional, default None
@@ -42,27 +63,23 @@ def eval(expr, engine='numexpr', truediv=True, local_dict=None,
 
     Returns
     -------
-    obj : ndarray, scalar, DataFrame, Series, or Panel
+    obj : ndarray, scalar, DataFrame, Series
 
     Notes
     -----
-    * The benefits of using ``eval`` are that very large frames that are terms in
-      long expressions are sped up, sometimes by as much as 10x.
-
     See :ref:`Enhancing performance <enhancingperf.eval>` for more details.
     """
     # make sure we're passed a valid engine
-    if not engine in _engines:
-        raise KeyError('Invalid engine {0} passed, valid engines are'
-                       ' {1}'.format(_engines.keys()))
+    _check_engine(engine)
+    _check_parser(parser)
 
     eng = _engines[engine]
 
-    if isinstance(expr, six.string_types):
+    if isinstance(expr, basestring):
         # need to go 2 up in the call stack from the constructor
         env = Scope(global_dict, local_dict, frame_level=2,
                     resolvers=resolvers)
-        parsed_expr = Expr(expr, engine, env, truediv)
+        parsed_expr = Expr(expr, engine, parser, env, truediv)
     elif isinstance(expr, Expr):
         parsed_expr = expr
     else:
diff --git a/pandas/computation/expr.py b/pandas/computation/expr.py
index cb7b26948..23f434110 100644
--- a/pandas/computation/expr.py
+++ b/pandas/computation/expr.py
@@ -8,10 +8,11 @@ from cStringIO import StringIO
 from functools import partial
 
 from pandas.core.base import StringMixin
-from pandas.computation.ops import BinOp, UnaryOp, _reductions, _mathops
-from pandas.computation.ops import _cmp_ops_syms, _bool_ops_syms
-from pandas.computation.ops import _arith_ops_syms, _unary_ops_syms
-from pandas.computation.ops import Term, Constant
+from pandas.core import common as com
+from pandas.computation.ops import (BinOp, UnaryOp, _reductions, _mathops,
+                                    _cmp_ops_syms, _bool_ops_syms,
+                                    _arith_ops_syms, _unary_ops_syms, Term,
+                                    Constant)
 
 import pandas.lib as lib
 import datetime
@@ -34,6 +35,10 @@ class Scope(object):
         self.globals['Timestamp'] = lib.Timestamp
         self.globals['datetime'] = datetime
 
+        # SUCH a hack
+        self.globals['True'] = True
+        self.globals['False'] = False
+
         self.resolvers = resolvers or []
         self.resolver_keys = set(reduce(operator.add, (list(o.keys()) for o in
                                                        self.resolvers), []))
@@ -219,8 +224,15 @@ class BaseExprVisitor(ast.NodeVisitor):
         self.preparser = preparser
 
     def visit(self, node, **kwargs):
+        parse = lambda x: ast.fix_missing_locations(ast.parse(x))
         if isinstance(node, basestring):
-            node = ast.fix_missing_locations(ast.parse(self.preparser(node)))
+            clean = self.preparser(node)
+        elif isinstance(node, ast.AST):
+            clean = node
+        else:
+            raise TypeError("Cannot visit objects of type {0!r}"
+                            "".format(node.__class__.__name__))
+        node = parse(clean)
 
         method = 'visit_' + node.__class__.__name__
         visitor = getattr(self, method, None)
@@ -263,7 +275,6 @@ class BaseExprVisitor(ast.NodeVisitor):
         """ df.index[4] """
         return self.visit(node.value)
 
-
     def visit_Subscript(self, node, **kwargs):
         """ df.index[4:6] """
         value = self.visit(node.value)
@@ -344,21 +355,16 @@ class BaseExprVisitor(ast.NodeVisitor):
         return node
 
 
-_numexpr_not_supported = frozenset(['Assign', 'BoolOp', 'Not', 'Str', 'Slice',
-                                    'Index', 'Subscript', 'Tuple', 'List',
-                                    'Dict', 'Call'])
+_python_not_supported = frozenset(['Assign', 'BoolOp', 'Not', 'Str', 'Slice',
+                                   'Index', 'Subscript', 'Tuple', 'List',
+                                   'Dict', 'Call'])
 _numexpr_supported_calls = frozenset(_reductions + _mathops)
 
-@disallow(_unsupported_nodes | _numexpr_not_supported)
-class NumExprVisitor(BaseExprVisitor):
-    def __init__(self, env, preparser=None):
-        if preparser is not None:
-            raise ValueError("only strict numexpr syntax is supported")
-        preparser = lambda x: x
-        super(NumExprVisitor, self).__init__(env, preparser)
-
+@disallow(_unsupported_nodes | _python_not_supported)
+class PandasExprVisitor(BaseExprVisitor):
+    def __init__(self, env, preparser=_preparse):
+        super(PandasExprVisitor, self).__init__(env, preparser)
 
-_python_not_supported = _numexpr_not_supported
 
 @disallow(_unsupported_nodes | _python_not_supported)
 class PythonExprVisitor(BaseExprVisitor):
@@ -369,10 +375,11 @@ class Expr(StringMixin):
 
     """Expr object"""
 
-    def __init__(self, expr, engine='numexpr', env=None, truediv=True):
+    def __init__(self, expr, engine='numexpr', parser='pandas', env=None,
+                 truediv=True):
         self.expr = expr
         self.env = env or Scope(frame_level=2)
-        self._visitor = _visitors[engine](self.env)
+        self._visitor = _parsers[parser](self.env)
         self.terms = self.parse()
         self.engine = engine
         self.truediv = truediv
@@ -382,7 +389,7 @@ class Expr(StringMixin):
         return self.terms(env)
 
     def __unicode__(self):
-        return unicode(self.terms)
+        return com.pprint_thing(self.terms)
 
     def __len__(self):
         return len(self.expr)
@@ -396,6 +403,18 @@ class Expr(StringMixin):
         return self.terms.align(self.env)
 
 
+def maybe_expression(s, kind='python'):
+    """ loose checking if s is an expression """
+    if not isinstance(s, basestring):
+        return False
+    try:
+        visitor = _parsers[kind]
+        # make sure we have an op at least
+        return any(op in s for op in visitor.binary_ops)
+    except:
+        return False
+
+
 def isexpr(s, check_names=True):
     try:
         Expr(s)
@@ -407,4 +426,4 @@ def isexpr(s, check_names=True):
         return True
 
 
-_visitors = {'python': PythonExprVisitor, 'numexpr': NumExprVisitor}
+_parsers = {'python': PythonExprVisitor, 'pandas': PandasExprVisitor}
diff --git a/pandas/computation/ops.py b/pandas/computation/ops.py
index b2dd638da..85459b2fa 100644
--- a/pandas/computation/ops.py
+++ b/pandas/computation/ops.py
@@ -2,7 +2,6 @@ import operator as op
 
 import numpy as np
 
-import pandas as pd
 from pandas.util.py3compat import PY3
 import pandas.core.common as com
 from pandas.core.base import StringMixin
@@ -34,20 +33,12 @@ class Term(StringMixin):
         self.side = side
         self.value = self._resolve_name()
 
-        try:
-            # ndframe potentially very slow for large, mixed dtype frames
-            self.type = self.value.values.dtype
-        except AttributeError:
-            try:
-                # ndarray
-                self.type = self.value.dtype
-            except AttributeError:
-                # scalar
-                self.type = type(self.value)
-
     def __unicode__(self):
         return com.pprint_thing(self.name)
 
+    def __call__(self, *args, **kwargs):
+        return self.value
+
     def _resolve_name(self):
         env = self.env
         key = self.name
@@ -59,9 +50,9 @@ class Term(StringMixin):
                 return key
             raise NameError('name {0!r} is not defined'.format(key))
 
-        if isinstance(res, pd.Panel):
-            raise NotImplementedError("Panel objects are not supported with "
-                                      "eval")
+        if hasattr(res, 'ndim') and res.ndim > 2:
+            raise NotImplementedError("N-dimensional objects, where N > 2, are"
+                                      " not supported with eval")
         return res
 
     def update(self, value):
@@ -79,7 +70,8 @@ class Term(StringMixin):
                         del env.globals[key]
                         env.globals[key] = value
                     except KeyError:
-                        raise NameError('{0!r} is undefined'.format(key))
+                        raise NameError('name {0!r} is not '
+                                        'defined'.format(key))
 
         self.value = value
 
@@ -87,6 +79,21 @@ class Term(StringMixin):
     def isscalar(self):
         return np.isscalar(self.value)
 
+    @property
+    def type(self):
+        try:
+            # ndframe potentially very slow for large, mixed dtype frames
+            return self.value.values.dtype
+        except AttributeError:
+            try:
+                # ndarray
+                return self.value.dtype
+            except AttributeError:
+                # scalar
+                return type(self.value)
+
+    return_type = type
+
 
 class Constant(Term):
     def __init__(self, value, env):
@@ -139,6 +146,11 @@ _arith_ops_funcs = (op.add, op.sub, op.mul, op.truediv if PY3 else op.div,
                     op.pow, op.floordiv, op.mod)
 _arith_ops_dict = dict(zip(_arith_ops_syms, _arith_ops_funcs))
 
+_special_case_arith_ops_syms = '**', '//', '%'
+_special_case_arith_ops_funcs = op.pow, op.floordiv, op.mod
+_special_case_arith_ops_dict = dict(zip(_special_case_arith_ops_syms,
+                                        _special_case_arith_ops_funcs))
+
 _binary_ops_dict = {}
 
 for d in (_cmp_ops_dict, _bool_ops_dict, _arith_ops_dict):
diff --git a/pandas/computation/tests/test_eval.py b/pandas/computation/tests/test_eval.py
index fa96342ec..06b6b211b 100755
--- a/pandas/computation/tests/test_eval.py
+++ b/pandas/computation/tests/test_eval.py
@@ -1,7 +1,8 @@
 #!/usr/bin/env python
 
 import unittest
-import itertools
+import functools
+import numbers
 from itertools import product
 import ast
 
@@ -18,15 +19,17 @@ import pandas as pd
 from pandas.core import common as com
 from pandas import DataFrame, Series, Panel
 from pandas.util.testing import makeCustomDataframe as mkdf
-from pandas.computation.engines import _engines, _reconstruct_object
-from pandas.computation.align import _align_core
-from pandas.computation.expr import NumExprVisitor, PythonExprVisitor
-from pandas.computation.ops import _binary_ops_dict, _unary_ops_dict, Term
+from pandas.computation.engines import _engines
+from pandas.computation.expr import PythonExprVisitor, PandasExprVisitor
+from pandas.computation.ops import (_binary_ops_dict, _unary_ops_dict,
+                                    _special_case_arith_ops_syms,
+                                    _arith_ops_syms)
 import pandas.computation.expr as expr
 from pandas.computation import pytables
 from pandas.computation.expressions import _USE_NUMEXPR
 from pandas.computation.eval import Scope
-from pandas.util.testing import assert_frame_equal, randbool
+from pandas.util.testing import (assert_frame_equal, randbool,
+                                 assertRaisesRegexp)
 from pandas.util.py3compat import PY3
 
 
@@ -39,30 +42,9 @@ def engine_has_neg_frac(engine):
     return _engines[engine].has_neg_frac
 
 
-def fractional(x):
-    frac, _ = np.modf(np.asanyarray(x))
-    return frac
-
-
-def hasfractional(x):
-    return np.any(fractional(x))
-
-
-def _eval_from_expr(lhs, cmp1, rhs, binop, cmp2):
-    f1 = _binary_ops_dict[cmp1]
-    f2 = _binary_ops_dict[cmp2]
-    bf = _binary_ops_dict[binop]
-    env = Scope()
-    typ, axes = _align_core((Term('lhs', env), Term('rhs', env)))
-    lhs, rhs = env.locals['lhs'], env.locals['rhs']
-    ret_type = np.result_type(lhs, rhs)
-    return _reconstruct_object(typ, bf(f1(lhs, rhs), f2(lhs, rhs)), axes,
-                               ret_type)
-
-
-def _eval_single_bin(lhs, cmp1, rhs, has_neg_frac):
+def _eval_single_bin(lhs, cmp1, rhs, engine):
     c = _binary_ops_dict[cmp1]
-    if has_neg_frac:
+    if engine_has_neg_frac(engine):
         try:
             result = c(lhs, rhs)
         except ValueError:
@@ -72,55 +54,57 @@ def _eval_single_bin(lhs, cmp1, rhs, has_neg_frac):
     return result
 
 
-def isframe(x):
-    return isinstance(x, pd.DataFrame)
-
-
-def isseries(x):
-    return isinstance(x, pd.Series)
-
-
-def are_compatible_types(op, lhs, rhs):
-    if op in ('&', '|'):
-        if isframe(lhs) and isseries(rhs) or isframe(rhs) and isseries(lhs):
-            return False
-    return True
-
-
-def _eval_bin_and_unary(unary, lhs, arith1, rhs):
-    binop = _binary_ops_dict[arith1]
-    unop = expr._unary_ops_dict[unary]
-    return unop(binop(lhs, rhs))
-
-
 def _series_and_2d_ndarray(lhs, rhs):
     return (com.is_series(lhs) and isinstance(rhs, np.ndarray) and rhs.ndim > 1
             or com.is_series(rhs) and isinstance(lhs, np.ndarray) and lhs.ndim
             > 1)
 
 
-class TestBasicEval(unittest.TestCase):
+def skip_incompatible_operand(f):
+    @functools.wraps(f)
+    def wrapper(self, lhs, arith1, rhs, *args, **kwargs):
+        if _series_and_2d_ndarray(lhs, rhs):
+            self.assertRaises(Exception, pd.eval, 'lhs {0} rhs'.format(arith1),
+                              local_dict={'lhs': lhs, 'rhs': rhs},
+                              engine=self.engine)
+        else:
+            f(self, lhs, arith1, rhs, *args, **kwargs)
+    return wrapper
+
+
+_good_arith_ops = tuple(set(_arith_ops_syms) -
+                        set(_special_case_arith_ops_syms))
+
+
+class TestEvalPandas(unittest.TestCase):
 
     @classmethod
-    def setUpClass(self):
-        self.cmp_ops = expr._cmp_ops_syms
-        self.cmp2_ops = self.cmp_ops[::-1]
-        self.bin_ops = expr._bool_ops_syms
-        self.arith_ops = tuple(o for o in expr._arith_ops_syms if o != '//')
-        self.unary_ops = '+', '-'
+    def setUpClass(cls):
+        cls.cmp_ops = expr._cmp_ops_syms
+        cls.cmp2_ops = cls.cmp_ops[::-1]
+        cls.bin_ops = expr._bool_ops_syms
+        cls.special_case_ops = _special_case_arith_ops_syms
+        cls.arith_ops = _good_arith_ops
+        cls.unary_ops = '+', '-'
 
     def set_current_engine(self):
         self.engine = 'numexpr'
 
     def setup_data(self):
-        nan_df = DataFrame(rand(10, 5))
-        nan_df[nan_df > 0.5] = np.nan
-        self.lhses = (DataFrame(randn(10, 5)), Series(randn(5)), randn(),
-                      np.float64(randn()), randn(10, 5), randn(5), np.nan,
-                      Series([1, 2, np.nan, np.nan, 5]), nan_df)
-        self.rhses = (DataFrame(randn(10, 5)), Series(randn(5)), randn(),
-                      np.float64(randn()), randn(10, 5), randn(5), np.nan,
-                      Series([1, 2, np.nan, np.nan, 5]), nan_df)
+        nan_df1 = DataFrame(rand(10, 5))
+        nan_df1[nan_df1 > 0.5] = np.nan
+        nan_df2 = DataFrame(rand(10, 5))
+        nan_df2[nan_df2 > 0.5] = np.nan
+
+        self.pandas_lhses = (DataFrame(randn(10, 5)), Series(randn(5)),
+                             Series([1, 2, np.nan, np.nan, 5]), nan_df1)
+        self.pandas_rhses = (DataFrame(randn(10, 5)), Series(randn(5)),
+                             Series([1, 2, np.nan, np.nan, 5]), nan_df2)
+        self.scalar_lhses = randn(), np.float64(randn()), np.nan
+        self.scalar_rhses = randn(), np.float64(randn()), np.nan
+
+        self.lhses = self.pandas_lhses + self.scalar_lhses
+        self.rhses = self.pandas_rhses + self.scalar_rhses
 
     def setUp(self):
         try:
@@ -135,131 +119,148 @@ class TestBasicEval(unittest.TestCase):
 
     @slow
     def test_complex_cmp_ops(self):
-        self.setUp()
-        lhses, rhses = self.lhses, self.rhses
-        args = itertools.product(lhses, self.cmp_ops, rhses, self.bin_ops,
-                                 self.cmp2_ops)
-        for lhs, cmp1, rhs, binop, cmp2 in args:
-            self._create_cmp_op_t(lhs, cmp1, rhs, binop, cmp2)
+        for lhs, cmp1, rhs, binop, cmp2 in product(self.lhses, self.cmp_ops,
+                                                   self.rhses, self.bin_ops,
+                                                   self.cmp2_ops):
+            self.check_complex_cmp_op(lhs, cmp1, rhs, binop, cmp2)
 
     def test_simple_cmp_ops(self):
         bool_lhses = (DataFrame(randbool(size=(10, 5))),
                       Series(randbool((5,))), randbool())
         bool_rhses = (DataFrame(randbool(size=(10, 5))),
                       Series(randbool((5,))), randbool())
-        args = itertools.product(bool_lhses, bool_rhses, self.cmp_ops)
-        for lhs, rhs, cmp_op in args:
-            self._create_simple_cmp_op_t(lhs, rhs, cmp_op)
+        for lhs, rhs, cmp_op in product(bool_lhses, bool_rhses, self.cmp_ops):
+            self.check_simple_cmp_op(lhs, cmp_op, rhs)
 
+    @slow
     def test_binary_arith_ops(self):
-        self.setUp()
-        lhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        rhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        args = itertools.product(lhses, self.arith_ops, rhses)
-        for lhs, op, rhs in args:
-            self._create_arith_op_t(lhs, op, rhs)
+        for lhs, op, rhs in product(self.lhses, self.arith_ops, self.rhses):
+            self.check_binary_arith_op(lhs, op, rhs)
+
+    def test_modulus(self):
+        for lhs, rhs in product(self.lhses, self.rhses):
+            self.check_modulus(lhs, '%', rhs)
+
+    def test_floor_division(self):
+        for lhs, rhs in product(self.lhses, self.rhses):
+            self.check_floor_division(lhs, '//', rhs)
+
+    def test_pow(self):
+        for lhs, rhs in product(self.lhses, self.rhses):
+            self.check_pow(lhs, '**', rhs)
 
+    @slow
     def test_unary_arith_ops(self):
-        self.setUp()
-        lhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        rhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        aops = tuple(aop for aop in self.arith_ops if aop not in '+-')
-        args = itertools.product(self.unary_ops, lhses, aops, rhses)
-        for unary_op, lhs, arith_op, rhs in args:
-            self._create_unary_arith_op_t(unary_op, lhs, arith_op, rhs)
-
-    def test_invert(self):
-        self.setUp()
-        lhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        rhses = DataFrame(randn(10, 5)), Series(randn(5)), randn()
-        args = itertools.product(lhses, self.cmp_ops, rhses)
-        for lhs, op, rhs in args:
-            self._create_invert_op_t(lhs, op, rhs)
-
-    def _create_cmp_op_t(self, lhs, cmp1, rhs, binop, cmp2):
+        for unary_op, lhs, arith_op, rhs in product(self.unary_ops, self.lhses,
+                                                    self.arith_ops,
+                                                    self.rhses):
+            self.check_unary_arith_op(lhs, arith_op, rhs, unary_op)
+
+    @slow
+    def test_single_invert_op(self):
+        for lhs, op, rhs in product(self.lhses, self.cmp_ops, self.rhses):
+            self.check_single_invert_op(lhs, op, rhs)
+
+    @slow
+    def test_compound_invert_op(self):
+        for lhs, op, rhs in product(self.lhses, self.cmp_ops, self.rhses):
+            self.check_compound_invert_op(lhs, op, rhs)
+
+    @skip_incompatible_operand
+    def check_complex_cmp_op(self, lhs, cmp1, rhs, binop, cmp2):
         ex = '(lhs {cmp1} rhs) {binop} (lhs {cmp2} rhs)'.format(cmp1=cmp1,
                                                                 binop=binop,
                                                                 cmp2=cmp2)
-        if _series_and_2d_ndarray(lhs, rhs):
-            self.assertRaises(Exception, _eval_from_expr, lhs, cmp1, rhs,
-                              binop, cmp2)
-            self.assertRaises(Exception, pd.eval, ex, engine=self.engine)
-        else:
-            expected = _eval_from_expr(lhs, cmp1, rhs, binop, cmp2)
-            result = pd.eval(ex, engine=self.engine)
-            assert_array_equal(result, expected)
+        lhs_new = _eval_single_bin(lhs, cmp1, rhs, self.engine)
+        rhs_new = _eval_single_bin(lhs, cmp2, rhs, self.engine)
+        expected = _eval_single_bin(lhs_new, binop, rhs_new, self.engine)
+        result = pd.eval(ex, engine=self.engine)
+        assert_array_equal(result, expected)
 
-    def _create_simple_cmp_op_t(self, lhs, rhs, cmp1):
+    @skip_incompatible_operand
+    def check_simple_cmp_op(self, lhs, cmp1, rhs):
         ex = 'lhs {0} rhs'.format(cmp1)
+        expected = _eval_single_bin(lhs, cmp1, rhs, self.engine)
+        result = pd.eval(ex, engine=self.engine)
+        assert_array_equal(result, expected)
 
-        if are_compatible_types(cmp1, lhs, rhs):
-            expected = _eval_single_bin(lhs, cmp1, rhs,
-                                        engine_has_neg_frac(self.engine))
-            result = pd.eval(ex, engine=self.engine)
-            assert_array_equal(result, expected)
+    @skip_incompatible_operand
+    def check_binary_arith_op(self, lhs, arith1, rhs):
+        ex = 'lhs {0} rhs'.format(arith1)
+        result = pd.eval(ex, engine=self.engine)
+        expected = _eval_single_bin(lhs, arith1, rhs, self.engine)
+        assert_array_equal(result, expected)
+        ex = 'lhs {0} rhs {0} rhs'.format(arith1)
+        result = pd.eval(ex, engine=self.engine)
+        nlhs = _eval_single_bin(lhs, arith1, rhs,
+                                self.engine)
+        self.check_alignment(result, nlhs, rhs, arith1)
+
+    def check_alignment(self, result, nlhs, ghs, op):
+        try:
+            nlhs, ghs = nlhs.align(ghs)
+        except (ValueError, TypeError, AttributeError):
+            # ValueError: series frame or frame series align
+            # TypeError, AttributeError: series or frame with scalar align
+            pass
         else:
-            assert_raises(TypeError, _eval_single_bin, lhs, cmp1, rhs,
-                          engine_has_neg_frac(self.engine))
+            expected = self.ne.evaluate('nlhs {0} ghs'.format(op))
+            assert_array_equal(result, expected)
 
-    def _create_arith_op_t(self, lhs, arith1, rhs):
+    # the following 3 tests require special casing
+
+    @skip_incompatible_operand
+    def check_modulus(self, lhs, arith1, rhs):
         ex = 'lhs {0} rhs'.format(arith1)
-        nan_frac_neg = (arith1 == '**' and np.any(lhs < 0) and
-                        hasfractional(rhs) and np.isscalar(lhs) and
-                        np.isscalar(rhs) and
-                        not (isinstance(lhs, tuple(np.typeDict.values()))
-                             or isinstance(rhs, tuple(np.typeDict.values()))))
-        if nan_frac_neg and not engine_has_neg_frac(self.engine):
-                assert_raises(ValueError, pd.eval, ex, engine=self.engine,
-                              local_dict=locals(), global_dict=globals())
-        else:
-            result = pd.eval(ex, engine=self.engine)
-
-            if arith1 != '//':
-                expected = _eval_single_bin(lhs, arith1, rhs,
-                                            engine_has_neg_frac(self.engine))
-                # roundoff error with modulus
-                if arith1 == '%':
-                    assert_allclose(result, expected)
-                else:
-                    assert_array_equal(result, expected)
+        result = pd.eval(ex, engine=self.engine)
+        expected = lhs % rhs
+        assert_allclose(result, expected)
+        expected = self.ne.evaluate('expected {0} rhs'.format(arith1))
+        assert_allclose(result, expected)
 
-            # sanity check on recursive parsing
-            try:
-                ghs = rhs.copy()
-            except AttributeError:
-                ghs = rhs
+    @skip_incompatible_operand
+    def check_floor_division(self, lhs, arith1, rhs):
+        ex = 'lhs {0} rhs'.format(arith1)
 
-        if nan_frac_neg and not engine_has_neg_frac(self.engine):
-            assert_raises(ValueError, pd.eval, ex, engine=self.engine,
-                          local_dict=locals(), global_dict=globals())
+        if self.engine == 'python':
+            res = pd.eval(ex, engine=self.engine)
+            expected = lhs // rhs
+            assert_array_equal(res, expected)
         else:
-            if arith1 == '**':
-                ex = '(lhs {0} rhs) {0} ghs'.format(arith1)
-            else:
-                ex = 'lhs {0} rhs {0} ghs'.format(arith1)
-            result = pd.eval(ex, engine=self.engine)
+            self.assertRaises(TypeError, pd.eval, ex, local_dict={'lhs': lhs,
+                                                                  'rhs': rhs},
+                              engine=self.engine)
 
-            try:
-                nlhs = _eval_single_bin(lhs, arith1, rhs,
-                                        engine_has_neg_frac(self.engine))
-            except ValueError:
-                assert_raises(ValueError, _eval_single_bin, lhs, arith1, rhs,
-                              engine_has_neg_frac(self.engine))
+    def get_expected_pow_result(self, lhs, rhs):
+        try:
+            expected = _eval_single_bin(lhs, '**', rhs, self.engine)
+        except ValueError as e:
+            msg = 'negative number cannot be raised to a fractional power'
+            if e.message == msg:
+                if self.engine == 'python':
+                    raise nose.SkipTest(e.message)
+                else:
+                    expected = np.nan
+            # raise on other, possibly valid ValueErrors
             else:
-                try:
-                    nlhs, ghs = nlhs.align(ghs)
-                except:
-                    pass
-                if arith1 != '//':
-                    expected = self.ne.evaluate('nlhs {0} ghs'.format(arith1))
-
-                    # roundoff error with modulus
-                    if arith1 == '%':
-                        assert_allclose(result, expected)
-                    else:
-                        assert_array_equal(result, expected)
-
-    def _create_invert_op_t(self, lhs, cmp1, rhs):
+                raise
+        return expected
+
+    @skip_incompatible_operand
+    def check_pow(self, lhs, arith1, rhs):
+        ex = 'lhs {0} rhs'.format(arith1)
+        expected = self.get_expected_pow_result(lhs, rhs)
+        result = pd.eval(ex, engine=self.engine)
+        assert_array_equal(result, expected)
+
+        ex = '(lhs {0} rhs) {0} rhs'.format(arith1)
+        result = pd.eval(ex, engine=self.engine)
+        expected = self.get_expected_pow_result(
+            self.get_expected_pow_result(lhs, rhs), rhs)
+        assert_array_equal(result, expected)
+
+    @skip_incompatible_operand
+    def check_single_invert_op(self, lhs, cmp1, rhs):
         # simple
         for el in (lhs, rhs):
             try:
@@ -273,33 +274,33 @@ class TestBasicEval(unittest.TestCase):
             for engine in self.current_engines:
                 assert_array_equal(result, pd.eval('~elb', engine=engine))
 
+    @skip_incompatible_operand
+    def check_compound_invert_op(self, lhs, cmp1, rhs):
         # compound
         ex = '~(lhs {0} rhs)'.format(cmp1)
         if np.isscalar(lhs) and np.isscalar(rhs):
             lhs, rhs = map(lambda x: np.array([x]), (lhs, rhs))
-        expected = ~_eval_single_bin(lhs, cmp1, rhs,
-                                     engine_has_neg_frac(self.engine))
+        expected = ~_eval_single_bin(lhs, cmp1, rhs, self.engine)
         result = pd.eval(ex, engine=self.engine)
         assert_array_equal(expected, result)
 
-        # make sure the other engines work
+        # make sure the other engines work the same as this one
         for engine in self.current_engines:
             ev = pd.eval(ex, engine=self.engine)
             assert_array_equal(ev, result)
 
-    def _create_unary_arith_op_t(self, unary_op, lhs, arith1, rhs):
+    @skip_incompatible_operand
+    def check_unary_arith_op(self, lhs, arith1, rhs, unary_op):
         # simple
         ex = '{0}lhs'.format(unary_op, arith1)
         f = _unary_ops_dict[unary_op]
-        bad_types = tuple(np.typeDict.values())
-
-        nan_frac_neg = (arith1 == '**' and
-                        np.any(lhs < 0) and
-                        hasfractional(rhs) and
-                        np.isscalar(lhs) and np.isscalar(rhs) and
-                        not (isinstance(lhs, bad_types) or
-                             isinstance(rhs, bad_types))
-                        and not engine_has_neg_frac(self.engine))
+        bad_types = np.floating, float, numbers.Real
+
+        if isinstance(lhs, bad_types):
+            raise nose.SkipTest("Incompatiable type for ~ operator")
+        if isinstance(rhs, bad_types):
+            raise nose.SkipTest("Incompatiable type for ~ operator")
+
         try:
             expected = f(lhs.values)
         except AttributeError:
@@ -311,40 +312,23 @@ class TestBasicEval(unittest.TestCase):
             assert_array_equal(result, pd.eval(ex, engine=engine))
 
         ex = '{0}(lhs {1} rhs)'.format(unary_op, arith1)
+        result = pd.eval(ex, engine=self.engine)
 
-        if nan_frac_neg:
-            assert_raises(ValueError, pd.eval, ex, engine=self.engine,
-                          local_dict=locals(), global_dict=globals())
-        else:
-            # compound
-            result = pd.eval(ex, engine=self.engine)
 
-            #(lhs, rhs), _ = _align((lhs, rhs))
-            #if arith1 != '//':
-                #expected = self.ne.evaluate(ex)
-                #assert_array_equal(result, expected)
-            #else:
-                #assert_raises(TypeError, self.ne.evaluate, ex)
+class TestEvalPython(TestEvalPandas):
 
-            #for engine in self.current_engines:
-                #if arith1 != '//':
-                    #if engine_has_neg_frac(engine):
-                        #assert_array_equal(result, pd.eval(ex, engine=engine))
-                #else:
-                    #assert_raises(TypeError, pd.eval, ex, engine=engine,
-                                  #local_dict=locals(), global_dict=globals())
+    def set_current_engine(self):
+        self.engine = 'python'
 
 
-class TestBasicEvalPython(TestBasicEval):
+class TestEvalPandasWithMixedTypeOperands(TestEvalPandas):
+    def setup_data(self):
+        super(TestEvalPandasWithMixedTypeOperands, self).setup_data()
+        self.lhses += randn(10, 5), randn(5)
+        self.rhses += randn(10, 5), randn(5)
 
-    @classmethod
-    def setUpClass(cls):
-        cls.cmp_ops = expr._cmp_ops_syms
-        cls.cmp2_ops = cls.cmp_ops[::-1]
-        cls.bin_ops = expr._bool_ops_syms
-        cls.arith_ops = expr._arith_ops_syms
-        cls.unary_ops = '+', '-'
 
+class TestEvalPythonWithMixedTypeOperands(TestEvalPandasWithMixedTypeOperands):
     def set_current_engine(self):
         self.engine = 'python'
 
@@ -373,7 +357,7 @@ def check_align_nested_unary_op(engine):
     skip_numexpr_engine(engine)
     s = 'df * ~2'
     df = mkdf(10, 10, data_gen_f=f)
-    res = pd.eval(s, engine)
+    res = pd.eval(s, engine=engine)
     assert_frame_equal(res, df * ~2)
 
 
@@ -450,7 +434,6 @@ def check_basic_series_frame_alignment(engine, r_idx_type, c_idx_type,
         assert_frame_equal(res, expected)
 
 
-@slow
 def check_basic_series_frame_alignment_datetime(engine, r_idx_type, c_idx_type,
                                                 index_name):
     skip_numexpr_engine(engine)
@@ -502,6 +485,7 @@ def test_series_frame_commutativity():
                                          index_name)
 
 
+@slow
 def test_basic_frame_series_alignment():
     args = product(_engines, INDEX_TYPES, INDEX_TYPES, ('index', 'columns'))
     for engine, r_idx_type, c_idx_type, index_name in args:
@@ -518,6 +502,7 @@ def test_basic_series_frame_alignment_datetime():
                                                     c_idx_type, index_name)
 
 
+@slow
 def test_basic_series_frame_alignment():
     args = product(_engines, INDEX_TYPES, INDEX_TYPES, ('index', 'columns'))
     for engine, r_idx_type, c_idx_type, index_name in args:
@@ -647,13 +632,13 @@ def test_or_fails():
         check_or_fails(engine)
 
 
-_visitors = {'numexpr': NumExprVisitor, 'python': PythonExprVisitor,
-             'pytables': pytables.ExprVisitor}
+_parsers = {'python': PythonExprVisitor, 'pytables': pytables.ExprVisitor,
+             'pandas': PandasExprVisitor}
 
 
-def check_disallowed_nodes(engine):
+def check_disallowed_nodes(visitor):
     """make sure the disallowed decorator works"""
-    VisitorClass = _visitors[engine]
+    VisitorClass = _parsers[visitor]
     uns_ops = VisitorClass.unsupported_nodes
     inst = VisitorClass('x + 1')
     for ops in uns_ops:
@@ -661,30 +646,57 @@ def check_disallowed_nodes(engine):
 
 
 def test_disallowed_nodes():
-    for engine in ('pytables', 'numexpr', 'python'):
-        check_disallowed_nodes(engine)
+    for visitor in _parsers:
+        check_disallowed_nodes(visitor)
 
 
-def check_simple_ops(engine):
-    ops = '+', '*', '/', '-', '%', '**'
+def check_simple_arith_ops(engine):
+    ops = expr._arith_ops_syms + expr._cmp_ops_syms
 
-    for op in ops:
-        expec = _eval_single_bin(1, op, 1, engine_has_neg_frac(engine))
+    for op in filter(lambda x: x != '//', ops):
+        expec = _eval_single_bin(1, op, 1, engine)
         x = pd.eval('1 {0} 1'.format(op), engine=engine)
         assert_equal(x, expec)
 
-        expec = _eval_single_bin(x, op, 1, engine_has_neg_frac(engine))
+        expec = _eval_single_bin(x, op, 1, engine)
         y = pd.eval('x {0} 1'.format(op), engine=engine)
         assert_equal(y, expec)
 
-        expec = _eval_single_bin(1, op, x + 1, engine_has_neg_frac(engine))
+        expec = _eval_single_bin(1, op, x + 1, engine)
         y = pd.eval('1 {0} (x + 1)'.format(op), engine=engine)
         assert_equal(y, expec)
 
 
-def test_simple_ops():
+def check_simple_bool_ops(engine):
+    for op, lhs, rhs in product(expr._bool_ops_syms, (True, False), (True,
+                                                                     False)):
+        expec = _eval_single_bin(lhs, op, rhs, engine)
+        x = pd.eval('lhs {0} rhs'.format(op), engine=engine)
+        assert_equal(x, expec)
+
+
+def check_bool_ops_with_constants(engine):
+    asteval = ast.literal_eval
+    for op, lhs, rhs in product(expr._bool_ops_syms, ('True', 'False'),
+                                ('True', 'False')):
+        expec = _eval_single_bin(asteval(lhs), op, asteval(rhs), engine)
+        x = pd.eval('{0} {1} {2}'.format(lhs, op, rhs), engine=engine)
+        assert_equal(x, expec)
+
+
+def test_simple_arith_ops():
+    for engine in _engines:
+        check_simple_arith_ops(engine)
+
+
+def test_simple_bool_ops():
     for engine in _engines:
-        check_simple_ops(engine)
+        check_simple_bool_ops(engine)
+
+
+def test_bool_ops_with_constants():
+    for engine in _engines:
+        check_bool_ops_with_constants(engine)
 
 
 def check_no_new_locals(engine):
@@ -727,6 +739,52 @@ def test_panel_fails():
         check_panel_fails(engine)
 
 
+def check_4d_ndarray_fails(engine):
+    x = randn(3, 4, 5, 6)
+    y = Series(randn(10))
+    assert_raises(NotImplementedError, pd.eval, 'x + y', local_dict={'x': x,
+                                                                     'y': y},
+                  engine=engine)
+
+
+def test_4d_ndarray_fails():
+    for engine in _engines:
+        check_4d_ndarray_fails(engine)
+
+
+def check_constant(engine):
+    x = pd.eval('1', engine=engine)
+    assert_equal(x, 1)
+
+
+def test_constant():
+    for engine in _engines:
+        check_constant(engine)
+
+
+def check_single_variable(engine):
+    df = DataFrame(randn(10, 2))
+    df2 = pd.eval('df', engine=engine)
+    assert_frame_equal(df, df2)
+
+
+def test_single_variable():
+    for engine in _engines:
+        check_single_variable(engine)
+
+
+def test_invalid_engine():
+    assertRaisesRegexp(KeyError, 'Invalid engine \'asdf\' passed',
+                       pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
+                       engine='asdf')
+
+
+def test_invalid_parser():
+    assertRaisesRegexp(KeyError, 'Invalid parser \'asdf\' passed',
+                       pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
+                       parser='asdf')
+
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 59145cd54..3f4b283f5 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -38,6 +38,7 @@ from pandas.core.series import Series, _radd_compat
 from pandas.sparse.array import SparseArray
 import pandas.computation.expressions as expressions
 from pandas.computation.eval import eval as _eval
+from pandas.computation.expr import maybe_expression
 from pandas.compat.scipy import scoreatpercentile as _quantile
 from pandas.compat import(range, zip, lrange, lmap, lzip, StringIO, u,
                           OrderedDict, raise_with_traceback)
@@ -1832,7 +1833,12 @@ class DataFrame(NDFrame):
         elif is_mi_columns:
             return self._getitem_multilevel(key)
         else:
-            return self._getitem_column(key)
+            try:
+                return self._getitem_column(key)
+            except KeyError:
+                if maybe_expression(key):
+                    return self.query(key)
+                raise
 
     def _getitem_column(self, key):
         """ return the actual column """
@@ -1899,6 +1905,89 @@ class DataFrame(NDFrame):
         return self.where(key)
 
     def query(self, expr, **kwargs):
+        """Query the columns of a frame with an expression.
+
+        Parameters
+        ----------
+        expr : string
+            The query string to evaluate. The result of the evaluation of this
+            expression is passed to
+            :meth:`~pandas.core.frame.DataFrame.__getitem__`.
+        kwargs : dict
+            See the documentation for :func:`~pandas.computation.eval.eval` for
+            complete details on the keyword arguments accepted by
+            :meth:`~pandas.core.frame.DataFrame.query`.
+
+        Returns
+        -------
+        q : DataFrame or Series
+
+        Notes
+        -----
+        This method uses the top-level :func:`~pandas.computation.eval.eval`
+        function to evaluate the passed query.
+
+        The :meth:`~pandas.core.frame.DataFrame.query` method uses a slightly
+        modified Python syntax by default. For example, the ``&`` and ``|``
+        (bitwise) operators have the precedence of their boolean cousins,
+        ``and`` and ``or``. This *is* syntactically valid Python, however the
+        semantics are different.
+
+        You can use a syntax that is semantically identical to Python by
+        passing the keyword argument ``parser='numexpr'``.
+
+        The ``index`` of the :class:`~pandas.core.frame.DataFrame` instance is
+        placed in the namespace by default, which allows you to treat the index
+        as a column in the frame. The identifier ``index`` is used for this
+        variable, and you can also use the name of the index to identify it in
+        a query.
+
+        Raises
+        ------
+        NameError
+          * if not all identifiers in the query can be found
+        SyntaxError
+          * if a syntactically *invalid* Python expression is passed
+
+        Examples
+        --------
+        Get the value of the frame where column ``b`` has values between the
+        values of columns ``a`` and ``c``.
+
+            >>> from pandas import DataFrame
+            >>> from numpy.random import randn
+            >>> df = DataFrame(randn(100, 3), columns=list('abc'))
+            >>> result = df.query('a < b & b < c')
+
+        Do the same thing but fallback on a named index if there is no column
+        with the name ``a``.
+
+            >>> from pandas import DataFrame, Index
+            >>> from numpy.random import randn
+            >>> n = 10
+            >>> index = Index(randn(n), name='a')
+            >>> df = DataFrame(randn(n, 2), index=index, columns=list('bc'))
+            >>> result = df.query('a < b & b < c')
+
+        A use case for :meth:`~pandas.core.frame.DataFrame.query` is when you
+        have a collection of :class:`~pandas.core.frame.DataFrame` s that have
+        a subset of column names in common. You can pass the same query to both
+        frames *without* having to specify which frame you're interested in
+        querying
+
+            >>> from pandas import DataFrame, Index
+            >>> from numpy.random import randn
+            >>> n = 100
+            >>> index = Index(randn(n), name='a')
+            >>> df = DataFrame(randn(n, 2), index=index, columns=list('bc'))
+            >>> df2 = DataFrame(randn(n + 10, 3))
+            >>> expr = 'a < b & b < c'
+            >>> results = map(lambda frame: frame.query(expr), [df, df2])
+
+        See Also
+        --------
+        pandas.computation.eval.eval
+        """
         resolvers = kwargs.get('resolvers', None)
         if resolvers is None:
             index_resolvers = {}
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 66a71d720..d53d966c6 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -45,6 +45,8 @@ from pandas.util.testing import (assert_almost_equal,
 from pandas.core.indexing import IndexingError
 from pandas.core.common import PandasError
 from pandas.util.compat import OrderedDict
+from pandas.computation.expr import Expr
+import pandas.computation as comp
 
 import pandas.util.testing as tm
 import pandas.lib as lib
@@ -8095,43 +8097,106 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expec = DataFrame([[nan, 2]])
         assert_frame_equal(res, expec)
 
-    def test_query(self):
+    def test_query_expressions(self):
         try:
             import numexpr as ne
         except ImportError:
-            raise nose.SkipTest
-        # comparison
+            raise nose.SkipTest("cannot query engine numexpr when numexpr not installed")
         df = DataFrame(np.random.randn(10, 3), columns=['a', 'b', 'c'])
-        assert_frame_equal(df.query('a < b'), df[df.a < df.b])
+        assert_frame_equal(df['a < b'], df[df.a < df.b])
+        assert_frame_equal(df['a + b > b * c'],
+                           df[df.a + df.b > df.b * df.c])
+
+    def test_query_expressions_with_index(self):
+        try:
+            import numexpr as ne
+        except ImportError:
+            raise nose.SkipTest("cannot query engine numexpr when numexpr not installed")
+        df = DataFrame(np.random.randint(10, size=(10, 3)),
+                       index=Index(range(10), name='blob'),
+                       columns=['a', 'b', 'c'])
+        assert_frame_equal(df['index < b'], df[df.index < df.b])
+        assert_frame_equal(df['index < 5'], df[df.index < 5])
+        assert_frame_equal(df['(blob < 5) & (a < b)'],
+                           df[(df.index < 5) & (df.a < df.b)])
+        assert_frame_equal(df['blob < b'], df[df.index < df.b])
+
+    def test_query(self):
+        import itertools
+        for engine, parser in itertools.product(comp.engines._engines,
+                                                comp.expr._parsers):
+            self.check_query(engine, parser)
+
+    def check_query(self, engine, parser):
+        if engine == 'numexpr':
+            try:
+                import numexpr as ne
+            except ImportError:
+                raise nose.SkipTest("cannot query engine numexpr when numexpr not installed")
 
-        # arith ops
-        assert_frame_equal(df.query('a + b > b * c'),
+        df = DataFrame(np.random.randn(10, 3), columns=['a', 'b', 'c'])
+        assert_frame_equal(df.query('a < b', engine=engine, parser=parser), df[df.a < df.b])
+        assert_frame_equal(df.query('a + b > b * c', engine=engine, parser=parser),
                            df[df.a + df.b > df.b * df.c])
 
         local_dict = dict(df.iteritems())
         local_dict.update({'df': df})
         self.assertRaises(NameError, df.query, 'a < d & b < f',
-                          local_dict=local_dict)
+                          local_dict=local_dict, engine=engine, parser=parser)
 
         # make sure that it's not just because we didn't pass the locals in
         self.assertRaises(AssertionError, self.assertRaises, NameError,
-                          df.query, 'a < b', local_dict=local_dict)
+                          df.query, 'a < b', local_dict=local_dict,
+                          engine=engine, parser=parser)
 
     def test_query_index(self):
-        try:
-            import numexpr as ne
-        except ImportError:
-            raise nose.SkipTest
-
-        df = DataFrame(np.random.randn(10, 3), index=Index(range(10),
-                                                           name='blob'),
+        import itertools
+        for engine, parser in itertools.product(comp.engines._engines,
+                                                comp.expr._parsers):
+            self.check_query_index(engine, parser)
+
+    def check_query_index(self, engine, parser):
+        if engine == 'numexpr':
+            try:
+                import numexpr as ne
+            except ImportError:
+                raise nose.SkipTest("cannot query engine numexpr when numexpr not installed")
+
+        df = DataFrame(np.random.randint(10, size=(10, 3)),
+                       index=Index(range(10), name='blob'),
+                       columns=['a', 'b', 'c'])
+        assert_frame_equal(df.query('index < b', engine=engine, parser=parser),
+                           df[df.index < df.b])
+        assert_frame_equal(df.query('index < 5', engine=engine, parser=parser),
+                           df[df.index < 5])
+        assert_frame_equal(df.query('(blob < 5) & (a < b)', engine=engine,
+                                    parser=parser),
+                           df[(df.index < 5) & (df.a < df.b)])
+        assert_frame_equal(df.query('blob < b', engine=engine, parser=parser),
+                           df[df.index < df.b])
+
+    def test_query_different_parsers(self):
+        for engine in comp.engines._engines:
+            self.check_query_different_parsers(engine)
+
+    def check_query_different_parsers(self, engine):
+        if engine == 'numexpr':
+            try:
+                import numexpr as ne
+            except ImportError:
+                raise nose.SkipTest("cannot query engine numexpr when numexpr not installed")
+        df = DataFrame(np.random.randn(10, 3), columns=['a', 'b', 'c'])
+        assert_frame_equal(df.query('(a < 5) & (a < b)', parser='python',
+                                    engine=engine),
+                           df.query('a < 5 & a < b', parser='pandas',
+                                    engine=engine))
+        df = DataFrame(np.random.randint(10, size=(10, 3)),
+                       index=Index(range(10), name='blob'),
                        columns=['a', 'b', 'c'])
-        assert_frame_equal(df.query('index < b'), df[df.index < df.b])
-        assert_frame_equal(df.query('index < 5'), df[df.index < 5])
-        assert_frame_equal(df.query('(blob < 5) & (a < b)'), df[(df.index < 5)
-                                                                & (df.a <
-                                                                   df.b)])
-        assert_frame_equal(df.query('blob < b'), df[df.index < df.b])
+        assert_frame_equal(df.query('(blob < 5) & (a < b)', parser='python',
+                                    engine=engine),
+                           df.query('blob < 5 & a < b', parser='pandas',
+                                    engine=engine))
 
 
     #----------------------------------------------------------------------
diff --git a/vb_suite/eval.py b/vb_suite/eval.py
new file mode 100644
index 000000000..c0c983862
--- /dev/null
+++ b/vb_suite/eval.py
@@ -0,0 +1,49 @@
+from vbench.benchmark import Benchmark
+from datetime import datetime
+
+setup = """from pandas_vb_common import *
+import pandas as pd
+df  = DataFrame(np.random.randn(20000, 100))
+df2 = DataFrame(np.random.randn(20000, 100))
+df3 = DataFrame(np.random.randn(20000, 100))
+df4 = DataFrame(np.random.randn(20000, 100))
+"""
+
+SECTION = 'Eval'
+
+#----------------------------------------------------------------------
+# binary ops
+
+#----------------------------------------------------------------------
+# add
+
+frame_add_eval = \
+    Benchmark("pd.eval('df + df2 + df3 + df4')", setup, name='frame_add_eval',
+              start_date=datetime(2013, 7, 21))
+
+frame_add_python = \
+    Benchmark("pd.eval('df + df2 + df3 + df4', engine='python')", setup,
+              name='frame_add_python', start_date=datetime(2013, 7, 21))
+
+#----------------------------------------------------------------------
+# mult
+
+frame_mult_eval = \
+    Benchmark("pd.eval('df * df2 * df3 * df4')", setup, name='frame_mult_eval',
+              start_date=datetime(2012, 7, 21))
+
+frame_mult_python = \
+    Benchmark("pdl.eval('df * df2 * df3 * df4', engine='python')", setup,
+              name='frame_mult_python', start_date=datetime(2013, 7, 21))
+
+#----------------------------------------------------------------------
+# multi and
+
+frame_and_eval = \
+    Benchmark("pd.eval('(df > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)')", setup,
+              name='frame_and_eval', start_date=datetime(2012, 7, 21))
+
+frame_and_python = \
+    Benchmark("pd.eval('(df > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)', "
+              "engine='python')", setup, name='frame_and_python',
+              start_date=datetime(2013, 7, 21))
diff --git a/vb_suite/suite.py b/vb_suite/suite.py
index ca83855c2..f3c8dfe30 100644
--- a/vb_suite/suite.py
+++ b/vb_suite/suite.py
@@ -23,7 +23,8 @@ modules = ['attrs_caching',
            'sparse',
            'reshape',
            'stat_ops',
-           'timeseries']
+           'timeseries',
+           'eval']
 
 by_module = {}
 benchmarks = []

commit 7dbdd79ab90fcca0c6b1f5c3bad4cbe553cf4bc4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Sep 28 15:33:24 2011 -0400

    ENH: more templated Cython code coming, renamed module

diff --git a/pandas/core/index.py b/pandas/core/index.py
index ae1fea31c..51d3568bf 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -40,9 +40,12 @@ class Index(np.ndarray):
     ----
     An Index instance can **only** contain hashable objects
     """
-    def __new__(cls, data, dtype=object, copy=False):
+    def __new__(cls, data, dtype=None, copy=False):
         if isinstance(data, np.ndarray):
-            subarr = np.array(data, dtype=dtype, copy=copy)
+            if issubclass(data.dtype.type, np.integer):
+                subarr = data.astype(np.int64)
+                return subarr.view(Int64Index)
+            subarr = np.array(data, dtype=object, copy=copy)
         elif np.isscalar(data):
             raise ValueError('Index(...) must be called with a collection '
                              'of some kind, %s was passed' % repr(data))
@@ -50,7 +53,7 @@ class Index(np.ndarray):
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
                 data = list(data)
-            subarr = np.empty(len(data), dtype=dtype)
+            subarr = np.empty(len(data), dtype=object)
             subarr[:] = data
         return subarr.view(cls)
 
@@ -65,6 +68,10 @@ class Index(np.ndarray):
     def values(self):
         return np.asarray(self)
 
+    @cache_readonly
+    def is_monotonic(self):
+        return lib.is_monotonic(self)
+
     _indexMap = None
     @property
     def indexMap(self):
@@ -343,15 +350,9 @@ class Index(np.ndarray):
         -------
         (indexer, mask) : (ndarray, ndarray)
         """
-        if method:
-            method = method.lower()
-
-        aliases = {
-            'ffill' : 'pad',
-            'bfill' : 'backfill'
-        }
         target = _ensure_index(target)
-        method = aliases.get(method, method)
+
+        method = self._get_method(method)
 
         if method == 'pad':
             indexer = lib.pad(self, target, self.indexMap, target.indexMap)
@@ -363,6 +364,16 @@ class Index(np.ndarray):
             raise ValueError('unrecognized method: %s' % method)
         return indexer
 
+    def _get_method(self, method):
+        if method:
+            method = method.lower()
+
+        aliases = {
+            'ffill' : 'pad',
+            'bfill' : 'backfill'
+        }
+        return aliases.get(method, method)
+
     def reindex(self, target, method=None):
         """
         For Index, simply returns the new index and the results of
@@ -475,7 +486,53 @@ class Index(np.ndarray):
 
 
 class Int64Index(Index):
-    pass
+
+    @cache_readonly
+    def is_monotonic(self):
+        return lib.is_monotonic_int64(self)
+
+    @property
+    def indexMap(self):
+        "{label -> location}"
+        if self._indexMap is None:
+            self._indexMap = lib.map_indices_int64(self)
+            self._verify_integrity()
+
+        return self._indexMap
+
+    def is_all_dates(self):
+        """
+        Checks that all the labels are datetime objects
+        """
+        return False
+
+    def equals(self, other):
+        """
+        Determines if two Index objects contain the same elements.
+        """
+        if self is other:
+            return True
+
+        if not isinstance(other, Int64Index):
+            return False
+
+        return np.array_equal(self, other)
+
+    def get_indexer(self, target, method=None):
+        target = _ensure_index(target)
+
+        method = self._get_method(method)
+
+        if method == 'pad':
+            indexer = lib.pad(self, target, self.indexMap, target.indexMap)
+        elif method == 'backfill':
+            indexer = lib.backfill(self, target, self.indexMap, target.indexMap)
+        elif method is None:
+            indexer = lib.merge_indexer_int64(target, self.indexMap)
+        else:
+            raise ValueError('unrecognized method: %s' % method)
+        return indexer
+    get_indexer.__doc__ = Index.get_indexer__doc__
 
 class DateIndex(Index):
     pass
@@ -892,14 +949,7 @@ class MultiIndex(Index):
         -------
         (indexer, mask) : (ndarray, ndarray)
         """
-        if method:
-            method = method.lower()
-
-        aliases = {
-            'ffill' : 'pad',
-            'bfill' : 'backfill'
-        }
-        method = aliases.get(method, method)
+        method = self._get_method(method)
 
         if isinstance(target, MultiIndex):
             target_index = target.get_tuple_index()
diff --git a/pandas/src/common.pyx b/pandas/src/common.pyx
index 0c514e8b2..7864227e2 100644
--- a/pandas/src/common.pyx
+++ b/pandas/src/common.pyx
@@ -129,6 +129,28 @@ cpdef map_indices_buf(ndarray[object] index):
 
     return result
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_int64(ndarray[int64_t] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
 cpdef map_indices_list(list index):
     '''
     Produce a dict mapping the values of the input array to their respective
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 9d36acda1..bab605a09 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -86,6 +86,26 @@ set_na = "outbuf[i] = NaN"
 set_na_2d = "outbuf[i, j] = NaN"
 raise_on_na = "raise ValueError('No NA values allowed')"
 
+merge_indexer_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_%(name)s(ndarray[%(c_type)s] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef %(c_type)s idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+"""
+
 # name, ctype, capable of holding NA
 function_list = [
     ('float64', 'float64_t', True),
@@ -107,8 +127,9 @@ def generate_from_template(template, ndim=1):
         output.write(func)
     return output.getvalue()
 
-def generate_take_cython_file(path='take.pyx'):
+def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
+        print >> f, generate_from_template(merge_indexer_template)
         print >> f, generate_from_template(take_1d_template)
         print >> f, generate_from_template(take_2d_axis0_template, ndim=2)
         print >> f, generate_from_template(take_2d_axis1_template, ndim=2)
diff --git a/pandas/src/take.pyx b/pandas/src/generated.pyx
similarity index 100%
rename from pandas/src/take.pyx
rename to pandas/src/generated.pyx
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index e6840351b..fa3c17412 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -251,6 +251,25 @@ def merge_indexer(ndarray[object] values, dict oldMap):
 
     return fill_vec
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_int64(ndarray[int64_t] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef int64_t idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    mask = np.zeros(newLength, dtype=np.int8)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
 def ordered_left_join(ndarray[object] left, ndarray[object] right):
     # cdef dict right_map = map_indices_buf(right)
     # return merge_indexer(left, right_map)
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 3a0361a79..a12593a13 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -5,4 +5,4 @@ include "groupby.pyx"
 include "moments.pyx"
 include "reindex.pyx"
 include "io.pyx"
-include "take.pyx"
+include "generated.pyx"
diff --git a/scripts/bench_join.R b/scripts/bench_join.R
index dfbbcea86..1d7db1f9e 100644
--- a/scripts/bench_join.R
+++ b/scripts/bench_join.R
@@ -37,3 +37,13 @@ for (ni in 1:length(ns)){
 
 rownames(result) <- kinds
 colnames(result) <- log10(ns)
+
+mat <- matrix(rnorm(500000), nrow=100000, ncol=5)
+set.seed(12345)
+indexer <- sample(1:100000)
+
+timing <- rep(0, 10)
+for (i in 1:10) {
+  gc()
+  timing[i] = system.time(mat[indexer,])[3]
+}
diff --git a/scripts/groupby_sample.py b/scripts/groupby_sample.py
index b96575165..fc4a54c81 100644
--- a/scripts/groupby_sample.py
+++ b/scripts/groupby_sample.py
@@ -30,4 +30,5 @@ def random_sample_v2():
     from random import choice
     choose = lambda group: choice(group.index)
     indices = [choice(v) for k, v in grouped.groups.iteritems()]
-    return df.reindex(np.asarray(indices))
+    return df.reindex(indices)
+

commit 9130da9ad35ba61bc4fa3ed503a7dd8d8eb1673c
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Mar 27 08:05:00 2020 -0700

    REF: MultiIndex Indexing tests (#33053)

diff --git a/pandas/tests/indexes/multi/test_analytics.py b/pandas/tests/indexes/multi/test_analytics.py
index a9e02934f..cd98a8745 100644
--- a/pandas/tests/indexes/multi/test_analytics.py
+++ b/pandas/tests/indexes/multi/test_analytics.py
@@ -57,23 +57,6 @@ def test_truncate():
         index.truncate(3, 1)
 
 
-def test_where():
-    i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
-
-    msg = r"\.where is not supported for MultiIndex operations"
-    with pytest.raises(NotImplementedError, match=msg):
-        i.where(True)
-
-
-@pytest.mark.parametrize("klass", [list, tuple, np.array, pd.Series])
-def test_where_array_like(klass):
-    i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
-    cond = [False, True]
-    msg = r"\.where is not supported for MultiIndex operations"
-    with pytest.raises(NotImplementedError, match=msg):
-        i.where(klass(cond))
-
-
 # TODO: reshape
 
 
diff --git a/pandas/tests/indexes/multi/test_get_level_values.py b/pandas/tests/indexes/multi/test_get_level_values.py
index 6f0b23c1e..1215e72be 100644
--- a/pandas/tests/indexes/multi/test_get_level_values.py
+++ b/pandas/tests/indexes/multi/test_get_level_values.py
@@ -1,4 +1,8 @@
-from pandas import MultiIndex, Timestamp, date_range
+import numpy as np
+
+import pandas as pd
+from pandas import CategoricalIndex, Index, MultiIndex, Timestamp, date_range
+import pandas._testing as tm
 
 
 class TestGetLevelValues:
@@ -11,3 +15,77 @@ class TestGetLevelValues:
         index = MultiIndex(levels=levels, codes=codes)
 
         assert isinstance(index.get_level_values(0)[0], Timestamp)
+
+
+def test_get_level_values(idx):
+    result = idx.get_level_values(0)
+    expected = Index(["foo", "foo", "bar", "baz", "qux", "qux"], name="first")
+    tm.assert_index_equal(result, expected)
+    assert result.name == "first"
+
+    result = idx.get_level_values("first")
+    expected = idx.get_level_values(0)
+    tm.assert_index_equal(result, expected)
+
+    # GH 10460
+    index = MultiIndex(
+        levels=[CategoricalIndex(["A", "B"]), CategoricalIndex([1, 2, 3])],
+        codes=[np.array([0, 0, 0, 1, 1, 1]), np.array([0, 1, 2, 0, 1, 2])],
+    )
+
+    exp = CategoricalIndex(["A", "A", "A", "B", "B", "B"])
+    tm.assert_index_equal(index.get_level_values(0), exp)
+    exp = CategoricalIndex([1, 2, 3, 1, 2, 3])
+    tm.assert_index_equal(index.get_level_values(1), exp)
+
+
+def test_get_level_values_all_na():
+    # GH#17924 when level entirely consists of nan
+    arrays = [[np.nan, np.nan, np.nan], ["a", np.nan, 1]]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(0)
+    expected = pd.Index([np.nan, np.nan, np.nan], dtype=np.float64)
+    tm.assert_index_equal(result, expected)
+
+    result = index.get_level_values(1)
+    expected = pd.Index(["a", np.nan, 1], dtype=object)
+    tm.assert_index_equal(result, expected)
+
+
+def test_get_level_values_int_with_na():
+    # GH#17924
+    arrays = [["a", "b", "b"], [1, np.nan, 2]]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(1)
+    expected = Index([1, np.nan, 2])
+    tm.assert_index_equal(result, expected)
+
+    arrays = [["a", "b", "b"], [np.nan, np.nan, 2]]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(1)
+    expected = Index([np.nan, np.nan, 2])
+    tm.assert_index_equal(result, expected)
+
+
+def test_get_level_values_na():
+    arrays = [[np.nan, np.nan, np.nan], ["a", np.nan, 1]]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(0)
+    expected = pd.Index([np.nan, np.nan, np.nan])
+    tm.assert_index_equal(result, expected)
+
+    result = index.get_level_values(1)
+    expected = pd.Index(["a", np.nan, 1])
+    tm.assert_index_equal(result, expected)
+
+    arrays = [["a", "b", "b"], pd.DatetimeIndex([0, 1, pd.NaT])]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(1)
+    expected = pd.DatetimeIndex([0, 1, pd.NaT])
+    tm.assert_index_equal(result, expected)
+
+    arrays = [[], []]
+    index = pd.MultiIndex.from_arrays(arrays)
+    result = index.get_level_values(0)
+    expected = pd.Index([], dtype=object)
+    tm.assert_index_equal(result, expected)
diff --git a/pandas/tests/indexes/multi/test_get_set.py b/pandas/tests/indexes/multi/test_get_set.py
index 675a1e2e8..8a3deca02 100644
--- a/pandas/tests/indexes/multi/test_get_set.py
+++ b/pandas/tests/indexes/multi/test_get_set.py
@@ -2,7 +2,7 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import CategoricalIndex, Index, MultiIndex
+from pandas import CategoricalIndex, MultiIndex
 import pandas._testing as tm
 
 
@@ -27,90 +27,6 @@ def test_get_level_number_integer(idx):
         idx._get_level_number("fourth")
 
 
-def test_get_level_values(idx):
-    result = idx.get_level_values(0)
-    expected = Index(["foo", "foo", "bar", "baz", "qux", "qux"], name="first")
-    tm.assert_index_equal(result, expected)
-    assert result.name == "first"
-
-    result = idx.get_level_values("first")
-    expected = idx.get_level_values(0)
-    tm.assert_index_equal(result, expected)
-
-    # GH 10460
-    index = MultiIndex(
-        levels=[CategoricalIndex(["A", "B"]), CategoricalIndex([1, 2, 3])],
-        codes=[np.array([0, 0, 0, 1, 1, 1]), np.array([0, 1, 2, 0, 1, 2])],
-    )
-
-    exp = CategoricalIndex(["A", "A", "A", "B", "B", "B"])
-    tm.assert_index_equal(index.get_level_values(0), exp)
-    exp = CategoricalIndex([1, 2, 3, 1, 2, 3])
-    tm.assert_index_equal(index.get_level_values(1), exp)
-
-
-def test_get_value_duplicates():
-    index = MultiIndex(
-        levels=[["D", "B", "C"], [0, 26, 27, 37, 57, 67, 75, 82]],
-        codes=[[0, 0, 0, 1, 2, 2, 2, 2, 2, 2], [1, 3, 4, 6, 0, 2, 2, 3, 5, 7]],
-        names=["tag", "day"],
-    )
-
-    assert index.get_loc("D") == slice(0, 3)
-
-
-def test_get_level_values_all_na():
-    # GH 17924 when level entirely consists of nan
-    arrays = [[np.nan, np.nan, np.nan], ["a", np.nan, 1]]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(0)
-    expected = pd.Index([np.nan, np.nan, np.nan], dtype=np.float64)
-    tm.assert_index_equal(result, expected)
-
-    result = index.get_level_values(1)
-    expected = pd.Index(["a", np.nan, 1], dtype=object)
-    tm.assert_index_equal(result, expected)
-
-
-def test_get_level_values_int_with_na():
-    # GH 17924
-    arrays = [["a", "b", "b"], [1, np.nan, 2]]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(1)
-    expected = Index([1, np.nan, 2])
-    tm.assert_index_equal(result, expected)
-
-    arrays = [["a", "b", "b"], [np.nan, np.nan, 2]]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(1)
-    expected = Index([np.nan, np.nan, 2])
-    tm.assert_index_equal(result, expected)
-
-
-def test_get_level_values_na():
-    arrays = [[np.nan, np.nan, np.nan], ["a", np.nan, 1]]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(0)
-    expected = pd.Index([np.nan, np.nan, np.nan])
-    tm.assert_index_equal(result, expected)
-
-    result = index.get_level_values(1)
-    expected = pd.Index(["a", np.nan, 1])
-    tm.assert_index_equal(result, expected)
-
-    arrays = [["a", "b", "b"], pd.DatetimeIndex([0, 1, pd.NaT])]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(1)
-    expected = pd.DatetimeIndex([0, 1, pd.NaT])
-    tm.assert_index_equal(result, expected)
-
-    arrays = [[], []]
-    index = pd.MultiIndex.from_arrays(arrays)
-    result = index.get_level_values(0)
-    expected = pd.Index([], dtype=object)
-    tm.assert_index_equal(result, expected)
-
-
 def test_set_name_methods(idx, index_names):
     # so long as these are synonyms, we don't need to test set_names
     assert idx.rename == idx.set_names
diff --git a/pandas/tests/indexes/multi/test_indexing.py b/pandas/tests/indexes/multi/test_indexing.py
index b7d7b3b45..3b3ae074c 100644
--- a/pandas/tests/indexes/multi/test_indexing.py
+++ b/pandas/tests/indexes/multi/test_indexing.py
@@ -441,6 +441,65 @@ class TestGetLoc:
         expected = slice(2, 4, None)
         assert idx.get_loc((np.nan, 1)) == expected
 
+    def test_get_loc_duplicates2(self):
+        # TODO: de-duplicate with test_get_loc_duplicates above?
+        index = MultiIndex(
+            levels=[["D", "B", "C"], [0, 26, 27, 37, 57, 67, 75, 82]],
+            codes=[[0, 0, 0, 1, 2, 2, 2, 2, 2, 2], [1, 3, 4, 6, 0, 2, 2, 3, 5, 7]],
+            names=["tag", "day"],
+        )
+
+        assert index.get_loc("D") == slice(0, 3)
+
+
+class TestWhere:
+    def test_where(self):
+        i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
+
+        msg = r"\.where is not supported for MultiIndex operations"
+        with pytest.raises(NotImplementedError, match=msg):
+            i.where(True)
+
+    @pytest.mark.parametrize("klass", [list, tuple, np.array, pd.Series])
+    def test_where_array_like(self, klass):
+        i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
+        cond = [False, True]
+        msg = r"\.where is not supported for MultiIndex operations"
+        with pytest.raises(NotImplementedError, match=msg):
+            i.where(klass(cond))
+
+
+class TestContains:
+    def test_contains_top_level(self):
+        midx = MultiIndex.from_product([["A", "B"], [1, 2]])
+        assert "A" in midx
+        assert "A" not in midx._engine
+
+    def test_contains_with_nat(self):
+        # MI with a NaT
+        mi = MultiIndex(
+            levels=[["C"], pd.date_range("2012-01-01", periods=5)],
+            codes=[[0, 0, 0, 0, 0, 0], [-1, 0, 1, 2, 3, 4]],
+            names=[None, "B"],
+        )
+        assert ("C", pd.Timestamp("2012-01-01")) in mi
+        for val in mi.values:
+            assert val in mi
+
+    def test_contains(self, idx):
+        assert ("foo", "two") in idx
+        assert ("bar", "two") not in idx
+        assert None not in idx
+
+    def test_contains_with_missing_value(self):
+        # GH#19132
+        idx = MultiIndex.from_arrays([[1, np.nan, 2]])
+        assert np.nan in idx
+
+        idx = MultiIndex.from_arrays([[1, 2], [np.nan, 3]])
+        assert np.nan not in idx
+        assert (1, np.nan) in idx
+
 
 def test_timestamp_multiindex_indexer():
     # https://github.com/pandas-dev/pandas/issues/26944
diff --git a/pandas/tests/indexes/multi/test_contains.py b/pandas/tests/indexes/multi/test_isin.py
similarity index 78%
rename from pandas/tests/indexes/multi/test_contains.py
rename to pandas/tests/indexes/multi/test_isin.py
index 49aa63210..122263e6e 100644
--- a/pandas/tests/indexes/multi/test_contains.py
+++ b/pandas/tests/indexes/multi/test_isin.py
@@ -3,35 +3,10 @@ import pytest
 
 from pandas.compat import PYPY
 
-import pandas as pd
 from pandas import MultiIndex
 import pandas._testing as tm
 
 
-def test_contains_top_level():
-    midx = MultiIndex.from_product([["A", "B"], [1, 2]])
-    assert "A" in midx
-    assert "A" not in midx._engine
-
-
-def test_contains_with_nat():
-    # MI with a NaT
-    mi = MultiIndex(
-        levels=[["C"], pd.date_range("2012-01-01", periods=5)],
-        codes=[[0, 0, 0, 0, 0, 0], [-1, 0, 1, 2, 3, 4]],
-        names=[None, "B"],
-    )
-    assert ("C", pd.Timestamp("2012-01-01")) in mi
-    for val in mi.values:
-        assert val in mi
-
-
-def test_contains(idx):
-    assert ("foo", "two") in idx
-    assert ("bar", "two") not in idx
-    assert None not in idx
-
-
 @pytest.mark.skipif(not PYPY, reason="tuples cmp recursively on PyPy")
 def test_isin_nan_pypy():
     idx = MultiIndex.from_arrays([["foo", "bar"], [1.0, np.nan]])
@@ -100,16 +75,6 @@ def test_isin_level_kwarg():
         idx.isin(vals_1, level="C")
 
 
-def test_contains_with_missing_value():
-    # issue 19132
-    idx = MultiIndex.from_arrays([[1, np.nan, 2]])
-    assert np.nan in idx
-
-    idx = MultiIndex.from_arrays([[1, 2], [np.nan, 3]])
-    assert np.nan not in idx
-    assert (1, np.nan) in idx
-
-
 @pytest.mark.parametrize(
     "labels,expected,level",
     [

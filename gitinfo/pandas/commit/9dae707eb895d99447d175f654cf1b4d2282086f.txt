commit 9dae707eb895d99447d175f654cf1b4d2282086f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jun 12 22:42:07 2011 -0400

    hammering out block internals issues

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 7d2a841b6..748f4c458 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -97,12 +97,8 @@ class DataFrame(PandasGeneric):
         Required if data is ndarray
     dtype : dtype, default None (infer)
         Data type to force
-
-    Notes
-    -----
-    Data contained within is COPIED from input arrays, this is to prevent silly
-    behavior like altering the original arrays and having those changes
-    reflected in the frame.
+    copy : boolean, default True
+        Copy data from input arrays
 
     Examples
     --------
@@ -118,26 +114,37 @@ class DataFrame(PandasGeneric):
 
     _AXIS_NAMES = dict((v, k) for k, v in _AXIS_NUMBERS.iteritems())
 
-    def __init__(self, data=None, index=None, columns=None, dtype=None):
+    def __init__(self, data=None, index=None, columns=None, dtype=None,
+                 copy=True):
+
         if data is None:
             data = {}
 
         if isinstance(data, BlockManager):
             mgr = data
+            if copy and dtype is None:
+                mgr = mgr.copy()
+            elif dtype is not None:
+                # no choice but to copy
+                mgr = mgr.cast(dtype)
         elif isinstance(data, DataFrame):
-            mgr = data._data.copy()
-            if dtype is not None:
+            mgr = data._data
+            if copy and dtype is None:
+                mgr = mgr.copy()
+            elif dtype is not None:
+                # no choice but to copy
                 mgr = mgr.cast(dtype)
         elif isinstance(data, dict):
-            mgr = self._init_dict(data, index, columns, dtype)
+            mgr = self._init_dict(data, index, columns, dtype=dtype)
         elif isinstance(data, (np.ndarray, list)):
-            mgr = self._init_matrix(data, index, columns, dtype)
+            mgr = self._init_matrix(data, index, columns, dtype=dtype,
+                                    copy=copy)
         else:
             raise Exception('DataFrame constructor not properly called!')
 
         self._data = mgr
 
-    def _init_dict(self, data, index, columns, dtype=None):
+    def _init_dict(self, data, index, columns, dtype=None, copy=True):
         """
         Segregate Series based on type and coerce into matrices.
 
@@ -165,7 +172,8 @@ class DataFrame(PandasGeneric):
         # TODO: need consolidate here?
         return BlockManager(blocks, index, columns).consolidate()
 
-    def _init_matrix(self, values, index, columns, dtype=None):
+    def _init_matrix(self, values, index, columns, dtype=None,
+                     copy=True):
         from pandas.core.internals import make_block
 
         values = _prep_ndarray(values)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 991a5a93f..ce586a861 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -25,8 +25,6 @@ class Block(object):
         self.columns = _ensure_index(columns)
         self.ref_columns = _ensure_index(ref_columns)
 
-        # self.ref_locs = np.asarray(ref_locs, dtype=int)
-
     _ref_locs = None
     @property
     def ref_locs(self):
@@ -83,7 +81,10 @@ class Block(object):
                           self.ref_columns)
 
     def merge(self, other):
-        return _merge_blocks([self, other])
+        union_ref = self.ref_columns
+        if not union_ref.equals(other.ref_columns):
+            union_ref = self.ref_columns + other.ref_columns
+        return _merge_blocks([self, other], union_ref)
 
     def reindex_index(self, indexer, notmask, needs_masking):
         """
@@ -112,20 +113,6 @@ class Block(object):
         new_cols = self.columns.take(masked_idx)
         return make_block(new_values, new_cols, new_columns)
 
-        # indexer, mask = new_columns.get_indexer(self.ref_columns)
-
-        # loc_indexer = indexer.take(self.ref_locs)
-        # loc_indexer = loc_indexer[mask.take(self.ref_locs)]
-
-        # new_values = self.values.take(indexer, axis=1)
-
-        # notmask = -mask
-        # if len(mask) > 0 and notmask.any():
-        #     new_values = _cast_if_bool_int(new_values)
-        #     common.null_out_axis(new_values, notmask, 1)
-
-        # return make_block(new_values, new_columns)
-
     def get(self, col):
         loc = self.columns.get_loc(col)
         return self.values[:, loc]
@@ -148,7 +135,7 @@ class Block(object):
         y : Block (new object)
         """
         loc = self.columns.get_loc(col)
-        new_cols = np.delete(self.columns, loc)
+        new_cols = np.delete(np.asarray(self.columns), loc)
         new_values = np.delete(self.values, loc, 1)
         return make_block(new_values, new_cols, self.ref_columns)
 
@@ -158,30 +145,11 @@ class Block(object):
         new_values.flat[mask] = value
         return make_block(new_values, self.columns, self.ref_columns)
 
-def _insert_into_block(block, ref_columns, col, value, loc=None):
-    """
-    Insert new column into Block, return new Block
-
-    Returns
-    -------
-    y : Block (new object)
-    """
-    assert(col in ref_columns)
-    if loc is None:
-        loc = len(columns)
-
-    new_columns = _insert_into_columns(self.columns, col, loc)
-    new_values = _insert_into_values(self.values, value, loc)
-    return make_block(new_values, new_columns)
-
 def _insert_into_columns(columns, col, loc):
     columns = np.asarray(columns)
     new_columns = np.insert(columns, loc, col)
     return Index(new_columns)
 
-def _insert_into_values(values, new_vec, loc):
-    return np.insert(values, loc, new_vec, 1)
-
 def _cast_if_bool_int(values):
     if issubclass(values.dtype.type, np.int_):
         values = values.astype(float)
@@ -189,14 +157,6 @@ def _cast_if_bool_int(values):
         values = values.astype(object)
     return values
 
-def _delete_from_columns(columns, loc):
-    columns = np.asarray(columns)
-    new_columns = np.delete(columns, loc)
-    return Index(new_columns)
-
-def _delete_from_values(values, loc):
-    return np.delete(values, loc, 1)
-
 def _convert_if_1d(values):
     if values.ndim == 1:
         values = np.atleast_2d(values).T
@@ -207,16 +167,25 @@ def _convert_if_1d(values):
 # Is this even possible?
 
 class FloatBlock(Block):
-    pass
+
+    def can_store(self, value):
+        return issubclass(value.dtype.type, (np.integer, np.floating))
 
 class IntBlock(Block):
-    pass
+
+    def can_store(self, value):
+        return issubclass(value.dtype.type, np.integer)
 
 class BoolBlock(Block):
-    pass
+
+    def can_store(self, value):
+        return issubclass(value.dtype.type, np.bool_)
 
 class ObjectBlock(Block):
-    pass
+
+    def can_store(self, value):
+        return not issubclass(value.dtype.type,
+                              (np.integer, np.floating, np.bool_))
 
 def make_block(values, columns, ref_columns):
     dtype = values.dtype
@@ -390,7 +359,7 @@ class BlockManager(object):
         if self.is_consolidated():
             return self
 
-        new_blocks = _consolidate(self.blocks)
+        new_blocks = _consolidate(self.blocks, self.columns)
         return BlockManager(new_blocks, self.index, self.columns)
 
     def get(self, col):
@@ -413,7 +382,7 @@ class BlockManager(object):
         assert(len(value) == len(self))
         if col in self.columns:
             i, block = self._find_block(col)
-            if _needs_other_dtype(block, value):
+            if not block.can_store(value):
                 # delete from block, create and append new block
                 self._delete_from_block(i, col)
                 self._add_new_block(col, value)
@@ -450,8 +419,6 @@ class BlockManager(object):
             if col in block:
                 return i, block
 
-        raise Exception('technically unreachable code')
-
     def _check_have(self, col):
         if col not in self.columns:
             raise KeyError('no column named %s' % col)
@@ -474,9 +441,16 @@ class BlockManager(object):
     def merge(self, other):
         # TODO
         assert(self.index.equals(other.index))
-        consolidated = _consolidate(self.blocks + other.blocks)
-        cons_columns = _union_block_columns(consolidated)
-        return BlockManager(consolidated, self.index, cons_columns)
+
+        intersection = self.columns.intersection(other.columns)
+        try:
+            assert(len(intersection) == 0)
+        except AssertionError:
+            raise Exception('columns overlap: %s' % intersection)
+
+        cons_cols = self.columns + other.columns
+        consolidated = _consolidate(self.blocks + other.blocks, cons_cols)
+        return BlockManager(consolidated, self.index, cons_cols)
 
     def join_on(self, other, on):
         reindexed = other.reindex_index(on)
@@ -504,7 +478,7 @@ class BlockManager(object):
         if len(extra_columns):
             na_block = add_na_columns(extra_columns, self.index, new_columns)
             new_blocks.append(na_block)
-            new_blocks = _consolidate(new_blocks)
+            new_blocks = _consolidate(new_blocks, new_columns)
 
         return BlockManager(new_blocks, self.index, new_columns)
 
@@ -575,7 +549,7 @@ def form_blocks(data, index, columns):
     if len(extra_columns):
         na_block = add_na_columns(extra_columns, index, columns)
         blocks.append(na_block)
-        blocks = _consolidate(blocks)
+        blocks = _consolidate(blocks, columns)
 
     return blocks, columns
 
@@ -620,15 +594,6 @@ def _slice_blocks(blocks, slice_obj):
         new_blocks.append(newb)
     return new_blocks
 
-# TODO!
-def _needs_other_dtype(block, to_insert):
-    if block.dtype == np.float64:
-        return not issubclass(to_insert.dtype.type, (np.integer, np.floating))
-    elif block.dtype == np.object_:
-        return issubclass(to_insert.dtype.type, (np.integer, np.floating))
-    else:
-        raise Exception('have not handled this case yet')
-
 def _blocks_to_series_dict(blocks, index=None):
     series_dict = {}
 
@@ -666,7 +631,7 @@ def _interleaved_dtype(blocks):
             return object
     return np.float64
 
-def _consolidate(blocks):
+def _consolidate(blocks, columns):
     """
     Merge blocks having same dtype
     """
@@ -678,18 +643,16 @@ def _consolidate(blocks):
 
     new_blocks = []
     for dtype, group_blocks in grouper:
-        new_block = _merge_blocks(list(group_blocks))
+        new_block = _merge_blocks(list(group_blocks), columns)
         new_blocks.append(new_block)
 
     return new_blocks
 
-def _merge_blocks(blocks):
-    ref_cols = blocks[0].ref_columns
-
+def _merge_blocks(blocks, columns):
     new_values = np.hstack([b.values for b in blocks])
     new_cols = np.concatenate([b.columns for b in blocks])
-    new_block = make_block(new_values, new_cols, ref_cols)
-    return new_block
+    new_block = make_block(new_values, new_cols, columns)
+    return new_block.reindex_columns_from(columns)
 
 def _xs(blocks, i, copy=True):
     if copy:
diff --git a/pandas/core/tests/test_internals.py b/pandas/core/tests/test_internals.py
index 3cfbed9ef..fd52eb5a4 100644
--- a/pandas/core/tests/test_internals.py
+++ b/pandas/core/tests/test_internals.py
@@ -7,22 +7,69 @@ from pandas.core.internals import *
 
 from pandas.util.testing import (assert_almost_equal, randn)
 
+def assert_block_equal(left, right):
+    assert_almost_equal(left.values, right.values)
+    assert(left.columns.equals(right.columns))
+    assert(left.ref_columns.equals(right.ref_columns))
+
+def get_float_mat(n, k):
+    return np.repeat(np.atleast_2d(np.arange(k, dtype=float)), n, axis=0)
+
+TEST_COLS = ['a', 'b', 'c', 'd', 'e', 'f']
+N = 10
+
+def get_float_ex():
+    floats = get_float_mat(N, 3)
+    return make_block(floats, ['a', 'c', 'e'], TEST_COLS)
+
+def get_obj_ex():
+    mat = np.empty((N, 2), dtype=object)
+    mat[:, 0] = 'foo'
+    mat[:, 1] = 'bar'
+    return make_block(mat, ['b', 'd'], TEST_COLS)
+
+def get_bool_ex():
+    mat = np.ones((N, 1), dtype=bool)
+    return make_block(mat, ['f'], TEST_COLS)
+
 class TestBlock(unittest.TestCase):
 
     def setUp(self):
-        n = 10
-        floats = np.repeat(np.atleast_2d(np.arange(3.)), n, axis=0)
-        self.fblock = make_block(floats, ['a', 'c', 'e'],
-                                 ['a', 'b', 'c', 'd', 'e'])
+        self.fblock = get_float_ex()
+        self.oblock = get_obj_ex()
+        self.bool_block = get_bool_ex()
+
+    def test_constructor(self):
+        pass
 
     def test_ref_locs(self):
         assert_almost_equal(self.fblock.ref_locs, [0, 2, 4])
 
+    def test_attrs(self):
+        self.assert_(self.fblock.shape == self.fblock.values.shape)
+        self.assert_(self.fblock.dtype == self.fblock.values.dtype)
+
     def test_merge(self):
-        pass
+        avals = randn(10, 2)
+        bvals = randn(10, 2)
+
+        ref_cols = ['e', 'a', 'b', 'd', 'f']
+
+        ablock = make_block(avals, ['e', 'b'], ref_cols)
+        bblock = make_block(bvals, ['a', 'd'], ref_cols)
+        merged = ablock.merge(bblock)
+        exvals = np.hstack((avals, bvals))
+        excols = ['e', 'b', 'a', 'd']
+        eblock = make_block(exvals, excols, ref_cols)
+        eblock = eblock.reindex_columns_from(ref_cols)
+        assert_block_equal(merged, eblock)
+
+        # TODO: merge with mixed type?
 
     def test_copy(self):
-        pass
+        cop = self.fblock.copy()
+        self.assert_(cop is not self.fblock)
+        assert_block_equal(self.fblock, cop)
 
     def test_columns(self):
         cols = self.fblock.columns
@@ -48,6 +95,9 @@ class TestBlock(unittest.TestCase):
         self.assert_((reindexed.values[:, 0] == 2).all())
         self.assert_((reindexed.values[:, 1] == 1).all())
 
+    def test_reindex_cast(self):
+        pass
+
     def test_insert(self):
         pass
 
@@ -81,12 +131,79 @@ class TestBlock(unittest.TestCase):
 
 class TestBlockManager(unittest.TestCase):
 
+    def setUp(self):
+        self.blocks = [get_float_ex(),
+                       get_obj_ex(),
+                       get_bool_ex()]
+        self.mgr = BlockManager.from_blocks(self.blocks, np.arange(N))
+
+    def test_attrs(self):
+        self.assertEquals(self.mgr.nblocks, len(self.mgr.blocks))
+        self.assertEquals(len(self.mgr), len(self.mgr.index))
+
+    def test_contains(self):
+        self.assert_('a' in self.mgr)
+        self.assert_('g' not in self.mgr)
+
+    def test_get(self):
+        pass
+
+    def test_set(self):
+        pass
+
+    def test_set_change_dtype(self):
+        self.mgr.set('g', np.zeros(N, dtype=bool))
+
+        self.mgr.set('g', np.repeat('foo', N))
+        self.assert_(self.mgr.get('g').dtype == np.object_)
+
+        mgr2 = self.mgr.consolidate()
+        mgr2.set('g', np.repeat('foo', N))
+        self.assert_(mgr2.get('g').dtype == np.object_)
+
+    def test_copy(self):
+        pass
+
+    def test_as_matrix(self):
+        pass
+
+    def test_xs(self):
+        pass
+
+    def test_from_blocks(self):
+        self.assert_(np.array_equal(self.mgr.columns, TEST_COLS))
+
     def test_interleave(self):
         pass
 
     def test_consolidate(self):
         pass
 
+    def test_consolidate_ordering_issues(self):
+        self.mgr.set('f', randn(N))
+        self.mgr.set('d', randn(N))
+        self.mgr.set('b', randn(N))
+
+        cons = self.mgr.consolidate()
+        self.assertEquals(cons.nblocks, 1)
+        self.assert_(cons.blocks[0].columns.equals(cons.columns))
+
+    def test_reindex_index(self):
+        pass
+
+    def test_reindex_columns(self):
+        def _check_cols(before, after, cols):
+            for col in cols:
+                assert_almost_equal(after.get(col), before.get(col))
+
+        # not consolidated
+        vals = randn(N)
+        self.mgr.set('g', vals)
+        reindexed = self.mgr.reindex_columns(['g', 'c', 'a', 'd'])
+        self.assertEquals(reindexed.nblocks, 2)
+        assert_almost_equal(reindexed.get('g'), vals)
+        _check_cols(self.mgr, reindexed, ['c', 'a', 'd'])
+
     def test_xs(self):
         pass
 

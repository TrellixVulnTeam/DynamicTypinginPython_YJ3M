commit cbbae3dc24ef93369b9c7dbc81f032ba57db4936
Author: jreback <jeff@reback.net>
Date:   Sun Dec 23 11:34:52 2012 -0500

    ENH: added append_to_multiple, to support multiple table creation

diff --git a/RELEASE.rst b/RELEASE.rst
index 72345a336..c43d242ec 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -40,7 +40,7 @@ pandas 0.10.1
     - support ``start`` and ``stop`` keywords in select to limit the row selection space
     - added ``get_store`` context manager to automatically import with pandas
     - added column filtering via ``columns`` keyword in select
-    - added methods select_as_multiple/select_as_coordinates to do multiple-table selection
+    - added methods append_to_multiple/select_as_multiple/select_as_coordinates to do multiple-table append/selection
 
 **Bug fixes**
 
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 70b65f2e4..e27e4af82 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1257,19 +1257,25 @@ If you want to inspect the table object, retrieve via ``get_table``. You could u
 Multiple Table Queries
 ~~~~~~~~~~~~~~~~~~~~~~
 
-New in 0.10.1 is the method ``select_as_multiple``, that can perform selections from multiple tables and return a combined result, by using ``where`` on a selector table. The purpose is to allow fast selection from really wide tables. Construct 2 (or more) tables, where your indexing criteria is contained in a relatively small table. Then put your data in another table. Queries will be quite fast, yet you can allow your tables to grow (in column space). **THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES**. This means, append to the tables in the same order. You can pass the ``axis`` parameter to control concatenation. Default is on the ``columns`` axis.
+New in 0.10.1 are the methods ``append_to_multple`` and ``select_as_multiple``, that can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables that you are indexed the same the selector table. You can then perform a very fast query on the selector table, yet get lots of data back. This method works similar to having a very wide-table, but is more efficient in terms of queries.
+
+Note, **THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES**. This means, append to the tables in the same order; ``append_to_multiple`` splits a single object to multiple tables, given a specification (as a dictionary). This dictionary is a mapping of the table names to the 'columns' you want included in that table. Pass a `None` for a single table (optional) to let it have the remaining columns. The argument ``selector`` defines which table is the selector table.
 
 .. ipython:: python
 
    index = date_range('1/1/2000', periods=8)
-   df1_mt = DataFrame(randn(8, 3), index=index, columns=['A', 'B', 'C'])
-   df2_mt = DataFrame(randn(8, 3), index=index, columns=['D', 'E', 'F'])
-   df2_mt['foo'] = 'bar'
+   df_mt = DataFrame(randn(8, 6), index=index, columns=['A', 'B', 'C', 'D', 'E', 'F'])
+   df_mt['foo'] = 'bar'
 
-   # you can use data columns as well
-   store.append('df1_mt',df1_mt, data_columns = ['A','B'])
-   store.append('df2_mt',df2_mt)
+   # you can also create the tables individually
+   store.append_to_multiple({ 'df1_mt' : ['A','B'], 'df2_mt' : None }, df_mt, selector = 'df1_mt')
+   store
 
+   # indiviual tables were created
+   store.select('df1_mt')
+   store.select('df2_mt')
+   
+   # as a multiple
    store.select_as_multiple(['df1_mt','df2_mt'], where = [ 'A>0','B>0' ], axis = 1, selector = 'df1_mt')
   
 
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index 6ba326bb4..56d38ee9c 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -72,21 +72,25 @@ You can pass ``columns`` keyword to select to filter a list of the return column
    # the levels are automatically included as data columns
    store.select('mi', Term('foo=bar'))
 
-Multi-table Selection via ``select_multiple`` can perform selections from multiple tables and return a combined result, by using ``where`` on a selector table.
+Multi-table creation via ``append_to_multiple`` and selection via ``select_multiple`` can create/select from multiple tables and return a combined result, by using ``where`` on a selector table.
 
 .. ipython:: python
 
    index = date_range('1/1/2000', periods=8)
-   df1_mt = DataFrame(randn(8, 3), index=index, columns=['A', 'B', 'C'])
-   df2_mt = DataFrame(randn(8, 3), index=index, columns=['D', 'E', 'F'])
-   df2_mt['foo'] = 'bar'
+   df_mt = DataFrame(randn(8, 6), index=index, columns=['A', 'B', 'C', 'D', 'E', 'F'])
+   df_mt['foo'] = 'bar'
 
-   # you can use data columns as well
-   store.append('df1_mt',df1_mt, data_columns = ['A','B'])
-   store.append('df2_mt',df2_mt)
+   # you can also create the tables individually
+   store.append_to_multiple({ 'df1_mt' : ['A','B'], 'df2_mt' : None }, df_mt, selector = 'df1_mt')
+   store
+
+   # indiviual tables were created
+   store.select('df1_mt')
+   store.select('df2_mt')
+   
+   # as a multiple
+   store.select_as_multiple(['df1_mt','df2_mt'], where = [ 'A>0','B>0' ], axis = 1, selector = 'df1_mt')
 
-   store.select_multiple(['df1_mt','df2_mt'], where = [ 'A>0' ], axis = 1, selector = 'df1_mt')
-  
 .. ipython:: python
    :suppress:
 
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index f99bc2452..ad31f0f53 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -79,6 +79,13 @@ _LEGACY_MAP = {
     'WidePanel': 'wide_table',
 }
 
+# axes map
+_AXES_MAP = {
+    DataFrame : [0],
+    Panel     : [1,2],
+    Panel4D   : [1,2,3],
+}
+
 # oh the troubles to reduce import time
 _table_mod = None
 _table_supports_index = False
@@ -387,15 +394,18 @@ class HDFStore(object):
         raise if any of the keys don't refer to tables or if they are not ALL THE SAME DIMENSIONS
         """
 
+        # default to single select
+        if isinstance(keys, (list,tuple)) and len(keys) == 1:
+            keys = keys[0]
+        if isinstance(keys,basestring):
+            return self.select(key = keys, where=where, columns = columns, **kwargs)
+
         if not isinstance(keys, (list,tuple)):
             raise Exception("keys must be a list/tuple")
 
         if len(keys) == 0:
             raise Exception("keys must have a non-zero length")
 
-        if len(keys) == 1:
-            return self.select(key = keys[0], where=where, columns = columns, **kwargs)
-
         if selector is None:
             selector = keys[0]
 
@@ -506,6 +516,63 @@ class HDFStore(object):
 
         self._write_to_group(key, value, table=True, append=True, **kwargs)
 
+    def append_to_multiple(self, d, value, selector, data_columns = None, axes = None, **kwargs):
+        """
+        Append to multiple tables
+
+        Parameters
+        ----------
+        d : a dict of table_name to table_columns, None is acceptable as the values of one node (this will get all the remaining columns)
+        value : a pandas object
+        selector : a string that designates the indexable table; all of its columns will be designed as data_columns, unless data_columns is passed,
+                   in which case these are used
+
+        Notes
+        -----
+        axes parameter is currently not accepted
+
+        """
+        if axes is not None:
+            raise Exception("axes is currently not accepted as a paremter to append_to_multiple; you can create the tables indepdently instead")
+
+        if not isinstance(d, dict):
+            raise Exception("append_to_multiple must have a dictionary specified as the way to split the value")
+            
+        if selector not in d:
+            raise Exception("append_to_multiple requires a selector that is in passed dict")
+
+        # figure out the splitting axis (the non_index_axis)
+        axis = list(set(range(value.ndim))-set(_AXES_MAP[type(value)]))[0]
+
+        # figure out how to split the value
+        remain_key = None
+        remain_values = []
+        for k, v in d.items():
+            if v is None:
+                if remain_key is not None:
+                    raise Exception("append_to_multiple can only have one value in d that is None")
+                remain_key = k
+            else:
+                remain_values.extend(v)
+        if remain_key is not None:
+            ordered = value.axes[axis]
+            ordd = ordered-Index(remain_values)
+            ordd = sorted(ordered.get_indexer(ordd))
+            d[remain_key] = ordered.take(ordd)
+
+        # data_columns
+        if data_columns is None:
+            data_columns = d[selector]
+
+        # append
+        for k, v in d.items():
+            dc = data_columns if k == selector else None
+
+            # compute the val
+            val = value.reindex_axis(v, axis = axis, copy = False)
+
+            self.append(k, val, data_columns = dc, **kwargs)
+
     def create_table_index(self, key, **kwargs):
         """ Create a pytables index on the table
         Paramaters
@@ -725,7 +792,7 @@ class HDFStore(object):
 
     def _write_ndim_table(self, group, obj, append=False, comp=None, axes=None, index=True, **kwargs):
         if axes is None:
-            axes = [1,2,3]
+            axes = _AXES_MAP[type(obj)]
         t = create_table(self, group, typ = 'appendable_ndim')
         t.write(axes=axes, obj=obj,
                 append=append, compression=comp, **kwargs)
@@ -738,7 +805,7 @@ class HDFStore(object):
 
     def _write_frame_table(self, group, df, append=False, comp=None, axes=None, index=True, **kwargs):
         if axes is None:
-            axes = [0]
+            axes = _AXES_MAP[type(df)]
 
         t = create_table(self, group, typ = 'appendable_frame' if df.index.nlevels == 1 else 'appendable_multiframe')
         t.write(axes=axes, obj=df, append=append, compression=comp, **kwargs)
@@ -749,7 +816,7 @@ class HDFStore(object):
 
     def _write_wide_table(self, group, panel, append=False, comp=None, axes=None, index=True, **kwargs):
         if axes is None:
-            axes = [1,2]
+            axes = _AXES_MAP[type(panel)]
         t = create_table(self, group, typ = 'appendable_panel')
         t.write(axes=axes, obj=panel,
                 append=append, compression=comp, **kwargs)
@@ -1755,10 +1822,9 @@ class Table(object):
             obj = obj.reindex_axis(labels,axis=axis,copy=False)
 
         def reindex(obj, axis, filt, ordered):
-            axis_name = obj._get_axis_name(axis)
             ordd = ordered & filt
             ordd = sorted(ordered.get_indexer(ordd))
-            return obj.reindex_axis(ordered.take(ordd), axis = obj._get_axis_number(axis_name), copy = False)
+            return obj.reindex_axis(ordered.take(ordd), axis = obj._get_axis_number(axis), copy = False)
             
         # apply the selection filters (but keep in the same order)
         if self.selection.filter:
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index f8c71a3f2..e62262656 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1409,6 +1409,24 @@ class TestHDFStore(unittest.TestCase):
         expected = expected[(expected.A > 0) & (expected.B > 0)]
         tm.assert_frame_equal(result, expected)
 
+    def test_append_to_multiple(self):
+        df1 = tm.makeTimeDataFrame()
+        df2 = tm.makeTimeDataFrame().rename(columns = lambda x: "%s_2" % x)
+        df2['foo'] = 'bar'
+        df  = concat([ df1, df2 ], axis=1)
+
+        # exceptions
+        self.assertRaises(Exception, self.store.append_to_multiple, { 'df1' : ['A','B'], 'df2' : None }, df, selector = 'df3')
+        self.assertRaises(Exception, self.store.append_to_multiple, { 'df1' : None, 'df2' : None }, df, selector = 'df3')
+        self.assertRaises(Exception, self.store.append_to_multiple, 'df1', df, 'df1')
+
+        # regular operation
+        self.store.append_to_multiple({ 'df1' : ['A','B'], 'df2' : None }, df, selector = 'df1')
+        result = self.store.select_as_multiple(['df1','df2'], where = [ 'A>0','B>0' ], selector = 'df1')
+        expected = df[(df.A > 0) & (df.B > 0)]
+        tm.assert_frame_equal(result, expected)
+
+
     def test_select_as_multiple(self):
         df1 = tm.makeTimeDataFrame()
         df2 = tm.makeTimeDataFrame().rename(columns = lambda x: "%s_2" % x)
@@ -1424,6 +1442,8 @@ class TestHDFStore(unittest.TestCase):
         result = self.store.select('df1', ['A>0','B>0'])
         expected = self.store.select_as_multiple([ 'df1' ], where = [ 'A>0','B>0' ], selector = 'df1')
         tm.assert_frame_equal(result, expected)
+        expected = self.store.select_as_multiple( 'df1' , where = [ 'A>0','B>0' ], selector = 'df1')
+        tm.assert_frame_equal(result, expected)
 
         # multiple
         result = self.store.select_as_multiple(['df1','df2'], where = [ 'A>0','B>0' ], selector = 'df1')

commit b3f54d7567759c4b325473b9e590e417cb9b7f1b
Author: Kaiqi Dong <kaiqi@kth.se>
Date:   Sun May 10 17:45:52 2020 +0200

    TST/REF: Fixturize constant functions in ConsistencyBase (#33943)

diff --git a/pandas/tests/window/common.py b/pandas/tests/window/common.py
index 7a7ab57cd..25989191a 100644
--- a/pandas/tests/window/common.py
+++ b/pandas/tests/window/common.py
@@ -25,40 +25,6 @@ class Base:
 
 
 class ConsistencyBase(Base):
-    base_functions = [
-        (lambda v: Series(v).count(), None, "count"),
-        (lambda v: Series(v).max(), None, "max"),
-        (lambda v: Series(v).min(), None, "min"),
-        (lambda v: Series(v).sum(), None, "sum"),
-        (lambda v: Series(v).mean(), None, "mean"),
-        (lambda v: Series(v).std(), 1, "std"),
-        (lambda v: Series(v).cov(Series(v)), None, "cov"),
-        (lambda v: Series(v).corr(Series(v)), None, "corr"),
-        (lambda v: Series(v).var(), 1, "var"),
-        # restore once GH 8086 is fixed
-        # lambda v: Series(v).skew(), 3, 'skew'),
-        # (lambda v: Series(v).kurt(), 4, 'kurt'),
-        # restore once GH 8084 is fixed
-        # lambda v: Series(v).quantile(0.3), None, 'quantile'),
-        (lambda v: Series(v).median(), None, "median"),
-        (np.nanmax, 1, "max"),
-        (np.nanmin, 1, "min"),
-        (np.nansum, 1, "sum"),
-        (np.nanmean, 1, "mean"),
-        (lambda v: np.nanstd(v, ddof=1), 1, "std"),
-        (lambda v: np.nanvar(v, ddof=1), 1, "var"),
-        (np.nanmedian, 1, "median"),
-    ]
-    no_nan_functions = [
-        (np.max, None, "max"),
-        (np.min, None, "min"),
-        (np.sum, None, "sum"),
-        (np.mean, None, "mean"),
-        (lambda v: np.std(v, ddof=1), 1, "std"),
-        (lambda v: np.var(v, ddof=1), 1, "var"),
-        (np.median, None, "median"),
-    ]
-
     def _create_data(self):
         super()._create_data()
 
diff --git a/pandas/tests/window/moments/conftest.py b/pandas/tests/window/moments/conftest.py
index 2002f4d0b..39e6ae711 100644
--- a/pandas/tests/window/moments/conftest.py
+++ b/pandas/tests/window/moments/conftest.py
@@ -18,3 +18,61 @@ def binary_ew_data():
 @pytest.fixture(params=[0, 1, 2])
 def min_periods(request):
     return request.param
+
+
+base_functions_list = [
+    (lambda v: Series(v).count(), None, "count"),
+    (lambda v: Series(v).max(), None, "max"),
+    (lambda v: Series(v).min(), None, "min"),
+    (lambda v: Series(v).sum(), None, "sum"),
+    (lambda v: Series(v).mean(), None, "mean"),
+    (lambda v: Series(v).std(), 1, "std"),
+    (lambda v: Series(v).cov(Series(v)), None, "cov"),
+    (lambda v: Series(v).corr(Series(v)), None, "corr"),
+    (lambda v: Series(v).var(), 1, "var"),
+    # restore once GH 8086 is fixed
+    # lambda v: Series(v).skew(), 3, 'skew'),
+    # (lambda v: Series(v).kurt(), 4, 'kurt'),
+    # restore once GH 8084 is fixed
+    # lambda v: Series(v).quantile(0.3), None, 'quantile'),
+    (lambda v: Series(v).median(), None, "median"),
+    (np.nanmax, 1, "max"),
+    (np.nanmin, 1, "min"),
+    (np.nansum, 1, "sum"),
+    (np.nanmean, 1, "mean"),
+    (lambda v: np.nanstd(v, ddof=1), 1, "std"),
+    (lambda v: np.nanvar(v, ddof=1), 1, "var"),
+    (np.nanmedian, 1, "median"),
+]
+
+no_nan_functions_list = [
+    (np.max, None, "max"),
+    (np.min, None, "min"),
+    (np.sum, None, "sum"),
+    (np.mean, None, "mean"),
+    (lambda v: np.std(v, ddof=1), 1, "std"),
+    (lambda v: np.var(v, ddof=1), 1, "var"),
+    (np.median, None, "median"),
+]
+
+
+@pytest.fixture(scope="session")
+def base_functions():
+    """Fixture for base functions.
+
+    Returns
+    -------
+    List of tuples: (applied function, require_min_periods, name of applied function)
+    """
+    return base_functions_list
+
+
+@pytest.fixture(scope="session")
+def no_nan_functions():
+    """Fixture for no nan functions.
+
+    Returns
+    -------
+    List of tuples: (applied function, require_min_periods, name of applied function)
+    """
+    return no_nan_functions_list
diff --git a/pandas/tests/window/moments/test_moments_expanding.py b/pandas/tests/window/moments/test_moments_expanding.py
index d20ab5131..6aff5b78b 100644
--- a/pandas/tests/window/moments/test_moments_expanding.py
+++ b/pandas/tests/window/moments/test_moments_expanding.py
@@ -145,50 +145,52 @@ class TestExpandingMomentsConsistency(ConsistencyBase):
             result = func(ser)
             tm.assert_almost_equal(result.iloc[-1], static_comp(ser[:50]))
 
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_apply_consistency(self, consistency_data, min_periods):
-        x, is_constant, no_nans = consistency_data
-        with warnings.catch_warnings():
-            warnings.filterwarnings(
-                "ignore",
-                message=".*(empty slice|0 for slice).*",
-                category=RuntimeWarning,
-            )
-            # test consistency between expanding_xyz() and either (a)
-            # expanding_apply of Series.xyz(), or (b) expanding_apply of
-            # np.nanxyz()
-            functions = self.base_functions
-
-            # GH 8269
-            if no_nans:
-                functions = self.base_functions + self.no_nan_functions
-            for (f, require_min_periods, name) in functions:
-                expanding_f = getattr(x.expanding(min_periods=min_periods), name)
-
-                if (
-                    require_min_periods
-                    and (min_periods is not None)
-                    and (min_periods < require_min_periods)
-                ):
-                    continue
-
-                if name == "count":
-                    expanding_f_result = expanding_f()
-                    expanding_apply_f_result = x.expanding(min_periods=0).apply(
-                        func=f, raw=True
-                    )
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+def test_expanding_apply_consistency(
+    consistency_data, base_functions, no_nan_functions, min_periods
+):
+    x, is_constant, no_nans = consistency_data
+
+    with warnings.catch_warnings():
+        warnings.filterwarnings(
+            "ignore", message=".*(empty slice|0 for slice).*", category=RuntimeWarning,
+        )
+        # test consistency between expanding_xyz() and either (a)
+        # expanding_apply of Series.xyz(), or (b) expanding_apply of
+        # np.nanxyz()
+        functions = base_functions
+
+        # GH 8269
+        if no_nans:
+            functions = base_functions + no_nan_functions
+        for (f, require_min_periods, name) in functions:
+            expanding_f = getattr(x.expanding(min_periods=min_periods), name)
+
+            if (
+                require_min_periods
+                and (min_periods is not None)
+                and (min_periods < require_min_periods)
+            ):
+                continue
+
+            if name == "count":
+                expanding_f_result = expanding_f()
+                expanding_apply_f_result = x.expanding(min_periods=0).apply(
+                    func=f, raw=True
+                )
+            else:
+                if name in ["cov", "corr"]:
+                    expanding_f_result = expanding_f(pairwise=False)
                 else:
-                    if name in ["cov", "corr"]:
-                        expanding_f_result = expanding_f(pairwise=False)
-                    else:
-                        expanding_f_result = expanding_f()
-                    expanding_apply_f_result = x.expanding(
-                        min_periods=min_periods
-                    ).apply(func=f, raw=True)
-
-                # GH 9422
-                if name in ["sum", "prod"]:
-                    tm.assert_equal(expanding_f_result, expanding_apply_f_result)
+                    expanding_f_result = expanding_f()
+                expanding_apply_f_result = x.expanding(min_periods=min_periods).apply(
+                    func=f, raw=True
+                )
+
+            # GH 9422
+            if name in ["sum", "prod"]:
+                tm.assert_equal(expanding_f_result, expanding_apply_f_result)
 
 
 @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
diff --git a/pandas/tests/window/moments/test_moments_rolling.py b/pandas/tests/window/moments/test_moments_rolling.py
index c7d3a50ec..28ad2b866 100644
--- a/pandas/tests/window/moments/test_moments_rolling.py
+++ b/pandas/tests/window/moments/test_moments_rolling.py
@@ -946,58 +946,6 @@ class TestRollingMomentsConsistency(ConsistencyBase):
     def setup_method(self, method):
         self._create_data()
 
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_apply_consistency(
-        self, consistency_data, window, min_periods, center
-    ):
-        x, is_constant, no_nans = consistency_data
-        with warnings.catch_warnings():
-            warnings.filterwarnings(
-                "ignore",
-                message=".*(empty slice|0 for slice).*",
-                category=RuntimeWarning,
-            )
-            # test consistency between rolling_xyz() and either (a)
-            # rolling_apply of Series.xyz(), or (b) rolling_apply of
-            # np.nanxyz()
-            functions = self.base_functions
-
-            # GH 8269
-            if no_nans:
-                functions = self.base_functions + self.no_nan_functions
-            for (f, require_min_periods, name) in functions:
-                rolling_f = getattr(
-                    x.rolling(window=window, center=center, min_periods=min_periods),
-                    name,
-                )
-
-                if (
-                    require_min_periods
-                    and (min_periods is not None)
-                    and (min_periods < require_min_periods)
-                ):
-                    continue
-
-                if name == "count":
-                    rolling_f_result = rolling_f()
-                    rolling_apply_f_result = x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).apply(func=f, raw=True)
-                else:
-                    if name in ["cov", "corr"]:
-                        rolling_f_result = rolling_f(pairwise=False)
-                    else:
-                        rolling_f_result = rolling_f()
-                    rolling_apply_f_result = x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).apply(func=f, raw=True)
-
-                # GH 9422
-                if name in ["sum", "prod"]:
-                    tm.assert_equal(rolling_f_result, rolling_apply_f_result)
-
     # binary moments
     def test_rolling_cov(self):
         A = self.series
@@ -1052,6 +1000,58 @@ class TestRollingMomentsConsistency(ConsistencyBase):
         tm.assert_frame_equal(res3, exp)
 
 
+@pytest.mark.slow
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_apply_consistency(
+    consistency_data, base_functions, no_nan_functions, window, min_periods, center
+):
+    x, is_constant, no_nans = consistency_data
+
+    with warnings.catch_warnings():
+        warnings.filterwarnings(
+            "ignore", message=".*(empty slice|0 for slice).*", category=RuntimeWarning,
+        )
+        # test consistency between rolling_xyz() and either (a)
+        # rolling_apply of Series.xyz(), or (b) rolling_apply of
+        # np.nanxyz()
+        functions = base_functions
+
+        # GH 8269
+        if no_nans:
+            functions = no_nan_functions + base_functions
+        for (f, require_min_periods, name) in functions:
+            rolling_f = getattr(
+                x.rolling(window=window, center=center, min_periods=min_periods), name,
+            )
+
+            if (
+                require_min_periods
+                and (min_periods is not None)
+                and (min_periods < require_min_periods)
+            ):
+                continue
+
+            if name == "count":
+                rolling_f_result = rolling_f()
+                rolling_apply_f_result = x.rolling(
+                    window=window, min_periods=min_periods, center=center
+                ).apply(func=f, raw=True)
+            else:
+                if name in ["cov", "corr"]:
+                    rolling_f_result = rolling_f(pairwise=False)
+                else:
+                    rolling_f_result = rolling_f()
+                rolling_apply_f_result = x.rolling(
+                    window=window, min_periods=min_periods, center=center
+                ).apply(func=f, raw=True)
+
+            # GH 9422
+            if name in ["sum", "prod"]:
+                tm.assert_equal(rolling_f_result, rolling_apply_f_result)
+
+
 @pytest.mark.parametrize("window", range(7))
 def test_rolling_corr_with_zero_variance(window):
     # GH 18430
@@ -1431,6 +1431,7 @@ def test_moment_functions_zero_length_pairwise():
         tm.assert_frame_equal(df2_result, df2_expected)
 
 
+@pytest.mark.slow
 @pytest.mark.parametrize(
     "window,min_periods,center", list(_rolling_consistency_cases())
 )
@@ -1455,6 +1456,7 @@ def test_rolling_consistency_var(consistency_data, window, min_periods, center):
     )
 
 
+@pytest.mark.slow
 @pytest.mark.parametrize(
     "window,min_periods,center", list(_rolling_consistency_cases())
 )
@@ -1477,6 +1479,7 @@ def test_rolling_consistency_std(consistency_data, window, min_periods, center):
     )
 
 
+@pytest.mark.slow
 @pytest.mark.parametrize(
     "window,min_periods,center", list(_rolling_consistency_cases())
 )

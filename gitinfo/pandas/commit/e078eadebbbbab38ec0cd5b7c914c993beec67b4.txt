commit e078eadebbbbab38ec0cd5b7c914c993beec67b4
Author: jreback <jeff@reback.net>
Date:   Wed Dec 26 22:14:14 2012 -0500

    ENH: added unique method to store, for selectin unique values in an indexable or data column w/o selecting the entire table

diff --git a/RELEASE.rst b/RELEASE.rst
index c57678fd0..ccd27685f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -42,6 +42,7 @@ pandas 0.10.1
     - added column filtering via ``columns`` keyword in select
     - added methods append_to_multiple/select_as_multiple/select_as_coordinates to do multiple-table append/selection
     - added support for datetime64 in columns
+    - added method ``unique`` to select the unique values in an indexable or data column
 
 **Bug fixes**
 
diff --git a/doc/source/io.rst b/doc/source/io.rst
index adb43190f..73822b387 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1246,6 +1246,17 @@ There is some performance degredation by making lots of columns into `data colum
 Advanced Queries
 ~~~~~~~~~~~~~~~~
 
+**Unique**
+
+To retrieve the *unique* values of an indexable or data column, use the method ``unique``. This will, for example, enable you to get the index very quickly. Note ``nan`` are excluded from the result set.
+
+.. ipython:: python
+
+   store.unique('df_dc','index')
+   store.unique('df_dc','string')
+
+**Replicating or**
+
 ``not`` and ``or`` conditions are unsupported at this time; however, ``or`` operations are easy to replicate, by repeately applying the criteria to the table, and then ``concat`` the results.
 
 .. ipython:: python
@@ -1255,6 +1266,8 @@ Advanced Queries
 
    concat([ store.select('df_dc',c) for c in [ crit1, crit2 ] ])
 
+**Table Object**
+
 If you want to inspect the table object, retrieve via ``get_table``. You could use this progamatically to say get the number of rows in the table.
 
 .. ipython:: python
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index fd585d2a5..b8137fda5 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -43,6 +43,13 @@ You can designate (and index) certain columns that you want to be able to perfor
    # this is in-memory version of this type of selection
    df[(df.B > 0) & (df.string == 'foo')]
 
+Retrieving unique values in an indexable or data column.
+
+.. ipython:: python
+
+   store.unique('df','index')
+   store.unique('df','string')
+
 You can now store ``datetime64`` in data columns
 
 .. ipython:: python
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 577f0ea99..4df28b59f 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -378,6 +378,23 @@ class HDFStore(object):
         """
         return self.get_table(key).read_coordinates(where = where, **kwargs)
 
+    def unique(self, key, column, **kwargs):
+        """ 
+        return a single column uniquely from the table. This is generally only useful to select an indexable
+
+        Parameters
+        ----------
+        key : object
+        column: the column of interest
+
+        Exceptions
+        ----------
+        raises KeyError if the column is not found (or key is not a valid store)
+        raises ValueError if the column can not be extracted indivually (it is part of a data block)
+
+        """
+        return self.get_table(key).read_column(column = column, **kwargs)
+
     def select_as_multiple(self, keys, where=None, selector=None, columns=None, **kwargs):
         """ Retrieve pandas objects from multiple tables
 
@@ -1124,9 +1141,19 @@ class IndexCol(object):
         return new_self
 
     def convert(self, values, nan_rep):
-        """ set the values from this selection """
-        self.values = Index(_maybe_convert(values[self.cname], self.kind))
-   
+        """ set the values from this selection: take = take ownership """
+        try:
+            values = values[self.cname]
+        except:
+            pass
+        self.values = Index(_maybe_convert(values, self.kind))
+        return self
+
+    def take_data(self):
+        """ return the values & release the memory """
+        self.values, values = None, self.values
+        return values
+
     @property
     def attrs(self):
         return self.table._v_attrs
@@ -1365,7 +1392,11 @@ class DataCol(IndexCol):
 
     def convert(self, values, nan_rep):
         """ set the data from this selection (and convert to the correct dtype if we can) """
-        self.set_data(values[self.cname])
+        try:
+            values = values[self.cname]
+        except:
+            pass
+        self.set_data(values)
 
         # convert to the correct dtype
         if self.dtype is not None:
@@ -1388,7 +1419,8 @@ class DataCol(IndexCol):
         # convert nans
         if self.kind == 'string':
             self.data = lib.array_replace_from_nan_rep(self.data.flatten(), nan_rep).reshape(self.data.shape)
-   
+        return self
+
     def get_attr(self):
         """ get the data for this colummn """
         self.values = getattr(self.attrs,self.kind_attr,None)
@@ -1898,6 +1930,7 @@ class Table(object):
         raise NotImplementedError("cannot read on an abstract table: subclasses should implement")
 
     def read_coordinates(self, where=None, **kwargs):
+        """ select coordinates (row numbers) from a table; return the coordinates object """
 
         # validate the version
         self.validate_version(where)
@@ -1909,6 +1942,28 @@ class Table(object):
         self.selection = Selection(self, where = where, **kwargs)
         return Coordinates(self.selection.select_coords(), group = self.group, where = where)
 
+    def read_column(self, column, **kwargs):
+        """ return a single column from the table, generally only indexables are interesting """
+
+        # validate the version
+        self.validate_version()
+
+        # infer the data kind
+        if not self.infer_axes(): return False
+
+        # find the axes
+        for a in self.axes:
+            if column == a.name:
+
+                if not a.is_data_indexable:
+                    raise ValueError("column [%s] can not be extracted individually; it is not data indexable" % column)
+
+                # column must be an indexable or a data column
+                c = getattr(self.table.cols,column)
+                return Categorical.from_array(a.convert(c[:], nan_rep = self.nan_rep).take_data()).levels
+
+        raise KeyError("column [%s] not found in the table" % column)
+
     def write(self, **kwargs):
         raise NotImplementedError("cannot write on an abstract table")
 
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 096d35922..a594da99a 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1432,6 +1432,41 @@ class TestHDFStore(unittest.TestCase):
         #self.assertRaises(Exception, self.store.select,
         #                  'frame', [crit1, crit2])
 
+    def test_unique(self):
+        df = tm.makeTimeDataFrame()
+
+
+        def check(x, y):
+            self.assert_((np.unique(x) == np.unique(y)).all() == True)
+
+        self.store.remove('df')
+        self.store.append('df', df)
+
+        # error
+        self.assertRaises(KeyError, self.store.unique, 'df','foo')
+
+        # valid
+        result = self.store.unique('df','index')
+        check(result.values,df.index.values)
+
+        # not a data indexable column
+        self.assertRaises(ValueError, self.store.unique, 'df','values_block_0')
+
+        # a data column
+        df2 = df.copy()
+        df2['string'] = 'foo'
+        self.store.append('df2',df2,data_columns = ['string'])
+        result = self.store.unique('df2','string')
+        check(result.values,df2['string'].unique())
+
+        # a data column with NaNs, result excludes the NaNs
+        df3 = df.copy()
+        df3['string'] = 'foo'
+        df3.ix[4:6,'string'] = np.nan
+        self.store.append('df3',df3,data_columns = ['string'])
+        result = self.store.unique('df3','string')
+        check(result.values,df3['string'].valid().unique())
+
     def test_coordinates(self):
         df = tm.makeTimeDataFrame()
 

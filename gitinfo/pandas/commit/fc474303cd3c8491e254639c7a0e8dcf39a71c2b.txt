commit fc474303cd3c8491e254639c7a0e8dcf39a71c2b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu May 24 22:45:10 2012 -0400

    ENH: implement many-to-many index joins, close #1306

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 7eeadfd2d..cd0ad3c10 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -844,7 +844,17 @@ class Index(np.ndarray):
 
         _validate_join_method(how)
 
-        if self.is_monotonic and other.is_monotonic:
+        if not self.is_unique and not other.is_unique:
+            return self._join_non_unique(other, how=how,
+                                         return_indexers=return_indexers)
+        elif not self.is_unique or not other.is_unique:
+            if self.is_monotonic and other.is_monotonic:
+                return self._join_monotonic(other, how=how,
+                                            return_indexers=return_indexers)
+            else:
+                return self._join_non_unique(other, how=how,
+                                             return_indexers=return_indexers)
+        elif self.is_monotonic and other.is_monotonic:
             return self._join_monotonic(other, how=how,
                                         return_indexers=return_indexers)
 
@@ -870,6 +880,23 @@ class Index(np.ndarray):
         else:
             return join_index
 
+    def _join_non_unique(self, other, how='left', return_indexers=False):
+        from pandas.tools.merge import _get_join_indexers
+
+        left_idx, right_idx = _get_join_indexers([self.values], [other.values],
+                                                 how=how, sort=True)
+
+        join_index = self.values.take(left_idx)
+        mask = left_idx == -1
+        np.putmask(join_index, mask, other.values.take(right_idx))
+
+        join_index = self._wrap_joined_index(join_index, other)
+
+        if return_indexers:
+            return join_index, left_idx, right_idx
+        else:
+            return join_index
+
     def _join_level(self, other, level, how='left', return_indexers=False):
         """
         The join method *only* affects the level of the resulting
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 4827fd711..6a87d249c 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -326,7 +326,7 @@ class IntBlock(Block):
     _can_hold_na = False
 
     def _can_hold_element(self, element):
-        return isinstance(element, int)
+        return com.is_integer(element)
 
     def _try_cast(self, element):
         try:
@@ -366,9 +366,21 @@ class ObjectBlock(Block):
                               (np.integer, np.floating, np.complexfloating,
                                np.bool_))
 
-class DatetimeBlock(IntBlock):
+class DatetimeBlock(Block):
     _can_hold_na = True
 
+    def _can_hold_element(self, element):
+        return com.is_integer(element)
+
+    def _try_cast(self, element):
+        try:
+            return int(element)
+        except:
+            return element
+
+    def should_store(self, value):
+        return issubclass(value.dtype.type, np.datetime64)
+
 
 def make_block(values, items, ref_items, do_integrity_check=False):
     dtype = values.dtype
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 2cfacf695..f031dca4c 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -249,12 +249,10 @@ class _MergeOperation(object):
                 _left_join_on_index(right_ax, left_ax, self.right_join_keys,
                                     sort=self.sort)
         else:
-            # max groups = largest possible number of distinct groups
-            left_key, right_key, max_groups = self._get_group_keys()
-
-            join_func = _join_functions[self.how]
-            left_indexer, right_indexer = join_func(left_key, right_key,
-                                                    max_groups)
+            (left_indexer,
+             right_indexer) = _get_join_indexers(self.left_join_keys,
+                                                 self.right_join_keys,
+                                                 sort=self.sort, how=self.how)
 
             if self.right_index:
                 join_index = self.left.index.take(left_indexer)
@@ -348,6 +346,9 @@ class _MergeOperation(object):
                                                  self.left.index.labels)]
             else:
                 left_keys = [self.left.index.values]
+        # else:
+        #     left_keys.append(self.left.index)
+        #     right_keys.append(self.right.index)
 
         if right_drop:
             self.right = self.right.drop(right_drop, axis=1)
@@ -390,46 +391,46 @@ class _MergeOperation(object):
                 self.left_on = [None] * n
         assert(len(self.right_on) == len(self.left_on))
 
-    def _get_group_keys(self):
-        """
 
-        Parameters
-        ----------
+def _get_join_indexers(left_keys, right_keys, sort=False, how='inner'):
+    """
 
-        Returns
-        -------
+    Parameters
+    ----------
 
-        """
-        left_keys = self.left_join_keys
-        right_keys = self.right_join_keys
+    Returns
+    -------
 
-        assert(len(left_keys) == len(right_keys))
+    """
+    assert(len(left_keys) == len(right_keys))
+
+    left_labels = []
+    right_labels = []
+    group_sizes = []
 
-        left_labels = []
-        right_labels = []
-        group_sizes = []
+    for lk, rk in zip(left_keys, right_keys):
+        llab, rlab, count = _factorize_keys(lk, rk, sort=sort)
 
-        for lk, rk in zip(left_keys, right_keys):
-            llab, rlab, count = _factorize_keys(lk, rk, sort=self.sort)
+        left_labels.append(llab)
+        right_labels.append(rlab)
+        group_sizes.append(count)
 
-            left_labels.append(llab)
-            right_labels.append(rlab)
-            group_sizes.append(count)
+    left_group_key = get_group_index(left_labels, group_sizes)
+    right_group_key = get_group_index(right_labels, group_sizes)
 
-        left_group_key = get_group_index(left_labels, group_sizes)
-        right_group_key = get_group_index(right_labels, group_sizes)
+    max_groups = 1L
+    for x in group_sizes:
+        max_groups *= long(x)
 
-        max_groups = 1L
-        for x in group_sizes:
-            max_groups *= long(x)
+    if max_groups > 2**63:  # pragma: no cover
+        raise MergeError('Combinatorial explosion! (boom)')
+
+    left_group_key, right_group_key, max_groups = \
+        _factorize_keys(left_group_key, right_group_key, sort=sort)
 
-        if max_groups > 2**63:  # pragma: no cover
-            raise MergeError('Combinatorial explosion! (boom)')
+    join_func = _join_functions[how]
+    return join_func(left_group_key, right_group_key, max_groups)
 
-        left_group_key, right_group_key, max_groups = \
-            _factorize_keys(left_group_key, right_group_key,
-                             sort=self.sort)
-        return left_group_key, right_group_key, max_groups
 
 
 class _OrderedMerge(_MergeOperation):
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 947892bbe..b6ab8976d 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -583,33 +583,44 @@ class TestMerge(unittest.TestCase):
         self.assertRaises(MergeError, merge, df1, df2)
 
     def test_merge_non_unique_indexes(self):
-        dt = datetime.now()
-        df1 = DataFrame({'x': ['a']}, index=[dt])
-        df2 = DataFrame({'y': ['b', 'c']}, index=[dt, dt])
-
-        for how in ['inner', 'left', 'outer']:
-            result = df1.join(df2, how=how)
-
-            expected = merge(df1.reset_index(), df2.reset_index(),
-                             how=how)
-            expected = expected.set_index('index')
-
-            assert_frame_equal(result, expected)
 
-    # def test_merge_many_to_many(self):
-    #     dt = datetime.now()
-    #     df1 = DataFrame({'x': ['a', 'b']}, index=[dt, dt])
-    #     df2 = DataFrame({'y': ['c', 'd']}, index=[dt, dt])
+        dt = datetime(2012, 5, 1)
+        dt2 = datetime(2012, 5, 2)
+        dt3 = datetime(2012, 5, 3)
+        dt4 = datetime(2012, 5, 4)
 
-    #     for how in ['inner', 'left', 'outer']:
-    #         result = df1.join(df2, how=how)
-
-    #         expected = merge(df1.reset_index(), df2.reset_index(),
-    #                          how=how)
-    #         expected = expected.set_index('index')
-
-    #         assert_frame_equal(result, expected)
+        df1 = DataFrame({'x': ['a']}, index=[dt])
+        df2 = DataFrame({'y': ['b', 'c']}, index=[dt, dt])
+        _check_merge(df1, df2)
+
+        # Not monotonic
+        df1 = DataFrame({'x': ['a', 'b', 'q']}, index=[dt2, dt, dt4])
+        df2 = DataFrame({'y': ['c', 'd', 'e', 'f', 'g', 'h']},
+                        index=[dt3, dt3, dt2, dt2, dt, dt])
+        _check_merge(df1, df2)
+
+        df1 = DataFrame({'x': ['a', 'b']}, index=[dt, dt])
+        df2 = DataFrame({'y': ['c', 'd']}, index=[dt, dt])
+        _check_merge(df1, df2)
+
+    def test_merge_non_unique_index_many_to_many(self):
+        dt = datetime(2012, 5, 1)
+        dt2 = datetime(2012, 5, 2)
+        dt3 = datetime(2012, 5, 3)
+        df1 = DataFrame({'x': ['a', 'b', 'c', 'd']},
+                        index=[dt2, dt2, dt, dt])
+        df2 = DataFrame({'y': ['e', 'f', 'g',' h', 'i']},
+                        index=[dt2, dt2, dt3, dt, dt])
+        _check_merge(df1, df2)
+
+def _check_merge(x, y):
+    for how in ['inner', 'left', 'outer']:
+        result = x.join(y, how=how)
+
+        expected = merge(x.reset_index(), y.reset_index(), how=how)
+        expected = expected.set_index('index')
 
+        assert_frame_equal(result, expected)
 
 class TestMergeMulti(unittest.TestCase):
 

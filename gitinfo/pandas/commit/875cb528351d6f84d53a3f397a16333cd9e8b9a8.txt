commit 875cb528351d6f84d53a3f397a16333cd9e8b9a8
Author: Adam Klein <adamklein@gmail.com>
Date:   Tue Mar 13 17:57:29 2012 -0400

    ENH: add basic skts frequency multiples functionality, eg 5Min intervals

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index fa379c4cc..4cb355954 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -123,9 +123,11 @@ def dt64arr_to_sktsarr(data, freq):
         return data
 
     if isinstance(freq, basestring):
-        freq = _interval_code_map[freq]
+        base, mult = _get_freq_code(freq)
+    else:
+        base, mult = freq
 
-    return lib.dt64arr_to_sktsarr(data.view('i8'), freq)
+    return lib.dt64arr_to_sktsarr(data.view('i8'), base, mult)
 
 # interval frequency constants corresponding to scikits timeseries
 # originals
@@ -212,14 +214,24 @@ class Interval:
                  year=None, month=1, quarter=None, day=1,
                  hour=0, minute=0, second=0):
 
+        # freq is a tuple (base, mult) where base is one of the defined
+        # intervals such as A, Q, etc. Every five minutes would be, e.g.,
+        # ('Min', 5) but may be passed in as a string like '5Min'
+
         self.freq = None
+
+        # ordinal is the interval offset from the gregorian proleptic epoch
+
         self.ordinal = None
 
         if freq is not None:
             if isinstance(freq, basestring):
-                self.freq = _interval_code_map[freq]
-            else:
+                base, mult = _get_freq_code(freq)
+                self.freq = (base, mult)
+            elif isinstance(freq, tuple):
                 self.freq = freq
+            else:
+                raise ValueError("Expected (timerule, mult) tuple for freq")
 
         if value is None:
             if self.freq is None:
@@ -231,8 +243,10 @@ class Interval:
             if quarter is not None:
                 month = (quarter - 1) * 3 + 1
 
-            self.ordinal = lib.skts_ordinal(year, month, day, hour,
-                                            minute, second, self.freq)
+            base, mult = self.freq
+
+            self.ordinal = lib.skts_ordinal(year, month, day, hour, minute,
+                                            second, base, mult)
             return
 
         if isinstance(value, Interval):
@@ -250,21 +264,21 @@ class Interval:
 
             if freq is None:
                 if reso == 'year':
-                    self.freq = _interval_code_map['A']
+                    freq = _interval_code_map['A']
                 elif reso == 'month':
-                    self.freq = _interval_code_map['M']
+                    freq = _interval_code_map['M']
                 elif reso == 'day':
-                    self.freq = _interval_code_map['D']
+                    freq = _interval_code_map['D']
                 elif reso == 'hour':
-                    self.freq = _interval_code_map['H']
+                    freq = _interval_code_map['H']
                 elif reso == 'minute':
-                    self.freq = _interval_code_map['Min']
+                    freq = _interval_code_map['Min']
                 elif reso == 'second':
-                    self.freq = _interval_code_map['S']
+                    freq = _interval_code_map['S']
                 else:
                     raise ValueError("Could not infer frequency for interval")
-            else:
-                self.freq = _interval_code_map[freq]
+                self.freq = (freq, 1)
+
         elif isinstance(value, datetime):
             dt = value
         elif isinstance(value, (int, long)):
@@ -272,9 +286,11 @@ class Interval:
         else:
             raise ValueError("Value must be string or datetime")
 
+        base, mult = self.freq
+
         if self.ordinal is None:
             self.ordinal = lib.skts_ordinal(dt.year, dt.month, dt.day, dt.hour,
-                                            dt.minute, dt.second, self.freq)
+                                            dt.minute, dt.second, base, mult)
 
     def __eq__(self, other):
         if isinstance(other, Interval):
@@ -299,43 +315,58 @@ class Interval:
         if how not in ('S', 'E'):
             raise ValueError('How must be one of S or E')
 
+        base1, mult1 = self.freq
+
         if isinstance(freq, basestring):
-            freq = _interval_code_map[freq]
+            base2, mult2 = _get_freq_code(freq)
+        else:
+            base2, mult2 = freq
 
-        new_ordinal = lib.skts_freq_conv(self.ordinal,
-                                         self.freq, freq, how)
+        new_ordinal = lib.skts_freq_conv(self.ordinal, base1, mult1, 
+                                         base2, mult2, how)
 
-        return Interval(new_ordinal, freq)
+        return Interval(new_ordinal, (base2, mult2))
 
     @classmethod
     def now(cls, freq=None):
         if isinstance(freq, basestring):
-            freq = _interval_code_map[freq]
+            base, mult = _get_freq_code(freq)
+            freq = (base, mult)
 
-        sfreq = _interval_code_map['S']
+        base, mult = _interval_code_map['S'], 1
+        sfreq = (base, mult)
 
         dt = datetime.now()
 
         skts_ordinal = lib.skts_ordinal(dt.year, dt.month, dt.day, dt.hour,
-                                        dt.minute, dt.second, sfreq)
+                                        dt.minute, dt.second, base, mult)
 
         return Interval(skts_ordinal, sfreq).asfreq(freq)
 
     def __repr__(self):
-        formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
-        freqstr = _reverse_interval_code_map[self.freq]
-        return ("Interval('%s', '%s')" % (formatted, freqstr))
+        base = self.freq[0]
+        mult = self.freq[1]
+        formatted = lib.skts_ordinal_to_string(self.ordinal, base, mult)
+        freqstr = _reverse_interval_code_map[base]
+        return ("Interval('%s', '%d%s')" % (formatted, mult, freqstr))
 
     def __str__(self):
-        formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
+        base = self.freq[0]
+        mult = self.freq[1]
+        formatted = lib.skts_ordinal_to_string(self.ordinal, base, mult)
         return ("%s" % formatted)
 
 def _infer_interval_group(freqstr):
     return _interval_group(_reso_interval_map[freqstr])
 
 def _interval_group(freqstr):
-    grp = _interval_code_map[freqstr]
-    return grp // 1000 * 1000
+    base, mult = _get_freq_code(freqstr)
+    return base // 1000 * 1000
+
+def _get_freq_code(freqstr):
+    base, stride = _base_and_stride(freqstr)
+    code = _interval_code_map[base]
+    return code, stride
 
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
@@ -1483,7 +1514,7 @@ def inferTimeRule(index, _deprecated=True):
 
 opattern = re.compile(r'(\d*)\s*(\S+)')
 
-def to_offset(name):
+def to_offset(freqstr):
     """
     Return DateOffset object from string representation
 
@@ -1491,10 +1522,27 @@ def to_offset(name):
     -------
     to_offset('5Min') -> Minute(5)
     """
-    groups = opattern.match(name)
+    name, stride = _base_and_stride(freqstr)
+
+    offset = _newOffsetMap.get(name)
+
+    if offset is None:
+        raise ValueError('Bad offset request: %s' % name)
+
+    return offset * stride
+
+def _base_and_stride(freqstr):
+    """
+    Return base freq and stride info from string representation
+
+    Example
+    -------
+    _freq_and_stride('5Min') -> 'Min', 5
+    """
+    groups = opattern.match(freqstr)
 
     if groups.lastindex != 2:
-        raise ValueError("Could not evaluate %s" % name)
+        raise ValueError("Could not evaluate %s" % freqstr)
 
     stride = groups.group(1)
 
@@ -1503,14 +1551,10 @@ def to_offset(name):
     else:
         stride = 1
 
-    name = groups.group(2)
+    base = groups.group(2)
 
-    offset = _newOffsetMap.get(name)
+    return (base, stride)
 
-    if offset is None:
-        raise ValueError('Bad offset request: %s' % name)
-
-    return offset * stride
 
 def getOffset(name, _deprecated=True):
     """
diff --git a/pandas/core/index.py b/pandas/core/index.py
index c2aa52db8..2ea4cd7d0 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1939,7 +1939,7 @@ class IntervalIndex(Int64Index):
 
                 # if our data is higher resolution than requested key, slice
                 if grp < freqn:
-                    iv = Interval(asdt, freq=grp)
+                    iv = Interval(asdt, freq=(grp,1))
                     ord1 = iv.asfreq(self.freq, how='S').ordinal
                     ord2 = iv.asfreq(self.freq, how='E').ordinal
                     pos = np.searchsorted(self.values, [ord1, ord2])
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 200827f94..21e5ccbc4 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1849,7 +1849,21 @@ cdef inline int64_t ts_dayofweek(_TSObject ts):
 # Interval logic
 # ------------------------------------------------------------------------------
 
-def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int freq):
+cdef long apply_mult(long skts_ord, long mult):
+    """
+    Get base+multiple ordinal value from corresponding base-only ordinal value.
+    For example, 5min ordinal will be 1/5th the 1min ordinal (rounding down to
+    integer).
+    """
+    return (skts_ord - 1) // mult
+
+cdef long remove_mult(long skits_ord_w_mult, long mult):
+    """
+    Get base-only ordinal value from corresponding base+multiple ordinal.
+    """
+    return skits_ord_w_mult * mult + 1;
+
+def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int base, long mult):
     """
     Convert array of datetime64 values (passed in as 'i8' dtype) to a set of
     intervals corresponding to desired frequency, per skts convention.
@@ -1866,12 +1880,12 @@ def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int freq):
     for i in range(l):
         PyArray_DatetimeToDatetimeStruct(dtarr[i], NPY_FR_us, &dts)
         out[i] = skts_ordinal(dts.year, dts.month, dts.day,
-                              dts.hour, dts.min, dts.sec, 
-                              freq)
+                              dts.hour, dts.min, dts.sec, base)
+        out[i] = apply_mult(out[i], mult)
     return out
 
-def skts_freq_conv(long skts_ordinal, int freq1, int freq2,
-                  object relation='E'):
+def skts_freq_conv(long skts_ordinal, int base1, long mult1, int base2, long mult2,
+                   object relation='E'):
     """
     """
     cdef:
@@ -1880,26 +1894,28 @@ def skts_freq_conv(long skts_ordinal, int freq1, int freq2,
     if not isinstance(relation, basestring) or len(relation) != 1:
         raise ValueError('relation argument must be one of S or E')
 
-    retval = frequency_conversion(skts_ordinal, freq1, freq2,
-                                  (<char*>relation)[0])
+    skts_ordinal = remove_mult(skts_ordinal, mult1)
 
-    return retval
+    retval = frequency_conversion(skts_ordinal, base1, base2, (<char*>relation)[0])
+
+    return apply_mult(retval, mult2)
 
-def skts_ordinal(int y, int m, int d, int h, int min, int s, int freq):
+def skts_ordinal(int y, int m, int d, int h, int min, int s, int base, long mult):
     cdef:
         long ordinal
 
-    ordinal = get_skts_ordinal(y, m, d, h, min, s, freq)
+    ordinal = get_skts_ordinal(y, m, d, h, min, s, base)
 
-    return ordinal
+    return apply_mult(ordinal, mult)
 
-def skts_ordinal_to_dt(long skts_ordinal, int freq):
+def skts_ordinal_to_dt(long skts_ordinal, int base, long mult):
     cdef:
         long ordinal
 
-    ordinal = get_python_ordinal(skts_ordinal, freq)
+    ordinal = remove_mult(skts_ordinal, mult)
+    ordinal = get_python_ordinal(ordinal, base)
 
     return datetime.fromordinal(ordinal)
 
-def skts_ordinal_to_string(long value, int freq):
-    return <object>interval_to_string(value, freq)
+def skts_ordinal_to_string(long value, int base, long mult):
+    return <object>interval_to_string(remove_mult(value, mult), base)
diff --git a/pandas/src/skts.c b/pandas/src/skts.c
index 710b7db24..e4b0a2cc9 100644
--- a/pandas/src/skts.c
+++ b/pandas/src/skts.c
@@ -672,6 +672,7 @@ static long asfreq_AtoS(long fromDate, char relation, asfreq_info *af_info)
     { return asfreq_DtoS(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
 
 static long nofunc(long fromDate, char relation, asfreq_info *af_info) { return INT_ERR_CODE; }
+static long no_op(long fromDate, char relation, asfreq_info *af_info) { return fromDate; }
 
 // end of frequency specific conversion routines
 
@@ -763,6 +764,7 @@ static freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
             {
                 case FR_ANN: return &asfreq_MtoA;
                 case FR_QTR: return &asfreq_MtoQ;
+                case FR_MTH: return &no_op;
                 case FR_WK: return &asfreq_MtoW;
                 case FR_BUS: return &asfreq_MtoB;
                 case FR_DAY: return &asfreq_MtoD;
@@ -795,6 +797,7 @@ static freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
                 case FR_MTH: return &asfreq_BtoM;
                 case FR_WK: return &asfreq_BtoW;
                 case FR_DAY: return &asfreq_BtoD;
+                case FR_BUS: return &no_op;
                 case FR_HR: return &asfreq_BtoH;
                 case FR_MIN: return &asfreq_BtoT;
                 case FR_SEC: return &asfreq_BtoS;
@@ -829,6 +832,7 @@ static freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
                     if (forConvert) { return &asfreq_HtoB_forConvert; }
                     else            { return &asfreq_HtoB; }
                 case FR_DAY: return &asfreq_HtoD;
+                case FR_HR: return &no_op;
                 case FR_MIN: return &asfreq_HtoT;
                 case FR_SEC: return &asfreq_HtoS;
                 default: return &nofunc;
@@ -846,6 +850,7 @@ static freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
                     else            { return &asfreq_TtoB; }
                 case FR_DAY: return &asfreq_TtoD;
                 case FR_HR: return &asfreq_TtoH;
+                case FR_MIN: return &no_op;
                 case FR_SEC: return &asfreq_TtoS;
                 default: return &nofunc;
             }
@@ -863,6 +868,7 @@ static freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
                 case FR_DAY: return &asfreq_StoD;
                 case FR_HR: return &asfreq_StoH;
                 case FR_MIN: return &asfreq_StoT;
+                case FR_SEC: return &no_op;
                 default: return &nofunc;
             }
         default: return &nofunc;
diff --git a/pandas/src/skts.h b/pandas/src/skts.h
index 04d4a7483..c9091bc68 100644
--- a/pandas/src/skts.h
+++ b/pandas/src/skts.h
@@ -108,6 +108,9 @@
 #define FR_HR   7000  /* Hourly */
 #define FR_MIN  8000  /* Minutely */
 #define FR_SEC  9000  /* Secondly */
+
+#define FR_MUL 10000  /* A multiple of a base frequency */
+
 #define FR_UND  -10000 /* Undefined */
 
 #define INT_ERR_CODE -1
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 01f5e3883..bcb3efa8a 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -616,6 +616,14 @@ class TestDatetime64(unittest.TestCase):
         res = s['2011']
         exp = s[12:24]
         assert_series_equal(res, exp)
+        
+    def test_interval_multiples(self):
+        ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='2M')
+        self.assertEquals(ii[0], Interval('1/1/10', '2M'))
+        self.assertEquals(ii[1], Interval('3/1/10', '2M'))
+
+        self.assertEquals(ii[0].asfreq('6M'), ii[2].asfreq('6M')) 
+
 
     def test_intervalindex_constructor(self):
         pass

commit 51cb276e623613991f94c4ef3f1ac5c5f5327655
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Jan 14 18:58:06 2020 -0800

    CLN: remove checks for inferred_dtype==unicode (#31020)

diff --git a/pandas/_testing.py b/pandas/_testing.py
index 1fdc5d478..018551224 100644
--- a/pandas/_testing.py
+++ b/pandas/_testing.py
@@ -613,8 +613,8 @@ def assert_index_equal(
                 assert_attr_equal("dtype", l, r, obj=obj)
 
             # allow string-like to have different inferred_types
-            if l.inferred_type in ("string", "unicode"):
-                assert r.inferred_type in ("string", "unicode")
+            if l.inferred_type in ("string"):
+                assert r.inferred_type in ("string")
             else:
                 assert_attr_equal("inferred_type", l, r, obj=obj)
 
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 39e8e9008..59256f692 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -201,7 +201,7 @@ def _ensure_arraylike(values):
     """
     if not is_array_like(values):
         inferred = lib.infer_dtype(values, skipna=False)
-        if inferred in ["mixed", "string", "unicode"]:
+        if inferred in ["mixed", "string"]:
             if isinstance(values, tuple):
                 values = list(values)
             values = construct_1d_object_array_from_listlike(values)
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index 1dbdb8dbb..2a09bd7e5 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -670,7 +670,7 @@ def infer_dtype_from_array(arr, pandas_dtype: bool = False):
 
     # don't force numpy coerce with nan's
     inferred = lib.infer_dtype(arr, skipna=False)
-    if inferred in ["string", "bytes", "unicode", "mixed", "mixed-integer"]:
+    if inferred in ["string", "bytes", "mixed", "mixed-integer"]:
         return (np.object_, arr)
 
     arr = np.asarray(arr)
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index f2f53f564..47daaa495 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -910,7 +910,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         # do we want to justify (only do so for non-objects)
         is_justify = not (
-            self.inferred_type in ("string", "unicode")
+            self.inferred_type in ("string")
             or (
                 self.inferred_type == "categorical" and is_object_dtype(self.categories)
             )
@@ -2860,7 +2860,6 @@ class Index(IndexOpsMixin, PandasObject):
                     "mixed-integer-float",
                     "integer-na",
                     "string",
-                    "unicode",
                     "mixed",
                 ]:
                     self._invalid_indexer("label", key)
diff --git a/pandas/io/parquet.py b/pandas/io/parquet.py
index 4be62b886..98f2eb392 100644
--- a/pandas/io/parquet.py
+++ b/pandas/io/parquet.py
@@ -51,7 +51,7 @@ class BaseImpl:
             raise ValueError("to_parquet only supports IO with DataFrames")
 
         # must have value column names (strings only)
-        if df.columns.inferred_type not in {"string", "unicode", "empty"}:
+        if df.columns.inferred_type not in {"string", "empty"}:
             raise ValueError("parquet must have string column names")
 
         # index level names must be strings
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 41db6ed0e..84a8b5b2a 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -1304,7 +1304,7 @@ def _validate_usecols_arg(usecols):
 
         usecols_dtype = lib.infer_dtype(usecols, skipna=False)
 
-        if usecols_dtype not in ("empty", "integer", "string", "unicode"):
+        if usecols_dtype not in ("empty", "integer", "string"):
             raise ValueError(msg)
 
         usecols = set(usecols)
diff --git a/pandas/io/stata.py b/pandas/io/stata.py
index b8e04ad55..cee5f3d28 100644
--- a/pandas/io/stata.py
+++ b/pandas/io/stata.py
@@ -2334,7 +2334,7 @@ class StataWriter(StataParser):
             dtype = column.dtype
             if dtype.type == np.object_:
                 inferred_dtype = infer_dtype(column, skipna=True)
-                if not ((inferred_dtype in ("string", "unicode")) or len(column) == 0):
+                if not ((inferred_dtype in ("string")) or len(column) == 0):
                     col = column.name
                     raise ValueError(
                         f"""\

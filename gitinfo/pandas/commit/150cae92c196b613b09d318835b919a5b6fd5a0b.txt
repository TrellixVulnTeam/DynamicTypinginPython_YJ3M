commit 150cae92c196b613b09d318835b919a5b6fd5a0b
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Dec 3 10:53:02 2019 -0800

    CLN: assorted pytables cleanups, remove unwanted assertion (#29982)

diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 487413543..a48d9abc3 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -361,9 +361,6 @@ def read_hdf(
     >>> df.to_hdf('./store.h5', 'data')
     >>> reread = pd.read_hdf('./store.h5')
     """
-    assert not kwargs, kwargs
-    # NB: in principle more kwargs could be passed to HDFStore, but in
-    #  tests none are.
 
     if mode not in ["r", "r+", "a"]:
         raise ValueError(
@@ -500,13 +497,14 @@ class HDFStore:
     """
 
     _handle: Optional["File"]
+    _mode: str
     _complevel: int
     _fletcher32: bool
 
     def __init__(
         self,
         path,
-        mode=None,
+        mode: str = "a",
         complevel: Optional[int] = None,
         complib=None,
         fletcher32: bool = False,
@@ -837,7 +835,13 @@ class HDFStore:
             raise TypeError("can only read_coordinates with a table")
         return tbl.read_coordinates(where=where, start=start, stop=stop)
 
-    def select_column(self, key: str, column: str, **kwargs):
+    def select_column(
+        self,
+        key: str,
+        column: str,
+        start: Optional[int] = None,
+        stop: Optional[int] = None,
+    ):
         """
         return a single column from the table. This is generally only useful to
         select an indexable
@@ -845,8 +849,10 @@ class HDFStore:
         Parameters
         ----------
         key : str
-        column: str
+        column : str
             The column of interest.
+        start : int or None, default None
+        stop : int or None, default None
 
         Raises
         ------
@@ -859,7 +865,7 @@ class HDFStore:
         tbl = self.get_storer(key)
         if not isinstance(tbl, Table):
             raise TypeError("can only read_column with a table")
-        return tbl.read_column(column=column, **kwargs)
+        return tbl.read_column(column=column, start=start, stop=stop)
 
     def select_as_multiple(
         self,
@@ -2582,9 +2588,9 @@ class Fixed:
 
         Parameters
         ----------
-
-        parent : my parent HDFStore
-        group  : the group node where the table resides
+        parent : HDFStore
+        group : Node
+            The group node where the table resides.
         """
 
     pandas_kind: str
@@ -2871,7 +2877,7 @@ class GenericFixed(Fixed):
             return self.read_multi_index(key, start=start, stop=stop)
         elif variety == "regular":
             node = getattr(self.group, key)
-            _, index = self.read_index_node(node, start=start, stop=stop)
+            index = self.read_index_node(node, start=start, stop=stop)
             return index
         else:  # pragma: no cover
             raise TypeError(f"unrecognized index variety: {variety}")
@@ -2931,13 +2937,13 @@ class GenericFixed(Fixed):
 
         levels = []
         codes = []
-        names = []
+        names: List[Optional[Hashable]] = []
         for i in range(nlevels):
             level_key = f"{key}_level{i}"
             node = getattr(self.group, level_key)
-            name, lev = self.read_index_node(node, start=start, stop=stop)
+            lev = self.read_index_node(node, start=start, stop=stop)
             levels.append(lev)
-            names.append(name)
+            names.append(lev.name)
 
             label_key = f"{key}_label{i}"
             level_codes = self.read_array(label_key, start=start, stop=stop)
@@ -2949,7 +2955,7 @@ class GenericFixed(Fixed):
 
     def read_index_node(
         self, node: "Node", start: Optional[int] = None, stop: Optional[int] = None
-    ):
+    ) -> Index:
         data = node[start:stop]
         # If the index was an empty array write_array_empty() will
         # have written a sentinel. Here we relace it with the original.
@@ -2997,7 +3003,7 @@ class GenericFixed(Fixed):
 
         index.name = name
 
-        return name, index
+        return index
 
     def write_array_empty(self, key: str, value):
         """ write a 0-len array """
@@ -3131,7 +3137,6 @@ class SeriesFixed(GenericFixed):
 
 class BlockManagerFixed(GenericFixed):
     attributes = ["ndim", "nblocks"]
-    is_shape_reversed = False
 
     nblocks: int
 
@@ -3158,10 +3163,6 @@ class BlockManagerFixed(GenericFixed):
 
             shape.append(items)
 
-            # hacky - this works for frames, but is reversed for panels
-            if self.is_shape_reversed:
-                shape = shape[::-1]
-
             return shape
         except AttributeError:
             return None
@@ -3259,7 +3260,6 @@ class Table(Fixed):
     table_type: str
     levels = 1
     is_table = True
-    is_shape_reversed = False
 
     index_axes: List[IndexCol]
     non_index_axes: List[Tuple[int, Any]]
@@ -3302,7 +3302,7 @@ class Table(Fixed):
             f"ncols->{self.ncols},indexers->[{jindex_axes}]{dc})"
         )
 
-    def __getitem__(self, c):
+    def __getitem__(self, c: str):
         """ return the axis for c """
         for a in self.axes:
             if c == a.name:
@@ -3345,10 +3345,6 @@ class Table(Fixed):
         """the levels attribute is 1 or a list in the case of a multi-index"""
         return isinstance(self.levels, list)
 
-    def validate_metadata(self, existing):
-        """ create / validate metadata """
-        self.metadata = [c.name for c in self.values_axes if c.metadata is not None]
-
     def validate_multiindex(self, obj):
         """validate that we can store the multi-index; reset and return the
         new object
@@ -3651,8 +3647,8 @@ class Table(Fixed):
         Parameters
         ----------
         where : ???
-        start: int or None, default None
-        stop: int or None, default None
+        start : int or None, default None
+        stop : int or None, default None
 
         Returns
         -------
@@ -3946,7 +3942,7 @@ class Table(Fixed):
         self.validate_min_itemsize(min_itemsize)
 
         # validate our metadata
-        self.validate_metadata(existing_table)
+        self.metadata = [c.name for c in self.values_axes if c.metadata is not None]
 
         # validate the axes if we have an existing table
         if validate:
@@ -4122,7 +4118,13 @@ class WORMTable(Table):
 
     table_type = "worm"
 
-    def read(self, **kwargs):
+    def read(
+        self,
+        where=None,
+        columns=None,
+        start: Optional[int] = None,
+        stop: Optional[int] = None,
+    ):
         """ read the indices and the indexing array, calculate offset rows and
         return """
         raise NotImplementedError("WORMTable needs to implement read")
@@ -4479,8 +4481,7 @@ class AppendableSeriesTable(AppendableFrameTable):
         """ we are going to write this as a frame table """
         if not isinstance(obj, DataFrame):
             name = obj.name or "values"
-            obj = DataFrame({name: obj}, index=obj.index)
-            obj.columns = [name]
+            obj = obj.to_frame(name)
         return super().write(obj=obj, data_columns=obj.columns.tolist(), **kwargs)
 
     def read(

commit 23fe904b2186b519816362b2c8d9face4ceef3ba
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jun 26 22:47:34 2011 -0400

    mostly feature complete for homogeneous fancy DataFrame setitem

diff --git a/RELEASE.rst b/RELEASE.rst
index b81eacbe4..ea69cc620 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -10,7 +10,8 @@ What is it
 **pandas** is a library of powerful labeled data structures, statistical tools,
 and general code for working with time series and cross-sectional data. It was
 designed with the practical needs of statistical modeling and large,
-inhomogeneous data sets in mind.
+inhomogeneous data sets in mind. It is particularly well suited for, among other
+things, financial data analysis applications.
 
 ===============
 Where to get it
@@ -36,7 +37,9 @@ Release notes
 * `Series.describe`, `DataFrame.describe`: produces an R-like table of summary
   statistics about each data column
 * `DataFrame.quantile`, `Series.quantile`
-* Fancy indexing operator on Series / DataFrame, e.g. via .ix operator:
+* Fancy indexing operator on Series / DataFrame, e.g. via .ix operator. Both
+  getting and setting of values is supported; however, setting values will only
+  currently work on homogeneously-typed DataFrame objects
   * series.ix[[d1, d2, d3]]
   * frame.ix[5:10, ['C', 'B', 'A']], frame.ix[5:10, 'A':'C']
   * frame.ix[date1:date2]
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 4b4dc0443..03e0d6168 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -109,7 +109,7 @@ class _DataFrameIndexer(object):
             raise Exception('setting on mixed-type frames not yet supported')
 
         if isinstance(key, tuple):
-            if len(key) != 2:
+            if len(key) != 2: # pragma: no cover
                 raise Exception('only length 2 tuple supported')
 
             x, y = key
@@ -133,7 +133,7 @@ class _DataFrameIndexer(object):
 
         Going by Zen of Python?
         "In the face of ambiguity, refuse the temptation to guess."
-        Going to raise AmbiguousIndexError with integer labels?
+        raise AmbiguousIndexError with integer labels?
 
         """
         index = self.frame._get_axis(axis)
@@ -145,18 +145,23 @@ class _DataFrameIndexer(object):
             else:
                 return obj
         elif _is_list_like(obj):
-            obj = np.asarray(obj)
+            objarr = np.asarray(obj)
 
-            if _is_integer_dtype(obj):
+            if _is_integer_dtype(objarr):
                 if is_int_index:
                     raise AmbiguousIndexError('integer labels')
 
                 # retrieve the indices corresponding
-                return obj
+                return objarr
+            elif objarr.dtype == np.bool_:
+                if not obj.index.equals(index):
+                    raise Exception('Cannot use boolean index with misaligned '
+                                    'or unequal labels')
+                return objarr
             else:
-                indexer, mask = index.get_indexer(obj)
+                indexer, mask = index.get_indexer(objarr)
                 if not mask.all():
-                    raise Exception('%s not in index' % obj[-mask])
+                    raise KeyError('%s not in index' % objarr[-mask])
 
                 return indexer
         else:
@@ -178,9 +183,6 @@ class _DataFrameIndexer(object):
         result = self._fancy_getitem_axis(colkey, axis=1)
         return result.ix[rowkey]
 
-    def _fancy_setitem_tuple(self, rowkey, colkey, value):
-        pass
-
     def _fancy_getitem_axis(self, key, axis=0):
         if isinstance(key, slice):
             return self._get_slice_axis(key, axis=axis)
@@ -189,6 +191,9 @@ class _DataFrameIndexer(object):
         elif axis == 0:
             idx = key
             if isinstance(key, int):
+                if _is_integer_index(self.frame.index):
+                    raise AmbiguousIndexError('integer labels')
+
                 idx = self.frame.index[key]
 
             if self.frame._is_mixed_type:
@@ -198,19 +203,20 @@ class _DataFrameIndexer(object):
         else:
             col = key
             if isinstance(key, int):
+                if _is_integer_index(self.frame.columns):
+                    raise AmbiguousIndexError('integer labels')
                 col = self.frame.columns[key]
 
             return self.frame[col]
 
-    def _fancy_setitem_axis(self, key, value, axis=0):
-        pass
-
     def _fancy_getitem(self, key, axis=0):
         labels = self.frame._get_axis(axis)
         axis_name = self.frame._get_axis_name(axis)
 
+        keyarr = np.asarray(key)
+
         # asarray can be unsafe, NumPy strings are weird
-        isbool = np.asarray(key).dtype == np.bool_
+        isbool = keyarr.dtype == np.bool_
         if isbool:
             if isinstance(key, Series):
                 if not key.index.equals(labels):
@@ -218,10 +224,10 @@ class _DataFrameIndexer(object):
                                     'or unequal labels')
             return self.frame.reindex(**{axis_name : labels[key]})
         else:
-            return self.frame.reindex(**{axis_name : key})
+            if _is_integer_dtype(keyarr) and _is_integer_index(labels):
+                raise AmbiguousIndexError('integer labels')
 
-    def _fancy_setitem(self, key, value, axis=0):
-        pass
+            return self.frame.reindex(**{axis_name : key})
 
     def _get_slice_axis(self, slice_obj, axis=0):
         _check_step(slice_obj)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index aac091e16..093078f52 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -294,8 +294,56 @@ class CheckIndexing(object):
         frame.ix[:, 'B':'C'] = 4.
         assert_frame_equal(frame, expected)
 
+        # case 8: set with booleans
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        mask = frame['A'] > 0
+        frame.ix[mask] = 0.
+        expected.values[mask] = 0.
+        assert_frame_equal(frame, expected)
+
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+        frame.ix[mask, ['A', 'B']] = 0.
+        expected.values[mask, :2] = 0.
+        assert_frame_equal(frame, expected)
+
+    def test_fancy_index_corner(self):
+        from pandas.core.indexing import AmbiguousIndexError
+
+        # ambiguous
+
+        df = DataFrame(np.random.randn(10, 5))
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__setitem__,
+                          ([0, 1, 2], [4, 5, 6]), 5)
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__setitem__, [0, 1, 2], 5)
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__setitem__, 0, 5)
+
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__getitem__, ([0, 1, 2], [4, 5, 6]))
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__getitem__, [0, 1, 2])
+        self.assertRaises(AmbiguousIndexError,
+                          df.ix.__getitem__, 0)
+
+        # try to set indices not contained in frame
+        self.assertRaises(KeyError,
+                          self.frame.ix.__setitem__,
+                          ['foo', 'bar', 'baz'], 1)
+        self.assertRaises(KeyError,
+                          self.frame.ix.__setitem__,
+                          (slice(None, None), ['E']), 1)
+        self.assertRaises(KeyError,
+                          self.frame.ix.__setitem__,
+                          (slice(None, None), 'E'), 1)
+
     def test_setitem_fancy_mixed_2d(self):
-        pass
+        self.assertRaises(Exception, self.mixed_frame.ix.__setitem__,
+                          (slice(0, 5), ['C', 'B', 'A']), 5)
 
     def test_getitem_fancy_1d(self):
         f = self.frame
@@ -398,17 +446,18 @@ class CheckIndexing(object):
                 assert_almost_equal(ix[idx, col], ts[idx])
 
     def test_setitem_fancy_scalar(self):
-        # foo
-        """
         f = self.frame
+        expected = self.frame.copy()
         ix = f.ix
         # individual value
-        for col in f.columns:
+        for j, col in enumerate(f.columns):
             ts = f[col]
             for idx in f.index[::5]:
-                assert_almost_equal(ix[idx, col], ts[idx])
-        """
-        pass
+                i = f.index.get_loc(idx)
+                val = randn()
+                expected.values[i,j] = val
+                ix[idx, col] = val
+                assert_frame_equal(f, expected)
 
     def test_getitem_fancy_boolean(self):
         f = self.frame

commit 743ceda3fac4e0cc285e07bf9113baa45a963a21
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jan 5 00:43:11 2010 +0000

    got rid of basically pointless asarray flag in DataFrame/Matrix statistical methods
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@102 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d46343807..f26c1f729 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -534,19 +534,20 @@ class DataFrame(Picklable, Groupable):
         return DataMatrix(self._series, index=self.index)
 
     def toString(self, buffer=sys.stdout, verbose=False,
-                 colSpace=15, nanRep='NaN', formatters=None,
-                 float_format=None):
+                 columns=None, colSpace=15, nanRep='NaN',
+                 formatters=None, float_format=None):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
-        columns = sorted(series.keys())
+
+        if columns is None:
+            columns = sorted(series.keys())
+        else:
+            columns = [c for c in columns if c in self]
+
         formatters = formatters or {}
 
         # TODO
-
-        float_format = float_format or str
-        for c in columns:
-            if c not in formatters:
-                formatters[c] = str # float_format if c in self.columns else str
+        ident = lambda x: x
 
         if len(columns) == 0 or len(self.index) == 0:
             print >> buffer, 'Empty DataFrame'
@@ -555,16 +556,20 @@ class DataFrame(Picklable, Groupable):
             idxSpace = max([len(str(idx)) for idx in self.index]) + 4
             head = _pfixed('', idxSpace)
             if verbose:
-                colSpace = max([len(c) for c in self.columns]) + 4
+                colSpace = max([len(c) for c in columns]) + 4
+
             for h in columns:
                 head += _pfixed(h, colSpace)
+
             print >> buffer, head
+
             for idx in self.index:
                 ot = _pfixed(idx, idxSpace)
                 for k in columns:
-                    formatter = formatters.get(k, str)
+                    formatter = formatters.get(k, ident)
                     ot += _pfixed(formatter(series[k][idx]),
-                                  colSpace, nanRep=nanRep)
+                                  colSpace, nanRep=nanRep,
+                                  float_format=float_format)
                 print >> buffer, ot
 
     def info(self, buffer=sys.stdout):
@@ -742,9 +747,9 @@ class DataFrame(Picklable, Groupable):
             N = len(intersection)
 
             filtered = self.filterItems(intersection)
-            theCount = filtered.count(axis=1, asarray=True)
+            theCount = filtered.count(axis=1)
         else:
-            theCount = self.count(axis=1, asarray=True)
+            theCount = self.count(axis=1)
 
         if minObs is None:
             minObs = N
@@ -1009,10 +1014,8 @@ class DataFrame(Picklable, Groupable):
                                         for idx in self.index]),
                                         index=Index(self.cols()))
 
-    def diff(self, periods = 1):
-        temp = self.values
-        temp = temp[periods:] - temp[:-periods]
-        return self.fromMatrix(temp, self.cols(), self.index[periods:])
+    def diff(self, periods=1):
+        return self - self.shift(periods)
 
     def shift(self, periods, offset=None, timeRule=None):
         """
@@ -1427,8 +1430,16 @@ class DataFrame(Picklable, Groupable):
             s = self[col]
             plot(s.index, s, label=col)
 
+    def _get_axis(self, axis_num):
+        if axis_num == 0:
+            return self.columns
+        elif axis_num == 1:
+            return self.index
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
     # ndarray-like stats methods
-    def count(self, axis=0, asarray=False):
+    def count(self, axis=0):
         """
         Return array or Series of # observations over requested axis.
 
@@ -1436,8 +1447,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1449,17 +1458,9 @@ class DataFrame(Picklable, Groupable):
             f = lambda s: notnull(s).sum()
             theCount = self.apply(f, axis=axis)
 
-        if asarray:
-            return theCount
-        else:
-            if axis == 0:
-                return Series(theCount, index=self.columns)
-            elif axis == 1:
-                return Series(theCount, index=self.index)
-            else:
-                raise Exception('Must have 0<= axis <= 1')
+        return Series(theCount, index=self._get_axis(axis))
 
-    def sum(self, axis=0, asarray=False):
+    def sum(self, axis=0):
         """
         Return array or Series of sums over requested axis.
 
@@ -1467,8 +1468,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1499,14 +1498,7 @@ class DataFrame(Picklable, Groupable):
         except Exception:
             theSum = self.apply(np.sum, axis=axis)
 
-        if asarray:
-            return theSum
-        if axis == 0:
-            return Series(theSum, index=self.columns)
-        elif axis == 1:
-            return Series(theSum, index=self.index)
-        else:
-            raise Exception('Must have 0<= axis <= 1')
+        return Series(theSum, index=self._get_axis(axis))
 
     def cumsum(self, axis=0):
         """
@@ -1529,7 +1521,7 @@ class DataFrame(Picklable, Groupable):
 
         return self.apply(get_cumsum, axis=axis)
 
-    def product(self, axis=0, asarray=False):
+    def product(self, axis=0):
         """
         Return array or Series of products over requested axis.
 
@@ -1537,8 +1529,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1553,19 +1543,9 @@ class DataFrame(Picklable, Groupable):
             theCount = self.count(axis)
             theProd[theCount == 0] = NaN
         except Exception:
-            if axis == 0:
-                theProd = self.apply(np.prod)
-            else:
-                theProd = self.apply(np.prod, axis=1)
+            theProd = self.apply(np.prod, axis=axis)
 
-        if asarray:
-            return theProd
-        if axis == 0:
-            return Series(theProd, index=self.columns)
-        elif axis == 1:
-            return Series(theProd, index=self.index)
-        else:
-            raise Exception('Must have 0<= axis <= 1')
+        return Series(theProd, index=self._get_axis(axis))
 
     def mean(self, axis=0):
         """
@@ -1580,7 +1560,7 @@ class DataFrame(Picklable, Groupable):
         -------
         Series or TimeSeries
         """
-        return self.sum(axis) / self.count(axis, asarray=True).astype(float)
+        return self.sum(axis) / self.count(axis).values().astype(float)
 
     def median(self, axis=0):
         """
@@ -1648,7 +1628,7 @@ class DataFrame(Picklable, Groupable):
         else:
             raise Exception('Must have 0<= axis <= 1')
 
-    def mad(self, axis=0, asarray=False):
+    def mad(self, axis=0):
         """
         Return array or Series of mean absolute deviation over
         requested axis.
@@ -1657,8 +1637,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1676,15 +1654,12 @@ class DataFrame(Picklable, Groupable):
 
         result = np.abs(y).mean(axis=axis)
 
-        if asarray:
-            return result
-
         if axis == 0:
             return Series(result, demeaned.cols())
         else:
             return Series(result, demeaned.index)
 
-    def var(self, axis=0, asarray=False):
+    def var(self, axis=0):
         """
         Return array or Series of unbiased variance over requested axis.
 
@@ -1692,8 +1667,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1708,16 +1681,10 @@ class DataFrame(Picklable, Groupable):
         XX = (y**2).sum(axis)
 
         theVar = (XX - X**2 / count) / (count - 1)
-        if asarray:
-            return theVar
-        if axis == 0:
-            return Series(theVar, index=self.columns)
-        elif axis == 1:
-            return Series(theVar, index=self.index)
-        else:
-            raise Exception('Must have 0<= axis <= 1')
 
-    def std(self, axis=0, asarray=False):
+        return Series(theVar, index=self._get_axis(axis))
+
+    def std(self, axis=0):
         """
         Return array or Series of unbiased std deviation over requested axis.
 
@@ -1725,16 +1692,14 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
         Series or TimeSeries
         """
-        return np.sqrt(self.var(axis=axis, asarray=asarray))
+        return np.sqrt(self.var(axis=axis))
 
-    def skew(self, axis=0, asarray=False):
+    def skew(self, axis=0):
         """
         Return array or Series of unbiased skewness over requested axis.
 
@@ -1742,8 +1707,6 @@ class DataFrame(Picklable, Groupable):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
 
         Returns
         -------
@@ -1760,22 +1723,18 @@ class DataFrame(Picklable, Groupable):
 
         theSkew = (np.sqrt((count**2-count))*C) / ((count-2)*np.sqrt(B)**3)
 
-        if asarray:
-            return theSkew
-        if axis == 0:
-            return Series(theSkew, index=self.columns)
-        elif axis == 1:
-            return Series(theSkew, index=self.index)
-        else:
-            raise Exception('Must have 0<= axis <= 1')
+        return Series(theSkew, index=self._get_axis(axis))
 
-def _pfixed(s, space, nanRep=None):
+def _pfixed(s, space, nanRep=None, float_format=None):
     if isinstance(s, float):
-        fstring = '%-' + str(space-4) + 'g'
         if nanRep is not None and isnull(s):
             return nanRep.ljust(space)
 
-        return (fstring % s).ljust(space)
+        if float_format:
+            return float_format(s)
+        else:
+            fstring = '%.4g'
+            return (fstring % s).ljust(space)
     else:
         return str(s)[:space-4].ljust(space)
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 3e6bc4e98..0ce119450 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -362,10 +362,7 @@ class DataMatrix(DataFrame):
             columns = [c for c in columns if c in self]
             values = self.asMatrix(columns)
 
-        float_format = float_format or str
-        for c in columns:
-            if c not in formatters:
-                formatters[c] = float_format if c in self.columns else str
+        ident = lambda x: x
 
         idxSpace = max([len(str(idx)) for idx in self.index]) + 4
 
@@ -381,8 +378,9 @@ class DataMatrix(DataFrame):
             for i, idx in enumerate(self.index):
                 buffer.write(_pfixed(idx, idxSpace))
                 for j, col in enumerate(columns):
-                    formatter = formatters[col]
-                    buffer.write(_pfixed(formatter(values[i, j]), colSpace))
+                    formatter = formatters.get(col, ident)
+                    buffer.write(_pfixed(formatter(values[i, j]), colSpace,
+                                         float_format=float_format))
                 buffer.write('\n')
 
     def info(self, buffer=sys.stdout):
@@ -872,21 +870,31 @@ class DataMatrix(DataFrame):
         ndarray
         """
         if columns is None:
-            return self.values.copy()
+            values = self.values.copy()
+
+            if self.objects:
+                values = np.column_stack((values, self.objects.values))
+
+            return values
         else:
-            idxMap = self.columns.indexMap
-            indexer = [idxMap[col] for col in columns if col in idxMap]
-            values = self.values.take(indexer, axis=1)
+            if not isinstance(columns, Index):
+                columns = Index(columns)
+
+            values = self.values
+            order = self.columns
 
             if self.objects:
                 idxMap = self.objects.columns.indexMap
                 indexer = [idxMap[col] for col in columns if col in idxMap]
 
                 obj_values = self.objects.values.take(indexer, axis=1)
+
                 values = np.column_stack((values, obj_values))
+                order = Index(np.concatenate((order, self.objects.columns)))
 
                 # now put in the right order
-                # XXX!
+
+            values = _reorder_columns(values, order, columns)
 
             return values
 
@@ -908,7 +916,7 @@ class DataMatrix(DataFrame):
         return DataMatrix(valsCopy, index=self.index,
                           columns=self.columns, objects=self.objects)
 
-    def cumsum(self, axis=0, asarray=False):
+    def cumsum(self, axis=0):
         """
         Return DataMatrix of cumulative sums over requested axis.
 
@@ -916,15 +924,16 @@ class DataMatrix(DataFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
-        asarray : boolean, default False
-            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        y : DataMatrix
         """
         y = np.array(self.values, subok=True)
         if not issubclass(y.dtype.type, np.int_):
             y[np.isnan(self.values)] = 0
         theSum = y.cumsum(axis)
-        if asarray:
-            return theSum
+
         return DataMatrix(theSum, index=self.index,
                           columns=self.columns, objects=self.objects)
 
@@ -945,10 +954,9 @@ class DataMatrix(DataFrame):
         DataMatrix with rows containing any NaN values deleted
         """
         if specificColumns:
-            theCount = self.filterItems(specificColumns).count(axis=1,
-                                                               asarray=True)
+            theCount = self.filterItems(specificColumns).count(axis=1)
         else:
-            theCount = self.count(axis=1, asarray=True)
+            theCount = self.count(axis=1)
 
         return self.reindex(self.index[theCount > 0])
 
@@ -974,10 +982,10 @@ class DataMatrix(DataFrame):
         T, N = self.values.shape
         if specificColumns:
             cols = self.columns.intersection(specificColumns)
-            theCount = self.filterItems(cols).count(axis=1, asarray=True)
+            theCount = self.filterItems(cols).count(axis=1)
             N = len(cols)
         else:
-            theCount = self.count(axis=1, asarray=True)
+            theCount = self.count(axis=1)
 
         if minObs is None:
             minObs = N
@@ -1015,10 +1023,6 @@ class DataMatrix(DataFrame):
                 result[col] = filledSeries
             return DataMatrix(result, index=self.index, objects=self.objects)
         else:
-            def fillfunc(vec):
-                vec[isnull(vec)] = value
-                return vec
-
             gotFloat = isinstance(value, (int, float))
             if gotFloat and self.values.dtype == np.float64:
                 # Float type values
@@ -1026,32 +1030,27 @@ class DataMatrix(DataFrame):
                     return self
 
                 vals = self.values.copy()
-                vals[-np.isfinite(self.values)] = value
+                vals.flat[isnull(vals.ravel())] = value
+
                 objectsToUse = None
+
                 if self.objects is not None:
                     objectsToUse = self.objects.copy()
+
                 return DataMatrix(vals, index=self.index, columns=self.columns,
                                   objects=objectsToUse)
 
-            elif self.values.dtype == np.object_:
+            else:
                 # Object type values
                 if len(self.columns) == 0:
                     return self
 
-                myCopy = self.copy()
-
-                vals = myCopy.values
-                myCopy.values = np.apply_along_axis(fillfunc, 0, vals)
-
-                return myCopy
-            else:
-                # Object type values
-                if len(self.objects.columns) == 0:
-                    return self
+                # XXX
 
                 myCopy = self.copy()
-                vals = myCopy.objects.values
-                myCopy.objects.values = np.apply_along_axis(fillfunc, 0, vals)
+                vals = myCopy.values
+                vals = self.values.copy()
+                vals.flat[isnull(vals.ravel())] = value
 
                 return myCopy
 
@@ -1614,3 +1613,12 @@ class DataMatrix(DataFrame):
             seriesDict.update(frame._series)
 
         return DataMatrix(seriesDict, index=self.index)
+
+
+def _reorder_columns(mat, current, desired):
+    fillVec, mask = tseries.getFillVec(current, desired, current.indexMap,
+                                       desired.indexMap, '')
+
+    fillVec = fillVec[mask]
+
+    return mat.take(fillVec, axis=1)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index b66d819e4..1c071693f 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -666,7 +666,7 @@ class Series(np.ndarray, Picklable, Groupable):
         """
         return Series([func(x) for x in self], index=self.index)
 
-    def plot(self, label=None, kind='line', **kwds): # pragma: no cover
+    def plot(self, label=None, kind='line', rot=30, **kwds): # pragma: no cover
         """
         Plot the input series with the index on the x-axis using
         matplotlib / pylab.
@@ -715,7 +715,8 @@ class Series(np.ndarray, Picklable, Groupable):
             plt.bar(xinds, self.values(), 0.5, bottom=np.zeros(N), linewidth=1)
             fontsize = 12 if N < 10 else 10
 
-            plt.xticks(xinds + 0.25, self.index, rotation=30, fontsize=fontsize)
+            plt.xticks(xinds + 0.25, self.index, rotation=rot,
+                       fontsize=fontsize)
 
     def toCSV(self, path):
         """
@@ -793,7 +794,7 @@ class Series(np.ndarray, Picklable, Groupable):
         TimeSeries
         """
         if periods == 0:
-            return self
+            return self.copy()
 
         if timeRule is not None and offset is None:
             offset = datetools.getOffset(timeRule)
@@ -807,8 +808,6 @@ class Series(np.ndarray, Picklable, Groupable):
             elif periods < 0:
                 newValues[:periods] = self.values()[-periods:]
                 newValues[periods:] = np.NaN
-            else:
-                newValues = self.values().copy()
 
             return self.__class__(newValues, index=self.index)
         else:
diff --git a/pandas/core/tests/common.py b/pandas/core/tests/common.py
index c683bf81e..9ed3bd947 100644
--- a/pandas/core/tests/common.py
+++ b/pandas/core/tests/common.py
@@ -7,7 +7,7 @@ import string
 from numpy.random import randn
 import numpy as np
 
-from pandas.core.api import DateRange, Index, Series, DataFrame
+from pandas.core.api import DateRange, Index, Series, DataFrame, DataMatrix
 
 N = 30
 K = 4
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 842d5d3df..7e40135a5 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -179,11 +179,20 @@ class TestDataFrame(unittest.TestCase):
 
         foo = repr(biggie)
 
+    def test_toString(self):
+        # big mixed
+        biggie = self.klass({'A' : randn(1000),
+                             'B' : common.makeStringIndex(1000)},
+                            index=range(1000))
+
+        biggie['A'][:20] = np.NaN
+        biggie['B'][:20] = np.NaN
         buf = StringIO()
         biggie.toString(buffer=buf)
 
-    def test_toString(self):
-        pass
+        biggie.toString(buffer=buf, columns=['B', 'A'], colSpace=17)
+        biggie.toString(buffer=buf, columns=['B', 'A'],
+                        formatters={'A' : lambda x: '%.1f' % x})
 
     def test_getitem(self):
         # slicing
@@ -429,7 +438,7 @@ class TestDataFrame(unittest.TestCase):
         frame = self.frame
         mat = frame.asMatrix()
         smallerCols = ['C', 'A']
-        # smallerMat = frame.asMatrix(smallerCols)
+
         frameCols = frame.cols()
         for i, row in enumerate(mat):
             for j, value in enumerate(row):
@@ -439,6 +448,10 @@ class TestDataFrame(unittest.TestCase):
                 else:
                     self.assertEqual(value, frame[col][i])
 
+        # mixed type
+        mat = self.mixed_frame.asMatrix(['foo', 'A'])
+        self.assertEqual(mat[0, 0], 'bar')
+
     def test_values(self):
         pass
 
@@ -499,6 +512,12 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(np.isnan(padded['A'][:5]).all())
         self.assert_((padded['A'][-5:] == padded['A'][-5]).all())
 
+        # mixed type
+        self.mixed_frame['foo'][5:20] = np.NaN
+        self.mixed_frame['A'][-10:] = np.NaN
+
+        result = self.mixed_frame.fill(value=0)
+
     def test_getTS(self):
         frame = self.tsframe
 
@@ -567,7 +586,23 @@ class TestDataFrame(unittest.TestCase):
                 self.assertEqual(value, self.frame[item][idx])
 
     def test_pivot(self):
-        pass
+        data = {
+            'index' : ['A', 'B', 'C', 'C', 'B', 'A'],
+            'columns' : ['One', 'One', 'One', 'Two', 'Two', 'Two'],
+            'values' : [1., 2., 3., 3., 2., 1.]
+        }
+
+        frame = DataFrame(data)
+        pivoted = frame.pivot(index='index', columns='columns', values='values')
+
+        expected = DataFrame.fromDict({
+            'One' : {'A' : 1., 'B' : 2., 'C' : 3.},
+            'Two' : {'A' : 1., 'B' : 2., 'C' : 3.}
+        })
+
+        assert_frame_equal(pivoted, expected)
+
+        # corner cases
 
     def test_reindex(self):
         newFrame = self.frame.reindex(self.ts1.index)
@@ -646,7 +681,10 @@ class TestDataFrame(unittest.TestCase):
             self.assert_(s.dtype == np.object_)
 
     def test_diff(self):
-        pass
+        the_diff = self.tsframe.diff(1)
+
+        assert_series_equal(the_diff['A'],
+                            self.tsframe['A'] - self.tsframe['A'].shift(1))
 
     def test_shift(self):
         # naive shift
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 560014b03..749ba5933 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -57,6 +57,17 @@ class TestDataMatrix(test_frame.TestDataFrame):
     def test_more_fromDict(self):
         pass
 
+    def test_fill_corner(self):
+        self.mixed_frame['foo'][5:20] = np.NaN
+        self.mixed_frame['A'][-10:] = np.NaN
+
+        obj_result = self.mixed_frame.objects.fill(value=0)
+
+        del self.mixed_frame['foo']
+
+        # XXX
+        obj_result = self.mixed_frame.objects.fill(value=0)
+
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 451a8b589..f7db9a2d1 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -461,6 +461,10 @@ class TestSeries(unittest.TestCase):
 
         common.assert_series_equal(unshifted, self.ts)
 
+        # corner case
+        unshifted = self.ts.shift(0)
+        common.assert_series_equal(unshifted, self.ts)
+
     def test_truncate(self):
         offset = datetools.bday
 

commit 87126b9b5a384842cdfe1f9faa63289e8b35727c
Author: y-p <yoval@gmx.com>
Date:   Fri Dec 14 07:57:48 2012 +0200

    BUG: make sure pd.options style access triggers warnings and callbacks as needed

diff --git a/pandas/core/config.py b/pandas/core/config.py
index 8eb5afc4a..7c3823bc4 100644
--- a/pandas/core/config.py
+++ b/pandas/core/config.py
@@ -141,23 +141,33 @@ def _reset_option(pat):
 class DictWrapper(object):
     """ provide attribute-style access to a nested dict
     """
-    def __init__(self,d):
+    def __init__(self,d,prefix=""):
         object.__setattr__(self,"d",d)
+        object.__setattr__(self,"prefix",prefix)
 
     def __setattr__(self,key,val):
+        prefix = object.__getattribute__(self,"prefix")
+        if prefix:
+            prefix += "."
+        prefix += key
         # you can't set new keys
         # can you can't overwrite subtrees
         if key in self.d and not isinstance(self.d[key],dict):
+            _set_option(prefix,val)
             self.d[key]=val
         else:
             raise KeyError("You can only set the value of existing options")
 
     def __getattr__(self,key):
+        prefix = object.__getattribute__(self,"prefix")
+        if prefix:
+            prefix += "."
+        prefix += key
         v=object.__getattribute__(self,"d")[key]
         if isinstance(v,dict):
-            return DictWrapper(v)
+            return DictWrapper(v,prefix)
         else:
-            return v
+            return _get_option(prefix)
 
     def __dir__(self):
         return self.d.keys()
@@ -366,6 +376,7 @@ def register_option(key, defval, doc='', validator=None, cb=None):
         raise KeyError("Path prefix to option '%s' is already an option"
                        % '.'.join(path[:-1]))
 
+
     cursor[path[-1]] = defval  # initialize
 
     # save the option metadata
diff --git a/pandas/tests/test_config.py b/pandas/tests/test_config.py
index 91318421b..f5a110ef4 100644
--- a/pandas/tests/test_config.py
+++ b/pandas/tests/test_config.py
@@ -325,11 +325,16 @@ class TestConfig(unittest.TestCase):
         eq(17)
 
     def test_attribute_access(self):
+        holder = []
         def f():
             options.b=1
         def f2():
             options.display=1
+        def f3(key):
+            holder.append(True)
+
         self.cf.register_option('a',0)
+        self.cf.register_option('c',0,cb=f3)
         options=self.cf.options
 
         self.assertEqual(options.a,0)
@@ -345,5 +350,9 @@ class TestConfig(unittest.TestCase):
         self.assertRaises(KeyError,f)
         self.assertRaises(KeyError,f2)
 
+        # make sure callback kicks when using this form of setting
+        options.c = 1
+        self.assertEqual(len(holder),1)
+
 # fmt.reset_printoptions and fmt.set_printoptions were altered
 # to use core.config, test_format exercises those paths.

commit 734b6d1346bd1ee9a480946c08607dadd4b14cb3
Author: Matthew Roeschke <emailformattr@gmail.com>
Date:   Sun Jun 30 13:57:01 2019 -0500

    CLN: Remove cdate_range, raise_on_error keyword, categories and ordered keywords in astype (#27141)
    
    * Remove raise_on_error
    
    * Removed categories and ordered keywords in astype
    
    * Remove cdate_range
    
    * Remove unused import

diff --git a/doc/source/user_guide/timeseries.rst b/doc/source/user_guide/timeseries.rst
index fcad6db94..ce02059cd 100644
--- a/doc/source/user_guide/timeseries.rst
+++ b/doc/source/user_guide/timeseries.rst
@@ -474,16 +474,6 @@ resulting ``DatetimeIndex``:
 Custom frequency ranges
 ~~~~~~~~~~~~~~~~~~~~~~~
 
-.. warning::
-
-   This functionality was originally exclusive to ``cdate_range``, which is
-   deprecated as of version 0.21.0 in favor of ``bdate_range``.  Note that
-   ``cdate_range`` only utilizes the ``weekmask`` and ``holidays`` parameters
-   when custom business day, 'C', is passed as the frequency string. Support has
-   been expanded with ``bdate_range`` to work with any custom frequency string.
-
-.. versionadded:: 0.21.0
-
 ``bdate_range`` can also generate a range of custom frequency dates by using
 the ``weekmask`` and ``holidays`` parameters.  These parameters will only be
 used if a custom frequency string is passed.
diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index a91a298f9..e42752cca 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -637,6 +637,9 @@ Removal of prior version deprecations/changes
 - Removed the previously deprecated behavior of altering column or index labels with :meth:`Series.rename_axis` or :meth:`DataFrame.rename_axis` (:issue:`17842`)
 - Removed the previously deprecated ``tupleize_cols`` keyword argument in :meth:`read_html`, :meth:`read_csv`, and :meth:`DataFrame.to_csv` (:issue:`17877`, :issue:`17820`)
 - Removed the previously deprecated ``DataFrame.from.csv`` and ``Series.from_csv`` (:issue:`17812`)
+- Removed the previously deprecated ``raise_on_error`` keyword argument in :meth:`DataFrame.where` and :meth:`DataFrame.mask` (:issue:`17744`)
+- Removed the previously deprecated ``ordered`` and ``categories`` keyword arguments in ``astype`` (:issue:`17742`)
+- Removed the previously deprecated ``cdate_range`` (:issue:`17691`)
 
 .. _whatsnew_0250.performance:
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 166d85264..841131b69 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -8644,13 +8644,6 @@ class NDFrame(PandasObject, SelectionMixin):
 
         try_cast : bool, default False
             Try to cast the result back to the input type (if possible).
-        raise_on_error : bool, default True
-            Whether to raise on invalid data types (e.g. trying to where on
-            strings).
-
-            .. deprecated:: 0.21.0
-
-               Use `errors`.
 
         Returns
         -------
@@ -8738,18 +8731,7 @@ class NDFrame(PandasObject, SelectionMixin):
                                            cond_rev="False", name='where',
                                            name_other='mask'))
     def where(self, cond, other=np.nan, inplace=False, axis=None, level=None,
-              errors='raise', try_cast=False, raise_on_error=None):
-
-        if raise_on_error is not None:
-            warnings.warn(
-                "raise_on_error is deprecated in "
-                "favor of errors='raise|ignore'",
-                FutureWarning, stacklevel=2)
-
-            if raise_on_error:
-                errors = 'raise'
-            else:
-                errors = 'ignore'
+              errors='raise', try_cast=False):
 
         other = com.apply_if_callable(other, self)
         return self._where(cond, other, inplace, axis, level,
@@ -8759,18 +8741,7 @@ class NDFrame(PandasObject, SelectionMixin):
                                            cond_rev="True", name='mask',
                                            name_other='where'))
     def mask(self, cond, other=np.nan, inplace=False, axis=None, level=None,
-             errors='raise', try_cast=False, raise_on_error=None):
-
-        if raise_on_error is not None:
-            warnings.warn(
-                "raise_on_error is deprecated in "
-                "favor of errors='raise|ignore'",
-                FutureWarning, stacklevel=2)
-
-            if raise_on_error:
-                errors = 'raise'
-            else:
-                errors = 'ignore'
+             errors='raise', try_cast=False):
 
         inplace = validate_bool_kwarg(inplace, 'inplace')
         cond = com.apply_if_callable(cond, self)
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 5ce670d9f..e2658b66f 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -29,7 +29,7 @@ from pandas.core.ops import get_op_result_name
 import pandas.core.tools.datetimes as tools
 
 from pandas.tseries.frequencies import Resolution, to_offset
-from pandas.tseries.offsets import CDay, Nano, prefix_mapping
+from pandas.tseries.offsets import Nano, prefix_mapping
 
 
 def _new_DatetimeIndex(cls, d):
@@ -1568,66 +1568,6 @@ def bdate_range(start=None, end=None, periods=None, freq='B', tz=None,
                       closed=closed, **kwargs)
 
 
-def cdate_range(start=None, end=None, periods=None, freq='C', tz=None,
-                normalize=True, name=None, closed=None, **kwargs):
-    """
-    Return a fixed frequency DatetimeIndex, with CustomBusinessDay as the
-    default frequency
-
-    .. deprecated:: 0.21.0
-
-    Parameters
-    ----------
-    start : string or datetime-like, default None
-        Left bound for generating dates
-    end : string or datetime-like, default None
-        Right bound for generating dates
-    periods : integer, default None
-        Number of periods to generate
-    freq : string or DateOffset, default 'C' (CustomBusinessDay)
-        Frequency strings can have multiples, e.g. '5H'
-    tz : string, default None
-        Time zone name for returning localized DatetimeIndex, for example
-        Asia/Beijing
-    normalize : bool, default False
-        Normalize start/end dates to midnight before generating date range
-    name : string, default None
-        Name of the resulting DatetimeIndex
-    weekmask : string, Default 'Mon Tue Wed Thu Fri'
-        weekmask of valid business days, passed to ``numpy.busdaycalendar``
-    holidays : list
-        list/array of dates to exclude from the set of valid business days,
-        passed to ``numpy.busdaycalendar``
-    closed : string, default None
-        Make the interval closed with respect to the given frequency to
-        the 'left', 'right', or both sides (None)
-
-    Notes
-    -----
-    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two
-    must be specified.
-
-    To learn more about the frequency strings, please see `this link
-    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.
-
-    Returns
-    -------
-    rng : DatetimeIndex
-    """
-    warnings.warn("cdate_range is deprecated and will be removed in a future "
-                  "version, instead use pd.bdate_range(..., freq='{freq}')"
-                  .format(freq=freq), FutureWarning, stacklevel=2)
-
-    if freq == 'C':
-        holidays = kwargs.pop('holidays', [])
-        weekmask = kwargs.pop('weekmask', 'Mon Tue Wed Thu Fri')
-        freq = CDay(holidays=holidays, weekmask=weekmask)
-
-    return date_range(start=start, end=end, periods=periods, freq=freq,
-                      tz=tz, normalize=normalize, name=name,
-                      closed=closed, **kwargs)
-
-
 def _time_to_micros(time):
     seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
     return 1000000 * seconds + time.microsecond
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index f0128b70d..36390d467 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -542,17 +542,10 @@ class Block(PandasObject):
         if self.is_categorical_astype(dtype):
 
             # deprecated 17636
-            if ('categories' in kwargs or 'ordered' in kwargs):
-                if isinstance(dtype, CategoricalDtype):
-                    raise TypeError(
-                        "Cannot specify a CategoricalDtype and also "
-                        "`categories` or `ordered`. Use "
-                        "`dtype=CategoricalDtype(categories, ordered)`"
-                        " instead.")
-                warnings.warn("specifying 'categories' or 'ordered' in "
-                              ".astype() is deprecated; pass a "
-                              "CategoricalDtype instead",
-                              FutureWarning, stacklevel=7)
+            for deprecated_arg in ('categories', 'ordered'):
+                if deprecated_arg in kwargs:
+                    raise ValueError('Got an unexpected argument: {}'.format(
+                        deprecated_arg))
 
             categories = kwargs.get('categories', None)
             ordered = kwargs.get('ordered', None)
diff --git a/pandas/tests/api/test_api.py b/pandas/tests/api/test_api.py
index b57c7a0cf..6ed1284ff 100644
--- a/pandas/tests/api/test_api.py
+++ b/pandas/tests/api/test_api.py
@@ -131,13 +131,3 @@ class TestTesting(Base):
 
         from pandas import testing
         self.check(testing, self.funcs)
-
-
-class TestCDateRange:
-
-    def test_deprecation_cdaterange(self):
-        # GH17596
-        from pandas.core.indexes.datetimes import cdate_range
-        with tm.assert_produces_warning(FutureWarning,
-                                        check_stacklevel=False):
-            cdate_range('2017-01-01', '2017-12-31')
diff --git a/pandas/tests/series/indexing/test_boolean.py b/pandas/tests/series/indexing/test_boolean.py
index 43dc29265..ef7312616 100644
--- a/pandas/tests/series/indexing/test_boolean.py
+++ b/pandas/tests/series/indexing/test_boolean.py
@@ -229,17 +229,6 @@ def test_where_unsafe():
     assert_series_equal(result, expected)
 
 
-def test_where_raise_on_error_deprecation():
-    # gh-14968
-    # deprecation of raise_on_error
-    s = Series(np.random.randn(5))
-    cond = s > 0
-    with tm.assert_produces_warning(FutureWarning):
-        s.where(cond, raise_on_error=True)
-    with tm.assert_produces_warning(FutureWarning):
-        s.mask(cond, raise_on_error=True)
-
-
 def test_where():
     s = Series(np.random.randn(5))
     cond = s > 0
diff --git a/pandas/tests/series/test_dtypes.py b/pandas/tests/series/test_dtypes.py
index b9146534d..59566ad32 100644
--- a/pandas/tests/series/test_dtypes.py
+++ b/pandas/tests/series/test_dtypes.py
@@ -223,15 +223,12 @@ class TestSeriesDtypes:
         with pytest.raises(KeyError, match=msg):
             s.astype(dt5)
 
-    def test_astype_categories_deprecation(self):
+    def test_astype_categories_deprecation_raises(self):
 
         # deprecated 17636
         s = Series(['a', 'b', 'a'])
-        expected = s.astype(CategoricalDtype(['a', 'b'], ordered=True))
-        with tm.assert_produces_warning(FutureWarning,
-                                        check_stacklevel=False):
-            result = s.astype('category', categories=['a', 'b'], ordered=True)
-        tm.assert_series_equal(result, expected)
+        with pytest.raises(ValueError, match="Got an unexpected"):
+            s.astype('category', categories=['a', 'b'], ordered=True)
 
     def test_astype_from_categorical(self):
         items = ["a", "b", "c", "a"]
@@ -349,21 +346,12 @@ class TestSeriesDtypes:
         expected = Series(s_data, name=name, dtype=exp_dtype)
         tm.assert_series_equal(result, expected)
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = s.astype('category', ordered=dtype_ordered)
-        tm.assert_series_equal(result, expected)
-
         # different categories
         dtype = CategoricalDtype(list('adc'), dtype_ordered)
         result = s.astype(dtype)
         expected = Series(s_data, name=name, dtype=dtype)
         tm.assert_series_equal(result, expected)
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = s.astype(
-                'category', categories=list('adc'), ordered=dtype_ordered)
-        tm.assert_series_equal(result, expected)
-
         if dtype_ordered is False:
             # not specifying ordered, so only test once
             expected = s
@@ -387,20 +375,6 @@ class TestSeriesDtypes:
         tm.assert_series_equal(result, expected)
         tm.assert_index_equal(result.cat.categories, Index(['a', 'b', 'c']))
 
-    def test_astype_categoricaldtype_with_args(self):
-        s = Series(['a', 'b'])
-        type_ = CategoricalDtype(['a', 'b'])
-
-        msg = (r"Cannot specify a CategoricalDtype and also `categories` or"
-               r" `ordered`\. Use `dtype=CategoricalDtype\(categories,"
-               r" ordered\)` instead\.")
-        with pytest.raises(TypeError, match=msg):
-            s.astype(type_, ordered=True)
-        with pytest.raises(TypeError, match=msg):
-            s.astype(type_, categories=['a', 'b'])
-        with pytest.raises(TypeError, match=msg):
-            s.astype(type_, categories=['a', 'b'], ordered=False)
-
     @pytest.mark.parametrize("dtype", [
         np.datetime64,
         np.timedelta64,

commit 155975e40685be90015523eb57c7a15b266793e5
Author: jreback <jeff@reback.net>
Date:   Tue Dec 25 12:51:32 2012 -0500

    BUG/ENH: explicity support Series construction with a datetime64 dtype (and allow np.nan) to be passed
             e.g. Series(np.nan,index=range(5),dtype='M8[ns]')
             bugfix in core/frame for applymap, handle dtype=M8[ns] series explicity (needed to cast datetim64 to Timestamp)

diff --git a/pandas/core/common.py b/pandas/core/common.py
index e380ed4d0..eb7cbd663 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -628,6 +628,29 @@ def _consensus_name_attr(objs):
 #----------------------------------------------------------------------
 # Lots of little utilities
 
+def _possibly_cast_to_datetime(value, dtype):
+    """ try to cast the array/value to a datetimelike dtype, converting float nan to iNaT """
+
+    if dtype == 'M8[ns]':
+        import pandas.tslib as tslib
+        if np.isscalar(value):
+            if value == tslib.iNaT or isnull(value):
+                value = tslib.iNaT
+        else:
+            value = np.array(value)
+
+            # have a scalar array-like (e.g. NaT)
+            if value.ndim == 0:
+                value = tslib.iNaT
+
+            # we have an array of datetime & nulls
+            elif np.prod(value.shape):
+                try:
+                    value = tslib.array_to_datetime(value)
+                except:
+                    pass
+            
+    return value
 
 def _infer_dtype(value):
     if isinstance(value, (float, np.floating)):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index b9617cd91..2f2eb8cbf 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -4235,7 +4235,14 @@ class DataFrame(NDFrame):
         -------
         applied : DataFrame
         """
-        return self.apply(lambda x: lib.map_infer(x, func))
+        
+        # if we have a dtype == 'M8[ns]', provide boxed values
+        def infer(x):
+            if x.dtype == 'M8[ns]':
+                from pandas import Timestamp
+                return [ func(Timestamp(e)) for e in x ]
+            return lib.map_infer(x, func)
+        return self.apply(infer)
 
     #----------------------------------------------------------------------
     # Merging / joining methods
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index c096df915..53eb18c12 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -4,7 +4,6 @@ from pandas.core.common import _asarray_tuplesafe
 from pandas.core.index import Index, MultiIndex
 import pandas.core.common as com
 import pandas.lib as lib
-import pandas.tslib as tslib
 
 import numpy as np
 
@@ -112,24 +111,15 @@ class _NDFrameIndexer(object):
                     data = self.obj[item]
                     values = data.values
                     if np.prod(values.shape):
+                        value = com._possibly_cast_to_datetime(value,getattr(data,'dtype',None))
                         values[plane_indexer] = value
             except ValueError:
+                for item, v in zip(item_labels[het_idx], value):
+                    data = self.obj[item]
+                    values = data.values
+                    if np.prod(values.shape):
+                        values[plane_indexer] = v
 
-                # convert nan to iNaT if possible
-                if data.dtype == 'M8[ns]':
-                    mask = com._isnull(value)
-                    if np.isscalar(value) and com.isnull(value):
-                        value = tslib.iNaT
-                        values[plane_indexer] = value
-                    else:
-                        raise ValueError("Cannot set indexer value of datetime64[ns] with [%s]" % value)
-
-                else:
-                    for item, v in zip(item_labels[het_idx], value):
-                        data = self.obj[item]
-                        values = data.values
-                        if np.prod(values.shape):
-                            values[plane_indexer] = v
         else:
             if isinstance(indexer, tuple):
                 indexer = _maybe_convert_ix(*indexer)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 67cda3757..57844656b 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -463,12 +463,13 @@ def make_block(values, items, ref_items):
 
     # try to infer a datetimeblock
     if klass is None and np.prod(values.shape):
-        inferred_type = lib.infer_dtype(values.flatten())
+        flat = values.flatten()
+        inferred_type = lib.infer_dtype(flat)
         if inferred_type == 'datetime':
 
             # we have an object array that has been inferred as datetime, so convert it
             try:
-                values = tslib.array_to_datetime(values.flatten()).reshape(values.shape)
+                values = tslib.array_to_datetime(flat).reshape(values.shape)
                 klass = DatetimeBlock
             except: # it already object, so leave it
                 pass
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 242903210..9e0e05712 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2992,12 +2992,13 @@ def _sanitize_array(data, index, dtype=None, copy=False,
 
     def _try_cast(arr):
         try:
-            subarr = np.array(data, dtype=dtype, copy=copy)
+            arr = com._possibly_cast_to_datetime(arr, dtype)
+            subarr = np.array(arr, dtype=dtype, copy=copy)
         except (ValueError, TypeError):
             if dtype is not None and raise_cast_failure:
                 raise
             else:  # pragma: no cover
-                subarr = np.array(data, dtype=object, copy=copy)
+                subarr = np.array(arr, dtype=object, copy=copy)
         return subarr
 
     # GH #846
@@ -3056,6 +3057,8 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                 value, dtype = _dtype_from_scalar(value)
                 subarr = np.empty(len(index), dtype=dtype)
             else:
+                # need to possibly convert the value here
+                value  = com._possibly_cast_to_datetime(value, dtype)
                 subarr = np.empty(len(index), dtype=dtype)
             subarr.fill(value)
         else:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index b6c38ab98..462812296 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1093,6 +1093,10 @@ class CheckIndexing(object):
         df.ix['c','timestamp'] = nan
         self.assert_(com.isnull(df.ix['c','timestamp']))
 
+        # allow this syntax
+        df.ix['d',:] = nan
+        self.assert_(com.isnull(df.ix['c',:]).all() == False)
+
         # try to set with a list like item
         self.assertRaises(Exception,  df.ix.__setitem__, ('d','timestamp'), [nan])
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index f0112e1ee..0ac32371c 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -351,6 +351,26 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         s2[1] = 5
         self.assertEquals(s[1], 5)
 
+    def test_constructor_dtype_datetime64(self):
+        import pandas.tslib as tslib
+
+        s = Series(tslib.iNaT,dtype='M8[ns]',index=range(5))
+        self.assert_(isnull(s).all() == True)
+
+        s = Series(tslib.NaT,dtype='M8[ns]',index=range(5))
+        self.assert_(isnull(s).all() == True)
+
+        s = Series(nan,dtype='M8[ns]',index=range(5))
+        self.assert_(isnull(s).all() == True)
+
+        s = Series([ datetime(2001,1,2,0,0), tslib.iNaT ],dtype='M8[ns]')
+        self.assert_(isnull(s[1]) == True)
+        self.assert_(s.dtype == 'M8[ns]')
+
+        s = Series([ datetime(2001,1,2,0,0), nan ],dtype='M8[ns]')
+        self.assert_(isnull(s[1]) == True)
+        self.assert_(s.dtype == 'M8[ns]')
+
     def test_constructor_dict(self):
         d = {'a' : 0., 'b' : 1., 'c' : 2.}
         result = Series(d, index=['b', 'c', 'd', 'a'])
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 729689dab..01e9197af 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -2079,7 +2079,7 @@ class TestLegacySupport(unittest.TestCase):
         df = df.applymap(lambda x: x+BDay())
         df = df.applymap(lambda x: x+BDay())
 
-        self.assertTrue(df.x1.dtype == object)
+        self.assertTrue(df.x1.dtype == 'M8[ns]')
 
 
 class TestLegacyCompat(unittest.TestCase):

commit c47bc50bef5b083f0aac64df5338c3fc642b2ab5
Author: jreback <jeff@reback.net>
Date:   Mon May 20 17:45:26 2013 -0400

    CLN: did not need to convert to index array/slicer as the only
    
         time this happens is when a boolean array comes back from get_loc,
         means the index is non_monotonic, which is an exception in any event

diff --git a/pandas/core/index.py b/pandas/core/index.py
index cad1186c6..3a6913a92 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1222,10 +1222,7 @@ class Index(np.ndarray):
 
         is_unique = self.is_unique
         if start is None:
-            if is_unique:
-                start_slice = 0
-            else:
-                start_slice = np.arange(len(self))
+            start_slice = 0
         else:
             try:
                 start_slice = self.get_loc(start)
@@ -1235,21 +1232,10 @@ class Index(np.ndarray):
                     # get_loc will return a boolean array for non_uniques
                     # if we are not monotonic
                     if isinstance(start_slice,np.ndarray):
-                        if not self.is_monotonic:
-                            raise KeyError("cannot peform a slice operation "
-                                           "on a non-unique non-monotonic index")
-                        start_slice = np.arange(len(self))[start_slice]
-
-                    # select all in the slice + all the rest of the entries
-                    # to the right
-                    elif isinstance(start_slice, slice):
-                        ss = np.arange(start_slice.stop,len(self))
-                        start_slice = np.arange(len(self))[start_slice]
-                        start_slice = (Index(ss) | Index(start_slice)).values
-                    else:
-                        start_slice = np.arange(start_slice,len(self))
+                        raise KeyError("cannot peform a slice operation "
+                                       "on a non-unique non-monotonic index")
 
-                elif isinstance(start_slice, slice):
+                if isinstance(start_slice, slice):
                     start_slice = start_slice.start
 
             except KeyError:
@@ -1259,10 +1245,7 @@ class Index(np.ndarray):
                     raise
 
         if end is None:
-            if is_unique:
-                end_slice = len(self)
-            else:
-                end_slice = np.arange(len(self))
+            end_slice = len(self)
         else:
             try:
                 end_slice = self.get_loc(end)
@@ -1271,20 +1254,10 @@ class Index(np.ndarray):
 
                     # get_loc will return a boolean array for non_uniques
                     if isinstance(end_slice,np.ndarray):
-                        if not self.is_monotonic:
-                            raise KeyError("cannot perform a slice operation "
-                                           "on a non-unique non-monotonic index")
-                        end_slice = np.arange(len(self))[end_slice]
-                        
-                    # select all in the slice + all to the left of the entries
-                    elif isinstance(end_slice, slice):
-                        es = np.arange(0,end_slice.start)
-                        end_slice = np.arange(len(self))[end_slice]
-                        end_slice = (Index(es) | Index(end_slice)).values
-                    else:
-                        end_slice = np.arange(0,end_slice+1)
+                        raise KeyError("cannot perform a slice operation "
+                                       "on a non-unique non-monotonic index")
 
-                elif isinstance(end_slice, slice):
+                if isinstance(end_slice, slice):
                     end_slice = end_slice.stop
                 else:
                     end_slice += 1
@@ -1295,16 +1268,6 @@ class Index(np.ndarray):
                 else:
                     raise
 
-        if not is_unique:
-            # see if we can convert back to and edge slice
-            if len(start_slice) == len(end_slice) and (start_slice == end_slice).all():
-                start_slice, end_slice = start_slice[0], start_slice[-1]+1
-            # partial slice
-            elif (len(start_slice) == start_slice[-1]-start_slice[0]+1) and (
-                len(end_slice) == end_slice[-1]-end_slice[0]+1):
-                res = (Index(start_slice) & Index(end_slice)).values
-                start_slice, end_slice = res[0],res[-1]+1
-
         return start_slice, end_slice
 
     def delete(self, loc):

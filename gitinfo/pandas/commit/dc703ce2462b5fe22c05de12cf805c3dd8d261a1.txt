commit dc703ce2462b5fe22c05de12cf805c3dd8d261a1
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Jan 5 06:53:44 2019 -0800

    Have Categorical ops defer to DataFrame; broken off of #24282 (#24630)

diff --git a/doc/source/whatsnew/v0.24.0.rst b/doc/source/whatsnew/v0.24.0.rst
index d13ab14e4..8bcb97ec0 100644
--- a/doc/source/whatsnew/v0.24.0.rst
+++ b/doc/source/whatsnew/v0.24.0.rst
@@ -1421,6 +1421,7 @@ Categorical
 - Bug in many methods of the ``.str``-accessor, which always failed on calling the ``CategoricalIndex.str`` constructor (:issue:`23555`, :issue:`23556`)
 - Bug in :meth:`Series.where` losing the categorical dtype for categorical data (:issue:`24077`)
 - Bug in :meth:`Categorical.apply` where ``NaN`` values could be handled unpredictably. They now remain unchanged (:issue:`24241`)
+- Bug in :class:`Categorical` comparison methods incorrectly raising ``ValueError`` when operating against a :class:`DataFrame` (:issue:`24630`)
 
 Datetimelike
 ^^^^^^^^^^^^
diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 969add2d3..ceab3d0f5 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -23,7 +23,7 @@ from pandas.core.dtypes.common import (
     is_timedelta64_dtype)
 from pandas.core.dtypes.dtypes import CategoricalDtype
 from pandas.core.dtypes.generic import (
-    ABCCategoricalIndex, ABCIndexClass, ABCSeries)
+    ABCCategoricalIndex, ABCDataFrame, ABCIndexClass, ABCSeries)
 from pandas.core.dtypes.inference import is_hashable
 from pandas.core.dtypes.missing import isna, notna
 
@@ -59,9 +59,11 @@ def _cat_compare_op(op):
         # results depending whether categories are the same or not is kind of
         # insane, so be a bit stricter here and use the python3 idea of
         # comparing only things of equal type.
-        if isinstance(other, ABCSeries):
+        if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
             return NotImplemented
 
+        other = lib.item_from_zerodim(other)
+
         if not self.ordered:
             if op in ['__lt__', '__gt__', '__le__', '__ge__']:
                 raise TypeError("Unordered Categoricals can only compare "
@@ -105,7 +107,6 @@ def _cat_compare_op(op):
         #
         # With cat[0], for example, being ``np.int64(1)`` by the time it gets
         # into this function would become ``np.array(1)``.
-        other = lib.item_from_zerodim(other)
         if is_scalar(other):
             if other in self.categories:
                 i = self.categories.get_loc(other)
diff --git a/pandas/tests/arrays/categorical/test_operators.py b/pandas/tests/arrays/categorical/test_operators.py
index 9304df58b..b2965bbcc 100644
--- a/pandas/tests/arrays/categorical/test_operators.py
+++ b/pandas/tests/arrays/categorical/test_operators.py
@@ -1,4 +1,5 @@
 # -*- coding: utf-8 -*-
+import operator
 
 import numpy as np
 import pytest
@@ -113,9 +114,34 @@ class TestCategoricalOpsWithFactor(TestCategorical):
         res = cat_rev > "b"
         tm.assert_numpy_array_equal(res, exp)
 
+        # check that zero-dim array gets unboxed
+        res = cat_rev > np.array("b")
+        tm.assert_numpy_array_equal(res, exp)
+
 
 class TestCategoricalOps(object):
 
+    def test_compare_frame(self):
+        # GH#24282 check that Categorical.__cmp__(DataFrame) defers to frame
+        data = ["a", "b", 2, "a"]
+        cat = Categorical(data)
+
+        df = DataFrame(cat)
+
+        for op in [operator.eq, operator.ne, operator.ge,
+                   operator.gt, operator.le, operator.lt]:
+            with pytest.raises(ValueError):
+                # alignment raises unless we transpose
+                op(cat, df)
+
+        result = cat == df.T
+        expected = DataFrame([[True, True, True, True]])
+        tm.assert_frame_equal(result, expected)
+
+        result = cat[::-1] != df.T
+        expected = DataFrame([[False, True, True, False]])
+        tm.assert_frame_equal(result, expected)
+
     def test_datetime_categorical_comparison(self):
         dt_cat = Categorical(date_range('2014-01-01', periods=3), ordered=True)
         tm.assert_numpy_array_equal(dt_cat > dt_cat[0],

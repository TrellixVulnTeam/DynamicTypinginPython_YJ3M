commit 1b52b1218e973382ea958084c47c3f33eb0ed40c
Author: Joel Nothman <joel.nothman@gmail.com>
Date:   Wed Apr 19 21:00:21 2017 -0400

    ENH: support Styler in ExcelFormatter
    
    closes #1663
    
    Author: Joel Nothman <joel.nothman@gmail.com>
    
    Closes #15530 from jnothman/excel_style and squashes the following commits:
    
    c7a51ca [Joel Nothman] Test currently fails on openpyxl1 due to version incompatibilities
    836f39e [Joel Nothman] Revert changes to xlwt
    de53808 [Joel Nothman] Remove debug code
    a5d51f9 [Joel Nothman] Merge branch 'master' into excel_style
    934df06 [Joel Nothman] Display df, not styled
    6465913 [Joel Nothman] More pytest-like test_styler_to_excel; enhancements to xlwt
    6168765 [Joel Nothman] Recommended changes to what's new
    9669d7d [Joel Nothman] Require jinja in test with df.style
    14035c5 [Joel Nothman] Merge branch 'master' into excel_style
    3071bac [Joel Nothman] Complete tests
    ceb9171 [Joel Nothman] reasons for xfails
    e2cfa77 [Joel Nothman] Test Styler.to_excel
    d5db0ac [Joel Nothman] Remove obsolete TODO
    0256fc6 [Joel Nothman] Return after unhandled font size warning
    60d6a3b [Joel Nothman] add doc/source/styled.xlsx to the gitignore
    4e72993 [Joel Nothman] Fix what's new heading
    d144fdf [Joel Nothman] Font name strings
    61fdc69 [Joel Nothman] Complete testing basic CSS -> Excel conversions
    6ff8a46 [Joel Nothman] Fix loose character; sorry
    6d3ffc6 [Joel Nothman] Lint
    79eae41 [Joel Nothman] Documentation tweaks
    c4f59c6 [Joel Nothman] Doc tweaks
    2c3d015 [Joel Nothman] Fix JSON syntax in IPynb
    b1d774b [Joel Nothman] What's new heading
    096f26c [Joel Nothman] Merge remote-tracking branch 'upstream/master' into excel_style
    433be03 [Joel Nothman] Documentation
    9a62699 [Joel Nothman] Fix tests and add TODOs to tests
    7c54a69 [Joel Nothman] Fix test failures; avoid hair border which renders strangely
    8e9a567 [Joel Nothman] Fixes from integration testing
    c1fc232 [Joel Nothman] Remove debugging print statements
    a43d6b7 [Joel Nothman] Cleaner imports
    a1127f6 [Joel Nothman] Merge branch 'master' into excel_style
    306eebe [Joel Nothman] Module-level docstring
    350eab5 [Joel Nothman] remove spurious blank line
    efce9b6 [Joel Nothman] More CSS to Excel testing; define ExcelFormatter.write
    f17a0f4 [Joel Nothman] Some border style tests
    1a8818f [Joel Nothman] Lint
    9a5b791 [Joel Nothman] Fix testing ImportError
    1984cab [Joel Nothman] Fix making get_level_lengths non-private
    eb02cc1 [Joel Nothman] Fix testing ImportError
    3b26087 [Joel Nothman] Make get_level_lengths non-private
    f62f02d [Joel Nothman] File restructure
    dc953d4 [Joel Nothman] Font size and border width
    7db59c0 [Joel Nothman] Test inherited styles in converter
    d103f61 [Joel Nothman] Refactoring and initial tests for CSS to Excel
    176e51c [Joel Nothman] Fix NameError
    c589c35 [Joel Nothman] Fix some lint errors (yes, the code needs testing)
    cb5cf02 [Joel Nothman] Fix bug where inherited not being passed; avoid classmethods
    0ce72f9 [Joel Nothman] Use inherited font size for em_pt
    8780076 [Joel Nothman] Merge branch 'master' into excel_style
    96680f9 [Joel Nothman] Largely complete CSSToExcelConverter and Styler.to_excel()
    f1cde08 [Joel Nothman] FIX column offset incorrect in refactor
    ada5101 [Joel Nothman] ENH: support Styler in ExcelFormatter

diff --git a/.gitignore b/.gitignore
index c953020f5..495429fcd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -103,4 +103,5 @@ doc/source/index.rst
 doc/build/html/index.html
 # Windows specific leftover:
 doc/tmp.sv
+doc/source/styled.xlsx
 doc/source/templates/
diff --git a/doc/source/_static/style-excel.png b/doc/source/_static/style-excel.png
new file mode 100644
index 000000000..f946949e8
Binary files /dev/null and b/doc/source/_static/style-excel.png differ
diff --git a/doc/source/style.ipynb b/doc/source/style.ipynb
index 93323d046..40b692441 100644
--- a/doc/source/style.ipynb
+++ b/doc/source/style.ipynb
@@ -4,11 +4,11 @@
    "cell_type": "markdown",
    "metadata": {},
    "source": [
-    "# HTML Styling\n",
+    "# Styling\n",
     "\n",
     "*New in version 0.17.1*\n",
     "\n",
-    "<p style=\"color: red\">*Provisional: This is a new feature and still under development. We'll be adding features and possibly making breaking changes in future releases. We'd love to hear your feedback.*<p style=\"color: red\">\n",
+    "<span style=\"color: red\">*Provisional: This is a new feature and still under development. We'll be adding features and possibly making breaking changes in future releases. We'd love to hear your feedback.*</span>\n",
     "\n",
     "This document is written as a Jupyter Notebook, and can be viewed or downloaded [here](http://nbviewer.ipython.org/github/pandas-dev/pandas/blob/master/doc/source/html-styling.ipynb).\n",
     "\n",
@@ -49,7 +49,6 @@
    "cell_type": "code",
    "execution_count": null,
    "metadata": {
-    "collapsed": true,
     "nbsphinx": "hidden"
    },
    "outputs": [],
@@ -62,9 +61,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {
-    "collapsed": true
-   },
+   "metadata": {},
    "outputs": [],
    "source": [
     "import pandas as pd\n",
@@ -130,9 +127,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {
-    "collapsed": true
-   },
+   "metadata": {},
    "outputs": [],
    "source": [
     "def color_negative_red(val):\n",
@@ -186,9 +181,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {
-    "collapsed": true
-   },
+   "metadata": {},
    "outputs": [],
    "source": [
     "def highlight_max(s):\n",
@@ -240,7 +233,7 @@
    "source": [
     "Above we used `Styler.apply` to pass in each column one at a time.\n",
     "\n",
-    "<p style=\"background-color: #DEDEBE\">*Debugging Tip*: If you're having trouble writing your style function, try just passing it into <code style=\"background-color: #DEDEBE\">DataFrame.apply</code>. Internally, <code style=\"background-color: #DEDEBE\">Styler.apply</code> uses <code style=\"background-color: #DEDEBE\">DataFrame.apply</code> so the result should be the same.</p>\n",
+    "<span style=\"background-color: #DEDEBE\">*Debugging Tip*: If you're having trouble writing your style function, try just passing it into <code style=\"background-color: #DEDEBE\">DataFrame.apply</code>. Internally, <code style=\"background-color: #DEDEBE\">Styler.apply</code> uses <code style=\"background-color: #DEDEBE\">DataFrame.apply</code> so the result should be the same.</span>\n",
     "\n",
     "What if you wanted to highlight just the maximum value in the entire table?\n",
     "Use `.apply(function, axis=None)` to indicate that your function wants the entire table, not one column or row at a time. Let's try that next.\n",
@@ -251,9 +244,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {
-    "collapsed": true
-   },
+   "metadata": {},
    "outputs": [],
    "source": [
     "def highlight_max(data, color='yellow'):\n",
@@ -819,9 +810,7 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {
-    "collapsed": true
-   },
+   "metadata": {},
    "outputs": [],
    "source": [
     "def magnify():\n",
@@ -854,6 +843,53 @@
     "    .set_table_styles(magnify())"
    ]
   },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## Export to Excel\n",
+    "\n",
+    "*New in version 0.20.0*\n",
+    "\n",
+    "<span style=\"color: red\">*Experimental: This is a new feature and still under development. We'll be adding features and possibly making breaking changes in future releases. We'd love to hear your feedback.*</span>\n",
+    "\n",
+    "Some support is available for exporting styled `DataFrames`Â to Excel worksheets using the `OpenPyXL` engine. CSS2.2 properties handled include:\n",
+    "\n",
+    "- `background-color`\n",
+    "- `border-style`, `border-width`, `border-color` and their {`top`, `right`, `bottom`, `left` variants}\n",
+    "- `color`\n",
+    "- `font-family`\n",
+    "- `font-style`\n",
+    "- `font-weight`\n",
+    "- `text-align`\n",
+    "- `text-decoration`\n",
+    "- `vertical-align`\n",
+    "- `white-space: nowrap`\n",
+    "\n",
+    "Only CSS2 named colors and hex colors of the form `#rgb` or `#rrggbb` are currently supported."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "df.style.\\\n",
+    "    applymap(color_negative_red).\\\n",
+    "    apply(highlight_max).\\\n",
+    "    to_excel('styled.xlsx', engine='openpyxl')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "A screenshot of the output:\n",
+    "\n",
+    "![Excel spreadsheet with styled DataFrame](_static/style-excel.png)\n"
+   ]
+  },
   {
    "cell_type": "markdown",
    "metadata": {},
@@ -1039,8 +1075,7 @@
    "mimetype": "text/x-python",
    "name": "python",
    "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.6.1"
+   "pygments_lexer": "ipython3"
   }
  },
  "nbformat": 4,
diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index f64f592e1..6802fceb9 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -17,6 +17,7 @@ Highlights include:
 - Improved user API when accessing levels in ``.groupby()``, see :ref:`here <whatsnew_0200.enhancements.groupby_access>`
 - Improved support for ``UInt64`` dtypes, see :ref:`here <whatsnew_0200.enhancements.uint64_support>`
 - A new orient for JSON serialization, ``orient='table'``, that uses the :ref:`Table Schema spec <whatsnew_0200.enhancements.table_schema>`
+- Experimental support for exporting ``DataFrame.style`` formats to Excel , see :ref:`here <whatsnew_0200.enhancements.style_excel>`
 - Window Binary Corr/Cov operations now return a MultiIndexed ``DataFrame`` rather than a ``Panel``, as ``Panel`` is now deprecated, see :ref:`here <whatsnew_0200.api_breaking.rolling_pairwise>`
 - Support for S3 handling now uses ``s3fs``, see :ref:`here <whatsnew_0200.api_breaking.s3>`
 - Google BigQuery support now uses the ``pandas-gbq`` library, see :ref:`here <whatsnew_0200.api_breaking.gbq>`
@@ -398,6 +399,39 @@ To convert a ``SparseDataFrame`` back to sparse SciPy matrix in COO format, you
 
    sdf.to_coo()
 
+.. _whatsnew_0200.enhancements.style_excel:
+
+Excel output for styled DataFrames
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+Experimental support has been added to export ``DataFrame.style`` formats to Excel using the ``openpyxl`` engine. (:issue:`15530`)
+
+For example, after running the following, ``styled.xlsx`` renders as below:
+
+.. ipython:: python
+
+    np.random.seed(24)
+    df = pd.DataFrame({'A': np.linspace(1, 10, 10)})
+    df = pd.concat([df, pd.DataFrame(np.random.RandomState(24).randn(10, 4),
+                                     columns=list('BCDE'))],
+                   axis=1)
+    df.iloc[0, 2] = np.nan
+    df
+    styled = df.style.\
+        applymap(lambda val: 'color: %s' % 'red' if val < 0 else 'black').\
+        apply(lambda s: ['background-color: yellow' if v else ''
+                         for v in s == s.max()])
+    styled.to_excel('styled.xlsx', engine='openpyxl')
+
+.. image:: _static/style-excel.png
+
+.. ipython:: python
+    :suppress:
+    import os
+    os.remove('styled.xlsx')
+
+See the :ref:`Style documentation <style>` for more detail.
+
 .. _whatsnew_0200.enhancements.intervalindex:
 
 IntervalIndex
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 7fbfa7962..dd2b97556 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1419,28 +1419,17 @@ class DataFrame(NDFrame):
                  index_label=None, startrow=0, startcol=0, engine=None,
                  merge_cells=True, encoding=None, inf_rep='inf', verbose=True,
                  freeze_panes=None):
-        from pandas.io.excel import ExcelWriter
-        need_save = False
-        if encoding is None:
-            encoding = 'ascii'
-
-        if isinstance(excel_writer, compat.string_types):
-            excel_writer = ExcelWriter(excel_writer, engine=engine)
-            need_save = True
-
-        formatter = fmt.ExcelFormatter(self, na_rep=na_rep, cols=columns,
-                                       header=header,
-                                       float_format=float_format, index=index,
-                                       index_label=index_label,
-                                       merge_cells=merge_cells,
-                                       inf_rep=inf_rep)
-
-        formatted_cells = formatter.get_formatted_cells()
-        excel_writer.write_cells(formatted_cells, sheet_name,
-                                 startrow=startrow, startcol=startcol,
-                                 freeze_panes=freeze_panes)
-        if need_save:
-            excel_writer.save()
+
+        from pandas.io.formats.excel import ExcelFormatter
+        formatter = ExcelFormatter(self, na_rep=na_rep, cols=columns,
+                                   header=header,
+                                   float_format=float_format, index=index,
+                                   index_label=index_label,
+                                   merge_cells=merge_cells,
+                                   inf_rep=inf_rep)
+        formatter.write(excel_writer, sheet_name=sheet_name, startrow=startrow,
+                        startcol=startcol, freeze_panes=freeze_panes,
+                        engine=engine)
 
     def to_stata(self, fname, convert_dates=None, write_index=True,
                  encoding="latin-1", byteorder=None, time_stamp=None,
diff --git a/pandas/io/formats/common.py b/pandas/io/formats/common.py
new file mode 100644
index 000000000..5cfdf5840
--- /dev/null
+++ b/pandas/io/formats/common.py
@@ -0,0 +1,44 @@
+# -*- coding: utf-8 -*-
+"""
+Common helper methods used in different submodules of pandas.io.formats
+"""
+
+
+def get_level_lengths(levels, sentinel=''):
+    """For each index in each level the function returns lengths of indexes.
+
+    Parameters
+    ----------
+    levels : list of lists
+        List of values on for level.
+    sentinel : string, optional
+        Value which states that no new index starts on there.
+
+    Returns
+    ----------
+    Returns list of maps. For each level returns map of indexes (key is index
+    in row and value is length of index).
+    """
+    if len(levels) == 0:
+        return []
+
+    control = [True for x in levels[0]]
+
+    result = []
+    for level in levels:
+        last_index = 0
+
+        lengths = {}
+        for i, key in enumerate(level):
+            if control[i] and key == sentinel:
+                pass
+            else:
+                control[i] = False
+                lengths[last_index] = i - last_index
+                last_index = i
+
+        lengths[last_index] = len(level) - last_index
+
+        result.append(lengths)
+
+    return result
diff --git a/pandas/io/formats/css.py b/pandas/io/formats/css.py
new file mode 100644
index 000000000..d12d2373e
--- /dev/null
+++ b/pandas/io/formats/css.py
@@ -0,0 +1,248 @@
+"""Utilities for interpreting CSS from Stylers for formatting non-HTML outputs
+"""
+
+import re
+import warnings
+
+
+class CSSWarning(UserWarning):
+    """This CSS syntax cannot currently be parsed"""
+    pass
+
+
+class CSSResolver(object):
+    """A callable for parsing and resolving CSS to atomic properties
+
+    """
+
+    INITIAL_STYLE = {
+    }
+
+    def __call__(self, declarations_str, inherited=None):
+        """ the given declarations to atomic properties
+
+        Parameters
+        ----------
+        declarations_str : str
+            A list of CSS declarations
+        inherited : dict, optional
+            Atomic properties indicating the inherited style context in which
+            declarations_str is to be resolved. ``inherited`` should already
+            be resolved, i.e. valid output of this method.
+
+        Returns
+        -------
+        props : dict
+            Atomic CSS 2.2 properties
+
+        Examples
+        --------
+        >>> resolve = CSSResolver()
+        >>> inherited = {'font-family': 'serif', 'font-weight': 'bold'}
+        >>> out = resolve('''
+        ...               border-color: BLUE RED;
+        ...               font-size: 1em;
+        ...               font-size: 2em;
+        ...               font-weight: normal;
+        ...               font-weight: inherit;
+        ...               ''', inherited)
+        >>> sorted(out.items())  # doctest: +NORMALIZE_WHITESPACE
+        [('border-bottom-color', 'blue'),
+         ('border-left-color', 'red'),
+         ('border-right-color', 'red'),
+         ('border-top-color', 'blue'),
+         ('font-family', 'serif'),
+         ('font-size', '24pt'),
+         ('font-weight', 'bold')]
+        """
+
+        props = dict(self.atomize(self.parse(declarations_str)))
+        if inherited is None:
+            inherited = {}
+
+        # 1. resolve inherited, initial
+        for prop, val in inherited.items():
+            if prop not in props:
+                props[prop] = val
+
+        for prop, val in list(props.items()):
+            if val == 'inherit':
+                val = inherited.get(prop, 'initial')
+            if val == 'initial':
+                val = self.INITIAL_STYLE.get(prop)
+
+            if val is None:
+                # we do not define a complete initial stylesheet
+                del props[prop]
+            else:
+                props[prop] = val
+
+        # 2. resolve relative font size
+        if props.get('font-size'):
+            if 'font-size' in inherited:
+                em_pt = inherited['font-size']
+                assert em_pt[-2:] == 'pt'
+                em_pt = float(em_pt[:-2])
+            else:
+                em_pt = None
+            props['font-size'] = self.size_to_pt(
+                props['font-size'], em_pt, conversions=self.FONT_SIZE_RATIOS)
+
+            font_size = float(props['font-size'][:-2])
+        else:
+            font_size = None
+
+        # 3. TODO: resolve other font-relative units
+        for side in self.SIDES:
+            prop = 'border-%s-width' % side
+            if prop in props:
+                props[prop] = self.size_to_pt(
+                    props[prop], em_pt=font_size,
+                    conversions=self.BORDER_WIDTH_RATIOS)
+            for prop in ['margin-%s' % side, 'padding-%s' % side]:
+                if prop in props:
+                    # TODO: support %
+                    props[prop] = self.size_to_pt(
+                        props[prop], em_pt=font_size,
+                        conversions=self.MARGIN_RATIOS)
+
+        return props
+
+    UNIT_RATIOS = {
+        'rem': ('pt', 12),
+        'ex': ('em', .5),
+        # 'ch':
+        'px': ('pt', .75),
+        'pc': ('pt', 12),
+        'in': ('pt', 72),
+        'cm': ('in', 1 / 2.54),
+        'mm': ('in', 1 / 25.4),
+        'q': ('mm', .25),
+        '!!default': ('em', 0),
+    }
+
+    FONT_SIZE_RATIOS = UNIT_RATIOS.copy()
+    FONT_SIZE_RATIOS.update({
+        '%': ('em', .01),
+        'xx-small': ('rem', .5),
+        'x-small': ('rem', .625),
+        'small': ('rem', .8),
+        'medium': ('rem', 1),
+        'large': ('rem', 1.125),
+        'x-large': ('rem', 1.5),
+        'xx-large': ('rem', 2),
+        'smaller': ('em', 1 / 1.2),
+        'larger': ('em', 1.2),
+        '!!default': ('em', 1),
+    })
+
+    MARGIN_RATIOS = UNIT_RATIOS.copy()
+    MARGIN_RATIOS.update({
+        'none': ('pt', 0),
+    })
+
+    BORDER_WIDTH_RATIOS = UNIT_RATIOS.copy()
+    BORDER_WIDTH_RATIOS.update({
+        'none': ('pt', 0),
+        'thick': ('px', 4),
+        'medium': ('px', 2),
+        'thin': ('px', 1),
+        # Default: medium only if solid
+    })
+
+    def size_to_pt(self, in_val, em_pt=None, conversions=UNIT_RATIOS):
+        def _error():
+            warnings.warn('Unhandled size: %r' % in_val, CSSWarning)
+            return self.size_to_pt('1!!default', conversions=conversions)
+
+        try:
+            val, unit = re.match(r'^(\S*?)([a-zA-Z%!].*)', in_val).groups()
+        except AttributeError:
+            return _error()
+        if val == '':
+            # hack for 'large' etc.
+            val = 1
+        else:
+            try:
+                val = float(val)
+            except ValueError:
+                return _error()
+
+        while unit != 'pt':
+            if unit == 'em':
+                if em_pt is None:
+                    unit = 'rem'
+                else:
+                    val *= em_pt
+                    unit = 'pt'
+                continue
+
+            try:
+                unit, mul = conversions[unit]
+            except KeyError:
+                return _error()
+            val *= mul
+
+        val = round(val, 5)
+        if int(val) == val:
+            size_fmt = '%d'
+        else:
+            size_fmt = '%f'
+        return (size_fmt + 'pt') % val
+
+    def atomize(self, declarations):
+        for prop, value in declarations:
+            attr = 'expand_' + prop.replace('-', '_')
+            try:
+                expand = getattr(self, attr)
+            except AttributeError:
+                yield prop, value
+            else:
+                for prop, value in expand(prop, value):
+                    yield prop, value
+
+    SIDE_SHORTHANDS = {
+        1: [0, 0, 0, 0],
+        2: [0, 1, 0, 1],
+        3: [0, 1, 2, 1],
+        4: [0, 1, 2, 3],
+    }
+    SIDES = ('top', 'right', 'bottom', 'left')
+
+    def _side_expander(prop_fmt):
+        def expand(self, prop, value):
+            tokens = value.split()
+            try:
+                mapping = self.SIDE_SHORTHANDS[len(tokens)]
+            except KeyError:
+                warnings.warn('Could not expand "%s: %s"' % (prop, value),
+                              CSSWarning)
+                return
+            for key, idx in zip(self.SIDES, mapping):
+                yield prop_fmt % key, tokens[idx]
+
+        return expand
+
+    expand_border_color = _side_expander('border-%s-color')
+    expand_border_style = _side_expander('border-%s-style')
+    expand_border_width = _side_expander('border-%s-width')
+    expand_margin = _side_expander('margin-%s')
+    expand_padding = _side_expander('padding-%s')
+
+    def parse(self, declarations_str):
+        """Generates (prop, value) pairs from declarations
+
+        In a future version may generate parsed tokens from tinycss/tinycss2
+        """
+        for decl in declarations_str.split(';'):
+            if not decl.strip():
+                continue
+            prop, sep, val = decl.partition(':')
+            prop = prop.strip().lower()
+            # TODO: don't lowercase case sensitive parts of values (strings)
+            val = val.strip().lower()
+            if sep:
+                yield prop, val
+            else:
+                warnings.warn('Ill-formatted attribute: expected a colon '
+                              'in %r' % decl, CSSWarning)
diff --git a/pandas/io/formats/excel.py b/pandas/io/formats/excel.py
new file mode 100644
index 000000000..80587f9a7
--- /dev/null
+++ b/pandas/io/formats/excel.py
@@ -0,0 +1,630 @@
+"""Utilities for conversion to writer-agnostic Excel representation
+"""
+
+import re
+import warnings
+import itertools
+
+import numpy as np
+
+from pandas.compat import reduce, string_types
+from pandas.io.formats.css import CSSResolver, CSSWarning
+from pandas.io.formats.printing import pprint_thing
+from pandas.core.dtypes.common import is_float
+import pandas._libs.lib as lib
+from pandas import Index, MultiIndex, PeriodIndex
+from pandas.io.formats.common import get_level_lengths
+
+
+class ExcelCell(object):
+    __fields__ = ('row', 'col', 'val', 'style', 'mergestart', 'mergeend')
+    __slots__ = __fields__
+
+    def __init__(self, row, col, val, style=None, mergestart=None,
+                 mergeend=None):
+        self.row = row
+        self.col = col
+        self.val = val
+        self.style = style
+        self.mergestart = mergestart
+        self.mergeend = mergeend
+
+
+header_style = {"font": {"bold": True},
+                "borders": {"top": "thin",
+                            "right": "thin",
+                            "bottom": "thin",
+                            "left": "thin"},
+                "alignment": {"horizontal": "center",
+                              "vertical": "top"}}
+
+
+class CSSToExcelConverter(object):
+    """A callable for converting CSS declarations to ExcelWriter styles
+
+    Supports parts of CSS 2.2, with minimal CSS 3.0 support (e.g. text-shadow),
+    focusing on font styling, backgrounds, borders and alignment.
+
+    Operates by first computing CSS styles in a fairly generic
+    way (see :meth:`compute_css`) then determining Excel style
+    properties from CSS properties (see :meth:`build_xlstyle`).
+
+    Parameters
+    ----------
+    inherited : str, optional
+        CSS declarations understood to be the containing scope for the
+        CSS processed by :meth:`__call__`.
+    """
+    # NB: Most of the methods here could be classmethods, as only __init__
+    #     and __call__ make use of instance attributes.  We leave them as
+    #     instancemethods so that users can easily experiment with extensions
+    #     without monkey-patching.
+
+    def __init__(self, inherited=None):
+        if inherited is not None:
+            inherited = self.compute_css(inherited,
+                                         self.compute_css.INITIAL_STYLE)
+
+        self.inherited = inherited
+
+    compute_css = CSSResolver()
+
+    def __call__(self, declarations_str):
+        """Convert CSS declarations to ExcelWriter style
+
+        Parameters
+        ----------
+        declarations_str : str
+            List of CSS declarations.
+            e.g. "font-weight: bold; background: blue"
+
+        Returns
+        -------
+        xlstyle : dict
+            A style as interpreted by ExcelWriter when found in
+            ExcelCell.style.
+        """
+        # TODO: memoize?
+        properties = self.compute_css(declarations_str, self.inherited)
+        return self.build_xlstyle(properties)
+
+    def build_xlstyle(self, props):
+        out = {
+            'alignment': self.build_alignment(props),
+            'border': self.build_border(props),
+            'fill': self.build_fill(props),
+            'font': self.build_font(props),
+        }
+        # TODO: support number format
+        # TODO: handle cell width and height: needs support in pandas.io.excel
+
+        def remove_none(d):
+            """Remove key where value is None, through nested dicts"""
+            for k, v in list(d.items()):
+                if v is None:
+                    del d[k]
+                elif isinstance(v, dict):
+                    remove_none(v)
+                    if not v:
+                        del d[k]
+
+        remove_none(out)
+        return out
+
+    VERTICAL_MAP = {
+        'top': 'top',
+        'text-top': 'top',
+        'middle': 'center',
+        'baseline': 'bottom',
+        'bottom': 'bottom',
+        'text-bottom': 'bottom',
+        # OpenXML also has 'justify', 'distributed'
+    }
+
+    def build_alignment(self, props):
+        # TODO: text-indent, padding-left -> alignment.indent
+        return {'horizontal': props.get('text-align'),
+                'vertical': self.VERTICAL_MAP.get(props.get('vertical-align')),
+                'wrap_text': (None if props.get('white-space') is None else
+                              props['white-space'] not in
+                              ('nowrap', 'pre', 'pre-line'))
+                }
+
+    def build_border(self, props):
+        return {side: {
+            'style': self._border_style(props.get('border-%s-style' % side),
+                                        props.get('border-%s-width' % side)),
+            'color': self.color_to_excel(
+                props.get('border-%s-color' % side)),
+        } for side in ['top', 'right', 'bottom', 'left']}
+
+    def _border_style(self, style, width):
+        # convert styles and widths to openxml, one of:
+        #       'dashDot'
+        #       'dashDotDot'
+        #       'dashed'
+        #       'dotted'
+        #       'double'
+        #       'hair'
+        #       'medium'
+        #       'mediumDashDot'
+        #       'mediumDashDotDot'
+        #       'mediumDashed'
+        #       'slantDashDot'
+        #       'thick'
+        #       'thin'
+        if width is None and style is None:
+            return None
+        if style == 'none' or style == 'hidden':
+            return None
+
+        if width is None:
+            width = '2pt'
+        width = float(width[:-2])
+        if width < 1e-5:
+            return None
+        elif width < 1.3:
+            width_name = 'thin'
+        elif width < 2.8:
+            width_name = 'medium'
+        else:
+            width_name = 'thick'
+
+        if style in (None, 'groove', 'ridge', 'inset', 'outset'):
+            # not handled
+            style = 'solid'
+
+        if style == 'double':
+            return 'double'
+        if style == 'solid':
+            return width_name
+        if style == 'dotted':
+            if width_name in ('hair', 'thin'):
+                return 'dotted'
+            return 'mediumDashDotDot'
+        if style == 'dashed':
+            if width_name in ('hair', 'thin'):
+                return 'dashed'
+            return 'mediumDashed'
+
+    def build_fill(self, props):
+        # TODO: perhaps allow for special properties
+        #       -excel-pattern-bgcolor and -excel-pattern-type
+        fill_color = props.get('background-color')
+        if fill_color not in (None, 'transparent', 'none'):
+            return {
+                'fgColor': self.color_to_excel(fill_color),
+                'patternType': 'solid',
+            }
+
+    BOLD_MAP = {'bold': True, 'bolder': True, '600': True, '700': True,
+                '800': True, '900': True,
+                'normal': False, 'lighter': False, '100': False, '200': False,
+                '300': False, '400': False, '500': False}
+    ITALIC_MAP = {'normal': False, 'italic': True, 'oblique': True}
+
+    def build_font(self, props):
+        size = props.get('font-size')
+        if size is not None:
+            assert size.endswith('pt')
+            size = float(size[:-2])
+
+        font_names_tmp = re.findall(r'''(?x)
+            (
+            "(?:[^"]|\\")+"
+            |
+            '(?:[^']|\\')+'
+            |
+            [^'",]+
+            )(?=,|\s*$)
+        ''', props.get('font-family', ''))
+        font_names = []
+        for name in font_names_tmp:
+            if name[:1] == '"':
+                name = name[1:-1].replace('\\"', '"')
+            elif name[:1] == '\'':
+                name = name[1:-1].replace('\\\'', '\'')
+            else:
+                name = name.strip()
+            if name:
+                font_names.append(name)
+
+        family = None
+        for name in font_names:
+            if name == 'serif':
+                family = 1  # roman
+                break
+            elif name == 'sans-serif':
+                family = 2  # swiss
+                break
+            elif name == 'cursive':
+                family = 4  # script
+                break
+            elif name == 'fantasy':
+                family = 5  # decorative
+                break
+
+        decoration = props.get('text-decoration')
+        if decoration is not None:
+            decoration = decoration.split()
+        else:
+            decoration = ()
+
+        return {
+            'name': font_names[0] if font_names else None,
+            'family': family,
+            'size': size,
+            'bold': self.BOLD_MAP.get(props.get('font-weight')),
+            'italic': self.ITALIC_MAP.get(props.get('font-style')),
+            'underline': ('single' if
+                          'underline' in decoration
+                          else None),
+            'strike': ('line-through' in decoration) or None,
+            'color': self.color_to_excel(props.get('color')),
+            # shadow if nonzero digit before shadow colour
+            'shadow': (bool(re.search('^[^#(]*[1-9]',
+                                      props['text-shadow']))
+                       if 'text-shadow' in props else None),
+            # 'vertAlign':,
+            # 'charset': ,
+            # 'scheme': ,
+            # 'outline': ,
+            # 'condense': ,
+        }
+
+    NAMED_COLORS = {
+        'maroon': '800000',
+        'red': 'FF0000',
+        'orange': 'FFA500',
+        'yellow': 'FFFF00',
+        'olive': '808000',
+        'green': '008000',
+        'purple': '800080',
+        'fuchsia': 'FF00FF',
+        'lime': '00FF00',
+        'teal': '008080',
+        'aqua': '00FFFF',
+        'blue': '0000FF',
+        'navy': '000080',
+        'black': '000000',
+        'gray': '808080',
+        'silver': 'C0C0C0',
+        'white': 'FFFFFF',
+    }
+
+    def color_to_excel(self, val):
+        if val is None:
+            return None
+        if val.startswith('#') and len(val) == 7:
+            return val[1:].upper()
+        if val.startswith('#') and len(val) == 4:
+            return (val[1] * 2 + val[2] * 2 + val[3] * 2).upper()
+        try:
+            return self.NAMED_COLORS[val]
+        except KeyError:
+            warnings.warn('Unhandled colour format: %r' % val, CSSWarning)
+
+
+class ExcelFormatter(object):
+    """
+    Class for formatting a DataFrame to a list of ExcelCells,
+
+    Parameters
+    ----------
+    df : DataFrame or Styler
+    na_rep: na representation
+    float_format : string, default None
+            Format string for floating point numbers
+    cols : sequence, optional
+        Columns to write
+    header : boolean or list of string, default True
+        Write out column names. If a list of string is given it is
+        assumed to be aliases for the column names
+    index : boolean, default True
+        output row names (index)
+    index_label : string or sequence, default None
+            Column label for index column(s) if desired. If None is given, and
+            `header` and `index` are True, then the index names are used. A
+            sequence should be given if the DataFrame uses MultiIndex.
+    merge_cells : boolean, default False
+            Format MultiIndex and Hierarchical Rows as merged cells.
+    inf_rep : string, default `'inf'`
+        representation for np.inf values (which aren't representable in Excel)
+        A `'-'` sign will be added in front of -inf.
+    style_converter : callable, optional
+        This translates Styler styles (CSS) into ExcelWriter styles.
+        Defaults to ``CSSToExcelConverter()``.
+        It should have signature css_declarations string -> excel style.
+        This is only called for body cells.
+    """
+
+    def __init__(self, df, na_rep='', float_format=None, cols=None,
+                 header=True, index=True, index_label=None, merge_cells=False,
+                 inf_rep='inf', style_converter=None):
+        self.rowcounter = 0
+        self.na_rep = na_rep
+        if hasattr(df, 'render'):
+            self.styler = df
+            df = df.data
+            if style_converter is None:
+                style_converter = CSSToExcelConverter()
+            self.style_converter = style_converter
+        else:
+            self.styler = None
+        self.df = df
+        if cols is not None:
+            self.df = df.loc[:, cols]
+        self.columns = self.df.columns
+        self.float_format = float_format
+        self.index = index
+        self.index_label = index_label
+        self.header = header
+        self.merge_cells = merge_cells
+        self.inf_rep = inf_rep
+
+    def _format_value(self, val):
+        if lib.checknull(val):
+            val = self.na_rep
+        elif is_float(val):
+            if lib.isposinf_scalar(val):
+                val = self.inf_rep
+            elif lib.isneginf_scalar(val):
+                val = '-%s' % self.inf_rep
+            elif self.float_format is not None:
+                val = float(self.float_format % val)
+        return val
+
+    def _format_header_mi(self):
+        if self.columns.nlevels > 1:
+            if not self.index:
+                raise NotImplementedError("Writing to Excel with MultiIndex"
+                                          " columns and no index "
+                                          "('index'=False) is not yet "
+                                          "implemented.")
+
+        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
+        if not (has_aliases or self.header):
+            return
+
+        columns = self.columns
+        level_strs = columns.format(sparsify=self.merge_cells, adjoin=False,
+                                    names=False)
+        level_lengths = get_level_lengths(level_strs)
+        coloffset = 0
+        lnum = 0
+
+        if self.index and isinstance(self.df.index, MultiIndex):
+            coloffset = len(self.df.index[0]) - 1
+
+        if self.merge_cells:
+            # Format multi-index as a merged cells.
+            for lnum in range(len(level_lengths)):
+                name = columns.names[lnum]
+                yield ExcelCell(lnum, coloffset, name, header_style)
+
+            for lnum, (spans, levels, labels) in enumerate(zip(
+                    level_lengths, columns.levels, columns.labels)):
+                values = levels.take(labels)
+                for i in spans:
+                    if spans[i] > 1:
+                        yield ExcelCell(lnum, coloffset + i + 1, values[i],
+                                        header_style, lnum,
+                                        coloffset + i + spans[i])
+                    else:
+                        yield ExcelCell(lnum, coloffset + i + 1, values[i],
+                                        header_style)
+        else:
+            # Format in legacy format with dots to indicate levels.
+            for i, values in enumerate(zip(*level_strs)):
+                v = ".".join(map(pprint_thing, values))
+                yield ExcelCell(lnum, coloffset + i + 1, v, header_style)
+
+        self.rowcounter = lnum
+
+    def _format_header_regular(self):
+        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
+        if has_aliases or self.header:
+            coloffset = 0
+
+            if self.index:
+                coloffset = 1
+                if isinstance(self.df.index, MultiIndex):
+                    coloffset = len(self.df.index[0])
+
+            colnames = self.columns
+            if has_aliases:
+                if len(self.header) != len(self.columns):
+                    raise ValueError('Writing %d cols but got %d aliases' %
+                                     (len(self.columns), len(self.header)))
+                else:
+                    colnames = self.header
+
+            for colindex, colname in enumerate(colnames):
+                yield ExcelCell(self.rowcounter, colindex + coloffset, colname,
+                                header_style)
+
+    def _format_header(self):
+        if isinstance(self.columns, MultiIndex):
+            gen = self._format_header_mi()
+        else:
+            gen = self._format_header_regular()
+
+        gen2 = ()
+        if self.df.index.names:
+            row = [x if x is not None else ''
+                   for x in self.df.index.names] + [''] * len(self.columns)
+            if reduce(lambda x, y: x and y, map(lambda x: x != '', row)):
+                gen2 = (ExcelCell(self.rowcounter, colindex, val, header_style)
+                        for colindex, val in enumerate(row))
+                self.rowcounter += 1
+        return itertools.chain(gen, gen2)
+
+    def _format_body(self):
+
+        if isinstance(self.df.index, MultiIndex):
+            return self._format_hierarchical_rows()
+        else:
+            return self._format_regular_rows()
+
+    def _format_regular_rows(self):
+        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
+        if has_aliases or self.header:
+            self.rowcounter += 1
+
+        # output index and index_label?
+        if self.index:
+            # chek aliases
+            # if list only take first as this is not a MultiIndex
+            if (self.index_label and
+                    isinstance(self.index_label, (list, tuple, np.ndarray,
+                                                  Index))):
+                index_label = self.index_label[0]
+            # if string good to go
+            elif self.index_label and isinstance(self.index_label, str):
+                index_label = self.index_label
+            else:
+                index_label = self.df.index.names[0]
+
+            if isinstance(self.columns, MultiIndex):
+                self.rowcounter += 1
+
+            if index_label and self.header is not False:
+                yield ExcelCell(self.rowcounter - 1, 0, index_label,
+                                header_style)
+
+            # write index_values
+            index_values = self.df.index
+            if isinstance(self.df.index, PeriodIndex):
+                index_values = self.df.index.to_timestamp()
+
+            for idx, idxval in enumerate(index_values):
+                yield ExcelCell(self.rowcounter + idx, 0, idxval, header_style)
+
+            coloffset = 1
+        else:
+            coloffset = 0
+
+        for cell in self._generate_body(coloffset):
+            yield cell
+
+    def _format_hierarchical_rows(self):
+        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
+        if has_aliases or self.header:
+            self.rowcounter += 1
+
+        gcolidx = 0
+
+        if self.index:
+            index_labels = self.df.index.names
+            # check for aliases
+            if (self.index_label and
+                    isinstance(self.index_label, (list, tuple, np.ndarray,
+                                                  Index))):
+                index_labels = self.index_label
+
+            # MultiIndex columns require an extra row
+            # with index names (blank if None) for
+            # unambigous round-trip, unless not merging,
+            # in which case the names all go on one row Issue #11328
+            if isinstance(self.columns, MultiIndex) and self.merge_cells:
+                self.rowcounter += 1
+
+            # if index labels are not empty go ahead and dump
+            if (any(x is not None for x in index_labels) and
+                    self.header is not False):
+
+                for cidx, name in enumerate(index_labels):
+                    yield ExcelCell(self.rowcounter - 1, cidx, name,
+                                    header_style)
+
+            if self.merge_cells:
+                # Format hierarchical rows as merged cells.
+                level_strs = self.df.index.format(sparsify=True, adjoin=False,
+                                                  names=False)
+                level_lengths = get_level_lengths(level_strs)
+
+                for spans, levels, labels in zip(level_lengths,
+                                                 self.df.index.levels,
+                                                 self.df.index.labels):
+
+                    values = levels.take(labels,
+                                         allow_fill=levels._can_hold_na,
+                                         fill_value=True)
+
+                    for i in spans:
+                        if spans[i] > 1:
+                            yield ExcelCell(self.rowcounter + i, gcolidx,
+                                            values[i], header_style,
+                                            self.rowcounter + i + spans[i] - 1,
+                                            gcolidx)
+                        else:
+                            yield ExcelCell(self.rowcounter + i, gcolidx,
+                                            values[i], header_style)
+                    gcolidx += 1
+
+            else:
+                # Format hierarchical rows with non-merged values.
+                for indexcolvals in zip(*self.df.index):
+                    for idx, indexcolval in enumerate(indexcolvals):
+                        yield ExcelCell(self.rowcounter + idx, gcolidx,
+                                        indexcolval, header_style)
+                    gcolidx += 1
+
+        for cell in self._generate_body(gcolidx):
+            yield cell
+
+    def _generate_body(self, coloffset):
+        if self.styler is None:
+            styles = None
+        else:
+            styles = self.styler._compute().ctx
+            if not styles:
+                styles = None
+        xlstyle = None
+
+        # Write the body of the frame data series by series.
+        for colidx in range(len(self.columns)):
+            series = self.df.iloc[:, colidx]
+            for i, val in enumerate(series):
+                if styles is not None:
+                    xlstyle = self.style_converter(';'.join(styles[i, colidx]))
+                yield ExcelCell(self.rowcounter + i, colidx + coloffset, val,
+                                xlstyle)
+
+    def get_formatted_cells(self):
+        for cell in itertools.chain(self._format_header(),
+                                    self._format_body()):
+            cell.val = self._format_value(cell.val)
+            yield cell
+
+    def write(self, writer, sheet_name='Sheet1', startrow=0,
+              startcol=0, freeze_panes=None, engine=None):
+        """
+        writer : string or ExcelWriter object
+            File path or existing ExcelWriter
+        sheet_name : string, default 'Sheet1'
+            Name of sheet which will contain DataFrame
+        startrow :
+            upper left cell row to dump data frame
+        startcol :
+            upper left cell column to dump data frame
+        freeze_panes : tuple of integer (length 2), default None
+            Specifies the one-based bottommost row and rightmost column that
+            is to be frozen
+        engine : string, default None
+            write engine to use if writer is a path - you can also set this
+            via the options ``io.excel.xlsx.writer``, ``io.excel.xls.writer``,
+            and ``io.excel.xlsm.writer``.
+        """
+        from pandas.io.excel import ExcelWriter
+        need_save = False
+        if isinstance(writer, string_types):
+            writer = ExcelWriter(writer, engine=engine)
+            need_save = True
+
+        formatted_cells = self.get_formatted_cells()
+        writer.write_cells(formatted_cells, sheet_name,
+                           startrow=startrow, startcol=startcol,
+                           freeze_panes=freeze_panes)
+        if need_save:
+            writer.save()
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index d618fab08..70ea6e5d8 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -28,12 +28,13 @@ from pandas.core.dtypes.generic import ABCSparseArray
 from pandas.core.base import PandasObject
 from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas import compat
-from pandas.compat import (StringIO, lzip, range, map, zip, reduce, u,
+from pandas.compat import (StringIO, lzip, range, map, zip, u,
                            OrderedDict, unichr)
 from pandas.util.terminal import get_terminal_size
 from pandas.core.config import get_option, set_option
 from pandas.io.common import _get_handle, UnicodeWriter, _expand_user
 from pandas.io.formats.printing import adjoin, justify, pprint_thing
+from pandas.io.formats.common import get_level_lengths
 import pandas.core.common as com
 import pandas._libs.lib as lib
 from pandas._libs.tslib import (iNaT, Timestamp, Timedelta,
@@ -1191,7 +1192,7 @@ class HTMLFormatter(TableFormatter):
                 sentinel = None
             levels = self.columns.format(sparsify=sentinel, adjoin=False,
                                          names=False)
-            level_lengths = _get_level_lengths(levels, sentinel)
+            level_lengths = get_level_lengths(levels, sentinel)
             inner_lvl = len(level_lengths) - 1
             for lnum, (records, values) in enumerate(zip(level_lengths,
                                                          levels)):
@@ -1357,7 +1358,7 @@ class HTMLFormatter(TableFormatter):
             levels = frame.index.format(sparsify=sentinel, adjoin=False,
                                         names=False)
 
-            level_lengths = _get_level_lengths(levels, sentinel)
+            level_lengths = get_level_lengths(levels, sentinel)
             inner_lvl = len(level_lengths) - 1
             if truncate_v:
                 # Insert ... row and adjust idx_values and
@@ -1440,46 +1441,6 @@ class HTMLFormatter(TableFormatter):
                               nindex_levels=frame.index.nlevels)
 
 
-def _get_level_lengths(levels, sentinel=''):
-    """For each index in each level the function returns lengths of indexes.
-
-    Parameters
-    ----------
-    levels : list of lists
-        List of values on for level.
-    sentinel : string, optional
-        Value which states that no new index starts on there.
-
-    Returns
-    ----------
-    Returns list of maps. For each level returns map of indexes (key is index
-    in row and value is length of index).
-    """
-    if len(levels) == 0:
-        return []
-
-    control = [True for x in levels[0]]
-
-    result = []
-    for level in levels:
-        last_index = 0
-
-        lengths = {}
-        for i, key in enumerate(level):
-            if control[i] and key == sentinel:
-                pass
-            else:
-                control[i] = False
-                lengths[last_index] = i - last_index
-                last_index = i
-
-        lengths[last_index] = len(level) - last_index
-
-        result.append(lengths)
-
-    return result
-
-
 class CSVFormatter(object):
 
     def __init__(self, obj, path_or_buf=None, sep=",", na_rep='',
@@ -1729,298 +1690,6 @@ class CSVFormatter(object):
 
         lib.write_csv_rows(self.data, ix, self.nlevels, self.cols, self.writer)
 
-# from collections import namedtuple
-# ExcelCell = namedtuple("ExcelCell",
-#                        'row, col, val, style, mergestart, mergeend')
-
-
-class ExcelCell(object):
-    __fields__ = ('row', 'col', 'val', 'style', 'mergestart', 'mergeend')
-    __slots__ = __fields__
-
-    def __init__(self, row, col, val, style=None, mergestart=None,
-                 mergeend=None):
-        self.row = row
-        self.col = col
-        self.val = val
-        self.style = style
-        self.mergestart = mergestart
-        self.mergeend = mergeend
-
-
-header_style = {"font": {"bold": True},
-                "borders": {"top": "thin",
-                            "right": "thin",
-                            "bottom": "thin",
-                            "left": "thin"},
-                "alignment": {"horizontal": "center",
-                              "vertical": "top"}}
-
-
-class ExcelFormatter(object):
-    """
-    Class for formatting a DataFrame to a list of ExcelCells,
-
-    Parameters
-    ----------
-    df : dataframe
-    na_rep: na representation
-    float_format : string, default None
-            Format string for floating point numbers
-    cols : sequence, optional
-        Columns to write
-    header : boolean or list of string, default True
-        Write out column names. If a list of string is given it is
-        assumed to be aliases for the column names
-    index : boolean, default True
-        output row names (index)
-    index_label : string or sequence, default None
-            Column label for index column(s) if desired. If None is given, and
-            `header` and `index` are True, then the index names are used. A
-            sequence should be given if the DataFrame uses MultiIndex.
-    merge_cells : boolean, default False
-            Format MultiIndex and Hierarchical Rows as merged cells.
-    inf_rep : string, default `'inf'`
-        representation for np.inf values (which aren't representable in Excel)
-        A `'-'` sign will be added in front of -inf.
-    """
-
-    def __init__(self, df, na_rep='', float_format=None, cols=None,
-                 header=True, index=True, index_label=None, merge_cells=False,
-                 inf_rep='inf'):
-        self.rowcounter = 0
-        self.na_rep = na_rep
-        self.df = df
-        if cols is not None:
-            self.df = df.loc[:, cols]
-        self.columns = self.df.columns
-        self.float_format = float_format
-        self.index = index
-        self.index_label = index_label
-        self.header = header
-        self.merge_cells = merge_cells
-        self.inf_rep = inf_rep
-
-    def _format_value(self, val):
-        if lib.checknull(val):
-            val = self.na_rep
-        elif is_float(val):
-            if lib.isposinf_scalar(val):
-                val = self.inf_rep
-            elif lib.isneginf_scalar(val):
-                val = '-%s' % self.inf_rep
-            elif self.float_format is not None:
-                val = float(self.float_format % val)
-        return val
-
-    def _format_header_mi(self):
-        if self.columns.nlevels > 1:
-            if not self.index:
-                raise NotImplementedError("Writing to Excel with MultiIndex"
-                                          " columns and no index "
-                                          "('index'=False) is not yet "
-                                          "implemented.")
-
-        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
-        if not (has_aliases or self.header):
-            return
-
-        columns = self.columns
-        level_strs = columns.format(sparsify=self.merge_cells, adjoin=False,
-                                    names=False)
-        level_lengths = _get_level_lengths(level_strs)
-        coloffset = 0
-        lnum = 0
-
-        if self.index and isinstance(self.df.index, MultiIndex):
-            coloffset = len(self.df.index[0]) - 1
-
-        if self.merge_cells:
-            # Format multi-index as a merged cells.
-            for lnum in range(len(level_lengths)):
-                name = columns.names[lnum]
-                yield ExcelCell(lnum, coloffset, name, header_style)
-
-            for lnum, (spans, levels, labels) in enumerate(zip(
-                    level_lengths, columns.levels, columns.labels)):
-                values = levels.take(labels)
-                for i in spans:
-                    if spans[i] > 1:
-                        yield ExcelCell(lnum, coloffset + i + 1, values[i],
-                                        header_style, lnum,
-                                        coloffset + i + spans[i])
-                    else:
-                        yield ExcelCell(lnum, coloffset + i + 1, values[i],
-                                        header_style)
-        else:
-            # Format in legacy format with dots to indicate levels.
-            for i, values in enumerate(zip(*level_strs)):
-                v = ".".join(map(pprint_thing, values))
-                yield ExcelCell(lnum, coloffset + i + 1, v, header_style)
-
-        self.rowcounter = lnum
-
-    def _format_header_regular(self):
-        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
-        if has_aliases or self.header:
-            coloffset = 0
-
-            if self.index:
-                coloffset = 1
-                if isinstance(self.df.index, MultiIndex):
-                    coloffset = len(self.df.index[0])
-
-            colnames = self.columns
-            if has_aliases:
-                if len(self.header) != len(self.columns):
-                    raise ValueError('Writing %d cols but got %d aliases' %
-                                     (len(self.columns), len(self.header)))
-                else:
-                    colnames = self.header
-
-            for colindex, colname in enumerate(colnames):
-                yield ExcelCell(self.rowcounter, colindex + coloffset, colname,
-                                header_style)
-
-    def _format_header(self):
-        if isinstance(self.columns, MultiIndex):
-            gen = self._format_header_mi()
-        else:
-            gen = self._format_header_regular()
-
-        gen2 = ()
-        if self.df.index.names:
-            row = [x if x is not None else ''
-                   for x in self.df.index.names] + [''] * len(self.columns)
-            if reduce(lambda x, y: x and y, map(lambda x: x != '', row)):
-                gen2 = (ExcelCell(self.rowcounter, colindex, val, header_style)
-                        for colindex, val in enumerate(row))
-                self.rowcounter += 1
-        return itertools.chain(gen, gen2)
-
-    def _format_body(self):
-
-        if isinstance(self.df.index, MultiIndex):
-            return self._format_hierarchical_rows()
-        else:
-            return self._format_regular_rows()
-
-    def _format_regular_rows(self):
-        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
-        if has_aliases or self.header:
-            self.rowcounter += 1
-
-        coloffset = 0
-        # output index and index_label?
-        if self.index:
-            # chek aliases
-            # if list only take first as this is not a MultiIndex
-            if (self.index_label and
-                    isinstance(self.index_label, (list, tuple, np.ndarray,
-                                                  Index))):
-                index_label = self.index_label[0]
-            # if string good to go
-            elif self.index_label and isinstance(self.index_label, str):
-                index_label = self.index_label
-            else:
-                index_label = self.df.index.names[0]
-
-            if isinstance(self.columns, MultiIndex):
-                self.rowcounter += 1
-
-            if index_label and self.header is not False:
-                yield ExcelCell(self.rowcounter - 1, 0, index_label,
-                                header_style)
-
-            # write index_values
-            index_values = self.df.index
-            if isinstance(self.df.index, PeriodIndex):
-                index_values = self.df.index.to_timestamp()
-
-            coloffset = 1
-            for idx, idxval in enumerate(index_values):
-                yield ExcelCell(self.rowcounter + idx, 0, idxval, header_style)
-
-        # Write the body of the frame data series by series.
-        for colidx in range(len(self.columns)):
-            series = self.df.iloc[:, colidx]
-            for i, val in enumerate(series):
-                yield ExcelCell(self.rowcounter + i, colidx + coloffset, val)
-
-    def _format_hierarchical_rows(self):
-        has_aliases = isinstance(self.header, (tuple, list, np.ndarray, Index))
-        if has_aliases or self.header:
-            self.rowcounter += 1
-
-        gcolidx = 0
-
-        if self.index:
-            index_labels = self.df.index.names
-            # check for aliases
-            if (self.index_label and
-                    isinstance(self.index_label, (list, tuple, np.ndarray,
-                                                  Index))):
-                index_labels = self.index_label
-
-            # MultiIndex columns require an extra row
-            # with index names (blank if None) for
-            # unambigous round-trip, unless not merging,
-            # in which case the names all go on one row Issue #11328
-            if isinstance(self.columns, MultiIndex) and self.merge_cells:
-                self.rowcounter += 1
-
-            # if index labels are not empty go ahead and dump
-            if (any(x is not None for x in index_labels) and
-                    self.header is not False):
-
-                for cidx, name in enumerate(index_labels):
-                    yield ExcelCell(self.rowcounter - 1, cidx, name,
-                                    header_style)
-
-            if self.merge_cells:
-                # Format hierarchical rows as merged cells.
-                level_strs = self.df.index.format(sparsify=True, adjoin=False,
-                                                  names=False)
-                level_lengths = _get_level_lengths(level_strs)
-
-                for spans, levels, labels in zip(level_lengths,
-                                                 self.df.index.levels,
-                                                 self.df.index.labels):
-
-                    values = levels.take(labels,
-                                         allow_fill=levels._can_hold_na,
-                                         fill_value=True)
-
-                    for i in spans:
-                        if spans[i] > 1:
-                            yield ExcelCell(self.rowcounter + i, gcolidx,
-                                            values[i], header_style,
-                                            self.rowcounter + i + spans[i] - 1,
-                                            gcolidx)
-                        else:
-                            yield ExcelCell(self.rowcounter + i, gcolidx,
-                                            values[i], header_style)
-                    gcolidx += 1
-
-            else:
-                # Format hierarchical rows with non-merged values.
-                for indexcolvals in zip(*self.df.index):
-                    for idx, indexcolval in enumerate(indexcolvals):
-                        yield ExcelCell(self.rowcounter + idx, gcolidx,
-                                        indexcolval, header_style)
-                    gcolidx += 1
-
-        # Write the body of the frame data series by series.
-        for colidx in range(len(self.columns)):
-            series = self.df.iloc[:, colidx]
-            for i, val in enumerate(series):
-                yield ExcelCell(self.rowcounter + i, gcolidx + colidx, val)
-
-    def get_formatted_cells(self):
-        for cell in itertools.chain(self._format_header(),
-                                    self._format_body()):
-            cell.val = self._format_value(cell.val)
-            yield cell
 
 # ----------------------------------------------------------------------
 # Array formatters
diff --git a/pandas/io/formats/style.py b/pandas/io/formats/style.py
index 10f18fc35..83062e7d7 100644
--- a/pandas/io/formats/style.py
+++ b/pandas/io/formats/style.py
@@ -25,8 +25,10 @@ import numpy as np
 import pandas as pd
 from pandas.compat import range
 from pandas.core.config import get_option
+from pandas.core.generic import _shared_docs
 import pandas.core.common as com
 from pandas.core.indexing import _maybe_numeric_slice, _non_reducing_slice
+from pandas.util.decorators import Appender
 try:
     import matplotlib.pyplot as plt
     from matplotlib import colors
@@ -151,6 +153,30 @@ class Styler(object):
         """Hooks into Jupyter notebook rich display system."""
         return self.render()
 
+    @Appender(_shared_docs['to_excel'] % dict(
+        axes='index, columns', klass='Styler',
+        axes_single_arg="{0 or 'index', 1 or 'columns'}",
+        optional_by="""
+            by : str or list of str
+                Name or list of names which refer to the axis items.""",
+        versionadded_to_excel='\n    .. versionadded:: 0.20'))
+    def to_excel(self, excel_writer, sheet_name='Sheet1', na_rep='',
+                 float_format=None, columns=None, header=True, index=True,
+                 index_label=None, startrow=0, startcol=0, engine=None,
+                 merge_cells=True, encoding=None, inf_rep='inf', verbose=True,
+                 freeze_panes=None):
+
+        from pandas.io.formats.excel import ExcelFormatter
+        formatter = ExcelFormatter(self, na_rep=na_rep, cols=columns,
+                                   header=header,
+                                   float_format=float_format, index=index,
+                                   index_label=index_label,
+                                   merge_cells=merge_cells,
+                                   inf_rep=inf_rep)
+        formatter.write(excel_writer, sheet_name=sheet_name, startrow=startrow,
+                        startcol=startcol, freeze_panes=freeze_panes,
+                        engine=engine)
+
     def _translate(self):
         """
         Convert the DataFrame in `self.data` and the attrs from `_build_styles`
diff --git a/pandas/tests/io/formats/test_css.py b/pandas/tests/io/formats/test_css.py
new file mode 100644
index 000000000..904a33392
--- /dev/null
+++ b/pandas/tests/io/formats/test_css.py
@@ -0,0 +1,256 @@
+import pytest
+
+from pandas.io.formats.css import CSSResolver, CSSWarning
+
+
+def assert_resolves(css, props, inherited=None):
+    resolve = CSSResolver()
+    actual = resolve(css, inherited=inherited)
+    assert props == actual
+
+
+def assert_same_resolution(css1, css2, inherited=None):
+    resolve = CSSResolver()
+    resolved1 = resolve(css1, inherited=inherited)
+    resolved2 = resolve(css2, inherited=inherited)
+    assert resolved1 == resolved2
+
+
+@pytest.mark.parametrize('name,norm,abnorm', [
+    ('whitespace', 'hello: world; foo: bar',
+     ' \t hello \t :\n  world \n  ;  \n foo: \tbar\n\n'),
+    ('case', 'hello: world; foo: bar', 'Hello: WORLD; foO: bar'),
+    ('empty-decl', 'hello: world; foo: bar',
+     '; hello: world;; foo: bar;\n; ;'),
+    ('empty-list', '', ';'),
+])
+def test_css_parse_normalisation(name, norm, abnorm):
+    assert_same_resolution(norm, abnorm)
+
+
+@pytest.mark.xfail(reason='CSS comments not yet stripped')
+def test_css_parse_comments():
+    assert_same_resolution('hello: world',
+                           'hello/* foo */:/* bar \n */ world /*;not:here*/')
+
+
+@pytest.mark.xfail(reason='''we don't need to handle specificity
+                             markers like !important, but we should
+                             ignore them in the future''')
+def test_css_parse_specificity():
+    assert_same_resolution('font-weight: bold', 'font-weight: bold !important')
+
+
+@pytest.mark.xfail(reason='Splitting CSS declarations not yet sensitive to '
+                          '; in CSS strings')
+def test_css_parse_strings():
+    # semicolons in strings
+    assert_resolves('background-image: url(\'http://blah.com/foo?a;b=c\')',
+                    {'background-image': 'url(\'http://blah.com/foo?a;b=c\')'})
+    assert_resolves('background-image: url("http://blah.com/foo?a;b=c")',
+                    {'background-image': 'url("http://blah.com/foo?a;b=c")'})
+
+
+@pytest.mark.parametrize(
+    'invalid_css,remainder', [
+        # No colon
+        ('hello-world', ''),
+        ('border-style: solid; hello-world', 'border-style: solid'),
+        ('border-style: solid; hello-world; font-weight: bold',
+         'border-style: solid; font-weight: bold'),
+        # Unclosed string
+        pytest.mark.xfail(('background-image: "abc', ''),
+                          reason='Unclosed CSS strings not detected'),
+        pytest.mark.xfail(('font-family: "abc', ''),
+                          reason='Unclosed CSS strings not detected'),
+        pytest.mark.xfail(('background-image: \'abc', ''),
+                          reason='Unclosed CSS strings not detected'),
+        pytest.mark.xfail(('font-family: \'abc', ''),
+                          reason='Unclosed CSS strings not detected'),
+        # Invalid size
+        ('font-size: blah', 'font-size: 1em'),
+        ('font-size: 1a2b', 'font-size: 1em'),
+        ('font-size: 1e5pt', 'font-size: 1em'),
+        ('font-size: 1+6pt', 'font-size: 1em'),
+        ('font-size: 1unknownunit', 'font-size: 1em'),
+        ('font-size: 10', 'font-size: 1em'),
+        ('font-size: 10 pt', 'font-size: 1em'),
+    ])
+def test_css_parse_invalid(invalid_css, remainder):
+    with pytest.warns(CSSWarning):
+        assert_same_resolution(invalid_css, remainder)
+
+    # TODO: we should be checking that in other cases no warnings are raised
+
+
+@pytest.mark.parametrize(
+    'shorthand,expansions',
+    [('margin', ['margin-top', 'margin-right',
+                 'margin-bottom', 'margin-left']),
+     ('padding', ['padding-top', 'padding-right',
+                  'padding-bottom', 'padding-left']),
+     ('border-width', ['border-top-width', 'border-right-width',
+                       'border-bottom-width', 'border-left-width']),
+     ('border-color', ['border-top-color', 'border-right-color',
+                       'border-bottom-color', 'border-left-color']),
+     ('border-style', ['border-top-style', 'border-right-style',
+                       'border-bottom-style', 'border-left-style']),
+     ])
+def test_css_side_shorthands(shorthand, expansions):
+    top, right, bottom, left = expansions
+
+    assert_resolves('%s: 1pt' % shorthand,
+                    {top: '1pt', right: '1pt',
+                     bottom: '1pt', left: '1pt'})
+
+    assert_resolves('%s: 1pt 4pt' % shorthand,
+                    {top: '1pt', right: '4pt',
+                     bottom: '1pt', left: '4pt'})
+
+    assert_resolves('%s: 1pt 4pt 2pt' % shorthand,
+                    {top: '1pt', right: '4pt',
+                     bottom: '2pt', left: '4pt'})
+
+    assert_resolves('%s: 1pt 4pt 2pt 0pt' % shorthand,
+                    {top: '1pt', right: '4pt',
+                     bottom: '2pt', left: '0pt'})
+
+    with pytest.warns(CSSWarning):
+        assert_resolves('%s: 1pt 1pt 1pt 1pt 1pt' % shorthand,
+                        {})
+
+
+@pytest.mark.xfail(reason='CSS font shorthand not yet handled')
+@pytest.mark.parametrize('css,props', [
+    ('font: italic bold 12pt helvetica,sans-serif',
+     {'font-family': 'helvetica,sans-serif',
+      'font-style': 'italic',
+      'font-weight': 'bold',
+      'font-size': '12pt'}),
+    ('font: bold italic 12pt helvetica,sans-serif',
+     {'font-family': 'helvetica,sans-serif',
+      'font-style': 'italic',
+      'font-weight': 'bold',
+      'font-size': '12pt'}),
+])
+def test_css_font_shorthand(css, props):
+    assert_resolves(css, props)
+
+
+@pytest.mark.xfail(reason='CSS background shorthand not yet handled')
+@pytest.mark.parametrize('css,props', [
+    ('background: blue', {'background-color': 'blue'}),
+    ('background: fixed blue',
+     {'background-color': 'blue', 'background-attachment': 'fixed'}),
+])
+def test_css_background_shorthand(css, props):
+    assert_resolves(css, props)
+
+
+@pytest.mark.xfail(reason='CSS border shorthand not yet handled')
+@pytest.mark.parametrize('style,equiv', [
+    ('border: 1px solid red',
+     'border-width: 1px; border-style: solid; border-color: red'),
+    ('border: solid red 1px',
+     'border-width: 1px; border-style: solid; border-color: red'),
+    ('border: red solid',
+     'border-style: solid; border-color: red'),
+])
+def test_css_border_shorthand(style, equiv):
+    assert_same_resolution(style, equiv)
+
+
+@pytest.mark.parametrize('style,inherited,equiv', [
+    ('margin: 1px; margin: 2px', '',
+     'margin: 2px'),
+    ('margin: 1px', 'margin: 2px',
+     'margin: 1px'),
+    ('margin: 1px; margin: inherit', 'margin: 2px',
+     'margin: 2px'),
+    ('margin: 1px; margin-top: 2px', '',
+     'margin-left: 1px; margin-right: 1px; ' +
+     'margin-bottom: 1px; margin-top: 2px'),
+    ('margin-top: 2px', 'margin: 1px',
+     'margin: 1px; margin-top: 2px'),
+    ('margin: 1px', 'margin-top: 2px',
+     'margin: 1px'),
+    ('margin: 1px; margin-top: inherit', 'margin: 2px',
+     'margin: 1px; margin-top: 2px'),
+])
+def test_css_precedence(style, inherited, equiv):
+    resolve = CSSResolver()
+    inherited_props = resolve(inherited)
+    style_props = resolve(style, inherited=inherited_props)
+    equiv_props = resolve(equiv)
+    assert style_props == equiv_props
+
+
+@pytest.mark.parametrize('style,equiv', [
+    ('margin: 1px; margin-top: inherit',
+     'margin-bottom: 1px; margin-right: 1px; margin-left: 1px'),
+    ('margin-top: inherit', ''),
+    ('margin-top: initial', ''),
+])
+def test_css_none_absent(style, equiv):
+    assert_same_resolution(style, equiv)
+
+
+@pytest.mark.parametrize('size,resolved', [
+    ('xx-small', '6pt'),
+    ('x-small', '%fpt' % 7.5),
+    ('small', '%fpt' % 9.6),
+    ('medium', '12pt'),
+    ('large', '%fpt' % 13.5),
+    ('x-large', '18pt'),
+    ('xx-large', '24pt'),
+
+    ('8px', '6pt'),
+    ('1.25pc', '15pt'),
+    ('.25in', '18pt'),
+    ('02.54cm', '72pt'),
+    ('25.4mm', '72pt'),
+    ('101.6q', '72pt'),
+    ('101.6q', '72pt'),
+])
+@pytest.mark.parametrize('relative_to',  # invariant to inherited size
+                         [None, '16pt'])
+def test_css_absolute_font_size(size, relative_to, resolved):
+    if relative_to is None:
+        inherited = None
+    else:
+        inherited = {'font-size': relative_to}
+    assert_resolves('font-size: %s' % size, {'font-size': resolved},
+                    inherited=inherited)
+
+
+@pytest.mark.parametrize('size,relative_to,resolved', [
+    ('1em', None, '12pt'),
+    ('1.0em', None, '12pt'),
+    ('1.25em', None, '15pt'),
+    ('1em', '16pt', '16pt'),
+    ('1.0em', '16pt', '16pt'),
+    ('1.25em', '16pt', '20pt'),
+    ('1rem', '16pt', '12pt'),
+    ('1.0rem', '16pt', '12pt'),
+    ('1.25rem', '16pt', '15pt'),
+    ('100%', None, '12pt'),
+    ('125%', None, '15pt'),
+    ('100%', '16pt', '16pt'),
+    ('125%', '16pt', '20pt'),
+    ('2ex', None, '12pt'),
+    ('2.0ex', None, '12pt'),
+    ('2.50ex', None, '15pt'),
+    ('inherit', '16pt', '16pt'),
+
+    ('smaller', None, '10pt'),
+    ('smaller', '18pt', '15pt'),
+    ('larger', None, '%fpt' % 14.4),
+    ('larger', '15pt', '18pt'),
+])
+def test_css_relative_font_size(size, relative_to, resolved):
+    if relative_to is None:
+        inherited = None
+    else:
+        inherited = {'font-size': relative_to}
+    assert_resolves('font-size: %s' % size, {'font-size': resolved},
+                    inherited=inherited)
diff --git a/pandas/tests/io/formats/test_to_excel.py b/pandas/tests/io/formats/test_to_excel.py
new file mode 100644
index 000000000..fff529992
--- /dev/null
+++ b/pandas/tests/io/formats/test_to_excel.py
@@ -0,0 +1,219 @@
+"""Tests formatting as writer-agnostic ExcelCells
+
+ExcelFormatter is tested implicitly in pandas/tests/io/test_excel.py
+"""
+
+import pytest
+
+from pandas.io.formats.excel import CSSToExcelConverter
+
+
+@pytest.mark.parametrize('css,expected', [
+    # FONT
+    # - name
+    ('font-family: foo,bar', {'font': {'name': 'foo'}}),
+    ('font-family: "foo bar",baz', {'font': {'name': 'foo bar'}}),
+    ('font-family: foo,\nbar', {'font': {'name': 'foo'}}),
+    ('font-family: foo, bar,    baz', {'font': {'name': 'foo'}}),
+    ('font-family: bar, foo', {'font': {'name': 'bar'}}),
+    ('font-family: \'foo bar\', baz', {'font': {'name': 'foo bar'}}),
+    ('font-family: \'foo \\\'bar\', baz', {'font': {'name': 'foo \'bar'}}),
+    ('font-family: "foo \\"bar", baz', {'font': {'name': 'foo "bar'}}),
+    ('font-family: "foo ,bar", baz', {'font': {'name': 'foo ,bar'}}),
+    # - family
+    ('font-family: serif', {'font': {'name': 'serif', 'family': 1}}),
+    ('font-family: Serif', {'font': {'name': 'serif', 'family': 1}}),
+    ('font-family: roman, serif', {'font': {'name': 'roman', 'family': 1}}),
+    ('font-family: roman, sans-serif', {'font': {'name': 'roman',
+                                                 'family': 2}}),
+    ('font-family: roman, sans serif', {'font': {'name': 'roman'}}),
+    ('font-family: roman, sansserif', {'font': {'name': 'roman'}}),
+    ('font-family: roman, cursive', {'font': {'name': 'roman', 'family': 4}}),
+    ('font-family: roman, fantasy', {'font': {'name': 'roman', 'family': 5}}),
+    # - size
+    ('font-size: 1em', {'font': {'size': 12}}),
+    # - bold
+    ('font-weight: 100', {'font': {'bold': False}}),
+    ('font-weight: 200', {'font': {'bold': False}}),
+    ('font-weight: 300', {'font': {'bold': False}}),
+    ('font-weight: 400', {'font': {'bold': False}}),
+    ('font-weight: normal', {'font': {'bold': False}}),
+    ('font-weight: lighter', {'font': {'bold': False}}),
+    ('font-weight: bold', {'font': {'bold': True}}),
+    ('font-weight: bolder', {'font': {'bold': True}}),
+    ('font-weight: 700', {'font': {'bold': True}}),
+    ('font-weight: 800', {'font': {'bold': True}}),
+    ('font-weight: 900', {'font': {'bold': True}}),
+    # - italic
+    # - underline
+    ('text-decoration: underline',
+     {'font': {'underline': 'single'}}),
+    ('text-decoration: overline',
+     {}),
+    ('text-decoration: none',
+     {}),
+    # - strike
+    ('text-decoration: line-through',
+     {'font': {'strike': True}}),
+    ('text-decoration: underline line-through',
+     {'font': {'strike': True, 'underline': 'single'}}),
+    ('text-decoration: underline; text-decoration: line-through',
+     {'font': {'strike': True}}),
+    # - color
+    ('color: red', {'font': {'color': 'FF0000'}}),
+    ('color: #ff0000', {'font': {'color': 'FF0000'}}),
+    ('color: #f0a', {'font': {'color': 'FF00AA'}}),
+    # - shadow
+    ('text-shadow: none', {'font': {'shadow': False}}),
+    ('text-shadow: 0px -0em 0px #CCC', {'font': {'shadow': False}}),
+    ('text-shadow: 0px -0em 0px #999', {'font': {'shadow': False}}),
+    ('text-shadow: 0px -0em 0px', {'font': {'shadow': False}}),
+    ('text-shadow: 2px -0em 0px #CCC', {'font': {'shadow': True}}),
+    ('text-shadow: 0px -2em 0px #CCC', {'font': {'shadow': True}}),
+    ('text-shadow: 0px -0em 2px #CCC', {'font': {'shadow': True}}),
+    ('text-shadow: 0px -0em 2px', {'font': {'shadow': True}}),
+    ('text-shadow: 0px -2em', {'font': {'shadow': True}}),
+    pytest.mark.xfail(('text-shadow: #CCC 3px 3px 3px',
+                       {'font': {'shadow': True}}),
+                      reason='text-shadow with color preceding width not yet '
+                             'identified as shadow'),
+    pytest.mark.xfail(('text-shadow: #999 0px 0px 0px',
+                       {'font': {'shadow': False}}),
+                      reason='text-shadow with color preceding zero width not '
+                             'yet identified as non-shadow'),
+    # FILL
+    # - color, fillType
+    ('background-color: red', {'fill': {'fgColor': 'FF0000',
+                                        'patternType': 'solid'}}),
+    ('background-color: #ff0000', {'fill': {'fgColor': 'FF0000',
+                                            'patternType': 'solid'}}),
+    ('background-color: #f0a', {'fill': {'fgColor': 'FF00AA',
+                                         'patternType': 'solid'}}),
+    # BORDER
+    # - style
+    ('border-style: solid',
+     {'border': {'top': {'style': 'medium'},
+                 'bottom': {'style': 'medium'},
+                 'left': {'style': 'medium'},
+                 'right': {'style': 'medium'}}}),
+    ('border-style: solid; border-width: thin',
+     {'border': {'top': {'style': 'thin'},
+                 'bottom': {'style': 'thin'},
+                 'left': {'style': 'thin'},
+                 'right': {'style': 'thin'}}}),
+
+    ('border-top-style: solid; border-top-width: thin',
+     {'border': {'top': {'style': 'thin'}}}),
+    ('border-top-style: solid; border-top-width: 1pt',
+     {'border': {'top': {'style': 'thin'}}}),
+    ('border-top-style: solid',
+     {'border': {'top': {'style': 'medium'}}}),
+    ('border-top-style: solid; border-top-width: medium',
+     {'border': {'top': {'style': 'medium'}}}),
+    ('border-top-style: solid; border-top-width: 2pt',
+     {'border': {'top': {'style': 'medium'}}}),
+    ('border-top-style: solid; border-top-width: thick',
+     {'border': {'top': {'style': 'thick'}}}),
+    ('border-top-style: solid; border-top-width: 4pt',
+     {'border': {'top': {'style': 'thick'}}}),
+
+    ('border-top-style: dotted',
+     {'border': {'top': {'style': 'mediumDashDotDot'}}}),
+    ('border-top-style: dotted; border-top-width: thin',
+     {'border': {'top': {'style': 'dotted'}}}),
+    ('border-top-style: dashed',
+     {'border': {'top': {'style': 'mediumDashed'}}}),
+    ('border-top-style: dashed; border-top-width: thin',
+     {'border': {'top': {'style': 'dashed'}}}),
+    ('border-top-style: double',
+     {'border': {'top': {'style': 'double'}}}),
+    # - color
+    ('border-style: solid; border-color: #0000ff',
+     {'border': {'top': {'style': 'medium', 'color': '0000FF'},
+                 'right': {'style': 'medium', 'color': '0000FF'},
+                 'bottom': {'style': 'medium', 'color': '0000FF'},
+                 'left': {'style': 'medium', 'color': '0000FF'}}}),
+    ('border-top-style: double; border-top-color: blue',
+     {'border': {'top': {'style': 'double', 'color': '0000FF'}}}),
+    ('border-top-style: solid; border-top-color: #06c',
+     {'border': {'top': {'style': 'medium', 'color': '0066CC'}}}),
+    # ALIGNMENT
+    # - horizontal
+    ('text-align: center',
+     {'alignment': {'horizontal': 'center'}}),
+    ('text-align: left',
+     {'alignment': {'horizontal': 'left'}}),
+    ('text-align: right',
+     {'alignment': {'horizontal': 'right'}}),
+    ('text-align: justify',
+     {'alignment': {'horizontal': 'justify'}}),
+    # - vertical
+    ('vertical-align: top',
+     {'alignment': {'vertical': 'top'}}),
+    ('vertical-align: text-top',
+     {'alignment': {'vertical': 'top'}}),
+    ('vertical-align: middle',
+     {'alignment': {'vertical': 'center'}}),
+    ('vertical-align: bottom',
+     {'alignment': {'vertical': 'bottom'}}),
+    ('vertical-align: text-bottom',
+     {'alignment': {'vertical': 'bottom'}}),
+    # - wrap_text
+    ('white-space: nowrap',
+     {'alignment': {'wrap_text': False}}),
+    ('white-space: pre',
+     {'alignment': {'wrap_text': False}}),
+    ('white-space: pre-line',
+     {'alignment': {'wrap_text': False}}),
+    ('white-space: normal',
+     {'alignment': {'wrap_text': True}}),
+])
+def test_css_to_excel(css, expected):
+    convert = CSSToExcelConverter()
+    assert expected == convert(css)
+
+
+def test_css_to_excel_multiple():
+    convert = CSSToExcelConverter()
+    actual = convert('''
+        font-weight: bold;
+        text-decoration: underline;
+        color: red;
+        border-width: thin;
+        text-align: center;
+        vertical-align: top;
+        unused: something;
+    ''')
+    assert {"font": {"bold": True, "underline": "single", "color": "FF0000"},
+            "border": {"top": {"style": "thin"},
+                       "right": {"style": "thin"},
+                       "bottom": {"style": "thin"},
+                       "left": {"style": "thin"}},
+            "alignment": {"horizontal": "center",
+                          "vertical": "top"}} == actual
+
+
+@pytest.mark.parametrize('css,inherited,expected', [
+    ('font-weight: bold', '',
+     {'font': {'bold': True}}),
+    ('', 'font-weight: bold',
+     {'font': {'bold': True}}),
+    ('font-weight: bold', 'font-style: italic',
+     {'font': {'bold': True, 'italic': True}}),
+    ('font-style: normal', 'font-style: italic',
+     {'font': {'italic': False}}),
+    ('font-style: inherit', '', {}),
+    ('font-style: normal; font-style: inherit', 'font-style: italic',
+     {'font': {'italic': True}}),
+])
+def test_css_to_excel_inherited(css, inherited, expected):
+    convert = CSSToExcelConverter(inherited)
+    assert expected == convert(css)
+
+
+@pytest.mark.xfail(reason='We are not currently warning for all unconverted '
+                          'CSS, but possibly should')
+def test_css_to_excel_warns_when_not_supported():
+    convert = CSSToExcelConverter()
+    with pytest.warns(UserWarning):
+        convert('background: red')
diff --git a/pandas/tests/io/test_excel.py b/pandas/tests/io/test_excel.py
index d9e036481..12d5c29cd 100644
--- a/pandas/tests/io/test_excel.py
+++ b/pandas/tests/io/test_excel.py
@@ -17,6 +17,7 @@ import numpy as np
 
 import pandas as pd
 from pandas import DataFrame, Index, MultiIndex
+from pandas.io.formats.excel import ExcelFormatter
 from pandas.io.parsers import read_csv
 from pandas.io.excel import (
     ExcelFile, ExcelWriter, read_excel, _XlwtWriter, _Openpyxl1Writer,
@@ -2006,7 +2007,7 @@ class Openpyxl20Tests(ExcelWriterBase, tm.TestCase):
         self.assertEqual(kw['protection'], protection)
 
     def test_write_cells_merge_styled(self):
-        from pandas.io.formats.format import ExcelCell
+        from pandas.io.formats.excel import ExcelCell
         from openpyxl import styles
 
         sheet_name = 'merge_styled'
@@ -2119,7 +2120,7 @@ class Openpyxl22Tests(ExcelWriterBase, tm.TestCase):
         if not openpyxl_compat.is_compat(major_ver=2):
             pytest.skip('incompatible openpyxl version')
 
-        from pandas.io.formats.format import ExcelCell
+        from pandas.io.formats.excel import ExcelCell
 
         sheet_name = 'merge_styled'
 
@@ -2351,3 +2352,141 @@ class ExcelWriterEngineTests(tm.TestCase):
                 check_called(
                     lambda: df.to_excel(
                         'something.xls', engine='dummy'))
+
+
+@pytest.mark.parametrize('engine', [
+    pytest.mark.xfail('xlwt', reason='xlwt does not support '
+                                     'openpyxl-compatible style dicts'),
+    'xlsxwriter',
+    'openpyxl',
+])
+def test_styler_to_excel(engine):
+    def style(df):
+        # XXX: RGB colors not supported in xlwt
+        return DataFrame([['font-weight: bold', '', ''],
+                          ['', 'color: blue', ''],
+                          ['', '', 'text-decoration: underline'],
+                          ['border-style: solid', '', ''],
+                          ['', 'font-style: italic', ''],
+                          ['', '', 'text-align: right'],
+                          ['background-color: red', '', ''],
+                          ['', '', ''],
+                          ['', '', ''],
+                          ['', '', '']],
+                         index=df.index, columns=df.columns)
+
+    def assert_equal_style(cell1, cell2):
+        # XXX: should find a better way to check equality
+        assert cell1.alignment.__dict__ == cell2.alignment.__dict__
+        assert cell1.border.__dict__ == cell2.border.__dict__
+        assert cell1.fill.__dict__ == cell2.fill.__dict__
+        assert cell1.font.__dict__ == cell2.font.__dict__
+        assert cell1.number_format == cell2.number_format
+        assert cell1.protection.__dict__ == cell2.protection.__dict__
+
+    def custom_converter(css):
+        # use bold iff there is custom style attached to the cell
+        if css.strip(' \n;'):
+            return {'font': {'bold': True}}
+        return {}
+
+    pytest.importorskip('jinja2')
+    pytest.importorskip(engine)
+
+    if engine == 'openpyxl' and openpyxl_compat.is_compat(major_ver=1):
+        pytest.xfail('openpyxl1 does not support some openpyxl2-compatible '
+                     'style dicts')
+
+    # Prepare spreadsheets
+
+    df = DataFrame(np.random.randn(10, 3))
+    with ensure_clean('.xlsx' if engine != 'xlwt' else '.xls') as path:
+        writer = ExcelWriter(path, engine=engine)
+        df.to_excel(writer, sheet_name='frame')
+        df.style.to_excel(writer, sheet_name='unstyled')
+        styled = df.style.apply(style, axis=None)
+        styled.to_excel(writer, sheet_name='styled')
+        ExcelFormatter(styled, style_converter=custom_converter).write(
+            writer, sheet_name='custom')
+
+    # For engines other than openpyxl 2, we only smoke test
+    if engine != 'openpyxl':
+        return
+    if not openpyxl_compat.is_compat(major_ver=2):
+        pytest.skip('incompatible openpyxl version')
+
+    # (1) compare DataFrame.to_excel and Styler.to_excel when unstyled
+    n_cells = 0
+    for col1, col2 in zip(writer.sheets['frame'].columns,
+                          writer.sheets['unstyled'].columns):
+        assert len(col1) == len(col2)
+        for cell1, cell2 in zip(col1, col2):
+            assert cell1.value == cell2.value
+            assert_equal_style(cell1, cell2)
+            n_cells += 1
+
+    # ensure iteration actually happened:
+    assert n_cells == (10 + 1) * (3 + 1)
+
+    # (2) check styling with default converter
+    n_cells = 0
+    for col1, col2 in zip(writer.sheets['frame'].columns,
+                          writer.sheets['styled'].columns):
+        assert len(col1) == len(col2)
+        for cell1, cell2 in zip(col1, col2):
+            ref = '%s%d' % (cell2.column, cell2.row)
+            # XXX: this isn't as strong a test as ideal; we should
+            #      differences are exclusive
+            if ref == 'B2':
+                assert not cell1.font.bold
+                assert cell2.font.bold
+            elif ref == 'C3':
+                assert cell1.font.color.rgb != cell2.font.color.rgb
+                assert cell2.font.color.rgb == '000000FF'
+            elif ref == 'D4':
+                assert cell1.font.underline != cell2.font.underline
+                assert cell2.font.underline == 'single'
+            elif ref == 'B5':
+                assert not cell1.border.left.style
+                assert (cell2.border.top.style ==
+                        cell2.border.right.style ==
+                        cell2.border.bottom.style ==
+                        cell2.border.left.style ==
+                        'medium')
+            elif ref == 'C6':
+                assert not cell1.font.italic
+                assert cell2.font.italic
+            elif ref == 'D7':
+                assert (cell1.alignment.horizontal !=
+                        cell2.alignment.horizontal)
+                assert cell2.alignment.horizontal == 'right'
+            elif ref == 'B8':
+                assert cell1.fill.fgColor.rgb != cell2.fill.fgColor.rgb
+                assert cell1.fill.patternType != cell2.fill.patternType
+                assert cell2.fill.fgColor.rgb == '00FF0000'
+                assert cell2.fill.patternType == 'solid'
+            else:
+                assert_equal_style(cell1, cell2)
+
+            assert cell1.value == cell2.value
+            n_cells += 1
+
+    assert n_cells == (10 + 1) * (3 + 1)
+
+    # (3) check styling with custom converter
+    n_cells = 0
+    for col1, col2 in zip(writer.sheets['frame'].columns,
+                          writer.sheets['custom'].columns):
+        assert len(col1) == len(col2)
+        for cell1, cell2 in zip(col1, col2):
+            ref = '%s%d' % (cell2.column, cell2.row)
+            if ref in ('B2', 'C3', 'D4', 'B5', 'C6', 'D7', 'B8'):
+                assert not cell1.font.bold
+                assert cell2.font.bold
+            else:
+                assert_equal_style(cell1, cell2)
+
+            assert cell1.value == cell2.value
+            n_cells += 1
+
+    assert n_cells == (10 + 1) * (3 + 1)

commit 613eb938be7aeb2286a2618808f7f7ae9ca7c78d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 26 21:49:52 2011 -0400

    ENH: cython code generation for faster take functions, some integration

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 97c53f0ad..8ace1d21e 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -81,17 +81,21 @@ def _unpickle_array(bytes):
     arr = read_array(StringIO(bytes))
     return arr
 
-def null_out_axis(arr, mask, axis):
-    indexer = [slice(None)] * arr.ndim
-    indexer[axis] = mask
-
-    arr[tuple(indexer)] = np.NaN
-
 def _take_1d_bool(arr, indexer, out):
     view = arr.view(np.uint8)
     outview = out.view(np.uint8)
     lib.take_1d_bool(view, indexer, outview)
 
+def _take_2d_axis0_bool(arr, indexer, out):
+    view = arr.view(np.uint8)
+    outview = out.view(np.uint8)
+    lib.take_2d_axis0_bool(view, indexer, outview)
+
+def _take_2d_axis1_bool(arr, indexer, out):
+    view = arr.view(np.uint8)
+    outview = out.view(np.uint8)
+    lib.take_2d_axis1_bool(view, indexer, outview)
+
 _take1d_dict = {
     'float64' : lib.take_1d_float64,
     'int32' : lib.take_1d_int32,
@@ -100,9 +104,31 @@ _take1d_dict = {
     'bool' : _take_1d_bool
 }
 
+_take2d_axis0_dict = {
+    'float64' : lib.take_2d_axis0_float64,
+    'int32' : lib.take_2d_axis0_int32,
+    'int64' : lib.take_2d_axis0_int64,
+    'object' : lib.take_2d_axis0_object,
+    'bool' : _take_2d_axis0_bool
+}
+
+_take2d_axis1_dict = {
+    'float64' : lib.take_2d_axis1_float64,
+    'int32' : lib.take_2d_axis1_int32,
+    'int64' : lib.take_2d_axis1_int64,
+    'object' : lib.take_2d_axis1_object,
+    'bool' : _take_2d_axis1_bool
+}
+
+def _get_take2d_function(dtype_str, axis=0):
+    if axis == 0:
+        return _take2d_axis0_dict[dtype_str]
+    else:
+        return _take2d_axis1_dict[dtype_str]
+
 def take_1d(arr, indexer):
     """
-    Specialized Cython take which sets NaN values
+    Specialized Cython take which sets NaN values in one pass
     """
     dtype_str = arr.dtype.name
 
@@ -129,6 +155,62 @@ def take_1d(arr, indexer):
 
     return out
 
+def take_2d(arr, indexer, mask=None, needs_masking=None, axis=0):
+    """
+    Specialized Cython take which sets NaN values in one pass
+    """
+    dtype_str = arr.dtype.name
+
+    out_shape = list(arr.shape)
+    out_shape[axis] = len(indexer)
+    out_shape = tuple(out_shape)
+
+    if dtype_str in ('int32', 'int64', 'bool'):
+        if mask is None:
+            mask = indexer == -1
+            needs_masking = mask.any()
+
+        if needs_masking:
+            out = arr.take(indexer, axis=axis)
+            out = _maybe_upcast(out)
+            null_out_axis(out, mask, axis)
+        else:
+            out = np.empty(out_shape, dtype=arr.dtype)
+            take_f = _get_take2d_function(dtype_str, axis=axis)
+            take_f(arr, indexer, out=out)
+    elif dtype_str in ('float64', 'object'):
+        out = np.empty(out_shape, dtype=arr.dtype)
+        take_f = _get_take2d_function(dtype_str, axis=axis)
+        take_f(arr, indexer, out=out)
+    else:
+        out = arr.take(indexer, axis=axis)
+        if mask is None:
+            mask = indexer == -1
+            needs_masking = mask.any()
+
+        if needs_masking:
+            out = _maybe_upcast(out)
+            null_out_axis(out, mask, axis)
+
+    return out
+
+def null_out_axis(arr, mask, axis):
+    indexer = [slice(None)] * arr.ndim
+    indexer[axis] = mask
+
+    arr[tuple(indexer)] = np.NaN
+
+def take_fast(arr, indexer, mask, needs_masking, axis=0):
+    if arr.ndim == 2:
+        return take_2d(arr, indexer, mask=mask,
+                       needs_masking=needs_masking,
+                       axis=axis)
+    out = arr.take(indexer, axis=axis)
+    if needs_masking:
+        out = _maybe_upcast(out)
+        null_out_axis(out, mask, axis)
+    return out
+
 def _maybe_upcast(values):
     if issubclass(values.dtype.type, np.int_):
         values = values.astype(float)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index f8ffc2f6c..5cfe0831b 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -98,21 +98,18 @@ class Block(object):
         #     union_ref = self.ref_items + other.ref_items
         return _merge_blocks([self, other], self.ref_items)
 
-    def reindex_axis(self, indexer, notmask, needs_masking, axis=0):
+    def reindex_axis(self, indexer, mask, needs_masking, axis=0):
         """
         Reindex using pre-computed indexer information
         """
         if self.values.size > 0:
-            new_values = self.values.take(indexer, axis=axis)
+            new_values = common.take_fast(self.values, indexer, mask,
+                                          needs_masking, axis=axis)
         else:
             shape = list(self.shape)
             shape[axis] = len(indexer)
             new_values = np.empty(shape)
             new_values.fill(np.nan)
-
-        if needs_masking:
-            new_values = _cast_if_bool_int(new_values)
-            common.null_out_axis(new_values, notmask, axis)
         return make_block(new_values, self.items, self.ref_items)
 
     def reindex_items_from(self, new_ref_items):
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
new file mode 100644
index 000000000..9d36acda1
--- /dev/null
+++ b/pandas/src/generate_code.py
@@ -0,0 +1,117 @@
+from cStringIO import StringIO
+
+take_1d_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_%(name)s(ndarray[%(c_type)s] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[%(c_type)s] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            %(na_action)s
+        else:
+            outbuf[i] = values[idx]
+
+"""
+
+take_2d_axis0_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_%(name)s(ndarray[%(c_type)s, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[%(c_type)s, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                %(na_action)s
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+"""
+
+take_2d_axis1_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_%(name)s(ndarray[%(c_type)s, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[%(c_type)s, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                %(na_action)s
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+"""
+
+set_na = "outbuf[i] = NaN"
+set_na_2d = "outbuf[i, j] = NaN"
+raise_on_na = "raise ValueError('No NA values allowed')"
+
+# name, ctype, capable of holding NA
+function_list = [
+    ('float64', 'float64_t', True),
+    ('object', 'object', True),
+    ('int32', 'int32_t', False),
+    ('int64', 'int64_t', False),
+    ('bool', 'uint8_t', False)
+]
+
+def generate_from_template(template, ndim=1):
+    output = StringIO()
+    for name, c_type, can_hold_na in function_list:
+        if ndim == 1:
+            na_action = set_na if can_hold_na else raise_on_na
+        elif ndim == 2:
+            na_action = set_na_2d if can_hold_na else raise_on_na
+        func = template % {'name' : name, 'c_type' : c_type,
+                           'na_action' : na_action}
+        output.write(func)
+    return output.getvalue()
+
+def generate_take_cython_file(path='take.pyx'):
+    with open(path, 'w') as f:
+        print >> f, generate_from_template(take_1d_template)
+        print >> f, generate_from_template(take_2d_axis0_template, ndim=2)
+        print >> f, generate_from_template(take_2d_axis1_template, ndim=2)
+
+if __name__ == '__main__':
+    generate_take_cython_file()
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index c8930baec..e61b99fa7 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -27,59 +27,45 @@ def backfill(ndarray[object] oldIndex, ndarray[object] newIndex,
     D
     '''
     cdef int i, j, oldLength, newLength, curLoc
-    # Make empty vectors
     cdef ndarray[int32_t, ndim=1] fill_vec
     cdef int newPos, oldPos
     cdef object prevOld, curOld
 
-    # Get the size
     oldLength = len(oldIndex)
     newLength = len(newIndex)
 
     fill_vec = np.empty(len(newIndex), dtype = np.int32)
     fill_vec.fill(-1)
 
-    # Current positions
     oldPos = oldLength - 1
     newPos = newLength - 1
 
-    # corner case, no filling possible
     if newIndex[0] > oldIndex[oldLength - 1]:
         return fill_vec
 
     while newPos >= 0:
         curOld = oldIndex[oldPos]
 
-        # Until we reach a point where we are before the curOld point
         while newIndex[newPos] > curOld:
             newPos -= 1
             if newPos < 0:
                 break
 
-        # Get the location in the old index
         curLoc = oldMap[curOld]
 
-        # At the beginning of the old index
         if oldPos == 0:
-            # Make sure we are before the curOld index
             if newIndex[newPos] <= curOld:
                 fill_vec[:newPos + 1] = curLoc
-            # Exit the main loop
             break
         else:
-            # Get the index there
             prevOld = oldIndex[oldPos - 1]
 
-            # Until we reach the previous index
             while newIndex[newPos] > prevOld:
-                # Set the current fill location
                 fill_vec[newPos] = curLoc
 
                 newPos -= 1
                 if newPos < 0:
                     break
-
-        # Move one period back
         oldPos -= 1
 
     return fill_vec
@@ -110,12 +96,10 @@ def pad(ndarray[object] oldIndex, ndarray[object] newIndex,
     C        C        2               1
     '''
     cdef int i, j, oldLength, newLength, curLoc
-    # Make empty vectors
     cdef ndarray[int32_t, ndim=1] fill_vec
     cdef int newPos, oldPos
     cdef object prevOld, curOld
 
-    # Get the size
     oldLength = len(oldIndex)
     newLength = len(newIndex)
 
@@ -125,53 +109,38 @@ def pad(ndarray[object] oldIndex, ndarray[object] newIndex,
     oldPos = 0
     newPos = 0
 
-    # corner case, no filling possible
     if newIndex[newLength - 1] < oldIndex[0]:
         return fill_vec
 
     while newPos < newLength:
         curOld = oldIndex[oldPos]
 
-        # At beginning, keep going until we go exceed the
-        # first OLD index in the NEW index
         while newIndex[newPos] < curOld:
             newPos += 1
             if newPos > newLength - 1:
                 break
 
-        # We got there, get the current location in the old index
         curLoc = oldMap[curOld]
 
-        # We're at the end of the road, need to propagate this value to the end
         if oldPos == oldLength - 1:
             if newIndex[newPos] >= curOld:
                 fill_vec[newPos:] = curLoc
             break
         else:
-            # Not at the end, need to go about filling
-
-            # Get the next index so we know when to stop propagating this value
             nextOld = oldIndex[oldPos + 1]
-
             done = 0
 
-            # Until we reach the next OLD value in the NEW index
             while newIndex[newPos] < nextOld:
-                # Use this location to fill
                 fill_vec[newPos] = curLoc
                 newPos += 1
 
-                # We got to the end of the new index
                 if newPos > newLength - 1:
                     done = 1
                     break
 
-            # We got to the end of the new index
             if done:
                 break
 
-        # We already advanced the iterold pointer to the next value,
-        # inc the count
         oldPos += 1
 
     return fill_vec
@@ -583,33 +552,6 @@ def outer_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
 
     return result, lindexer, rindexer
 
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_axis0(ndarray[float64_t, ndim=2] values,
-               ndarray[int32_t] indexer,
-               out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[float64_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
-
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                outbuf[i, j] = NaN
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
-
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_join_contiguous(ndarray[float64_t, ndim=2] lvalues,
@@ -651,146 +593,6 @@ def take_join_contiguous(ndarray[float64_t, ndim=2] lvalues,
                 outbuf[0] = rvalues[ridx, j]
                 outbuf = outbuf + 1
 
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_axis1(ndarray[float64_t, ndim=2] values,
-               ndarray[int32_t] indexer,
-               out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[float64_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
-
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-
-        if idx == -1:
-            for i from 0 <= i < n:
-                outbuf[i, j] = NaN
-        else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
-                    out=None):
-    cdef:
-        Py_ssize_t i, n, idx
-        ndarray[float64_t] outbuf
-
-    n = len(indexer)
-
-    if out is None:
-        outbuf = np.empty(n, dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-        if idx == -1:
-            outbuf[i] = NaN
-        else:
-            outbuf[i] = values[idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
-                   out=None):
-    cdef:
-        Py_ssize_t i, n, idx
-        ndarray[object] outbuf
-        object nan
-
-    nan = np.nan
-
-    n = len(indexer)
-
-    if out is None:
-        outbuf = np.empty(n, dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-        if idx == -1:
-            outbuf[i] = nan
-        else:
-            outbuf[i] = values[idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
-                  out=None):
-    cdef:
-        Py_ssize_t i, n, idx
-        ndarray[int32_t] outbuf
-
-    n = len(indexer)
-
-    if out is None:
-        outbuf = np.empty(n, dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
-                  out=None):
-    cdef:
-        Py_ssize_t i, n, idx
-        ndarray[int64_t] outbuf
-
-    n = len(indexer)
-
-    if out is None:
-        outbuf = np.empty(n, dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
-                 out=None):
-    cdef:
-        Py_ssize_t i, n, idx
-        ndarray[uint8_t] outbuf
-
-    n = len(indexer)
-
-    if out is None:
-        outbuf = np.empty(n, dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for i from 0 <= i < n:
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
-
 def ordered_put_indexer(ndarray[int64_t] left, ndarray[int64_t] right,
                         ndarray[float64_t, ndim=2] lvalues,
                         ndarray[float64_t, ndim=2] rvalues,
diff --git a/pandas/src/take.pyx b/pandas/src/take.pyx
new file mode 100644
index 000000000..bcc45f8cb
--- /dev/null
+++ b/pandas/src/take.pyx
@@ -0,0 +1,383 @@
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[float64_t] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = NaN
+        else:
+            outbuf[i] = values[idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[object] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = NaN
+        else:
+            outbuf[i] = values[idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[int32_t] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            raise ValueError('No NA values allowed')
+        else:
+            outbuf[i] = values[idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[int64_t] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            raise ValueError('No NA values allowed')
+        else:
+            outbuf[i] = values[idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
+                     out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[uint8_t] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            raise ValueError('No NA values allowed')
+        else:
+            outbuf[i] = values[idx]
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = NaN
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_object(ndarray[object, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[object, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = NaN
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int32_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[uint8_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_float64(ndarray[float64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = NaN
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_object(ndarray[object, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[object, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = NaN
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int32_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int64_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[uint8_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 654d9255b..3a0361a79 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -5,3 +5,4 @@ include "groupby.pyx"
 include "moments.pyx"
 include "reindex.pyx"
 include "io.pyx"
+include "take.pyx"

commit 5254e523d330d8560a255a08949b950af6d0c0d0
Author: jmorris0x0 <jmorris0x0@gmail.com>
Date:   Mon Aug 4 09:06:28 2014 -0400

    BUG: Fix Grouper with multi-level index and frequency (GH7885)

diff --git a/doc/source/v0.15.0.txt b/doc/source/v0.15.0.txt
index aa6d1dff2..f73c080b6 100644
--- a/doc/source/v0.15.0.txt
+++ b/doc/source/v0.15.0.txt
@@ -480,7 +480,7 @@ Enhancements
 
 
 
-
+- Bug in ``DataFrame.groupby`` where ``Grouper`` does not recognize level when frequency is specified (:issue:`7885`)
 
 
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 41ff6a696..afebdb306 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -248,7 +248,7 @@ class Grouper(object):
             key = self.key
             if key not in obj._info_axis:
                 raise KeyError("The grouper name {0} is not found".format(key))
-            ax = Index(obj[key],name=key)
+            ax = Index(obj[key], name=key)
 
         else:
             ax = obj._get_axis(self.axis)
@@ -258,18 +258,12 @@ class Grouper(object):
                 # if a level is given it must be a mi level or
                 # equivalent to the axis name
                 if isinstance(ax, MultiIndex):
-
-                    if isinstance(level, compat.string_types):
-                        if obj.index.name != level:
-                            raise ValueError('level name %s is not the name of the '
-                                             'index' % level)
-                    elif level > 0:
-                        raise ValueError('level > 0 only valid with MultiIndex')
-                    ax = Index(ax.get_level_values(level), name=level)
+                    level = ax._get_level_number(level)
+                    ax = Index(ax.get_level_values(level), name=ax.names[level])
 
                 else:
-                    if not (level == 0 or level == ax.name):
-                        raise ValueError("The grouper level {0} is not valid".format(level))
+                    if level not in (0, ax.name):
+                        raise ValueError("The level {0} is not valid".format(level))
 
         # possibly sort
         if (self.sort or sort) and not ax.is_monotonic:
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 84aaed819..b44b948c9 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -351,6 +351,24 @@ class TestGroupBy(tm.TestCase):
             df.index = list(reversed(df.index.tolist()))
             df.groupby(list('abcde')).apply(lambda x: x)
 
+    def test_grouper_multilevel_freq(self):
+        # GH 7885
+        from datetime import date, timedelta
+        d0 = date.today() - timedelta(days=14)
+        dates = date_range(d0, date.today())
+        date_index = pd.MultiIndex.from_product([dates, dates], names=['foo', 'bar'])
+        df = pd.DataFrame(np.random.randint(0, 100, 225), index=date_index)
+        # Check string level
+        expected = df.reset_index().groupby([pd.Grouper(key='foo', freq='W'),
+                                             pd.Grouper(key='bar', freq='W')]).sum()
+        result = df.groupby([pd.Grouper(level='foo', freq='W'),
+                             pd.Grouper(level='bar', freq='W')]).sum()
+        assert_frame_equal(result, expected)
+        # Check integer level
+        result = df.groupby([pd.Grouper(level=0, freq='W'),
+                             pd.Grouper(level=1, freq='W')]).sum()
+        assert_frame_equal(result, expected)
+
     def test_grouper_iter(self):
         self.assertEqual(sorted(self.df.groupby('A').grouper), ['bar', 'foo'])
 

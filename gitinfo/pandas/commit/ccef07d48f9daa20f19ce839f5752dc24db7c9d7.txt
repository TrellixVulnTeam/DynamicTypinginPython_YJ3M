commit ccef07d48f9daa20f19ce839f5752dc24db7c9d7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Dec 6 19:51:55 2009 +0000

    more unit tests for DataFrame and DataMatrix
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@76 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 17efeb8d4..ba4a84b4f 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1,6 +1,6 @@
 # pylint: disable-msg=E1101
 # pylint: disable-msg=E1103
-# pylint: disable-msg=W0212
+# pylint: disable-msg=W0212,W0703
 
 import operator
 
@@ -59,36 +59,42 @@ class DataFrame(Picklable, Groupable):
         >>> d = {'col1' : ts1, 'col2' : ts2}
         >>> df = DataFrame(data=d, index=someIndex)
     """
-    def __init__(self, data = None, index = None):
-        series = data
+    def __init__(self, data=None, index=None):
         self._series = {}
-        if series is not None and len(series) > 0:
+        if data is not None and len(data) > 0:
             if index is None:
-                for s in series.values(): break
-                if hasattr(s, 'index'):
+                s = data.values()[0]
+                if isinstance(s, Series):
                     self.index = s.index
                 else:
-                    self.index = Index(np.arange(len(s)))
+                    self.index = np.arange(len(s))
             else:
-                if isinstance(index, Index):
-                    self.index = index
-                else:
-                    self.index = Index(index)
-            for k, v in series.iteritems():
+                self.index = index
+
+            for k, v in data.iteritems():
                 if isinstance(v, Series):
-                    self._series[k] = v.reindex(self.index) # Forces homogoneity
+                    # Forces homogoneity and copies data
+                    self._series[k] = v.reindex(self.index)
                 else:
-                    assert(len(v) == len(self.index))
-                    s = Series(v, index=self.index)
-                    self._series[k] = s
+                    # Copies data and checks length
+                    self._series[k] = Series(v, index=self.index)
+
         elif index is not None:
-            if isinstance(index, Index):
-                self.index = index
-            else:
-                self.index = Index(index)
+            self.index = index
         else:
             raise Exception('DataFrame constructor not properly called!')
 
+    def _set_index(self, index):
+        if isinstance(index, Index):
+            self._index = index
+        else:
+            self._index = Index(index)
+
+    def _get_index(self):
+        return self._index
+
+    index = property(fget=_get_index, fset=_set_index)
+
     # Alternate constructors
     @classmethod
     def fromDict(cls, inputDict=None, castFloat=True, **kwds):
@@ -124,7 +130,7 @@ class DataFrame(Picklable, Groupable):
             inputDict = {}
         else:
             if not hasattr(inputDict, 'iteritems'):
-                raise Exception('Input must be dict or dict-like!')
+                raise Exception('Input must be a dict or dict-like!')
             inputDict = inputDict.copy()
 
         inputDict.update(kwds)
@@ -155,11 +161,27 @@ class DataFrame(Picklable, Groupable):
                     columns[key] = Series(tmp, dtype=float, index=index)
                 else:
                     columns[key] = Series(tmp, index=index)
-            except Exception, e:
+            except Exception:
                 columns[key] = Series(tmp, index=index)
 
         return DataFrame(data=columns, index=index)
 
+    def toDict(self):
+        """
+        Simpler pseudo-inverse operation of dictToDataFrame, NaN values will be
+        included in the resulting dict-tree.
+
+        Return
+        ------
+        nested dict mapping: {column -> index -> value}
+        """
+        tree = {}
+        for col, series in self.iteritems():
+            tree[col] = branch = {}
+            for i in self.index:
+                branch[i] = series[i]
+        return tree
+
     @classmethod
     def fromRecords(cls, data, indexField=None):
         """
@@ -177,8 +199,7 @@ class DataFrame(Picklable, Groupable):
         if data.dtype.type != np.void:
             raise Exception('Input was not a structured array!')
 
-        columns = data.dtype.names
-        dataDict = dict((k, data[k]) for k in columns)
+        dataDict = dict((k, data[k]) for k in data.dtype.names)
 
         if indexField is not None:
             index = dataDict.pop(indexField)
@@ -232,9 +253,8 @@ class DataFrame(Picklable, Groupable):
 
         idxMap = colIndex.indexMap
 
-        return DataFrame(data = dict([(idx, mat[:, idxMap[idx]])
-                                      for idx in colIndex]),
-                         index = index)
+        data = dict([(idx, mat[:, idxMap[idx]]) for idx in colIndex])
+        return DataFrame(data=data, index=index)
 
 #-------------------------------------------------------------------------------
 # Magic methods
@@ -274,6 +294,7 @@ class DataFrame(Picklable, Groupable):
                     newColumns[col] = series[start:stop]
                 return DataFrame(data=newColumns, index=dateRange)
             elif isinstance(item, np.ndarray):
+
                 if len(item) != len(self.index):
                     raise Exception('Item wrong length %d instead of %d!' %
                                     (len(item), len(self.index)))
@@ -293,22 +314,19 @@ class DataFrame(Picklable, Groupable):
         ensure homogeneity.
         """
         # Array
-        try:
-            if hasattr(value, '__iter__'):
-                if hasattr(value, 'reindex'):
-                    cleanSeries = value.reindex(self.index)
-                else:
-                    cleanSeries = Series(value, index=self.index)
-                assert(len(cleanSeries) == len(self.index))
-                self._series[key] = cleanSeries
-
-            # Scalar
+        if hasattr(value, '__iter__'):
+            if isinstance(value, Series):
+                cleanSeries = value.reindex(self.index)
             else:
-                self._series[key] = Series.fromValue(value, index=self.index)
-        except AssertionError:
-            raise
-        except Exception, e:
-            raise Exception('Could not put key, value pair in Frame!')
+                cleanSeries = Series(value, index=self.index)
+
+            if len(cleanSeries) != len(self.index):
+                raise Exception('Series was wrong length!')
+
+            self._series[key] = cleanSeries
+        # Scalar
+        else:
+            self._series[key] = Series.fromValue(value, index=self.index)
 
     def __delitem__(self, key):
         """
@@ -334,7 +352,7 @@ class DataFrame(Picklable, Groupable):
         """
         Iterate over columns of the frame.
         """
-        return self._series.__iter__()
+        return iter(self._series)
 
     def __len__(self):
         """
@@ -361,11 +379,7 @@ class DataFrame(Picklable, Groupable):
     __rpow__ = arith_method(lambda x, y: y ** x, '__rpow__')
 
     def __neg__(self):
-        mycopy = self.copy()
-        myseries = mycopy._series
-        for col in myseries:
-            mycopy[col] = -myseries[col]
-        return mycopy
+        return self * -1
 
 #-------------------------------------------------------------------------------
 # Private / helper methods
@@ -494,12 +508,14 @@ class DataFrame(Picklable, Groupable):
         else:
             f = open(path, 'w')
         cols = self.cols() if cols is None else cols
+
         if inclHeader:
             if inclIndex:
                 f.write(',' + ','.join([str(c) for c in cols]))
             else:
                 f.write(','.join([str(c) for c in cols]))
             f.write('\n')
+
         for idx in self.index:
             if inclIndex:
                 f.write(str(idx) + ',')
@@ -517,22 +533,6 @@ class DataFrame(Picklable, Groupable):
         if verbose:
             print 'CSV file written successfully: %s' % path
 
-    def toDict(self):
-        """
-        Simpler pseudo-inverse operation of dictToDataFrame, NaN values will be
-        included in the resulting dict-tree.
-
-        Return
-        ------
-        nested dict mapping: {column -> index -> value}
-        """
-        tree = {}
-        for col, series in self.iteritems():
-            tree[col] = branch = {}
-            for i in self.index:
-                branch[i] = series[i]
-        return tree
-
     def toDataMatrix(self):
         from pandas.core.matrix import DataMatrix
 
@@ -738,10 +738,6 @@ class DataFrame(Picklable, Groupable):
 
             N = len(intersection)
 
-            #if len(cols) < N:
-                #diff = str(set(specificColumns) - set(cols))
-                #raise Exception('Missing columns: %s' % diff)
-
             filtered = self.filterItems(intersection)
             theCount = filtered.count(axis=1, asarray=True)
         else:
@@ -1384,7 +1380,7 @@ class DataFrame(Picklable, Groupable):
         """
         try:
             theCount = np.isfinite(self.values).sum(axis)
-        except Exception, e:
+        except Exception:
             f = lambda s: notnull(s).sum()
             if axis == 0:
                 theCount = self.apply(f)
@@ -1438,7 +1434,7 @@ class DataFrame(Picklable, Groupable):
             theSum = y.sum(axis)
             theCount = self.count(axis)
             theSum[theCount == 0] = NaN
-        except Exception, e:
+        except Exception:
             if axis == 0:
                 theSum = self.apply(np.sum)
             else:
@@ -1476,7 +1472,7 @@ class DataFrame(Picklable, Groupable):
             theProd = y.prod(axis)
             theCount = self.count(axis)
             theProd[theCount == 0] = NaN
-        except Exception, e:
+        except Exception:
             if axis == 0:
                 theProd = self.apply(np.prod)
             else:
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index d6cfa4d49..0d0f39cd8 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -207,7 +207,7 @@ class DataMatrix(DataFrame):
 # Alternate constructors
 
     @classmethod
-    def fromDict(cls, inputDict={}, castFloat=True, **kwds):
+    def fromDict(cls, inputDict=None, castFloat=True, **kwds):
         """
         Convert a two-level tree representation of a series or time series
         to a DataMatrix.
@@ -232,6 +232,13 @@ class DataMatrix(DataFrame):
         df1 = DataMatrix.fromDict(myDict)
         df2 = DataMatrix.fromDict(A=seriesA, B=seriesB)
         """
+        if inputDict is None:
+            inputDict = {}
+        else:
+            if not hasattr(inputDict, 'iteritems'):
+                raise Exception('Input must be a dict or dict-like!')
+            inputDict = inputDict.copy()
+
         inputDict.update(kwds)
 
         # Get set of indices
@@ -244,7 +251,7 @@ class DataMatrix(DataFrame):
         series = {}
         for col, mapping in inputDict.iteritems():
             if not isinstance(mapping, Series):
-                mapping = Series.fromDict(mapping)
+                mapping = Series.fromDict(mapping, castFloat=castFloat)
             series[col] = mapping.reindex(index)
 
         return DataMatrix(series, index=index)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 8b11804cb..2aed8a818 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1,3 +1,5 @@
+# pylint: disable-msg=W0612
+
 from copy import deepcopy
 from datetime import datetime
 import unittest
@@ -18,22 +20,30 @@ class TestDataFrame(unittest.TestCase):
     klass = DataFrame
 
     def setUp(self):
-        index1 = DateRange(datetime(2008,4,22), periods=50)
-        index2 = DateRange(datetime(2008,4,29), periods=50)
-        index3 = DateRange(datetime(2008,4,28), periods=50)
-        ts1 = Series(random.random(50), index=index1)
-        ts2 = Series(random.random(50), index=index2)
-        ts3 = Series(random.random(50), index=index3)
-        ts4 = Series(random.random(50), index=index1)
-        data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
-        self.frame = self.klass(data=data, index=index3)
-        self.ts1 = ts1
-        self.ts2 = ts2
-        self.ts3 = ts3
-        self.ts4 = ts4
+        self.seriesd = common.getSeriesData()
+        self.tsd = common.getTimeSeriesData()
+
+        self.frame = self.klass(self.seriesd)
+        self.tsframe = self.klass(self.tsd)
+
+        self.mixed_frame = self.frame.copy()
+        self.mixed_frame['foo'] = 'bar'
+
+        self.ts1 = common.makeTimeSeries()
+        self.ts2 = common.makeTimeSeries()[5:]
+        self.ts3 = common.makeTimeSeries()[-5:]
+        self.ts4 = common.makeTimeSeries()[1:-1]
+
+        self.ts_dict = {
+            'col1' : self.ts1,
+            'col2' : self.ts2,
+            'col3' : self.ts3,
+            'col4' : self.ts4,
+        }
 
     def test_constructor(self):
-        pass
+
+        self.assertRaises(Exception, DataFrame)
 
     def test_constructor_mixed(self):
         index, data = common.getMixedTypeDict()
@@ -42,53 +52,155 @@ class TestDataFrame(unittest.TestCase):
         unindexed_frame = self.klass(data)
 
     def test_fromDict(self):
-        newFrame = self.klass.fromDict(col1=self.ts1, col2 = self.ts2)
-        for idx in newFrame.index:
-            if idx in self.ts1.index:
-                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
-            if idx in self.ts2.index:
-                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
+        frame = self.klass.fromDict(col1=self.ts1, col2 = self.ts2)
+
+        common.assert_dict_equal(self.ts1, frame['col1'], compare_keys=False)
+        common.assert_dict_equal(self.ts2, frame['col2'], compare_keys=False)
+
+        # cast float tests
+        test_data = {
+                'A' : {'1' : 1, '2' : 2},
+                'B' : {'1' : '1', '2' : '2', '3' : '3'},
+        }
+        frame = self.klass.fromDict(test_data)
+        self.assertEqual(len(frame), 3)
+        self.assert_(frame['B'].dtype == np.float_)
+        self.assert_(frame['A'].dtype == np.float_)
+
+        frame = self.klass.fromDict(test_data, castFloat=False)
+        self.assertEqual(len(frame), 3)
+        self.assert_(frame['B'].dtype == np.object_)
+        self.assert_(frame['A'].dtype == np.float_)
+
+        # can't cast to float
+        test_data = {
+                'A' : dict(zip(range(20), common.makeDateIndex(20))),
+                'B' : dict(zip(range(15), common.randn(15)))
+        }
+        frame = self.klass.fromDict(test_data)
+        self.assertEqual(len(frame), 20)
+        self.assert_(frame['A'].dtype == np.object_)
+        self.assert_(frame['B'].dtype == np.float_)
+
+        # Corner cases
+        self.assertEqual(len(self.klass.fromDict({})), 0)
+        self.assertEqual(len(self.klass.fromDict()), 0)
+        self.assertRaises(Exception, self.klass.fromDict, [self.ts1, self.ts2])
 
-    def test_fromRecords(self):
+    def test_toDict(self):
         pass
 
-    def test_toRecords(self):
-        pass
+    def test_fromRecords(self):
+        # from numpy documentation
+        arr = np.zeros((2,),dtype=('i4,f4,a10'))
+        arr[:] = [(1,2.,'Hello'),(2,3.,"World")]
+
+        frame = self.klass.fromRecords(arr)
+        indexed_frame = self.klass.fromRecords(arr, indexField='f1')
+
+        self.assertRaises(Exception, self.klass.fromRecords, np.zeros((2, 3)))
+
+        # what to do?
+        records = indexed_frame.toRecords()
+        self.assertEqual(len(records.dtype.names), 3)
 
     def test_fromMatrix(self):
-        pass
+        mat = np.zeros((2, 3), dtype=float)
+
+        frame = self.klass.fromMatrix(mat, ['A', 'B', 'C'], [1, 2])
+
+        self.assertEqual(len(frame.index), 2)
+        self.assertEqual(len(frame.cols()), 3)
+
+        self.assertRaises(Exception, self.klass.fromMatrix,
+                          mat, ['A', 'B', 'C'], [1])
+        self.assertRaises(Exception, self.klass.fromMatrix,
+                          mat, ['A', 'B'], [1, 2])
 
     def test_nonzero(self):
         pass
 
     def test_repr(self):
-        pass
+        # small one
+        foo = repr(self.frame)
+
+        # big one
+        biggie = self.klass.fromMatrix(np.zeros((1000, 4)),
+                                       range(4), range(1000))
+        foo = repr(biggie)
+
+        # mixed
+        foo = repr(self.mixed_frame)
+
+        # big mixed
+        biggie = self.klass({'A' : common.randn(1000),
+                             'B' : common.makeStringIndex(1000)},
+                            index=range(1000))
+        foo = repr(biggie)
 
     def test_getitem(self):
-        """Slicing NOT intended for production code"""
+        # slicing
+
         sl = self.frame[:20]
         self.assertEqual(20, len(sl.index))
+
+        # column access
+
         for _, series in sl.iteritems():
             self.assertEqual(20, len(series.index))
             self.assert_(common.equalContents(series.index, sl.index))
 
         for key, _ in self.frame._series.iteritems():
             self.assert_(self.frame[key] is not None)
+
         self.assert_('random' not in self.frame)
+        self.assertRaises(Exception, self.frame.__getitem__, 'random')
+
+        # boolean indexing
+        d = self.tsframe.index[10]
+        indexer = self.tsframe.index > d
+
+        subindex = self.tsframe.index[indexer]
+        subframe = self.tsframe[indexer]
+
+        self.assert_(np.array_equal(subindex, subframe.index))
+        self.assertRaises(Exception, self.tsframe.__getitem__, indexer[:-1])
 
     def test_setitem(self):
         # not sure what else to do here
-        series = self.frame['col1']
+        series = self.frame['A'][::2]
         self.frame['col5'] = series
         self.assert_('col5' in self.frame)
+        common.assert_dict_equal(series, self.frame['col5'],
+                                 compare_keys=False)
+
+        series = self.frame['A']
+        self.frame['col6'] = series
+        common.assert_dict_equal(series, self.frame['col6'],
+                                 compare_keys=False)
+
+        # set value
+        self.frame['col7'] = 5
+        assert((self.frame['col7'] == 5).all())
+
+        self.frame['col8'] = 'foo'
+        assert((self.frame['col8'] == 'foo').all())
+
+        self.assertRaises(Exception, self.frame.__setitem__,
+                          common.randn(len(self.frame) + 1))
+
 
     def test_delitem(self):
-        del self.frame['col1']
-        self.assert_('col1' not in self.frame)
-        self.assert_('col1' not in self.frame._series)
+        del self.frame['A']
+        self.assert_('A' not in self.frame)
 
     def test_pop(self):
-        pass
+        A = self.frame.pop('A')
+        self.assert_('A' not in self.frame)
+
+        self.frame['foo'] = 'bar'
+        foo = self.frame.pop('foo')
+        self.assert_('foo' not in self.frame)
 
     def test_iter(self):
         pass
@@ -120,7 +232,8 @@ class TestDataFrame(unittest.TestCase):
                     self.assert_(np.isnan(origVal))
 
     def test_neg(self):
-        pass
+        # what to do?
+        f = -self.frame
 
     def test_firstTimeWithNValues(self):
         pass
@@ -143,9 +256,6 @@ class TestDataFrame(unittest.TestCase):
     def test_toCSV(self):
         pass
 
-    def test_toDict(self):
-        pass
-
     def test_toDataMatrix(self):
         pass
 
@@ -176,7 +286,7 @@ class TestDataFrame(unittest.TestCase):
     def test_asMatrix(self):
         frame = self.frame
         mat = frame.asMatrix()
-        smallerCols = ['col3', 'col1']
+        smallerCols = ['C', 'A']
         # smallerMat = frame.asMatrix(smallerCols)
         frameCols = frame.cols()
         for i, row in enumerate(mat):
@@ -192,10 +302,10 @@ class TestDataFrame(unittest.TestCase):
 
     def test_deepcopy(self):
         cp = deepcopy(self.frame)
-        series = cp['col1']
+        series = cp['A']
         series[:] = 10
         for idx, value in series.iteritems():
-            self.assertNotEqual(self.frame['col1'][idx], value)
+            self.assertNotEqual(self.frame['A'][idx], value)
 
     def test_copy(self):
         pass
@@ -213,7 +323,7 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_getTS(self):
-        frame = self.frame
+        frame = self.tsframe
         tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
         for i, idx in enumerate(tsFrame.index):
             self.assertEqual(idx, frame.index[5+i])
@@ -284,12 +394,12 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_shift(self):
-        shiftedFrame = self.frame.shift(5)
+        shiftedFrame = self.tsframe.shift(5)
         for i, idx in enumerate(shiftedFrame.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
-        series = shiftedFrame['col1']
+            self.assert_(idx-5*bday == self.tsframe.index[i])
+        series = shiftedFrame['A']
         for i, idx in enumerate(series.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
+            self.assert_(idx-5*bday == self.tsframe.index[i])
 
     def test_apply(self):
         pass

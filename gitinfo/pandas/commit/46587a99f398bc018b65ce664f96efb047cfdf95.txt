commit 46587a99f398bc018b65ce664f96efb047cfdf95
Author: Jeffrey Tratner <jeffrey.tratner@gmail.com>
Date:   Fri Aug 9 22:26:12 2013 -0400

    ENH: Make core/index exceptions more descriptive
    
    * `assert_copy`: You can use `assert_copy` to check that two iterables
      produce copies that are not the same object. (uses `assert_almost_equal`
      under the hood).
    * Fix assert_almost_equal to handle non-ndarrays (previously failed
      after iterable check)
    * Fix test_mixed_panel to reflect true name behavior

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 224925f14..29a7f84cd 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -1229,7 +1229,9 @@ However:
 ::
 
    >>> s.ix[('a', 'b'):('b', 'a')]
-   Exception: MultiIndex lexsort depth 1, key was length 2
+   Traceback (most recent call last)
+        ...
+   KeyError: Key length (3) was greater than MultiIndex lexsort depth (2)
 
 Swapping levels with ``swaplevel``
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 33ea4d25b..15e9398bd 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -109,7 +109,7 @@ class Index(PandasObject, np.ndarray):
 
             subarr = com._asarray_tuplesafe(data, dtype=object)
         elif np.isscalar(data):
-            raise ValueError('Index(...) must be called with a collection '
+            raise TypeError('Index(...) must be called with a collection '
                              'of some kind, %s was passed' % repr(data))
         else:
             # other iterable of some kind
@@ -201,7 +201,7 @@ class Index(PandasObject, np.ndarray):
 
     def _set_names(self, values):
         if len(values) != 1:
-            raise AssertionError('Length of new names must be 1, got %d'
+            raise ValueError('Length of new names must be 1, got %d'
                                  % len(values))
         self.name = values[0]
 
@@ -327,7 +327,7 @@ class Index(PandasObject, np.ndarray):
         return hash(self.view(np.ndarray))
 
     def __setitem__(self, key, value):
-        raise Exception(str(self.__class__) + ' object is immutable')
+        raise TypeError(str(self.__class__) + ' does not support item assignment')
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
@@ -513,7 +513,7 @@ class Index(PandasObject, np.ndarray):
             return sorted_index
 
     def sort(self, *args, **kwargs):
-        raise Exception('Cannot sort an Index object')
+        raise TypeError('Cannot sort an %r object' % self.__class__.__name__)
 
     def shift(self, periods=1, freq=None):
         """
@@ -572,7 +572,7 @@ class Index(PandasObject, np.ndarray):
         union : Index
         """
         if not hasattr(other, '__iter__'):
-            raise Exception('Input must be iterable!')
+            raise TypeError('Input must be iterable.')
 
         if len(other) == 0 or self.equals(other):
             return self
@@ -637,7 +637,7 @@ class Index(PandasObject, np.ndarray):
         intersection : Index
         """
         if not hasattr(other, '__iter__'):
-            raise Exception('Input must be iterable!')
+            raise TypeError('Input must be iterable!')
 
         self._assert_can_do_setop(other)
 
@@ -679,7 +679,7 @@ class Index(PandasObject, np.ndarray):
         """
 
         if not hasattr(other, '__iter__'):
-            raise Exception('Input must be iterable!')
+            raise TypeError('Input must be iterable!')
 
         if self.equals(other):
             return Index([], name=self.name)
@@ -807,7 +807,7 @@ class Index(PandasObject, np.ndarray):
             return this.get_indexer(target, method=method, limit=limit)
 
         if not self.is_unique:
-            raise Exception('Reindexing only valid with uniquely valued Index '
+            raise InvalidIndexError('Reindexing only valid with uniquely valued Index '
                             'objects')
 
         if method == 'pad':
@@ -900,7 +900,7 @@ class Index(PandasObject, np.ndarray):
         target = _ensure_index(target)
         if level is not None:
             if method is not None:
-                raise ValueError('Fill method not supported if level passed')
+                raise TypeError('Fill method not supported if level passed')
             _, indexer, _ = self._join_level(target, level, how='right',
                                              return_indexers=True)
         else:
@@ -1055,7 +1055,7 @@ class Index(PandasObject, np.ndarray):
         the MultiIndex will not be changed (currently)
         """
         if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):
-            raise Exception('Join on level between two MultiIndex objects '
+            raise TypeError('Join on level between two MultiIndex objects '
                             'is ambiguous')
 
         left, right = self, other
@@ -1429,11 +1429,10 @@ class MultiIndex(Index):
 
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
         if len(levels) != len(labels):
-            raise AssertionError(
+            raise ValueError(
                 'Length of levels and labels must be the same')
         if len(levels) == 0:
-            raise Exception('Must pass non-zero number of levels/labels')
-
+            raise TypeError('Must pass non-zero number of levels/labels')
         if len(levels) == 1:
             if names:
                 name = names[0]
@@ -1534,17 +1533,17 @@ class MultiIndex(Index):
         try:
             count = self.names.count(level)
             if count > 1:
-                raise Exception('The name %s occurs multiple times, use a '
+                raise ValueError('The name %s occurs multiple times, use a '
                                 'level number' % level)
             level = self.names.index(level)
         except ValueError:
             if not isinstance(level, int):
-                raise Exception('Level %s not found' % str(level))
+                raise KeyError('Level %s not found' % str(level))
             elif level < 0:
                 level += self.nlevels
             # Note: levels are zero-based
             elif level >= self.nlevels:
-                raise ValueError('Index has only %d levels, not %d'
+                raise IndexError('Too many levels: Index has only %d levels, not %d'
                                  % (self.nlevels, level + 1))
         return level
 
@@ -1790,7 +1789,8 @@ class MultiIndex(Index):
         index : MultiIndex
         """
         if len(tuples) == 0:
-            raise Exception('Cannot infer number of levels from empty list')
+            # I think this is right? Not quite sure...
+            raise TypeError('Cannot infer number of levels from empty list')
 
         if isinstance(tuples, np.ndarray):
             if isinstance(tuples, Index):
@@ -2158,7 +2158,8 @@ class MultiIndex(Index):
         """
         if level is not None:
             if method is not None:
-                raise ValueError('Fill method not supported if level passed')
+                # FIXME: Should this actually be a TypeError [given that it's a signature issue] or ValueError
+                raise TypeError('Fill method not supported if level passed')
             target, indexer, _ = self._join_level(target, level, how='right',
                                                   return_indexers=True)
         else:
@@ -2202,7 +2203,7 @@ class MultiIndex(Index):
     def slice_locs(self, start=None, end=None, strict=False):
         """
         For an ordered MultiIndex, compute the slice locations for input
-        labels. They can tuples representing partial levels, e.g. for a
+        labels. They can be tuples representing partial levels, e.g. for a
         MultiIndex with 3 levels, you can pass a single value (corresponding to
         the first level), or a 1-, 2-, or 3-tuple.
 
@@ -2240,8 +2241,9 @@ class MultiIndex(Index):
 
     def _partial_tup_index(self, tup, side='left'):
         if len(tup) > self.lexsort_depth:
-            raise KeyError('MultiIndex lexsort depth %d, key was length %d' %
-                           (self.lexsort_depth, len(tup)))
+            raise KeyError('Key length (%d) was greater than MultiIndex'
+                           ' lexsort depth (%d)' %
+                           (len(tup), self.lexsort_depth))
 
         n = len(tup)
         start, end = 0, len(self)
@@ -2251,7 +2253,7 @@ class MultiIndex(Index):
 
             if lab not in lev:
                 if not lev.is_type_compatible(lib.infer_dtype([lab])):
-                    raise Exception('Level type mismatch: %s' % lab)
+                    raise TypeError('Level type mismatch: %s' % lab)
 
                 # short circuit
                 loc = lev.searchsorted(lab, side=side)
@@ -2546,7 +2548,7 @@ class MultiIndex(Index):
             try:
                 other = MultiIndex.from_tuples(other)
             except:
-                raise TypeError("other should be a MultiIndex or a list of tuples")
+                raise TypeError("other must be a MultiIndex or a list of tuples")
             result_names = self.names
         else:
             result_names = self.names if self.names == other.names else None
@@ -2588,7 +2590,7 @@ class MultiIndex(Index):
         if not isinstance(item, tuple):
             item = (item,) + ('',) * (self.nlevels - 1)
         elif len(item) != self.nlevels:
-            raise ValueError('Passed item incompatible tuple length')
+            raise ValueError('Item must have length equal to number of levels.')
 
         new_levels = []
         new_labels = []
@@ -2691,7 +2693,7 @@ def _ensure_index(index_like):
 
 def _validate_join_method(method):
     if method not in ['left', 'right', 'inner', 'outer']:
-        raise Exception('do not recognize join method %s' % method)
+        raise ValueError('do not recognize join method %s' % method)
 
 
 # TODO: handle index names!
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 1b405eae0..9e49d79de 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -5920,14 +5920,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         assert_series_equal(result, expected)
 
     def test_drop_names(self):
-        df = DataFrame([[1, 2, 3],[3, 4, 5],[5, 6, 7]], index=['a', 'b', 'c'], columns=['d', 'e', 'f'])
+        df = DataFrame([[1, 2, 3],[3, 4, 5],[5, 6, 7]], index=['a', 'b', 'c'],
+                       columns=['d', 'e', 'f'])
         df.index.name, df.columns.name = 'first', 'second'
         df_dropped_b = df.drop('b')
         df_dropped_e = df.drop('e', axis=1)
-        self.assert_(df_dropped_b.index.name == 'first')
-        self.assert_(df_dropped_e.index.name == 'first')
-        self.assert_(df_dropped_b.columns.name == 'second')
-        self.assert_(df_dropped_e.columns.name == 'second')
+        self.assertEqual(df_dropped_b.index.name, 'first')
+        self.assertEqual(df_dropped_e.index.name, 'first')
+        self.assertEqual(df_dropped_b.columns.name, 'second')
+        self.assertEqual(df_dropped_e.columns.name, 'second')
 
     def test_dropEmptyRows(self):
         N = len(self.frame.index)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index cc069a4da..5942f8cd9 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -11,8 +11,8 @@ import os
 import numpy as np
 from numpy.testing import assert_array_equal
 
-from pandas.core.index import Index, Int64Index, MultiIndex
-from pandas.util.testing import assert_almost_equal
+from pandas.core.index import Index, Int64Index, MultiIndex, InvalidIndexError
+from pandas.util.testing import assert_almost_equal, assertRaisesRegexp
 from pandas import compat
 
 import pandas.util.testing as tm
@@ -37,6 +37,14 @@ class TestIndex(unittest.TestCase):
         self.empty = Index([])
         self.tuples = Index(lzip(['foo', 'bar', 'baz'], [1, 2, 3]))
 
+    def test_wrong_number_names(self):
+        def testit(ind):
+            ind.names = ["apple", "banana", "carrot"]
+
+        indices = (self.dateIndex, self.unicodeIndex, self.strIndex, self.intIndex, self.floatIndex, self.empty, self.tuples)
+        for ind in indices:
+            assertRaisesRegexp(ValueError, "^Length", testit, ind)
+
     def test_hash_error(self):
         self.assertRaises(TypeError, hash, self.strIndex)
 
@@ -56,10 +64,10 @@ class TestIndex(unittest.TestCase):
         self.assert_(not idx.is_unique)
 
     def test_sort(self):
-        self.assertRaises(Exception, self.strIndex.sort)
+        self.assertRaises(TypeError, self.strIndex.sort)
 
     def test_mutability(self):
-        self.assertRaises(Exception, self.strIndex.__setitem__, 0, 'foo')
+        self.assertRaises(TypeError, self.strIndex.__setitem__, 0, 'foo')
 
     def test_constructor(self):
         # regular instance creation
@@ -85,7 +93,7 @@ class TestIndex(unittest.TestCase):
 
     def test_constructor_corner(self):
         # corner case
-        self.assertRaises(Exception, Index, 0)
+        self.assertRaises(TypeError, Index, 0)
 
     def test_index_ctor_infer_periodindex(self):
         from pandas import period_range, PeriodIndex
@@ -219,7 +227,7 @@ class TestIndex(unittest.TestCase):
         self.assert_(inter is first)
 
         # non-iterable input
-        self.assertRaises(Exception, first.intersection, 0.5)
+        assertRaisesRegexp(TypeError, "iterable", first.intersection, 0.5)
 
     def test_union(self):
         first = self.strIndex[5:20]
@@ -239,7 +247,7 @@ class TestIndex(unittest.TestCase):
         self.assert_(union is first)
 
         # non-iterable input
-        self.assertRaises(Exception, first.union, 0.5)
+        assertRaisesRegexp(TypeError, "iterable", first.union, 0.5)
 
         # preserve names
         first.name = 'A'
@@ -325,7 +333,7 @@ class TestIndex(unittest.TestCase):
         self.assertEqual(result.name, first.name)
 
         # non-iterable input
-        self.assertRaises(Exception, first.diff, 0.5)
+        assertRaisesRegexp(TypeError, "iterable", first.diff, 0.5)
 
     def test_pickle(self):
         def testit(index):
@@ -571,6 +579,11 @@ class TestInt64Index(unittest.TestCase):
     def setUp(self):
         self.index = Int64Index(np.arange(0, 20, 2))
 
+    def test_too_many_names(self):
+        def testit():
+            self.index.names = ["roger", "harold"]
+        assertRaisesRegexp(ValueError, "^Length", testit)
+
     def test_constructor(self):
         # pass list, coerce fine
         index = Int64Index([-5, 0, 1, 2])
@@ -969,7 +982,15 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(single_level.name is None)
 
     def test_constructor_no_levels(self):
-        self.assertRaises(Exception, MultiIndex, levels=[], labels=[])
+        assertRaisesRegexp(TypeError, "non-zero number of levels/labels",
+                           MultiIndex, levels=[], labels=[])
+
+    def test_constructor_mismatched_label_levels(self):
+        levels = [np.array([1]), np.array([2]), np.array([3])]
+        labels = ["a"]
+        assertRaisesRegexp(ValueError, "Length of levels and labels must be"
+                           " the same", MultiIndex, levels=levels,
+                           labels=labels)
 
     def test_copy(self):
         i_copy = self.index.copy()
@@ -1017,15 +1038,16 @@ class TestMultiIndex(unittest.TestCase):
 
     def test_duplicate_names(self):
         self.index.names = ['foo', 'foo']
-        self.assertRaises(Exception, self.index._get_level_number, 'foo')
+        assertRaisesRegexp(KeyError, 'Level foo not found',
+                           self.index._get_level_number, 'foo')
 
     def test_get_level_number_integer(self):
         self.index.names = [1, 0]
         self.assertEqual(self.index._get_level_number(1), 0)
         self.assertEqual(self.index._get_level_number(0), 1)
-        self.assertRaises(Exception, self.index._get_level_number, 2)
-
-        self.assertRaises(Exception, self.index._get_level_number, 'fourth')
+        self.assertRaises(IndexError, self.index._get_level_number, 2)
+        assertRaisesRegexp(KeyError, 'Level fourth not found',
+                           self.index._get_level_number, 'fourth')
 
     def test_from_arrays(self):
         arrays = []
@@ -1060,8 +1082,8 @@ class TestMultiIndex(unittest.TestCase):
 
     def test_reorder_levels(self):
         # this blows up
-        self.assertRaises(Exception, self.index.reorder_levels,
-                          [2, 1, 0])
+        assertRaisesRegexp(IndexError, '^Too many levels',
+                           self.index.reorder_levels, [2, 1, 0])
 
     def test_nlevels(self):
         self.assertEquals(self.index.nlevels, 2)
@@ -1234,6 +1256,22 @@ class TestMultiIndex(unittest.TestCase):
         expected = df[6:15].stack()
         tm.assert_almost_equal(sliced.values, expected.values)
 
+    def test_slice_locs_with_type_mismatch(self):
+        df = tm.makeTimeDataFrame()
+        stacked = df.stack()
+        idx = stacked.index
+        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs,
+                           (1, 3))
+        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs,
+                           df.index[5] + timedelta(seconds=30), (5, 2))
+        df = tm.makeCustomDataframe(5, 5)
+        stacked = df.stack()
+        idx = stacked.index
+        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs, timedelta(seconds=30))
+        # TODO: Try creating a UnicodeDecodeError in exception message
+        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs,
+                           df.index[1], (16, "a"))
+
     def test_slice_locs_not_sorted(self):
         index = MultiIndex(levels=[Index(lrange(4)),
                                    Index(lrange(4)),
@@ -1242,8 +1280,9 @@ class TestMultiIndex(unittest.TestCase):
                                    np.array([0, 1, 0, 0, 0, 1, 0, 1]),
                                    np.array([1, 0, 1, 1, 0, 0, 1, 0])])
 
-        self.assertRaises(Exception, index.slice_locs, (1, 0, 1),
-                          (2, 1, 0))
+        assertRaisesRegexp(KeyError, "[Kk]ey length.*greater than MultiIndex"
+                           " lexsort depth", index.slice_locs, (1, 0, 1),
+                           (2, 1, 0))
 
         # works
         sorted_index, _ = index.sortlevel(0)
@@ -1369,6 +1408,12 @@ class TestMultiIndex(unittest.TestCase):
         r1 = idx1.get_indexer([1, 2, 3])
         self.assert_((r1 == [-1, -1, -1]).all())
 
+        # create index with duplicates
+        idx1 = Index(lrange(10) + lrange(10))
+        idx2 = Index(range(20))
+        assertRaisesRegexp(InvalidIndexError, "Reindexing only valid with"
+                           " uniquely valued Index objects",
+                           idx1.get_indexer, idx2)
 
     def test_format(self):
         self.index.format()
@@ -1564,9 +1609,12 @@ class TestMultiIndex(unittest.TestCase):
                                               ('qux', 'one'), ('qux', 'two')])
         expected.names = first.names
         self.assertEqual(first.names, result.names)
+        assertRaisesRegexp(TypeError, "other must be a MultiIndex or a list"
+                           " of tuples", first.diff, [1,2,3,4,5])
 
     def test_from_tuples(self):
-        self.assertRaises(Exception, MultiIndex.from_tuples, [])
+        assertRaisesRegexp(TypeError, 'Cannot infer number of levels from'
+                           ' empty list', MultiIndex.from_tuples, [])
 
         idx = MultiIndex.from_tuples(((1, 2), (3, 4)), names=['a', 'b'])
         self.assertEquals(len(idx), 2)
@@ -1638,8 +1686,8 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(dropped.equals(expected))
 
         index = MultiIndex.from_tuples([('bar', 'two')])
-        self.assertRaises(Exception, self.index.drop, [('bar', 'two')])
-        self.assertRaises(Exception, self.index.drop, index)
+        self.assertRaises(KeyError, self.index.drop, [('bar', 'two')])
+        self.assertRaises(KeyError, self.index.drop, index)
 
         # mixed partial / full drop
         dropped = self.index.drop(['foo', ('qux', 'one')])
@@ -1693,7 +1741,8 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(new_index[0] == ('abc', 'three'))
 
         # key wrong length
-        self.assertRaises(Exception, self.index.insert, 0, ('foo2',))
+        assertRaisesRegexp(ValueError, "Item must have length equal to number"
+                           " of levels", self.index.insert, 0, ('foo2',))
 
     def test_take_preserve_name(self):
         taken = self.index.take([3, 0, 1])
@@ -1740,7 +1789,8 @@ class TestMultiIndex(unittest.TestCase):
         result = idx.join(self.index, level='second')
         tm.assert_isinstance(result, MultiIndex)
 
-        self.assertRaises(Exception, self.index.join, self.index, level=1)
+        assertRaisesRegexp(TypeError, "Join.*MultiIndex.*ambiguous",
+                           self.index.join, self.index, level=1)
 
     def test_join_self(self):
         kinds = 'outer', 'inner', 'left', 'right'
@@ -1774,11 +1824,12 @@ class TestMultiIndex(unittest.TestCase):
         exp_indexer2 = np.array([0, -1, 0, -1, 0, -1])
         self.assert_(np.array_equal(indexer2, exp_indexer2))
 
-        self.assertRaises(ValueError, self.index.reindex,
-                          self.index, method='pad', level='second')
+        assertRaisesRegexp(TypeError, "Fill method not supported",
+                           self.index.reindex, self.index, method='pad',
+                           level='second')
 
-        self.assertRaises(ValueError, idx.reindex,
-                          idx, method='bfill', level='first')
+        assertRaisesRegexp(TypeError, "Fill method not supported",
+                           idx.reindex, idx, method='bfill', level='first')
 
     def test_has_duplicates(self):
         self.assert_(not self.index.has_duplicates)
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 3d2a5f2e5..e8b50e21f 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -1255,7 +1255,8 @@ class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
         lp = panel.to_frame()
         wp = lp.to_panel()
         self.assertEqual(wp['bool'].values.dtype, np.bool_)
-        assert_frame_equal(wp['bool'], panel['bool'])
+        # Previously, this was mutating the underlying index and changing its name
+        assert_frame_equal(wp['bool'], panel['bool'], check_names=False)
 
     def test_to_panel_na_handling(self):
         df = DataFrame(np.random.randint(0, 10, size=20).reshape((10, 2)),
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 82fdf4526..8af88895a 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -176,7 +176,9 @@ def assert_almost_equal(a, b, check_less_precise=False):
         np.testing.assert_(isiterable(b))
         na, nb = len(a), len(b)
         assert na == nb, "%s != %s" % (na, nb)
-
+        # TODO: Figure out why I thought this needed instance cheacks...
+        # if (isinstance(a, np.ndarray) and isinstance(b, np.ndarray) and
+        #     np.array_equal(a, b)):
         if np.array_equal(a, b):
             return True
         else:
@@ -321,6 +323,18 @@ def assert_contains_all(iterable, dic):
     for k in iterable:
         assert k in dic, "Did not contain item: '%r'" % k
 
+def assert_copy(iter1, iter2, **eql_kwargs):
+    """
+    iter1, iter2: iterables that produce elements comparable with assert_almost_equal
+
+    Checks that the elements are equal, but not the same object. (Does not
+    check that items in sequences are also not the same object)
+    """
+    for elem1, elem2 in zip(iter1, iter2):
+        assert_almost_equal(elem1, elem2, **eql_kwargs)
+        assert elem1 is not elem2, "Expected object %r and object %r to be different objects, were same." % (
+                                    type(elem1), type(elem2))
+
 
 def getCols(k):
     return string.ascii_uppercase[:k]

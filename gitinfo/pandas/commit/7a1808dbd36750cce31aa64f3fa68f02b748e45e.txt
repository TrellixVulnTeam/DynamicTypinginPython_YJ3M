commit 7a1808dbd36750cce31aa64f3fa68f02b748e45e
Author: Adam Klein <adamklein@gmail.com>
Date:   Wed Mar 7 21:08:50 2012 -0500

    TST: fixed error raising up to python from skts code

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 2eca513f5..a323df8f4 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -93,16 +93,16 @@ cdef extern from "np_datetime_strings.h":
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
 
 cdef extern from "skts.h":
-    int frequency_conversion(int dtordinal, int freq1, int freq2, char relation)
+    long frequency_conversion(long dtordinal, int freq1, int freq2, char relation) except -1
 
     long get_skts_ordinal(int year, int month, int day,
                           int hour, int minute, int second,
-                          int freq)
+                          int freq) except -1
 
-    long get_python_ordinal(long skts_ordinal, int freq)
+    long get_python_ordinal(long skts_ordinal, int freq) except -1
 
-    PyObject *interval_strftime(long value, int freq, PyObject *args)
-    PyObject *interval_to_string(long value, int freq)
+    PyObject *interval_strftime(long value, int freq, PyObject *args) except -1
+    PyObject *interval_to_string(long value, int freq) except -1
 
 cdef extern from "stdint.h":
     enum: INT64_MIN
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index b9dc03818..0cc1f50da 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1849,11 +1849,14 @@ cdef inline int64_t ts_dayofweek(_TSObject ts):
 # Interval logic
 # ------------------------------------------------------------------------------
 
-def interval_freq_conv(int dtordinal, int freq1, int freq2, char relation='E'):
+def interval_freq_conv(long dtordinal, int freq1, int freq2, object relation='E'):
     cdef:
-        int retval
+        long retval
 
-    retval = frequency_conversion(dtordinal, freq1, freq2, relation)
+    if not isinstance(relation, basestring) or len(relation) != 1:
+        raise ValueError('relation argument must be one of S or E')
+
+    retval = frequency_conversion(dtordinal, freq1, freq2, (<char*>relation)[0])
 
     return retval
 
@@ -1866,7 +1869,12 @@ def skts_ordinal(int y, int m, int d, int h, int min, int s, int freq):
     return ordinal
 
 def skts_ordinal_to_dt(long skts_ordinal, int freq):
-    return datetime.fromordinal(get_python_ordinal(skts_ordinal, freq))
+    cdef:
+        long ordinal
+
+    ordinal = get_python_ordinal(skts_ordinal, freq)
+
+    return datetime.fromordinal(ordinal)
 
 
 def skts_interval_to_string(long value, int freq):
diff --git a/pandas/src/skts.c b/pandas/src/skts.c
index 67d54dbfe..746781b43 100644
--- a/pandas/src/skts.c
+++ b/pandas/src/skts.c
@@ -78,7 +78,7 @@ static int dInfoCalc_YearOffset(long year, int calendar)
     }
     Py_Error(PyExc_ValueError, "unknown calendar");
  onError:
-    return -1;
+    return INT_ERR_CODE;
 }
 
 /* Set the instance's value using the given date and time. calendar may be set
@@ -163,7 +163,7 @@ static int dInfoCalc_SetFromDateAndTime(struct date_info *dinfo,
     return 0;
 
  onError:
-    return -1;
+    return INT_ERR_CODE;
 }
 
 /* Sets the date part of the date_info struct using the indicated
@@ -242,7 +242,7 @@ int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
     return 0;
 
  onError:
-    return -1;
+    return INT_ERR_CODE;
 }
 
 ///////////////////////////////////////////////
@@ -317,9 +317,8 @@ static long asfreq_DtoQ(long fromDate, char relation, asfreq_info *af_info) {
 
     int year, quarter;
 
-    if (DtoQ_yq(fromDate, af_info, &year, &quarter) == INT_ERR_CODE)
-    { 
-        return INT_ERR_CODE; 
+    if (DtoQ_yq(fromDate, af_info, &year, &quarter) == INT_ERR_CODE) {
+        return INT_ERR_CODE;
     }
 
     return (long)((year - 1) * 4 + quarter);
@@ -328,8 +327,8 @@ static long asfreq_DtoQ(long fromDate, char relation, asfreq_info *af_info) {
 static long asfreq_DtoM(long fromDate, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate, GREGORIAN_CALENDAR))
+        return INT_ERR_CODE;
     return (long)((dinfo.year - 1) * 12 + dinfo.month);
 }
 
@@ -353,11 +352,11 @@ static long asfreq_DtoB(long fromDate, char relation, asfreq_info *af_info) {
 static long asfreq_DtoB_forConvert(long fromDate, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate, GREGORIAN_CALENDAR))
+        return INT_ERR_CODE;
 
     if (dinfo.day_of_week > 4) {
-        return -1;
+        return INT_ERR_CODE;
     } else {
         return DtoB_weekday(fromDate);
     }
@@ -370,7 +369,7 @@ static long asfreq_DtoHIGHFREQ(long fromDate, char relation, long periodsPerDay)
     if (fromDate >= HIGHFREQ_ORIG) {
         if (relation == 'S') { return (fromDate - HIGHFREQ_ORIG)*(periodsPerDay) + 1; }
         else                 { return (fromDate - HIGHFREQ_ORIG + 1)*(periodsPerDay); }
-    } else { return -1; }
+    } else { return INT_ERR_CODE; }
 }
 
 static long asfreq_DtoH(long fromDate, char relation, asfreq_info *af_info)
@@ -672,7 +671,7 @@ static long asfreq_AtoT(long fromDate, char relation, asfreq_info *af_info)
 static long asfreq_AtoS(long fromDate, char relation, asfreq_info *af_info)
     { return asfreq_DtoS(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
 
-static long nofunc(long fromDate, char relation, asfreq_info *af_info) { return -1; }
+static long nofunc(long fromDate, char relation, asfreq_info *af_info) { return INT_ERR_CODE; }
 
 // end of frequency specific conversion routines
 
@@ -945,21 +944,28 @@ int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
 
     return 0;
  onError:
-    return -1;
+    return INT_ERR_CODE;
 }
 
 /* ------------------------------------------------------------------
- * New pandas API-helper code, to expose to cython 
+ * New pandas API-helper code, to expose to cython
  * ------------------------------------------------------------------*/
 
-int frequency_conversion(long dtordinal, int freq1, int freq2, char relation)
+long frequency_conversion(long skts_ordinal, int freq1, int freq2, char relation)
 {
     freq_conv_func func = get_asfreq_func(freq1, freq2, 1);
 
     asfreq_info finfo;
     get_asfreq_info(freq1, freq2, &finfo);
 
-    return (*func)(dtordinal, relation, &finfo);
+    long val = (*func)(skts_ordinal, relation, &finfo);
+
+    if (val == INT_ERR_CODE)
+        Py_Error(PyExc_ValueError, "Unable to convert to desired frequency.");
+
+    return val;
+onError:
+    return INT_ERR_CODE;
 }
 
 /* generate an ordinal in skts space */
@@ -986,7 +992,7 @@ long get_skts_ordinal(int year, int month, int day,
 
     if (freq == FR_HR) {
         long absdays, delta;
-        if ((absdays = absdate_from_ymd(year, month, day)) == INT_ERR_CODE) 
+        if ((absdays = absdate_from_ymd(year, month, day)) == INT_ERR_CODE)
         {
             goto onError;
         }
@@ -1049,8 +1055,9 @@ long get_skts_ordinal(int year, int month, int day,
         return year;
     }
 
+    Py_Error(PyExc_RuntimeError, "Unable to generate frequency ordinal");
+
 onError:
-    Py_Error(PyExc_Exception, "Unable to generate frequency ordinal");
     return INT_ERR_CODE;
 }
 
@@ -1063,7 +1070,7 @@ onError:
 
 long get_python_ordinal(long skts_ordinal, int freq)
 {
-    if (freq == FR_DAY) 
+    if (freq == FR_DAY)
         return skts_ordinal;
 
     long (*toDaily)(long, char, asfreq_info*) = NULL;
diff --git a/pandas/src/skts.h b/pandas/src/skts.h
index 4c0aff08e..5dadc186a 100644
--- a/pandas/src/skts.h
+++ b/pandas/src/skts.h
@@ -143,7 +143,7 @@ typedef long (*freq_conv_func)(long, char, asfreq_info*);
  * new pandas API helper functions here
  */
 
-int frequency_conversion(long dtordinal, int freq1, int freq2, char relation);
+long frequency_conversion(long skts_ordinal, int freq1, int freq2, char relation);
 
 long get_skts_ordinal(int year, int month, int day,
                       int hour, int minute, int second,
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 1d9e35418..6522ae2fc 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -572,14 +572,24 @@ class TestDatetime64(unittest.TestCase):
 
         self.assertEquals(i1, i2)
 
+        i3 = Interval('2005', freq='M')
+        self.assert_(i1 != i3)
+
         i1 = Interval.now('Q')
         i2 = Interval(datetime.now(), freq='Q')
 
         self.assertEquals(i1, i2)
 
+        # Biz day construction, roll forward if non-weekday
+        i1 = Interval('3/10/12', freq='B')
+        i2 = Interval('3/12/12', freq='D')
+        self.assertEquals(i1, i2.asfreq('B'))
+
     def test_interval_asfreq(self):
         # need a whole bunch of tests here ...
-        pass
+        # D to B conversion exception, was failing silently before
+        i1 = Interval('3/10/12')
+        self.assertRaises(Exception, i1.asfreq, 'B')
 
     def test_intervalindex_constructor(self):
         pass

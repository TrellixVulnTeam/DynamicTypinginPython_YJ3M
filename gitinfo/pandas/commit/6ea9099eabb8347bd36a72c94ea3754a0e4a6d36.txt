commit 6ea9099eabb8347bd36a72c94ea3754a0e4a6d36
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jun 3 11:17:12 2012 -0400

    ENH: use kvec.h instead of PyList for accumulating uniques in hashtable.pyx, return arrays from pandas.unique, close #1353

diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 894acdb6a..214476e14 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -92,7 +92,7 @@ def _unique_generic(values, table_type, type_caster):
     values = type_caster(values)
     table = table_type(len(values))
     uniques = table.unique(values)
-    return uniques
+    return type_caster(uniques)
 
 
 def factorize(values, sort=False, order=None, na_sentinel=-1):
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 92f105027..71819167c 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -404,15 +404,12 @@ def unique1d(values):
                            dtype=np.float64)
     elif np.issubdtype(values.dtype, np.datetime64):
         table = lib.Int64HashTable(len(values))
-        uniques = np.array(table.unique(com._ensure_int64(values)),
-                           dtype=np.int64)
+        uniques = table.unique(com._ensure_int64(values))
         uniques = uniques.view('M8[ns]')
     elif np.issubdtype(values.dtype, np.integer):
         table = lib.Int64HashTable(len(values))
-        uniques = np.array(table.unique(com._ensure_int64(values)),
-                           dtype=np.int64)
+        uniques = table.unique(com._ensure_int64(values))
     else:
         table = lib.PyObjectHashTable(len(values))
         uniques = table.unique(com._ensure_object(values))
-        uniques = lib.list_to_object_array(uniques)
     return uniques
diff --git a/pandas/src/hashtable.pyx b/pandas/src/hashtable.pyx
index fea622449..b1b254d0f 100644
--- a/pandas/src/hashtable.pyx
+++ b/pandas/src/hashtable.pyx
@@ -29,6 +29,64 @@ def list_to_object_array(list obj):
     return arr
 
 
+cdef extern from "kvec.h":
+
+    ctypedef struct kv_int64_t:
+        size_t n, m
+        int64_t* a
+
+    ctypedef struct kv_object_t:
+        size_t n, m
+        PyObject** a
+
+    inline void kv_object_push(kv_object_t *v, PyObject* x)
+    inline void kv_object_destroy(kv_object_t *v)
+    inline void kv_int64_push(kv_int64_t *v, int64_t x)
+
+
+cdef class ObjectVector:
+
+    cdef:
+        kv_object_t vec
+
+    def __array__(self):
+        """ Here we use the __array__ method, that is called when numpy
+            tries to get an array from the object."""
+        cdef npy_intp shape[1]
+        shape[0] = <npy_intp> self.vec.n
+
+        # Create a 1D array, of length 'size'
+        return PyArray_SimpleNewFromData(1, shape, np.NPY_OBJECT, self.vec.a)
+
+    cdef inline append(self, object o):
+        kv_object_push(&self.vec, <PyObject*> o)
+
+    def __dealloc__(self):
+        kv_object_destroy(&self.vec)
+
+
+cdef class Int64Vector:
+
+    cdef:
+        kv_int64_t vec
+
+    def __array__(self):
+        """ Here we use the __array__ method, that is called when numpy
+            tries to get an array from the object."""
+        cdef npy_intp shape[1]
+        shape[0] = <npy_intp> self.vec.n
+
+        # Create a 1D array, of length 'size'
+        return PyArray_SimpleNewFromData(1, shape, np.NPY_INT64,
+                                         self.vec.a)
+
+    cdef inline append(self, int64_t x):
+        kv_int64_push(&self.vec, x)
+
+    def __dealloc__(self):
+        free(self.vec.a)
+
+
 cdef class HashTable:
     pass
 
@@ -449,9 +507,10 @@ cdef class Int64HashTable(HashTable):
             Py_ssize_t i, n = len(values)
             Py_ssize_t idx, count = 0
             int ret = 0
+            ndarray result
             int64_t val
             khiter_t k
-            list uniques = []
+            Int64Vector uniques = Int64Vector()
 
         # TODO: kvec
 
@@ -463,7 +522,11 @@ cdef class Int64HashTable(HashTable):
                 uniques.append(val)
                 count += 1
 
-        return uniques
+        result = np.array(uniques, copy=False)
+        result.base = <PyObject*> uniques
+        Py_INCREF(uniques)
+
+        return result
 
 def value_count_int64(ndarray[int64_t] values):
     cdef:
@@ -717,8 +780,9 @@ cdef class PyObjectHashTable(HashTable):
             Py_ssize_t idx, count = 0
             int ret = 0
             object val
+            ndarray result
             khiter_t k
-            list uniques = []
+            ObjectVector uniques = ObjectVector()
             bint seen_na = 0
 
         for i in range(n):
@@ -733,7 +797,11 @@ cdef class PyObjectHashTable(HashTable):
                 seen_na = 1
                 uniques.append(ONAN)
 
-        return uniques
+        result = np.array(uniques, copy=False)
+        result.base = <PyObject*> uniques
+        Py_INCREF(uniques)
+
+        return result
 
     cpdef get_labels(self, ndarray[object] values, list uniques,
                      Py_ssize_t count_prior, int64_t na_sentinel):
diff --git a/pandas/src/kvec.h b/pandas/src/kvec.h
index 9ca232f21..ab9e0b65d 100644
--- a/pandas/src/kvec.h
+++ b/pandas/src/kvec.h
@@ -49,7 +49,20 @@ int main() {
 #define AC_KVEC_H
 
 #include <stdlib.h>
-#include <ktypes.h>
+#include <Python.h>
+#include <numpy/ndarraytypes.h>
+
+#ifndef PANDAS_INLINE
+  #if defined(__GNUC__)
+    #define PANDAS_INLINE __inline__
+  #elif defined(_MSC_VER)
+    #define PANDAS_INLINE __inline
+  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    #define PANDAS_INLINE inline
+  #else
+    #define PANDAS_INLINE
+  #endif
+#endif
 
 #define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
 
@@ -70,11 +83,11 @@ int main() {
 	} while (0)												\
 
 #define kv_push(type, v, x) do {									\
-		if ((v).n == (v).m) {										\
-			(v).m = (v).m? (v).m<<1 : 2;							\
-			(v).a = (type*)realloc((v).a, sizeof(type) * (v).m);	\
+		if ((v)->n == (v)->m) {										\
+			(v)->m = (v)->m? (v)->m<<1 : 2;							\
+			(v)->a = (type*)realloc((v)->a, sizeof(type) * (v)->m);	\
 		}															\
-		(v).a[(v).n++] = (x);										\
+		(v)->a[(v)->n++] = (x);										\
 	} while (0)
 
 #define kv_pushp(type, v) (((v).n == (v).m)?							\
@@ -88,11 +101,42 @@ int main() {
 						  : (v).n <= (size_t)(i)? (v).n = (i)			\
 						  : 0), (v).a[(i)]
 
-#define kv_int64_push(v, x) (kv_push(int64_t, (v), (x)))
+// #define kv_int64_push(v, x) (kv_push(int64_t, (v), (x)))
 
 typedef struct {
   size_t n, m;
-  int64_t *a;
+  int64_t* a;
 } kv_int64_t;
 
+typedef struct {
+  size_t n, m;
+  PyObject** a;
+} kv_object_t;
+
+void PANDAS_INLINE kv_object_push(kv_object_t *v, PyObject *x) {
+  do {
+		if (v->n == v->m) {
+			v->m = v->m? v->m<<1 : 2;
+			v->a = (PyObject**)realloc(v->a, sizeof(PyObject*) * v->m);
+		}
+		v->a[v->n++] = x;
+	} while (0);
+  // kv_push(PyObject*, v, x);
+  Py_INCREF(x);
+}
+
+void PANDAS_INLINE kv_int64_push(kv_int64_t *v, int64_t x) {
+  kv_push(int64_t, v, x);
+}
+
+void PANDAS_INLINE kv_object_destroy(kv_object_t *v) {
+  int i;
+  for (i = 0; i < v->n; ++i)
+  {
+    Py_XDECREF(v->a[i]);
+  }
+  free(v->a);
+}
+
+
 #endif
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index a64b880c3..5e8de5326 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -25,6 +25,22 @@ class TestMatch(unittest.TestCase):
         expected = np.array([1, 0, -1, 0, 1, 2, -1])
         self.assert_(np.array_equal(result, expected))
 
+
+class TestUnique(unittest.TestCase):
+
+    def test_ints(self):
+        arr = np.random.randint(0, 100, size=50)
+
+        result = algos.unique(arr)
+        self.assert_(isinstance(result, np.ndarray))
+
+    def test_objects(self):
+        arr = np.random.randint(0, 100, size=50).astype('O')
+
+        result = algos.unique(arr)
+        self.assert_(isinstance(result, np.ndarray))
+
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],

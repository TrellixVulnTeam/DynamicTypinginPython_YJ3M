commit 163806f7b8dc98671e7e7aea1050c1ada9f6e779
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Aug 9 18:45:57 2011 -0400

    TST: unit tests coverage for MultiIndex

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index ea7d6b63d..664489cf9 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -376,7 +376,7 @@ def _convert_grouper(axis, grouper):
             return np.asarray(grouper, dtype=object)
         else:
             return grouper.__getitem__
-    elif isinstance(grouper, np.ndarray):
+    elif isinstance(grouper, (list, np.ndarray)):
         assert(len(grouper) == len(axis))
         return np.asarray(grouper, dtype=object)
     else:
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 39592a290..a4e81f5f1 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -407,6 +407,9 @@ class MultiIndex(Index):
     def is_all_dates(self):
         return False
 
+    def is_sorted(self):
+        raise NotImplementedError
+
     @classmethod
     def from_arrays(cls, arrays, sortorder=None):
         """
@@ -548,11 +551,7 @@ class MultiIndex(Index):
         return indexer, mask
 
     def get_tuple_index(self):
-        to_join = []
-        for lev, lab in zip(self.levels, self.labels):
-            to_join.append(np.asarray(lev).take(lab))
-
-        return Index(zip(*to_join))
+        return Index(list(self))
 
     def slice_locs(self, start=None, end=None):
         """
@@ -564,9 +563,8 @@ class MultiIndex(Index):
         -----
         This function assumes that the data is sorted by the first level
         """
-        assert(self.sortorder == 0)
-
-        level0 = self.levels[0]
+        # relax for now
+        # assert(self.sortorder == 0)
 
         if start is None:
             start_slice = 0
@@ -585,32 +583,28 @@ class MultiIndex(Index):
         return start_slice, end_slice
 
     def _partial_tup_index(self, tup, side='left'):
-        assert(self.sortorder == 0)
-        tup_labels = self._get_label_key_approx(tup, side=side)
+        # relax for now
+        # assert(self.sortorder == 0)
 
-        n = len(tup_labels)
+        n = len(tup)
         start, end = 0, len(self)
-        for k, (idx, labs) in enumerate(zip(tup_labels, self.labels)):
+        zipped = izip(tup, self.levels, self.labels)
+        for k, (lab, lev, labs) in enumerate(zipped):
             section = labs[start:end]
+
+            if lab not in lev:
+                # short circuit
+                loc = lev.searchsorted(lab, side=side)
+                if side == 'right' and loc > 0:
+                    loc -= 1
+                return start + section.searchsorted(loc, side=side)
+
+            idx = lev.get_loc(lab)
             if k < n - 1:
-                start = start + section.searchsorted(idx, side='left')
                 end = start + section.searchsorted(idx, side='right')
+                start = start + section.searchsorted(idx, side='left')
             else:
-                return start + labs.searchsorted(idx, side=side)
-
-    def _get_label_key_approx(self, tup, side='left'):
-        result = []
-        for lev, v in zip(self.levels, tup):
-            try:
-                label = lev.get_loc(v)
-            except KeyError:
-                label = lev.searchsorted(v, side=side)
-
-                if side == 'right' and label > 0:
-                    label -= 1
-
-            result.append(label)
-        return tuple(result)
+                return start + section.searchsorted(idx, side=side)
 
     def get_loc(self, key):
         if isinstance(key, tuple):
@@ -652,8 +646,8 @@ class MultiIndex(Index):
         -------
         MultiIndex
         """
-        i, j = self._get_axis_bounds(before, after)
-        left, right = self._get_label_bounds(i, j)
+        i, j = self.levels[0].slice_locs(before, after)
+        left, right = self.slice_locs(before, after)
 
         new_levels = list(self.levels)
         new_levels[0] = new_levels[0][i:j]
@@ -751,67 +745,15 @@ class MultiIndex(Index):
 
         assert(self.nlevels == other.nlevels)
 
-    def get_major_bounds(self, begin=None, end=None):
-        """
-        Return index bounds for slicing LongPanel labels and / or
-        values
-
-        Parameters
-        ----------
-        begin : axis value or None
-        end : axis value or None
-
-        Returns
-        -------
-        y : tuple
-            (left, right) absolute bounds on LongPanel values
-        """
-        i, j = self._get_axis_bounds(begin, end)
-        left, right = self._get_label_bounds(i, j)
-
-        return left, right
-
-    def _get_axis_bounds(self, begin, end):
-        """
-        Return major axis locations corresponding to interval values
-        """
-        if begin is not None:
-            i = self.levels[0].indexMap.get(begin)
-            if i is None:
-                i = self.levels[0].searchsorted(begin, side='right')
-        else:
-            i = 0
-
-        if end is not None:
-            j = self.levels[0].indexMap.get(end)
-            if j is None:
-                j = self.levels[0].searchsorted(end)
-            else:
-                j = j + 1
-        else:
-            j = len(self.levels[0])
-
-        if i > j:
-            raise ValueError('Must have begin <= end!')
-
-        return i, j
-
-    def _get_label_bounds(self, i, j):
-        "Return slice points between two major axis locations"
-
-        left = self._bounds[i]
-
-        if j >= len(self.levels[0]):
-            right = len(self.labels[0])
-        else:
-            right = self._bounds[j]
-
-        return left, right
+    get_major_bounds = slice_locs
 
     __bounds = None
     @property
     def _bounds(self):
-        "Return or compute and return slice points for major axis"
+        """
+        Return or compute and return slice points for level 0, assuming
+        sortedness
+        """
         if self.__bounds is None:
             inds = np.arange(len(self.levels[0]))
             self.__bounds = self.labels[0].searchsorted(inds)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index f75b9bbba..246f3c291 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1239,7 +1239,7 @@ class LongPanel(Panel, DataFrame):
         -------
         LongPanel
         """
-        left, right = self.index.get_major_bounds(before, after)
+        left, right = self.index.slice_locs(before, after)
         new_index = self.index.truncate(before, after)
 
         return LongPanel(self.values[left : right],
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 1a2087ac8..a11069273 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -7,15 +7,15 @@ import numpy as np
 
 from pandas.core.index import Index, Factor, MultiIndex, NULL_INDEX
 from pandas.util.testing import assert_almost_equal
-import pandas.util.testing as common
+import pandas.util.testing as tm
 import pandas._tseries as tseries
 
 class TestIndex(unittest.TestCase):
 
     def setUp(self):
-        self.strIndex = common.makeStringIndex(100)
-        self.dateIndex = common.makeDateIndex(100)
-        self.intIndex = common.makeIntIndex(100)
+        self.strIndex = tm.makeStringIndex(100)
+        self.dateIndex = tm.makeDateIndex(100)
+        self.intIndex = tm.makeIntIndex(100)
         self.empty = Index([])
         self.tuples = Index(zip(['foo', 'bar', 'baz'], [1, 2, 3]))
 
@@ -41,13 +41,13 @@ class TestIndex(unittest.TestCase):
 
     def test_constructor(self):
         # regular instance creation
-        common.assert_contains_all(self.strIndex, self.strIndex)
-        common.assert_contains_all(self.dateIndex, self.dateIndex)
+        tm.assert_contains_all(self.strIndex, self.strIndex)
+        tm.assert_contains_all(self.dateIndex, self.dateIndex)
 
         # casting
         arr = np.array(self.strIndex)
         index = arr.view(Index)
-        common.assert_contains_all(arr, index)
+        tm.assert_contains_all(arr, index)
         self.assert_(np.array_equal(self.strIndex, index))
 
         # what to do here?
@@ -112,11 +112,11 @@ class TestIndex(unittest.TestCase):
         boolIdx[5:30:2] = False
 
         subIndex = self.strIndex[boolIdx]
-        common.assert_dict_equal(tseries.map_indices(subIndex),
+        tm.assert_dict_equal(tseries.map_indices(subIndex),
                                  subIndex.indexMap)
 
         subIndex = self.strIndex[list(boolIdx)]
-        common.assert_dict_equal(tseries.map_indices(subIndex),
+        tm.assert_dict_equal(tseries.map_indices(subIndex),
                                  subIndex.indexMap)
 
     def test_fancy(self):
@@ -140,7 +140,7 @@ class TestIndex(unittest.TestCase):
         second = self.strIndex[:10]
         intersect = first.intersection(second)
 
-        self.assert_(common.equalContents(intersect, second))
+        self.assert_(tm.equalContents(intersect, second))
 
         # Corner cases
         inter = first.intersection(first)
@@ -154,7 +154,7 @@ class TestIndex(unittest.TestCase):
         second = self.strIndex[:10]
         everything = self.strIndex[:20]
         union = first.union(second)
-        self.assert_(common.equalContents(union, everything))
+        self.assert_(tm.equalContents(union, everything))
 
         # Corner cases
         union = first.union(first)
@@ -170,12 +170,12 @@ class TestIndex(unittest.TestCase):
         firstCat = self.strIndex + self.dateIndex
         secondCat = self.strIndex + self.strIndex
 
-        self.assert_(common.equalContents(np.append(self.strIndex,
+        self.assert_(tm.equalContents(np.append(self.strIndex,
                                                     self.dateIndex), firstCat))
-        self.assert_(common.equalContents(secondCat, self.strIndex))
-        common.assert_contains_all(self.strIndex, firstCat.indexMap)
-        common.assert_contains_all(self.strIndex, secondCat.indexMap)
-        common.assert_contains_all(self.dateIndex, firstCat.indexMap)
+        self.assert_(tm.equalContents(secondCat, self.strIndex))
+        tm.assert_contains_all(self.strIndex, firstCat.indexMap)
+        tm.assert_contains_all(self.strIndex, secondCat.indexMap)
+        tm.assert_contains_all(self.dateIndex, firstCat.indexMap)
 
         # this is valid too
         shifted = self.dateIndex + timedelta(1)
@@ -194,7 +194,7 @@ class TestIndex(unittest.TestCase):
         answer = self.strIndex[10:20]
         result = first - second
 
-        self.assert_(common.equalContents(result, answer))
+        self.assert_(tm.equalContents(result, answer))
 
         diff = first.diff(first)
         self.assert_(len(diff) == 0)
@@ -210,7 +210,7 @@ class TestIndex(unittest.TestCase):
             self.assert_(isinstance(unpickled, Index))
             self.assert_(np.array_equal(unpickled, index))
 
-            common.assert_dict_equal(unpickled.indexMap, index.indexMap)
+            tm.assert_dict_equal(unpickled.indexMap, index.indexMap)
 
         testit(self.strIndex)
         testit(self.dateIndex)
@@ -353,8 +353,26 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(self.index.get_loc(('baz', 'two')) == 3)
         self.assertRaises(KeyError, self.index.get_loc, ('bar', 'two'))
 
+    def test_slice_locs(self):
+        df = tm.makeTimeDataFrame()
+        stacked = df.stack()
+
+        idx = stacked.index
+
+        slob = slice(*idx.slice_locs(df.index[5], df.index[15]))
+        sliced = stacked[slob]
+        expected = df[5:16].stack()
+        tm.assert_almost_equal(sliced.values, expected.values)
+
+        slob = slice(*idx.slice_locs(df.index[5] + timedelta(seconds=30),
+                                     df.index[15] - timedelta(seconds=30)))
+        sliced = stacked[slob]
+        expected = df[6:15].stack()
+        tm.assert_almost_equal(sliced.values, expected.values)
+
     def test_slice_locs_partial(self):
         sorted_idx, _ = self.index.sortlevel(0)
+
         result = sorted_idx.slice_locs(('foo', 'two'), ('qux', 'one'))
         self.assertEquals(result, (1, 5))
 
@@ -376,14 +394,23 @@ class TestMultiIndex(unittest.TestCase):
                            sortorder=0)
 
         result = index.slice_locs((1, 0), (5, 2))
-        self.assertEquals(result, (3, 7))
+        self.assertEquals(result, (3, 6))
+
+        result = index.slice_locs(1, 5)
+        self.assertEquals(result, (3, 6))
 
         result = index.slice_locs((2, 2), (5, 2))
-        self.assertEquals(result, (4, 7))
+        self.assertEquals(result, (3, 6))
+
+        result = index.slice_locs(2, 5)
+        self.assertEquals(result, (3, 6))
 
         result = index.slice_locs((1, 0), (6, 3))
         self.assertEquals(result, (3, 8))
 
+        result = index.slice_locs(-1, 10)
+        self.assertEquals(result, (0, len(index)))
+
     def test_consistency(self):
         # need to construct an overflow
         major_axis = range(70000)
@@ -464,17 +491,8 @@ class TestMultiIndex(unittest.TestCase):
     def test_format(self):
         self.index.format()
 
-    def test_getMajorBounds(self):
-        pass
-
-    def test_getAxisBounds(self):
-        pass
-
-    def test_getLabelBounds(self):
-        pass
-
     def test_bounds(self):
-        pass
+        self.index._bounds
 
     def test_makeMask(self):
         from pandas.core.panel import make_mask
@@ -559,6 +577,29 @@ class TestMultiIndex(unittest.TestCase):
         self.assertRaises(TypeError, self.index.intersection,
                           self.index.get_tuple_index())
 
+    def test_sortlevel(self):
+        import random
+
+        tuples = list(self.index)
+        random.shuffle(tuples)
+
+        index = MultiIndex.from_tuples(tuples)
+
+        sorted_idx, _ = index.sortlevel(0)
+        expected = MultiIndex.from_tuples(sorted(tuples))
+        self.assert_(sorted_idx.equals(expected))
+
+        sorted_idx, _ = index.sortlevel(0, ascending=False)
+        self.assert_(sorted_idx.equals(expected[::-1]))
+
+        sorted_idx, _ = index.sortlevel(1)
+        by1 = sorted(tuples, key=lambda x: (x[1], x[0]))
+        expected = MultiIndex.from_tuples(by1)
+        self.assert_(sorted_idx.equals(expected))
+
+        sorted_idx, _ = index.sortlevel(1, ascending=False)
+        self.assert_(sorted_idx.equals(expected[::-1]))
+
     def test_dims(self):
         pass
 
@@ -574,10 +615,10 @@ class TestFactor(unittest.TestCase):
         self.assertEqual(self.factor[-1], 'c')
 
         subf = self.factor[[0, 1, 2]]
-        common.assert_almost_equal(subf.labels, [0, 1, 1])
+        tm.assert_almost_equal(subf.labels, [0, 1, 1])
 
         subf = self.factor[self.factor.asarray() == 'c']
-        common.assert_almost_equal(subf.labels, [2, 2, 2])
+        tm.assert_almost_equal(subf.labels, [2, 2, 2])
 
     def test_factor_agg(self):
         import pandas.core.frame as frame
@@ -596,4 +637,3 @@ if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure',#]
                          '--with-coverage', '--cover-package=pandas.core'],
                    exit=False)
-

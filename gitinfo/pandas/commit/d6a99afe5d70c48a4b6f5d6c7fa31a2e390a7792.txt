commit d6a99afe5d70c48a4b6f5d6c7fa31a2e390a7792
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jul 23 15:32:38 2012 -0400

    ENH: add flags option for re.compile in findall, match, contains, close #1659

diff --git a/RELEASE.rst b/RELEASE.rst
index 102914c9e..9cf1f6405 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -22,6 +22,15 @@ Where to get it
 * Binary installers on PyPI: http://pypi.python.org/pypi/pandas
 * Documentation: http://pandas.pydata.org
 
+pandas 0.8.2
+============
+
+**Release date:** NOT YET RELEASED
+
+**Improvements to existing features**
+
+  - Add ``flags`` option for ``re.compile`` in some Series.str methods (#1659)
+
 pandas 0.8.1
 ============
 
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index 511fdd24b..6541906d5 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -88,30 +88,6 @@ contains = mapwrap(lambda x, p: x.__contains__(p))
 upper = mapwrap(lambda x: x.upper())
 lower = mapwrap(lambda x: x.lower())
 
-def _re_get_groups(pattern, n):
-    def inner(s, *groups):
-        m = pattern.search(s)
-        if m:
-            return m.group(*[int(g) for g in groups])
-        return np.nan if n == 1 else [np.nan] * n
-
-    return inner
-
-def search_re(arr, pattern, groups=(0,)):
-    if isinstance(pattern, str):
-        pattern = re.compile(pattern)
-
-    if isinstance(groups, np.ndarray):
-        if groups.ndim == 1:
-            n_groups = 1
-        else:
-            n_groups = groups.shape[1]
-    else:
-        n_groups = len(groups)
-
-    return auto_map(arr, _re_get_groups(pattern, n_groups),
-                    (groups,), n_results=n_groups)
-
 
 def _get_array_list(arr, others):
     if isinstance(others[0], (list, np.ndarray)):
@@ -214,7 +190,7 @@ def _map(f, arr):
     return lib.map_infer(arr, f)
 
 
-def str_count(arr, pat):
+def str_count(arr, pat, flags=0):
     """
     Count occurrences of pattern in each string
 
@@ -222,17 +198,19 @@ def str_count(arr, pat):
     ----------
     arr : list or array-like
     pat : string, valid regular expression
+    flags : int, default 0 (no flags)
+        re module flags, e.g. re.IGNORECASE
 
     Returns
     -------
     counts : arrays
     """
-    regex = re.compile(pat)
+    regex = re.compile(pat, flags=flags)
     f = lambda x: len(regex.findall(x))
     return _na_map(f, arr)
 
 
-def str_contains(arr, pat, case=True):
+def str_contains(arr, pat, case=True, flags=0):
     """
     Check whether given pattern is contained in each string in the array
 
@@ -242,15 +220,18 @@ def str_contains(arr, pat, case=True):
         Character sequence or regular expression
     case : boolean, default True
         If True, case sensitive
+    flags : int, default 0 (no flags)
+        re module flags, e.g. re.IGNORECASE
 
     Returns
     -------
 
     """
     if not case:
-        regex = re.compile(pat, re.IGNORECASE)
-    else:
-        regex = re.compile(pat)
+        flags |= re.IGNORECASE
+
+    regex = re.compile(pat, flags=flags)
+
     f = lambda x: bool(regex.search(x))
     return _na_map(f, arr)
 
@@ -313,7 +294,7 @@ def str_upper(arr):
     return _na_map(lambda x: x.upper(), arr)
 
 
-def str_replace(arr, pat, repl, n=0, case=True):
+def str_replace(arr, pat, repl, n=0, case=True, flags=0):
     """
     Replace
 
@@ -327,15 +308,18 @@ def str_replace(arr, pat, repl, n=0, case=True):
         Number of replacements to make from start
     case : boolean, default True
         If True, case sensitive
+    flags : int, default 0 (no flags)
+        re module flags, e.g. re.IGNORECASE
 
     Returns
     -------
     replaced : array
     """
     if not case:
-        regex = re.compile(pat, re.IGNORECASE)
-    else:
-        regex = re.compile(pat)
+        flags |= re.IGNORECASE
+
+    regex = re.compile(pat, flags=flags)
+
     def f(x):
         return regex.sub(repl, x, count=n)
 
@@ -371,7 +355,7 @@ def str_repeat(arr, repeats):
         result = lib.vec_binop(arr, repeats, rep)
         return result
 
-def str_match(arr, pat):
+def str_match(arr, pat, flags=0):
     """
     Find groups in each string (from beginning) using passed regular expression
 
@@ -379,12 +363,14 @@ def str_match(arr, pat):
     ----------
     pat : string
         Pattern or regular expression
+    flags : int, default 0 (no flags)
+        re module flags, e.g. re.IGNORECASE
 
     Returns
     -------
     matches : array
     """
-    regex = re.compile(pat)
+    regex = re.compile(pat, flags=flags)
     def f(x):
         m = regex.match(x)
         if m:
@@ -424,7 +410,7 @@ def str_len(arr):
 
 
 
-def str_findall(arr, pat):
+def str_findall(arr, pat, flags=0):
     """
     Find all occurrences of pattern or regular expression
 
@@ -432,12 +418,14 @@ def str_findall(arr, pat):
     ----------
     pat : string
         Pattern or regular expressino
+    flags : int, default 0 (no flags)
+        re module flags, e.g. re.IGNORECASE
 
     Returns
     -------
     matches : array
     """
-    regex = re.compile(pat)
+    regex = re.compile(pat, flags=flags)
     return _na_map(regex.findall, arr)
 
 
@@ -615,11 +603,17 @@ def _noarg_wrapper(f):
     return wrapper
 
 
-def _pat_wrapper(f):
-    def wrapper(self, pat):
+def _pat_wrapper(f, flags=False):
+    def wrapper1(self, pat):
         result = f(self.series, pat)
         return self._wrap_result(result)
 
+    def wrapper2(self, pat, flags=0):
+        result = f(self.series, pat, flags=flags)
+        return self._wrap_result(result)
+
+    wrapper = wrapper2 if flags else wrapper1
+
     wrapper.__name__ = f.__name__
     if f.__doc__:
         wrapper.__doc__ = f.__doc__
@@ -681,8 +675,8 @@ class StringMethods(object):
         return self._wrap_result(result)
 
     @copy(str_contains)
-    def contains(self, pat, case=True):
-        result = str_contains(self.series, pat, case=case)
+    def contains(self, pat, case=True, flags=0):
+        result = str_contains(self.series, pat, case=case, flags=flags)
         return self._wrap_result(result)
 
     @copy(str_replace)
@@ -714,11 +708,11 @@ class StringMethods(object):
     def slice_replace(self, i=None, j=None):
         raise NotImplementedError
 
-    count = _pat_wrapper(str_count)
+    count = _pat_wrapper(str_count, flags=True)
     startswith = _pat_wrapper(str_startswith)
     endswith = _pat_wrapper(str_endswith)
-    findall = _pat_wrapper(str_findall)
-    match = _pat_wrapper(str_match)
+    findall = _pat_wrapper(str_findall, flags=True)
+    match = _pat_wrapper(str_match, flags=True)
 
     len = _noarg_wrapper(str_len)
     strip = _noarg_wrapper(str_strip)
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index db0b99ead..7ee7977a2 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -3,6 +3,7 @@
 from datetime import datetime, timedelta, date
 import os
 import operator
+import re
 import unittest
 
 import nose
@@ -638,6 +639,25 @@ class TestStringMethods(unittest.TestCase):
         expected = s.str.slice(stop=3)
         assert_series_equal(result, expected)
 
+    def test_match_findall_flags(self):
+        data = {'Dave': 'dave@google.com', 'Steve': 'steve@gmail.com',
+		'Rob': 'rob@gmail.com', 'Wes': np.nan}
+        data = Series(data)
+
+        pat = pattern = r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,4})'
+
+        result = data.str.match(pat, flags=re.IGNORECASE)
+        self.assertEquals(result[0], ('dave', 'google', 'com'))
+
+        result = data.str.findall(pat, flags=re.IGNORECASE)
+        self.assertEquals(result[0][0], ('dave', 'google', 'com'))
+
+        result = data.str.count(pat, flags=re.IGNORECASE)
+        self.assertEquals(result[0], 1)
+
+        result = data.str.contains(pat, flags=re.IGNORECASE)
+        self.assertEquals(result[0], True)
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/setup.py b/setup.py
index d35f3ad91..5e9d07098 100755
--- a/setup.py
+++ b/setup.py
@@ -173,8 +173,8 @@ CLASSIFIERS = [
 
 MAJOR = 0
 MINOR = 8
-MICRO = 1
-ISRELEASED = True
+MICRO = 2
+ISRELEASED = False
 VERSION = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
 QUALIFIER = ''
 

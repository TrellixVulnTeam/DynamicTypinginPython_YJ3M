commit cba2916bd08585d22ffa719a05dfc3c522b83969
Author: Angelos Evripiotis <jevripiotis@bloomberg.net>
Date:   Sat Nov 29 16:03:41 2014 +0000

    CLN: Add 'is_hashable' predicate to core/common
    
    Some types will pass a test against collections.Hashable but fail when
    they are actually hashed with hash().
    
    Introduce a new predicate to help handle these types.
    
    Will use this in subsequent commit.
    
    Test Plan:
    In addition to running tests, run the doctest
    $ nosetests pandas/core/common.py:is_hashable --with-doc -v

diff --git a/pandas/core/common.py b/pandas/core/common.py
index f7f944bb4..e5ff35310 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -2504,6 +2504,38 @@ def is_list_like(arg):
             not isinstance(arg, compat.string_and_binary_types))
 
 
+def is_hashable(arg):
+    """Return True if hash(arg) will succeed, False otherwise.
+
+    Some types will pass a test against collections.Hashable but fail when they
+    are actually hashed with hash().
+
+    Distinguish between these and other types by trying the call to hash() and
+    seeing if they raise TypeError.
+
+    Examples
+    --------
+    >>> a = ([],)
+    >>> isinstance(a, collections.Hashable)
+    True
+    >>> is_hashable(a)
+    False
+    """
+    # don't consider anything not collections.Hashable, so as not to broaden
+    # the definition of hashable beyond that. For example, old-style classes
+    # are not collections.Hashable but they won't fail hash().
+    if not isinstance(arg, collections.Hashable):
+        return False
+
+    # narrow the definition of hashable if hash(arg) fails in practice
+    try:
+        hash(arg)
+    except TypeError:
+        return False
+    else:
+        return True
+
+
 def is_sequence(x):
     try:
         iter(x)
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 946524705..63927fd4a 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -1,5 +1,7 @@
+import collections
 from datetime import datetime
 import re
+import sys
 
 import nose
 from nose.tools import assert_equal
@@ -398,6 +400,55 @@ def test_is_list_like():
         assert not com.is_list_like(f)
 
 
+def test_is_hashable():
+
+    # all new-style classes are hashable by default
+    class HashableClass(object):
+        pass
+
+    class UnhashableClass1(object):
+        __hash__ = None
+
+    class UnhashableClass2(object):
+        def __hash__(self):
+            raise TypeError("Not hashable")
+
+    hashable = (
+        1, 'a', tuple(), (1,), HashableClass(),
+    )
+    not_hashable = (
+        [], UnhashableClass1(),
+    )
+    abc_hashable_not_really_hashable = (
+        ([],), UnhashableClass2(),
+    )
+
+    for i in hashable:
+        assert isinstance(i, collections.Hashable)
+        assert com.is_hashable(i)
+    for i in not_hashable:
+        assert not isinstance(i, collections.Hashable)
+        assert not com.is_hashable(i)
+    for i in abc_hashable_not_really_hashable:
+        assert isinstance(i, collections.Hashable)
+        assert not com.is_hashable(i)
+
+    # numpy.array is no longer collections.Hashable as of
+    # https://github.com/numpy/numpy/pull/5326, just test
+    # pandas.common.is_hashable()
+    assert not com.is_hashable(np.array([]))
+
+    # old-style classes in Python 2 don't appear hashable to
+    # collections.Hashable but also seem to support hash() by default
+    if sys.version_info[0] == 2:
+        class OldStyleClass():
+            pass
+        c = OldStyleClass()
+        assert not isinstance(c, collections.Hashable)
+        assert not com.is_hashable(c)
+        hash(c)  # this will not raise
+
+
 def test_ensure_int32():
     values = np.arange(10, dtype=np.int32)
     result = com._ensure_int32(values)

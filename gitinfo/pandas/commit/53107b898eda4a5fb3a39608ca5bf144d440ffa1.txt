commit 53107b898eda4a5fb3a39608ca5bf144d440ffa1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jun 22 20:55:50 2011 -0400

    mixed type storage support for DataFrame in HDFStore

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 4c2d7cf61..0ff0b450d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -227,6 +227,11 @@ class DataFrame(PandasGeneric):
     #----------------------------------------------------------------------
     # Class behavior
 
+    @property
+    def _is_mixed_type(self):
+        self._consolidate_inplace()
+        return len(self._data.blocks) > 1
+
     def __nonzero__(self):
         # e.g. "if frame: ..."
         return len(self.columns) > 0 and len(self.index) > 0
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 47ea4ae7d..35033b432 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -180,6 +180,24 @@ class HDFStore(object):
         Parameters
         ----------
         key : object
+        where : list, optional
+
+           Must be a list of dict objects of the following forms. Selection can
+           be performed on the 'index' or 'column' fields.
+
+           Comparison op
+               {'field' : 'index',
+                'op'    : '>=',
+                'value' : value}
+
+           Match single value
+               {'field' : 'index',
+                'value' : v1}
+
+           Match a set of values
+               {'field' : 'index',
+                'value' : [v1, v2, v3]}
+
         """
         group = getattr(self.handle.root, key, None)
         if 'table' not in group._v_attrs.pandas_type:
@@ -284,7 +302,48 @@ class HDFStore(object):
     def _write_frame(self, group, df):
         self._write_index(group, 'index', df.index)
         self._write_index(group, 'columns', df.columns)
-        self._write_array(group, 'values', df.values)
+
+        # Supporting mixed-type DataFrame objects...nontrivial
+
+        df._consolidate_inplace()
+        nblocks = len(df._data.blocks)
+        group._v_attrs.nblocks = nblocks
+        for i in range(nblocks):
+            blk = df._data.blocks[i]
+            typ = type(blk).__name__
+            setattr(group._v_attrs, 'block%d_dtype' % i, typ)
+            self._write_index(group, 'block%d_columns' % i, blk.columns)
+
+            vkey = 'block%d_values' % i
+            if typ == 'ObjectBlock':
+                self._write_object_array(group, vkey, blk.values)
+            else:
+                self._write_array(group, vkey, blk.values)
+
+    def _read_frame(self, group, where=None):
+        from pandas.core.internals import BlockManager, make_block
+
+        index = _read_index(group, 'index')
+        frame_columns = _read_index(group, 'columns')
+
+        blocks = []
+        for i in range(group._v_attrs.nblocks):
+            blk_columns = _read_index(group, 'block%d_columns' % i)
+
+            vkey = 'block%d_values' % i
+            values = getattr(group, vkey)[:]
+
+            # Objects stored in a VLArray...
+            typ = getattr(group._v_attrs, 'block%d_dtype' % i)
+            if typ == 'ObjectBlock':
+                # kludge
+                values = values[0]
+
+            blk = make_block(values, blk_columns, frame_columns)
+            blocks.append(blk)
+
+        mgr = BlockManager(blocks, index=index, columns=frame_columns)
+        return DataFrame(mgr)
 
     def _write_frame_table(self, group, df, append=False, comp=None):
         mat = df.values
@@ -349,6 +408,13 @@ class HDFStore(object):
 
         self.handle.createArray(group, key, value)
 
+    def _write_object_array(self, group, key, value):
+        if key in group:
+            self.handle.removeNode(group, key)
+
+        vlarr = self.handle.createVLArray(group, key, tables.ObjectAtom())
+        vlarr.append(value)
+
     def _write_table(self, group, items=None, index=None, columns=None,
                      values=None, append=False, compression=None):
         """ need to check for conform to the existing table:
@@ -427,12 +493,6 @@ class HDFStore(object):
         values = group.values[:]
         return Series(values, index=index)
 
-    def _read_frame(self, group, where=None):
-        index = _read_index(group, 'index')
-        columns = _read_index(group, 'columns')
-        values = group.values[:]
-        return DataFrame(values, index=index, columns=columns)
-
     def _read_legacy_frame(self, group, where=None):
         index = _read_index_legacy(group, 'index')
         columns = _read_index_legacy(group, 'columns')
@@ -479,7 +539,7 @@ class HDFStore(object):
         l.reverse()
         for c in l:
             table.removeRows(c)
-            self.handle.flush()
+        self.handle.flush()
         return len(s.values)
 
 def _convert_index(index):
@@ -562,10 +622,25 @@ def _is_table_type(group):
 
 class Selection(object):
     """
-    apply selection criteria
-    where of the form:  [ list of and_ conditions ]
-    condition of the form dict(field = 'index', 'op' = '<=',
-                               value=datetime(2010,6,14))
+    Carries out a selection operation on a tables.Table object.
+
+    Parameters
+    ----------
+    table : tables.Table
+    where : list of dicts of the following form
+
+        Comparison op
+           {'field' : 'index',
+            'op'    : '>=',
+            'value' : value}
+
+        Match single value
+           {'field' : 'index',
+            'value' : v1}
+
+        Match a set of values
+           {'field' : 'index',
+            'value' : [v1, v2, v3]}
     """
     def __init__(self, table, where=None):
         self.table = table
@@ -608,8 +683,9 @@ class Selection(object):
             self.conditions.append('(%s %s "%s")' % (field,op,value))
 
     def select(self):
-        """ generate the selection """
-
+        """
+        generate the selection
+        """
         if self.the_condition:
             self.values = self.table.readWhere(self.the_condition)
 
@@ -617,6 +693,8 @@ class Selection(object):
             self.values = self.table.read()
 
     def select_coords(self):
-        """ generate the selection """
+        """
+        generate the selection
+        """
         self.values = self.table.getWhereList(self.the_condition)
 
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index a164a81d2..391805359 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -8,6 +8,11 @@ from pandas import (Series, DataFrame, WidePanel, LongPanel, DateRange)
 from pandas.io.pytables import HDFStore
 import pandas.util.testing as tm
 
+try:
+    import tables
+except ImportError:
+    raise nose.SkipTest('no pytables')
+
 class TesttHDFStore(unittest.TestCase):
     path = '__test__.h5'
     scratchpath = '__scratch__.h5'
@@ -148,10 +153,26 @@ class TesttHDFStore(unittest.TestCase):
         self._check_roundtrip(tdf, tm.assert_frame_equal)
 
     def test_frame_mixed(self):
-        raise nose.SkipTest('cannot handle for now')
-        df = tm.makeDataFrame()
-        df['nonfloat'] = 'foo'
-        self._check_roundtrip(df, tm.assert_frame_equal)
+        def _make_one():
+            df = tm.makeDataFrame()
+            df['obj1'] = 'foo'
+            df['obj2'] = 'bar'
+            df['bool1'] = df['A'] > 0
+            df['bool2'] = df['B'] > 0
+            df['int1'] = 1
+            df['int2'] = 2
+            return df.consolidate()
+
+        df1 = _make_one()
+        df2 = _make_one()
+
+        self._check_roundtrip(df1, tm.assert_frame_equal)
+        self._check_roundtrip(df2, tm.assert_frame_equal)
+
+        self.store['obj'] = df1
+        tm.assert_frame_equal(self.store['obj'], df1)
+        self.store['obj'] = df2
+        tm.assert_frame_equal(self.store['obj'], df2)
 
     def test_frame_table(self):
         df = tm.makeDataFrame()

commit 8efb3a6e7ec022f699f4a061e99cf65da2eca130
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jan 12 14:10:29 2010 +0000

    many more unit tests, expansion of pandas.* namespace. expanded WidePanel functionality
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@114 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/__init__.py b/pandas/__init__.py
index 7af425b99..54c37ee6e 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -2,6 +2,10 @@
 
 __docformat__ = 'restructuredtext'
 
+from datetime import datetime
+
+import numpy as np
+
 from pandas.version import __version__
 from pandas.info import __doc__
 
diff --git a/pandas/core/api.py b/pandas/core/api.py
index d4860de0c..c55204ec4 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -7,7 +7,7 @@ from pandas.core.datetools import DateOffset
 from pandas.core.frame import DataFrame
 from pandas.core.index import Index
 from pandas.core.matrix import DataMatrix
-from pandas.core.panel import WidePanel, LongPanel
+from pandas.core.panel import WidePanel, LongPanel, pivot
 from pandas.core.series import Series, TimeSeries
 
 import pandas.core.datetools as datetools
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index bdc11001b..31eb4212a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1528,12 +1528,39 @@ class DataFrame(Picklable, Groupable):
         """
         def get_cumsum(y):
             y = np.array(y)
+            mask = isnull(y)
             if not issubclass(y.dtype.type, np.int_):
-                y[np.isnan(y)] = 0
-            return y.cumsum()
+                y[mask] = 0
+            result = y.cumsum()
+
+            return result
 
         return self.apply(get_cumsum, axis=axis)
 
+    def cumprod(self, axis=0):
+        """
+        Return cumulative product over requested axis as DataFrame
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        def get_cumprod(y):
+            y = np.array(y)
+            mask = isnull(y)
+            if not issubclass(y.dtype.type, np.int_):
+                y[mask] = 1
+            result = y.cumprod()
+
+            return result
+
+        return self.apply(get_cumprod, axis=axis)
+
     def product(self, axis=0):
         """
         Return array or Series of products over requested axis.
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index a5929a543..25571f1e4 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -578,10 +578,7 @@ class DataMatrix(DataFrame):
                     if value.dtype.type == np.str_:
                         value = np.array(value, dtype=object)
         else:
-            try:
-                value = np.repeat(value, len(self.index))
-            except Exception:
-                raise Exception('Could not put %s in the matrix!' % value)
+            value = np.repeat(value, len(self.index))
 
         if value.dtype not in self._dataTypes:
             isObject = True
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index bc8f97bd8..d53a3c221 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -9,11 +9,13 @@ Contains data structures designed for manipulating panel (3-dimensional) data
 from cStringIO import StringIO
 from functools import partial
 import operator
+import sys
 
 import numpy as np
 from numpy.lib.format import write_array, read_array
 
-from pandas.core.common import _pickle_array, _unpickle_array
+from pandas.core.common import (_pickle_array, _unpickle_array,
+                                _pfixed)
 from pandas.core.groupby import GroupBy
 from pandas.core.index import Index
 from pandas.core.frame import DataFrame
@@ -247,6 +249,44 @@ class WidePanel(Panel):
 
         return DataMatrix(mat, index=self.major_axis, columns=self.minor_axis)
 
+    def __delitem__(self, key):
+        try:
+            loc = self.items.indexMap[key]
+        except KeyError:
+            raise KeyError('%s not contained in panel data items!' % key)
+
+        if loc == 0:
+            new_items = self.items[1:]
+            new_values = self.values[1:]
+        elif loc == (len(self.items) - 1):
+            new_items = self.items[:-1]
+            new_values = self.values[:-1]
+        else:
+            new_items = Index(np.concatenate((self.items[:loc],
+                                              self.items[loc + 1:])))
+            new_values = np.row_stack(self.values[:loc],
+                                      self.values[loc + 1:])
+
+        self.items = new_items
+        self.values = new_values
+
+    def pop(self, key):
+        """
+        Return item slice from panel and delete from panel
+
+        Parameters
+        ----------
+        key : object
+            Must be contained in panel's items
+
+        Returns
+        -------
+        y : DataMatrix
+        """
+        result = self[key]
+        del self[key]
+        return result
+
     def __setitem__(self, key, value):
         _, N, K = self.dims
 
@@ -463,7 +503,8 @@ class WidePanel(Panel):
 
         Returns
         -------
-        DataMatrix: index -> minor axis, columns -> items
+        y : DataMatrix
+            index -> minor axis, columns -> items
         """
         try:
             loc = self.major_axis.indexMap[key]
@@ -480,7 +521,8 @@ class WidePanel(Panel):
 
         Returns
         -------
-        DataMatrix: index -> major axis, columns -> items
+        y : DataMatrix
+            index -> major axis, columns -> items
         """
         try:
             loc = self.minor_axis.indexMap[key]
@@ -504,19 +546,27 @@ class WidePanel(Panel):
         """
         return WidePanelGroupBy(self, function, axis=axis)
 
-    def swapaxes(self):
+    def swapaxes(self, axis1='major', axis2='minor'):
         """
-        Switch minor and major axes (and transpose values to reflect
-        the change)
+        Interchange axes and swap values axes appropriately
 
         Returns
         -------
-        WidePanel (new object)
+        y : WidePanel (new object)
         """
-        new_values = self.values.swapaxes(1, 2)
+        i = self._wide_axis_number(axis1)
+        j = self._wide_axis_number(axis2)
+
+        if i == j:
+            raise Exception('Cannot specify the same axis')
+
+        mapping = {i : j, j : i}
 
-        return WidePanel(new_values, self.items,
-                         self.minor_axis, self.major_axis)
+        new_axes = (self._get_axis(mapping.get(k, k))
+                    for k in range(3))
+        new_values = self.values.swapaxes(i, j).copy()
+
+        return WidePanel(new_values, *new_axes)
 
     def toLong(self, filter_observations=True):
         """
@@ -530,7 +580,7 @@ class WidePanel(Panel):
 
         Returns
         -------
-        LongPanel
+        y : LongPanel
         """
         I, N, K = self.dims
 
@@ -577,7 +627,7 @@ class WidePanel(Panel):
 
         Returns
         -------
-        WidePanel
+        y : WidePanel
         """
         intersection = self.items.intersection(items)
         indexer = [self.items.indexMap[col] for col in intersection]
@@ -635,7 +685,7 @@ class WidePanel(Panel):
 
         Returns
         -------
-        DataMatrix
+        y : DataMatrix
         """
         i = self._wide_axis_number(axis)
 
@@ -807,6 +857,12 @@ class WidePanel(Panel):
                              self.minor_axis)
 
     def shift(self, lags, axis='major'):
+        """
+
+        Returns
+        -------
+        y : WidePanel
+        """
         values = self.values
         items = self.items
         major_axis = self.major_axis
@@ -836,6 +892,8 @@ class LongPanelIndex(object):
         self.major_axis = major_axis
         self.minor_axis = minor_axis
 
+        assert(len(minor_labels) == len(major_labels))
+
         self.major_labels = major_labels
         self.minor_labels = minor_labels
 
@@ -875,7 +933,8 @@ class LongPanelIndex(object):
 
     def truncate(self, before=None, after=None):
         """
-        Slice index between two major axis values, return complete LongPanel
+        Slice index between two major axis values, return new
+        LongPanelIndex
 
         Parameters
         ----------
@@ -887,7 +946,7 @@ class LongPanelIndex(object):
 
         Returns
         -------
-        LongPanel
+        LongPanelIndex
         """
         i, j = self._getAxisBounds(before, after)
         left, right = self._getLabelBounds(i, j)
@@ -899,7 +958,18 @@ class LongPanelIndex(object):
 
     def getMajorBounds(self, begin=None, end=None):
         """
+        Return index bounds for slicing LongPanel labels and / or
+        values
+
+        Parameters
+        ----------
+        begin : axis value or None
+        end : axis value or None
 
+        Returns
+        -------
+        y : tuple
+            (left, right) absolute bounds on LongPanel values
         """
         i, j = self._getAxisBounds(begin, end)
         left, right = self._getLabelBounds(i, j)
@@ -955,9 +1025,6 @@ class LongPanelIndex(object):
 
     @property
     def mask(self):
-        """
-
-        """
         if self._mask is None:
             self._mask = self._makeMask()
 
@@ -984,6 +1051,18 @@ class LongPanelIndex(object):
 class LongPanel(Panel):
     """
     Represents long or "stacked" format panel data
+
+    Parameters
+    ----------
+    values : ndarray (N x K)
+    items : sequence
+    index : LongPanelIndex
+
+    Note
+    ----
+    Constructor should probably not be called directly since it
+    requires creating the major and minor axis label vectors for for
+    the LongPanelIndex
     """
 
     def __init__(self, values, items, index, factors=None):
@@ -998,7 +1077,8 @@ class LongPanel(Panel):
     def fromRecords(cls, data, major_field, minor_field,
                     factors=None, exclude=None):
         """
-        Convert LongPanel
+        Create LongPanel from DataFrame or record / structured ndarray
+        object
 
         Parameters
         ----------
@@ -1060,6 +1140,17 @@ class LongPanel(Panel):
 
         return LongPanel(values, items, index, factors=factor_dict)
 
+    def toRecords(self):
+        major = np.asarray(self.major_axis).take(self.index.major_labels)
+        minor = np.asarray(self.minor_axis).take(self.index.minor_labels)
+
+        arrays = [major, minor] + list(self.values[:, i]
+                                       for i in range(len(self.items)))
+
+        names = ['major', 'minor'] + list(self.items)
+
+        return np.rec.fromarrays(arrays, names=names)
+
     @property
     def columns(self):
         """
@@ -1072,21 +1163,24 @@ class LongPanel(Panel):
         return self.columns
 
     def copy(self):
-        values = self.values.copy()
-        items = self.items
-        index = self.index
-        return LongPanel(values, items, index, factors=self.factors)
+        """
+        Return copy of LongPanel (copies ndarray)
 
-    def _get_major_axis(self):
-        return self.index.major_axis
+        Returns
+        -------
+        y : LongPanel
+        """
+        return LongPanel(self.values.copy(), self.items, self.index,
+                         factors=self.factors)
 
-    major_axis = property(fget=_get_major_axis)
+    @property
+    def major_axis(self):
+        return self.index.major_axis
 
-    def _get_minor_axis(self):
+    @property
+    def minor_axis(self):
         return self.index.minor_axis
 
-    minor_axis = property(fget=_get_minor_axis)
-
     def _get_values(self):
         return self._values
 
@@ -1113,13 +1207,20 @@ class LongPanel(Panel):
                         [key], self.index, factors=self.factors)
 
     def __setitem__(self, key, value):
-        """
-        Insert item at end of items for now
-        """
         if np.isscalar(value):
             mat = np.empty((len(self.values), 1), dtype=float)
             mat.fill(value)
+        elif isinstance(value, LongPanel):
+            if len(value.items) > 1:
+                raise Exception('input LongPanel must only have one column')
+
+            if value.index is not self.index:
+                raise Exception('Only can set identically-indexed LongPanel '
+                                'items for now')
 
+            mat = value.values
+
+        # Insert item at end of items for now
         self.items = Index(list(self.items) + [key])
         self.values = np.column_stack((self.values, mat))
 
@@ -1263,18 +1364,14 @@ class LongPanel(Panel):
             vals = ','.join('%.12f' % val for val in values)
             return '%s,%s,%s' % (major, minor, vals)
 
-        output = self._textConvert(format_cols, format_row)
-
         f = open(path, 'w')
-        f.write(output)
+        self._textConvert(f, format_cols, format_row)
         f.close()
 
-    def toString(self, col_space=15, return_=False):
+    def toString(self, buffer=sys.stdout, col_space=15):
         """
         Output a screen-friendly version of this Panel
         """
-        from pandas.core.frame import _pfixed
-
         major_space = max(max([len(str(idx))
                                for idx in self.major_axis]) + 4, 9)
         minor_space = max(max([len(str(idx))
@@ -1290,25 +1387,17 @@ class LongPanel(Panel):
                                _pfixed(minor, minor_space),
                                ''.join(_pfixed(v, col_space) for v in values))
 
-        output = self._textConvert(format_cols, format_row)
-
-        if return_:
-            return output
-        else:
-            print output
+        self._textConvert(buffer, format_cols, format_row)
 
-    def _textConvert(self, format_cols, format_row):
-        output = StringIO()
-        print >> output, format_cols(self.items)
+    def _textConvert(self, buffer, format_cols, format_row):
+        print >> buffer, format_cols(self.items)
 
         label_pairs = zip(self.index.major_labels,
                           self.index.minor_labels)
         major, minor = self.major_axis, self.minor_axis
         for i, (major_i, minor_i) in enumerate(label_pairs):
             row = format_row(major[major_i], minor[minor_i], self.values[i])
-            print >> output, row
-
-        return output.getvalue()
+            print >> buffer, row
 
     def swapaxes(self):
         """
@@ -1321,7 +1410,7 @@ class LongPanel(Panel):
         """
         # Order everything by minor labels. Have to use mergesort
         # because NumPy quicksort is not stable. Here of course I'm
-        # using the invariant that the major labels are ordered.
+        # using the property that the major labels are ordered.
         indexer = self.index.minor_labels.argsort(kind='mergesort')
 
         new_major = self.index.minor_labels.take(indexer)
@@ -1525,9 +1614,6 @@ class LongPanel(Panel):
     def apply(self, f):
         return LongPanel(f(self.values), self.items, self.index)
 
-    def square(self):
-        return self.apply(np.square)
-
     def count(self, axis=0):
         if axis == 0:
             lp = self
diff --git a/pandas/core/pytools.py b/pandas/core/pytools.py
index 60d80c84c..3d14fe60a 100644
--- a/pandas/core/pytools.py
+++ b/pandas/core/pytools.py
@@ -2,6 +2,7 @@
 from random import Random
 import base64
 import functools
+import itertools
 import os
 import string
 
@@ -18,7 +19,11 @@ def adjoin(space, *lists):
     """
     outLines = []
     newLists = []
-    lengths = [max(map(len, x)) + space for x in lists]
+    lengths = [max(map(len, x)) + space for x in lists[:-1]]
+
+    # not the last one
+    lengths.append(max(map(len, lists[-1])))
+
     maxLen = max(map(len, lists))
     for i, lst in enumerate(lists):
         nl = [x.ljust(lengths[i]) for x in lst]
@@ -45,20 +50,12 @@ def iterpairs(seq):
     >>> iterpairs([1, 2, 3, 4])
     [(1, 2), (2, 3), (3, 4)
     """
-    if len(seq) < 2:
-        raise Exception('Only works on sequences length 2 or greater!')
-
-    seqiter = iter(seq)
-    current = seqiter.next()
-    while True:
-        try:
-            next = seqiter.next()
-            yield current, next
+    # input may not be sliceable
+    seq_it = iter(seq)
+    seq_it_next = iter(seq)
+    _ = seq_it_next.next()
 
-            current = next
-
-        except StopIteration:
-            break
+    return itertools.izip(seq_it, seq_it_next)
 
 def indent(string, spaces=4):
     dent = ' ' * spaces
@@ -71,7 +68,6 @@ def banner(message):
     bar = '=' * 80
     return '%s\n%s\n%s' % (bar, message, bar)
 
-
 class groupby(dict):
     """
     A simple groupby different from the one in itertools.
@@ -85,10 +81,10 @@ class groupby(dict):
             self.setdefault(k, []).append(value)
     __iter__ = dict.iteritems
 
-    
+
 def map_indices_py(arr):
     """
-    Returns a dictionary with (element, index) pairs for each element in the 
+    Returns a dictionary with (element, index) pairs for each element in the
     given array/list
     """
     return dict([(x, i) for i, x in enumerate(arr)])
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 90035cbe4..c496cae6f 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1008,5 +1008,11 @@ class TestDataFrame(unittest.TestCase):
 
         assert_series_equal(cumsum['A'], np.cumsum(self.tsframe['A'].fill(0)))
 
+    def test_cumprod(self):
+        cumprod = self.tsframe.cumprod()
+
+        assert_series_equal(cumprod['A'],
+                            np.cumprod(self.tsframe['A'].fill(1)))
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index 8dc6bbb13..faaf021f8 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -1,11 +1,13 @@
-import unittest
+import os
 import operator
+import unittest
 
+from numpy.random import randint
 import numpy as np
 
-from pandas.core.api import notnull
+from pandas.core.api import Index, notnull
 from pandas.core.datetools import bday
-from pandas.core.panel import WidePanel, LongPanel
+from pandas.core.panel import WidePanel, LongPanelIndex, LongPanel
 from pandas.core.tests.common import (assert_frame_equal,
                                       assert_series_equal,
                                       assert_almost_equal)
@@ -214,6 +216,12 @@ class TestWidePanel(unittest.TestCase, PanelTests):
     def test_getitem(self):
         pass
 
+    def test_delitem_pop(self):
+        expected = self.panel['ItemA']
+        result = self.panel.pop('ItemA')
+        assert_frame_equal(expected, result)
+        self.assert_('ItemA' not in self.panel.items)
+
     def test_setitem(self):
 
         # LongPanel with one item
@@ -349,7 +357,18 @@ class TestWidePanel(unittest.TestCase, PanelTests):
         pass
 
     def test_swapaxes(self):
-        pass
+        result = self.panel.swapaxes('items', 'minor')
+        self.assert_(result.items is self.panel.minor_axis)
+
+        result = self.panel.swapaxes('items', 'major')
+        self.assert_(result.items is self.panel.major_axis)
+
+        result = self.panel.swapaxes('major', 'minor')
+        self.assert_(result.major_axis is self.panel.minor_axis)
+
+        # this should also work
+        result = self.panel.swapaxes(0, 1)
+        self.assert_(result.items is self.panel.major_axis)
 
     def test_toLong(self):
         # filtered
@@ -389,29 +408,48 @@ class TestWidePanel(unittest.TestCase, PanelTests):
 class TestLongPanelIndex(unittest.TestCase):
 
     def setUp(self):
-        panel = common.makeWidePanel()
-        common.add_nans(panel)
+        major_axis = Index([1, 2, 3, 4])
+        minor_axis = Index([1, 2])
 
-        self.panel = panel.toLong()
-        self.unfiltered_panel = panel.toLong(filter_observations=False)
-
-    def test_pickle(self):
-        import cPickle
+        major_labels = np.array([0, 0, 1, 2, 3, 3])
+        minor_labels = np.array([0, 1, 0, 1, 0, 1])
 
-        pickled = cPickle.dumps(self.panel)
-        unpickled = cPickle.loads(pickled)
+        self.index = LongPanelIndex(major_axis, minor_axis,
+                                    major_labels, minor_labels)
 
-        assert_almost_equal(unpickled['ItemA'].values,
-                            self.panel['ItemA'].values)
+        major_labels = np.array([0, 0, 1, 1, 1, 2, 2, 3, 3])
+        minor_labels = np.array([0, 1, 0, 1, 1, 0, 1, 0, 1])
 
-    def test_constructor(self):
-        pass
+        self.incon = LongPanelIndex(major_axis, minor_axis,
+                                    major_labels, minor_labels)
 
     def test_isConsistent(self):
-        pass
+        self.assert_(self.index.isConsistent())
+        self.assert_(not self.incon.isConsistent())
+
+        # need to construct an overflow
+        major_axis = range(70000)
+        minor_axis = range(10)
+
+        major_labels = np.arange(70000)
+        minor_labels = np.repeat(range(10), 7000)
+
+        index = LongPanelIndex(major_axis, minor_axis,
+                               major_labels, minor_labels)
+
+        self.assert_(index.isConsistent())
 
     def test_truncate(self):
-        pass
+        result = self.index.truncate(before=1)
+        self.assert_(0 not in result.major_axis)
+        self.assert_(1 in result.major_axis)
+
+        result = self.index.truncate(after=1)
+        self.assert_(2 not in result.major_axis)
+        self.assert_(1 in result.major_axis)
+
+        result = self.index.truncate(before=1, after=2)
+        self.assertEqual(len(result.major_axis), 2)
 
     def test_getMajorBounds(self):
         pass
@@ -426,13 +464,34 @@ class TestLongPanelIndex(unittest.TestCase):
         pass
 
     def test_makeMask(self):
-        pass
+        mask =  self.index.mask
+        expected = np.array([True, True,
+                             True, False,
+                             False, True,
+                             True, True], dtype=bool)
+        self.assert_(np.array_equal(mask, expected))
 
     def test_dims(self):
         pass
 
 class TestLongPanel(unittest.TestCase):
 
+    def setUp(self):
+        panel = common.makeWidePanel()
+        common.add_nans(panel)
+
+        self.panel = panel.toLong()
+        self.unfiltered_panel = panel.toLong(filter_observations=False)
+
+    def test_pickle(self):
+        import cPickle
+
+        pickled = cPickle.dumps(self.panel)
+        unpickled = cPickle.loads(pickled)
+
+        assert_almost_equal(unpickled['ItemA'].values,
+                            self.panel['ItemA'].values)
+
     def test_constructor(self):
         pass
 
@@ -449,10 +508,10 @@ class TestLongPanel(unittest.TestCase):
         pass
 
     def test_getitem(self):
-        pass
+        col = self.panel['ItemA']
 
     def test_setitem(self):
-        pass
+        self.panel['ItemE'] = self.panel['ItemA']
 
     def test_pickle(self):
         pass
@@ -467,19 +526,35 @@ class TestLongPanel(unittest.TestCase):
         pass
 
     def test_sort(self):
-        pass
+        def is_sorted(arr):
+            return (arr[1:] > arr[:-1]).any()
+
+        sorted_minor = self.panel.sort(axis='minor')
+        self.assert_(is_sorted(sorted_minor.index.minor_labels))
+
+        sorted_major = sorted_minor.sort(axis='major')
+        self.assert_(is_sorted(sorted_major.index.major_labels))
 
     def test_toWide(self):
         pass
 
     def test_toCSV(self):
-        pass
+        self.panel.toCSV('__tmp__')
+        os.remove('__tmp__')
 
     def test_toString(self):
-        pass
+        from cStringIO import StringIO
+
+        buf = StringIO()
+        self.panel.toString(buf)
+        self.panel.toString(buf, col_space=12)
 
     def test_swapaxes(self):
-        pass
+        swapped = self.panel.swapaxes()
+
+        self.assert_(swapped.major_axis is self.panel.minor_axis)
+
+        # what else to test here?
 
     def test_truncate(self):
         pass

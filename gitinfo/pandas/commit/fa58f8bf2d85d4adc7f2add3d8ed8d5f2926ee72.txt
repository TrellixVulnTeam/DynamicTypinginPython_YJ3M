commit fa58f8bf2d85d4adc7f2add3d8ed8d5f2926ee72
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jul 28 00:54:10 2011 -0400

    ENH: working on multi-level index object

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 79569b2a1..fb6b0db98 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -498,8 +498,12 @@ class DataFrame(NDFrame):
                 return _pfixed(v, colSpace, nanRep=nanRep,
                                float_format=float_format)
 
-        def _stringify(series):
-            return map(_myformat, series)
+        if formatters is None:
+            formatters = {}
+
+        def _stringify(col):
+            formatter = formatters.get(col, _myformat)
+            return [formatter(x) for x in self[col]]
 
         if columns is None:
             columns = self.columns
@@ -511,7 +515,7 @@ class DataFrame(NDFrame):
             print >> buf, repr(self.index)
         else:
             str_index = [''] + [str(x) for x in self.index]
-            stringified = [[' %s' % c] + _stringify(self[c]) for c in columns]
+            stringified = [[' %s' % c] + _stringify(c) for c in columns]
             print >> buf, adjoin(2, str_index, *stringified)
 
     def info(self, verbose=True, buf=sys.stdout):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index d3f62a5ea..a096c7001 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from pandas.core.common import _ensure_index, _is_bool_indexer
+import pandas.core.common as common
 import pandas._tseries as _tseries
 
 __all__ = ['Index']
@@ -311,6 +312,349 @@ class Index(np.ndarray):
 
         return beg_slice, end_slice
 
+
+
+class Factor(object):
+    """
+    Represents a categorical variable in classic R / S-plus fashion
+    """
+    def __init__(self, labels, levels):
+        self.labels = labels
+        self.levels = levels
+
+    @classmethod
+    def fromarray(cls, values):
+        levels = np.array(sorted(set(values)), dtype=object)
+        labels = levels.searchsorted(values)
+
+        return Factor(labels, levels=levels)
+
+    def asarray(self):
+        return self.levels[self.labels]
+
+    def __len__(self):
+        return len(self.labels)
+
+    def __repr__(self):
+        temp = 'Factor:\n%s\nLevels (%d): %s'
+        values = self.asarray()
+        return temp % (repr(values), len(self.levels), self.levels)
+
+    def __getitem__(self, key):
+        if isinstance(key, (int, np.integer)):
+            i = self.labels[key]
+            return self.levels[i]
+        else:
+            new_labels = self.labels[key]
+            return Factor(new_labels, self.levels)
+
+
+"""
+something like this?
+
+            ----------------------------------------------------
+            | common                     | uncommon            |
+            ----------------------------------------------------
+            | foo     | bar     | baz    | qux     | wibble    |
+            ----------------------------------------------------
+A       1     ...       ...       ...      ...       ...
+        2
+        3
+B       1
+        2
+C       1
+        2
+        3     ...       ...       ...      ...       ...
+
+
+ common                uncommon
+ ------                --------
+|foo    bar    baz    |qux    wibble
+
+"""
+
+class MultiLevelIndex(Index):
+    """
+    Implements multi-level, a.k.a. hierarchical, index object for pandas objects
+
+
+    Parameters
+    ----------
+    levels : list or tuple of arrays
+    labels :
+
+    """
+
+    def __new__(cls, levels=None, labels=None):
+        arr = np.empty(len(labels[0]), dtype=object)
+        arr[:] = zip(*labels)
+        arr = arr.view(cls)
+
+        arr.levels = [_ensure_index(lev) for lev in levels]
+        arr.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
+
+        return arr
+
+    # def __init__(self, levels=None, labels=None):
+    #     self.levels = [_ensure_index(lev) for lev in levels]
+    #     self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
+    #     self._verify_integrity()
+
+    def __array_finalize__(self, obj):
+        self.labels = getattr(obj, 'labels', None)
+        self.levels = getattr(obj, 'levels', None)
+
+    @property
+    def nlevels(self):
+        return len(levels)
+
+    @property
+    def levshape(self):
+        return tuple(len(x) for x in self.levels)
+
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(np.ndarray.__reduce__(self))
+        subclass_state = (self.levels, self.labels)
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
+    def __setstate__(self, state):
+        """Necessary for making this object picklable"""
+        nd_state, own_state = state
+        np.ndarray.__setstate__(self, nd_state)
+        levels, labels, = own_state
+
+        self.levels = [Index(x) for x in levels]
+        self.labels = labels
+
+    def sort(self, bylevel=0):
+        pass
+
+    @classmethod
+    def from_arrays(cls, *arrays):
+        levels = []
+        labels = []
+        return cls(levels, labels)
+
+    def get_loc(self, key):
+        return self.indexMap[key]
+
+    def get_indexer(self, target, method=None):
+        """
+
+        Parameters
+        ----------
+        target : Index
+        method :
+
+        Returns
+        -------
+        (indexer, mask)
+        """
+        if method:
+            method = method.upper()
+
+        aliases = {
+            'FFILL' : 'PAD',
+            'BFILL' : 'BACKFILL'
+        }
+
+        target = _ensure_index(target)
+
+        method = aliases.get(method, method)
+        indexer, mask = _tseries.getFillVec(self, target, self.indexMap,
+                                            target.indexMap, method)
+        return indexer, mask
+
+    def slice_locs(self, start=None, end=None):
+        """
+
+
+        Returns
+        -------
+
+        Notes
+        -----
+        This function assumes that the data is sorted, so use at your own peril
+        """
+        if start is None:
+            beg_slice = 0
+        elif start in self:
+            beg_slice = self.indexMap[start]
+        else:
+            beg_slice = self.searchsorted(start, side='left')
+
+        if end is None:
+            end_slice = len(self)
+        elif end in self.indexMap:
+            end_slice = self.indexMap[end] + 1
+        else:
+            end_slice = self.searchsorted(end, side='right')
+
+        return beg_slice, end_slice
+
+class LongPanelIndex(MultiLevelIndex):
+    """
+    Holds axis indexing information for a LongPanel instance
+
+    Parameters
+    ----------
+    major_axis : Index-like
+    minor_axis : Index-like
+    major_labels : ndarray
+    minor_labels : ndarray
+    mask : ndarray (bool), optional
+        observation selection vector using major and minor labels, for
+        converting to wide format.
+    """
+    # def __new__(cls, major_axis, minor_axis, major_labels, minor_labels):
+    #     return MultiLevelIndex.__new__(cls, levels=[major_axis, minor_axis],
+    #                                    labels=[major_labels, minor_labels])
+
+    # def __init__(self, major_axis, minor_axis, major_labels,
+    #              minor_labels, mask=None):
+
+    #     assert(len(minor_labels) == len(major_labels))
+    #     MultiLevelIndex.__init__(self, levels=[major_axis, minor_axis],
+    #                              labels=[major_labels, minor_labels])
+    #     self._mask = mask
+
+    @property
+    def major_axis(self):
+        return self.levels[0]
+
+    @property
+    def minor_axis(self):
+        return self.levels[1]
+
+
+    @property
+    def major_labels(self):
+        return self.labels[0]
+
+    @property
+    def minor_labels(self):
+        return self.labels[1]
+
+    def truncate(self, before=None, after=None):
+        """
+        Slice index between two major axis values, return new
+        LongPanelIndex
+
+        Parameters
+        ----------
+        before : type of major_axis values or None, default None
+            None defaults to start of panel
+
+        after : type of major_axis values or None, default None
+            None defaults to after of panel
+
+        Returns
+        -------
+        LongPanelIndex
+        """
+        i, j = self._get_axis_bounds(before, after)
+        left, right = self._get_label_bounds(i, j)
+
+        return LongPanelIndex([self.major_axis[i : j],
+                               self.minor_axis],
+                              [self.major_labels[left : right] - i,
+                               self.minor_labels[left : right]])
+
+    def get_major_bounds(self, begin=None, end=None):
+        """
+        Return index bounds for slicing LongPanel labels and / or
+        values
+
+        Parameters
+        ----------
+        begin : axis value or None
+        end : axis value or None
+
+        Returns
+        -------
+        y : tuple
+            (left, right) absolute bounds on LongPanel values
+        """
+        i, j = self._get_axis_bounds(begin, end)
+        left, right = self._get_label_bounds(i, j)
+
+        return left, right
+
+    def _get_axis_bounds(self, begin, end):
+        """
+        Return major axis locations corresponding to interval values
+        """
+        if begin is not None:
+            i = self.major_axis.indexMap.get(begin)
+            if i is None:
+                i = self.major_axis.searchsorted(begin, side='right')
+        else:
+            i = 0
+
+        if end is not None:
+            j = self.major_axis.indexMap.get(end)
+            if j is None:
+                j = self.major_axis.searchsorted(end)
+            else:
+                j = j + 1
+        else:
+            j = len(self.major_axis)
+
+        if i > j:
+            raise ValueError('Must have begin <= end!')
+
+        return i, j
+
+    def _get_label_bounds(self, i, j):
+        "Return slice points between two major axis locations"
+
+        left = self._bounds[i]
+
+        if j >= len(self.major_axis):
+            right = len(self.major_labels)
+        else:
+            right = self._bounds[j]
+
+        return left, right
+
+    __bounds = None
+    @property
+    def _bounds(self):
+        "Return or compute and return slice points for major axis"
+        if self.__bounds is None:
+            inds = np.arange(len(self.major_axis))
+            self.__bounds = self.major_labels.searchsorted(inds)
+
+        return self.__bounds
+
+    @property
+    def mask(self):
+        return self._make_mask()
+        # if self._mask is None:
+        #     self._mask = self._make_mask()
+
+        # return self._mask
+
+    def _make_mask(self):
+        """
+        Create observation selection vector using major and minor
+        labels, for converting to wide format.
+        """
+        N, K = self.levshape
+        selector = self.minor_labels + K * self.major_labels
+
+        mask = np.zeros(N * K, dtype=bool)
+        mask[selector] = True
+
+        return mask
+
+    # @property
+    # def shape(self):
+    #     return len(self.major_axis), len(self.minor_axis)
+
+
 # For utility purposes
 
 NULL_INDEX = Index([])
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 5a23e4b8c..10ed52f6e 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -12,7 +12,7 @@ import numpy as np
 
 from pandas.core.common import (PandasError, _mut_exclusive, _ensure_index,
                                 _pfixed, _default_index, _infer_dtype)
-from pandas.core.index import Index
+from pandas.core.index import Index, Factor, LongPanelIndex
 from pandas.core.internals import BlockManager, make_block
 from pandas.core.frame import DataFrame
 from pandas.core.generic import AxisProperty, NDFrame, Picklable
@@ -675,11 +675,11 @@ class WidePanel(Panel, NDFrame):
         else:
             mask = None
 
-        index = LongPanelIndex(self.major_axis,
-                               self.minor_axis,
-                               major_labels,
-                               minor_labels,
-                               mask=mask)
+        index = LongPanelIndex(levels=[self.major_axis,
+                                       self.minor_axis],
+                               labels=[major_labels,
+                                       minor_labels])
+                               # mask=mask)
 
         return LongPanel(values, self.items, index)
 
@@ -1056,8 +1056,8 @@ class LongPanel(Panel, Picklable):
         items = sorted(data)
         values = np.array([data[k] for k in items]).T
 
-        index = LongPanelIndex(major_axis, minor_axis,
-                               major_labels, minor_labels)
+        index = LongPanelIndex([major_axis, minor_axis],
+                               [major_labels, minor_labels])
 
         return LongPanel(values, items, index, factors=factor_dict)
 
@@ -1231,8 +1231,8 @@ class LongPanel(Panel, Picklable):
         new_minor = self.index.minor_labels.take(indexer)
         new_values = self.values.take(indexer, axis=0)
 
-        new_index = LongPanelIndex(self.major_axis, self.minor_axis,
-                                   new_major, new_minor)
+        new_index = LongPanelIndex([self.major_axis, self.minor_axis],
+                                    [new_major, new_minor])
 
         new_factors = dict((k, v.take(indexer))
                            for k, v in self.factors.iteritems())
@@ -1248,10 +1248,6 @@ class LongPanel(Panel, Picklable):
         -------
         WidePanel
         """
-        if not self.index.consistent:
-            raise PanelError('Panel has duplicate (major, minor) pairs, '
-                             'cannot be reliably converted to wide format.')
-
         I, N, K = self.shape
 
         values = np.empty((I, N, K), dtype=self.values.dtype)
@@ -1331,11 +1327,11 @@ class LongPanel(Panel, Picklable):
 
         new_values = self.values.take(indexer, axis=0)
 
-        new_index = LongPanelIndex(self.minor_axis,
-                                   self.major_axis,
-                                   new_major,
-                                   new_minor,
-                                   mask=self.index.mask)
+        new_index = LongPanelIndex([self.minor_axis,
+                                    self.major_axis],
+                                   [new_major,
+                                    new_minor])
+                                   # mask=self.index.mask)
 
         return LongPanel(new_values, self.items, new_index)
 
@@ -1573,188 +1569,6 @@ class LongPanel(Panel, Picklable):
         return LongPanel(self.values, new_items, self.index)
 
 
-class LongPanelIndex(object):
-    """
-    Holds axis indexing information for a LongPanel instance
-
-    Parameters
-    ----------
-    major_axis : Index-like
-    minor_axis : Index-like
-    major_labels : ndarray
-    minor_labels : ndarray
-    mask : ndarray (bool), optional
-        observation selection vector using major and minor labels, for
-        converting to wide format.
-    """
-    def __init__(self, major_axis, minor_axis, major_labels,
-                 minor_labels, mask=None):
-
-        self.major_axis = major_axis
-        self.minor_axis = minor_axis
-
-        assert(len(minor_labels) == len(major_labels))
-
-        self.major_labels = major_labels
-        self.minor_labels = minor_labels
-
-        self._mask = mask
-
-    def __len__(self):
-        return len(self.major_labels)
-
-    def __getstate__(self):
-        _pickle = common._pickle_array
-        return (_pickle(self.major_axis),
-                _pickle(self.minor_axis),
-                _pickle(self.major_labels),
-                _pickle(self.minor_labels))
-
-    def __setstate__(self, state):
-        _unpickle = common._unpickle_array
-
-        major, minor, major_labels, minor_labels = state
-
-        self.major_axis = _unpickle(major)
-        self.minor_axis = _unpickle(minor)
-
-        self.major_labels = _unpickle(major_labels)
-        self.minor_labels = _unpickle(minor_labels)
-
-    @property
-    def consistent(self):
-        offset = max(len(self.major_axis), len(self.minor_axis))
-
-        # overflow risk
-        if (offset + 1) ** 2 > 2**32:
-            keys = (self.major_labels.astype(np.int64) * offset +
-                    self.minor_labels.astype(np.int64))
-        else:
-            keys = self.major_labels * offset + self.minor_labels
-
-        unique_keys = np.unique(keys)
-
-        if len(unique_keys) < len(keys):
-            return False
-
-        return True
-
-    def truncate(self, before=None, after=None):
-        """
-        Slice index between two major axis values, return new
-        LongPanelIndex
-
-        Parameters
-        ----------
-        before : type of major_axis values or None, default None
-            None defaults to start of panel
-
-        after : type of major_axis values or None, default None
-            None defaults to after of panel
-
-        Returns
-        -------
-        LongPanelIndex
-        """
-        i, j = self._get_axis_bounds(before, after)
-        left, right = self._get_label_bounds(i, j)
-
-        return LongPanelIndex(self.major_axis[i : j],
-                              self.minor_axis,
-                              self.major_labels[left : right] - i,
-                              self.minor_labels[left : right])
-
-    def get_major_bounds(self, begin=None, end=None):
-        """
-        Return index bounds for slicing LongPanel labels and / or
-        values
-
-        Parameters
-        ----------
-        begin : axis value or None
-        end : axis value or None
-
-        Returns
-        -------
-        y : tuple
-            (left, right) absolute bounds on LongPanel values
-        """
-        i, j = self._get_axis_bounds(begin, end)
-        left, right = self._get_label_bounds(i, j)
-
-        return left, right
-
-    def _get_axis_bounds(self, begin, end):
-        """
-        Return major axis locations corresponding to interval values
-        """
-        if begin is not None:
-            i = self.major_axis.indexMap.get(begin)
-            if i is None:
-                i = self.major_axis.searchsorted(begin, side='right')
-        else:
-            i = 0
-
-        if end is not None:
-            j = self.major_axis.indexMap.get(end)
-            if j is None:
-                j = self.major_axis.searchsorted(end)
-            else:
-                j = j + 1
-        else:
-            j = len(self.major_axis)
-
-        if i > j:
-            raise ValueError('Must have begin <= end!')
-
-        return i, j
-
-    def _get_label_bounds(self, i, j):
-        "Return slice points between two major axis locations"
-
-        left = self._bounds[i]
-
-        if j >= len(self.major_axis):
-            right = len(self.major_labels)
-        else:
-            right = self._bounds[j]
-
-        return left, right
-
-    __bounds = None
-    @property
-    def _bounds(self):
-        "Return or compute and return slice points for major axis"
-        if self.__bounds is None:
-            inds = np.arange(len(self.major_axis))
-            self.__bounds = self.major_labels.searchsorted(inds)
-
-        return self.__bounds
-
-    @property
-    def mask(self):
-        if self._mask is None:
-            self._mask = self._make_mask()
-
-        return self._mask
-
-    def _make_mask(self):
-        """
-        Create observation selection vector using major and minor
-        labels, for converting to wide format.
-        """
-        N, K = self.shape
-        selector = self.minor_labels + K * self.major_labels
-
-        mask = np.zeros(N * K, dtype=bool)
-        mask[selector] = True
-
-        return mask
-
-    @property
-    def shape(self):
-        return len(self.major_axis), len(self.minor_axis)
-
 def _prep_ndarray(values, copy=True):
     if not isinstance(values, np.ndarray):
         values = np.asarray(values)
@@ -1767,39 +1581,6 @@ def _prep_ndarray(values, copy=True):
     assert(values.ndim == 3)
     return values
 
-class Factor(object):
-    """
-    Represents a categorical variable in classic R / S-plus fashion
-    """
-    def __init__(self, labels, levels):
-        self.labels = labels
-        self.levels = levels
-
-    @classmethod
-    def fromarray(cls, values):
-        levels = np.array(sorted(set(values)), dtype=object)
-        labels = levels.searchsorted(values)
-
-        return Factor(labels, levels=levels)
-
-    def asarray(self):
-        return self.levels[self.labels]
-
-    def __len__(self):
-        return len(self.labels)
-
-    def __repr__(self):
-        temp = 'Factor:\n%s\nLevels (%d): %s'
-        values = self.asarray()
-        return temp % (repr(values), len(self.levels), self.levels)
-
-    def __getitem__(self, key):
-        if isinstance(key, (int, np.integer)):
-            i = self.labels[key]
-            return self.levels[i]
-        else:
-            new_labels = self.labels[key]
-            return Factor(new_labels, self.levels)
 
 def factor_agg(factor, vec, func):
     """
@@ -1981,8 +1762,8 @@ def _make_long_index(major_values, minor_values):
     major_labels, _ = _tseries.getMergeVec(major_values, major_axis.indexMap)
     minor_labels, _ = _tseries.getMergeVec(minor_values, minor_axis.indexMap)
 
-    long_index = LongPanelIndex(major_axis, minor_axis,
-                               major_labels, minor_labels)
+    long_index = LongPanelIndex([major_axis, minor_axis],
+                                [major_labels, minor_labels])
     return long_index
 
 def _slow_pivot(index, columns, values):
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 136d59480..cc80025a1 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -5,7 +5,7 @@ import unittest
 
 import numpy as np
 
-from pandas.core.index import Index
+from pandas.core.index import Index, Factor, MultiLevelIndex, LongPanelIndex
 import pandas.util.testing as common
 import pandas._tseries as tseries
 
@@ -210,6 +210,35 @@ class TestIndex(unittest.TestCase):
         testit(self.strIndex)
         testit(self.dateIndex)
 
+
+class TestFactor(unittest.TestCase):
+
+    def setUp(self):
+        self.factor = Factor.fromarray(['a', 'b', 'b', 'a',
+                                        'a', 'c', 'c', 'c'])
+
+    def test_getitem(self):
+        self.assertEqual(self.factor[0], 'a')
+        self.assertEqual(self.factor[-1], 'c')
+
+        subf = self.factor[[0, 1, 2]]
+        common.assert_almost_equal(subf.labels, [0, 1, 1])
+
+        subf = self.factor[self.factor.asarray() == 'c']
+        common.assert_almost_equal(subf.labels, [2, 2, 2])
+
+    def test_factor_agg(self):
+        import pandas.core.panel as panelmod
+
+        arr = np.arange(len(self.factor))
+
+        f = np.sum
+        agged = panelmod.factor_agg(self.factor, arr, f)
+        labels = self.factor.labels
+        for i, idx in enumerate(self.factor.levels):
+            self.assertEqual(f(arr[labels == i]), agged[i])
+
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 35ef0520d..99b31e2c9 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -1045,31 +1045,6 @@ def test_monotonic():
 
     assert not panelm._monotonic(neg2)
 
-class TestFactor(unittest.TestCase):
-
-    def setUp(self):
-        self.factor = panelmod.Factor.fromarray(['a', 'b', 'b', 'a',
-                                                 'a', 'c', 'c', 'c'])
-
-    def test_getitem(self):
-        self.assertEqual(self.factor[0], 'a')
-        self.assertEqual(self.factor[-1], 'c')
-
-        subf = self.factor[[0, 1, 2]]
-        common.assert_almost_equal(subf.labels, [0, 1, 1])
-
-        subf = self.factor[self.factor.asarray() == 'c']
-        common.assert_almost_equal(subf.labels, [2, 2, 2])
-
-    def test_factor_agg(self):
-        arr = np.arange(len(self.factor))
-
-        f = np.sum
-        agged = panelmod.factor_agg(self.factor, arr, f)
-        labels = self.factor.labels
-        for i, idx in enumerate(self.factor.levels):
-            self.assertEqual(f(arr[labels == i]), agged[i])
-
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],

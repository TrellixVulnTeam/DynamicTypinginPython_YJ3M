commit 5ebb1e401006008d34a7aba1bc21e65c9333a7aa
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Sep 20 05:35:25 2019 -0700

    CLN: dont catch Exception when calling maybe_convert_numeric (#28513)

diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index ac9b57dc8..e31918c21 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -796,7 +796,7 @@ def maybe_convert_objects(values: np.ndarray, convert_numeric: bool = True):
                 new_values = lib.maybe_convert_numeric(
                     values, set(), coerce_numeric=True
                 )
-            except Exception:
+            except (ValueError, TypeError):
                 pass
             else:
                 # if we are all nans then leave me alone
@@ -875,7 +875,7 @@ def soft_convert_objects(
     if numeric and is_object_dtype(values.dtype):
         try:
             converted = lib.maybe_convert_numeric(values, set(), coerce_numeric=True)
-        except Exception:
+        except (ValueError, TypeError):
             pass
         else:
             # If all NaNs, then do not-alter
@@ -953,9 +953,10 @@ def maybe_infer_to_datetimelike(value, convert_dates=False):
             # we might have a sequence of the same-datetimes with tz's
             # if so coerce to a DatetimeIndex; if they are not the same,
             # then these stay as object dtype, xref GH19671
+            from pandas._libs.tslibs import conversion
+            from pandas import DatetimeIndex
+
             try:
-                from pandas._libs.tslibs import conversion
-                from pandas import DatetimeIndex
 
                 values, tz = conversion.datetime_to_datetime64(v)
                 return DatetimeIndex(values).tz_localize("UTC").tz_convert(tz=tz)
diff --git a/pandas/core/tools/numeric.py b/pandas/core/tools/numeric.py
index a0e2c8d9c..fa33d11bd 100644
--- a/pandas/core/tools/numeric.py
+++ b/pandas/core/tools/numeric.py
@@ -137,21 +137,20 @@ def to_numeric(arg, errors="raise", downcast=None):
     else:
         values = arg
 
-    try:
-        if is_numeric_dtype(values):
-            pass
-        elif is_datetime_or_timedelta_dtype(values):
-            values = values.astype(np.int64)
-        else:
-            values = ensure_object(values)
-            coerce_numeric = errors not in ("ignore", "raise")
+    if is_numeric_dtype(values):
+        pass
+    elif is_datetime_or_timedelta_dtype(values):
+        values = values.astype(np.int64)
+    else:
+        values = ensure_object(values)
+        coerce_numeric = errors not in ("ignore", "raise")
+        try:
             values = lib.maybe_convert_numeric(
                 values, set(), coerce_numeric=coerce_numeric
             )
-
-    except Exception:
-        if errors == "raise":
-            raise
+        except (ValueError, TypeError):
+            if errors == "raise":
+                raise
 
     # attempt downcast only if the data has been successfully converted
     # to a numerical dtype and if a downcast method has been specified
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 72f1adf0a..3678e3294 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -1782,14 +1782,17 @@ class ParserBase:
                 np.putmask(values, mask, np.nan)
             return values, na_count
 
-        if try_num_bool:
+        if try_num_bool and is_object_dtype(values.dtype):
+            # exclude e.g DatetimeIndex here
             try:
                 result = lib.maybe_convert_numeric(values, na_values, False)
-                na_count = isna(result).sum()
-            except Exception:
+            except (ValueError, TypeError):
+                # e.g. encountering datetime string gets ValueError
+                #  TypeError can be raised in floatify
                 result = values
-                if values.dtype == np.object_:
-                    na_count = parsers.sanitize_objects(result, na_values, False)
+                na_count = parsers.sanitize_objects(result, na_values, False)
+            else:
+                na_count = isna(result).sum()
         else:
             result = values
             if values.dtype == np.object_:
diff --git a/pandas/tests/dtypes/test_inference.py b/pandas/tests/dtypes/test_inference.py
index 0a8707bda..cfa630490 100644
--- a/pandas/tests/dtypes/test_inference.py
+++ b/pandas/tests/dtypes/test_inference.py
@@ -379,9 +379,12 @@ class TestInference:
         assert not libmissing.isneginf_scalar(1)
         assert not libmissing.isneginf_scalar("a")
 
-    def test_maybe_convert_numeric_infinities(self):
+    @pytest.mark.parametrize("maybe_int", [True, False])
+    @pytest.mark.parametrize(
+        "infinity", ["inf", "inF", "iNf", "Inf", "iNF", "InF", "INf", "INF"]
+    )
+    def test_maybe_convert_numeric_infinities(self, infinity, maybe_int):
         # see gh-13274
-        infinities = ["inf", "inF", "iNf", "Inf", "iNF", "InF", "INf", "INF"]
         na_values = {"", "NULL", "nan"}
 
         pos = np.array(["inf"], dtype=np.float64)
@@ -389,35 +392,31 @@ class TestInference:
 
         msg = "Unable to parse string"
 
-        for infinity in infinities:
-            for maybe_int in (True, False):
-                out = lib.maybe_convert_numeric(
-                    np.array([infinity], dtype=object), na_values, maybe_int
-                )
-                tm.assert_numpy_array_equal(out, pos)
-
-                out = lib.maybe_convert_numeric(
-                    np.array(["-" + infinity], dtype=object), na_values, maybe_int
-                )
-                tm.assert_numpy_array_equal(out, neg)
-
-                out = lib.maybe_convert_numeric(
-                    np.array([infinity], dtype=object), na_values, maybe_int
-                )
-                tm.assert_numpy_array_equal(out, pos)
-
-                out = lib.maybe_convert_numeric(
-                    np.array(["+" + infinity], dtype=object), na_values, maybe_int
-                )
-                tm.assert_numpy_array_equal(out, pos)
-
-                # too many characters
-                with pytest.raises(ValueError, match=msg):
-                    lib.maybe_convert_numeric(
-                        np.array(["foo_" + infinity], dtype=object),
-                        na_values,
-                        maybe_int,
-                    )
+        out = lib.maybe_convert_numeric(
+            np.array([infinity], dtype=object), na_values, maybe_int
+        )
+        tm.assert_numpy_array_equal(out, pos)
+
+        out = lib.maybe_convert_numeric(
+            np.array(["-" + infinity], dtype=object), na_values, maybe_int
+        )
+        tm.assert_numpy_array_equal(out, neg)
+
+        out = lib.maybe_convert_numeric(
+            np.array([infinity], dtype=object), na_values, maybe_int
+        )
+        tm.assert_numpy_array_equal(out, pos)
+
+        out = lib.maybe_convert_numeric(
+            np.array(["+" + infinity], dtype=object), na_values, maybe_int
+        )
+        tm.assert_numpy_array_equal(out, pos)
+
+        # too many characters
+        with pytest.raises(ValueError, match=msg):
+            lib.maybe_convert_numeric(
+                np.array(["foo_" + infinity], dtype=object), na_values, maybe_int
+            )
 
     def test_maybe_convert_numeric_post_floatify_nan(self, coerce):
         # see gh-13314

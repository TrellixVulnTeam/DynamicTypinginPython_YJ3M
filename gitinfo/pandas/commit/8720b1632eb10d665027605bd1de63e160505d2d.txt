commit 8720b1632eb10d665027605bd1de63e160505d2d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jun 24 23:17:03 2011 -0400

    Pre-emptive unit tests for fancy setitem on DataFrame

diff --git a/RELEASE.rst b/RELEASE.rst
index 2e7645bc5..b81eacbe4 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -40,7 +40,10 @@ Release notes
   * series.ix[[d1, d2, d3]]
   * frame.ix[5:10, ['C', 'B', 'A']], frame.ix[5:10, 'A':'C']
   * frame.ix[date1:date2]
-* Boolean indexing with DataFrame objects: df[df > 1] = 1
+* `Series` arithmetic methods with optional fill_value for missing data,
+  e.g. a.add(b, fill_value=0). If a location is missing for both it will still
+  be missing in the result though.
+* Boolean indexing with `DataFrame` objects: data[data > 0.1] = 0.1
 * `pytz` / tzinfo support in `DateRange`
   * `tz_localize`, `tz_normalize`, and `tz_validate` methods added
 * Added `ExcelFile` class to `pandas.io.parsers` for parsing multiple sheets out
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 1c48a3307..c958a3f44 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -54,6 +54,9 @@ Returns
 result : DataFrame
 """
 
+class PandasError(Exception):
+    pass
+
 def _arith_method(func, name, default_axis='columns'):
     def f(self, other, axis=default_axis):
         if isinstance(other, DataFrame):    # Another DataFrame
@@ -150,7 +153,7 @@ class DataFrame(PandasGeneric):
             mgr = self._init_matrix(data, index, columns, dtype=dtype,
                                     copy=copy)
         else:
-            raise Exception('DataFrame constructor not properly called!')
+            raise PandasError('DataFrame constructor not properly called!')
 
         self._data = mgr
 
@@ -769,8 +772,8 @@ class DataFrame(PandasGeneric):
             return DataFrame(new_data)
         elif isinstance(item, np.ndarray):
             if len(item) != len(self.index):
-                raise Exception('Item wrong length %d instead of %d!' %
-                                (len(item), len(self.index)))
+                raise ValueError('Item wrong length %d instead of %d!' %
+                                 (len(item), len(self.index)))
             new_index = self.index[item]
             return self.reindex(new_index)
         else:
@@ -791,8 +794,8 @@ class DataFrame(PandasGeneric):
         if isinstance(key, DataFrame):
             if not (key.index.equals(self.index) and
                     key.columns.equals(self.columns)):
-                raise Exception('Can only index with like-indexed '
-                                'DataFrame objects')
+                raise PandasError('Can only index with like-indexed '
+                                  'DataFrame objects')
 
             self._boolean_set(key, value)
         else:
@@ -801,10 +804,10 @@ class DataFrame(PandasGeneric):
     def _boolean_set(self, key, value):
         mask = key.values
         if mask.dtype != np.bool_:
-            raise Exception('Must pass DataFrame with boolean values only')
+            raise ValueError('Must pass DataFrame with boolean values only')
 
         if self._data.is_mixed_dtype():
-            raise Exception('Boolean setting not possible on mixed-type frame')
+            raise ValueError('Boolean setting not possible on mixed-type frame')
 
         self.values[mask] = value
 
@@ -981,7 +984,7 @@ class DataFrame(PandasGeneric):
             matcher = re.compile(regex)
             return self.select(lambda x: matcher.match(x) is not None, axis=1)
         else:
-            raise Exception('items was None!')
+            raise ValueError('items was None!')
 
     def select(self, crit, axis=0):
         """
@@ -2463,26 +2466,7 @@ class DataFrame(PandasGeneric):
 
         return self._ix
 
-    def _fancy_getitem(self, key, axis=0):
-        labels = self._get_axis(axis)
-        axis_name = self._get_axis_name(axis)
-
-        # asarray can be unsafe, NumPy strings are weird
-        isbool = np.asarray(key).dtype == np.bool_
-        if isbool:
-            if isinstance(key, Series):
-                if not key.index.equals(labels):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-            return self.reindex(**{axis_name : labels[key]})
-        else:
-            return self.reindex(**{axis_name : key})
-
     def _fancy_getitem_tuple(self, rowkey, colkey):
-        def _is_label_like(key):
-            # select a label or row
-            return not isinstance(key, slice) and not _is_list_like(key)
-
         # to avoid wasted computation
         # df.ix[d1:d2, 0] -> columns first (True)
         # df.ix[0, ['C', 'B', A']] -> rows first (False)
@@ -2496,9 +2480,12 @@ class DataFrame(PandasGeneric):
 
         return result
 
+    def _fancy_setitem_tuple(self, rowkey, colkey, value):
+        pass
+
     def _fancy_getitem_axis(self, key, axis=0):
         if isinstance(key, slice):
-            return self._slice_axis(key, axis=axis)
+            return self._get_slice_axis(key, axis=axis)
         elif _is_list_like(key):
             return self._fancy_getitem(key, axis=axis)
         elif axis == 0:
@@ -2517,7 +2504,25 @@ class DataFrame(PandasGeneric):
 
             return self[col]
 
-    def _slice_axis(self, slice_obj, axis=0):
+    def _fancy_getitem(self, key, axis=0):
+        labels = self._get_axis(axis)
+        axis_name = self._get_axis_name(axis)
+
+        # asarray can be unsafe, NumPy strings are weird
+        isbool = np.asarray(key).dtype == np.bool_
+        if isbool:
+            if isinstance(key, Series):
+                if not key.index.equals(labels):
+                    raise Exception('Cannot use boolean index with misaligned '
+                                    'or unequal labels')
+            return self.reindex(**{axis_name : labels[key]})
+        else:
+            return self.reindex(**{axis_name : key})
+
+    def _fancy_setitem_axis(self, key, value, axis=0):
+        pass
+
+    def _get_slice_axis(self, slice_obj, axis=0):
         _check_step(slice_obj)
 
         if not _need_slice(slice_obj):
@@ -2542,6 +2547,12 @@ class DataFrame(PandasGeneric):
 
         return DataFrame(new_values, index=new_index, columns=new_columns)
 
+
+def _is_label_like(key):
+    # select a label or row
+    return not isinstance(key, slice) and not _is_list_like(key)
+
+
 class _DataFrameIndexer(object):
     """
     Class to support fancy indexing, potentially using labels of DataFrame
@@ -2577,7 +2588,21 @@ class _DataFrameIndexer(object):
             return frame._fancy_getitem_axis(key, axis=0)
 
     def __setitem__(self, key, value):
-        raise NotImplementedError
+        if self.frame._is_mixed_type:
+            raise Exception('setting on mixed-type frames not yet supported')
+
+        frame = self.frame
+        if isinstance(key, slice):
+            return frame._fancy_setitem_axis(key, value, axis=0)
+        elif isinstance(key, tuple):
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            x, y = key
+            return frame._fancy_setitem_tuple(x, y, value)
+        elif _is_list_like(key):
+            return frame._fancy_setitem(key, value, axis=0)
+        else:
+            return frame._fancy_setitem_axis(key, value, axis=0)
 
 def extract_index(data):
     def _union_if(index, new_index):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 410e3a4c5..c39bd0a47 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1528,4 +1528,3 @@ def _seriesRepr(index, vals, nanRep='NaN'):
                            itertools.izip(string_index, vals))
 
     return '\n'.join(it)
-
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index b77840578..a92052ab1 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -7,6 +7,7 @@ import os
 import unittest
 
 from numpy import random
+from numpy.random import randn
 import numpy as np
 
 import pandas.core.datetools as datetools
@@ -205,6 +206,97 @@ class CheckIndexing(object):
         exp.values[5:10] = 5
         assert_frame_equal(f, exp)
 
+    def test_setitem_fancy_2d(self):
+        f = self.frame
+        ix = f.ix
+
+        # case 1
+        frame = self.frame.copy()
+        expected = frame.copy()
+        frame.ix[:, ['B', 'A']] = 1
+        expected['B'] = 1
+        expected['A'] = 1
+        assert_frame_equal(frame, expected)
+
+        # case 2
+        frame = self.frame.copy()
+        frame2 = self.frame.copy()
+
+        expected = frame.copy()
+
+        subidx = self.frame.index[[5, 4, 1]]
+        values = randn(3, 2)
+
+        frame.ix[subidx, ['B', 'A']] = values
+        frame2.ix[[5, 4, 1], ['B', 'A']] = values
+
+        expected['B'].ix[subidx] = values[:, 0]
+        expected['A'].ix[subidx] = values[:, 1]
+
+        assert_frame_equal(frame, expected)
+        assert_frame_equal(frame2, expected)
+
+        # case 3: slicing rows, etc.
+        frame = self.frame.copy()
+
+        expected1 = self.frame.copy()
+        frame.ix[5:10] = 1.
+        expected1.values[5:10] = 1.
+        assert_frame_equal(frame, expected1)
+
+        expected2 = self.frame.copy()
+        arr = randn(5, len(frame.columns))
+        frame.ix[5:10] = arr
+        expected2.values[5:10] = arr
+        assert_frame_equal(frame, expected2)
+
+        # case 4
+        frame = self.frame.copy()
+        frame.ix[5:10, :] = 1.
+        assert_frame_equal(frame, expected1)
+        frame.ix[5:10, :] = arr
+        assert_frame_equal(frame, expected2)
+
+        # case 5
+        frame = self.frame.copy()
+        frame2 = self.frame.copy()
+
+        expected = self.frame.copy()
+        values = randn(5, 2)
+
+        frame.ix[:5, ['A', 'B']] = values
+        expected['A'][:5] = values[:, 0]
+        expected['B'][:5] = values[:, 1]
+        assert_frame_equal(frame, expected)
+
+        frame.ix[:5, [0, 1]] = values
+        assert_frame_equal(frame2, expected)
+
+        # case 6: slice rows with labels, inclusive!
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        frame.ix[frame.index[5]:frame.index[10]] = 5.
+        expected.values[5:11] = 5
+        assert_frame_equal(frame, expected)
+
+        # case 7: slice columns
+        frame = self.frame.copy()
+        frame2 = self.frame.copy()
+        expected = self.frame.copy()
+
+        # slice indices
+        frame.ix[:, 1:3] = 4.
+        expected.values[:, 1:3] = 4.
+        assert_frame_equal(frame, expected)
+
+        # slice with labels
+        frame.ix[:, 'B':'C'] = 4.
+        assert_frame_equal(frame, expected)
+
+    def test_setitem_fancy_mixed_2d(self):
+        pass
+
     def test_getitem_fancy_1d(self):
         f = self.frame
         ix = f.ix
@@ -248,6 +340,54 @@ class CheckIndexing(object):
         exp = self.mixed_frame.xs(self.mixed_frame.index[5])
         assert_series_equal(xs, exp)
 
+    def test_setitem_fancy_1d(self):
+        # case 1: set cross-section for indices
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        frame.ix[2, ['C', 'B', 'A']] = [1., 2., 3.]
+        expected['C'][2] = 1.
+        expected['B'][2] = 2.
+        expected['A'][2] = 3.
+        assert_frame_equal(frame, expected)
+
+        frame2 = self.frame.copy()
+        frame2.ix[2, [3, 2, 1]] = [1., 2., 3.]
+        assert_frame_equal(frame, expected)
+
+        # case 2, set a section of a column
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        vals = randn(5)
+        expected.values[5:10, 2] = vals
+        frame.ix[5:10, 2] = vals
+        assert_frame_equal(frame, expected)
+
+        frame2 = self.frame.copy()
+        frame2.ix[5:10, 'B'] = vals
+        assert_frame_equal(frame, expected)
+
+        # case 3: full xs
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        frame.ix[4] = 5.
+        expected.values[4] = 5.
+        assert_frame_equal(frame, expected)
+
+        frame.ix[frame.index[4]] = 6.
+        expected.values[4] = 6.
+        assert_frame_equal(frame, expected)
+
+        # single column
+        frame = self.frame.copy()
+        expected = self.frame.copy()
+
+        frame.ix[:, 'A'] = 7.
+        expected['A'] = 7.
+        assert_frame_equal(frame, expected)
+
     def test_getitem_fancy_scalar(self):
         f = self.frame
         ix = f.ix
@@ -257,6 +397,19 @@ class CheckIndexing(object):
             for idx in f.index[::5]:
                 assert_almost_equal(ix[idx, col], ts[idx])
 
+    def test_setitem_fancy_scalar(self):
+        # foo
+        """
+        f = self.frame
+        ix = f.ix
+        # individual value
+        for col in f.columns:
+            ts = f[col]
+            for idx in f.index[::5]:
+                assert_almost_equal(ix[idx, col], ts[idx])
+        """
+        pass
+
     def test_getitem_fancy_boolean(self):
         f = self.frame
         ix = f.ix
@@ -281,6 +434,9 @@ class CheckIndexing(object):
                              columns=['C', 'D'])
         assert_frame_equal(result, expected)
 
+    def test_setitem_fancy_boolean(self):
+        pass
+
     def test_getitem_fancy_exceptions(self):
         ix = self.frame.ix
         self.assertRaises(Exception, ix.__getitem__,
@@ -294,27 +450,15 @@ class CheckIndexing(object):
         mask = self.frame['A'][::-1] > 1
         self.assertRaises(Exception, ix.__getitem__, mask)
 
-    def test_setitem_fancy_1d(self):
-        f = self.frame
-
-    def test_setitem_fancy_2d(self):
-        f = self.frame
-
-    def test_setitem_fancy_scalar(self):
-        f = self.frame
-        ix = f.ix
-        # individual value
-        for col in f.columns:
-            ts = f[col]
-            for idx in f.index[::5]:
-                assert_almost_equal(ix[idx, col], ts[idx])
-
-    def test_setitem_fancy_boolean(self):
-        f = self.frame
+    def test_setitem_fancy_exceptions(self):
+        pass
 
     def test_getitem_boolean_missing(self):
         pass
 
+    def test_setitem_boolean_missing(self):
+        pass
+
 class TestDataFrame(unittest.TestCase, CheckIndexing):
     klass = DataFrame
 
@@ -1095,7 +1239,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
 
     def test_corrwith(self):
         a = self.tsframe
-        noise = Series(np.random.randn(len(a)), index=a.index)
+        noise = Series(randn(len(a)), index=a.index)
 
         b = self.tsframe + noise
 
diff --git a/refactor_notes.txt b/refactor_notes.txt
deleted file mode 100644
index 43c362e31..000000000
--- a/refactor_notes.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-- NOT DOING ANYTHING C-contiguousness
-  - Get C-contiguousness right this time?
-- OK Series homogenization
-  - when does casting fail?
-- OK Deal with emptiness: empty index and / or columns
-- OK Transpose: float casted to string??
-- YES Casting, want to continue to support?
-- OK Column ordering during consolidation
-- OK Different index passed with BlockManager
-- NO Set values attribute? Way to hack it? Should I?
-
-- TODO Need sparse internal data structure
-
-NO SUPPORT YET Insertion at location...ugh
-- Currently not supported?
-
-- YES Empty columns as result of reindex?
-  - Empty columns -> floats
-
-When do consolidations happen?
-------------------------------
-- YES Before reindex
-- NO Before column deletion?
-- NO Before / after column insertion
-- YES Before joining
-- YES Before xs
-- YES Before as_matrix
-
-TODO
-----
-- transpose with blocks
-- pickling w/ backwards compat
-
-extract_index--pass index! sparse breaking
-
-Mixed type handling
--------------------
-
-Immutability
-------------
-- How much do I care?
-- Try to do it when possible...
-
-Transposing
------------
-- Currently getting casted to object...not much to do
-
-Maintain sortedness?
-- Current do where possible...maybe should preserve this?
-
-Combine / Arithmetic methods
-----------------------------
-- Consolidate, reindex, do it
-
-Rename / operations on index / columns
---------------------------------------
-
-Pickling
---------
-- backwards compat, possible?
-- need make pickles with master
-
-Ints
-----
-- Allow things to be int until introduce NaNs?
-
-Missing data in ints?
----------------------
-need some concrete test cases
-
-Sparse data structures (!)
---------------------------
-Surely going to break SparseDataFrame...will need to think of something
-

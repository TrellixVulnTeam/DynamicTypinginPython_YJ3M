commit 9a320e8d051c91109b0348628ac21eef43485e82
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Sep 23 10:40:37 2011 -0400

    ENH: doing the take in Cython makes things faster

diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index 8fc26d886..e9b416ebe 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -342,6 +342,8 @@ def ordered_left_join(ndarray[object] left, ndarray[object] right):
 
     return indexer, mask
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
 def ordered_left_join_int64(ndarray[int64_t] left, ndarray[int64_t] right):
     cdef:
         Py_ssize_t i, j, k, n
@@ -372,8 +374,72 @@ def ordered_left_join_int64(ndarray[int64_t] left, ndarray[int64_t] right):
 
     return indexer, mask
 
-def ordered_outer_join(ndarray[object] left, ndarray[object] right):
-    pass
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def ordered_left_join_put(ndarray[int64_t] left, ndarray[int64_t] right,
+                          ndarray[float64_t, ndim=2] lvalues,
+                          ndarray[float64_t, ndim=2] rvalues,
+                          ndarray[float64_t, ndim=2] out):
+    cdef:
+        Py_ssize_t i, j, k, nright, nleft, kright, kleft
+        int64_t val
+
+    nleft, kleft = (<object> lvalues).shape
+    nright, kright = (<object> rvalues).shape
+
+    j = 0
+    for i from 0 <= i < nleft:
+        for k from 0 <= k < kleft:
+            out[i, k] = lvalues[i, k]
+
+        val = left[i]
+
+        while j < nright and right[j] < val:
+            j += 1
+
+        if j == nright:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = NaN
+            continue
+
+        if val == right[j]:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = rvalues[j, k - kleft]
+        else:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = NaN
+
+
+def ordered_outer_join(ndarray[int64] left, ndarray[int64] right):
+    cdef:
+        Py_ssize_t i, j, k, nright, nleft, kright, kleft
+        int64_t val
+
+    nleft, kleft = (<object> lvalues).shape
+    nright, kright = (<object> rvalues).shape
+
+    j = 0
+    for i from 0 <= i < nleft:
+        for k from 0 <= k < kleft:
+            out[i, k] = lvalues[i, k]
+
+        val = left[i]
+
+        while j < nright and right[j] < val:
+            j += 1
+
+        if j == nright:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = NaN
+            continue
+
+        if val == right[j]:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = rvalues[j, k - kleft]
+        else:
+            for k from kleft <= k < kleft + kright:
+                out[i, k] = NaN
+
 
 def ordered_inner_join(ndarray[object] left, ndarray[object] right):
     pass
diff --git a/scripts/bench_join.py b/scripts/bench_join.py
index 4eb1aa647..be9feb4e5 100644
--- a/scripts/bench_join.py
+++ b/scripts/bench_join.py
@@ -4,21 +4,21 @@ from pandas import *
 from copy import deepcopy
 
 a = np.arange(100000, dtype=np.int64)
-b = a[::2].copy()
+b = np.arange(20000, 120000, dtype=np.int64)
 
 dr1 = DateRange('1/1/2000', periods=100000, offset=datetools.Minute())
-dr2 = DateRange('1/1/2000', periods=50000, offset=datetools.Minute(2))
+dr2 = DateRange(dr1[20000], periods=100000, offset=datetools.Minute(2))
 
 aobj = a.astype(object)
 bobj = b.astype(object)
 
 av = np.random.randn(100000)
-bv = np.random.randn(50000)
+bv = np.random.randn(100000)
 
-K = 1
+K = 5
 
 avf = np.random.randn(100000, K)
-bvf = np.random.randn(50000, K)
+bvf = np.random.randn(100000, K)
 
 a_series = Series(av, index=a)
 b_series = Series(bv, index=b)
@@ -37,7 +37,6 @@ prof = LineProfiler()
 
 from pandas.util.testing import set_trace
 
-@prof
 def do_left_join_multi(a, b, av, bv):
     indexer, mask = lib.ordered_left_join_int64(a, b)
 
@@ -49,16 +48,23 @@ def do_left_join_multi(a, b, av, bv):
     result[:ak] = av.T
 
     bchunk = result[ak:]
-    take_multi(bv.T, indexer, bchunk)
+    _take_multi(bv.T, indexer, bchunk)
     np.putmask(bchunk, np.tile(mask, bk), np.nan)
     return result
 
-def take_multi(data, indexer, out):
+def _take_multi(data, indexer, out):
     if not data.flags.c_contiguous:
         data = data.copy()
     for i in xrange(data.shape[0]):
         data[i].take(indexer, out=out[i])
 
+def do_left_join_multi_put(a, b, av, bv):
+    n, ak = av.shape
+    _, bk = bv.shape
+    result = np.empty((n, ak + bk), dtype=np.float64)
+    lib.ordered_left_join_put(a, b, av, bv, result)
+    return result
+
 def do_left_join_multi_v2(a, b, av, bv):
     indexer, mask = lib.ordered_left_join_int64(a, b)
     bv_taken = bv.take(indexer, axis=0)

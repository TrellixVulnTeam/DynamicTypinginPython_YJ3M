commit b7e80a53bba25038d749ba2a487e916023cd78d1
Author: jreback <jeff@reback.net>
Date:   Mon Aug 12 19:30:41 2013 -0400

    DOC/ENH: timedelta conversions & docs
    
    TST: add tests/catch for non-absolute DateOffsets in timedelta operations

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 5b6157ede..e0532b6be 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -53,8 +53,11 @@ pandas 0.13
   - Add ``rename`` and ``set_names`` methods to ``Index`` as well as
     ``set_names``, ``set_levels``, ``set_labels`` to ``MultiIndex``.
     (:issue:`4039`)
-  - A Series of dtype ``Timedelta64[ns]`` can now be divided/multiplied
+  - A Series of dtype ``timedelta64[ns]`` can now be divided/multiplied
     by an integer series (:issue`4521`)
+  - A Series of dtype ``timedelta64[ns]`` can now be divided by another
+    ``timedelta64[ns]`` object to yield a ``float64`` dtyped Series. This
+    is frequency conversion.
 
 **API Changes**
 
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 78c3e832b..e9540365c 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -170,7 +170,7 @@ Take care, ``to_datetime`` may not act as you expect on mixed data:
 
 .. ipython:: python
 
-   pd.to_datetime([1, '1'])
+   to_datetime([1, '1'])
 
 .. _timeseries.daterange:
 
@@ -297,7 +297,7 @@ the year or year and month as strings:
 
    ts['2011-6']
 
-This type of slicing will work on a DataFrame with a ``DateTimeIndex`` as well. Since the 
+This type of slicing will work on a DataFrame with a ``DateTimeIndex`` as well. Since the
 partial string selection is a form of label slicing, the endpoints **will be** included. This
 would include matching times on an included date. Here's an example:
 
@@ -1112,7 +1112,8 @@ Time Deltas
 -----------
 
 Timedeltas are differences in times, expressed in difference units, e.g. days,hours,minutes,seconds.
-They can be both positive and negative.
+They can be both positive and negative. :ref:`DateOffsets<timeseries.offsets>` that are absolute in nature
+(``Day, Hour, Minute, Second, Milli, Micro, Nano``) can be used as ``timedeltas``.
 
 .. ipython:: python
 
@@ -1128,41 +1129,16 @@ They can be both positive and negative.
    s - s.max()
    s - datetime(2011,1,1,3,5)
    s + timedelta(minutes=5)
+   s + Minute(5)
+   s + Minute(5) + Milli(5)
 
 Getting scalar results from a ``timedelta64[ns]`` series
 
-.. ipython:: python
-   :suppress:
-
-   from distutils.version import LooseVersion
-
 .. ipython:: python
 
    y = s - s[0]
    y
 
-.. code-block:: python
-
-   if LooseVersion(np.__version__) <= '1.6.2':
-       y.apply(lambda x: x.item().total_seconds())
-       y.apply(lambda x: x.item().days)
-   else:
-       y.apply(lambda x: x / np.timedelta64(1, 's'))
-       y.apply(lambda x: x / np.timedelta64(1, 'D'))
-
-.. note::
-
-   As you can see from the conditional statement above, these operations are
-   different in numpy 1.6.2 and in numpy >= 1.7. The ``timedelta64[ns]`` scalar
-   type in 1.6.2 is much like a ``datetime.timedelta``, while in 1.7 it is a
-   nanosecond based integer.  A future version of pandas will make this
-   transparent.
-
-.. note::
-
-   In numpy >= 1.7 dividing a ``timedelta64`` array by another ``timedelta64``
-   array will yield an array with dtype ``np.float64``.
-
 Series of timedeltas with ``NaT`` values are supported
 
 .. ipython:: python
@@ -1218,3 +1194,55 @@ issues). ``idxmin, idxmax`` are supported as well.
 
    df.min().idxmax()
    df.min(axis=1).idxmin()
+
+.. _timeseries.timedeltas_convert:
+
+Time Deltas & Conversions
+-------------------------
+
+.. versionadded:: 0.13
+
+Timedeltas can be converted to other 'frequencies' by dividing by another timedelta.
+These operations yield ``float64`` dtyped Series.
+
+.. ipython:: python
+
+   td = Series(date_range('20130101',periods=4))-Series(date_range('20121201',periods=4))
+   td[2] += np.timedelta64(timedelta(minutes=5,seconds=3))
+   td[3] = np.nan
+   td
+
+   # to days
+   td / np.timedelta64(1,'D')
+
+   # to seconds
+   td / np.timedelta64(1,'s')
+
+Dividing or multiplying a ``timedelta64[ns]`` Series by an integer or integer Series
+yields another ``timedelta64[ns]`` dtypes Series.
+
+.. ipython:: python
+
+   td * -1
+   td * Series([1,2,3,4])
+
+Numpy < 1.7 Compatibility
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Numpy < 1.7 has a broken ``timedelta64`` type that does not correctly work
+for arithmetic. Pandas bypasses this, but for frequency conversion as above,
+you need to create the divisor yourself. The ``np.timetimedelta64`` type only
+has 1 argument, the number of **micro** seconds.
+
+The following are equivalent statements in the two versions of numpy.
+
+.. code-block:: python
+
+   from distutils.version import LooseVersion
+   if LooseVersion(np.__version__) <= '1.6.2':
+       y / np.timedelta(86400*int(1e6))
+       y / np.timedelta(int(1e6))
+   else:
+       y / np.timedelta64(1,'D')
+       y / np.timedelta64(1,'s')
+
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 8ded258dc..bac8cb319 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -100,6 +100,40 @@ Enhancements
   - Added a more informative error message when plot arguments contain
     overlapping color and style arguments (:issue:`4402`)
 
+  - ``timedelta64[ns]`` operations
+
+    - A Series of dtype ``timedelta64[ns]`` can now be divided by another
+      ``timedelta64[ns]`` object to yield a ``float64`` dtyped Series. This
+      is frequency conversion. See :ref:`here<timeseries.timedeltas_convert>` for the docs.
+
+      .. ipython:: python
+
+         from datetime import timedelta
+         td = Series(date_range('20130101',periods=4))-Series(date_range('20121201',periods=4))
+         td[2] += np.timedelta64(timedelta(minutes=5,seconds=3))
+         td[3] = np.nan
+         td
+
+         # to days
+         td / np.timedelta64(1,'D')
+
+         # to seconds
+         td / np.timedelta64(1,'s')
+
+    - Dividing or multiplying a ``timedelta64[ns]`` Series by an integer or integer Series
+
+      .. ipython:: python
+
+         td * -1
+         td * Series([1,2,3,4])
+
+    - Absolute ``DateOffset`` objects can act equivalenty to ``timedeltas``
+
+      .. ipython:: python
+
+         from pandas import offsets
+         td + offsets.Minute(5) + offsets.Milli(5)
+
 Bug Fixes
 ~~~~~~~~~
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e4170dd5e..d35e251a2 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -85,13 +85,14 @@ def _arith_method(op, name, fill_zeros=None):
     def wrapper(self, other, name=name):
         from pandas.core.frame import DataFrame
         dtype = None
+        fill_value = tslib.iNaT
         wrap_results = lambda x: x
 
         lvalues, rvalues = self, other
 
         is_timedelta_lhs = com.is_timedelta64_dtype(self)
         is_datetime_lhs  = com.is_datetime64_dtype(self)
-        is_integer_lhs   = lvalues.dtype == np.int64
+        is_integer_lhs   = lvalues.dtype.kind in ['i','u']
 
         if is_datetime_lhs or is_timedelta_lhs:
 
@@ -116,14 +117,19 @@ def _arith_method(op, name, fill_zeros=None):
                     # py3 compat where dtype is 'm' but is an integer
                     if values.dtype.kind == 'm':
                         values = values.astype('timedelta64[ns]')
-                    elif name not in ['__div__','__mul__']:
-                        raise TypeError("incompatible type for a datetime/timedelta operation")
+                    elif name not in ['__truediv__','__div__','__mul__']:
+                        raise TypeError("incompatible type for a datetime/timedelta operation [{0}]".format(name))
                 elif isinstance(values[0],DateOffset):
                     # handle DateOffsets
-                    values = pa.array([ v.delta for v in values ])
-                    values = com._possibly_cast_to_timedelta(values, coerce=coerce)
+                    os = pa.array([ getattr(v,'delta',None) for v in values ])
+                    mask = isnull(os)
+                    if mask.any():
+                        raise TypeError("cannot use a non-absolute DateOffset in "
+                                        "datetime/timedelta operations [{0}]".format(','.join([ com.pprint_thing(v) for v in values[mask] ])))
+                    values = com._possibly_cast_to_timedelta(os, coerce=coerce)
                 else:
-                    values = pa.array(values)
+                    raise TypeError("incompatible type [{0}] for a datetime/timedelta operation".format(pa.array(values).dtype))
+
                 return values
 
             # convert lhs and rhs
@@ -132,13 +138,13 @@ def _arith_method(op, name, fill_zeros=None):
 
             is_datetime_rhs  = com.is_datetime64_dtype(rvalues)
             is_timedelta_rhs = com.is_timedelta64_dtype(rvalues) or (not is_datetime_rhs and _np_version_under1p7)
-            is_integer_rhs = rvalues.dtype == np.int64
+            is_integer_rhs = rvalues.dtype.kind in ['i','u']
             mask = None
 
             # timedelta and integer mul/div
             if (is_timedelta_lhs and is_integer_rhs) or (is_integer_lhs and is_timedelta_rhs):
 
-                if name not in ['__div__','__mul__']:
+                if name not in ['__truediv__','__div__','__mul__']:
                     raise TypeError("can only operate on a timedelta and an integer for "
                                     "division, but the operator [%s] was passed" % name)
                 dtype = 'timedelta64[ns]'
@@ -146,18 +152,37 @@ def _arith_method(op, name, fill_zeros=None):
                 lvalues = lvalues.astype(np.int64)
                 rvalues = rvalues.astype(np.int64)
 
-            # 2 datetimes or 2 timedeltas
-            elif (is_timedelta_lhs and is_timedelta_rhs) or (is_datetime_lhs and
-                    is_datetime_rhs):
-                if is_datetime_lhs and name != '__sub__':
+            # 2 datetimes
+            elif is_datetime_lhs and is_datetime_rhs:
+                if name != '__sub__':
                     raise TypeError("can only operate on a datetimes for subtraction, "
                                     "but the operator [%s] was passed" % name)
-                elif is_timedelta_lhs and name not in ['__add__','__sub__']:
-                    raise TypeError("can only operate on a timedeltas for "
-                                    "addition and subtraction, but the operator [%s] was passed" % name)
 
                 dtype = 'timedelta64[ns]'
                 mask = isnull(lvalues) | isnull(rvalues)
+                lvalues = lvalues.view('i8')
+                rvalues = rvalues.view('i8')
+
+            # 2 timedeltas
+            elif is_timedelta_lhs and is_timedelta_rhs:
+                mask = isnull(lvalues) | isnull(rvalues)
+
+                # time delta division -> unit less
+                if name in ['__div__','__truediv__']:
+                    dtype = 'float64'
+                    fill_value = np.nan
+                    lvalues = lvalues.astype(np.int64).astype(np.float64)
+                    rvalues = rvalues.astype(np.int64).astype(np.float64)
+
+                # another timedelta
+                elif name in ['__add__','__sub__']:
+                    dtype = 'timedelta64[ns]'
+                    lvalues = lvalues.astype(np.int64)
+                    rvalues = rvalues.astype(np.int64)
+
+                else:
+                    raise TypeError("can only operate on a timedeltas for "
+                                    "addition, subtraction, and division, but the operator [%s] was passed" % name)
 
             # datetime and timedelta
             elif is_timedelta_rhs and is_datetime_lhs:
@@ -166,6 +191,8 @@ def _arith_method(op, name, fill_zeros=None):
                     raise TypeError("can only operate on a datetime with a rhs of a timedelta for "
                                     "addition and subtraction, but the operator [%s] was passed" % name)
                 dtype = 'M8[ns]'
+                lvalues = lvalues.view('i8')
+                rvalues = rvalues.view('i8')
 
             elif is_timedelta_lhs and is_datetime_rhs:
 
@@ -173,6 +200,8 @@ def _arith_method(op, name, fill_zeros=None):
                     raise TypeError("can only operate on a timedelta and a datetime for "
                                     "addition, but the operator [%s] was passed" % name)
                 dtype = 'M8[ns]'
+                lvalues = lvalues.view('i8')
+                rvalues = rvalues.view('i8')
 
             else:
                 raise TypeError('cannot operate on a series with out a rhs '
@@ -183,14 +212,11 @@ def _arith_method(op, name, fill_zeros=None):
             if mask is not None:
                 if mask.any():
                     def f(x):
-                        x = pa.array(x,dtype='timedelta64[ns]')
-                        np.putmask(x,mask,tslib.iNaT)
+                        x = pa.array(x,dtype=dtype)
+                        np.putmask(x,mask,fill_value)
                         return x
                     wrap_results = f
 
-            lvalues = lvalues.view('i8')
-            rvalues = rvalues.view('i8')
-
         if isinstance(rvalues, Series):
 
             if hasattr(lvalues,'values'):
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 4f6b9f535..9a959fa78 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1964,14 +1964,12 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(df['A'], resultb)
         self.assert_(resultb.dtype == 'M8[ns]')
 
-        # td operate with td
-        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
-        td2 = timedelta(minutes=5, seconds=4)
-        result = td1 - td2
-        expected = Series([timedelta(seconds=0)] * 3) -Series(
-            [timedelta(seconds=1)] * 3)
-        self.assert_(result.dtype == 'm8[ns]')
-        assert_series_equal(result, expected)
+        # inplace
+        value = rs[2] + np.timedelta64(timedelta(minutes=5,seconds=1))
+        rs[2] += np.timedelta64(timedelta(minutes=5,seconds=1))
+        self.assert_(rs[2] == value)
+
+    def test_timedeltas_with_DateOffset(self):
 
         # GH 4532
         # operate with pd.offsets
@@ -1986,6 +1984,11 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
             [Timestamp('20130101 9:01:00.005'), Timestamp('20130101 9:02:00.005')])
         assert_series_equal(result, expected)
 
+        result = s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
+        expected = Series(
+            [Timestamp('20130101 9:06:00.005'), Timestamp('20130101 9:07:00.005')])
+        assert_series_equal(result, expected)
+
         if not com._np_version_under1p7:
 
             # operate with np.timedelta64 correctly
@@ -1999,6 +2002,36 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
                 [Timestamp('20130101 9:01:00.005'), Timestamp('20130101 9:02:00.005')])
             assert_series_equal(result, expected)
 
+        # valid DateOffsets
+        for do in [ 'Hour', 'Minute', 'Second', 'Day', 'Micro',
+                    'Milli', 'Nano' ]:
+            op = getattr(pd.offsets,do)
+            s + op(5)
+
+        # invalid DateOffsets
+        for do in [ 'Week', 'BDay', 'BQuarterEnd', 'BMonthEnd', 'BYearEnd',
+                    'BYearBegin','BQuarterBegin', 'BMonthBegin',
+                    'MonthEnd','YearBegin', 'YearEnd',
+                    'MonthBegin', 'QuarterBegin' ]:
+            op = getattr(pd.offsets,do)
+            self.assertRaises(TypeError, s.__add__, op(5))
+
+    def test_timedelta64_operations_with_timedeltas(self):
+
+        # td operate with td
+        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
+        td2 = timedelta(minutes=5, seconds=4)
+        result = td1 - td2
+        expected = Series([timedelta(seconds=0)] * 3) -Series(
+            [timedelta(seconds=1)] * 3)
+        self.assert_(result.dtype == 'm8[ns]')
+        assert_series_equal(result, expected)
+
+        # roundtrip
+        assert_series_equal(result + td2,td1)
+
+    def test_timedelta64_operations_with_integers(self):
+
         # GH 4521
         # divide/multiply by integers
         startdate = Series(date_range('2013-01-01', '2013-01-03'))
@@ -2029,20 +2062,51 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         result = s1 * s2
         assert_series_equal(result,expected)
 
+        for dtype in ['int32','int16','uint32','uint64','uint32','uint16','uint8']:
+            s2 = Series([20, 30, 40],dtype=dtype)
+            expected = Series(s1.values.astype(np.int64) * s2.astype(np.int64), dtype='m8[ns]')
+            expected[2] = np.nan
+            result = s1 * s2
+            assert_series_equal(result,expected)
+
         result = s1 * 2
         expected = Series(s1.values.astype(np.int64) * 2, dtype='m8[ns]')
         expected[2] = np.nan
         assert_series_equal(result,expected)
 
-        self.assertRaises(TypeError, s1.__div__, s2.astype(float))
-        self.assertRaises(TypeError, s1.__mul__, s2.astype(float))
-        self.assertRaises(TypeError, s1.__div__, 2.)
-        self.assertRaises(TypeError, s1.__mul__, 2.)
+        result = s1 * -1
+        expected = Series(s1.values.astype(np.int64) * -1, dtype='m8[ns]')
+        expected[2] = np.nan
+        assert_series_equal(result,expected)
 
-        self.assertRaises(TypeError, s1.__add__, 1)
-        self.assertRaises(TypeError, s1.__sub__, 1)
-        self.assertRaises(TypeError, s1.__add__, s2.values)
-        self.assertRaises(TypeError, s1.__sub__, s2.values)
+        # invalid ops
+        for op in ['__true_div__','__div__','__mul__']:
+            sop = getattr(s1,op,None)
+            if sop is not None:
+                self.assertRaises(TypeError, sop, s2.astype(float))
+                self.assertRaises(TypeError, sop, 2.)
+
+        for op in ['__add__','__sub__']:
+            sop = getattr(s1,op,None)
+            if sop is not None:
+                self.assertRaises(TypeError, sop, 1)
+                self.assertRaises(TypeError, sop, s2.values)
+
+    def test_timedelta64_conversions(self):
+        if com._np_version_under1p7:
+            raise nose.SkipTest("cannot use 2 argument form of timedelta64 conversions with numpy < 1.7")
+
+        startdate = Series(date_range('2013-01-01', '2013-01-03'))
+        enddate = Series(date_range('2013-03-01', '2013-03-03'))
+
+        s1 = enddate - startdate
+        s1[2] = np.nan
+
+        for m in [1, 3, 10]:
+            for unit in ['D','h','m','s','ms','us','ns']:
+                expected = s1.apply(lambda x: x / np.timedelta64(m,unit))
+                result = s1 / np.timedelta64(m,unit)
+                assert_series_equal(result, expected)
 
     def test_timedelta64_equal_timedelta_supported_ops(self):
         ser = Series([Timestamp('20130301'), Timestamp('20130228 23:00:00'),
@@ -2080,12 +2144,13 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         # timedelta64 ###
         td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
         td2 = timedelta(minutes=5, seconds=4)
-        for op in ['__mul__', '__floordiv__', '__truediv__', '__div__', '__pow__']:
+        for op in ['__mul__', '__floordiv__', '__pow__']:
             op = getattr(td1, op, None)
             if op is not None:
                 self.assertRaises(TypeError, op, td2)
         td1 + td2
         td1 - td2
+        td1 / td2
 
         # datetime64 ###
         dt1 = Series(

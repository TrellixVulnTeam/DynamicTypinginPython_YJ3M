commit 54c8a0f10c2ddde7c18c79461bf773b9887558b7
Author: Chang She <chang@lambdafoundry.com>
Date:   Tue May 22 18:08:18 2012 -0400

    ENH: intraday time filter #1275

diff --git a/pandas/core/series.py b/pandas/core/series.py
index d50b74f51..4e6b0ceeb 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2682,6 +2682,28 @@ class TimeSeries(Series):
         from pandas.tseries.resample import values_at_time
         return values_at_time(self, time, tz=tz, asof=asof)
 
+    def between_time(self, start_time, end_time, include_start=True,
+                     include_end=True, tz=None):
+        """
+        Select values between particular times of the day (e.g., 9:00-9:30 AM)
+
+        Parameters
+        ----------
+        start_time : datetime.time or string
+        end_time : datetime.time or string
+        include_start : boolean, default True
+        include_end : boolean, default True
+        tz : string or pytz.timezone, default None
+
+        Returns
+        -------
+        values_between_time : TimeSeries
+        """
+        from pandas.tseries.resample import values_between_time
+        return values_between_time(self, start_time, end_time, tz=tz,
+                                   include_start=include_start,
+                                   include_end=include_end)
+
     def tz_convert(self, tz, copy=True):
         """
         Convert TimeSeries to target time zone. If it is time zone naive, it
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 80ab72843..ca0fa8406 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1234,6 +1234,75 @@ def values_at_time(ndarray[int64_t] stamps, int64_t time):
 
     return indexer
 
+def values_between_time(ndarray[int64_t] stamps, int64_t stime, int64_t etime,
+                        bint include_start, bint include_end):
+    cdef:
+        Py_ssize_t i, j, count, n = len(stamps)
+        ndarray[int64_t] indexer, times
+        int64_t last, cur
+
+    # Assumes stamps is sorted
+
+    if len(stamps) == 0:
+        return np.empty(0, dtype=np.int64)
+
+    # is this OK?
+    # days = stamps // DAY_NS
+    times = stamps % DAY_NS
+
+    # Nanosecond resolution
+    count = 0
+    if include_start and include_end:
+        for i in range(n):
+            cur = times[i]
+            if cur >= stime and cur <= etime:
+                count += 1
+    elif include_start:
+        for i in range(n):
+            cur = times[i]
+            if cur >= stime and cur < etime:
+                count += 1
+    elif include_end:
+        for i in range(n):
+            cur = times[i]
+            if cur > stime and cur <= etime:
+                count += 1
+    else:
+        for i in range(n):
+            cur = times[i]
+            if cur > stime and cur < etime:
+                count += 1
+
+    indexer = np.empty(count, dtype=np.int64)
+
+    j = 0
+    # last = days[0]
+    if include_start and include_end:
+        for i in range(n):
+            cur = times[i]
+            if cur >= stime and cur <= etime:
+                indexer[j] = i
+                j += 1
+    elif include_start:
+        for i in range(n):
+            cur = times[i]
+            if cur >= stime and cur < etime:
+                indexer[j] = i
+                j += 1
+    elif include_end:
+        for i in range(n):
+            cur = times[i]
+            if cur > stime and cur <= etime:
+                indexer[j] = i
+                j += 1
+    else:
+        for i in range(n):
+            cur = times[i]
+            if cur > stime and cur < etime:
+                indexer[j] = i
+                j += 1
+
+    return indexer
 
 def date_normalize(ndarray[int64_t] stamps):
     cdef:
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 241e692db..e1fb75a3e 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -353,6 +353,44 @@ def values_at_time(obj, time, tz=None, asof=False):
     indexer = com._ensure_platform_int(indexer)
     return obj.take(indexer)
 
+def values_between_time(obj, start_time, end_time, include_start=True,
+                        include_end=True, tz=None):
+    """
+    Select values between particular times of day (e.g., 9:00-9:30AM)
+
+    Parameters
+    ----------
+    start_time : datetime.time or string
+    end_time : datetime.time or string
+    include_start : boolean, default True
+    include_end : boolean, default True
+    tz : string or pytz.timezone, default None
+
+    Returns
+    -------
+    values_between_time : TimeSeries
+    """
+    from dateutil.parser import parse
+
+    if tz:
+        raise NotImplementedError
+
+    if not isinstance(obj.index, DatetimeIndex):
+        raise NotImplementedError
+
+    if isinstance(start_time, basestring):
+        start_time = parse(start_time).time()
+
+    if isinstance(end_time, basestring):
+        end_time = parse(end_time).time()
+
+    start_ns = _time_to_nanosecond(start_time)
+    end_ns = _time_to_nanosecond(end_time)
+    indexer = lib.values_between_time(obj.index.asi8, start_ns, end_ns,
+                                      include_start, include_end)
+    indexer = com._ensure_platform_int(indexer)
+    return obj.take(indexer)
+
 def _time_to_nanosecond(time):
     seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
     return 1000000000L * seconds + time.microsecond * 1000
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 1599ba3f1..8a58487de 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1,5 +1,6 @@
 # pylint: disable-msg=E1101,W0612
 from __future__ import with_statement # for Python 2.5
+import itertools
 from datetime import datetime, time, timedelta
 import sys
 import os
@@ -585,6 +586,27 @@ class TestTimeSeries(unittest.TestCase):
         result = ts.at_time(time(0, 0))
         assert_series_equal(result, ts)
 
+    def test_between_time(self):
+        rng = date_range('1/1/2000', '1/5/2000', freq='5min')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        stime = time(0, 0)
+        etime = time(1, 0)
+
+        close_open = itertools.product([True, False], [True, False])
+        for inc_start, inc_end in close_open:
+            filtered = ts.between_time(stime, etime, inc_start, inc_end)
+            for rs in filtered.index:
+                t = rs.time()
+                if inc_start:
+                    self.assert_(t >= stime)
+                else:
+                    self.assert_(t > stime)
+
+                if inc_end:
+                    self.assert_(t <= etime)
+                else:
+                    self.assert_(t < etime)
+
     def test_dti_constructor_preserve_dti_freq(self):
         rng = date_range('1/1/2000', '1/2/2000', freq='5min')
 

commit be26f6dc467a92108132b309d9fe9443bce43ef8
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Thu Jan 17 12:48:41 2019 +0000

     STY: use pytest.raises context syntax (series) (#24812)

diff --git a/pandas/tests/series/test_alter_axes.py b/pandas/tests/series/test_alter_axes.py
index 99a4f0c42..cd4c0a792 100644
--- a/pandas/tests/series/test_alter_axes.py
+++ b/pandas/tests/series/test_alter_axes.py
@@ -16,11 +16,16 @@ class TestSeriesAlterAxes(object):
 
     def test_setindex(self, string_series):
         # wrong type
-        pytest.raises(TypeError, setattr, string_series, 'index', None)
+        msg = (r"Index\(\.\.\.\) must be called with a collection of some"
+               r" kind, None was passed")
+        with pytest.raises(TypeError, match=msg):
+            string_series.index = None
 
         # wrong length
-        pytest.raises(Exception, setattr, string_series, 'index',
-                      np.arange(len(string_series) - 1))
+        msg = (r"Length mismatch: Expected axis has (30|100) elements, new"
+               r" values have (29|99) elements")
+        with pytest.raises(ValueError, match=msg):
+            string_series.index = np.arange(len(string_series) - 1)
 
         # works
         string_series.index = np.arange(len(string_series))
diff --git a/pandas/tests/series/test_analytics.py b/pandas/tests/series/test_analytics.py
index b5140a531..6811e3707 100644
--- a/pandas/tests/series/test_analytics.py
+++ b/pandas/tests/series/test_analytics.py
@@ -97,8 +97,10 @@ class TestSeriesAnalytics(object):
                                check_dtype=False)
         tm.assert_series_equal(qindexer, Series(qexpected),
                                check_dtype=False)
-        pytest.raises(AssertionError, tm.assert_numpy_array_equal,
-                      qindexer, mindexer)
+        msg = (r"ndarray Expected type <(class|type) 'numpy\.ndarray'>,"
+               r" found <class 'pandas\.core\.series\.Series'> instead")
+        with pytest.raises(AssertionError, match=msg):
+            tm.assert_numpy_array_equal(qindexer, mindexer)
 
     def test_cumsum(self, datetime_series):
         self._check_accum_op('cumsum', datetime_series)
@@ -476,8 +478,13 @@ class TestSeriesAnalytics(object):
         assert_almost_equal(a.dot(b['1']), expected['1'])
         assert_almost_equal(a.dot(b2['1']), expected['1'])
 
-        pytest.raises(Exception, a.dot, a.values[:3])
-        pytest.raises(ValueError, a.dot, b.T)
+        msg = r"Dot product shape mismatch, \(4L?,\) vs \(3L?,\)"
+        # exception raised is of type Exception
+        with pytest.raises(Exception, match=msg):
+            a.dot(a.values[:3])
+        msg = "matrices are not aligned"
+        with pytest.raises(ValueError, match=msg):
+            a.dot(b.T)
 
     @pytest.mark.skipif(not PY35,
                         reason='matmul supported for Python>=3.5')
@@ -541,8 +548,13 @@ class TestSeriesAnalytics(object):
                           index=['1', '2', '3'])
         assert_series_equal(result, expected)
 
-        pytest.raises(Exception, a.dot, a.values[:3])
-        pytest.raises(ValueError, a.dot, b.T)
+        msg = r"Dot product shape mismatch, \(4,\) vs \(3,\)"
+        # exception raised is of type Exception
+        with pytest.raises(Exception, match=msg):
+            a.dot(a.values[:3])
+        msg = "matrices are not aligned"
+        with pytest.raises(ValueError, match=msg):
+            a.dot(b.T)
 
     def test_clip(self, datetime_series):
         val = datetime_series.median()
@@ -697,11 +709,13 @@ class TestSeriesAnalytics(object):
     def test_isin_with_string_scalar(self):
         # GH4763
         s = Series(['A', 'B', 'C', 'a', 'B', 'B', 'A', 'C'])
-        with pytest.raises(TypeError):
+        msg = (r"only list-like objects are allowed to be passed to isin\(\),"
+               r" you passed a \[str\]")
+        with pytest.raises(TypeError, match=msg):
             s.isin('a')
 
-        with pytest.raises(TypeError):
-            s = Series(['aaa', 'b', 'c'])
+        s = Series(['aaa', 'b', 'c'])
+        with pytest.raises(TypeError, match=msg):
             s.isin('aaa')
 
     def test_isin_with_i8(self):
@@ -771,18 +785,21 @@ class TestSeriesAnalytics(object):
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             tm.assert_series_equal(s.ptp(level=0, skipna=False), expected)
 
-        with pytest.raises(ValueError):
+        msg = r"No axis named 1 for object type <(class|type) 'type'>"
+        with pytest.raises(ValueError, match=msg):
             with tm.assert_produces_warning(FutureWarning,
                                             check_stacklevel=False):
                 s.ptp(axis=1)
 
         s = pd.Series(['a', 'b', 'c', 'd', 'e'])
-        with pytest.raises(TypeError):
+        msg = r"unsupported operand type\(s\) for -: 'str' and 'str'"
+        with pytest.raises(TypeError, match=msg):
             with tm.assert_produces_warning(FutureWarning,
                                             check_stacklevel=False):
                 s.ptp()
 
-        with pytest.raises(NotImplementedError):
+        msg = r"Series\.ptp does not implement numeric_only\."
+        with pytest.raises(NotImplementedError, match=msg):
             with tm.assert_produces_warning(FutureWarning,
                                             check_stacklevel=False):
                 s.ptp(numeric_only=True)
@@ -1103,20 +1120,27 @@ class TestSeriesAnalytics(object):
         param = list(kwargs)[0]
         name = func.__name__
 
-        msg = "the '{}' parameter .* {}".format(param, name)
+        msg = (r"the '{arg}' parameter is not "
+               r"supported in the pandas "
+               r"implementation of {fname}\(\)").format(arg=param, fname=name)
         with pytest.raises(ValueError, match=msg):
             func(s, **kwargs)
 
     @td.skip_if_np_lt_115
     def test_validate_sum_initial(self):
         s = pd.Series([1, 2])
-        with pytest.raises(ValueError, match="the 'initial' .* sum"):
+        msg = (r"the 'initial' parameter is not "
+               r"supported in the pandas "
+               r"implementation of sum\(\)")
+        with pytest.raises(ValueError, match=msg):
             np.sum(s, initial=10)
 
     def test_validate_median_initial(self):
         s = pd.Series([1, 2])
-        with pytest.raises(ValueError,
-                           match="the 'overwrite_input' .* median"):
+        msg = (r"the 'overwrite_input' parameter is not "
+               r"supported in the pandas "
+               r"implementation of median\(\)")
+        with pytest.raises(ValueError, match=msg):
             # It seems like np.median doesn't dispatch, so we use the
             # method instead of the ufunc.
             s.median(overwrite_input=True)
@@ -1124,8 +1148,10 @@ class TestSeriesAnalytics(object):
     @td.skip_if_np_lt_115
     def test_validate_stat_keepdims(self):
         s = pd.Series([1, 2])
-        with pytest.raises(ValueError,
-                           match="the 'keepdims'"):
+        msg = (r"the 'keepdims' parameter is not "
+               r"supported in the pandas "
+               r"implementation of sum\(\)")
+        with pytest.raises(ValueError, match=msg):
             np.sum(s, keepdims=True)
 
 
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index c95cf125e..1f2e2b179 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -289,8 +289,11 @@ class TestSeriesMisc(TestData, SharedWithSparse):
     def test_not_hashable(self):
         s_empty = Series()
         s = Series([1])
-        pytest.raises(TypeError, hash, s_empty)
-        pytest.raises(TypeError, hash, s)
+        msg = "'Series' objects are mutable, thus they cannot be hashed"
+        with pytest.raises(TypeError, match=msg):
+            hash(s_empty)
+        with pytest.raises(TypeError, match=msg):
+            hash(s)
 
     def test_contains(self):
         tm.assert_contains_all(self.ts.index, self.ts)
@@ -333,7 +336,8 @@ class TestSeriesMisc(TestData, SharedWithSparse):
 
     def test_raise_on_info(self):
         s = Series(np.random.randn(10))
-        with pytest.raises(AttributeError):
+        msg = "'Series' object has no attribute 'info'"
+        with pytest.raises(AttributeError, match=msg):
             s.info()
 
     def test_copy(self):
@@ -555,15 +559,17 @@ class TestCategoricalSeries(object):
     def test_categorical_delegations(self):
 
         # invalid accessor
-        pytest.raises(AttributeError, lambda: Series([1, 2, 3]).cat)
-        with pytest.raises(AttributeError,
-                           match=(r"Can only use .cat accessor "
-                                  r"with a 'category' dtype")):
+        msg = r"Can only use \.cat accessor with a 'category' dtype"
+        with pytest.raises(AttributeError, match=msg):
+            Series([1, 2, 3]).cat
+        with pytest.raises(AttributeError, match=msg):
             Series([1, 2, 3]).cat()
-        pytest.raises(AttributeError, lambda: Series(['a', 'b', 'c']).cat)
-        pytest.raises(AttributeError, lambda: Series(np.arange(5.)).cat)
-        pytest.raises(AttributeError,
-                      lambda: Series([Timestamp('20130101')]).cat)
+        with pytest.raises(AttributeError, match=msg):
+            Series(['a', 'b', 'c']).cat
+        with pytest.raises(AttributeError, match=msg):
+            Series(np.arange(5.)).cat
+        with pytest.raises(AttributeError, match=msg):
+            Series([Timestamp('20130101')]).cat
 
         # Series should delegate calls to '.categories', '.codes', '.ordered'
         # and the methods '.set_categories()' 'drop_unused_categories()' to the
@@ -605,10 +611,10 @@ class TestCategoricalSeries(object):
 
         # This method is likely to be confused, so test that it raises an error
         # on wrong inputs:
-        def f():
+        msg = "'Series' object has no attribute 'set_categories'"
+        with pytest.raises(AttributeError, match=msg):
             s.set_categories([4, 3, 2, 1])
 
-        pytest.raises(Exception, f)
         # right: s.cat.set_categories([4,3,2,1])
 
         # GH18862 (let Series.cat.rename_categories take callables)
diff --git a/pandas/tests/series/test_combine_concat.py b/pandas/tests/series/test_combine_concat.py
index e13cb9edf..45e3dffde 100644
--- a/pandas/tests/series/test_combine_concat.py
+++ b/pandas/tests/series/test_combine_concat.py
@@ -25,8 +25,9 @@ class TestSeriesCombine(object):
             else:
                 raise AssertionError("orphaned index!")
 
-        pytest.raises(ValueError, datetime_series.append, datetime_series,
-                      verify_integrity=True)
+        msg = "Indexes have overlapping values:"
+        with pytest.raises(ValueError, match=msg):
+            datetime_series.append(datetime_series, verify_integrity=True)
 
     def test_append_many(self, datetime_series):
         pieces = [datetime_series[:5], datetime_series[5:10],
diff --git a/pandas/tests/series/test_constructors.py b/pandas/tests/series/test_constructors.py
index fa303c904..d92ca4875 100644
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -65,8 +65,10 @@ class TestSeriesConstructors():
 
         assert not empty_series.index.is_all_dates
         assert not Series({}).index.is_all_dates
-        pytest.raises(Exception, Series, np.random.randn(3, 3),
-                      index=np.arange(3))
+
+        # exception raised is of type Exception
+        with pytest.raises(Exception, match="Data must be 1-dimensional"):
+            Series(np.random.randn(3, 3), index=np.arange(3))
 
         mixed.name = 'Series'
         rs = Series(mixed).name
@@ -75,7 +77,9 @@ class TestSeriesConstructors():
 
         # raise on MultiIndex GH4187
         m = MultiIndex.from_arrays([[1, 2], [3, 4]])
-        pytest.raises(NotImplementedError, Series, m)
+        msg = "initializing a Series from a MultiIndex is not supported"
+        with pytest.raises(NotImplementedError, match=msg):
+            Series(m)
 
     @pytest.mark.parametrize('input_class', [list, dict, OrderedDict])
     def test_constructor_empty(self, input_class):
@@ -495,7 +499,9 @@ class TestSeriesConstructors():
         # GH 19342
         # construction with single-element container and index
         # should raise
-        pytest.raises(ValueError, Series, ['foo'], index=['a', 'b', 'c'])
+        msg = "Length of passed values is 1, index implies 3"
+        with pytest.raises(ValueError, match=msg):
+            Series(['foo'], index=['a', 'b', 'c'])
 
     def test_constructor_corner(self):
         df = tm.makeTimeDataFrame()
@@ -675,10 +681,17 @@ class TestSeriesConstructors():
         assert s.dtype == 'M8[ns]'
 
         # GH3414 related
+        # msg = (r"cannot astype a datetimelike from \[datetime64\[ns\]\] to"
+        #        r" \[int32\]")
+        # with pytest.raises(TypeError, match=msg):
+        #     Series(Series(dates).astype('int') / 1000000, dtype='M8[ms]')
         pytest.raises(TypeError, lambda x: Series(
             Series(dates).astype('int') / 1000000, dtype='M8[ms]'))
-        pytest.raises(TypeError,
-                      lambda x: Series(dates, dtype='datetime64'))
+
+        msg = (r"The 'datetime64' dtype has no unit\. Please pass in"
+               r" 'datetime64\[ns\]' instead\.")
+        with pytest.raises(ValueError, match=msg):
+            Series(dates, dtype='datetime64')
 
         # invalid dates can be help as object
         result = Series([datetime(2, 1, 1)])
@@ -984,9 +997,11 @@ class TestSeriesConstructors():
 
     def test_constructor_set(self):
         values = {1, 2, 3, 4, 5}
-        pytest.raises(TypeError, Series, values)
+        with pytest.raises(TypeError, match="'set' type is unordered"):
+            Series(values)
         values = frozenset(values)
-        pytest.raises(TypeError, Series, values)
+        with pytest.raises(TypeError, match="'frozenset' type is unordered"):
+            Series(values)
 
     # https://github.com/pandas-dev/pandas/issues/22698
     @pytest.mark.filterwarnings("ignore:elementwise comparison:FutureWarning")
@@ -1081,14 +1096,16 @@ class TestSeriesConstructors():
         td.astype('int64')
 
         # invalid casting
-        pytest.raises(TypeError, td.astype, 'int32')
+        msg = (r"cannot astype a timedelta from \[timedelta64\[ns\]\] to"
+               r" \[int32\]")
+        with pytest.raises(TypeError, match=msg):
+            td.astype('int32')
 
         # this is an invalid casting
-        def f():
+        msg = "Could not convert object to NumPy timedelta"
+        with pytest.raises(ValueError, match=msg):
             Series([timedelta(days=1), 'foo'], dtype='m8[ns]')
 
-        pytest.raises(Exception, f)
-
         # leave as object here
         td = Series([timedelta(days=i) for i in range(3)] + ['foo'])
         assert td.dtype == 'object'
@@ -1134,9 +1151,11 @@ class TestSeriesConstructors():
                 assert s.name == n
 
     def test_constructor_name_unhashable(self):
+        msg = r"Series\.name must be a hashable type"
         for n in [['name_list'], np.ones(2), {1: 2}]:
             for data in [['name_list'], np.ones(2), {1: 2}]:
-                pytest.raises(TypeError, Series, data, name=n)
+                with pytest.raises(TypeError, match=msg):
+                    Series(data, name=n)
 
     def test_auto_conversion(self):
         series = Series(list(date_range('1/1/2000', periods=10)))
diff --git a/pandas/tests/series/test_dtypes.py b/pandas/tests/series/test_dtypes.py
index 2bc009c5a..5ec3f69e5 100644
--- a/pandas/tests/series/test_dtypes.py
+++ b/pandas/tests/series/test_dtypes.py
@@ -74,7 +74,8 @@ class TestSeriesDtypes(object):
     @pytest.mark.parametrize("dtype", [int, np.int8, np.int64])
     def test_astype_cast_object_int_fail(self, dtype):
         arr = Series(["car", "house", "tree", "1"])
-        with pytest.raises(ValueError):
+        msg = r"invalid literal for (int|long)\(\) with base 10: 'car'"
+        with pytest.raises(ValueError, match=msg):
             arr.astype(dtype)
 
     def test_astype_cast_object_int(self):
@@ -213,17 +214,19 @@ class TestSeriesDtypes(object):
         tm.assert_series_equal(result, expected)
 
         dt3 = dtype_class({'abc': str, 'def': str})
-        with pytest.raises(KeyError):
+        msg = ("Only the Series name can be used for the key in Series dtype"
+               r" mappings\.")
+        with pytest.raises(KeyError, match=msg):
             s.astype(dt3)
 
         dt4 = dtype_class({0: str})
-        with pytest.raises(KeyError):
+        with pytest.raises(KeyError, match=msg):
             s.astype(dt4)
 
         # GH16717
         # if dtypes provided is empty, it should error
         dt5 = dtype_class({})
-        with pytest.raises(KeyError):
+        with pytest.raises(KeyError, match=msg):
             s.astype(dt5)
 
     def test_astype_categories_deprecation(self):
@@ -288,7 +291,10 @@ class TestSeriesDtypes(object):
         expected = s
         tm.assert_series_equal(s.astype('category'), expected)
         tm.assert_series_equal(s.astype(CategoricalDtype()), expected)
-        pytest.raises(ValueError, lambda: s.astype('float64'))
+        msg = (r"could not convert string to float: '(0 - 499|9500 - 9999)'|"
+               r"invalid literal for float\(\): 9500 - 9999")
+        with pytest.raises(ValueError, match=msg):
+            s.astype('float64')
 
         cat = Series(Categorical(['a', 'b', 'b', 'a', 'a', 'c', 'c', 'c']))
         exp = Series(['a', 'b', 'b', 'a', 'a', 'c', 'c', 'c'])
@@ -324,9 +330,12 @@ class TestSeriesDtypes(object):
             tm.assert_series_equal(result, s, check_categorical=False)
 
         # invalid conversion (these are NOT a dtype)
+        msg = (r"invalid type <class 'pandas\.core\.arrays\.categorical\."
+               "Categorical'> for astype")
         for invalid in [lambda x: x.astype(Categorical),
                         lambda x: x.astype('object').astype(Categorical)]:
-            pytest.raises(TypeError, lambda: invalid(s))
+            with pytest.raises(TypeError, match=msg):
+                invalid(s)
 
     @pytest.mark.parametrize('name', [None, 'foo'])
     @pytest.mark.parametrize('dtype_ordered', [True, False])
@@ -387,11 +396,14 @@ class TestSeriesDtypes(object):
         s = Series(['a', 'b'])
         type_ = CategoricalDtype(['a', 'b'])
 
-        with pytest.raises(TypeError):
+        msg = (r"Cannot specify a CategoricalDtype and also `categories` or"
+               r" `ordered`\. Use `dtype=CategoricalDtype\(categories,"
+               r" ordered\)` instead\.")
+        with pytest.raises(TypeError, match=msg):
             s.astype(type_, ordered=True)
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             s.astype(type_, categories=['a', 'b'])
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             s.astype(type_, categories=['a', 'b'], ordered=False)
 
     @pytest.mark.parametrize("dtype", [
@@ -435,7 +447,9 @@ class TestSeriesDtypes(object):
         # see gh-14878
         s = Series([1, 2, 3])
 
-        with pytest.raises(ValueError):
+        msg = (r"Expected value of kwarg 'errors' to be one of \['raise',"
+               r" 'ignore'\]\. Supplied value is 'False'")
+        with pytest.raises(ValueError, match=msg):
             s.astype(np.float64, errors=False)
 
         s.astype(np.int8, errors='raise')
diff --git a/pandas/tests/series/test_internals.py b/pandas/tests/series/test_internals.py
index 772617c49..26b868872 100644
--- a/pandas/tests/series/test_internals.py
+++ b/pandas/tests/series/test_internals.py
@@ -293,7 +293,9 @@ class TestSeriesInternals(object):
 
     def test_convert_no_arg_error(self):
         s = Series(['1.0', '2'])
-        pytest.raises(ValueError, s._convert)
+        msg = r"At least one of datetime, numeric or timedelta must be True\."
+        with pytest.raises(ValueError, match=msg):
+            s._convert()
 
     def test_convert_preserve_bool(self):
         s = Series([1, True, 3, 5], dtype=object)
diff --git a/pandas/tests/series/test_missing.py b/pandas/tests/series/test_missing.py
index f4f16ff2d..985288c43 100644
--- a/pandas/tests/series/test_missing.py
+++ b/pandas/tests/series/test_missing.py
@@ -360,14 +360,24 @@ class TestSeriesMissingData():
 
     def test_fillna_raise(self):
         s = Series(np.random.randint(-100, 100, 50))
-        pytest.raises(TypeError, s.fillna, [1, 2])
-        pytest.raises(TypeError, s.fillna, (1, 2))
+        msg = ('"value" parameter must be a scalar or dict, but you passed a'
+               ' "list"')
+        with pytest.raises(TypeError, match=msg):
+            s.fillna([1, 2])
+
+        msg = ('"value" parameter must be a scalar or dict, but you passed a'
+               ' "tuple"')
+        with pytest.raises(TypeError, match=msg):
+            s.fillna((1, 2))
 
         # related GH 9217, make sure limit is an int and greater than 0
         s = Series([1, 2, 3, None])
+        msg = (r"Cannot specify both 'value' and 'method'\.|"
+               r"Limit must be greater than 0|"
+               "Limit must be an integer")
         for limit in [-1, 0, 1., 2.]:
             for method in ['backfill', 'bfill', 'pad', 'ffill', None]:
-                with pytest.raises(ValueError):
+                with pytest.raises(ValueError, match=msg):
                     s.fillna(1, limit=limit, method=method)
 
     def test_categorical_nan_equality(self):
@@ -508,9 +518,13 @@ class TestSeriesMissingData():
         exp = Series([0., 1., 5., 3., 4.], index=ts.index)
         tm.assert_series_equal(ts.fillna(value=5), exp)
 
-        pytest.raises(ValueError, ts.fillna)
-        pytest.raises(ValueError, datetime_series.fillna, value=0,
-                      method='ffill')
+        msg = "Must specify a fill 'value' or 'method'"
+        with pytest.raises(ValueError, match=msg):
+            ts.fillna()
+
+        msg = "Cannot specify both 'value' and 'method'"
+        with pytest.raises(ValueError, match=msg):
+            datetime_series.fillna(value=0, method='ffill')
 
         # GH 5703
         s1 = Series([np.nan])
@@ -647,7 +661,9 @@ class TestSeriesMissingData():
         assert len(s) == 0
 
         # invalid axis
-        pytest.raises(ValueError, s.dropna, axis=1)
+        msg = r"No axis named 1 for object type <(class|type) 'type'>"
+        with pytest.raises(ValueError, match=msg):
+            s.dropna(axis=1)
 
     def test_datetime64_tz_dropna(self):
         # DatetimeBlock
@@ -736,7 +752,9 @@ class TestSeriesMissingData():
         # neither monotonic increasing or decreasing
         rng2 = rng[[1, 0, 2]]
 
-        pytest.raises(ValueError, rng2.get_indexer, rng, method='pad')
+        msg = "index must be monotonic increasing or decreasing"
+        with pytest.raises(ValueError, match=msg):
+            rng2.get_indexer(rng, method='pad')
 
     def test_dropna_preserve_name(self, datetime_series):
         datetime_series[:5] = np.nan
@@ -861,7 +879,10 @@ class TestSeriesInterpolateData():
         # Only raises ValueError if there are NaNs.
         non_ts = string_series.copy()
         non_ts[0] = np.NaN
-        pytest.raises(ValueError, non_ts.interpolate, method='time')
+        msg = ("time-weighted interpolation only works on Series or DataFrames"
+               " with a DatetimeIndex")
+        with pytest.raises(ValueError, match=msg):
+            non_ts.interpolate(method='time')
 
     @td.skip_if_no_scipy
     def test_interpolate_pchip(self):
@@ -956,7 +977,9 @@ class TestSeriesInterpolateData():
 
     def test_interpolate_non_ts(self):
         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
-        with pytest.raises(ValueError):
+        msg = ("time-weighted interpolation only works on Series or DataFrames"
+               " with a DatetimeIndex")
+        with pytest.raises(ValueError, match=msg):
             s.interpolate(method='time')
 
     @pytest.mark.parametrize("kwargs", [
@@ -1044,9 +1067,14 @@ class TestSeriesInterpolateData():
                    'polynomial', 'spline', 'piecewise_polynomial', None,
                    'from_derivatives', 'pchip', 'akima']
         s = pd.Series([1, 2, np.nan, np.nan, 5])
+        msg = (r"Limit must be greater than 0|"
+               "time-weighted interpolation only works on Series or"
+               r" DataFrames with a DatetimeIndex|"
+               r"invalid method '(polynomial|spline|None)' to interpolate|"
+               "Limit must be an integer")
         for limit in [-1, 0, 1., 2.]:
             for method in methods:
-                with pytest.raises(ValueError):
+                with pytest.raises(ValueError, match=msg):
                     s.interpolate(limit=limit, method=method)
 
     def test_interp_limit_forward(self):
@@ -1084,12 +1112,14 @@ class TestSeriesInterpolateData():
     def test_interp_limit_bad_direction(self):
         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
 
-        pytest.raises(ValueError, s.interpolate, method='linear', limit=2,
-                      limit_direction='abc')
+        msg = (r"Invalid limit_direction: expecting one of \['forward',"
+               r" 'backward', 'both'\], got 'abc'")
+        with pytest.raises(ValueError, match=msg):
+            s.interpolate(method='linear', limit=2, limit_direction='abc')
 
         # raises an error even if no limit is specified.
-        pytest.raises(ValueError, s.interpolate, method='linear',
-                      limit_direction='abc')
+        with pytest.raises(ValueError, match=msg):
+            s.interpolate(method='linear', limit_direction='abc')
 
     # limit_area introduced GH #16284
     def test_interp_limit_area(self):
@@ -1127,8 +1157,10 @@ class TestSeriesInterpolateData():
                                direction='backward')
 
         # raises an error even if limit type is wrong.
-        pytest.raises(ValueError, s.interpolate, method='linear',
-                      limit_area='abc')
+        msg = (r"Invalid limit_area: expecting one of \['inside', 'outside'\],"
+               " got abc")
+        with pytest.raises(ValueError, match=msg):
+            s.interpolate(method='linear', limit_area='abc')
 
     def test_interp_limit_direction(self):
         # These tests are for issue #9218 -- fill NaNs in both directions.
@@ -1214,14 +1246,16 @@ class TestSeriesInterpolateData():
         result = s.interpolate()
         assert_series_equal(result, expected)
 
+        msg = "Only `method=linear` interpolation is supported on MultiIndexes"
         if check_scipy:
-            with pytest.raises(ValueError):
+            with pytest.raises(ValueError, match=msg):
                 s.interpolate(method='polynomial', order=1)
 
     @td.skip_if_no_scipy
     def test_interp_nonmono_raise(self):
         s = Series([1, np.nan, 3], index=[0, 2, 1])
-        with pytest.raises(ValueError):
+        msg = "krogh interpolation requires that the index be monotonic"
+        with pytest.raises(ValueError, match=msg):
             s.interpolate(method='krogh')
 
     @td.skip_if_no_scipy
@@ -1243,7 +1277,8 @@ class TestSeriesInterpolateData():
     @pytest.mark.parametrize("method", ['polynomial', 'spline'])
     def test_no_order(self, method):
         s = Series([0, 1, np.nan, 3])
-        with pytest.raises(ValueError):
+        msg = "invalid method '{}' to interpolate".format(method)
+        with pytest.raises(ValueError, match=msg):
             s.interpolate(method=method)
 
     @td.skip_if_no_scipy
@@ -1283,10 +1318,12 @@ class TestSeriesInterpolateData():
         # see gh-10633
         s = pd.Series(np.arange(10) ** 2)
         s[np.random.randint(0, 9, 3)] = np.nan
-        with pytest.raises(ValueError):
+        msg = "invalid method 'spline' to interpolate"
+        with pytest.raises(ValueError, match=msg):
             s.interpolate(method='spline')
 
-        with pytest.raises(ValueError):
+        msg = "order needs to be specified and greater than 0"
+        with pytest.raises(ValueError, match=msg):
             s.interpolate(method='spline', order=0)
 
     def test_interp_timedelta64(self):
diff --git a/pandas/tests/series/test_rank.py b/pandas/tests/series/test_rank.py
index da414a577..510a51e00 100644
--- a/pandas/tests/series/test_rank.py
+++ b/pandas/tests/series/test_rank.py
@@ -206,7 +206,9 @@ class TestSeriesRank(TestData):
     def test_rank_signature(self):
         s = Series([0, 1])
         s.rank(method='average')
-        pytest.raises(ValueError, s.rank, 'average')
+        msg = r"No axis named average for object type <(class|type) 'type'>"
+        with pytest.raises(ValueError, match=msg):
+            s.rank('average')
 
     @pytest.mark.parametrize('contents,dtype', [
         ([-np.inf, -50, -1, -1e-20, -1e-25, -1e-50, 0, 1e-40, 1e-20, 1e-10,
diff --git a/pandas/tests/series/test_replace.py b/pandas/tests/series/test_replace.py
index 3a9c21001..40b280470 100644
--- a/pandas/tests/series/test_replace.py
+++ b/pandas/tests/series/test_replace.py
@@ -73,7 +73,9 @@ class TestSeriesReplace(TestData):
         tm.assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
 
         # malformed
-        pytest.raises(ValueError, ser.replace, [1, 2, 3], [np.nan, 0])
+        msg = r"Replacement lists must match in length\. Expecting 3 got 2"
+        with pytest.raises(ValueError, match=msg):
+            ser.replace([1, 2, 3], [np.nan, 0])
 
         # make sure that we aren't just masking a TypeError because bools don't
         # implement indexing
@@ -125,7 +127,9 @@ class TestSeriesReplace(TestData):
 
         # make sure things don't get corrupted when fillna call fails
         s = ser.copy()
-        with pytest.raises(ValueError):
+        msg = (r"Invalid fill method\. Expecting pad \(ffill\) or backfill"
+               r" \(bfill\)\. Got crash_cymbal")
+        with pytest.raises(ValueError, match=msg):
             s.replace([1, 2, 3], inplace=True, method='crash_cymbal')
         tm.assert_series_equal(s, ser)
 
diff --git a/pandas/tests/series/test_sorting.py b/pandas/tests/series/test_sorting.py
index ef6998c1a..216f84c8f 100644
--- a/pandas/tests/series/test_sorting.py
+++ b/pandas/tests/series/test_sorting.py
@@ -55,16 +55,21 @@ class TestSeriesSorting(TestData):
         expected = ts.sort_values(ascending=False, na_position='first')
         assert_series_equal(expected, ordered)
 
-        pytest.raises(ValueError,
-                      lambda: ts.sort_values(ascending=None))
-        pytest.raises(ValueError,
-                      lambda: ts.sort_values(ascending=[]))
-        pytest.raises(ValueError,
-                      lambda: ts.sort_values(ascending=[1, 2, 3]))
-        pytest.raises(ValueError,
-                      lambda: ts.sort_values(ascending=[False, False]))
-        pytest.raises(ValueError,
-                      lambda: ts.sort_values(ascending='foobar'))
+        msg = "ascending must be boolean"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending=None)
+        msg = r"Length of ascending \(0\) must be 1 for Series"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending=[])
+        msg = r"Length of ascending \(3\) must be 1 for Series"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending=[1, 2, 3])
+        msg = r"Length of ascending \(2\) must be 1 for Series"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending=[False, False])
+        msg = "ascending must be boolean"
+        with pytest.raises(ValueError, match=msg):
+            ts.sort_values(ascending='foobar')
 
         # inplace=True
         ts = self.ts.copy()
@@ -78,11 +83,11 @@ class TestSeriesSorting(TestData):
         df = DataFrame(np.random.randn(10, 4))
         s = df.iloc[:, 0]
 
-        def f():
+        msg = ("This Series is a view of some other array, to sort in-place"
+               " you must create a copy")
+        with pytest.raises(ValueError, match=msg):
             s.sort_values(inplace=True)
 
-        pytest.raises(ValueError, f)
-
     def test_sort_index(self):
         rindex = list(self.ts.index)
         random.shuffle(rindex)
@@ -104,13 +109,15 @@ class TestSeriesSorting(TestData):
         sorted_series = random_order.sort_index(axis=0)
         assert_series_equal(sorted_series, self.ts)
 
-        pytest.raises(ValueError, lambda: random_order.sort_values(axis=1))
+        msg = r"No axis named 1 for object type <(class|type) 'type'>"
+        with pytest.raises(ValueError, match=msg):
+            random_order.sort_values(axis=1)
 
         sorted_series = random_order.sort_index(level=0, axis=0)
         assert_series_equal(sorted_series, self.ts)
 
-        pytest.raises(ValueError,
-                      lambda: random_order.sort_index(level=0, axis=1))
+        with pytest.raises(ValueError, match=msg):
+            random_order.sort_index(level=0, axis=1)
 
     def test_sort_index_inplace(self):
 
diff --git a/pandas/tests/series/test_timeseries.py b/pandas/tests/series/test_timeseries.py
index 07808008c..d082b023e 100644
--- a/pandas/tests/series/test_timeseries.py
+++ b/pandas/tests/series/test_timeseries.py
@@ -7,6 +7,7 @@ import numpy as np
 import pytest
 
 from pandas._libs.tslib import iNaT
+from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
 from pandas.compat import StringIO, lrange, product
 from pandas.errors import NullFrequencyError
 import pandas.util._test_decorators as td
@@ -78,7 +79,8 @@ class TestTimeSeries(TestData):
         assert_series_equal(shifted2, shifted3)
         assert_series_equal(ps, shifted2.shift(-1, 'B'))
 
-        with pytest.raises(ValueError):
+        msg = "Given freq D does not match PeriodIndex freq B"
+        with pytest.raises(ValueError, match=msg):
             ps.shift(freq='D')
 
         # legacy support
@@ -110,7 +112,9 @@ class TestTimeSeries(TestData):
         # incompat tz
         s2 = Series(date_range('2000-01-01 09:00:00', periods=5,
                                tz='CET'), name='foo')
-        with pytest.raises(TypeError):
+        msg = ("DatetimeArray subtraction must have the same timezones or no"
+               " timezones")
+        with pytest.raises(TypeError, match=msg):
             s - s2
 
     def test_shift2(self):
@@ -127,7 +131,9 @@ class TestTimeSeries(TestData):
         tm.assert_index_equal(result.index, exp_index)
 
         idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-04'])
-        pytest.raises(NullFrequencyError, idx.shift, 1)
+        msg = "Cannot shift with no freq"
+        with pytest.raises(NullFrequencyError, match=msg):
+            idx.shift(1)
 
     def test_shift_fill_value(self):
         # GH #24128
@@ -158,7 +164,8 @@ class TestTimeSeries(TestData):
         tm.assert_equal(res, expected)
 
         # check for incorrect fill_value
-        with pytest.raises(ValueError):
+        msg = "'fill_value=f' is not present in this Categorical's categories"
+        with pytest.raises(ValueError, match=msg):
             ts.shift(1, fill_value='f')
 
     def test_shift_dst(self):
@@ -202,7 +209,8 @@ class TestTimeSeries(TestData):
         shifted3 = ps.tshift(freq=BDay())
         assert_series_equal(shifted, shifted3)
 
-        with pytest.raises(ValueError):
+        msg = "Given freq M does not match PeriodIndex freq B"
+        with pytest.raises(ValueError, match=msg):
             ps.tshift(freq='M')
 
         # DatetimeIndex
@@ -222,7 +230,8 @@ class TestTimeSeries(TestData):
         assert_series_equal(unshifted, inferred_ts)
 
         no_freq = self.ts[[0, 5, 7]]
-        with pytest.raises(ValueError):
+        msg = "Freq was not given and was not set in the index"
+        with pytest.raises(ValueError, match=msg):
             no_freq.tshift()
 
     def test_truncate(self):
@@ -271,9 +280,10 @@ class TestTimeSeries(TestData):
         truncated = ts.truncate(before=self.ts.index[-1] + offset)
         assert (len(truncated) == 0)
 
-        pytest.raises(ValueError, ts.truncate,
-                      before=self.ts.index[-1] + offset,
-                      after=self.ts.index[0] - offset)
+        msg = "Truncate: 1999-12-31 00:00:00 must be after 2000-02-14 00:00:00"
+        with pytest.raises(ValueError, match=msg):
+            ts.truncate(before=self.ts.index[-1] + offset,
+                        after=self.ts.index[0] - offset)
 
     def test_truncate_nonsortedindex(self):
         # GH 17935
@@ -553,9 +563,11 @@ class TestTimeSeries(TestData):
                                   Timestamp('1970-01-03')] + ['NaT'] * 3)
         tm.assert_index_equal(result, expected)
 
-        with pytest.raises(ValueError):
+        msg = "non convertible value foo with the unit 'D'"
+        with pytest.raises(ValueError, match=msg):
             to_datetime([1, 2, 'foo'], unit='D')
-        with pytest.raises(ValueError):
+        msg = "cannot convert input 111111111 with the unit 'D'"
+        with pytest.raises(OutOfBoundsDatetime, match=msg):
             to_datetime([1, 2, 111111111], unit='D')
 
         # coerce we can process
@@ -660,7 +672,8 @@ class TestTimeSeries(TestData):
     def test_first_raises(self):
         # GH20725
         ser = pd.Series('a b c'.split())
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "'first' only supports a DatetimeIndex index"
+        with pytest.raises(TypeError, match=msg):
             ser.first('1D')
 
     def test_last_subset(self):
@@ -686,7 +699,8 @@ class TestTimeSeries(TestData):
     def test_last_raises(self):
         # GH20725
         ser = pd.Series('a b c'.split())
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "'last' only supports a DatetimeIndex index"
+        with pytest.raises(TypeError, match=msg):
             ser.last('1D')
 
     def test_format_pre_1900_dates(self):
@@ -740,7 +754,8 @@ class TestTimeSeries(TestData):
     def test_at_time_raises(self):
         # GH20725
         ser = pd.Series('a b c'.split())
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):
             ser.at_time('00:00')
 
     def test_between(self):
@@ -814,23 +829,26 @@ class TestTimeSeries(TestData):
     def test_between_time_raises(self):
         # GH20725
         ser = pd.Series('a b c'.split())
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):
             ser.between_time(start_time='00:00', end_time='12:00')
 
     def test_between_time_types(self):
         # GH11818
         rng = date_range('1/1/2000', '1/5/2000', freq='5min')
-        with pytest.raises(ValueError):
+        msg = (r"Cannot convert arg \[datetime\.datetime\(2010, 1, 2, 1, 0\)\]"
+               " to a time")
+        with pytest.raises(ValueError, match=msg):
             rng.indexer_between_time(datetime(2010, 1, 2, 1),
                                      datetime(2010, 1, 2, 5))
 
         frame = DataFrame({'A': 0}, index=rng)
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg):
             frame.between_time(datetime(2010, 1, 2, 1),
                                datetime(2010, 1, 2, 5))
 
         series = Series(0, index=rng)
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg):
             series.between_time(datetime(2010, 1, 2, 1),
                                 datetime(2010, 1, 2, 5))
 
@@ -858,7 +876,9 @@ class TestTimeSeries(TestData):
 
         assert len(ts.between_time(stime, etime)) == expected_length
         assert len(ts.between_time(stime, etime, axis=0)) == expected_length
-        pytest.raises(ValueError, ts.between_time, stime, etime, axis=1)
+        msg = r"No axis named 1 for object type <(class|type) 'type'>"
+        with pytest.raises(ValueError, match=msg):
+            ts.between_time(stime, etime, axis=1)
 
     def test_to_period(self):
         from pandas.core.indexes.period import period_range

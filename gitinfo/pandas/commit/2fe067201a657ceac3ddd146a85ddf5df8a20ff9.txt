commit 2fe067201a657ceac3ddd146a85ddf5df8a20ff9
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Dec 2 04:42:18 2009 +0000

    test suite in broken state for now
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@61 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/__init__.py b/pandas/__init__.py
index 024bcc144..a062faffd 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -18,7 +18,7 @@ DataFrame / DataMatrix
 
 DateRange
     Index subclass for generating arrays of fixed frequency dates
-    
+
 Subpackages
 -----------
 core
@@ -29,8 +29,11 @@ io
 lib
     C, Cython, and Fortran extensions for other components
 stats
-    Standard 
+    Statistical and econometric functions
 """
 
+# pylint: disable-msg=W0614,W0401,W0611
+
 from pandas.core.api import *
 from pandas.io.parsers import parseCSV, parseText, parseExcel
+from pandas.stats.api import *
diff --git a/pandas/core/api.py b/pandas/core/api.py
index f0717d3c2..d4860de0c 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -1,3 +1,5 @@
+# pylint: disable-msg=W0614,W0401,W0611
+
 import numpy as np
 
 from pandas.core.daterange import DateRange
@@ -5,6 +7,7 @@ from pandas.core.datetools import DateOffset
 from pandas.core.frame import DataFrame
 from pandas.core.index import Index
 from pandas.core.matrix import DataMatrix
+from pandas.core.panel import WidePanel, LongPanel
 from pandas.core.series import Series, TimeSeries
 
 import pandas.core.datetools as datetools
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index d9704e68a..db6b71e3b 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1395,17 +1395,6 @@ def _makePrefixedLongPanel(values, items, index, prefix):
 
     return LongPanel(values, items, index)
 
-def _convert(data, order, factors=None):
-    """
-
-    Parameters
-    ----------
-
-    Returns
-    -------
-
-    """
-
 def _homogenize(frames, intersect=True):
     """
     Conform set of DataFrame-like objects to either an intersection
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 33b08a6f4..daf2c89e6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -73,13 +73,6 @@ def _seriesOpWrap(opname, comp=False):
 class Series(np.ndarray, Picklable, Groupable):
     """Generic indexed series (time series or otherwise) object.
 
-    Parameters
-    ----------
-    data:  array-like
-        Underlying values of Series, preferably as numpy ndarray
-    index: array-like, optional
-        Index object (or other iterable of same length as data)
-
     Contains values in a numpy-ndarray with an optional bound index
     (also an array of dates, strings, or whatever you want the 'row
     names' of your series to be)
@@ -93,13 +86,23 @@ class Series(np.ndarray, Picklable, Groupable):
     underlying ndarray. In other words, there is no 'matching' or
     'aligning' to do, it's all taken care of for you.
 
-    NOTE: If you combine two series, all values for an index position
-    must be present or the value for that index position will be
-    nan. The new index is the sorted union of the two Series indices.
+    Note
+    ----
+    If you combine two series, all values for an index position must
+    be present or the value for that index position will be nan. The
+    new index is the sorted union of the two Series indices.
 
     ALSO NOTE: There is currently no restriction on what can be in the
     index.
 
+    Parameters
+    ----------
+    data:  array-like
+        Underlying values of Series, preferably as numpy ndarray
+    index: array-like, optional
+        Index object (or other iterable of same length as data)
+
+
     Example usage:
         >>> s = Series(arr, index=Index(dates))
         >>> t = Series(otherArr, index=Index(otherDates))
@@ -878,6 +881,10 @@ class Series(np.ndarray, Picklable, Groupable):
             return self.__class__(self, index=newIndex)
 
     def slice(self, before, after):
+        """
+
+        """
+
         import bisect
 
         if before is not None:
@@ -910,17 +917,25 @@ class Series(np.ndarray, Picklable, Groupable):
         requested date.
 
         If there is no good value, NaN is returned.
+
+        Returns
+        -------
+        value or NaN
         """
         if isinstance(date, basestring):
             date = datetools.to_datetime(date)
+
         v = self.get(date)
+
         if isnull(v):
             candidates = self.index[notnull(self)]
             candidates = candidates[candidates <= date]
+
             if any(candidates):
                 asOfDate = max(candidates)
             else:
                 return NaN
+
             return self.get(asOfDate)
         else:
             return v
diff --git a/pandas/core/tests/test_dataframe.py b/pandas/core/tests/test_dataframe.py
index 65cb967cc..ee81be223 100644
--- a/pandas/core/tests/test_dataframe.py
+++ b/pandas/core/tests/test_dataframe.py
@@ -1,24 +1,14 @@
-from pandas.core.daterange import DateRange
+from pandas.core.api import DateRange, DataFrame, Index, Series
 from pandas.core.datetools import bday
-from pandas.core.frame import DataFrame
-from pandas.core.index import Index
-from pandas.core.series import Series
 from copy import deepcopy
 from datetime import datetime
-from numpy import isnan, array
+
 from numpy import random
-from random import choice
 import numpy as np
+
 import string
 import unittest
 
-def rands(n):
-    return ''.join([choice(string.letters + string.digits) for i in range(n)])
-def equalContents(arr1, arr2):
-    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
-    """
-    return frozenset(arr1) == frozenset(arr2)
-
 #-------------------------------------------------------------------------------
 # DataFrame test cases
 
@@ -43,12 +33,12 @@ class TestDataFrame(unittest.TestCase):
         for col in newFrame.cols():
             for idx, val in newFrame[col].iteritems():
                 if idx in self.frame.index:
-                    if isnan(val):
-                        self.assert_(isnan(self.frame[col][idx]))
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
                     else:
                         self.assertEqual(val, self.frame[col][idx])
                 else:
-                    self.assert_(isnan(val))
+                    self.assert_(np.isnan(val))
         for col, series in newFrame.iteritems():
             self.assert_(equalContents(series.index, newFrame.index))
         emptyFrame = self.frame.reindex(Index([]))
@@ -58,12 +48,12 @@ class TestDataFrame(unittest.TestCase):
         for col in nonContigFrame.cols():
             for idx, val in nonContigFrame[col].iteritems():
                 if idx in self.frame.index:
-                    if isnan(val):
-                        self.assert_(isnan(self.frame[col][idx]))
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
                     else:
                         self.assertEqual(val, self.frame[col][idx])
                 else:
-                    self.assert_(isnan(val))
+                    self.assert_(np.isnan(val))
         for col, series in nonContigFrame.iteritems():
             self.assert_(equalContents(series.index, nonContigFrame.index))
 
@@ -77,23 +67,23 @@ class TestDataFrame(unittest.TestCase):
 
     def testOperators(self):
         garbage = random.random(4)
-        colSeries = Series(garbage, index=array(self.frame.cols()))
+        colSeries = Series(garbage, index=np.array(self.frame.cols()))
         idSum = self.frame + self.frame
         seriesSum = self.frame + colSeries
         for col, series in idSum.iteritems():
             for idx, val in series.iteritems():
                 origVal = self.frame[col][idx] * 2
-                if not isnan(val):
+                if not np.isnan(val):
                     self.assertEqual(val, origVal)
                 else:
-                    self.assert_(isnan(origVal))
+                    self.assert_(np.isnan(origVal))
         for col, series in seriesSum.iteritems():
             for idx, val in series.iteritems():
                 origVal = self.frame[col][idx] + colSeries[col]
-                if not isnan(val):
+                if not np.isnan(val):
                     self.assertEqual(val, origVal)
                 else:
-                    self.assert_(isnan(origVal))
+                    self.assert_(np.isnan(origVal))
 
     def testSlice(self):
         """Slicing NOT intended for production code"""
@@ -128,8 +118,8 @@ class TestDataFrame(unittest.TestCase):
         idx = self.frame.index[5]
         xs = self.frame.getXS(idx)
         for item, value in xs.iteritems():
-            if isnan(value):
-                self.assert_(isnan(self.frame[item][idx]))
+            if np.isnan(value):
+                self.assert_(np.isnan(self.frame[item][idx]))
             else:
                 self.assertEqual(value, self.frame[item][idx])
 
@@ -142,8 +132,8 @@ class TestDataFrame(unittest.TestCase):
                 self.assertEqual(idx, series.index[i])
         for col, series in frame.iteritems():
             for idx, value in series.iteritems():
-                if isnan(value):
-                    self.assert_(isnan(frame[col][idx]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][idx]))
                 else:
                     self.assertEqual(value, frame[col][idx])
 
@@ -152,8 +142,8 @@ class TestDataFrame(unittest.TestCase):
         dft = frame.T
         for idx, series in dft.iteritems():
             for col, value in series.iteritems():
-                if isnan(value):
-                    self.assert_(isnan(frame[col][idx]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][idx]))
                 else:
                     self.assertEqual(value, frame[col][idx])
 
@@ -166,8 +156,8 @@ class TestDataFrame(unittest.TestCase):
         for i, row in enumerate(mat):
             for j, value in enumerate(row):
                 col = frameCols[j]
-                if isnan(value):
-                    self.assert_(isnan(frame[col][i]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][i]))
                 else:
                     self.assertEqual(value, frame[col][i])
 
@@ -191,21 +181,6 @@ class TestDataFrame(unittest.TestCase):
     def testSort(self):
         pass
 
-    def testToCSV(self):
-        pass
-
-    def testPickle(self):
-        pass
-
-    def testToDictList(self):
-        pass
-
-    def testDictToDataFrame(self):
-        pass
-
-    def testDataFrameToDict(self):
-        pass
-
     def testFromDict(self):
         newFrame = DataFrame.fromDict(col1=self.ts1, col2 = self.ts2)
         for idx in newFrame.index:
@@ -214,12 +189,5 @@ class TestDataFrame(unittest.TestCase):
             if idx in self.ts2.index:
                 self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
 
-
-    def testPreserveReferences(self):
-        pass
-
-    def testCleanNaN(self):
-        pass
-
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_datamatrix.py b/pandas/core/tests/test_datamatrix.py
index 0b5625f4f..dc6bbb1b1 100644
--- a/pandas/core/tests/test_datamatrix.py
+++ b/pandas/core/tests/test_datamatrix.py
@@ -1,25 +1,13 @@
-from pandas.core.daterange import DateRange
-from pandas.core.datetools import bday
-from pandas.core.index import Index, NULL_INDEX
-from pandas.core.matrix import DataMatrix
-from pandas.core.series import Series
-from pandas.lib.tseries import map_indices
 from copy import deepcopy
 from datetime import datetime
-from numpy import isnan, array, NaN, alltrue
-from numpy import random
-from random import choice
-import numpy as np
-import pickle
-import string
 import unittest
 
-def rands(n):
-    return ''.join([choice(string.letters + string.digits) for i in range(n)])
-def equalContents(arr1, arr2):
-    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
-    """
-    return frozenset(arr1) == frozenset(arr2)
+from numpy.random import randn
+import numpy as np
+
+from pandas.core.api import Index, NULL_INDEX, DataMatrix, Series, DateRange
+from pandas.core.datetools import bday
+import pandas.core.tests.common as common
 
 #-------------------------------------------------------------------------------
 # DataMatrix test cases
@@ -29,10 +17,10 @@ class TestDataMatrix(unittest.TestCase):
         index1 = DateRange(datetime(2008,4,22), periods=50)
         index2 = DateRange(datetime(2008,4,29), periods=50)
         index3 = DateRange(datetime(2008,4,28), periods=50)
-        ts1 = Series(random.random(50), index=index1)
-        ts2 = Series(random.random(50), index=index2)
-        ts3 = Series(random.random(50), index=index3)
-        ts4 = Series(random.random(50), index=index1)
+        ts1 = Series(randn(50), index=index1)
+        ts2 = Series(randn(50), index=index2)
+        ts3 = Series(randn(50), index=index3)
+        ts4 = Series(randn(50), index=index1)
         data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
         self.frame = DataMatrix(data=data, index=index3)
         self.ts1 = ts1
@@ -45,14 +33,14 @@ class TestDataMatrix(unittest.TestCase):
         for col in newFrame.cols():
             for idx, val in newFrame[col].iteritems():
                 if idx in self.frame.index:
-                    if isnan(val):
-                        self.assert_(isnan(self.frame[col][idx]))
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
                     else:
                         self.assertEqual(val, self.frame[col][idx])
                 else:
-                    self.assert_(isnan(val))
+                    self.assert_(np.isnan(val))
         for col, series in newFrame.iteritems():
-            self.assert_(equalContents(series.index, newFrame.index))
+            self.assert_(common.equalContents(series.index, newFrame.index))
         emptyFrame = self.frame.reindex(Index([]))
         self.assert_(len(emptyFrame.index) == 0)
 
@@ -60,14 +48,14 @@ class TestDataMatrix(unittest.TestCase):
         for col in nonContigFrame.cols():
             for idx, val in nonContigFrame[col].iteritems():
                 if idx in self.frame.index:
-                    if isnan(val):
-                        self.assert_(isnan(self.frame[col][idx]))
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
                     else:
                         self.assertEqual(val, self.frame[col][idx])
                 else:
-                    self.assert_(isnan(val))
+                    self.assert_(np.isnan(val))
         for col, series in nonContigFrame.iteritems():
-            self.assert_(equalContents(series.index, nonContigFrame.index))
+            self.assert_(common.equalContents(series.index, nonContigFrame.index))
 
     def testShift(self):
         shiftedFrame = self.frame.shift(5)
@@ -78,24 +66,24 @@ class TestDataMatrix(unittest.TestCase):
             self.assert_(idx-5*bday == self.frame.index[i])
 
     def testOperators(self):
-        garbage = random.random(4)
-        colSeries = Series(garbage, index=array(self.frame.cols()))
+        garbage = randn(4)
+        colSeries = Series(garbage, index=np.array(self.frame.cols()))
         idSum = self.frame + self.frame
         seriesSum = self.frame + colSeries
         for col, series in idSum.iteritems():
             for idx, val in series.iteritems():
                 origVal = self.frame[col][idx] * 2
-                if not isnan(val):
+                if not np.isnan(val):
                     self.assertEqual(val, origVal)
                 else:
-                    self.assert_(isnan(origVal))
+                    self.assert_(np.isnan(origVal))
         for col, series in seriesSum.iteritems():
             for idx, val in series.iteritems():
                 origVal = self.frame[col][idx] + colSeries[col]
-                if not isnan(val):
+                if not np.isnan(val):
                     self.assertEqual(val, origVal)
                 else:
-                    self.assert_(isnan(origVal))
+                    self.assert_(np.isnan(origVal))
 
     def testSlice(self):
         """Slicing NOT intended for production code"""
@@ -103,7 +91,7 @@ class TestDataMatrix(unittest.TestCase):
         self.assertEqual(20, len(slice.index))
         for col, series in slice.iteritems():
             self.assertEqual(20, len(series.index))
-            self.assert_(equalContents(series.index, slice.index))
+            self.assert_(common.equalContents(series.index, slice.index))
 
     def testGetItem(self):
         for key, value in self.frame._series.iteritems():
@@ -120,7 +108,7 @@ class TestDataMatrix(unittest.TestCase):
         sumFrame = self.frame.apply(np.sum)
         for col, series in self.frame.iteritems():
             val = sumFrame[col]
-            if isnan(val):
+            if np.isnan(val):
                 print self.frame[col]
             self.assertEqual(val, series.sum())
 
@@ -133,8 +121,8 @@ class TestDataMatrix(unittest.TestCase):
         idx = self.frame.index[5]
         xs = self.frame.getXS(idx)
         for item, value in xs.iteritems():
-            if isnan(value):
-                self.assert_(isnan(self.frame[item][idx]))
+            if np.isnan(value):
+                self.assert_(np.isnan(self.frame[item][idx]))
             else:
                 self.assertEqual(value, self.frame[item][idx])
 
@@ -147,8 +135,8 @@ class TestDataMatrix(unittest.TestCase):
                 self.assertEqual(idx, series.index[i])
         for col, series in frame.iteritems():
             for idx, value in series.iteritems():
-                if isnan(value):
-                    self.assert_(isnan(frame[col][idx]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][idx]))
                 else:
                     self.assertEqual(value, frame[col][idx])
 
@@ -157,8 +145,8 @@ class TestDataMatrix(unittest.TestCase):
         dft = frame.T
         for idx, series in dft.iteritems():
             for col, value in series.iteritems():
-                if isnan(value):
-                    self.assert_(isnan(frame[col][idx]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][idx]))
                 else:
                     self.assertEqual(value, frame[col][idx])
 
@@ -171,8 +159,8 @@ class TestDataMatrix(unittest.TestCase):
         for i, row in enumerate(mat):
             for j, value in enumerate(row):
                 col = frameCols[j]
-                if isnan(value):
-                    self.assert_(isnan(frame[col][i]))
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][i]))
                 else:
                     self.assertEqual(value, frame[col][i])
 
@@ -183,6 +171,14 @@ class TestDataMatrix(unittest.TestCase):
         for idx, value in series.iteritems():
             self.assertNotEqual(self.frame['col1'][idx], value)
 
+    def testFromDict(self):
+        newFrame = DataMatrix.fromDict(col1=self.ts1, col2 = self.ts2)
+        for idx in newFrame.index:
+            if idx in self.ts1.index:
+                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
+            if idx in self.ts2.index:
+                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
+
     def testFilterItems(self):
         pass
 
@@ -199,32 +195,5 @@ class TestDataMatrix(unittest.TestCase):
     def testToCSV(self):
         pass
 
-    def testPickle(self):
-        pass
-
-    def testToDictList(self):
-        pass
-
-    def testDictToDataFrame(self):
-        pass
-
-    def testDataFrameToDict(self):
-        pass
-
-    def testFromDict(self):
-        newFrame = DataMatrix.fromDict(col1=self.ts1, col2 = self.ts2)
-        for idx in newFrame.index:
-            if idx in self.ts1.index:
-                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
-            if idx in self.ts2.index:
-                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
-
-
-    def testPreserveReferences(self):
-        pass
-
-    def testCleanNaN(self):
-        pass
-
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_index.py b/pandas/core/tests/test_index.py
index 406e1edeb..f1ea91e5f 100644
--- a/pandas/core/tests/test_index.py
+++ b/pandas/core/tests/test_index.py
@@ -1,47 +1,29 @@
-from pandas.core.daterange import DateRange
-from pandas.core.datetools import bday
 from pandas.core.index import Index
-from pandas.core.series import Series
-from pandas.lib.tseries import map_indices
-from copy import deepcopy
-from datetime import datetime
-from numpy import isnan, array, NaN, alltrue
-from numpy import random
-from random import choice
+import pandas.core.tests.common as common
+import pandas.lib.tseries as tseries
 import numpy as np
 import os
 import pickle
-import string
-import sys
 import unittest
 
-def rands(n):
-    return ''.join([choice(string.letters + string.digits) for i in range(n)])
-def equalContents(arr1, arr2):
-    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
-    """
-    return frozenset(arr1) == frozenset(arr2)
-
 class TestIndex(unittest.TestCase):
     def setUp(self):
-        self.strIndex = Index([rands(10) for i in range(50)])
-        self.dateIndex = DateRange(datetime(2008,4,22), periods=50, offset=bday)
-        self.intIndex = Index(np.arange(50))
-        
+        self.strIndex = common.makeStringIndex(100)
+        self.dateIndex = common.makeStringIndex(100)
+        self.intIndex = common.makeIntIndex(100)
+
     def testSlice(self):
         strSlice = self.strIndex[10:20]
         dateSlice = self.dateIndex[10:20]
         intSlice = self.intIndex[10:20]
-        strMap = map_indices(array(strSlice))
-        dateMap = map_indices(array(dateSlice))
-        intMap = map_indices(array(intSlice))
-        for key, value in strMap.iteritems():
-            self.assert_(strSlice.indexMap[key] == value)
-        for key, value in dateMap.iteritems():
-            self.assert_(dateSlice.indexMap[key] == value)        
-        for key, value in intMap.iteritems():
-            self.assert_(intSlice.indexMap[key] == value)        
-    
+        strMap = tseries.map_indices(np.array(strSlice))
+        dateMap = tseries.map_indices(np.array(dateSlice))
+        intMap = tseries.map_indices(np.array(intSlice))
+
+        common.assert_dict_equal(strSlice.indexMap, strMap)
+        common.assert_dict_equal(dateSlice.indexMap, dateMap)
+        common.assert_dict_equal(intSlice.indexMap, intMap)
+
     def testGetItem(self):
         sl = self.strIndex[[1,2,3]]
         for i in sl:
@@ -49,21 +31,21 @@ class TestIndex(unittest.TestCase):
         boolIdx = np.repeat(True, len(self.strIndex)).astype(bool)
         boolIdx[5:30:2] = False
         subIndex = self.strIndex[boolIdx]
-        strMap = map_indices(subIndex)
+        strMap = tseries.map_indices(subIndex)
         for key, value in strMap.iteritems():
             self.assert_(subIndex.indexMap[key] == value)
-        
+
     def testAdd(self):
         firstCat = self.strIndex + self.dateIndex
         secondCat = self.strIndex + self.strIndex
-        self.assert_(equalContents(np.append(self.strIndex, self.dateIndex), firstCat))
-        self.assert_(equalContents(secondCat, self.strIndex))
+        self.assert_(common.equalContents(np.append(self.strIndex, self.dateIndex), firstCat))
+        self.assert_(common.equalContents(secondCat, self.strIndex))
         for key in self.strIndex:
             self.assert_(key in firstCat.indexMap)
             self.assert_(key in secondCat.indexMap)
         for key in self.dateIndex:
             self.assert_(key in firstCat.indexMap)
-            
+
     def testContains(self):
         self.assert_(self.strIndex[10] in self.strIndex)
         self.assert_(self.dateIndex[10] in self.dateIndex)
@@ -74,11 +56,11 @@ class TestIndex(unittest.TestCase):
         self.assert_(self.strIndex[9] not in strSlice)
         self.assert_(self.dateIndex[9] not in dateSlice)
         self.assert_(self.intIndex[9] not in intSlice)
-    
+
     def testMutability(self):
         self.assertRaises(Exception, self.strIndex.__setitem__, 5, 0)
         self.assertRaises(Exception, self.strIndex.__setitem__, slice(1,5), 0)
-    
+
     def testPickle(self):
         f = open('tmp', 'wb')
         pickle.dump(self.strIndex, f)
@@ -88,7 +70,7 @@ class TestIndex(unittest.TestCase):
         f.close()
         os.remove('tmp')
         self.assert_(isinstance(unPickled, Index))
-        self.assert_(equalContents(unPickled, self.strIndex))
+        self.assert_(common.equalContents(unPickled, self.strIndex))
         for k, v in self.strIndex.indexMap.iteritems():
             self.assert_(k in unPickled.indexMap)
             self.assertEqual(unPickled.indexMap[k], v)
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 891613157..85e6e6471 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -1,26 +1,8 @@
-from pandas.core.daterange import DateRange
-from pandas.core.datetools import bday
-from pandas.core.index import Index
-from pandas.core.series import Series
-from pandas.lib.tseries import map_indices
-from copy import deepcopy
-from datetime import datetime
-from numpy import isnan, array, NaN, alltrue
-from numpy import random
-from random import choice
-import numpy as np
-import os
-import pickle
-import string
-import sys
 import unittest
 
-def rands(n):
-    return ''.join([choice(string.letters + string.digits) for i in range(n)])
-def equalContents(arr1, arr2):
-    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
-    """
-    return frozenset(arr1) == frozenset(arr2)
+import numpy as np
+
+import pandas.core.tests.common as common
 
 #-------------------------------------------------------------------------------
 # Series test cases
@@ -32,8 +14,7 @@ class TestSeries(unittest.TestCase):
         self.ts = Series(random.random(50), index=dateIndex)
         self.series = Series(random.random(50), index=index)
         self.objSeries = Series(dateIndex, index=index)
-        #self.plainSeries = Series(random.random(50))
-    
+
     def testSlice(self):
         numSlice = self.series[10:20]
         numSliceEnd = self.series[-10:]
@@ -43,31 +24,31 @@ class TestSeries(unittest.TestCase):
         self.assertEqual(len(numSlice), len(numSlice.index))
         self.assertEqual(self.series[numSlice.index[0]], numSlice[numSlice.index[0]])
         self.assertEqual(numSlice.index[1], self.series.index[11])
-        self.assert_(equalContents(numSliceEnd, array(self.series)[-10:]))
-    
+        self.assert_(common.equalContents(numSliceEnd, array(self.series)[-10:]))
+
     def testGet(self):
         self.assertEqual(self.series[5], self.series.get(self.series.index[5]))
-    
+
     def testGetItem(self):
         idx1 = self.series.index[5]
         idx2 = self.objSeries.index[5]
         self.assertEqual(self.series[idx1], self.series.get(idx1))
         self.assertEqual(self.objSeries[idx2], self.objSeries.get(idx2))
-    
+
     def testSetItem(self):
         self.ts[self.ts.index[5]] = NaN
         self.ts[[1,2,27]] = NaN
         self.ts[6] = NaN
-        self.assert_(isnan(self.ts[6]))
-        self.assert_(isnan(self.ts[2]))
-        self.ts[isnan(self.ts)] = 5
-        self.assert_(not isnan(self.ts[2]))
-        
+        self.assert_(np.isnan(self.ts[6]))
+        self.assert_(np.isnan(self.ts[2]))
+        self.ts[np.isnan(self.ts)] = 5
+        self.assert_(not np.isnan(self.ts[2]))
+
     def testSetSlice(self):
         slice = self.ts[5:20]
         self.assertEqual(len(slice), len(slice.index))
         self.assertEqual(len(slice.index.indexMap), len(slice.index))
-        
+
     def testGetSequence(self):
         slice1 = self.series[[1,2,3]]
         slice2 = self.objSeries[[1,2,3]]
@@ -76,77 +57,52 @@ class TestSeries(unittest.TestCase):
         self.assertEqual(self.series[2], slice1[1])
         self.assertEqual(self.objSeries[2], slice2[1])
 
-        #slice3 = self.plainSeries[[1,2,3]]
-        #self.assertEqual(self.plainSeries[2], slice3[1])
-        
     def testMeta(self):
         wrapped = Series(self.series)
-        self.assert_(equalContents(wrapped.index, self.series.index))
+        self.assert_(common.equalContents(wrapped.index, self.series.index))
         # Ensure new index is not created
         self.assertEquals(id(self.series.index), id(wrapped.index))
-    
+
     def testStatistics(self):
         self.series[5:15] = NaN
-        
+
         s1 = array(self.series)
-        s1 = s1[-isnan(s1)]
+        s1 = s1[-np.isnan(s1)]
         self.assertEquals(np.mean(s1), self.series.mean())
         self.assertEquals(np.std(s1, ddof=1), self.series.std())
         self.assertEquals(np.var(s1, ddof=1), self.series.var())
         self.assertEquals(np.sum(s1), self.series.sum())
-        self.assert_(not isnan(np.sum(self.series)))
-        self.assert_(not isnan(np.mean(self.series)))
-        self.assert_(not isnan(np.std(self.series)))
-        self.assert_(not isnan(np.var(self.series)))
-
-        #self.plainSeries[20:25] = NaN
-        #s2 = array(self.plainSeries)
-        #s2 = s2[-isnan(s2)]
-        #self.assertEquals(np.mean(s2), self.plainSeries.mean())
-        #self.assertEquals(np.std(s2, ddof=1), self.plainSeries.std())
-        #self.assertEquals(np.var(s2, ddof=1), self.plainSeries.var())
-        #self.assertEquals(np.sum(s2), self.plainSeries.sum())
-
-        #self.assert_(isnan(self.series.mean(removeNA=False)))
-        #self.assert_(isnan(self.series.std(removeNA=False)))
-        #self.assert_(isnan(self.series.var(removeNA=False)))
-        #self.assert_(isnan(self.series.sum(removeNA=False)))
-        
+        self.assert_(not np.isnan(np.sum(self.series)))
+        self.assert_(not np.isnan(np.mean(self.series)))
+        self.assert_(not np.isnan(np.std(self.series)))
+        self.assert_(not np.isnan(np.var(self.series)))
+
     def testPickle(self):
         f = open('tmp1', 'wb')
-        #g = open('tmp2', 'wb')
         h = open('tmp3', 'wb')
         pickle.dump(self.series, f)
-        #pickle.dump(self.plainSeries, g)
         pickle.dump(self.ts, h)
         f.close()
-        #g.close()
         h.close()
         f = open('tmp1', 'rb')
-        #g = open('tmp2', 'rb')
         h = open('tmp3', 'rb')
         unPickledf = pickle.load(f)
-        #unPickledg = pickle.load(g)
         unPickledh = pickle.load(h)
         f.close()
-        #g.close()
         h.close()
         os.remove('tmp1')
-        #os.remove('tmp2')
         os.remove('tmp3')
         self.assert_(isinstance(unPickledf, Series))
-        #self.assert_(isinstance(unPickledg, Series))
         self.assert_(isinstance(unPickledh, Series))
-        self.assert_(equalContents(unPickledf, self.series))
-        #self.assert_(equalContents(unPickledg, self.plainSeries))
-        self.assert_(equalContents(unPickledh, self.ts))
+        self.assert_(common.equalContents(unPickledf, self.series))
+        self.assert_(common.equalContents(unPickledh, self.ts))
         for idx in self.series.index:
             self.assert_(idx in unPickledf.index)
-            self.assertEqual(unPickledf[idx], self.series[idx])    
+            self.assertEqual(unPickledf[idx], self.series[idx])
         for idx in self.ts.index:
             self.assert_(idx in unPickledh.index)
-            self.assertEqual(unPickledh[idx], self.ts[idx])    
-            
+            self.assertEqual(unPickledh[idx], self.ts[idx])
+
     def testIter(self):
         for i, val in enumerate(self.series):
             self.assertEqual(val, self.series[i])
@@ -155,9 +111,8 @@ class TestSeries(unittest.TestCase):
         for idx, val in self.series.iteritems():
             self.assertEqual(val, self.series[idx])
         for idx, val in self.ts.iteritems():
-            self.assertEqual(val, self.ts[idx])            
-        #self.assertRaises(Exception, self.plainSeries.iteritems)
-        
+            self.assertEqual(val, self.ts[idx])
+
     def testFromIndex(self):
         identity = self.series.reindex(self.series.index)
         self.assertEqual(id(self.series.index), id(identity.index))
@@ -170,18 +125,18 @@ class TestSeries(unittest.TestCase):
         for idx, val in subTS.iteritems():
             self.assertEqual(val, self.ts[idx])
         crapSeries = self.ts.reindex(subIndex)
-        self.assert_(alltrue(isnan(crapSeries)))
-        
+        self.assert_(alltrue(np.isnan(crapSeries)))
+
         # This is extremely important for the Cython code to not screw up
         nonContigIndex = self.ts.index[::2]
         subNonContig = self.ts.reindex(nonContigIndex)
         for idx, val in subNonContig.iteritems():
-            self.assertEqual(val, self.ts[idx])            
-    
+            self.assertEqual(val, self.ts[idx])
+
     def testCombineFunc(self):
         shiftedSum = self.ts + self.ts.shift(5)
         idSum = self.ts + self.ts
-        self.assert_(isnan(shiftedSum[0]))
+        self.assert_(np.isnan(shiftedSum[0]))
         for idx, val in idSum.iteritems():
             self.assertAlmostEqual(self.ts[idx] + self.ts[idx], val)
         multiplied = self.ts * 5
@@ -200,12 +155,12 @@ class TestSeries(unittest.TestCase):
         self.assertFalse(ltSeries[10])
         self.assertTrue(gtSeries[10])
         self.assertFalse(gtSeries[20])
-        
-        
+
+
     def testShift(self):
         shifted = self.ts.shift(1)
         unshifted = shifted.shift(-1)
-        #self.assert_(equalContents(self.ts.index, unshifted.index))
+        #self.assert_(common.equalContents(self.ts.index, unshifted.index))
         idxMap = self.ts.index.indexMap
         for k, v in unshifted.iteritems():
             self.assertEqual(self.ts[idxMap[k]], v)
@@ -217,15 +172,15 @@ class TestSeries(unittest.TestCase):
         val2 = self.ts.asOf(self.ts.index[19])
         self.assertEqual(val1, self.ts[4])
         self.assertEqual(val2, self.ts[14])
-        
+
     def testPreserveReferences(self):
         slice = self.ts[5:10]
         seq = self.ts[[5,10,15]]
         slice[4] = NaN
         seq[1] = NaN
-        self.assertFalse(isnan(self.ts[9]))
-        self.assertFalse(isnan(self.ts[10]))
-        
+        self.assertFalse(np.isnan(self.ts[9]))
+        self.assertFalse(np.isnan(self.ts[10]))
+
     def testAppend(self):
         appendedSeries = self.series.append(self.ts)
         for idx, value in appendedSeries.iteritems():
diff --git a/pandas/lib/src/reindex.pyx b/pandas/lib/src/reindex.pyx
index abc34b824..595e256e4 100644
--- a/pandas/lib/src/reindex.pyx
+++ b/pandas/lib/src/reindex.pyx
@@ -85,28 +85,39 @@ def reindexObject(ndarray[object, ndim=1] index,
     Using the provided new index, a given array, and a mapping of index-value
     correpondences in the value array, return a new ndarray conforming to
     the new index.
+
+    Returns
+    -------
+    ndarray
     '''
-    cdef int j, loc, length
+    cdef ndarray[object, ndim = 1] result
+    cdef int i, loc, length
     cdef object idx, value
     cdef object nan = np.NaN
 
     length = index.shape[0]
-    cdef ndarray[object, ndim = 1] result = np.empty(length, dtype=object)
+    result = np.empty(length, dtype=object)
 
-    loc = 0
-    cdef int i = 0
     for i from 0 <= i < length:
         idx = index[i]
-        if not PyDict_Contains(idxMap, idx):
+        if idx not in idxMap:
             result[i] = nan
             continue
-        value = arr[idxMap[idx]]
-        result[i] = value
+
+        result[i] = arr[idxMap[idx]]
+
     return result
 
 cdef tuple _nofill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
     cdef int *fillLocs
     cdef char *mask
+
+
+
+
+
+
+
     cdef int i, j, length, newLength
 
     cdef flatiter iterold
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 4f436eb46..6eff2ba38 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -827,8 +827,8 @@ class MovingOLS(OLS):
             Y_slice = np.asarray(Y.truncate(before=prior_date, after=date))
 
             resid = Y_slice - np.dot(X_slice, beta)
-            SS_err = (resid ** 2).sum()
 
+            SS_err = (resid ** 2).sum()
             SS_total = ((Y_slice - Y_slice.mean()) ** 2).sum()
 
             sse.append(SS_err)
diff --git a/pandas/stats/tests/common.py b/pandas/stats/tests/common.py
index 73f112f09..c149e20dd 100644
--- a/pandas/stats/tests/common.py
+++ b/pandas/stats/tests/common.py
@@ -5,7 +5,7 @@ import unittest
 import numpy as np
 
 from pandas.core.api import DataMatrix, DateRange
-
+from pandas.core.tests.common import assert_almost_equal
 
 N = 100
 K = 4
@@ -22,32 +22,6 @@ def makeDataMatrix():
 
     return data
 
-def isiterable(obj):
-    return getattr(obj, '__iter__', False)
-
-def assert_almost_equal(a, b):
-    if isiterable(a):
-        np.testing.assert_(isiterable(b))
-        np.testing.assert_equal(len(a), len(b))
-        for i in xrange(len(a)):
-            assert_almost_equal(a[i], b[i])
-        return
-
-    err_msg = lambda a, b: 'expected %.5f but got %.5f' % (a, b)
-
-    if np.isnan(a):
-        np.testing.assert_(np.isnan(b))
-        return
-
-    # case for zero
-    if abs(a) < 1e-5:
-        np.testing.assert_almost_equal(
-            a, b, decimal=5, err_msg=err_msg(a, b), verbose=False)
-    else:
-        np.testing.assert_almost_equal(
-            1, a/b, decimal=5, err_msg=err_msg(a, b), verbose=False)
-
-
 def getBasicDatasets():
     A = makeDataMatrix()
     B = makeDataMatrix()

commit e131b21f0131122d4066b0b532022a02a0140947
Author: Terji Petersen <contribute@tensortable.com>
Date:   Thu Nov 7 01:34:46 2019 +0000

    API: rename labels to codes in core/groupby (#29402)

diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 8512b6c3a..511b87dab 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -655,16 +655,17 @@ class SeriesGroupBy(GroupBy):
         rep = partial(np.repeat, repeats=np.add.reduceat(inc, idx))
 
         # multi-index components
-        labels = list(map(rep, self.grouper.recons_labels)) + [llab(lab, inc)]
+        codes = self.grouper.recons_codes
+        codes = [rep(level_codes) for level_codes in codes] + [llab(lab, inc)]
         levels = [ping.group_index for ping in self.grouper.groupings] + [lev]
         names = self.grouper.names + [self._selection_name]
 
         if dropna:
-            mask = labels[-1] != -1
+            mask = codes[-1] != -1
             if mask.all():
                 dropna = False
             else:
-                out, labels = out[mask], [label[mask] for label in labels]
+                out, codes = out[mask], [level_codes[mask] for level_codes in codes]
 
         if normalize:
             out = out.astype("float")
@@ -680,11 +681,11 @@ class SeriesGroupBy(GroupBy):
         if sort and bins is None:
             cat = ids[inc][mask] if dropna else ids[inc]
             sorter = np.lexsort((out if ascending else -out, cat))
-            out, labels[-1] = out[sorter], labels[-1][sorter]
+            out, codes[-1] = out[sorter], codes[-1][sorter]
 
         if bins is None:
             mi = MultiIndex(
-                levels=levels, codes=labels, names=names, verify_integrity=False
+                levels=levels, codes=codes, names=names, verify_integrity=False
             )
 
             if is_integer_dtype(out):
@@ -694,14 +695,14 @@ class SeriesGroupBy(GroupBy):
         # for compat. with libgroupby.value_counts need to ensure every
         # bin is present at every index level, null filled with zeros
         diff = np.zeros(len(out), dtype="bool")
-        for lab in labels[:-1]:
-            diff |= np.r_[True, lab[1:] != lab[:-1]]
+        for level_codes in codes[:-1]:
+            diff |= np.r_[True, level_codes[1:] != level_codes[:-1]]
 
         ncat, nbin = diff.sum(), len(levels[-1])
 
         left = [np.repeat(np.arange(ncat), nbin), np.tile(np.arange(nbin), ncat)]
 
-        right = [diff.cumsum() - 1, labels[-1]]
+        right = [diff.cumsum() - 1, codes[-1]]
 
         _, idx = _get_join_indexers(left, right, sort=False, how="left")
         out = np.where(idx != -1, out[idx], 0)
@@ -711,7 +712,10 @@ class SeriesGroupBy(GroupBy):
             out, left[-1] = out[sorter], left[-1][sorter]
 
         # build the multi-index w/ full levels
-        codes = list(map(lambda lab: np.repeat(lab[diff], nbin), labels[:-1]))
+        def build_codes(lev_codes: np.ndarray) -> np.ndarray:
+            return np.repeat(lev_codes[diff], nbin)
+
+        codes = [build_codes(lev_codes) for lev_codes in codes[:-1]]
         codes.append(left[-1])
 
         mi = MultiIndex(levels=levels, codes=codes, names=names, verify_integrity=False)
@@ -758,7 +762,7 @@ class SeriesGroupBy(GroupBy):
                 )
             )
         filled = getattr(self, fill_method)(limit=limit)
-        fill_grp = filled.groupby(self.grouper.labels)
+        fill_grp = filled.groupby(self.grouper.codes)
         shifted = fill_grp.shift(periods=periods, freq=freq)
 
         return (filled / shifted) - 1
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index fa4a184e8..81ba594c9 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -2349,7 +2349,7 @@ class GroupBy(_GroupBy):
                 )
             )
         filled = getattr(self, fill_method)(limit=limit)
-        fill_grp = filled.groupby(self.grouper.labels)
+        fill_grp = filled.groupby(self.grouper.codes)
         shifted = fill_grp.shift(periods=periods, freq=freq)
         return (filled / shifted) - 1
 
diff --git a/pandas/core/groupby/grouper.py b/pandas/core/groupby/grouper.py
index 45d2a819a..dc6336b17 100644
--- a/pandas/core/groupby/grouper.py
+++ b/pandas/core/groupby/grouper.py
@@ -3,7 +3,7 @@ Provide user facing operators for doing the split part of the
 split-apply-combine paradigm.
 """
 
-from typing import Tuple
+from typing import Optional, Tuple
 import warnings
 
 import numpy as np
@@ -21,6 +21,7 @@ from pandas.core.dtypes.common import (
 )
 from pandas.core.dtypes.generic import ABCSeries
 
+from pandas._typing import FrameOrSeries
 import pandas.core.algorithms as algorithms
 from pandas.core.arrays import Categorical, ExtensionArray
 import pandas.core.common as com
@@ -228,10 +229,10 @@ class Grouping:
     ----------
     index : Index
     grouper :
-    obj :
+    obj Union[DataFrame, Series]:
     name :
     level :
-    observed : boolean, default False
+    observed : bool, default False
         If we are a Categorical, use the observed values
     in_axis : if the Grouping is a column in self.obj and hence among
         Groupby.exclusions list
@@ -240,25 +241,22 @@ class Grouping:
     -------
     **Attributes**:
       * indices : dict of {group -> index_list}
-      * labels : ndarray, group labels
-      * ids : mapping of label -> group
-      * counts : array of group counts
+      * codes : ndarray, group codes
       * group_index : unique groups
       * groups : dict of {group -> label_list}
     """
 
     def __init__(
         self,
-        index,
+        index: Index,
         grouper=None,
-        obj=None,
+        obj: Optional[FrameOrSeries] = None,
         name=None,
         level=None,
-        sort=True,
-        observed=False,
-        in_axis=False,
+        sort: bool = True,
+        observed: bool = False,
+        in_axis: bool = False,
     ):
-
         self.name = name
         self.level = level
         self.grouper = _convert_grouper(index, grouper)
@@ -290,12 +288,12 @@ class Grouping:
             if self.name is None:
                 self.name = index.names[level]
 
-            self.grouper, self._labels, self._group_index = index._get_grouper_for_level(  # noqa: E501
+            self.grouper, self._codes, self._group_index = index._get_grouper_for_level(  # noqa: E501
                 self.grouper, level
             )
 
         # a passed Grouper like, directly get the grouper in the same way
-        # as single grouper groupby, use the group_info to get labels
+        # as single grouper groupby, use the group_info to get codes
         elif isinstance(self.grouper, Grouper):
             # get the new grouper; we already have disambiguated
             # what key/level refer to exactly, don't need to
@@ -308,7 +306,7 @@ class Grouping:
             self.grouper = grouper._get_grouper()
 
         else:
-            if self.grouper is None and self.name is not None:
+            if self.grouper is None and self.name is not None and self.obj is not None:
                 self.grouper = self.obj[self.name]
 
             elif isinstance(self.grouper, (list, tuple)):
@@ -324,7 +322,7 @@ class Grouping:
 
                 # we make a CategoricalIndex out of the cat grouper
                 # preserving the categories / ordered attributes
-                self._labels = self.grouper.codes
+                self._codes = self.grouper.codes
                 if observed:
                     codes = algorithms.unique1d(self.grouper.codes)
                     codes = codes[codes != -1]
@@ -380,11 +378,11 @@ class Grouping:
     def __iter__(self):
         return iter(self.indices)
 
-    _labels = None
-    _group_index = None
+    _codes = None  # type: np.ndarray
+    _group_index = None  # type: Index
 
     @property
-    def ngroups(self):
+    def ngroups(self) -> int:
         return len(self.group_index)
 
     @cache_readonly
@@ -397,38 +395,38 @@ class Grouping:
         return values._reverse_indexer()
 
     @property
-    def labels(self):
-        if self._labels is None:
-            self._make_labels()
-        return self._labels
+    def codes(self) -> np.ndarray:
+        if self._codes is None:
+            self._make_codes()
+        return self._codes
 
     @cache_readonly
-    def result_index(self):
+    def result_index(self) -> Index:
         if self.all_grouper is not None:
             return recode_from_groupby(self.all_grouper, self.sort, self.group_index)
         return self.group_index
 
     @property
-    def group_index(self):
+    def group_index(self) -> Index:
         if self._group_index is None:
-            self._make_labels()
+            self._make_codes()
         return self._group_index
 
-    def _make_labels(self):
-        if self._labels is None or self._group_index is None:
+    def _make_codes(self) -> None:
+        if self._codes is None or self._group_index is None:
             # we have a list of groupers
             if isinstance(self.grouper, BaseGrouper):
-                labels = self.grouper.label_info
+                codes = self.grouper.codes_info
                 uniques = self.grouper.result_index
             else:
-                labels, uniques = algorithms.factorize(self.grouper, sort=self.sort)
+                codes, uniques = algorithms.factorize(self.grouper, sort=self.sort)
                 uniques = Index(uniques, name=self.name)
-            self._labels = labels
+            self._codes = codes
             self._group_index = uniques
 
     @cache_readonly
-    def groups(self):
-        return self.index.groupby(Categorical.from_codes(self.labels, self.group_index))
+    def groups(self) -> dict:
+        return self.index.groupby(Categorical.from_codes(self.codes, self.group_index))
 
 
 def _get_grouper(
@@ -678,7 +676,7 @@ def _is_label_like(val):
     return isinstance(val, (str, tuple)) or (val is not None and is_scalar(val))
 
 
-def _convert_grouper(axis, grouper):
+def _convert_grouper(axis: Index, grouper):
     if isinstance(grouper, dict):
         return grouper.get
     elif isinstance(grouper, Series):
diff --git a/pandas/core/groupby/ops.py b/pandas/core/groupby/ops.py
index 5bad73bf4..2c8aa1294 100644
--- a/pandas/core/groupby/ops.py
+++ b/pandas/core/groupby/ops.py
@@ -7,7 +7,7 @@ are contained *in* the SeriesGroupBy and DataFrameGroupBy objects.
 """
 
 import collections
-from typing import List, Optional, Type
+from typing import List, Optional, Sequence, Type
 
 import numpy as np
 
@@ -41,7 +41,7 @@ from pandas.core.base import SelectionMixin
 import pandas.core.common as com
 from pandas.core.frame import DataFrame
 from pandas.core.generic import NDFrame
-from pandas.core.groupby import base
+from pandas.core.groupby import base, grouper
 from pandas.core.index import Index, MultiIndex, ensure_index
 from pandas.core.series import Series
 from pandas.core.sorting import (
@@ -62,13 +62,13 @@ class BaseGrouper:
     Parameters
     ----------
     axis : Index
-    groupings : array of grouping
+    groupings : Sequence[Grouping]
         all the grouping instances to handle in this grouper
         for example for grouper list to groupby, need to pass the list
-    sort : boolean, default True
+    sort : bool, default True
         whether this grouper will give sorted result or not
-    group_keys : boolean, default True
-    mutated : boolean, default False
+    group_keys : bool, default True
+    mutated : bool, default False
     indexer : intp array, optional
         the indexer created by Grouper
         some groupers (TimeGrouper) will sort its axis and its
@@ -79,16 +79,17 @@ class BaseGrouper:
     def __init__(
         self,
         axis: Index,
-        groupings,
-        sort=True,
-        group_keys=True,
-        mutated=False,
-        indexer=None,
+        groupings: "Sequence[grouper.Grouping]",
+        sort: bool = True,
+        group_keys: bool = True,
+        mutated: bool = False,
+        indexer: Optional[np.ndarray] = None,
     ):
         assert isinstance(axis, Index), axis
+
         self._filter_empty_groups = self.compressed = len(groupings) != 1
         self.axis = axis
-        self.groupings = groupings
+        self.groupings = groupings  # type: Sequence[grouper.Grouping]
         self.sort = sort
         self.group_keys = group_keys
         self.mutated = mutated
@@ -139,7 +140,7 @@ class BaseGrouper:
             comp_ids, _, ngroups = self.group_info
 
             # provide "flattened" iterator for multi-group setting
-            return get_flattened_iterator(comp_ids, ngroups, self.levels, self.labels)
+            return get_flattened_iterator(comp_ids, ngroups, self.levels, self.codes)
 
     def apply(self, f, data, axis: int = 0):
         mutated = self.mutated
@@ -210,13 +211,13 @@ class BaseGrouper:
         if len(self.groupings) == 1:
             return self.groupings[0].indices
         else:
-            label_list = [ping.labels for ping in self.groupings]
+            codes_list = [ping.codes for ping in self.groupings]
             keys = [com.values_from_object(ping.group_index) for ping in self.groupings]
-            return get_indexer_dict(label_list, keys)
+            return get_indexer_dict(codes_list, keys)
 
     @property
-    def labels(self):
-        return [ping.labels for ping in self.groupings]
+    def codes(self):
+        return [ping.codes for ping in self.groupings]
 
     @property
     def levels(self):
@@ -256,46 +257,46 @@ class BaseGrouper:
 
     @cache_readonly
     def group_info(self):
-        comp_ids, obs_group_ids = self._get_compressed_labels()
+        comp_ids, obs_group_ids = self._get_compressed_codes()
 
         ngroups = len(obs_group_ids)
         comp_ids = ensure_int64(comp_ids)
         return comp_ids, obs_group_ids, ngroups
 
     @cache_readonly
-    def label_info(self):
-        # return the labels of items in original grouped axis
-        labels, _, _ = self.group_info
+    def codes_info(self):
+        # return the codes of items in original grouped axis
+        codes, _, _ = self.group_info
         if self.indexer is not None:
-            sorter = np.lexsort((labels, self.indexer))
-            labels = labels[sorter]
-        return labels
-
-    def _get_compressed_labels(self):
-        all_labels = [ping.labels for ping in self.groupings]
-        if len(all_labels) > 1:
-            group_index = get_group_index(all_labels, self.shape, sort=True, xnull=True)
+            sorter = np.lexsort((codes, self.indexer))
+            codes = codes[sorter]
+        return codes
+
+    def _get_compressed_codes(self):
+        all_codes = [ping.codes for ping in self.groupings]
+        if len(all_codes) > 1:
+            group_index = get_group_index(all_codes, self.shape, sort=True, xnull=True)
             return compress_group_index(group_index, sort=self.sort)
 
         ping = self.groupings[0]
-        return ping.labels, np.arange(len(ping.group_index))
+        return ping.codes, np.arange(len(ping.group_index))
 
     @cache_readonly
     def ngroups(self) -> int:
         return len(self.result_index)
 
     @property
-    def recons_labels(self):
+    def recons_codes(self):
         comp_ids, obs_ids, _ = self.group_info
-        labels = (ping.labels for ping in self.groupings)
-        return decons_obs_group_ids(comp_ids, obs_ids, self.shape, labels, xnull=True)
+        codes = (ping.codes for ping in self.groupings)
+        return decons_obs_group_ids(comp_ids, obs_ids, self.shape, codes, xnull=True)
 
     @cache_readonly
     def result_index(self):
         if not self.compressed and len(self.groupings) == 1:
             return self.groupings[0].result_index.rename(self.names[0])
 
-        codes = self.recons_labels
+        codes = self.recons_codes
         levels = [ping.result_index for ping in self.groupings]
         result = MultiIndex(
             levels=levels, codes=codes, verify_integrity=False, names=self.names
@@ -307,9 +308,9 @@ class BaseGrouper:
             return [self.groupings[0].result_index]
 
         name_list = []
-        for ping, labels in zip(self.groupings, self.recons_labels):
-            labels = ensure_platform_int(labels)
-            levels = ping.result_index.take(labels)
+        for ping, codes in zip(self.groupings, self.recons_codes):
+            codes = ensure_platform_int(codes)
+            levels = ping.result_index.take(codes)
 
             name_list.append(levels)
 
@@ -490,7 +491,7 @@ class BaseGrouper:
             else:
                 out_dtype = "object"
 
-        labels, _, _ = self.group_info
+        codes, _, _ = self.group_info
 
         if kind == "aggregate":
             result = _maybe_fill(
@@ -498,7 +499,7 @@ class BaseGrouper:
             )
             counts = np.zeros(self.ngroups, dtype=np.int64)
             result = self._aggregate(
-                result, counts, values, labels, func, is_datetimelike, min_count
+                result, counts, values, codes, func, is_datetimelike, min_count
             )
         elif kind == "transform":
             result = _maybe_fill(
@@ -507,7 +508,7 @@ class BaseGrouper:
 
             # TODO: min_count
             result = self._transform(
-                result, values, labels, func, is_datetimelike, **kwargs
+                result, values, codes, func, is_datetimelike, **kwargs
             )
 
         if is_integer_dtype(result) and not is_datetimelike:
diff --git a/pandas/tests/groupby/test_grouping.py b/pandas/tests/groupby/test_grouping.py
index e1fd8d7da..e4edc6401 100644
--- a/pandas/tests/groupby/test_grouping.py
+++ b/pandas/tests/groupby/test_grouping.py
@@ -559,12 +559,12 @@ class TestGrouping:
         # GH 17537
         grouped = mframe.groupby(level=0, sort=sort)
         exp_labels = np.array(labels, np.intp)
-        tm.assert_almost_equal(grouped.grouper.labels[0], exp_labels)
+        tm.assert_almost_equal(grouped.grouper.codes[0], exp_labels)
 
     def test_grouping_labels(self, mframe):
         grouped = mframe.groupby(mframe.index.get_level_values(0))
         exp_labels = np.array([2, 2, 2, 0, 0, 1, 1, 3, 3, 3], dtype=np.intp)
-        tm.assert_almost_equal(grouped.grouper.labels[0], exp_labels)
+        tm.assert_almost_equal(grouped.grouper.codes[0], exp_labels)
 
     def test_list_grouper_with_nat(self):
         # GH 14715
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 5a2f189ad..4ba32c377 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -621,8 +621,8 @@ def assert_index_equal(
     def _get_ilevel_values(index, level):
         # accept level number only
         unique = index.levels[level]
-        labels = index.codes[level]
-        filled = take_1d(unique.values, labels, fill_value=unique._na_value)
+        level_codes = index.codes[level]
+        filled = take_1d(unique.values, level_codes, fill_value=unique._na_value)
         values = unique._shallow_copy(filled, name=index.names[level])
         return values
 

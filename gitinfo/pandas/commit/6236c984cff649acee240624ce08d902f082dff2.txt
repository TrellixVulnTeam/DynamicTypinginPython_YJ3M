commit 6236c984cff649acee240624ce08d902f082dff2
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Mar 21 13:18:15 2020 -0700

    REF: misplaced Timedelta tests (#32871)

diff --git a/pandas/tests/indexes/timedeltas/test_scalar_compat.py b/pandas/tests/indexes/timedeltas/test_scalar_compat.py
index 44f4a2ade..1b86cd1df 100644
--- a/pandas/tests/indexes/timedeltas/test_scalar_compat.py
+++ b/pandas/tests/indexes/timedeltas/test_scalar_compat.py
@@ -69,3 +69,67 @@ class TestVectorizedTimedelta:
             td.round(freq="M")
         with pytest.raises(ValueError, match=msg):
             elt.round(freq="M")
+
+    @pytest.mark.parametrize(
+        "freq,msg",
+        [
+            ("Y", "<YearEnd: month=12> is a non-fixed frequency"),
+            ("M", "<MonthEnd> is a non-fixed frequency"),
+            ("foobar", "Invalid frequency: foobar"),
+        ],
+    )
+    def test_tdi_round_invalid(self, freq, msg):
+        t1 = timedelta_range("1 days", periods=3, freq="1 min 2 s 3 us")
+
+        with pytest.raises(ValueError, match=msg):
+            t1.round(freq)
+        with pytest.raises(ValueError, match=msg):
+            # Same test for TimedeltaArray
+            t1._data.round(freq)
+
+    # TODO: de-duplicate with test_tdi_round
+    def test_round(self):
+        t1 = timedelta_range("1 days", periods=3, freq="1 min 2 s 3 us")
+        t2 = -1 * t1
+        t1a = timedelta_range("1 days", periods=3, freq="1 min 2 s")
+        t1c = TimedeltaIndex([1, 1, 1], unit="D")
+
+        # note that negative times round DOWN! so don't give whole numbers
+        for (freq, s1, s2) in [
+            ("N", t1, t2),
+            ("U", t1, t2),
+            (
+                "L",
+                t1a,
+                TimedeltaIndex(
+                    ["-1 days +00:00:00", "-2 days +23:58:58", "-2 days +23:57:56"],
+                ),
+            ),
+            (
+                "S",
+                t1a,
+                TimedeltaIndex(
+                    ["-1 days +00:00:00", "-2 days +23:58:58", "-2 days +23:57:56"],
+                ),
+            ),
+            ("12T", t1c, TimedeltaIndex(["-1 days", "-1 days", "-1 days"],),),
+            ("H", t1c, TimedeltaIndex(["-1 days", "-1 days", "-1 days"],),),
+            ("d", t1c, TimedeltaIndex([-1, -1, -1], unit="D")),
+        ]:
+
+            r1 = t1.round(freq)
+            tm.assert_index_equal(r1, s1)
+            r2 = t2.round(freq)
+            tm.assert_index_equal(r2, s2)
+
+    def test_components(self):
+        rng = timedelta_range("1 days, 10:11:12", periods=2, freq="s")
+        rng.components
+
+        # with nat
+        s = Series(rng)
+        s[1] = np.nan
+
+        result = s.dt.components
+        assert not result.iloc[0].isna().all()
+        assert result.iloc[1].isna().all()
diff --git a/pandas/tests/scalar/timedelta/test_arithmetic.py b/pandas/tests/scalar/timedelta/test_arithmetic.py
index ea02a7627..3cb868dd8 100644
--- a/pandas/tests/scalar/timedelta/test_arithmetic.py
+++ b/pandas/tests/scalar/timedelta/test_arithmetic.py
@@ -88,6 +88,13 @@ class TestTimedeltaAdditionSubtraction:
         result = op(td, NaT)
         assert result is NaT
 
+    def test_td_add_timestamp_overflow(self):
+        with pytest.raises(OverflowError):
+            Timestamp("1700-01-01") + Timedelta(13 * 19999, unit="D")
+
+        with pytest.raises(OverflowError):
+            Timestamp("1700-01-01") + timedelta(days=13 * 19999)
+
     @pytest.mark.parametrize("op", [operator.add, ops.radd])
     def test_td_add_td(self, op):
         td = Timedelta(10, unit="d")
@@ -365,6 +372,26 @@ class TestTimedeltaMultiplicationDivision:
 
         assert np.isnan(td / NaT)
 
+    def test_td_div_td64_non_nano(self):
+
+        # truediv
+        td = Timedelta("1 days 2 hours 3 ns")
+        result = td / np.timedelta64(1, "D")
+        assert result == td.value / float(86400 * 1e9)
+        result = td / np.timedelta64(1, "s")
+        assert result == td.value / float(1e9)
+        result = td / np.timedelta64(1, "ns")
+        assert result == td.value
+
+        # floordiv
+        td = Timedelta("1 days 2 hours 3 ns")
+        result = td // np.timedelta64(1, "D")
+        assert result == 1
+        result = td // np.timedelta64(1, "s")
+        assert result == 93600
+        result = td // np.timedelta64(1, "ns")
+        assert result == td.value
+
     def test_td_div_numeric_scalar(self):
         # GH#19738
         td = Timedelta(10, unit="d")
@@ -589,6 +616,13 @@ class TestTimedeltaMultiplicationDivision:
         expected = np.array([10, np.nan])
         tm.assert_numpy_array_equal(res, expected)
 
+    def test_td_rfloordiv_intarray(self):
+        # deprecated GH#19761, enforced GH#29797
+        ints = np.array([1349654400, 1349740800, 1349827200, 1349913600]) * 10 ** 9
+
+        with pytest.raises(TypeError, match="Invalid dtype"):
+            ints // Timedelta(1, unit="s")
+
     def test_td_rfloordiv_numeric_series(self):
         # GH#18846
         td = Timedelta(hours=3, minutes=3)
@@ -796,3 +830,129 @@ class TestTimedeltaMultiplicationDivision:
     def test_td_op_timedelta_timedeltalike_array(self, op, arr):
         with pytest.raises(TypeError):
             op(arr, Timedelta("1D"))
+
+
+class TestTimedeltaComparison:
+    def test_compare_tick(self, tick_classes):
+        cls = tick_classes
+
+        off = cls(4)
+        td = off.delta
+        assert isinstance(td, Timedelta)
+
+        assert td == off
+        assert not td != off
+        assert td <= off
+        assert td >= off
+        assert not td < off
+        assert not td > off
+
+        assert not td == 2 * off
+        assert td != 2 * off
+        assert td <= 2 * off
+        assert td < 2 * off
+        assert not td >= 2 * off
+        assert not td > 2 * off
+
+    def test_comparison_object_array(self):
+        # analogous to GH#15183
+        td = Timedelta("2 days")
+        other = Timedelta("3 hours")
+
+        arr = np.array([other, td], dtype=object)
+        res = arr == td
+        expected = np.array([False, True], dtype=bool)
+        assert (res == expected).all()
+
+        # 2D case
+        arr = np.array([[other, td], [td, other]], dtype=object)
+        res = arr != td
+        expected = np.array([[True, False], [False, True]], dtype=bool)
+        assert res.shape == expected.shape
+        assert (res == expected).all()
+
+    def test_compare_timedelta_ndarray(self):
+        # GH#11835
+        periods = [Timedelta("0 days 01:00:00"), Timedelta("0 days 01:00:00")]
+        arr = np.array(periods)
+        result = arr[0] > arr
+        expected = np.array([False, False])
+        tm.assert_numpy_array_equal(result, expected)
+
+    @pytest.mark.skip(reason="GH#20829 is reverted until after 0.24.0")
+    def test_compare_custom_object(self):
+        """
+        Make sure non supported operations on Timedelta returns NonImplemented
+        and yields to other operand (GH#20829).
+        """
+
+        class CustomClass:
+            def __init__(self, cmp_result=None):
+                self.cmp_result = cmp_result
+
+            def generic_result(self):
+                if self.cmp_result is None:
+                    return NotImplemented
+                else:
+                    return self.cmp_result
+
+            def __eq__(self, other):
+                return self.generic_result()
+
+            def __gt__(self, other):
+                return self.generic_result()
+
+        t = Timedelta("1s")
+
+        assert not (t == "string")
+        assert not (t == 1)
+        assert not (t == CustomClass())
+        assert not (t == CustomClass(cmp_result=False))
+
+        assert t < CustomClass(cmp_result=True)
+        assert not (t < CustomClass(cmp_result=False))
+
+        assert t == CustomClass(cmp_result=True)
+
+    @pytest.mark.parametrize("val", ["string", 1])
+    def test_compare_unknown_type(self, val):
+        # GH#20829
+        t = Timedelta("1s")
+        with pytest.raises(TypeError):
+            t >= val
+        with pytest.raises(TypeError):
+            t > val
+        with pytest.raises(TypeError):
+            t <= val
+        with pytest.raises(TypeError):
+            t < val
+
+
+def test_ops_notimplemented():
+    class Other:
+        pass
+
+    other = Other()
+
+    td = Timedelta("1 day")
+    assert td.__add__(other) is NotImplemented
+    assert td.__sub__(other) is NotImplemented
+    assert td.__truediv__(other) is NotImplemented
+    assert td.__mul__(other) is NotImplemented
+    assert td.__floordiv__(other) is NotImplemented
+
+
+def test_ops_error_str():
+    # GH#13624
+    td = Timedelta("1 day")
+
+    for left, right in [(td, "a"), ("a", td)]:
+
+        with pytest.raises(TypeError):
+            left + right
+
+        with pytest.raises(TypeError):
+            left > right
+
+        assert not left == right
+        assert left != right
diff --git a/pandas/tests/scalar/timedelta/test_timedelta.py b/pandas/tests/scalar/timedelta/test_timedelta.py
index 9cdbeb6ab..0f2486be3 100644
--- a/pandas/tests/scalar/timedelta/test_timedelta.py
+++ b/pandas/tests/scalar/timedelta/test_timedelta.py
@@ -4,56 +4,14 @@ from datetime import timedelta
 import numpy as np
 import pytest
 
-from pandas._libs.tslibs import NaT, Timestamp, iNaT
+from pandas._libs.tslibs import NaT, iNaT
 
 import pandas as pd
-from pandas import Series, Timedelta, TimedeltaIndex, timedelta_range, to_timedelta
+from pandas import Timedelta, TimedeltaIndex, offsets, to_timedelta
 import pandas._testing as tm
 
 
-class TestTimedeltaArithmetic:
-    def test_arithmetic_overflow(self):
-        with pytest.raises(OverflowError):
-            Timestamp("1700-01-01") + Timedelta(13 * 19999, unit="D")
-
-        with pytest.raises(OverflowError):
-            Timestamp("1700-01-01") + timedelta(days=13 * 19999)
-
-    def test_array_timedelta_floordiv(self):
-        # deprecated GH#19761, enforced GH#29797
-        ints = pd.date_range("2012-10-08", periods=4, freq="D").view("i8")
-
-        with pytest.raises(TypeError, match="Invalid dtype"):
-            ints // Timedelta(1, unit="s")
-
-    def test_ops_error_str(self):
-        # GH 13624
-        td = Timedelta("1 day")
-
-        for left, right in [(td, "a"), ("a", td)]:
-
-            with pytest.raises(TypeError):
-                left + right
-
-            with pytest.raises(TypeError):
-                left > right
-
-            assert not left == right
-            assert left != right
-
-    def test_ops_notimplemented(self):
-        class Other:
-            pass
-
-        other = Other()
-
-        td = Timedelta("1 day")
-        assert td.__add__(other) is NotImplemented
-        assert td.__sub__(other) is NotImplemented
-        assert td.__truediv__(other) is NotImplemented
-        assert td.__mul__(other) is NotImplemented
-        assert td.__floordiv__(other) is NotImplemented
-
+class TestTimedeltaUnaryOps:
     def test_unary_ops(self):
         td = Timedelta(10, unit="d")
 
@@ -68,102 +26,6 @@ class TestTimedeltaArithmetic:
         assert abs(-td) == Timedelta("10d")
 
 
-class TestTimedeltaComparison:
-    def test_compare_tick(self, tick_classes):
-        cls = tick_classes
-
-        off = cls(4)
-        td = off.delta
-        assert isinstance(td, Timedelta)
-
-        assert td == off
-        assert not td != off
-        assert td <= off
-        assert td >= off
-        assert not td < off
-        assert not td > off
-
-        assert not td == 2 * off
-        assert td != 2 * off
-        assert td <= 2 * off
-        assert td < 2 * off
-        assert not td >= 2 * off
-        assert not td > 2 * off
-
-    def test_comparison_object_array(self):
-        # analogous to GH#15183
-        td = Timedelta("2 days")
-        other = Timedelta("3 hours")
-
-        arr = np.array([other, td], dtype=object)
-        res = arr == td
-        expected = np.array([False, True], dtype=bool)
-        assert (res == expected).all()
-
-        # 2D case
-        arr = np.array([[other, td], [td, other]], dtype=object)
-        res = arr != td
-        expected = np.array([[True, False], [False, True]], dtype=bool)
-        assert res.shape == expected.shape
-        assert (res == expected).all()
-
-    def test_compare_timedelta_ndarray(self):
-        # GH11835
-        periods = [Timedelta("0 days 01:00:00"), Timedelta("0 days 01:00:00")]
-        arr = np.array(periods)
-        result = arr[0] > arr
-        expected = np.array([False, False])
-        tm.assert_numpy_array_equal(result, expected)
-
-    @pytest.mark.skip(reason="GH#20829 is reverted until after 0.24.0")
-    def test_compare_custom_object(self):
-        """
-        Make sure non supported operations on Timedelta returns NonImplemented
-        and yields to other operand (GH#20829).
-        """
-
-        class CustomClass:
-            def __init__(self, cmp_result=None):
-                self.cmp_result = cmp_result
-
-            def generic_result(self):
-                if self.cmp_result is None:
-                    return NotImplemented
-                else:
-                    return self.cmp_result
-
-            def __eq__(self, other):
-                return self.generic_result()
-
-            def __gt__(self, other):
-                return self.generic_result()
-
-        t = Timedelta("1s")
-
-        assert not (t == "string")
-        assert not (t == 1)
-        assert not (t == CustomClass())
-        assert not (t == CustomClass(cmp_result=False))
-
-        assert t < CustomClass(cmp_result=True)
-        assert not (t < CustomClass(cmp_result=False))
-
-        assert t == CustomClass(cmp_result=True)
-
-    @pytest.mark.parametrize("val", ["string", 1])
-    def test_compare_unknown_type(self, val):
-        # GH20829
-        t = Timedelta("1s")
-        with pytest.raises(TypeError):
-            t >= val
-        with pytest.raises(TypeError):
-            t > val
-        with pytest.raises(TypeError):
-            t <= val
-        with pytest.raises(TypeError):
-            t < val
-
-
 class TestTimedeltas:
     @pytest.mark.parametrize(
         "unit, value, expected",
@@ -209,26 +71,6 @@ class TestTimedeltas:
         td = Timedelta("1 days, 10:11:12.012345678")
         assert td != td.to_pytimedelta()
 
-    def test_freq_conversion(self):
-
-        # truediv
-        td = Timedelta("1 days 2 hours 3 ns")
-        result = td / np.timedelta64(1, "D")
-        assert result == td.value / float(86400 * 1e9)
-        result = td / np.timedelta64(1, "s")
-        assert result == td.value / float(1e9)
-        result = td / np.timedelta64(1, "ns")
-        assert result == td.value
-
-        # floordiv
-        td = Timedelta("1 days 2 hours 3 ns")
-        result = td // np.timedelta64(1, "D")
-        assert result == 1
-        result = td // np.timedelta64(1, "s")
-        assert result == 93600
-        result = td // np.timedelta64(1, "ns")
-        assert result == td.value
-
     def test_fields(self):
         def check(value):
             # that we are int
@@ -457,13 +299,15 @@ class TestTimedeltas:
         td = Timedelta("10m7s")
         assert td.to_timedelta64() == td.to_numpy()
 
-    def test_round(self):
-
-        t1 = Timedelta("1 days 02:34:56.789123456")
-        t2 = Timedelta("-1 days 02:34:56.789123456")
-
-        for (freq, s1, s2) in [
-            ("N", t1, t2),
+    @pytest.mark.parametrize(
+        "freq,s1,s2",
+        [
+            # This first case has s1, s2 being the same as t1,t2 below
+            (
+                "N",
+                Timedelta("1 days 02:34:56.789123456"),
+                Timedelta("-1 days 02:34:56.789123456"),
+            ),
             (
                 "U",
                 Timedelta("1 days 02:34:56.789123000"),
@@ -481,75 +325,21 @@ class TestTimedeltas:
             ("12T", Timedelta("1 days 02:36:00"), Timedelta("-1 days 02:36:00")),
             ("H", Timedelta("1 days 03:00:00"), Timedelta("-1 days 03:00:00")),
             ("d", Timedelta("1 days"), Timedelta("-1 days")),
-        ]:
-            r1 = t1.round(freq)
-            assert r1 == s1
-            r2 = t2.round(freq)
-            assert r2 == s2
-
-        # invalid
-        for freq, msg in [
-            ("Y", "<YearEnd: month=12> is a non-fixed frequency"),
-            ("M", "<MonthEnd> is a non-fixed frequency"),
-            ("foobar", "Invalid frequency: foobar"),
-        ]:
-            with pytest.raises(ValueError, match=msg):
-                t1.round(freq)
+        ],
+    )
+    def test_round(self, freq, s1, s2):
 
-        t1 = timedelta_range("1 days", periods=3, freq="1 min 2 s 3 us")
-        t2 = -1 * t1
-        t1a = timedelta_range("1 days", periods=3, freq="1 min 2 s")
-        t1c = TimedeltaIndex([1, 1, 1], unit="D")
+        t1 = Timedelta("1 days 02:34:56.789123456")
+        t2 = Timedelta("-1 days 02:34:56.789123456")
 
-        # note that negative times round DOWN! so don't give whole numbers
-        for (freq, s1, s2) in [
-            ("N", t1, t2),
-            ("U", t1, t2),
-            (
-                "L",
-                t1a,
-                TimedeltaIndex(
-                    ["-1 days +00:00:00", "-2 days +23:58:58", "-2 days +23:57:56"],
-                    dtype="timedelta64[ns]",
-                    freq=None,
-                ),
-            ),
-            (
-                "S",
-                t1a,
-                TimedeltaIndex(
-                    ["-1 days +00:00:00", "-2 days +23:58:58", "-2 days +23:57:56"],
-                    dtype="timedelta64[ns]",
-                    freq=None,
-                ),
-            ),
-            (
-                "12T",
-                t1c,
-                TimedeltaIndex(
-                    ["-1 days", "-1 days", "-1 days"],
-                    dtype="timedelta64[ns]",
-                    freq=None,
-                ),
-            ),
-            (
-                "H",
-                t1c,
-                TimedeltaIndex(
-                    ["-1 days", "-1 days", "-1 days"],
-                    dtype="timedelta64[ns]",
-                    freq=None,
-                ),
-            ),
-            ("d", t1c, TimedeltaIndex([-1, -1, -1], unit="D")),
-        ]:
+        r1 = t1.round(freq)
+        assert r1 == s1
+        r2 = t2.round(freq)
+        assert r2 == s2
 
-            r1 = t1.round(freq)
-            tm.assert_index_equal(r1, s1)
-            r2 = t2.round(freq)
-            tm.assert_index_equal(r2, s2)
+    def test_round_invalid(self):
+        t1 = Timedelta("1 days 02:34:56.789123456")
 
-        # invalid
         for freq, msg in [
             ("Y", "<YearEnd: month=12> is a non-fixed frequency"),
             ("M", "<MonthEnd> is a non-fixed frequency"),
@@ -561,7 +351,7 @@ class TestTimedeltas:
     def test_contains(self):
         # Checking for any NaT-like objects
         # GH 13603
-        td = to_timedelta(range(5), unit="d") + pd.offsets.Hour(1)
+        td = to_timedelta(range(5), unit="d") + offsets.Hour(1)
         for v in [NaT, None, float("nan"), np.nan]:
             assert not (v in td)
 
@@ -652,29 +442,6 @@ class TestTimedeltas:
         with pytest.raises(ValueError):
             Timedelta("- 1days, 00")
 
-    def test_overflow(self):
-        # GH 9442
-        s = Series(pd.date_range("20130101", periods=100000, freq="H"))
-        s[0] += Timedelta("1s 1ms")
-
-        # mean
-        result = (s - s.min()).mean()
-        expected = Timedelta((TimedeltaIndex((s - s.min())).asi8 / len(s)).sum())
-
-        # the computation is converted to float so
-        # might be some loss of precision
-        assert np.allclose(result.value / 1000, expected.value / 1000)
-
-        # sum
-        msg = "overflow in timedelta operation"
-        with pytest.raises(ValueError, match=msg):
-            (s - s.min()).sum()
-        s1 = s[0:10000]
-        with pytest.raises(ValueError, match=msg):
-            (s1 - s1.min()).sum()
-        s2 = s[0:1000]
-        result = (s2 - s2.min()).sum()
-
     def test_pickle(self):
 
         v = Timedelta("1 days 10:11:12.0123456")
@@ -690,7 +457,7 @@ class TestTimedeltas:
         d = {td: 2}
         assert d[v] == 2
 
-        tds = timedelta_range("1 second", periods=20)
+        tds = [Timedelta(seconds=1) + Timedelta(days=n) for n in range(20)]
         assert all(hash(td) == hash(td.to_pytimedelta()) for td in tds)
 
         # python timedeltas drop ns resolution
@@ -734,57 +501,6 @@ class TestTimedeltas:
         assert (Timedelta("30S").total_seconds() - 30.0) < 1e-20
         assert (30.0 - Timedelta("30S").total_seconds()) < 1e-20
 
-    def test_timedelta_arithmetic(self):
-        data = Series(["nat", "32 days"], dtype="timedelta64[ns]")
-        deltas = [timedelta(days=1), Timedelta(1, unit="D")]
-        for delta in deltas:
-            result_method = data.add(delta)
-            result_operator = data + delta
-            expected = Series(["nat", "33 days"], dtype="timedelta64[ns]")
-            tm.assert_series_equal(result_operator, expected)
-            tm.assert_series_equal(result_method, expected)
-
-            result_method = data.sub(delta)
-            result_operator = data - delta
-            expected = Series(["nat", "31 days"], dtype="timedelta64[ns]")
-            tm.assert_series_equal(result_operator, expected)
-            tm.assert_series_equal(result_method, expected)
-            # GH 9396
-            result_method = data.div(delta)
-            result_operator = data / delta
-            expected = Series([np.nan, 32.0], dtype="float64")
-            tm.assert_series_equal(result_operator, expected)
-            tm.assert_series_equal(result_method, expected)
-
-    def test_apply_to_timedelta(self):
-        timedelta_NaT = to_timedelta("NaT")
-
-        list_of_valid_strings = ["00:00:01", "00:00:02"]
-        a = to_timedelta(list_of_valid_strings)
-        b = Series(list_of_valid_strings).apply(to_timedelta)
-        # Can't compare until apply on a Series gives the correct dtype
-        # assert_series_equal(a, b)
-
-        list_of_strings = ["00:00:01", np.nan, NaT, timedelta_NaT]
-
-        # TODO: unused?
-        a = to_timedelta(list_of_strings)  # noqa
-        b = Series(list_of_strings).apply(to_timedelta)  # noqa
-        # Can't compare until apply on a Series gives the correct dtype
-        # assert_series_equal(a, b)
-
-    def test_components(self):
-        rng = timedelta_range("1 days, 10:11:12", periods=2, freq="s")
-        rng.components
-
-        # with nat
-        s = Series(rng)
-        s[1] = np.nan
-
-        result = s.dt.components
-        assert not result.iloc[0].isna().all()
-        assert result.iloc[1].isna().all()
-
     def test_resolution_string(self):
         assert Timedelta(days=1).resolution_string == "D"
         assert Timedelta(days=1, hours=6).resolution_string == "H"
diff --git a/pandas/tests/series/test_analytics.py b/pandas/tests/series/test_analytics.py
index 6f45b7215..149d0aae8 100644
--- a/pandas/tests/series/test_analytics.py
+++ b/pandas/tests/series/test_analytics.py
@@ -209,3 +209,27 @@ class TestSeriesAnalytics:
         )
         with pytest.raises(ValueError, match=msg):
             np.sum(s, keepdims=True)
+
+    def test_td64_summation_overflow(self):
+        # GH 9442
+        s = pd.Series(pd.date_range("20130101", periods=100000, freq="H"))
+        s[0] += pd.Timedelta("1s 1ms")
+
+        # mean
+        result = (s - s.min()).mean()
+        expected = pd.Timedelta((pd.TimedeltaIndex((s - s.min())).asi8 / len(s)).sum())
+
+        # the computation is converted to float so
+        # might be some loss of precision
+        assert np.allclose(result.value / 1000, expected.value / 1000)
+
+        # sum
+        msg = "overflow in timedelta operation"
+        with pytest.raises(ValueError, match=msg):
+            (s - s.min()).sum()
+
+        s1 = s[0:10000]
+        with pytest.raises(ValueError, match=msg):
+            (s1 - s1.min()).sum()
+        s2 = s[0:1000]
+        (s2 - s2.min()).sum()
diff --git a/pandas/tests/series/test_apply.py b/pandas/tests/series/test_apply.py
index a4c55a80a..dbe3ca27f 100644
--- a/pandas/tests/series/test_apply.py
+++ b/pandas/tests/series/test_apply.py
@@ -787,3 +787,18 @@ class TestSeriesMap:
         result = ser.map(lambda val: str(val)).to_dict()
         expected = {0: "0.3333333333333333"}
         assert result == expected
+
+    def test_apply_to_timedelta(self):
+        list_of_valid_strings = ["00:00:01", "00:00:02"]
+        a = pd.to_timedelta(list_of_valid_strings)
+        b = Series(list_of_valid_strings).apply(pd.to_timedelta)
+        # FIXME: dont leave commented-out
+        # Can't compare until apply on a Series gives the correct dtype
+        # assert_series_equal(a, b)
+
+        list_of_strings = ["00:00:01", np.nan, pd.NaT, pd.NaT]
+
+        a = pd.to_timedelta(list_of_strings)  # noqa
+        b = Series(list_of_strings).apply(pd.to_timedelta)  # noqa
+        # Can't compare until apply on a Series gives the correct dtype
+        # assert_series_equal(a, b)

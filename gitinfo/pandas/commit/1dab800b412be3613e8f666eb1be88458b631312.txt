commit 1dab800b412be3613e8f666eb1be88458b631312
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Mar 27 13:37:32 2017 -0400

    BUG: index_names can be None when processing date conversions
    
    closes #15820
    closes #11544

diff --git a/doc/source/whatsnew/v0.19.0.txt b/doc/source/whatsnew/v0.19.0.txt
index 11df0afb1..9b003034a 100644
--- a/doc/source/whatsnew/v0.19.0.txt
+++ b/doc/source/whatsnew/v0.19.0.txt
@@ -517,7 +517,6 @@ Other enhancements
 - The ``pd.read_json`` and ``DataFrame.to_json`` has gained support for reading and writing json lines with ``lines`` option see :ref:`Line delimited json <io.jsonl>` (:issue:`9180`)
 - :func:`read_excel` now supports the true_values and false_values keyword arguments (:issue:`13347`)
 - ``groupby()`` will now accept a scalar and a single-element list for specifying ``level`` on a non-``MultiIndex`` grouper. (:issue:`13907`)
-<<<<<<< HEAD
 - Non-convertible dates in an excel date column will be returned without conversion and the column will be ``object`` dtype, rather than raising an exception (:issue:`10001`).
 - ``pd.Timedelta(None)`` is now accepted and will return ``NaT``, mirroring ``pd.Timestamp`` (:issue:`13687`)
 - ``pd.read_stata()`` can now handle some format 111 files, which are produced by SAS when generating Stata dta files (:issue:`11526`)
@@ -525,9 +524,6 @@ Other enhancements
   series or indices. This behaves like a standard binary operator with regards
   to broadcasting rules (:issue:`14208`).
 
-=======
-- Re-enable the ``parse_dates`` keyword of ``read_excel`` to parse string columns as dates (:issue:`14326`)
->>>>>>> PR_TOOL_MERGE_PR_14326
 
 .. _whatsnew_0190.api:
 
diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 3ab69e1ff..fdf34e0d1 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -270,7 +270,7 @@ To convert a ``SparseDataFrame`` back to sparse SciPy matrix in COO format, you
 
 .. _whatsnew_0200.enhancements.other:
 
-Other enhancements
+Other Enhancements
 ^^^^^^^^^^^^^^^^^^
 
 - Integration with the ``feather-format``, including a new top-level ``pd.read_feather()`` and ``DataFrame.to_feather()`` method, see :ref:`here <io.feather>`.
@@ -314,6 +314,7 @@ Other enhancements
 - ``pd.types.concat.union_categoricals`` gained the ``ignore_ordered`` argument to allow ignoring the ordered attribute of unioned categoricals (:issue:`13410`). See the :ref:`categorical union docs <categorical.union>` for more information.
 - ``pandas.io.json.json_normalize()`` with an empty ``list`` will return an empty ``DataFrame`` (:issue:`15534`)
 - ``pd.DataFrame.to_latex`` and ``pd.DataFrame.to_string`` now allow optional header aliases. (:issue:`15536`)
+- Re-enable the ``parse_dates`` keyword of ``read_excel`` to parse string columns as dates (:issue:`14326`)
 
 .. _ISO 8601 duration: https://en.wikipedia.org/wiki/ISO_8601#Durations
 
diff --git a/pandas/io/excel.py b/pandas/io/excel.py
index e7a8b71a5..d324855bc 100644
--- a/pandas/io/excel.py
+++ b/pandas/io/excel.py
@@ -344,7 +344,7 @@ class ExcelFile(object):
             raise NotImplementedError("chunksize keyword of read_excel "
                                       "is not implemented")
 
-        if parse_dates is True and not index_col:
+        if parse_dates is True and index_col is None:
             warn("The 'parse_dates=True' keyword of read_excel was provided"
                  " without an 'index_col' keyword value.")
 
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 45c62b224..30b88de91 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -1176,13 +1176,18 @@ class ParserBase(object):
         if isinstance(self.parse_dates, bool):
             return self.parse_dates
         else:
-            name = self.index_names[i]
+            if self.index_names is not None:
+                name = self.index_names[i]
+            else:
+                name = None
             j = self.index_col[i]
 
             if is_scalar(self.parse_dates):
-                return (j == self.parse_dates) or (name == self.parse_dates)
+                return ((j == self.parse_dates) or
+                        (name is not None and name == self.parse_dates))
             else:
-                return (j in self.parse_dates) or (name in self.parse_dates)
+                return ((j in self.parse_dates) or
+                        (name is not None and name in self.parse_dates))
 
     def _extract_multi_indexer_columns(self, header, index_names, col_names,
                                        passed_names=False):
@@ -1352,6 +1357,7 @@ class ParserBase(object):
 
     def _agg_index(self, index, try_parse_dates=True):
         arrays = []
+
         for i, arr in enumerate(index):
 
             if (try_parse_dates and self._should_parse_dates(i)):
@@ -1512,6 +1518,7 @@ class ParserBase(object):
 
     def _do_date_conversions(self, names, data):
         # returns data, columns
+
         if self.parse_dates is not None:
             data, names = _process_date_conversion(
                 data, self._date_conv, self.parse_dates, self.index_col,
diff --git a/pandas/tests/io/test_excel.py b/pandas/tests/io/test_excel.py
index df7770823..256a37e92 100644
--- a/pandas/tests/io/test_excel.py
+++ b/pandas/tests/io/test_excel.py
@@ -938,12 +938,17 @@ class XlrdTests(ReadingTestsBase):
             res = read_excel(pth)
             tm.assert_frame_equal(df2, res)
 
-            res = read_excel(pth, parse_dates=['date_strings'])
+            # no index_col specified when parse_dates is True
+            with tm.assert_produces_warning():
+                res = read_excel(pth, parse_dates=True)
+                tm.assert_frame_equal(df2, res)
+
+            res = read_excel(pth, parse_dates=['date_strings'], index_col=0)
             tm.assert_frame_equal(df, res)
 
             dateparser = lambda x: pd.datetime.strptime(x, '%m/%d/%Y')
             res = read_excel(pth, parse_dates=['date_strings'],
-                             date_parser=dateparser)
+                             date_parser=dateparser, index_col=0)
             tm.assert_frame_equal(df, res)
 
     def test_read_excel_skiprows_list(self):

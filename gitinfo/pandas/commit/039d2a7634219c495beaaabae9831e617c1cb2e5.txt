commit 039d2a7634219c495beaaabae9831e617c1cb2e5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Feb 17 18:23:34 2012 -0500

    ENH: optimize fillna for 2D blocks, add inplace option, GH #788, #786

diff --git a/RELEASE.rst b/RELEASE.rst
index d764c904b..0a973ed00 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -22,6 +22,16 @@ Where to get it
 * Binary installers on PyPI: http://pypi.python.org/pypi/pandas
 * Documentation: http://pandas.pydata.org
 
+pandas 0.7.1
+============
+
+**Release date:** NOT YET RELEASED
+
+**Bug fixes**
+
+  - Fix memory leak when inserting large number of columns into a single
+    DataFrame (#790)
+
 pandas 0.7.0
 ============
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 0378a9b25..f8889cb7e 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -562,6 +562,13 @@ def _ensure_object(arr):
         arr = arr.astype('O')
     return arr
 
+def _clean_fill_method(method):
+    method = method.lower()
+    if method == 'ffill':
+        method = 'pad'
+    if method == 'bfill':
+        method = 'backfill'
+    return method
 
 def save(obj, path):
     """
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0461cf8c0..1304f98b2 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2307,7 +2307,7 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Filling NA's
 
-    def fillna(self, value=None, method='pad'):
+    def fillna(self, value=None, method='pad', inplace=False):
         """
         Fill NA/NaN values using the specified method. Member Series /
         TimeSeries are filled separately
@@ -2320,6 +2320,11 @@ class DataFrame(NDFrame):
             backfill / bfill: use NEXT valid observation to fill gap
         value : any kind (should be same type as array)
             Value to use to fill holes (e.g. 0)
+        inplace : boolean, default False
+            If True, fill the DataFrame in place. Note: this will modify any
+            other views on this DataFrame, like if you took a no-copy slice of
+            an existing DataFrame, for example a column in a DataFrame. Returns
+            a reference to the filled object, which is self if inplace=True
 
         See also
         --------
@@ -2329,18 +2334,38 @@ class DataFrame(NDFrame):
         -------
         filled : DataFrame
         """
+        from pandas.core.internals import FloatBlock, ObjectBlock
+
+        self._consolidate_inplace()
+
         if value is None:
-            result = {}
-            series = self._series
-            for col, s in series.iteritems():
-                result[col] = s.fillna(method=method, value=value)
-            return self._constructor(result, index=self.index,
-                                     columns=self.columns)
+            new_blocks = []
+
+            method = com._clean_fill_method(method)
+            for block in self._data.blocks:
+                if isinstance(block, (FloatBlock, ObjectBlock)):
+                    newb = block.interpolate(method, inplace=inplace)
+                else:
+                    newb = block if inplace else block.copy()
+                new_blocks.append(newb)
+
+            new_data = BlockManager(new_blocks, self._data.axes)
+
+            # series = self._series
+            # for col, s in series.iteritems():
+            #     result[col] = s.fillna(method=method, value=value)
+            # return self._constructor(result, index=self.index,
+            #                          columns=self.columns)
         else:
             # Float type values
             if len(self.columns) == 0:
                 return self
             new_data = self._data.fillna(value)
+
+        if inplace:
+            self._data = new_data
+            return self
+        else:
             return self._constructor(new_data)
 
     #----------------------------------------------------------------------
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 2b3ce3fed..556826dc8 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -209,6 +209,39 @@ class Block(object):
         new_values.flat[mask] = value
         return make_block(new_values, self.items, self.ref_items)
 
+    def interpolate(self, method='pad', inplace=False):
+        values = self.values if inplace else self.values.copy()
+
+        if values.ndim != 2:
+            raise NotImplementedError
+
+        if method == 'pad':
+            _pad(values)
+        else:
+            _backfill(values)
+
+        return make_block(values, self.items, self.ref_items)
+
+def _pad(values):
+    if com.is_float_dtype(values):
+        _method = lib.pad_2d_inplace_float64
+    elif values.dtype == np.object_:
+        _method = lib.pad_2d_inplace_object
+    else:
+        raise ValueError('Invalid dtype for padding')
+
+    _method(values, com.isnull(values).view(np.uint8))
+
+def _backfill(values):
+    if com.is_float_dtype(values):
+        _method = lib.backfill_2d_inplace_float64
+    elif values.dtype == np.object_:
+        _method = lib.backfill_2d_inplace_object
+    else:
+        raise ValueError('Invalid dtype for padding')
+
+    _method(values, com.isnull(values).view(np.uint8))
+
 #-------------------------------------------------------------------------------
 # Is this even possible?
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 3105248d6..b0f208378 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1832,7 +1832,7 @@ copy : boolean, default False
 
     truncate = generic.truncate
 
-    def fillna(self, value=None, method='pad'):
+    def fillna(self, value=None, method='pad', inplace=False):
         """
         Fill NA/NaN values using the specified method
 
@@ -1844,6 +1844,10 @@ copy : boolean, default False
             Method to use for filling holes in reindexed Series
             pad / ffill: propagate last valid observation forward to next valid
             backfill / bfill: use NEXT valid observation to fill gap
+        inplace : boolean, default False
+            If True, fill the Series in place. Note: this will modify any other
+            views on this Series, for example a column in a DataFrame. Returns
+            a reference to the filled object, which is self if inplace=True
 
         See also
         --------
@@ -1853,22 +1857,16 @@ copy : boolean, default False
         -------
         filled : Series
         """
+        mask = isnull(self.values)
+
         if value is not None:
-            newSeries = self.copy()
-            newSeries[isnull(newSeries)] = value
-            return newSeries
+            result = self.copy() if not inplace else self
+            np.putmask(result, mask, value)
         else:
             if method is None:  # pragma: no cover
                 raise ValueError('must specify a fill method')
 
-            method = method.lower()
-
-            if method == 'ffill':
-                method = 'pad'
-            if method == 'bfill':
-                method = 'backfill'
-
-            mask = isnull(self.values)
+            method = com._clean_fill_method(method)
 
             # sadness. for Python 2.5 compatibility
             mask = mask.astype(np.uint8)
@@ -1878,8 +1876,14 @@ copy : boolean, default False
             elif method == 'backfill':
                 indexer = lib.get_backfill_indexer(mask)
 
-            new_values = self.values.take(indexer)
-            return Series(new_values, index=self.index, name=self.name)
+            if inplace:
+                self.values[:] = self.values.take(indexer)
+                result = self
+            else:
+                new_values = self.values.take(indexer)
+                result = Series(new_values, index=self.index, name=self.name)
+
+        return result
 
     def isin(self, values):
         """
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 66f23d390..09d2173c3 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -268,6 +268,105 @@ def pad_%(name)s(ndarray[%(c_type)s] oldIndex,
 
 """
 
+pad_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_%(name)s(ndarray[%(c_type)s] oldIndex,
+                 ndarray[%(c_type)s] newIndex,
+                 dict oldMap, dict newMap):
+    cdef Py_ssize_t i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef Py_ssize_t newPos, oldPos
+    cdef %(c_type)s prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    if oldLength == 0 or newLength == 0:
+        return fill_vec
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+"""
+
+pad_2d_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_%(name)s(ndarray[%(c_type)s, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef %(c_type)s val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+"""
+
+backfill_2d_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_%(name)s(ndarray[%(c_type)s, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef %(c_type)s val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+"""
+
+
 is_monotonic_template = """@cython.boundscheck(False)
 @cython.wraparound(False)
 def is_monotonic_%(name)s(ndarray[%(c_type)s] arr):
@@ -638,6 +737,8 @@ templates_1d = [map_indices_template,
                 merge_indexer_template,
                 pad_template,
                 backfill_template,
+                pad_2d_template,
+                backfill_2d_template,
                 take_1d_template,
                 is_monotonic_template,
                 groupby_template,
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index ba1eb0a31..7f8ada117 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -752,6 +752,178 @@ def backfill_bool(ndarray[uint8_t] oldIndex,
     return fill_vec
 
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_float64(ndarray[float64_t, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef float64_t val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_object(ndarray[object, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef object val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_int32(ndarray[int32_t, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef int32_t val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_int64(ndarray[int64_t, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef int64_t val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_2d_inplace_bool(ndarray[uint8_t, ndim=2] values,
+                            ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef uint8_t val
+
+    K, N = (<object> values).shape
+
+    val = np.nan
+
+    for j in range(K):
+        val = values[j, 0]
+        for i in range(N):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_float64(ndarray[float64_t, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef float64_t val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_object(ndarray[object, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef object val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_int32(ndarray[int32_t, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef int32_t val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_int64(ndarray[int64_t, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef int64_t val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_2d_inplace_bool(ndarray[uint8_t, ndim=2] values,
+                                 ndarray[uint8_t, ndim=2] mask):
+    cdef Py_ssize_t i, j, N, K
+    cdef uint8_t val
+
+    K, N = (<object> values).shape
+
+    for j in range(K):
+        val = values[j, N - 1]
+        for i in range(N - 1, -1 , -1):
+            if mask[j, i]:
+                values[j, i] = val
+            else:
+                val = values[j, i]
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 7f5d1cd10..f8978da54 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2842,6 +2842,27 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         result = self.mixed_frame.fillna(value=0)
 
+    def test_fillna_inplace(self):
+        df = DataFrame(np.random.randn(10, 4))
+        df[1][:4] = np.nan
+        df[3][-4:] = np.nan
+
+        expected = df.fillna(value=0)
+        self.assert_(expected is not df)
+
+        df2 = df.fillna(value=0, inplace=True)
+        self.assert_(df2 is df)
+        assert_frame_equal(df2, expected)
+
+        df[1][:4] = np.nan
+        df[3][-4:] = np.nan
+        expected = df.fillna()
+        self.assert_(expected is not df)
+
+        df2 = df.fillna(inplace=True)
+        self.assert_(df2 is df)
+        assert_frame_equal(df2, expected)
+
     def test_truncate(self):
         offset = datetools.bday
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 08166fbf7..bf6e8a71b 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1991,6 +1991,16 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         expected = Series([1., 1., 3., 3., nan], x.index)
         assert_series_equal(filled, expected)
 
+    def test_fillna_inplace(self):
+        x = Series([nan, 1., nan, 3., nan],['z','a','b','c','d'])
+        y = x.copy()
+
+        y2 = y.fillna(value=0, inplace=True)
+        self.assert_(y is y2)
+
+        expected = x.fillna(value=0)
+        assert_series_equal(y2, expected)
+
     def test_asfreq(self):
         ts = Series([0., 1., 2.], index=[datetime(2009, 10, 30),
                                          datetime(2009, 11, 30),
diff --git a/vb_suite/reindex.py b/vb_suite/reindex.py
index d0c0ab7c9..9c307131a 100644
--- a/vb_suite/reindex.py
+++ b/vb_suite/reindex.py
@@ -134,3 +134,16 @@ statement = "df.drop_duplicates(['key1', 'key2'])"
 frame_drop_duplicates = Benchmark(statement, setup,
                                   name='frame_drop_duplicates',
                                   start_date=datetime(2011, 11, 15))
+
+#----------------------------------------------------------------------
+# fillna, many columns
+
+
+setup = common_setup + """
+values = np.random.randn(1000, 1000)
+values[::2] = np.nan
+df = DataFrame(values)
+"""
+
+frame_fillna_many_columns_pad = Benchmark("df.fillna(method='pad')",
+                                          setup)

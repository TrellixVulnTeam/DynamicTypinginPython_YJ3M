commit 275a9043f53986877490f8aa6a6e5101db8fc235
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Apr 10 12:54:37 2012 -0400

    TST: test coverage for 0.7.3, remove deprecated sandbox.functions

diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1e981e919..de5613d7f 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2085,7 +2085,6 @@ copy : boolean, default False
         Returns
         -------
         is_between : Series
-            NAs, if any, will be preserved
         """
         if inclusive:
             lmask = self >= left
@@ -2094,12 +2093,7 @@ copy : boolean, default False
             lmask = self > left
             rmask = self < right
 
-        mask = lmask & rmask
-        if mask.dtype == np.object_:
-            np.putmask(mask, isnull(mask), False)
-            mask = mask.astype(bool)
-
-        return mask
+        return lmask & rmask
 
     @classmethod
     def from_csv(cls, path, sep=',', parse_dates=True, header=None,
diff --git a/pandas/sandbox/functions.py b/pandas/sandbox/functions.py
deleted file mode 100644
index 02adc7b2e..000000000
--- a/pandas/sandbox/functions.py
+++ /dev/null
@@ -1,120 +0,0 @@
-from pandas.core.common import isnull
-import numpy as np
-
-#-------------------------------------------------------------------------------
-# NaN-friendly reductions and such
-
-def reduce_mean(values, index, buckets, inclusive=False):
-    def _reduceat_mean(values, mask, locs):
-        the_sum = np.add.reduceat(values, locs)
-        the_count = np.add.reduceat(-mask, locs)
-        return the_sum / the_count
-    return _reduce_generic(values, index, buckets, _reduceat_mean,
-                           inclusive=inclusive, na_fill=0)
-
-
-def _reduceat_var(values, mask, locs):
-    XX = np.add.reduceat(values ** 2, locs)
-    X = np.add.reduceat(values, locs)
-    nobs = np.add.reduceat(-mask, locs)
-    return (XX - X * X) / (nobs - 1)
-
-def reduce_std(values, index, buckets, inclusive=False):
-    result = _reduce_generic(values, index, buckets, _reduceat_var,
-                             inclusive=inclusive, na_fill=0)
-    return np.sqrt(result)
-
-def reduce_prod(values, index, buckets, inclusive=False):
-    def _reduceat_prod(values, mask, locs):
-        return np.multiply.reduceat(values, locs)
-    return _reduce_generic(values, index, buckets, _reduceat_prod,
-                           inclusive=inclusive, na_fill=1)
-
-def reduce_min(values, index, buckets, inclusive=False):
-    def _reduceat_min(values, mask, locs):
-        return np.minimum.reduceat(values, locs)
-    return _reduce_generic(values, index, buckets, _reduceat_min,
-                           inclusive=inclusive, na_fill=np.inf)
-
-def reduce_max(values, index, buckets, inclusive=False):
-    def _reduceat_max(values, mask, locs):
-        return np.maximum.reduceat(values, locs)
-    return _reduce_generic(values, index, buckets, _reduceat_max,
-                           inclusive=inclusive, na_fill=-np.inf)
-
-def _reduce_generic(values, index, buckets, freduce, inclusive=False,
-                    na_fill=None):
-    """
-
-    """
-    locs = _bucket_locs(index, buckets, inclusive=inclusive)
-
-    values = np.asarray(values)
-    mask = isnull(values)
-
-    if na_fill is not None:
-        values = values.copy()
-        np.putmask(values, mask, na_fill)
-
-    return freduce(values, mask, locs)
-
-def _reduceat_count(values, mask, locs):
-    return np.add.reduceat(-mask, locs)
-
-def _bucket_locs(index, buckets, inclusive=False):
-    if inclusive:
-        locs = index.searchsorted(buckets, side='left')
-    else:
-        locs = index.searchsorted(buckets, side='right')
-
-    return locs
-
-def get_bucket(date, bucks):
-    if date in bucks:
-        idx = bucks.indexMap[date] + 1
-    else:
-        idx = bucks.searchsorted(date)
-    return bucks[idx]
-
-def dumb_way(series, buckets):
-    sampled2 = hfseries.groupby(lambda x: get_bucket(x, buckets)).mean()
-    sampled2 = sampled2.reindex(buckets)
-    return sampled2
-
-def ts_upsample(dates, buckets, values, aggfunc, inclusive=True):
-    '''
-    put something here
-    '''
-    nbuckets = len(buckets)
-    nvalues = len(dates)
-    output = np.empty(nbuckets, dtype=float)
-
-    if inclusive:
-        _check = lambda x, y: x < y
-    else:
-        _check = lambda x, y: x <= y
-
-    j = 0
-    for i, bound in enumerate(buckets):
-        next_bound = buckets[i + 1]
-        jstart = j
-
-        while _check(dates[j], next_bound) and j < nvalues:
-            j += 1
-
-        output[i] = aggfunc(values[jstart:j])
-
-    return Series(output, index=buckets)
-
-if __name__ == '__main__':
-    N = 1000000
-    K = 1000
-
-    values = np.random.randn(N)
-    index = np.arange(N).astype(object)
-    buckets = np.arange(0, N, N // K).astype(object)
-
-    result = reduce_mean(values, index, buckets)
-
-    import pandas._tseries as tseries
-    tseries.ts_upsample_mean(index, buckets, values)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 9eb7f7a7a..27fd004a0 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2046,6 +2046,11 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         fmt.reset_printoptions()
 
+    def test_very_wide_info_repr(self):
+        df = DataFrame(np.random.randn(10, 20),
+                       columns=[tm.rands(10) for _ in xrange(20)])
+        repr(df)
+
     def test_head_tail(self):
         assert_frame_equal(self.frame.head(), self.frame[:5])
         assert_frame_equal(self.frame.tail(), self.frame[-5:])
@@ -2703,8 +2708,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.tsframe.info(buf=io)
 
         frame = DataFrame(np.random.randn(5, 3))
+
+        import sys
+        sys.stdout = StringIO()
         frame.info()
         frame.info(verbose=False)
+        sys.stdout = sys.__stdout__
 
     def test_dtypes(self):
         self.mixed_frame['bool'] = self.mixed_frame['A'] > 0

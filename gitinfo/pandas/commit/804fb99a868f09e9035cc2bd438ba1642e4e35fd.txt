commit 804fb99a868f09e9035cc2bd438ba1642e4e35fd
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Nov 2 15:49:22 2017 -0700

    Index tests in the wrong places (#18074)

diff --git a/pandas/tests/indexes/datetimes/test_astype.py b/pandas/tests/indexes/datetimes/test_astype.py
index 46be24b90..0197fc4c5 100644
--- a/pandas/tests/indexes/datetimes/test_astype.py
+++ b/pandas/tests/indexes/datetimes/test_astype.py
@@ -117,6 +117,15 @@ class TestDatetimeIndex(object):
                                  dtype='datetime64[ns]')
         tm.assert_index_equal(result, expected)
 
+    def test_astype_object(self):
+        rng = date_range('1/1/2000', periods=20)
+
+        casted = rng.astype('O')
+        exp_values = list(rng)
+
+        tm.assert_index_equal(casted, Index(exp_values, dtype=np.object_))
+        assert casted.tolist() == exp_values
+
     def test_astype_raises(self):
         # GH 13149, GH 13209
         idx = DatetimeIndex(['2016-05-16', 'NaT', NaT, np.NaN])
@@ -287,12 +296,18 @@ class TestToPeriod(object):
         assert result == expected
         tm.assert_index_equal(ts.to_period(), xp)
 
-    def test_astype_object(self):
-        # NumPy 1.6.1 weak ns support
-        rng = date_range('1/1/2000', periods=20)
-
-        casted = rng.astype('O')
-        exp_values = list(rng)
-
-        tm.assert_index_equal(casted, Index(exp_values, dtype=np.object_))
-        assert casted.tolist() == exp_values
+    def test_to_period_nofreq(self):
+        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-04'])
+        pytest.raises(ValueError, idx.to_period)
+
+        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'],
+                            freq='infer')
+        assert idx.freqstr == 'D'
+        expected = pd.PeriodIndex(['2000-01-01', '2000-01-02',
+                                   '2000-01-03'], freq='D')
+        tm.assert_index_equal(idx.to_period(), expected)
+
+        # GH 7606
+        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'])
+        assert idx.freqstr is None
+        tm.assert_index_equal(idx.to_period(), expected)
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index 88bf8a402..cc6eeb44c 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -8,10 +8,10 @@ import pandas as pd
 import pandas.util.testing as tm
 from pandas.compat import lrange
 from pandas.compat.numpy import np_datetime64_compat
-from pandas import (DatetimeIndex, Index, date_range, Series, DataFrame,
+from pandas import (DatetimeIndex, Index, date_range, DataFrame,
                     Timestamp, datetime, offsets)
 
-from pandas.util.testing import assert_series_equal, assert_almost_equal
+from pandas.util.testing import assert_almost_equal
 
 randn = np.random.randn
 
@@ -223,22 +223,6 @@ class TestDatetimeIndex(object):
         # it works
         rng.join(idx, how='outer')
 
-    def test_to_period_nofreq(self):
-        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-04'])
-        pytest.raises(ValueError, idx.to_period)
-
-        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'],
-                            freq='infer')
-        assert idx.freqstr == 'D'
-        expected = pd.PeriodIndex(['2000-01-01', '2000-01-02',
-                                   '2000-01-03'], freq='D')
-        tm.assert_index_equal(idx.to_period(), expected)
-
-        # GH 7606
-        idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'])
-        assert idx.freqstr is None
-        tm.assert_index_equal(idx.to_period(), expected)
-
     def test_comparisons_coverage(self):
         rng = date_range('1/1/2000', periods=10)
 
@@ -567,13 +551,6 @@ class TestDatetimeIndex(object):
         assert cols.dtype == joined.dtype
         tm.assert_numpy_array_equal(cols.values, joined.values)
 
-    def test_slice_keeps_name(self):
-        # GH4226
-        st = pd.Timestamp('2013-07-01 00:00:00', tz='America/Los_Angeles')
-        et = pd.Timestamp('2013-07-02 00:00:00', tz='America/Los_Angeles')
-        dr = pd.date_range(st, et, freq='H', name='timebucket')
-        assert dr[1:].name == dr.name
-
     def test_join_self(self):
         index = date_range('1/1/2000', periods=10)
         kinds = 'outer', 'inner', 'left', 'right'
@@ -687,59 +664,3 @@ class TestDatetimeIndex(object):
             arr, res = obj.factorize()
             tm.assert_numpy_array_equal(arr, np.arange(12, dtype=np.intp))
             tm.assert_index_equal(res, idx)
-
-    def test_slice_with_negative_step(self):
-        ts = Series(np.arange(20),
-                    date_range('2014-01-01', periods=20, freq='MS'))
-        SLC = pd.IndexSlice
-
-        def assert_slices_equivalent(l_slc, i_slc):
-            assert_series_equal(ts[l_slc], ts.iloc[i_slc])
-            assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])
-            assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])
-
-        assert_slices_equivalent(SLC[Timestamp('2014-10-01')::-1], SLC[9::-1])
-        assert_slices_equivalent(SLC['2014-10-01'::-1], SLC[9::-1])
-
-        assert_slices_equivalent(SLC[:Timestamp('2014-10-01'):-1], SLC[:8:-1])
-        assert_slices_equivalent(SLC[:'2014-10-01':-1], SLC[:8:-1])
-
-        assert_slices_equivalent(SLC['2015-02-01':'2014-10-01':-1],
-                                 SLC[13:8:-1])
-        assert_slices_equivalent(SLC[Timestamp('2015-02-01'):Timestamp(
-            '2014-10-01'):-1], SLC[13:8:-1])
-        assert_slices_equivalent(SLC['2015-02-01':Timestamp('2014-10-01'):-1],
-                                 SLC[13:8:-1])
-        assert_slices_equivalent(SLC[Timestamp('2015-02-01'):'2014-10-01':-1],
-                                 SLC[13:8:-1])
-
-        assert_slices_equivalent(SLC['2014-10-01':'2015-02-01':-1], SLC[:0])
-
-    def test_slice_with_zero_step_raises(self):
-        ts = Series(np.arange(20),
-                    date_range('2014-01-01', periods=20, freq='MS'))
-        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
-                               lambda: ts[::0])
-        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
-                               lambda: ts.loc[::0])
-        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
-                               lambda: ts.loc[::0])
-
-    def test_slice_bounds_empty(self):
-        # GH 14354
-        empty_idx = DatetimeIndex(freq='1H', periods=0, end='2015')
-
-        right = empty_idx._maybe_cast_slice_bound('2015-01-02', 'right', 'loc')
-        exp = Timestamp('2015-01-02 23:59:59.999999999')
-        assert right == exp
-
-        left = empty_idx._maybe_cast_slice_bound('2015-01-02', 'left', 'loc')
-        exp = Timestamp('2015-01-02 00:00:00')
-        assert left == exp
-
-    def test_slice_duplicate_monotonic(self):
-        # https://github.com/pandas-dev/pandas/issues/16515
-        idx = pd.DatetimeIndex(['2017', '2017'])
-        result = idx._maybe_cast_slice_bound('2017-01-01', 'left', 'loc')
-        expected = Timestamp('2017-01-01')
-        assert result == expected
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 14217ae29..6e66e4a36 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -383,49 +383,6 @@ class TestDatetimeIndexOps(Ops):
                                     tz=tz)
                 assert idx.resolution == expected
 
-    def test_union(self):
-        for tz in self.tz:
-            # union
-            rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
-            expected1 = pd.date_range('1/1/2000', freq='D', periods=10, tz=tz)
-
-            rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
-            expected2 = pd.date_range('1/1/2000', freq='D', periods=8, tz=tz)
-
-            rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other3 = pd.DatetimeIndex([], tz=tz)
-            expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-
-            for rng, other, expected in [(rng1, other1, expected1),
-                                         (rng2, other2, expected2),
-                                         (rng3, other3, expected3)]:
-
-                result_union = rng.union(other)
-                tm.assert_index_equal(result_union, expected)
-
-    def test_difference(self):
-        for tz in self.tz:
-            # diff
-            rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
-            expected1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-
-            rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
-            expected2 = pd.date_range('1/1/2000', freq='D', periods=3, tz=tz)
-
-            rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-            other3 = pd.DatetimeIndex([], tz=tz)
-            expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
-
-            for rng, other, expected in [(rng1, other1, expected1),
-                                         (rng2, other2, expected2),
-                                         (rng3, other3, expected3)]:
-                result_diff = rng.difference(other)
-                tm.assert_index_equal(result_diff, expected)
-
     def test_comp_nat(self):
         left = pd.DatetimeIndex([pd.Timestamp('2011-01-01'), pd.NaT,
                                  pd.Timestamp('2011-01-03')])
diff --git a/pandas/tests/indexes/datetimes/test_partial_slicing.py b/pandas/tests/indexes/datetimes/test_partial_slicing.py
index e7d03aa19..50ee88bd8 100644
--- a/pandas/tests/indexes/datetimes/test_partial_slicing.py
+++ b/pandas/tests/indexes/datetimes/test_partial_slicing.py
@@ -12,6 +12,68 @@ from pandas.util import testing as tm
 
 
 class TestSlicing(object):
+    def test_slice_keeps_name(self):
+        # GH4226
+        st = pd.Timestamp('2013-07-01 00:00:00', tz='America/Los_Angeles')
+        et = pd.Timestamp('2013-07-02 00:00:00', tz='America/Los_Angeles')
+        dr = pd.date_range(st, et, freq='H', name='timebucket')
+        assert dr[1:].name == dr.name
+
+    def test_slice_with_negative_step(self):
+        ts = Series(np.arange(20),
+                    date_range('2014-01-01', periods=20, freq='MS'))
+        SLC = pd.IndexSlice
+
+        def assert_slices_equivalent(l_slc, i_slc):
+            tm.assert_series_equal(ts[l_slc], ts.iloc[i_slc])
+            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])
+            tm.assert_series_equal(ts.loc[l_slc], ts.iloc[i_slc])
+
+        assert_slices_equivalent(SLC[Timestamp('2014-10-01')::-1], SLC[9::-1])
+        assert_slices_equivalent(SLC['2014-10-01'::-1], SLC[9::-1])
+
+        assert_slices_equivalent(SLC[:Timestamp('2014-10-01'):-1], SLC[:8:-1])
+        assert_slices_equivalent(SLC[:'2014-10-01':-1], SLC[:8:-1])
+
+        assert_slices_equivalent(SLC['2015-02-01':'2014-10-01':-1],
+                                 SLC[13:8:-1])
+        assert_slices_equivalent(SLC[Timestamp('2015-02-01'):Timestamp(
+            '2014-10-01'):-1], SLC[13:8:-1])
+        assert_slices_equivalent(SLC['2015-02-01':Timestamp('2014-10-01'):-1],
+                                 SLC[13:8:-1])
+        assert_slices_equivalent(SLC[Timestamp('2015-02-01'):'2014-10-01':-1],
+                                 SLC[13:8:-1])
+
+        assert_slices_equivalent(SLC['2014-10-01':'2015-02-01':-1], SLC[:0])
+
+    def test_slice_with_zero_step_raises(self):
+        ts = Series(np.arange(20),
+                    date_range('2014-01-01', periods=20, freq='MS'))
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
+
+    def test_slice_bounds_empty(self):
+        # GH 14354
+        empty_idx = DatetimeIndex(freq='1H', periods=0, end='2015')
+
+        right = empty_idx._maybe_cast_slice_bound('2015-01-02', 'right', 'loc')
+        exp = Timestamp('2015-01-02 23:59:59.999999999')
+        assert right == exp
+
+        left = empty_idx._maybe_cast_slice_bound('2015-01-02', 'left', 'loc')
+        exp = Timestamp('2015-01-02 00:00:00')
+        assert left == exp
+
+    def test_slice_duplicate_monotonic(self):
+        # https://github.com/pandas-dev/pandas/issues/16515
+        idx = pd.DatetimeIndex(['2017', '2017'])
+        result = idx._maybe_cast_slice_bound('2017-01-01', 'left', 'loc')
+        expected = Timestamp('2017-01-01')
+        assert result == expected
 
     def test_slice_year(self):
         dti = DatetimeIndex(freq='B', start=datetime(2005, 1, 1), periods=500)
diff --git a/pandas/tests/indexes/datetimes/test_setops.py b/pandas/tests/indexes/datetimes/test_setops.py
index ff436e050..5df75338d 100644
--- a/pandas/tests/indexes/datetimes/test_setops.py
+++ b/pandas/tests/indexes/datetimes/test_setops.py
@@ -1,5 +1,6 @@
 from datetime import datetime
 
+import pytest
 import numpy as np
 
 import pandas as pd
@@ -11,14 +12,30 @@ from pandas.tseries.offsets import Minute, BMonthEnd, MonthEnd
 START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 
 
-class TestDatetimeIndex(object):
+class TestDatetimeIndexSetOps(object):
+    tz = [None, 'UTC', 'Asia/Tokyo', 'US/Eastern', 'dateutil/Asia/Singapore',
+          'dateutil/US/Pacific']
 
-    def test_union(self):
-        i1 = Int64Index(np.arange(0, 20, 2))
-        i2 = Int64Index(np.arange(10, 30, 2))
-        result = i1.union(i2)
-        expected = Int64Index(np.arange(0, 30, 2))
-        tm.assert_index_equal(result, expected)
+    @pytest.mark.parametrize("tz", tz)
+    def test_union(self, tz):
+        rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
+        expected1 = pd.date_range('1/1/2000', freq='D', periods=10, tz=tz)
+
+        rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
+        expected2 = pd.date_range('1/1/2000', freq='D', periods=8, tz=tz)
+
+        rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other3 = pd.DatetimeIndex([], tz=tz)
+        expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+
+        for rng, other, expected in [(rng1, other1, expected1),
+                                     (rng2, other2, expected2),
+                                     (rng3, other3, expected3)]:
+
+            result_union = rng.union(other)
+            tm.assert_index_equal(result_union, expected)
 
     def test_union_coverage(self):
         idx = DatetimeIndex(['2000-01-03', '2000-01-01', '2000-01-02'])
@@ -83,62 +100,62 @@ class TestDatetimeIndex(object):
         i1.union(i2)  # Works
         i2.union(i1)  # Fails with "AttributeError: can't set attribute"
 
-    def test_intersection(self):
+    @pytest.mark.parametrize("tz", [None, 'Asia/Tokyo', 'US/Eastern',
+                                    'dateutil/US/Pacific'])
+    def test_intersection(self, tz):
         # GH 4690 (with tz)
-        for tz in [None, 'Asia/Tokyo', 'US/Eastern', 'dateutil/US/Pacific']:
-            base = date_range('6/1/2000', '6/30/2000', freq='D', name='idx')
-
-            # if target has the same name, it is preserved
-            rng2 = date_range('5/15/2000', '6/20/2000', freq='D', name='idx')
-            expected2 = date_range('6/1/2000', '6/20/2000', freq='D',
-                                   name='idx')
-
-            # if target name is different, it will be reset
-            rng3 = date_range('5/15/2000', '6/20/2000', freq='D', name='other')
-            expected3 = date_range('6/1/2000', '6/20/2000', freq='D',
-                                   name=None)
-
-            rng4 = date_range('7/1/2000', '7/31/2000', freq='D', name='idx')
-            expected4 = DatetimeIndex([], name='idx')
-
-            for (rng, expected) in [(rng2, expected2), (rng3, expected3),
-                                    (rng4, expected4)]:
-                result = base.intersection(rng)
-                tm.assert_index_equal(result, expected)
-                assert result.name == expected.name
-                assert result.freq == expected.freq
-                assert result.tz == expected.tz
-
-            # non-monotonic
-            base = DatetimeIndex(['2011-01-05', '2011-01-04',
-                                  '2011-01-02', '2011-01-03'],
-                                 tz=tz, name='idx')
-
-            rng2 = DatetimeIndex(['2011-01-04', '2011-01-02',
-                                  '2011-02-02', '2011-02-03'],
-                                 tz=tz, name='idx')
-            expected2 = DatetimeIndex(
-                ['2011-01-04', '2011-01-02'], tz=tz, name='idx')
-
-            rng3 = DatetimeIndex(['2011-01-04', '2011-01-02',
-                                  '2011-02-02', '2011-02-03'],
-                                 tz=tz, name='other')
-            expected3 = DatetimeIndex(
-                ['2011-01-04', '2011-01-02'], tz=tz, name=None)
-
-            # GH 7880
-            rng4 = date_range('7/1/2000', '7/31/2000', freq='D', tz=tz,
-                              name='idx')
-            expected4 = DatetimeIndex([], tz=tz, name='idx')
-
-            for (rng, expected) in [(rng2, expected2), (rng3, expected3),
-                                    (rng4, expected4)]:
-                result = base.intersection(rng)
-                tm.assert_index_equal(result, expected)
-                assert result.name == expected.name
-                assert result.freq is None
-                assert result.tz == expected.tz
-
+        base = date_range('6/1/2000', '6/30/2000', freq='D', name='idx')
+
+        # if target has the same name, it is preserved
+        rng2 = date_range('5/15/2000', '6/20/2000', freq='D', name='idx')
+        expected2 = date_range('6/1/2000', '6/20/2000', freq='D', name='idx')
+
+        # if target name is different, it will be reset
+        rng3 = date_range('5/15/2000', '6/20/2000', freq='D', name='other')
+        expected3 = date_range('6/1/2000', '6/20/2000', freq='D', name=None)
+
+        rng4 = date_range('7/1/2000', '7/31/2000', freq='D', name='idx')
+        expected4 = DatetimeIndex([], name='idx')
+
+        for (rng, expected) in [(rng2, expected2), (rng3, expected3),
+                                (rng4, expected4)]:
+            result = base.intersection(rng)
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq == expected.freq
+            assert result.tz == expected.tz
+
+        # non-monotonic
+        base = DatetimeIndex(['2011-01-05', '2011-01-04',
+                              '2011-01-02', '2011-01-03'],
+                             tz=tz, name='idx')
+
+        rng2 = DatetimeIndex(['2011-01-04', '2011-01-02',
+                              '2011-02-02', '2011-02-03'],
+                             tz=tz, name='idx')
+        expected2 = DatetimeIndex(['2011-01-04', '2011-01-02'],
+                                  tz=tz, name='idx')
+
+        rng3 = DatetimeIndex(['2011-01-04', '2011-01-02',
+                              '2011-02-02', '2011-02-03'],
+                             tz=tz, name='other')
+        expected3 = DatetimeIndex(['2011-01-04', '2011-01-02'],
+                                  tz=tz, name=None)
+
+        # GH 7880
+        rng4 = date_range('7/1/2000', '7/31/2000', freq='D', tz=tz,
+                          name='idx')
+        expected4 = DatetimeIndex([], tz=tz, name='idx')
+
+        for (rng, expected) in [(rng2, expected2), (rng3, expected3),
+                                (rng4, expected4)]:
+            result = base.intersection(rng)
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq is None
+            assert result.tz == expected.tz
+
+    def test_intersection_empty(self):
         # empty same freq GH2129
         rng = date_range('6/1/2000', '6/15/2000', freq='T')
         result = rng[0:0].intersection(rng)
@@ -155,6 +172,26 @@ class TestDatetimeIndex(object):
         result = index_1 & index_2
         assert len(result) == 0
 
+    @pytest.mark.parametrize("tz", tz)
+    def test_difference(self, tz):
+        rng1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other1 = pd.date_range('1/6/2000', freq='D', periods=5, tz=tz)
+        expected1 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+
+        rng2 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other2 = pd.date_range('1/4/2000', freq='D', periods=5, tz=tz)
+        expected2 = pd.date_range('1/1/2000', freq='D', periods=3, tz=tz)
+
+        rng3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+        other3 = pd.DatetimeIndex([], tz=tz)
+        expected3 = pd.date_range('1/1/2000', freq='D', periods=5, tz=tz)
+
+        for rng, other, expected in [(rng1, other1, expected1),
+                                     (rng2, other2, expected2),
+                                     (rng3, other3, expected3)]:
+            result_diff = rng.difference(other)
+            tm.assert_index_equal(result_diff, expected)
+
     def test_difference_freq(self):
         # GH14323: difference of DatetimeIndex should not preserve frequency
 
diff --git a/pandas/tests/indexes/timedeltas/test_partial_slicing.py b/pandas/tests/indexes/timedeltas/test_partial_slicing.py
index 8e5eae2a7..7c5f82193 100644
--- a/pandas/tests/indexes/timedeltas/test_partial_slicing.py
+++ b/pandas/tests/indexes/timedeltas/test_partial_slicing.py
@@ -9,6 +9,10 @@ from pandas.util.testing import assert_series_equal
 
 
 class TestSlicing(object):
+    def test_slice_keeps_name(self):
+        # GH4226
+        dr = pd.timedelta_range('1d', '5d', freq='H', name='timebucket')
+        assert dr[1:].name == dr.name
 
     def test_partial_slice(self):
         rng = timedelta_range('1 day 10:11:12', freq='h', periods=500)
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index 2683110f2..615c0d0ff 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -233,12 +233,6 @@ class TestTimedeltaIndex(DatetimeLike):
             joined = index.join(index, how=kind)
             tm.assert_index_equal(index, joined)
 
-    def test_slice_keeps_name(self):
-
-        # GH4226
-        dr = pd.timedelta_range('1d', '5d', freq='H', name='timebucket')
-        assert dr[1:].name == dr.name
-
     def test_does_not_convert_mixed_integer(self):
         df = tm.makeCustomDataframe(10, 10,
                                     data_gen_f=lambda *args, **kwargs: randn(),

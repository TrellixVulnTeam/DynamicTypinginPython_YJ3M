commit e5be6bde969a75b62fee0d9449cf82c2ce29ca1b
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Feb 21 02:31:55 2018 -0800

    BUG: fix Period.asfreq conversion near datetime(1, 1, 1) (#19650)

diff --git a/doc/source/whatsnew/v0.23.0.txt b/doc/source/whatsnew/v0.23.0.txt
index 8d6a3dc72..35856b64c 100644
--- a/doc/source/whatsnew/v0.23.0.txt
+++ b/doc/source/whatsnew/v0.23.0.txt
@@ -741,8 +741,9 @@ Timedelta
 - Bug in :class:`TimedeltaIndex` where division by a ``Series`` would return a ``TimedeltaIndex`` instead of a ``Series`` (:issue:`19042`)
 - Bug in :func:`Timedelta.__add__`, :func:`Timedelta.__sub__` where adding or subtracting a ``np.timedelta64`` object would return another ``np.timedelta64`` instead of a ``Timedelta`` (:issue:`19738`)
 - Bug in :func:`Timedelta.__floordiv__`, :func:`Timedelta.__rfloordiv__` where operating with a ``Tick`` object would raise a ``TypeError`` instead of returning a numeric value (:issue:`19738`)
+- Bug in :func:`Period.asfreq` where periods near ``datetime(1, 1, 1)`` could be converted incorrectly (:issue:`19643`)
 - Bug in :func:`Timedelta.total_seconds()` causing precision errors i.e. ``Timedelta('30S').total_seconds()==30.000000000000004`` (:issue:`19458`)
-
+-
 
 Timezones
 ^^^^^^^^^
diff --git a/pandas/_libs/src/period_helper.c b/pandas/_libs/src/period_helper.c
index 7c4de8e42..a812ed2e7 100644
--- a/pandas/_libs/src/period_helper.c
+++ b/pandas/_libs/src/period_helper.c
@@ -138,7 +138,7 @@ PANDAS_INLINE npy_int64 transform_via_day(npy_int64 ordinal,
 }
 
 static npy_int64 DtoB_weekday(npy_int64 absdate) {
-    return (((absdate) / 7) * 5) + (absdate) % 7 - BDAY_OFFSET;
+    return floordiv(absdate, 7) * 5 + mod_compat(absdate, 7) - BDAY_OFFSET;
 }
 
 static npy_int64 DtoB(struct date_info *dinfo,
@@ -245,7 +245,8 @@ static npy_int64 asfreq_UpsampleWithinDay(npy_int64 ordinal,
 static npy_int64 asfreq_BtoDT(npy_int64 ordinal, asfreq_info *af_info) {
     ordinal += BDAY_OFFSET;
     ordinal =
-        (((ordinal - 1) / 5) * 7 + mod_compat(ordinal - 1, 5) + 1 - ORD_OFFSET);
+        (floordiv(ordinal - 1, 5) * 7 + mod_compat(ordinal - 1, 5) + 1 -
+         ORD_OFFSET);
 
     return upsample_daytime(ordinal, af_info);
 }
diff --git a/pandas/_libs/tslibs/period.pyx b/pandas/_libs/tslibs/period.pyx
index 32ffe4e6d..e1c783ac9 100644
--- a/pandas/_libs/tslibs/period.pyx
+++ b/pandas/_libs/tslibs/period.pyx
@@ -154,12 +154,32 @@ cdef inline int get_freq_group(int freq) nogil:
     return (freq // 1000) * 1000
 
 
-@cython.cdivision
+# specifically _dont_ use cdvision or else ordinals near -1 are assigned to
+# incorrect dates GH#19643
+@cython.cdivision(False)
 cdef int64_t get_period_ordinal(int year, int month, int day,
                                 int hour, int minute, int second,
                                 int microseconds, int picoseconds,
                                 int freq) nogil:
-    """generate an ordinal in period space"""
+    """
+    Generate an ordinal in period space
+
+    Parameters
+    ----------
+    year : int
+    month : int
+    day : int
+    hour : int
+    minute : int
+    second : int
+    microseconds : int
+    picoseconds : int
+    freq : int
+
+    Returns
+    -------
+    period_ordinal : int64_t
+    """
     cdef:
         int64_t absdays, unix_date, seconds, delta
         int64_t weeks
@@ -190,7 +210,7 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
         if month >= fmonth:
             mdiff += 12
 
-        return (year - 1970) * 4 + (mdiff - 1) / 3
+        return (year - 1970) * 4 + (mdiff - 1) // 3
 
     elif freq == FR_MTH:
         return (year - 1970) * 12 + month - 1
@@ -202,14 +222,14 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
         seconds = unix_date * 86400 + hour * 3600 + minute * 60 + second
 
         if freq == FR_MS:
-            return seconds * 1000 + microseconds / 1000
+            return seconds * 1000 + microseconds // 1000
 
         elif freq == FR_US:
             return seconds * 1000000 + microseconds
 
         elif freq == FR_NS:
             return (seconds * 1000000000 +
-                    microseconds * 1000 + picoseconds / 1000)
+                    microseconds * 1000 + picoseconds // 1000)
 
         else:
             return seconds
@@ -229,7 +249,7 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
     elif freq == FR_BUS:
         # calculate the current week assuming sunday as last day of a week
         # Jan 1 0001 is a Monday, so subtract 1 to get to end-of-week
-        weeks = (unix_date + ORD_OFFSET - 1) / 7
+        weeks = (unix_date + ORD_OFFSET - 1) // 7
         # calculate the current weekday (in range 1 .. 7)
         delta = (unix_date + ORD_OFFSET - 1) % 7 + 1
         # return the number of business days in full weeks plus the business
@@ -241,12 +261,12 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
 
     elif freq_group == FR_WK:
         day_adj = freq - FR_WK
-        return (unix_date + ORD_OFFSET - (1 + day_adj)) / 7 + 1 - WEEK_OFFSET
+        return (unix_date + ORD_OFFSET - (1 + day_adj)) // 7 + 1 - WEEK_OFFSET
 
     # raise ValueError
 
 
-cdef int get_date_info(int64_t ordinal, int freq, date_info *dinfo) nogil:
+cdef void get_date_info(int64_t ordinal, int freq, date_info *dinfo) nogil:
     cdef:
         int64_t absdate
         double abstime
@@ -263,7 +283,6 @@ cdef int get_date_info(int64_t ordinal, int freq, date_info *dinfo) nogil:
         absdate += 1
 
     dInfoCalc_SetFromAbsDateTime(dinfo, absdate, abstime)
-    return 0
 
 
 cdef int64_t get_python_ordinal(int64_t period_ordinal, int freq) nogil:
@@ -272,6 +291,15 @@ cdef int64_t get_python_ordinal(int64_t period_ordinal, int freq) nogil:
     This corresponds to the number of days since Jan., 1st, 1AD.
     When the instance has a frequency less than daily, the proleptic date
     is calculated for the last day of the period.
+
+    Parameters
+    ----------
+    period_ordinal : int64_t
+    freq : int
+
+    Returns
+    -------
+    absdate : int64_t number of days since datetime(1, 1, 1)
     """
     cdef:
         asfreq_info af_info
@@ -285,11 +313,23 @@ cdef int64_t get_python_ordinal(int64_t period_ordinal, int freq) nogil:
     return toDaily(period_ordinal, &af_info) + ORD_OFFSET
 
 
-cdef int dInfoCalc_SetFromAbsDateTime(date_info *dinfo,
-                                      int64_t absdate, double abstime) nogil:
+cdef void dInfoCalc_SetFromAbsDateTime(date_info *dinfo,
+                                       int64_t absdate, double abstime) nogil:
     """
     Set the instance's value using the given date and time.
     Assumes GREGORIAN_CALENDAR.
+
+    Parameters
+    ----------
+    dinfo : date_info*
+    absdate : int64_t
+        days elapsed since datetime(1, 1, 1)
+    abstime : double
+        seconds elapsed since beginning of day described by absdate
+
+    Notes
+    -----
+    Updates dinfo inplace
     """
     # Bounds check
     # The calling function is responsible for ensuring that
@@ -300,13 +340,21 @@ cdef int dInfoCalc_SetFromAbsDateTime(date_info *dinfo,
 
     # Calculate the time
     dInfoCalc_SetFromAbsTime(dinfo, abstime)
-    return 0
 
 
-cdef int dInfoCalc_SetFromAbsDate(date_info *dinfo, int64_t absdate) nogil:
+cdef void dInfoCalc_SetFromAbsDate(date_info *dinfo, int64_t absdate) nogil:
     """
     Sets the date part of the date_info struct
     Assumes GREGORIAN_CALENDAR
+
+    Parameters
+    ----------
+    dinfo : date_info*
+    unix_date : int64_t
+
+    Notes
+    -----
+    Updates dinfo inplace
     """
     cdef:
         pandas_datetimestruct dts
@@ -315,13 +363,22 @@ cdef int dInfoCalc_SetFromAbsDate(date_info *dinfo, int64_t absdate) nogil:
     dinfo.year = dts.year
     dinfo.month = dts.month
     dinfo.day = dts.day
-    return 0
 
 
 @cython.cdivision
-cdef int dInfoCalc_SetFromAbsTime(date_info *dinfo, double abstime) nogil:
+cdef void dInfoCalc_SetFromAbsTime(date_info *dinfo, double abstime) nogil:
     """
     Sets the time part of the DateTime object.
+
+    Parameters
+    ----------
+    dinfo : date_info*
+    abstime : double
+        seconds elapsed since beginning of day described by absdate
+
+    Notes
+    -----
+    Updates dinfo inplace
     """
     cdef:
         int inttime
@@ -336,7 +393,6 @@ cdef int dInfoCalc_SetFromAbsTime(date_info *dinfo, double abstime) nogil:
     dinfo.hour = hour
     dinfo.minute = minute
     dinfo.second = second
-    return 0
 
 
 @cython.cdivision
@@ -370,7 +426,19 @@ cdef int64_t absdate_from_ymd(int year, int month, int day) nogil:
     Find the absdate (days elapsed since datetime(1, 1, 1)
     for the given year/month/day.
     Assumes GREGORIAN_CALENDAR
+
+    Parameters
+    ----------
+    year : int
+    month : int
+    day : int
+
+    Returns
+    -------
+    absdate : int
+        days elapsed since datetime(1, 1, 1)
     """
+
     # /* Calculate the absolute date
     cdef:
         pandas_datetimestruct dts
@@ -385,6 +453,25 @@ cdef int64_t absdate_from_ymd(int year, int month, int day) nogil:
 
 
 cdef int get_yq(int64_t ordinal, int freq, int *quarter, int *year):
+    """
+    Find the year and quarter of a Period with the given ordinal and frequency
+
+    Parameters
+    ----------
+    ordinal : int64_t
+    freq : int
+    quarter : *int
+    year : *int
+
+    Returns
+    -------
+    qtr_freq : int
+        describes the implied quarterly frequency associated with `freq`
+
+    Notes
+    -----
+    Sets quarter and year inplace
+    """
     cdef:
         asfreq_info af_info
         int qtr_freq
@@ -403,8 +490,8 @@ cdef int get_yq(int64_t ordinal, int freq, int *quarter, int *year):
     return qtr_freq
 
 
-cdef int64_t DtoQ_yq(int64_t ordinal, asfreq_info *af_info,
-                     int *year, int *quarter):
+cdef void DtoQ_yq(int64_t ordinal, asfreq_info *af_info,
+                  int *year, int *quarter):
     cdef:
         date_info dinfo
 
@@ -419,7 +506,6 @@ cdef int64_t DtoQ_yq(int64_t ordinal, asfreq_info *af_info,
 
     year[0] = dinfo.year
     quarter[0] = monthToQuarter(dinfo.month)
-    return 0
 
 
 cdef inline int monthToQuarter(int month):
diff --git a/pandas/tests/scalar/period/test_period_asfreq.py b/pandas/tests/scalar/period/test_period_asfreq.py
index a2819a347..9f8b2562e 100644
--- a/pandas/tests/scalar/period/test_period_asfreq.py
+++ b/pandas/tests/scalar/period/test_period_asfreq.py
@@ -1,3 +1,7 @@
+import pytest
+
+from pandas.errors import OutOfBoundsDatetime
+
 import pandas as pd
 from pandas import Period, offsets
 from pandas.util import testing as tm
@@ -6,6 +10,24 @@ from pandas._libs.tslibs.frequencies import _period_code_map
 
 class TestFreqConversion(object):
     """Test frequency conversion of date objects"""
+    @pytest.mark.parametrize('freq', ['A', 'Q', 'M', 'W', 'B', 'D'])
+    def test_asfreq_near_zero(self, freq):
+        # GH#19643, GH#19650
+        per = Period('0001-01-01', freq=freq)
+        tup1 = (per.year, per.hour, per.day)
+
+        prev = per - 1
+        assert (per - 1).ordinal == per.ordinal - 1
+        tup2 = (prev.year, prev.month, prev.day)
+        assert tup2 < tup1
+
+    @pytest.mark.xfail(reason='GH#19643 period_helper asfreq functions fail '
+                              'to check for overflows')
+    def test_to_timestamp_out_of_bounds(self):
+        # GH#19643, currently gives Timestamp('1754-08-30 22:43:41.128654848')
+        per = Period('0001-01-01', freq='B')
+        with pytest.raises(OutOfBoundsDatetime):
+            per.to_timestamp()
 
     def test_asfreq_corner(self):
         val = Period(freq='A', year=2007)
diff --git a/pandas/tests/tslibs/test_period_asfreq.py b/pandas/tests/tslibs/test_period_asfreq.py
index 98959adf6..61737083e 100644
--- a/pandas/tests/tslibs/test_period_asfreq.py
+++ b/pandas/tests/tslibs/test_period_asfreq.py
@@ -5,6 +5,7 @@ from pandas._libs.tslibs.period import period_ordinal, period_asfreq
 
 
 class TestPeriodFreqConversion(object):
+
     def test_intraday_conversion_factors(self):
         assert period_asfreq(1, get_freq('D'), get_freq('H'), False) == 24
         assert period_asfreq(1, get_freq('D'), get_freq('T'), False) == 1440

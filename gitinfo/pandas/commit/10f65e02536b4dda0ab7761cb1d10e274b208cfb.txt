commit 10f65e02536b4dda0ab7761cb1d10e274b208cfb
Author: Stephen Lin <stephenwlin@gmail.com>
Date:   Wed Feb 13 03:33:35 2013 -0500

    ENH: optimize Cython take functions with memmove where possible

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 68cf9fa09..4f2852f42 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -697,8 +697,6 @@ def _maybe_promote(dtype, fill_value=np.nan):
                 # object (but numpy 1.6.1 doesn't do this properly)
                 fill_value = tslib.iNaT 
     elif is_float(fill_value):
-        if fill_value is None:
-            fill_value = np.nan
         if issubclass(dtype.type, np.bool_):
             dtype = np.object_
         elif issubclass(dtype.type, np.integer):
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 11fbf5371..c94ed8730 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -5,6 +5,8 @@ header = """
 cimport numpy as np
 cimport cython
 
+from libc.string cimport memmove
+
 from numpy cimport *
 
 from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
@@ -86,6 +88,23 @@ def take_2d_axis0_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF %(can_copy)s:
+        cdef:
+            %(c_type_out)s *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(%(c_type_out)s) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -109,8 +128,25 @@ def take_2d_axis1_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF %(can_copy)s:
+        cdef:
+            %(c_type_out)s *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(%(c_type_out)s) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -2115,39 +2151,40 @@ def generate_put_template(template, use_ints = True, use_floats = True):
     return output.getvalue()
 
 def generate_take_template(template, exclude=None):
-    # name, dest, ctypein, ctypeout, preval, postval
+    # name, dest, ctypein, ctypeout, preval, postval, cancopy
     function_list = [
-        ('bool', 'bool', 'uint8_t', 'uint8_t', '', ''),
+        ('bool', 'bool', 'uint8_t', 'uint8_t', '', '', True),
         ('bool', 'object', 'uint8_t', 'object',
-         'True if ', ' > 0 else False'),
-        ('int8', 'int8', 'int8_t', 'int8_t', '', ''),
-        ('int8', 'int32', 'int8_t', 'int32_t', '', ''),
-        ('int8', 'int64', 'int8_t', 'int64_t', '', ''),
-        ('int8', 'float64', 'int8_t', 'float64_t', '', ''),
-        ('int16', 'int16', 'int16_t', 'int16_t', '', ''),
-        ('int16', 'int32', 'int16_t', 'int32_t', '', ''),
-        ('int16', 'int64', 'int16_t', 'int64_t', '', ''),
-        ('int16', 'float64', 'int16_t', 'float64_t', '', ''),
-        ('int32', 'int32', 'int32_t', 'int32_t', '', ''),
-        ('int32', 'int64', 'int32_t', 'int64_t', '', ''),
-        ('int32', 'float64', 'int32_t', 'float64_t', '', ''),
-        ('int64', 'int64', 'int64_t', 'int64_t', '', ''),
-        ('int64', 'float64', 'int64_t', 'float64_t', '', ''),
-        ('float32', 'float32', 'float32_t', 'float32_t', '', ''),
-        ('float32', 'float64', 'float32_t', 'float64_t', '', ''),
-        ('float64', 'float64', 'float64_t', 'float64_t', '', ''),
-        ('object', 'object', 'object', 'object', '', '')
+         'True if ', ' > 0 else False', False),
+        ('int8', 'int8', 'int8_t', 'int8_t', '', '', True),
+        ('int8', 'int32', 'int8_t', 'int32_t', '', '', False),
+        ('int8', 'int64', 'int8_t', 'int64_t', '', '', False),
+        ('int8', 'float64', 'int8_t', 'float64_t', '', '', False),
+        ('int16', 'int16', 'int16_t', 'int16_t', '', '', True),
+        ('int16', 'int32', 'int16_t', 'int32_t', '', '', False),
+        ('int16', 'int64', 'int16_t', 'int64_t', '', '', False),
+        ('int16', 'float64', 'int16_t', 'float64_t', '', '', False),
+        ('int32', 'int32', 'int32_t', 'int32_t', '', '', True),
+        ('int32', 'int64', 'int32_t', 'int64_t', '', '', False),
+        ('int32', 'float64', 'int32_t', 'float64_t', '', '', False),
+        ('int64', 'int64', 'int64_t', 'int64_t', '', '', True),
+        ('int64', 'float64', 'int64_t', 'float64_t', '', '', False),
+        ('float32', 'float32', 'float32_t', 'float32_t', '', '', True),
+        ('float32', 'float64', 'float32_t', 'float64_t', '', '', False),
+        ('float64', 'float64', 'float64_t', 'float64_t', '', '', True),
+        ('object', 'object', 'object', 'object', '', '', False)
     ]
 
     output = StringIO()
     for (name, dest, c_type_in, c_type_out, 
-         preval, postval) in function_list:
+         preval, postval, can_copy) in function_list:
         if exclude is not None and name in exclude:
             continue
 
         func = template % {'name': name, 'dest': dest,
                            'c_type_in': c_type_in, 'c_type_out': c_type_out,
-                           'preval': preval, 'postval': postval}
+                           'preval': preval, 'postval': postval,
+                           'can_copy': 'True' if can_copy else 'False'}
         output.write(func)
     return output.getvalue()
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index af79ebfc1..ce83e0878 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -2,6 +2,8 @@
 cimport numpy as np
 cimport cython
 
+from libc.string cimport memmove
+
 from numpy cimport *
 
 from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
@@ -2573,6 +2575,23 @@ def take_2d_axis0_bool_bool(ndarray[uint8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            uint8_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(uint8_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2596,6 +2615,23 @@ def take_2d_axis0_bool_object(ndarray[uint8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            object *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(object) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2619,6 +2655,23 @@ def take_2d_axis0_int8_int8(ndarray[int8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            int8_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int8_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2642,6 +2695,23 @@ def take_2d_axis0_int8_int32(ndarray[int8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2665,6 +2735,23 @@ def take_2d_axis0_int8_int64(ndarray[int8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2688,6 +2775,23 @@ def take_2d_axis0_int8_float64(ndarray[int8_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2711,6 +2815,23 @@ def take_2d_axis0_int16_int16(ndarray[int16_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            int16_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int16_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2734,6 +2855,23 @@ def take_2d_axis0_int16_int32(ndarray[int16_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2757,6 +2895,23 @@ def take_2d_axis0_int16_int64(ndarray[int16_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2780,6 +2935,23 @@ def take_2d_axis0_int16_float64(ndarray[int16_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2803,6 +2975,23 @@ def take_2d_axis0_int32_int32(ndarray[int32_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2826,6 +3015,23 @@ def take_2d_axis0_int32_int64(ndarray[int32_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2849,6 +3055,23 @@ def take_2d_axis0_int32_float64(ndarray[int32_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2872,6 +3095,23 @@ def take_2d_axis0_int64_int64(ndarray[int64_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2895,6 +3135,23 @@ def take_2d_axis0_int64_float64(ndarray[int64_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2918,6 +3175,23 @@ def take_2d_axis0_float32_float32(ndarray[float32_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            float32_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float32_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2941,6 +3215,23 @@ def take_2d_axis0_float32_float64(ndarray[float32_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2964,6 +3255,23 @@ def take_2d_axis0_float64_float64(ndarray[float64_t, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF True:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -2987,6 +3295,23 @@ def take_2d_axis0_object_object(ndarray[object, ndim=2] values,
     k = values.shape[1]
 
     fv = fill_value
+
+    IF False:
+        cdef:
+            object *v, *o
+
+        if values.flags.c_contiguous and out.flags.c_contiguous:
+            for i from 0 <= i < n:
+                idx = indexer[i]
+                if idx == -1:
+                    for j from 0 <= j < k:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[idx, 0]
+                    o = &outbuf[i, 0]
+                    memmove(o, v, <size_t>(sizeof(object) * k))
+            return
+
     for i from 0 <= i < n:
         idx = indexer[i]
         if idx == -1:
@@ -3009,8 +3334,25 @@ def take_2d_axis1_bool_bool(ndarray[uint8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            uint8_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(uint8_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3032,8 +3374,25 @@ def take_2d_axis1_bool_object(ndarray[uint8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            object *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(object) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3055,8 +3414,25 @@ def take_2d_axis1_int8_int8(ndarray[int8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            int8_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int8_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3078,8 +3454,25 @@ def take_2d_axis1_int8_int32(ndarray[int8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3101,8 +3494,25 @@ def take_2d_axis1_int8_int64(ndarray[int8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3124,8 +3534,25 @@ def take_2d_axis1_int8_float64(ndarray[int8_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3147,8 +3574,25 @@ def take_2d_axis1_int16_int16(ndarray[int16_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            int16_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int16_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3170,8 +3614,25 @@ def take_2d_axis1_int16_int32(ndarray[int16_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3193,8 +3654,25 @@ def take_2d_axis1_int16_int64(ndarray[int16_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3216,8 +3694,25 @@ def take_2d_axis1_int16_float64(ndarray[int16_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3239,8 +3734,25 @@ def take_2d_axis1_int32_int32(ndarray[int32_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            int32_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int32_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3262,8 +3774,25 @@ def take_2d_axis1_int32_int64(ndarray[int32_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3285,8 +3814,25 @@ def take_2d_axis1_int32_float64(ndarray[int32_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3308,8 +3854,25 @@ def take_2d_axis1_int64_int64(ndarray[int64_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            int64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(int64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3331,8 +3894,25 @@ def take_2d_axis1_int64_float64(ndarray[int64_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3354,8 +3934,25 @@ def take_2d_axis1_float32_float32(ndarray[float32_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            float32_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float32_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3377,8 +3974,25 @@ def take_2d_axis1_float32_float64(ndarray[float32_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3400,8 +4014,25 @@ def take_2d_axis1_float64_float64(ndarray[float64_t, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF True:
+        cdef:
+            float64_t *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(float64_t) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:
@@ -3423,8 +4054,25 @@ def take_2d_axis1_object_object(ndarray[object, ndim=2] values,
 
     n = len(values)
     k = len(indexer)
-
+    
     fv = fill_value
+
+    IF False:
+        cdef:
+            object *v, *o
+
+        if values.flags.f_contiguous and out.flags.f_contiguous:
+            for j from 0 <= j < k:
+                idx = indexer[j]
+                if idx == -1:
+                    for i from 0 <= i < n:
+                        outbuf[i, j] = fv
+                else:
+                    v = &values[0, idx]
+                    o = &outbuf[0, j]
+                    memmove(o, v, <size_t>(sizeof(object) * n))
+            return
+
     for j from 0 <= j < k:
         idx = indexer[j]
         if idx == -1:

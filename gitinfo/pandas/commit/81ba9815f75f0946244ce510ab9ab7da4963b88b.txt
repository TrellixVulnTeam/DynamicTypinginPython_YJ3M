commit 81ba9815f75f0946244ce510ab9ab7da4963b88b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 27 21:44:22 2011 -0400

    implemented rolling_quantile and unit tests

diff --git a/pandas/src/common.pyx b/pandas/src/common.pyx
index 9c314bb82..d8a311c8a 100644
--- a/pandas/src/common.pyx
+++ b/pandas/src/common.pyx
@@ -14,7 +14,7 @@ cdef double NaN = <double> np.NaN
 from datetime import datetime as pydatetime
 
 cdef inline int int_max(int a, int b): return a if a >= b else b
-cdef inline int int_min(int a, int b): return a if a >= b else b
+cdef inline int int_min(int a, int b): return a if a <= b else b
 
 ctypedef unsigned char UChar
 
diff --git a/pandas/src/moments.pyx b/pandas/src/moments.pyx
index d6aee7503..ff23a312d 100644
--- a/pandas/src/moments.pyx
+++ b/pandas/src/moments.pyx
@@ -75,13 +75,12 @@ def median(ndarray arr):
 #-------------------------------------------------------------------------------
 # Rolling sum
 
-def roll_sum(ndarray[double_t, ndim=1] input,
-              int win, int minp):
+def roll_sum(ndarray[double_t] input, int win, int minp):
     cdef double val, prev, sum_x = 0
     cdef int nobs = 0, i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     if minp > N:
         minp = N + 1
@@ -119,13 +118,13 @@ def roll_sum(ndarray[double_t, ndim=1] input,
 #-------------------------------------------------------------------------------
 # Rolling mean
 
-def roll_mean(ndarray[double_t, ndim=1] input,
+def roll_mean(ndarray[double_t] input,
                int win, int minp):
     cdef double val, prev, sum_x = 0
     cdef int nobs = 0, i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     if minp > N:
         minp = N + 1
@@ -163,7 +162,7 @@ def roll_mean(ndarray[double_t, ndim=1] input,
 #-------------------------------------------------------------------------------
 # Exponentially weighted moving average
 
-def ewma(ndarray[double_t, ndim=1] input, double_t com):
+def ewma(ndarray[double_t] input, double_t com):
     '''
     Compute exponentially-weighted moving average using center-of-mass.
 
@@ -181,7 +180,7 @@ def ewma(ndarray[double_t, ndim=1] input, double_t com):
     cdef int i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
 
     neww = 1. / (1. + com)
@@ -214,13 +213,12 @@ def ewma(ndarray[double_t, ndim=1] input, double_t com):
 #-------------------------------------------------------------------------------
 # Rolling variance
 
-def roll_var(ndarray[double_t, ndim=1] input,
-              int win, int minp):
+def roll_var(ndarray[double_t] input, int win, int minp):
     cdef double val, prev, sum_x = 0, sum_xx = 0, nobs = 0
     cdef int i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     if minp > N:
         minp = N + 1
@@ -261,14 +259,13 @@ def roll_var(ndarray[double_t, ndim=1] input,
 #-------------------------------------------------------------------------------
 # Rolling skewness
 
-def roll_skew(ndarray[double_t, ndim=1] input,
-               int win, int minp):
+def roll_skew(ndarray[double_t] input, int win, int minp):
     cdef double val, prev
     cdef double x = 0, xx = 0, xxx = 0
     cdef int nobs = 0, i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     # 3 components of the skewness equation
     cdef double A, B, C, R
@@ -324,14 +321,14 @@ def roll_skew(ndarray[double_t, ndim=1] input,
 # Rolling kurtosis
 
 
-def roll_kurt(ndarray[double_t, ndim=1] input,
+def roll_kurt(ndarray[double_t] input,
                int win, int minp):
     cdef double val, prev
     cdef double x = 0, xx = 0, xxx = 0, xxxx = 0
     cdef int nobs = 0, i
     cdef int N = len(input)
 
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     # 5 components of the kurtosis equation
     cdef double A, B, C, D, R, K
@@ -398,13 +395,13 @@ def roll_kurt(ndarray[double_t, ndim=1] input,
 ctypedef double_t (* skiplist_f)(object sl, int n, int p)
 
 cdef _roll_skiplist_op(ndarray arg, int win, int minp, skiplist_f op):
-    cdef ndarray[double_t, ndim=1] input = arg
+    cdef ndarray[double_t] input = arg
     cdef double val, prev, midpoint
     cdef IndexableSkiplist skiplist
     cdef int nobs = 0, i
 
     cdef int N = len(input)
-    cdef ndarray[double_t, ndim=1] output = np.empty(N, dtype=float)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
 
     skiplist = IndexableSkiplist(win)
 
@@ -445,18 +442,6 @@ def roll_median(ndarray input, int win, int minp):
     '''
     return _roll_skiplist_op(input, win, minp, _get_median)
 
-def roll_max(ndarray input, int win, int minp):
-    '''
-    O(N log(window)) implementation using skip list
-    '''
-    return _roll_skiplist_op(input, win, minp, _get_max)
-
-def roll_min(ndarray input, int win, int minp):
-    '''
-    O(N log(window)) implementation using skip list
-    '''
-    return _roll_skiplist_op(input, win, minp, _get_min)
-
 # Unfortunately had to resort to some hackery here, would like for
 # Cython to be able to get this right.
 
@@ -473,14 +458,111 @@ cdef double_t _get_median(object sl, int nobs, int minp):
     else:
         return NaN
 
+def roll_max(ndarray input, int win, int minp):
+    '''
+    O(N log(window)) implementation using skip list
+    '''
+    return _roll_skiplist_op(input, win, minp, _get_max)
+
 cdef double_t _get_max(object skiplist, int nobs, int minp):
     if nobs >= minp:
         return <IndexableSkiplist> skiplist.get(nobs - 1)
     else:
         return NaN
 
+def roll_min(ndarray input, int win, int minp):
+    '''
+    O(N log(window)) implementation using skip list
+    '''
+    return _roll_skiplist_op(input, win, minp, _get_min)
+
 cdef double_t _get_min(object skiplist, int nobs, int minp):
     if nobs >= minp:
         return <IndexableSkiplist> skiplist.get(0)
     else:
         return NaN
+
+def roll_quantile(ndarray[float64_t, cast=True] input, int win,
+                  int minp, double quantile):
+   '''
+   O(N log(window)) implementation using skip list
+   '''
+   cdef double val, prev, midpoint
+   cdef IndexableSkiplist skiplist
+   cdef int nobs = 0, i
+   cdef int N = len(input)
+   cdef ndarray[double_t] output = np.empty(N, dtype=float)
+
+   skiplist = IndexableSkiplist(win)
+
+   if minp > N:
+       minp = N + 1
+
+   for i from 0 <= i < minp - 1:
+       val = input[i]
+
+       # Not NaN
+       if val == val:
+           nobs += 1
+           skiplist.insert(val)
+
+       output[i] = NaN
+
+   for i from minp - 1 <= i < N:
+       val = input[i]
+
+       if i > win - 1:
+           prev = input[i - win]
+
+           if prev == prev:
+               skiplist.remove(prev)
+               nobs -= 1
+
+       if val == val:
+           nobs += 1
+           skiplist.insert(val)
+
+       if nobs >= minp:
+           idx = int((quantile / 1.) * (nobs - 1))
+           output[i] = skiplist.get(idx)
+       else:
+           output[i] = NaN
+
+   return output
+
+def roll_generic(ndarray[float64_t, cast=True] input, int win,
+                 int minp, object func):
+    cdef ndarray[double_t] output, counts, bufarr
+    cdef Py_ssize_t i, n
+    cdef float64_t *buf, *oldbuf
+
+    if not input.flags.c_contiguous:
+        input = input.copy('C')
+
+    buf = <float64_t*> input.data
+
+    n = len(input)
+    output = np.empty(n, dtype=float)
+    counts = roll_sum(np.isfinite(input).astype(float), win, minp)
+
+    bufarr = np.empty(win, dtype=float)
+    oldbuf = <float64_t*> bufarr.data
+
+    n = len(input)
+    for i from 0 <= i < win:
+        if counts[i] >= minp:
+            output[i] = func(input[int_max(i - win + 1, 0) : i + 1])
+        else:
+            output[i] = NaN
+
+    for i from win <= i < n:
+        buf = buf + 1
+        bufarr.data = <char*> buf
+        if counts[i] >= minp:
+            output[i] = func(bufarr)
+        else:
+            output[i] = NaN
+
+    bufarr.data = <char*> oldbuf
+
+    return output
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 22b48d1c9..e39177693 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -15,8 +15,8 @@ import pandas._tseries as _tseries
 __all__ = ['rolling_count', 'rolling_max', 'rolling_min',
            'rolling_sum', 'rolling_mean', 'rolling_std', 'rolling_cov',
            'rolling_corr', 'rolling_var', 'rolling_skew', 'rolling_kurt',
-           'rolling_median', 'ewma', 'ewmvar', 'ewmstd', 'ewmvol',
-           'ewmcorr', 'ewmcov']
+           'rolling_quantile', 'rolling_median', 'ewma', 'ewmvar', 'ewmstd',
+           'ewmvol', 'ewmcorr', 'ewmcov']
 
 def rolling_count(arg, window, time_rule=None):
     """
@@ -327,3 +327,26 @@ rolling_skew = _rolling_func(_tseries.roll_skew, 'Unbiased moving skewness',
 rolling_kurt = _rolling_func(_tseries.roll_kurt, 'Unbiased moving kurtosis',
                              check_minp=_two_periods)
 
+def rolling_quantile(arg, window, quantile, min_periods=None, time_rule=None):
+    """Moving quantile
+
+    Parameters
+    ----------
+    arg : Series, DataFrame
+    window : Number of observations used for calculating statistic
+    quantile : 0 <= quantile <= 1
+    min_periods : int
+        Minimum number of observations in window required to have a value
+    time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default=None
+        Name of time rule to conform to before computing statistic
+
+    Returns
+    -------
+    y : type of input argument
+    """
+
+    def call_cython(arg, window, minp):
+        minp = _use_window(minp, window)
+        return _tseries.roll_quantile(arg, window, minp, quantile)
+    return _rolling_moment(arg, window, call_cython, min_periods,
+                           time_rule=time_rule)
diff --git a/pandas/stats/tests/test_moments.py b/pandas/stats/tests/test_moments.py
index 87323879d..29aa289fc 100644
--- a/pandas/stats/tests/test_moments.py
+++ b/pandas/stats/tests/test_moments.py
@@ -50,6 +50,25 @@ class TestMoments(unittest.TestCase):
     def test_rolling_max(self):
         self._check_moment_func(moments.rolling_max, np.max)
 
+    def test_rolling_quantile(self):
+        qs = [.1, .5, .9]
+
+        def scoreatpercentile(a, per):
+            values = np.sort(a,axis=0)
+
+            idx = per /1. * (values.shape[0] - 1)
+            return values[int(idx)]
+
+        for q in qs:
+            def f(x, window, min_periods=None, time_rule=None):
+                return moments.rolling_quantile(x, window, q,
+                                                min_periods=min_periods,
+                                                time_rule=time_rule)
+            def alt(x):
+                return scoreatpercentile(x, q)
+
+            self._check_moment_func(f, alt)
+
     def test_rolling_std(self):
         self._check_moment_func(moments.rolling_std,
                                 lambda x: np.std(x, ddof=1))
@@ -231,5 +250,6 @@ class TestMoments(unittest.TestCase):
         self.assertRaises(Exception, func, A, randn(50), 20, min_periods=5)
 
 if __name__ == '__main__':
-    unittest.main()
-
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)

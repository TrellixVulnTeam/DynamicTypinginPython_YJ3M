commit 6c797a97063bfe076d1656ec49fe9c76b2bc69f8
Author: Adam Klein <adamklein@gmail.com>
Date:   Sun Mar 4 19:58:25 2012 -0500

    ENH: fancier datetime slicing logic, commented out b/c broke other tests, will fix

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 3ae7718cb..101f9c582 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -97,6 +97,36 @@ def to_timestamp(arg, offset=None, tzinfo=None):
 
     return lib.Timestamp(arg, offset=offset, tzinfo=tzinfo)
 
+class DateParseError(Exception):
+    pass
+
+_dtparser = parser.parser()
+
+def parse_time_string(arg):
+    if not isinstance(arg, basestring):
+        return arg
+
+    try:
+        parsed = _dtparser._parse(arg)
+        default = datetime.now().replace(hour=0, minute=0,
+                                         second=0, microsecond=0)
+        repl = {}
+        reso = 'year'
+        stopped = False
+        for attr in ["year", "month", "day", "hour",
+                     "minute", "second", "microsecond"]:
+            value = getattr(parsed, attr)
+            if value is not None:
+                repl[attr] = value
+                if not stopped:
+                    reso = attr
+            else:
+                stopped = True
+        ret = default.replace(**repl)
+        return ret, parsed, reso  # datetime, partial parse, resolution
+    except Exception:
+        raise DateParseError
+
 def to_datetime(arg):
     """Attempts to convert arg to datetime"""
     if arg is None:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 162933ebb..8d5c06160 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1620,6 +1620,8 @@ class DataFrame(NDFrame):
         index = self.index
         if isinstance(index, MultiIndex):
             loc, new_index = self.index.get_loc_level(key)
+        #elif isinstance(index, DatetimeIndex):
+        #    loc, new_index = self.index.get_loc(key)
         else:
             loc = self.index.get_loc(key)
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 9cd4fc414..8ffc1b49d 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -15,7 +15,7 @@ from pandas._tseries import Timestamp
 
 import pandas.core.datetools as datetools
 from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
-                                   _dt_unbox_array)
+                                   _dt_unbox_array, to_timestamp)
 
 __all__ = ['Index']
 
@@ -1498,8 +1498,26 @@ class DatetimeIndex(Int64Index):
         try:
             return super(DatetimeIndex, self).get_value(series, key)
         except KeyError:
-            return self._engine.get_value(series,
-                                          datetools.to_timestamp(key))
+            #try:
+            #    asdt, parsed, reso = datetools.parse_time_string(key)
+            #    if reso == 'year':
+            #        t1 = to_timestamp(datetime(parsed.year, 1, 1))
+            #        t2 = to_timestamp(datetime(parsed.year, 12, 31))
+            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            #        return series[slice(i1, i2+1)]
+            #    elif reso == 'month':
+            #        d = lib.monthrange(parsed.year, parsed.month)[1]
+            #        t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
+            #        t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
+            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            #        return series[slice(i1, i2+1)]
+            #    else:
+                    #return self._engine.get_value(series, to_timestamp(asdt))
+            #except datetools.DateParseError:
+            #    raise KeyError(key)
+            #except KeyError:
+            #    raise
+            return self._engine.get_value(series, to_timestamp(key))
 
     def get_loc(self, key):
         """
@@ -1512,7 +1530,26 @@ class DatetimeIndex(Int64Index):
         try:
             return self._engine.get_loc(key)
         except KeyError:
-            return self._engine.get_loc(datetools.to_timestamp(key))
+            #try:
+            #    asdt, parsed, reso = datetools.parse_time_string(key)
+            #    if reso == 'year':
+            #        t1 = to_timestamp(datetime(parsed.year, 1, 1))
+            #        t2 = to_timestamp(datetime(parsed.year, 12, 31))
+            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            #        return slice(i1, i2+1), self[i1:i2+1]
+            #    elif reso == 'month':
+            #        d = lib.monthrange(parsed.year, parsed.month)[1]
+            #        t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
+            #        t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
+            #        i1, i2 = np.searchsorted(self.asi8, [t1.value, t2.value])
+            #        return slice(i1, i2+1), self[i1:i2+1]
+            #    else:
+            #        return self._engine.get_loc(to_timestamp(asdt)), None
+            #except datetools.DateParseError:
+            #    raise KeyError(key)
+            #except KeyError:
+            #    raise
+            return self._engine.get_loc(to_timestamp(key))
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
@@ -1536,7 +1573,7 @@ class DatetimeIndex(Int64Index):
             if result.ndim > 1:
                 return result
 
-            return DatetimeIndex(result, name=self.name, offset=new_offset,
+            return DatetimeIndex(result, name=self.name, freq=new_offset,
                                  tzinfo=self.tzinfo)
 
     # Try to run function on index first, and then on elements of index
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 119cc2ae7..013430526 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -914,43 +914,6 @@ cpdef DatetimeCache get_tcache(freq, object first=None, object last=None):
 # Helper methods for frequency-based analysis
 # -------------------------------------------------------------
 
-#def resample(ndarray[int64_t] data, object freq1, object freq2):
-#    """
-#    Handle frequency conversions from freq1 to freq2
-#    """
-#    cdef:
-#        int rank1, rank2
-#        int idx1, idx2
-#        DatetimeCache tc1, tc2
-#        ndarray[int64_t] cache
-
-#    if freq1 == freq2:
-#        return data
-
-#    rank1 = _freqrank[freq1[0:2]]
-#    rank2 = _freqrank[freq2[0:2]]
-
-#    if rank1 >= rank2:
-#        # same or lesser rank, shift forward to conform
-#        tc2 = get_tcache(freq2)
-#        cache = tc2.cache()
-
-#        if data[0] < cache[0] or data[-1] > cache[-1]:
-#            cache = tc2.extend(data[0], data[-1], 0)
-
-#        idx1 = cache.searchsorted(data[0])
-#        idx2 = cache.searchsorted(data[-1])
-#        return cache[idx1:(idx2+1)]
-
-#    if rank1 < rank2:
-#        # upsampling
-#        failure, regular = conformity_check(data, freq2)
-#        if failure is not None:
-#            raise ValueError("Upsample error: %s does not satisfy frequency %s"
-#                              % (np.datetime64(failure), freq2))
-#        return data
-
-
 @cython.wraparound(False)
 def conformity_check(ndarray[int64_t] data, object freq):
     """
@@ -1601,6 +1564,7 @@ def i8_to_pydt(int64_t i8, object tzinfo = None):
     return Timestamp(i8)
 
 # time zone conversion helpers
+# ------------------------------------------------------------------------------
 
 try:
     import pytz
@@ -1854,7 +1818,6 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
 
     raise ValueError("Field %s not supported" % field)
 
-
 # Some general helper functions
 # ------------------------------------------------------------------------------
 
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
index dc4402112..f266bd24c 100644
--- a/pandas/src/np_datetime.c
+++ b/pandas/src/np_datetime.c
@@ -11,34 +11,6 @@
 #include <numpy/ndarrayobject.h>
 #include "np_datetime.h"
 
-/* Exported as DATETIMEUNITS in multiarraymodule.c */
-static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
-    NPY_STR_Y,
-    NPY_STR_M,
-    NPY_STR_W,
-    NPY_STR_D,
-    NPY_STR_h,
-    NPY_STR_m,
-    NPY_STR_s,
-    NPY_STR_ms,
-    NPY_STR_us,
-    NPY_STR_ns,
-    NPY_STR_ps,
-    NPY_STR_fs,
-    NPY_STR_as,
-    "generic"
-};
-
-static int _days_per_month_table[2][12] = {
-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
-};
-
-static int _month_offset[2][13] = {
-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
-};
-
 /*
  * Returns 1 if the given year is a leap year, 0 otherwise.
  */
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index c936d40c3..cf1bf2fee 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -18,19 +18,39 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
 
 int dayofweek(int y, int m, int d);
 
-/* Days per month, regular year and leap year */
-static int _days_per_month_table[2][12];
-
-/* Table with day offsets for each month (0-based, without and with leap) */
-static int _month_offset[2][13];
+/* Exported as DATETIMEUNITS in multiarraymodule.c */
+static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
+    NPY_STR_Y,
+    NPY_STR_M,
+    NPY_STR_W,
+    NPY_STR_D,
+    NPY_STR_h,
+    NPY_STR_m,
+    NPY_STR_s,
+    NPY_STR_ms,
+    NPY_STR_us,
+    NPY_STR_ns,
+    NPY_STR_ps,
+    NPY_STR_fs,
+    NPY_STR_as,
+    "generic"
+};
+
+static int _days_per_month_table[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
+
+static int _month_offset[2][13] = {
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
 
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
 int is_leapyear(npy_int64 year);
 
-static char *_datetime_strings[NPY_DATETIME_NUMUNITS];
-
 /*
  * Converts a datetime from a datetimestruct to a datetime based
  * on some metadata. The date is assumed to be valid.
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 03dc75c34..c77f85b2f 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -476,6 +476,24 @@ class TestDatetime64(unittest.TestCase):
                             freq='L')
         self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
 
+    def test_slice_year(self):
+        dti = DatetimeIndex(freq='B', start=datetime(2005,1,1), periods=500)
+
+        s = Series(np.arange(len(dti)), index=dti)
+        self.assertEquals(len(s['2005']), 261)
+
+        df = DataFrame(np.random.rand(len(dti), 5), index=dti)
+        self.assertEquals(len(df.ix['2005']), 261)
+
+    def test_slice_month(self):
+        dti = DatetimeIndex(freq='D', start=datetime(2005,1,1), periods=500)
+
+        s = Series(np.arange(len(dti)), index=dti)
+        self.assertEquals(len(s['2005-11']), 30)
+
+        df = DataFrame(np.random.rand(len(dti), 5), index=dti)
+        self.assertEquals(len(df.ix['2005-11']), 30)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],

commit 70d55cd885e8555b493c7f0dd7551536ad65977d
Author: jreback <jeff@reback.net>
Date:   Tue Nov 12 12:24:02 2013 -0500

    API/ENH: pass thru store creation arguments for HDFStore; can be used to support in-memory stores

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 6ae7493fb..17fe4be73 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -289,6 +289,7 @@ API Changes
     - ``flush`` now accepts an ``fsync`` parameter, which defaults to ``False``
       (:issue:`5364`)
     - ``unicode`` indices not supported on ``table`` formats (:issue:`5386`)
+    - pass thru store creation arguments; can be used to support in-memory stores
   - ``JSON``
 
     - added ``date_unit`` parameter to specify resolution of timestamps.
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 73800c066..70fc0572a 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -373,6 +373,7 @@ HDFStore API Changes
 - add the keyword ``dropna=True`` to ``append`` to change whether ALL nan rows are not written
   to the store (default is ``True``, ALL nan rows are NOT written), also settable
   via the option ``io.hdf.dropna_table`` (:issue:`4625`)
+- pass thru store creation arguments; can be used to support in-memory stores
 
 Enhancements
 ~~~~~~~~~~~~
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index bc2f41502..49f60a705 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -376,7 +376,7 @@ class HDFStore(StringMixin):
         self._complib = complib
         self._fletcher32 = fletcher32
         self._filters = None
-        self.open(mode=mode)
+        self.open(mode=mode, **kwargs)
 
     @property
     def root(self):
@@ -465,7 +465,7 @@ class HDFStore(StringMixin):
 
     iteritems = items
 
-    def open(self, mode='a'):
+    def open(self, mode='a', **kwargs):
         """
         Open the file in the specified mode
 
@@ -502,11 +502,11 @@ class HDFStore(StringMixin):
                                               fletcher32=self._fletcher32)
 
         try:
-            self._handle = tables.openFile(self._path, self._mode)
+            self._handle = tables.openFile(self._path, self._mode, **kwargs)
         except (IOError) as e:  # pragma: no cover
             if 'can not be written' in str(e):
                 print('Opening %s in read-only mode' % self._path)
-                self._handle = tables.openFile(self._path, 'r')
+                self._handle = tables.openFile(self._path, 'r', **kwargs)
             else:
                 raise
         except (Exception) as e:
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 737acef20..759f63a96 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -489,6 +489,28 @@ class TestHDFStore(unittest.TestCase):
             store.close()
             self.assert_(not store.is_open)
 
+    def test_open_args(self):
+
+        with ensure_clean_path(self.path) as path:
+
+            df = tm.makeDataFrame()
+
+            # create an in memory store
+            store = HDFStore(path,mode='a',driver='H5FD_CORE',driver_core_backing_store=0)
+            store['df'] = df
+            store.append('df2',df)
+
+            tm.assert_frame_equal(store['df'],df)
+            tm.assert_frame_equal(store['df2'],df)
+
+            store.close()
+
+            # only supported on pytable >= 3.0.0
+            if LooseVersion(tables.__version__) >= '3.0.0':
+
+                # the file should not have actually been written
+                self.assert_(os.path.exists(path) is False)
+
     def test_flush(self):
 
         with ensure_clean_store(self.path) as store:

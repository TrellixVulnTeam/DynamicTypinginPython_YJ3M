commit 5fc081e2dd03c9b7d656faa7fb9bdbc0a4ff4cc1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Jul 30 21:40:05 2011 -0400

    ENH: stack and unstack methods

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 46a8e012a..2daf3ef91 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -35,8 +35,10 @@ def isnull(input):
     if isinstance(input, np.ndarray):
         if input.dtype.kind in ('O', 'S'):
             # Working around NumPy ticket 1542
-            result = input.copy().astype(bool)
-            result[:] = _tseries.isnullobj(input)
+            shape = input.shape
+            result = np.empty(shape, dtype=bool)
+            vec = _tseries.isnullobj(input.ravel())
+            result[:] = vec.reshape(shape)
         else:
             result = -np.isfinite(input)
     else:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a11dd7956..d5747e1be 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1023,35 +1023,27 @@ class DataFrame(NDFrame):
 
     def sortlevel(self, level=0, axis=0, ascending=True):
         """
-        Sort value by chosen axis (break ties using other axis)
+        Sort value by chosen axis and primary level. Data will be
+        lexicographically sorted by the chosen level followed by the other
+        levels (in order)
 
-        Note
-        ----
-        A LongPanel must be sorted to convert to a WidePanel
+        Parameters
+        ----------
+        level : int
+        axis : int
+        ascending : bool, default True
 
         Returns
         -------
-        LongPanel (in sorted order)
+        sorted : DataFrame
         """
         the_axis = self._get_axis(axis)
-
         if not isinstance(the_axis, MultiIndex):
             raise Exception('can only sort by level with a hierarchical index')
 
-        labels = list(the_axis.labels)
-        primary = labels.pop(level)
-
-        # Lexsort starts from END
-        indexer = np.lexsort(tuple(labels[::-1]) + (primary,))
-
-        if not ascending:
-            indexer = indexer[::-1]
-
-        new_labels = [lab.take(indexer) for lab in the_axis.labels]
+        new_axis, indexer = the_axis.sortlevel(level, ascending=ascending)
         new_values = self.values.take(indexer, axis=0)
 
-        new_axis = MultiIndex(levels=self.index.levels, labels=new_labels)
-
         if axis == 0:
             index = new_axis
             columns = self.columns
@@ -1448,6 +1440,21 @@ class DataFrame(NDFrame):
         else:
             return wp
 
+    def stack(self):
+        """
+        Convert DataFrame to Series with multi-level Index
+
+        Returns
+        -------
+        stacked : Series
+        """
+        N, K = len(self.index), len(self.columns)
+        ilabels = np.arange(N).repeat(K)
+        clabels = np.tile(np.arange(K), N).ravel()
+        index = MultiIndex(levels=[self.index, self.columns],
+                           labels=[ilabels, clabels])
+        return Series(self.values.ravel(), index=index)
+
     #----------------------------------------------------------------------
     # Time series-related
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 409fb1f98..bdd643b38 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -53,18 +53,6 @@ class Index(np.ndarray):
             return self.item()
             # raise Exception('Cannot create 0-dimensional Index!')
 
-        return
-
-        # New instance creation
-        if obj is None:
-            pass
-        # New from template / slicing
-        elif isinstance(obj, type(self)) and len(self) != len(obj.indexMap):
-            pass
-        # View casting
-        else:
-            pass
-
     def summary(self):
         if len(self) > 0:
             index_summary = ', %s to %s' % (self[0], self[-1])
@@ -75,7 +63,7 @@ class Index(np.ndarray):
     @property
     def indexMap(self):
         if not hasattr(self, '_cache_indexMap'):
-            self._cache_indexMap = _tseries.map_indices(self)
+            self._cache_indexMap = _tseries.map_indices_buf(self)
             self._verify_integrity()
 
         return self._cache_indexMap
@@ -396,21 +384,26 @@ class MultiIndex(Index):
     """
 
     def __new__(cls, levels=None, labels=None):
-        arr = np.empty(len(labels[0]), dtype=object)
-        arr[:] = zip(*labels)
-        arr = arr.view(cls)
-        return arr
+        return np.arange(len(labels[0]), dtype=object).view(cls)
 
     def __init__(self, levels, labels):
         self.levels = [_ensure_index(lev) for lev in levels]
         self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
-        self._verify_integrity()
 
     def __array_finalize__(self, obj):
         pass
         # self.labels = getattr(obj, 'labels', None)
         # self.levels = getattr(obj, 'levels', None)
 
+    @property
+    def indexMap(self):
+        if not hasattr(self, '_cache_indexMap'):
+            zipped = zip(*self.labels)
+            self._cache_indexMap = _tseries.map_indices_list(zipped)
+            self._verify_integrity()
+
+        return self._cache_indexMap
+
     @property
     def nlevels(self):
         return len(self.levels)
@@ -438,8 +431,8 @@ class MultiIndex(Index):
     def __getitem__(self, key):
         arr_idx = self.view(np.ndarray)
         if np.isscalar(key):
-            return tuple(self.levels[i][k]
-                         for i, k in enumerate(arr_idx[key]))
+            return tuple(lev[lab[key]]
+                         for lev, lab in zip(self.levels, self.labels))
         else:
             if _is_bool_indexer(key):
                 key = np.asarray(key)
@@ -726,6 +719,24 @@ class MultiIndex(Index):
 
         return self.__bounds
 
+    def sortlevel(self, level=0, ascending=True):
+        """
+
+        """
+        labels = list(self.labels)
+        primary = labels.pop(level)
+
+        # Lexsort starts from END
+        indexer = np.lexsort(tuple(labels[::-1]) + (primary,))
+
+        if not ascending:
+            indexer = indexer[::-1]
+
+        new_labels = [lab.take(indexer) for lab in self.labels]
+        new_index = MultiIndex(levels=self.levels, labels=new_labels)
+
+        return new_index, indexer
+
 # For utility purposes
 
 NULL_INDEX = Index([])
diff --git a/pandas/core/series.py b/pandas/core/series.py
index de27d2ce2..4b3cc7552 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -860,8 +860,8 @@ class Series(np.ndarray, PandasObject):
         result = Series(np.where(isnull(this), other, this), index=newIndex)
         return result
 
-#-------------------------------------------------------------------------------
-# Reindexing, sorting
+    #----------------------------------------------------------------------
+    # Reindexing, sorting
 
     def sort(self, axis=0, kind='quicksort', order=None):
         """
@@ -934,6 +934,63 @@ class Series(np.ndarray, PandasObject):
 
         return Series(arr[sortedIdx], index=self.index[sortedIdx])
 
+    def sortlevel(self, level=0, ascending=True):
+        """
+        Sort multilevel index by chosen level. Data will be lexicographically
+        sorted by the chosen level followed by the other levels (in order)
+
+        Parameters
+        ----------
+        level : int
+        ascending : bool, default True
+
+        Returns
+        -------
+        sorted : Series
+        """
+        if not isinstance(self.index, MultiIndex):
+            raise Exception('can only sort by level with a hierarchical index')
+
+        new_index, indexer = self.index.sortlevel(level, ascending=ascending)
+        new_values = self.values.take(indexer)
+        return Series(new_values, index=new_index)
+
+    def unstack(self, level=-1):
+        """
+        "Unstack" Series with multi-level index to produce DataFrame
+
+        Parameters
+        ----------
+        level : int, default last level
+            Level to "unstack"
+
+        Examples
+        --------
+        >>> s
+        one  a   1.
+        one  b   2.
+        two  a   3.
+        two  b   4.
+
+        >>> s.unstack(level=-1)
+             a   b
+        one  1.  2.
+        two  3.  4.
+
+        >>> s.unstack(level=0)
+           one  two
+        a  1.   2.
+        b  3.   4.
+
+        Returns
+        -------
+        unstacked : DataFrame
+        """
+        return unstack(self.values, self.index, level=level)
+
+    #----------------------------------------------------------------------
+    # function application
+
     def map(self, arg):
         """
         Map values of Series using input correspondence (which can be
@@ -1442,6 +1499,95 @@ class TimeSeries(Series):
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
+def unstack(values, index, level=-1):
+    """
+    "Unstack" Series with multi-level index to produce DataFrame
+
+    Parameters
+    ----------
+    level : int, default last level
+        Level to "unstack"
+
+    Examples
+    --------
+    >>> s
+    one  a   1.
+    one  b   2.
+    two  a   3.
+    two  b   4.
+
+    >>> s.unstack(level=-1)
+         a   b
+    one  1.  2.
+    two  3.  4.
+
+    >>> s.unstack(level=0)
+       one  two
+    a  1.   2.
+    b  3.   4.
+
+    Returns
+    -------
+    unstacked : DataFrame
+    """
+    from pandas.core.frame import DataFrame
+
+    v = level
+    if v < 0:
+        v = index.nlevels + v
+
+    labs = index.labels
+    to_sort = labs[:v] + labs[v+1:] + [labs[v]]
+    indexer = np.lexsort(to_sort[::-1])
+
+    sorted_labels = [l.take(indexer) for l in to_sort[:-1]]
+    new_levels = list(index.levels)
+    columns = new_levels.pop(v)
+
+    lshape = index.levshape
+    full_shape = np.prod(lshape[:v] + lshape[v+1:]), lshape[v]
+
+    # make the mask
+    group_index = sorted_labels[0]
+    prev_levsize = len(new_levels[0])
+    for ilev, ilab in zip(new_levels[1:], sorted_labels[1:]):
+        group_index = prev_levsize * ilab
+        prev_levsize = len(ilev)
+
+    group_mask = np.zeros(full_shape[0], dtype=bool)
+    group_mask.put(group_index, True)
+
+    selector = labs[v] + lshape[v] * group_index
+    mask = np.zeros(np.prod(full_shape), dtype=bool)
+    mask.put(selector, True)
+
+    # compress labels
+    unique_groups = np.arange(full_shape[0])[group_mask]
+    compressor = group_index.searchsorted(unique_groups)
+
+    result_labels = []
+    for cur in sorted_labels:
+        # bit of a kludgy way to get at the label
+        # labels = np.empty(full_shape, dtype=np.int32)
+        # labels.fill(-1)
+        # np.putmask(labels.ravel(), mask, cur)
+        # result_labels.append(labels.max(1).take(compressor))
+
+        result_labels.append(cur.take(compressor))
+
+    # place the values
+    new_values = np.empty(full_shape, dtype=values.dtype)
+    new_values.fill(np.nan)
+    new_values.ravel()[mask] = values
+    new_values = new_values.take(unique_groups, axis=0)
+
+    # construct the new index
+    if len(new_levels) == 1:
+        new_index = Index(new_levels[0])
+    else:
+        new_index = MultiIndex(levels=new_levels, labels=result_labels)
+
+    return DataFrame(new_values, index=new_index, columns=columns)
 
 _ndgi = ndarray.__getitem__
 
diff --git a/pandas/src/common.pyx b/pandas/src/common.pyx
index 81edb03b4..1a3f8286f 100644
--- a/pandas/src/common.pyx
+++ b/pandas/src/common.pyx
@@ -107,6 +107,96 @@ cpdef map_indices(ndarray index):
 
     return result
 
+cpdef map_indices_buf(ndarray[object] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+cpdef map_indices_list(list index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+from libc.stdlib cimport malloc, free
+
+cdef class MultiMap:
+    '''
+    Need to come up with a better data structure for multi-level indexing
+    '''
+
+    cdef:
+        dict store
+        Py_ssize_t depth, length
+
+    def __init__(self, list label_arrays):
+        cdef:
+            int32_t **ptr
+            Py_ssize_t i
+
+        self.depth = len(label_arrays)
+        self.length = len(label_arrays[0])
+        self.store = {}
+
+        ptr = <int32_t**> malloc(self.depth * sizeof(int32_t*))
+
+        for i in range(self.depth):
+            ptr[i] = <int32_t*> (<ndarray> label_arrays[i]).data
+
+        free(ptr)
+
+    cdef populate(self, int32_t **ptr):
+        cdef Py_ssize_t i, j
+        cdef int32_t* buf
+        cdef dict level
+
+        for i from 0 <= i < self.length:
+
+            for j from 0 <= j < self.depth - 1:
+                pass
+
+    cpdef get(self, tuple key):
+        cdef Py_ssize_t i
+        cdef dict level = self.store
+
+        for i from 0 <= i < self.depth:
+            if i == self.depth - 1:
+                return level[i]
+            else:
+                level = level[i]
+
+        raise KeyError(key)
+
+
 def isAllDates(ndarray index):
     cdef int i, length
     cdef flatiter iter
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 93773b4c9..9a0fd51b6 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -1,5 +1,3 @@
-from libc.stdlib cimport malloc, free
-
 #-------------------------------------------------------------------------------
 # Groupby-related functions
 
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 784080eda..02a66978f 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -308,7 +308,7 @@ class PanelOLS(OLS):
 
             dummies = _convertDummies(dummies, cat_mappings.get(effect))
             dummies = dummies.addPrefix('%s_' % effect)
-            panel = panel.leftJoin(dummies)
+            panel = panel.join(dummies)
 
         return panel
 

commit fa4b1bd62111d600e365e61bf3848cd9e2234134
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Dec 24 11:57:40 2011 -0500

    ENH: benching / testing with khash

diff --git a/bench/bench_groupby.py b/bench/bench_groupby.py
index 724a1e1e7..78e2c51ab 100644
--- a/bench/bench_groupby.py
+++ b/bench/bench_groupby.py
@@ -4,8 +4,8 @@ from pandas.util.testing import rands
 import string
 import random
 
-k = 200
-n = 1000
+k = 20000
+n = 10
 
 foo = np.tile(np.array([rands(10) for _ in xrange(k)], dtype='O'), n)
 foo2 = list(foo)
@@ -20,8 +20,13 @@ import pandas._sandbox as sbx
 
 def f():
     table = sbx.StringHashTable(len(df))
-    ret = table.factorize(['A'])
+    ret = table.factorize(df['A'])
     return ret
+def g():
+    table = sbx.PyObjectHashTable(len(df))
+    ret = table.factorize(df['A'])
+    return ret
+
 ret = f()
 
 """
diff --git a/bench/bench_khash_dict.py b/bench/bench_khash_dict.py
new file mode 100644
index 000000000..1d803bec8
--- /dev/null
+++ b/bench/bench_khash_dict.py
@@ -0,0 +1,78 @@
+"""
+Some comparisons of khash.h to Python dict
+"""
+
+import numpy as np
+import os
+
+from vbench.api import Benchmark
+from pandas.util.testing import rands
+import pandas._tseries as lib
+import pandas._sandbox as sbx
+import time
+
+import psutil
+
+pid = os.getpid()
+proc = psutil.Process(pid)
+
+def object_test_data(n):
+    pass
+
+def string_test_data(n):
+    return np.array([rands(10) for _ in xrange(n)], dtype='O')
+
+def int_test_data(n):
+    return np.arange(n, dtype='i8')
+
+N = 1000000
+
+#----------------------------------------------------------------------
+# Benchmark 1: map_locations
+
+def map_locations_python_object():
+    arr = string_test_data(N)
+    return _timeit(lambda: lib.map_indices_object(arr))
+
+def map_locations_khash_object():
+    arr = string_test_data(N)
+    def f():
+        table = sbx.PyObjectHashTable(len(arr))
+        table.map_locations(arr)
+    return _timeit(f)
+
+def _timeit(f, iterations=10):
+    start = time.time()
+    for _ in xrange(iterations):
+        foo = f()
+    elapsed = time.time() - start
+    return elapsed
+
+#----------------------------------------------------------------------
+# Benchmark 2: lookup_locations
+
+def lookup_python(values):
+    table = lib.map_indices_object(values)
+    return _timeit(lambda: lib.merge_indexer_object(values, table))
+
+def lookup_khash(values):
+    table = sbx.PyObjectHashTable(len(values))
+    table.map_locations(values)
+    locs = table.lookup_locations(values)
+    # elapsed = _timeit(lambda: table.lookup_locations2(values))
+    return table
+
+def leak(values):
+    for _ in xrange(100):
+        print proc.get_memory_info()
+        table = lookup_khash(values)
+        # table.destroy()
+
+arr = string_test_data(N)
+
+#----------------------------------------------------------------------
+# Benchmark 3: unique
+
+#----------------------------------------------------------------------
+# Benchmark 4: factorize
+
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index ccc57a606..3984607e2 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -1,7 +1,11 @@
+# cython: wraparound=False
+# cython: boundscheck=False
+
 from numpy cimport *
 cimport numpy as cnp
 import numpy as np
 
+from cpython cimport *
 cimport cpython
 
 cnp.import_array()
@@ -317,20 +321,24 @@ cdef class StringHashTable:
         # return None
         return reverse, labels, counts[:count].copy()
 
+from libc.stdlib cimport free
+
 cdef class PyObjectHashTable:
 
     cdef:
         kh_pymap_t *table
 
     def __init__(self, size_hint=1):
-        if size_hint is not None:
-            kh_resize_pymap(self.table, size_hint)
-
-    def __cinit__(self):
         self.table = kh_init_pymap()
+        kh_resize_pymap(self.table, size_hint)
 
     def __dealloc__(self):
+        if self.table is not NULL:
+            self.destroy()
+
+    cpdef destroy(self):
         kh_destroy_pymap(self.table)
+        self.table = NULL
 
     cpdef get_item(self, object val):
         cdef khiter_t k
@@ -360,6 +368,74 @@ cdef class PyObjectHashTable:
         else:
             raise KeyError(key)
 
+    def map_locations(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            int ret
+            object val
+            khiter_t k
+
+        for i in range(n):
+            val = values[i]
+            k = kh_put_pymap(self.table, <PyObject*>val, &ret)
+            # print 'putting %s, %s' % (val, count)
+            self.table.vals[k] = i
+
+    def lookup_locations(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            int ret
+            object val
+            khiter_t k
+            ndarray[int32_t] locs = np.empty(n, dtype='i4')
+
+        for i in range(n):
+            val = values[i]
+            k = kh_get_pymap(self.table, <PyObject*>val)
+            if k != self.table.n_buckets:
+                locs[i] = self.table.vals[k]
+            else:
+                locs[i] = -1
+
+        return locs
+
+    def lookup_locations2(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            int ret
+            object val
+            khiter_t k
+            long hval
+            ndarray[int32_t] locs = np.empty(n, dtype='i4')
+
+        # for i in range(n):
+        #     val = values[i]
+            # hval = PyObject_Hash(val)
+            # k = kh_get_pymap(self.table, <PyObject*>val)
+
+        return locs
+
+    def unique(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            ndarray[int32_t] labels = np.empty(n, dtype=np.int32)
+            ndarray[int32_t] counts = np.empty(n, dtype=np.int32)
+            dict reverse = {}
+            Py_ssize_t idx, count = 0
+            int ret
+            object val
+            khiter_t k
+            list uniques = []
+
+        for i in range(n):
+            val = values[i]
+            k = kh_get_pymap(self.table, <PyObject*>val)
+            if k == self.table.n_buckets:
+                k = kh_put_pymap(self.table, <PyObject*>val, &ret)
+                uniques.append(val)
+
+        return uniques
+
     def factorize(self, ndarray[object] values):
         cdef:
             Py_ssize_t i, n = len(values)
@@ -381,8 +457,8 @@ cdef class PyObjectHashTable:
             else:
                 k = kh_put_pymap(self.table, <PyObject*>val, &ret)
                 # print 'putting %s, %s' % (val, count)
-                if not ret:
-                    kh_del_pymap(self.table, k)
+                # if not ret:
+                #     kh_del_pymap(self.table, k)
 
                 self.table.vals[k] = count
                 reverse[count] = val
@@ -390,6 +466,21 @@ cdef class PyObjectHashTable:
                 counts[count] = 1
                 count += 1
 
-        # return None
         return reverse, labels, counts[:count].copy()
 
+def lookup_locations2(ndarray[object] values):
+    cdef:
+        Py_ssize_t i, n = len(values)
+        int ret
+        object val
+        khiter_t k
+        long hval
+        ndarray[int32_t] locs = np.empty(n, dtype='i4')
+
+    # for i in range(n):
+    #     val = values[i]
+        # hval = PyObject_Hash(val)
+        # k = kh_get_pymap(self.table, <PyObject*>val)
+
+    return locs
+

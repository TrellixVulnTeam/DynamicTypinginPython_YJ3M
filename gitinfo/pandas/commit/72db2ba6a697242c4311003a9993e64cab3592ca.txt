commit 72db2ba6a697242c4311003a9993e64cab3592ca
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 2 23:12:31 2012 -0500

    BUG: inner join on columns with MultiIndex, further performance enhancement

diff --git a/doc/source/merging.rst b/doc/source/merging.rst
index 0e22a9edf..1f9a2a5a9 100644
--- a/doc/source/merging.rst
+++ b/doc/source/merging.rst
@@ -69,7 +69,7 @@ Here's a description of what each argument is for:
 DataFrame instance method, with the calling DataFrame being implicitly
 considered the left object in the join.
 
-The related ``DataFrame.join``, uses ``merge`` internally for the
+The related ``DataFrame.join`` method, uses ``merge`` internally for the
 index-on-index and index-on-column(s) joins, but *joins on indexes* by default
 rather than trying to join on common columns (the default behavior for
 ``merge``). If you are joining on index, you may wish to use ``DataFrame.join``
@@ -172,10 +172,20 @@ indexes:
 Joining key columns on an index
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-``join`` takes an optional ``on`` argument which should be a column name in the
-calling DataFrame which will be used to "align" the passed DataFrame. The
-joining currently aligns the calling DataFrame's column (or columns) on the
-passed DataFrame's index. This is best illustrated by example:
+``join`` takes an optional ``on`` argument which may be a column or multiple
+column names, which specifies that the passed DataFrame is to be aligned on
+that column in the DataFrame. These two function calls are completely
+equivalent:
+
+::
+
+    left.join(right, on=key_or_keys)
+    merge(left, right, left_on=key_or_keys, right_index=True,
+          how='left', sort=False)
+
+Obviously you can choose whichever form you find more convenient. For
+many-to-one joins (where one of the DataFrame's is already indexed by the join
+key), using ``join`` may be more convenient. Here is a simple example:
 
 .. ipython:: python
 
@@ -185,6 +195,8 @@ passed DataFrame's index. This is best illustrated by example:
    df
    to_join
    df.join(to_join, on='key')
+   merge(df, to_join, left_on='key', right_index=True,
+         how='left', sort=False)
 
 .. _merging.multikey_join:
 
@@ -212,6 +224,7 @@ To join on multiple keys, the passed DataFrame must have a ``MultiIndex``:
    data
    to_join
 
+Now this can be joined by passing the two key column names:
 
 .. ipython:: python
 
@@ -219,14 +232,16 @@ To join on multiple keys, the passed DataFrame must have a ``MultiIndex``:
 
 .. _merging.df_inner_join:
 
-This is by default a "many-to-one" or "VLOOKUP"-style left join operation. An
-inner join is also supported:
+The default for ``DataFrame.join`` is to perform a left join (essentially a
+"VLOOKUP" operation, for Excel users), which uses only the keys found in the
+calling DataFrame. Other join types, for example inner join, can be just as
+easily performed:
 
 .. ipython:: python
 
    data.join(to_join, on=['key1', 'key2'], how='inner')
 
-This drops any rows where there was no match.
+As you can see, this drops any rows where there was no match.
 
 Overlapping value columns
 ~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -235,11 +250,14 @@ The merge ``suffixes`` argument takes a tuple of list of strings to append to
 overlapping column names in the input DataFrames to disambiguate the result
 columns:
 
+.. ipython:: python
+
    left = DataFrame({'key': ['foo', 'foo'], 'value': [1, 2]})
    right = DataFrame({'key': ['foo', 'foo'], 'value': [4, 5]})
    merge(left, right, on='key', suffixes=['_left', '_right'])
 
-``DataFrame.join`` has ``lsuffix`` and ``rsuffix`` arguments
+``DataFrame.join`` has ``lsuffix`` and ``rsuffix`` arguments which behave
+similarly.
 
 Joining multiple DataFrame objects at once
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a8cc4f153..4270c0b59 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2840,7 +2840,7 @@ class DataFrame(NDFrame):
 
         return merge(self, other, left_on=on, how=how,
                      left_index=on is None, right_index=True,
-                     suffixes=(lsuffix, rsuffix))
+                     suffixes=(lsuffix, rsuffix), sort=False)
 
     def merge(self, right, how='inner', on=None, left_on=None, right_on=None,
               left_index=False, right_index=False, sort=True,
diff --git a/pandas/src/hashtable.pyx b/pandas/src/hashtable.pyx
index 28d513d9a..3601169c6 100644
--- a/pandas/src/hashtable.pyx
+++ b/pandas/src/hashtable.pyx
@@ -700,7 +700,6 @@ cdef class DictFactorizer:
             Py_ssize_t idx, count = self.count
             int ret
             object val
-            khiter_t k
 
         labels = np.empty(n, dtype=np.int32)
         counts = np.empty(count + n, dtype=np.int32)
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index d477260e2..ea31782da 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -109,7 +109,7 @@ class _MergeOperation(object):
                        len(self.left_join_keys) == right_ax.nlevels)
 
                 right_indexer = _get_multiindex_indexer(self.left_join_keys,
-                                                        right_ax)
+                                                        right_ax, sort=False)
             else:
                 right_indexer = right_ax.get_indexer(self.left_join_keys[0])
 
@@ -121,14 +121,12 @@ class _MergeOperation(object):
                 assert(isinstance(left_ax, MultiIndex) and
                        len(self.right_join_keys) == left_ax.nlevels)
                 left_indexer = _get_multiindex_indexer(self.right_join_keys,
-                                                       left_ax)
+                                                       left_ax, sort=False)
             else:
                 left_indexer = left_ax.get_indexer(self.right_join_keys[0])
         else:
             # max groups = largest possible number of distinct groups
-            left_key, right_key, max_groups = \
-                _get_group_keys(self.left_join_keys, self.right_join_keys,
-                                sort=self.sort)
+            left_key, right_key, max_groups = self._get_group_keys()
 
             join_func = _join_functions[self.how]
             left_indexer, right_indexer = join_func(left_key.astype('i4'),
@@ -199,21 +197,77 @@ class _MergeOperation(object):
             self.drop_keys = True
 
         # this is a touch kludgy, but accomplishes the goal
+        left_keys = None
+        if self.left_on is not None:
+            self.left, left_keys, left_names = \
+                _get_keys(self.left, self.left_on, drop=self.drop_keys)
+            join_names = left_names
+
+        right_keys = None
         if self.right_on is not None:
             self.right, right_keys, right_names = \
                 _get_keys(self.right, self.right_on, drop=self.drop_keys)
             join_names = right_names
+
+        return left_keys, right_keys, join_names
+
+    def _get_group_keys(self):
+        """
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+
+        """
+        if self.left_index:
+            if isinstance(self.left.index, MultiIndex):
+                left_keys = [lev.values.take(lab)
+                              for lev, lab in zip(self.left.index.levels,
+                                                  self.left.index.labels)]
+            else:
+                left_keys = [self.left.index.values]
         else:
-            right_keys = [self.right.index.values]
+            left_keys = self.left_join_keys
 
-        if self.left_on is not None:
-            self.left, left_keys, left_names = \
-                _get_keys(self.left, self.left_on, drop=self.drop_keys)
-            join_names = left_names
+        if self.right_index:
+            if isinstance(self.right.index, MultiIndex):
+                right_keys = [lev.values.take(lab)
+                              for lev, lab in zip(self.right.index.levels,
+                                                  self.right.index.labels)]
+            else:
+                right_keys = [self.right.index.values]
         else:
-            left_keys = [self.left.index.values]
+            right_keys = self.right_join_keys
 
-        return left_keys, right_keys, join_names
+        assert(len(left_keys) == len(right_keys))
+
+        left_labels = []
+        right_labels = []
+        group_sizes = []
+
+        for lk, rk in zip(left_keys, right_keys):
+            llab, rlab, count = _factorize_objects(lk, rk, sort=self.sort)
+
+            left_labels.append(llab)
+            right_labels.append(rlab)
+            group_sizes.append(count)
+
+        left_group_key = get_group_index(left_labels, group_sizes)
+        right_group_key = get_group_index(right_labels, group_sizes)
+
+        max_groups = 1L
+        for x in group_sizes:
+            max_groups *= long(x)
+
+        if max_groups > 2**63:  # pragma: no cover
+            raise Exception('Combinatorial explosion! (boom)')
+
+        left_group_key, right_group_key, max_groups = \
+            _factorize_int64(left_group_key, right_group_key,
+                             sort=self.sort)
+        return left_group_key, right_group_key, max_groups
 
 def _get_keys(frame, on, drop=False):
     to_drop = []
@@ -239,46 +293,8 @@ def _get_keys(frame, on, drop=False):
 
     return frame, keys, names
 
-def _get_group_keys(left_keys, right_keys, sort=True):
-    """
-
-    Parameters
-    ----------
-
-    Returns
-    -------
-
-    """
-    assert(len(left_keys) == len(right_keys))
-
-    left_labels = []
-    right_labels = []
-    group_sizes = []
-
-    for lk, rk in zip(left_keys, right_keys):
-        llab, rlab, count = _factorize_objects(lk, rk, sort=sort)
-
-        left_labels.append(llab)
-        right_labels.append(rlab)
-        group_sizes.append(count)
-
-    left_group_key = get_group_index(left_labels, group_sizes)
-    right_group_key = get_group_index(right_labels, group_sizes)
-
-    max_groups = 1L
-    for x in group_sizes:
-        max_groups *= long(x)
 
-    if max_groups > 2**63:  # pragma: no cover
-        raise Exception('Combinatorial explosion! (boom)')
-
-    left_group_key, right_group_key, max_groups = \
-        _factorize_int64(left_group_key, right_group_key,
-                         sort=sort)
-    return left_group_key, right_group_key, max_groups
-
-
-def _get_multiindex_indexer(join_keys, index):
+def _get_multiindex_indexer(join_keys, index, sort=True):
     shape = []
     labels = []
     for level, key in zip(index.levels, join_keys):
@@ -287,14 +303,24 @@ def _get_multiindex_indexer(join_keys, index):
         labels.append(lab)
         shape.append(len(rizer.uniques))
 
-    left_group_key = get_group_index(labels, shape).astype('i4')
-    right_group_key = get_group_index(index.labels, shape).astype('i4')
+    left_group_key = get_group_index(labels, shape) #.astype('i4')
+    right_group_key = get_group_index(index.labels, shape) #.astype('i4')
+
+    left_group_key, right_group_key, max_groups = \
+        _factorize_int64(left_group_key, right_group_key,
+                         sort=sort)
+
     left_indexer, right_indexer = \
-        lib.left_outer_join(left_group_key, right_group_key,
-                            np.prod(shape))
+        lib.left_outer_join(left_group_key.astype('i4'),
+                            right_group_key.astype('i4'),
+                            max_groups)
+
+    return right_indexer
+
+    # after refactorizing, I don't think reordering is necessary
 
     # NOW! reorder
-    return right_indexer.take(left_indexer.argsort())
+    #right_indexer.take(left_indexer.argsort())
 
 def _maybe_make_list(obj):
     if obj is not None and not isinstance(obj, (tuple, list)):
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 0b16247c2..f56effe9a 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -347,9 +347,40 @@ class TestMerge(unittest.TestCase):
         joined = df1.join(df2, how='outer').sortlevel(0)
         ex_index = index1.get_tuple_index() + index2.get_tuple_index()
         expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
+
         assert_frame_equal(joined, expected)
         self.assertEqual(joined.index.names, index1.names)
 
+    def test_join_inner_multiindex(self):
+        key1 = ['bar', 'bar', 'bar', 'foo', 'foo', 'baz', 'baz', 'qux',
+               'qux', 'snap']
+        key2 = ['two', 'one', 'three', 'one', 'two', 'one', 'two', 'two',
+               'three', 'one']
+
+        data = np.random.randn(len(key1))
+        data = DataFrame({'key1' : key1, 'key2' : key2,
+                         'data' : data})
+
+        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
+                                   ['one', 'two', 'three']],
+                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
+                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
+                           names=['first', 'second'])
+        to_join = DataFrame(np.random.randn(10, 3), index=index,
+                            columns=['j_one', 'j_two', 'j_three'])
+
+        joined = data.join(to_join, on=['key1', 'key2'], how='inner')
+        expected = merge(data, to_join.reset_index(),
+                         left_on=['key1', 'key2'],
+                         right_on=['first', 'second'], how='inner',
+                         sort=False)
+
+        expected = expected.drop(['first', 'second'], axis=1)
+        expected.index = joined.index
+
+        self.assert_(joined.index.is_monotonic)
+        assert_frame_equal(joined, expected)
+
     def test_join_float64_float32(self):
         a = DataFrame(randn(10,2), columns=['a','b'])
         b = DataFrame(randn(10,1), columns=['c']).astype(np.float32)

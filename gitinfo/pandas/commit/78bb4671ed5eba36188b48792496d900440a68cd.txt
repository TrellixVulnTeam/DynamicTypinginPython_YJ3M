commit 78bb4671ed5eba36188b48792496d900440a68cd
Author: Dan Birken <birken@gmail.com>
Date:   Thu Jan 23 18:07:24 2014 -0800

    PERF: Speed up pd.to_datetime() by optionally inferring dt format #5490
    
    Given an array of strings that represent datetimes, infer_format=True
    will attempt to guess the format of the datetimes, and if it can infer
    the format, it will use a faster function to convert/import the
    datetimes.  In cases where this speed-up can be used, the function
    should be about 10x faster.

diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index bae93602c..8cce0162e 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -18,6 +18,7 @@ from pandas import (Index, Series, TimeSeries, DataFrame,
 from pandas.core.daterange import DateRange
 import pandas.core.datetools as datetools
 import pandas.tseries.offsets as offsets
+import pandas.tseries.tools as tools
 import pandas.tseries.frequencies as fmod
 import pandas as pd
 
@@ -49,6 +50,11 @@ def _skip_if_no_pytz():
     except ImportError:
         raise nose.SkipTest("pytz not installed")
 
+def _skip_if_has_locale():
+    import locale
+    lang, _ = locale.getlocale()
+    if lang is not None:
+        raise nose.SkipTest("Specific locale is set {0}".format(lang))
 
 class TestTimeSeriesDuplicates(tm.TestCase):
     _multiprocess_can_split_ = True
@@ -909,12 +915,8 @@ class TestTimeSeries(tm.TestCase):
         self.assertEquals(result[0], s[0])
 
     def test_to_datetime_with_apply(self):
-
         # this is only locale tested with US/None locales
-        import locale
-        (lang,encoding) = locale.getlocale()
-        if lang is not None:
-            raise nose.SkipTest("format codes cannot work with a locale of {0}".format(lang))
+        _skip_if_has_locale()
 
         # GH 5195
         # with a format and coerce a single item to_datetime fails
@@ -3124,6 +3126,177 @@ class TestSlicing(tm.TestCase):
         self.assertEqual(dr[1], Timestamp('2014-01-30'))
 
 
+class TestToDatetimeInferFormat(tm.TestCase):
+    def test_to_datetime_infer_datetime_format_consistent_format(self):
+        time_series = pd.Series(
+            pd.date_range('20000101', periods=50, freq='H')
+        )
+
+        test_formats = [
+            '%m-%d-%Y',
+            '%m/%d/%Y %H:%M:%S.%f',
+            '%Y-%m-%dT%H:%M:%S.%f',
+        ]
+
+        for test_format in test_formats:
+            s_as_dt_strings = time_series.apply(
+                lambda x: x.strftime(test_format)
+            )
+
+            with_format = pd.to_datetime(s_as_dt_strings, format=test_format)
+            no_infer = pd.to_datetime(
+                s_as_dt_strings, infer_datetime_format=False
+            )
+            yes_infer = pd.to_datetime(
+                s_as_dt_strings, infer_datetime_format=True
+            )
+
+            # Whether the format is explicitly passed, it is inferred, or
+            # it is not inferred, the results should all be the same
+            self.assert_(np.array_equal(with_format, no_infer))
+            self.assert_(np.array_equal(no_infer, yes_infer))
+
+    def test_to_datetime_infer_datetime_format_inconsistent_format(self):
+        test_series = pd.Series(
+            np.array([
+                '01/01/2011 00:00:00',
+                '01-02-2011 00:00:00',
+                '2011-01-03T00:00:00',
+        ]))
+
+        # When the format is inconsistent, infer_datetime_format should just
+        # fallback to the default parsing
+        self.assert_(np.array_equal(
+            pd.to_datetime(test_series, infer_datetime_format=False),
+            pd.to_datetime(test_series, infer_datetime_format=True)
+        ))
+
+        test_series = pd.Series(
+            np.array([
+                'Jan/01/2011',
+                'Feb/01/2011',
+                'Mar/01/2011',
+        ]))
+
+        self.assert_(np.array_equal(
+            pd.to_datetime(test_series, infer_datetime_format=False),
+            pd.to_datetime(test_series, infer_datetime_format=True)
+        ))
+
+    def test_to_datetime_infer_datetime_format_series_with_nans(self):
+        test_series = pd.Series(
+            np.array([
+                '01/01/2011 00:00:00',
+                np.nan,
+                '01/03/2011 00:00:00',
+                np.nan,
+        ]))
+
+        self.assert_(np.array_equal(
+            pd.to_datetime(test_series, infer_datetime_format=False),
+            pd.to_datetime(test_series, infer_datetime_format=True)
+        ))
+
+    def test_to_datetime_infer_datetime_format_series_starting_with_nans(self):
+        test_series = pd.Series(
+            np.array([
+                np.nan,
+                np.nan,
+                '01/01/2011 00:00:00',
+                '01/02/2011 00:00:00',
+                '01/03/2011 00:00:00',
+        ]))
+
+        self.assert_(np.array_equal(
+            pd.to_datetime(test_series, infer_datetime_format=False),
+            pd.to_datetime(test_series, infer_datetime_format=True)
+        ))
+
+
+class TestGuessDatetimeFormat(tm.TestCase):
+    def test_guess_datetime_format_with_parseable_formats(self):
+        dt_string_to_format = (
+            ('20111230', '%Y%m%d'),
+            ('2011-12-30', '%Y-%m-%d'),
+            ('30-12-2011', '%d-%m-%Y'),
+            ('2011-12-30 00:00:00', '%Y-%m-%d %H:%M:%S'),
+            ('2011-12-30T00:00:00', '%Y-%m-%dT%H:%M:%S'),
+            ('2011-12-30 00:00:00.000000', '%Y-%m-%d %H:%M:%S.%f'),
+        )
+
+        for dt_string, dt_format in dt_string_to_format:
+            self.assertEquals(
+                tools._guess_datetime_format(dt_string),
+                dt_format
+            )
+
+    def test_guess_datetime_format_with_dayfirst(self):
+        ambiguous_string = '01/01/2011'
+        self.assertEquals(
+            tools._guess_datetime_format(ambiguous_string, dayfirst=True),
+            '%d/%m/%Y'
+        )
+        self.assertEquals(
+            tools._guess_datetime_format(ambiguous_string, dayfirst=False),
+            '%m/%d/%Y'
+        )
+
+    def test_guess_datetime_format_with_locale_specific_formats(self):
+        # The month names will vary depending on the locale, in which
+        # case these wont be parsed properly (dateutil can't parse them)
+        _skip_if_has_locale()
+
+        dt_string_to_format = (
+            ('30/Dec/2011', '%d/%b/%Y'),
+            ('30/December/2011', '%d/%B/%Y'),
+            ('30/Dec/2011 00:00:00', '%d/%b/%Y %H:%M:%S'),
+        )
+
+        for dt_string, dt_format in dt_string_to_format:
+            self.assertEquals(
+                tools._guess_datetime_format(dt_string),
+                dt_format
+            )
+
+    def test_guess_datetime_format_invalid_inputs(self):
+        # A datetime string must include a year, month and a day for it
+        # to be guessable, in addition to being a string that looks like
+        # a datetime
+        invalid_dts = [
+            '2013',
+            '01/2013',
+            '12:00:00',
+            '1/1/1/1',
+            'this_is_not_a_datetime',
+            '51a',
+            9,
+            datetime(2011, 1, 1),
+        ]
+
+        for invalid_dt in invalid_dts:
+            self.assertTrue(tools._guess_datetime_format(invalid_dt) is None)
+
+    def test_guess_datetime_format_for_array(self):
+        expected_format = '%Y-%m-%d %H:%M:%S.%f'
+        dt_string = datetime(2011, 12, 30, 0, 0, 0).strftime(expected_format)
+
+        test_arrays = [
+            np.array([dt_string, dt_string, dt_string], dtype='O'),
+            np.array([np.nan, np.nan, dt_string], dtype='O'),
+            np.array([dt_string, 'random_string'], dtype='O'),
+        ]
+
+        for test_array in test_arrays:
+            self.assertEqual(
+                tools._guess_datetime_format_for_array(test_array),
+                expected_format
+            )
+
+        format_for_string_of_nans = tools._guess_datetime_format_for_array(
+            np.array([np.nan, np.nan, np.nan], dtype='O')
+        )
+        self.assertTrue(format_for_string_of_nans is None)
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 2d4f27cb1..6761b5cbb 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -24,6 +24,21 @@ except ImportError:  # pragma: no cover
     print('Please install python-dateutil via easy_install or some method!')
     raise  # otherwise a 2nd import won't show the message
 
+_DATEUTIL_LEXER_SPLIT = None
+try:
+    # Since these are private methods from dateutil, it is safely imported
+    # here so in case this interface changes, pandas will just fallback
+    # to not using the functionality
+    from dateutil.parser import _timelex
+
+    if hasattr(_timelex, 'split'):
+        def _lexer_split_from_str(dt_str):
+            # The StringIO(str(_)) is for dateutil 2.2 compatibility
+            return _timelex.split(StringIO(str(dt_str)))
+
+        _DATEUTIL_LEXER_SPLIT = _lexer_split_from_str
+except (ImportError, AttributeError):
+    pass
 
 def _infer_tzinfo(start, end):
     def _infer(a, b):
@@ -50,9 +65,126 @@ def _maybe_get_tz(tz):
         tz = pytz.FixedOffset(tz / 60)
     return tz
 
+def _guess_datetime_format(dt_str, dayfirst=False,
+                           dt_str_parse=compat.parse_date,
+                           dt_str_split=_DATEUTIL_LEXER_SPLIT):
+    """
+    Guess the datetime format of a given datetime string.
+
+    Parameters
+    ----------
+    dt_str : string, datetime string to guess the format of
+    dayfirst : boolean, default False
+        If True parses dates with the day first, eg 20/01/2005
+        Warning: dayfirst=True is not strict, but will prefer to parse
+        with day first (this is a known bug).
+    dt_str_parse : function, defaults to `compate.parse_date` (dateutil)
+        This function should take in a datetime string and return
+        a `datetime.datetime` guess that the datetime string represents
+    dt_str_split : function, defaults to `_DATEUTIL_LEXER_SPLIT` (dateutil)
+        This function should take in a datetime string and return
+        a list of strings, the guess of the various specific parts
+        e.g. '2011/12/30' -> ['2011', '/', '12', '/', '30']
+
+    Returns
+    -------
+    ret : datetime formatt string (for `strftime` or `strptime`)
+    """
+    if dt_str_parse is None or dt_str_split is None:
+        return None
+
+    if not isinstance(dt_str, compat.string_types):
+        return None
+
+    day_attribute_and_format = (('day',), '%d')
+
+    datetime_attrs_to_format = [
+        (('year', 'month', 'day'), '%Y%m%d'),
+        (('year',), '%Y'),
+        (('month',), '%B'),
+        (('month',), '%b'),
+        (('month',), '%m'),
+        day_attribute_and_format,
+        (('hour',), '%H'),
+        (('minute',), '%M'),
+        (('second',), '%S'),
+        (('microsecond',), '%f'),
+        (('second', 'microsecond'), '%S.%f'),
+    ]
+
+    if dayfirst:
+        datetime_attrs_to_format.remove(day_attribute_and_format)
+        datetime_attrs_to_format.insert(0, day_attribute_and_format)
+
+    try:
+        parsed_datetime = dt_str_parse(dt_str, dayfirst=dayfirst)
+    except:
+        # In case the datetime can't be parsed, its format cannot be guessed
+        return None
+
+    if parsed_datetime is None:
+        return None
+
+    try:
+        tokens = dt_str_split(dt_str)
+    except:
+        # In case the datetime string can't be split, its format cannot
+        # be guessed
+        return None
+
+    format_guess = [None] * len(tokens)
+    found_attrs = set()
+
+    for attrs, attr_format in datetime_attrs_to_format:
+        # If a given attribute has been placed in the format string, skip
+        # over other formats for that same underlying attribute (IE, month
+        # can be represented in multiple different ways)
+        if set(attrs) & found_attrs:
+            continue
+
+        if all(getattr(parsed_datetime, attr) is not None for attr in attrs):
+            for i, token_format in enumerate(format_guess):
+                if (token_format is None and
+                        tokens[i] == parsed_datetime.strftime(attr_format)):
+                    format_guess[i] = attr_format
+                    found_attrs.update(attrs)
+                    break
+
+    # Only consider it a valid guess if we have a year, month and day
+    if len(set(['year', 'month', 'day']) & found_attrs) != 3:
+        return None
+
+    output_format = []
+    for i, guess in enumerate(format_guess):
+        if guess is not None:
+            # Either fill in the format placeholder (like %Y)
+            output_format.append(guess)
+        else:
+            # Or just the token separate (IE, the dashes in "01-01-2013")
+            try:
+                # If the token is numeric, then we likely didn't parse it
+                # properly, so our guess is wrong
+                float(tokens[i])
+                return None
+            except ValueError:
+                pass
+
+            output_format.append(tokens[i])
+
+    guessed_format = ''.join(output_format)
+
+    if parsed_datetime.strftime(guessed_format) == dt_str:
+        return guessed_format
+
+def _guess_datetime_format_for_array(arr, **kwargs):
+    # Try to guess the format based on the first non-NaN element
+    non_nan_elements = com.notnull(arr).nonzero()[0]
+    if len(non_nan_elements):
+        return _guess_datetime_format(arr[non_nan_elements[0]], **kwargs)
 
 def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
-                format=None, coerce=False, unit='ns'):
+                format=None, coerce=False, unit='ns',
+                infer_datetime_format=False):
     """
     Convert argument to datetime
 
@@ -75,6 +207,9 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
     coerce : force errors to NaT (False by default)
     unit : unit of the arg (D,s,ms,us,ns) denote the unit in epoch
         (e.g. a unix timestamp), which is an integer/float number
+    infer_datetime_format: boolean, default False
+        If no `format` is given, try to infer the format based on the first
+        datetime string. Provides a large speed-up in many cases.
 
     Returns
     -------
@@ -98,7 +233,7 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
     from pandas.core.series import Series
     from pandas.tseries.index import DatetimeIndex
 
-    def _convert_listlike(arg, box):
+    def _convert_listlike(arg, box, format):
 
         if isinstance(arg, (list,tuple)):
             arg = np.array(arg, dtype='O')
@@ -113,10 +248,26 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
             return arg
 
         arg = com._ensure_object(arg)
-        try:
+
+        if infer_datetime_format and format is None:
+            format = _guess_datetime_format_for_array(arg, dayfirst=dayfirst)
+
             if format is not None:
-                result = None
+                # There is a special fast-path for iso8601 formatted
+                # datetime strings, so in those cases don't use the inferred
+                # format because this path makes process slower in this
+                # special case
+                format_is_iso8601 = (
+                    '%Y-%m-%dT%H:%M:%S.%f'.startswith(format) or
+                    '%Y-%m-%d %H:%M:%S.%f'.startswith(format)
+                )
+                if format_is_iso8601:
+                    format = None
 
+        try:
+            result = None
+
+            if format is not None:
                 # shortcut formatting here
                 if format == '%Y%m%d':
                     try:
@@ -127,15 +278,24 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
                 # fallback
                 if result is None:
                     try:
-                        result = tslib.array_strptime(arg, format, coerce=coerce)
+                        result = tslib.array_strptime(
+                            arg, format, coerce=coerce
+                        )
                     except (tslib.OutOfBoundsDatetime):
                         if errors == 'raise':
                             raise
                         result = arg
-            else:
+                    except ValueError:
+                        # Only raise this error if the user provided the
+                        # datetime format, and not when it was inferred
+                        if not infer_datetime_format:
+                            raise
+
+            if result is None and (format is None or infer_datetime_format):
                 result = tslib.array_to_datetime(arg, raise_=errors == 'raise',
                                                  utc=utc, dayfirst=dayfirst,
                                                  coerce=coerce, unit=unit)
+
             if com.is_datetime64_dtype(result) and box:
                 result = DatetimeIndex(result, tz='utc' if utc else None)
             return result
@@ -152,12 +312,12 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
     elif isinstance(arg, Timestamp):
         return arg
     elif isinstance(arg, Series):
-        values = _convert_listlike(arg.values, box=False)
+        values = _convert_listlike(arg.values, False, format)
         return Series(values, index=arg.index, name=arg.name)
     elif com.is_list_like(arg):
-        return _convert_listlike(arg, box=box)
+        return _convert_listlike(arg, box, format)
 
-    return _convert_listlike(np.array([ arg ]), box=box)[0]
+    return _convert_listlike(np.array([ arg ]), box, format)[0]
 
 class DateParseError(ValueError):
     pass

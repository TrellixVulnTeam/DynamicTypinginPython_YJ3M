commit 04edff418074bfd168a0e34c2907cef261ad6eb5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Dec 25 21:19:59 2011 -0500

    REF: starting to refactor for removing LongPanel, GH #108

diff --git a/RELEASE.rst b/RELEASE.rst
index 2d0f60ee9..a66b1f047 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -98,10 +98,10 @@ Thanks
 ------
 - Craig Austin
 - Andreas Hilboll
-- Adam Klein
 - Matt Harrison
 - Mario Gamboa-Cavazos
 - Arthur Gerigk
+- Adam Klein
 - Gregg Lind
 - Solomon Negusse
 - Wouter Overmeire
diff --git a/pandas/core/api.py b/pandas/core/api.py
index 5c2423ab9..1201bde94 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -10,7 +10,7 @@ from pandas.core.index import Index, Int64Index, Factor, MultiIndex
 from pandas.core.daterange import DateRange
 from pandas.core.series import Series, TimeSeries
 from pandas.core.frame import DataFrame
-from pandas.core.panel import Panel, LongPanel
+from pandas.core.panel import Panel
 from pandas.core.groupby import groupby
 from pandas.core.reshape import pivot_simple as pivot
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 7b27ae5ae..3b57caf22 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2484,31 +2484,12 @@ class DataFrame(NDFrame):
 
         return result
 
-    def _apply_level(self, f, axis='major', broadcast=False):
-        from pandas.core.panel import LongPanel
-
-        if axis == 'major':
-            panel = self.swapaxes()
-            result = panel._apply_level(f, axis='minor', broadcast=broadcast)
-            if broadcast:
-                result = result.swapaxes()
-
-            return result
-
-        bounds = self.index._bounds
-        values = self.values
-        N, _ = values.shape
-        result = group_agg(values, bounds, f)
-
+    def _apply_level(self, f, level=0, broadcast=False):
+        grouped = self.groupby(level=level)
         if broadcast:
-            repeater = np.concatenate((np.diff(bounds), [N - bounds[-1]]))
-            panel = LongPanel(result.repeat(repeater, axis=0),
-                              columns=self.items, index=self.index)
+            return grouped.transform(f)
         else:
-            panel = DataFrame(result, index=self.major_axis,
-                              columns=self.items)
-
-        return panel
+            return grouped.agg(f)
 
     def applymap(self, func):
         """
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 8d67c2583..64fd952df 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -13,8 +13,8 @@ from pandas.core.indexing import _NDFrameIndexer
 from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.frame import DataFrame, _union_indexes
 from pandas.core.generic import NDFrame
-from pandas.core.series import Series
 from pandas.util import py3compat
+from pandas.util.decorators import deprecate
 import pandas.core.common as com
 import pandas._tseries as lib
 
@@ -106,7 +106,7 @@ def _panel_arith_method(op, name):
 
         Returns
         -------
-        LongPanel
+        Panel
         """
         return self._combine(other, op, axis=axis)
 
@@ -514,14 +514,6 @@ class Panel(NDFrame):
 
     def __setitem__(self, key, value):
         _, N, K = self.shape
-
-        # XXX
-        if isinstance(value, LongPanel):
-            if len(value.items) != 1:
-                raise ValueError('Input panel must have only one item!')
-
-            value = value.to_wide()[value.items[0]]
-
         if isinstance(value, DataFrame):
             value = value.reindex(index=self.major_axis,
                                   columns=self.minor_axis)
@@ -659,13 +651,12 @@ class Panel(NDFrame):
                             minor=other.minor_axis, method=method)
 
     def _combine(self, other, func, axis=0):
-        if isinstance(other, (Panel, LongPanel)):
+        if isinstance(other, Panel):
             return self._combine_panel(other, func)
         elif isinstance(other, DataFrame):
             return self._combine_frame(other, func, axis=axis)
         elif np.isscalar(other):
             new_values = func(self.values, other)
-
             return Panel(new_values, self.items, self.major_axis,
                              self.minor_axis)
 
@@ -691,15 +682,11 @@ class Panel(NDFrame):
                      self.minor_axis)
 
     def _combine_panel(self, other, func):
-        if isinstance(other, LongPanel):
-            other = other.to_wide()
-
         items = self.items + other.items
         major = self.major_axis + other.major_axis
         minor = self.minor_axis + other.minor_axis
 
         # could check that everything's the same size, but forget it
-
         this = self.reindex(items=items, major=major, minor=minor)
         other = other.reindex(items=items, major=major, minor=minor)
 
@@ -865,7 +852,7 @@ class Panel(NDFrame):
 
         Returns
         -------
-        y : LongPanel
+        y : DataFrame
         """
         I, N, K = self.shape
 
@@ -889,11 +876,12 @@ class Panel(NDFrame):
         minor_labels = minor_labels.ravel()[selector]
 
         index = MultiIndex(levels=[self.major_axis, self.minor_axis],
-                           labels=[major_labels, minor_labels])
+                           labels=[major_labels, minor_labels],
+                           names=['major', 'minor'])
 
-        return LongPanel(data, index=index, columns=self.items)
+        return DataFrame(data, index=index, columns=self.items)
 
-    toLong = to_long
+    toLong = deprecate('toLong', to_long)
 
     def filter(self, items):
         """
@@ -1175,368 +1163,222 @@ WidePanel = Panel
 # LongPanel and friends
 
 
-class LongPanel(DataFrame):
-    """
-    Represents long or "stacked" format panel data
-
-    Parameters
-    ----------
-    values : ndarray (N x K)
-    items : sequence
-    index : MultiIndex
-
-    Note
-    ----
-    LongPanel will likely disappear in a future release in favor of just using
-    DataFrame objects with hierarchical indexes. You should be careful about
-    writing production code depending on LongPanel
-    """
-
-    @property
-    def consistent(self):
-        offset = max(len(self.major_axis), len(self.minor_axis))
-
-        major_labels = self.major_labels
-        minor_labels = self.minor_labels
-
-        # overflow risk
-        if (offset + 1) ** 2 > 2**32:  # pragma: no cover
-            major_labels = major_labels.astype(np.int64)
-            minor_labels = minor_labels.astype(np.int64)
-
-        keys = major_labels * offset + minor_labels
-        unique_keys = np.unique(keys)
+def panel_is_consistent(panel):
+    offset = max(len(panel.major_axis), len(panel.minor_axis))
 
-        if len(unique_keys) < len(keys):
-            return False
+    major_labels = panel.major_labels
+    minor_labels = panel.minor_labels
 
-        return True
+    # overflow risk
+    if (offset + 1) ** 2 > 2**32:  # pragma: no cover
+        major_labels = major_labels.astype(np.int64)
+        minor_labels = minor_labels.astype(np.int64)
 
-    @property
-    def wide_shape(self):
-        return (len(self.items), len(self.major_axis), len(self.minor_axis))
+    keys = major_labels * offset + minor_labels
+    unique_keys = np.unique(keys)
 
-    @property
-    def items(self):
-        return self.columns
+    if len(unique_keys) < len(keys):
+        return False
 
-    @property
-    def _constructor(self):
-        return LongPanel
+    return True
 
-    def __len__(self):
-        return len(self.index)
-
-    def __repr__(self):
-        return DataFrame.__repr__(self)
-
-    @classmethod
-    def fromRecords(cls, data, major_field, minor_field,
-                    exclude=None):
-        """
-        Create LongPanel from DataFrame or record / structured ndarray
-        object
-
-        Parameters
-        ----------
-        data : DataFrame, structured or record array, or dict
-        major_field : string
-        minor_field : string
-            Name of field
-        exclude : list-like, default None
-
-        Returns
-        -------
-        LongPanel
-        """
-        return cls.from_records(data, [major_field, minor_field],
-                                exclude=exclude)
-
-    def toRecords(self):
-        major = np.asarray(self.major_axis).take(self.major_labels)
-        minor = np.asarray(self.minor_axis).take(self.minor_labels)
-
-        arrays = [major, minor] + list(self.values[:, i]
-                                       for i in range(len(self.items)))
-
-        names = ['major', 'minor'] + list(self.items)
-
-        return np.rec.fromarrays(arrays, names=names)
-
-    @property
-    def major_axis(self):
-        return self.index.levels[0]
-
-    @property
-    def minor_axis(self):
-        return self.index.levels[1]
-
-    @property
-    def major_labels(self):
-        return self.index.labels[0]
-
-    @property
-    def minor_labels(self):
-        return self.index.labels[1]
-
-    def _combine(self, other, func, axis='items'):
-        if isinstance(other, LongPanel):
-            return self._combine_frame(other, func)
-        elif isinstance(other, DataFrame):
-            return self._combine_panel_frame(other, func, axis=axis)
-        elif isinstance(other, Series):
-            return self._combine_series(other, func, axis=axis)
-        elif np.isscalar(other):
-            return LongPanel(func(self.values, other), columns=self.items,
-                             index=self.index)
-        else:  # pragma: no cover
-            raise Exception('type %s not supported' % type(other))
-
-    def _combine_panel_frame(self, other, func, axis='items'):
-        """
-        Arithmetic op
-
-        Parameters
-        ----------
-        other : DataFrame
-        func : function
-        axis : int / string
-
-        Returns
-        -------
-        y : LongPanel
-        """
-        wide = self.to_wide()
-        result = wide._combine_frame(other, func, axis=axis)
-        return result.to_long()
-
-    add = _panel_arith_method(operator.add, 'add')
-    subtract = sub = _panel_arith_method(operator.sub, 'subtract')
-    multiply = mul = _panel_arith_method(operator.mul, 'multiply')
-
-    try:
-        divide = div = _panel_arith_method(operator.div, 'divide')
-    except AttributeError:  # pragma: no cover
-        # Python 3
-        divide = div = _panel_arith_method(operator.truediv, 'divide')
-
-    def to_wide(self):
-        """
-        Transform long (stacked) format into wide format
-
-        Returns
-        -------
-        Panel
-        """
-        assert(self.consistent)
-        mask = make_mask(self.index)
-        if self._data.is_mixed_dtype():
-            return self._to_wide_mixed(mask)
-        else:
-            return self._to_wide_homogeneous(mask)
-
-    def _to_wide_homogeneous(self, mask):
-        values = np.empty(self.wide_shape, dtype=self.values.dtype)
+def long_to_wide(lp):
+    """
+    Transform long (stacked) format into wide format
 
-        if not issubclass(self.values.dtype.type, np.integer):
-            values.fill(np.nan)
+    Returns
+    -------
+    Panel
+    """
+    assert(lp.consistent)
+    mask = make_mask(lp.index)
+    if lp._data.is_mixed_dtype():
+        return _to_wide_mixed(lp, mask)
+    else:
+        return _to_wide_homogeneous(lp, mask)
 
-        for i in xrange(len(self.items)):
-            values[i].flat[mask] = self.values[:, i]
+def _to_wide_homogeneous(lp, mask):
+    shape = _wide_shape(lp)
+    values = np.empty(shape, dtype=lp.values.dtype)
 
-        return Panel(values, self.items, self.major_axis, self.minor_axis)
+    if not issubclass(lp.values.dtype.type, np.integer):
+        values.fill(np.nan)
 
-    def _to_wide_mixed(self, mask):
-        _, N, K = self.wide_shape
+    for i in xrange(len(lp.items)):
+        values[i].flat[mask] = lp.values[:, i]
 
-        # TODO: make much more efficient
+    return Panel(values, lp.items, lp.major_axis, lp.minor_axis)
 
-        data = {}
-        for i, item in enumerate(self.items):
-            item_vals = self[item].values
-
-            values = np.empty((N, K), dtype=item_vals.dtype)
-            values.ravel()[mask] = item_vals
-            data[item] = DataFrame(values, index=self.major_axis,
-                                   columns=self.minor_axis)
-        return Panel.from_dict(data)
-
-    def toCSV(self, path):
-        def format_cols(items):
-            cols = ['Major', 'Minor'] + list(items)
-            return '"%s"' % '","'.join(cols)
-
-        def format_row(major, minor, values):
-            vals = ','.join('%.12f' % val for val in values)
-            return '%s,%s,%s' % (major, minor, vals)
-
-        f = open(path, 'w')
-        self._textConvert(f, format_cols, format_row)
-        f.close()
-
-    def _textConvert(self, buf, format_cols, format_row):
-        print >> buf, format_cols(self.items)
-
-        label_pairs = zip(self.major_axis.take(self.major_labels),
-                          self.minor_axis.take(self.minor_labels))
-        for i, (major, minor) in enumerate(label_pairs):
-            row = format_row(major, minor, self.values[i])
-            print >> buf, row
-
-    def swapaxes(self):
-        """
-        Swap major and minor axes and reorder values to be grouped by
-        minor axis values
+def _to_wide_mixed(lp, mask):
+    _, N, K = _wide_shape(lp)
 
-        Returns
-        -------
-        LongPanel (new object)
-        """
-        # Order everything by minor labels. Have to use mergesort
-        # because NumPy quicksort is not stable. Here of course I'm
-        # using the property that the major labels are ordered.
-        indexer = self.minor_labels.argsort(kind='mergesort')
+    # TODO: make much more efficient
 
-        new_major = self.minor_labels.take(indexer)
-        new_minor = self.major_labels.take(indexer)
-        new_values = self.values.take(indexer, axis=0)
+    data = {}
+    for i, item in enumerate(lp.items):
+        item_vals = lp[item].values
 
-        new_index = MultiIndex(levels=[self.minor_axis, self.major_axis],
-                               labels=[new_major, new_minor])
+        values = np.empty((N, K), dtype=item_vals.dtype)
+        values.ravel()[mask] = item_vals
+        data[item] = DataFrame(values, index=lp.major_axis,
+                               columns=lp.minor_axis)
+    return Panel.from_dict(data)
 
-        return LongPanel(new_values, columns=self.items,
-                         index=new_index)
+def _wide_shape(lp):
+    return (len(lp.columns), len(lp.index.levels[0]), len(lp.index.levels[1]))
 
-    def truncate(self, before=None, after=None):
-        """
-        Slice panel between two major axis values, return complete LongPanel
+def panel_from_records(data, major_field, minor_field, exclude=None):
+    """
+    Create LongPanel from DataFrame or record / structured ndarray
+    object
 
-        Parameters
-        ----------
-        before : type of major_axis values or None, default None
-            None defaults to start of panel
+    Parameters
+    ----------
+    data : DataFrame, structured or record array, or dict
+    major_field : string
+    minor_field : string
+        Name of field
+    exclude : list-like, default None
 
-        after : type of major_axis values or None, default None
-            None defaults to end of panel
+    Returns
+    -------
+    LongPanel
+    """
+    return DataFrame.from_records(data, [major_field, minor_field],
+                                  exclude=exclude)
 
-        Returns
-        -------
-        LongPanel
-        """
-        left, right = self.index.slice_locs(before, after)
-        new_index = self.index.truncate(before, after)
 
-        return LongPanel(self.values[left : right],
-                         columns=self.items, index=new_index)
+def long_swapaxes(frame):
+    """
+    Swap major and minor axes and reorder values to be grouped by
+    minor axis values
 
-    def get_axis_dummies(self, axis='minor', transform=None,
-                         prefix=None):
-        """
-        Construct 1-0 dummy variables corresponding to designated axis
-        labels
+    Returns
+    -------
+    LongPanel (new object)
+    """
+    return frame.swaplevel(0, 1, axis=0)
 
-        Parameters
-        ----------
-        axis : {'major', 'minor'}, default 'minor'
-        transform : function, default None
 
-            Function to apply to axis labels first. For example, to
-            get "day of week" dummies in a time series regression you might
-            call:
+def long_truncate(lp, before=None, after=None):
+    """
+    Slice panel between two major axis values, return complete LongPanel
 
-                panel.get_axis_dummies(axis='major',
-                                       transform=lambda d: d.weekday())
-        Returns
-        -------
-        LongPanel, item names taken from chosen axis
-        """
-        if axis == 'minor':
-            dim = len(self.minor_axis)
-            items = self.minor_axis
-            labels = self.minor_labels
-        elif axis == 'major':
-            dim = len(self.major_axis)
-            items = self.major_axis
-            labels = self.major_labels
-        else: # pragma: no cover
-            raise ValueError('Do not recognize axis %s' % axis)
+    Parameters
+    ----------
+    before : type of major_axis values or None, default None
+        None defaults to start of panel
+    after : type of major_axis values or None, default None
+        None defaults to end of panel
 
-        if transform:
-            mapped = np.array([transform(val) for val in items])
+    Returns
+    -------
+    LongPanel
+    """
+    left, right = lp.index.slice_locs(before, after)
+    new_index = lp.index.truncate(before, after)
 
-            items = np.array(sorted(set(mapped)))
-            labels = Index(items).get_indexer(mapped[labels])
-            dim = len(items)
+    return DataFrame(lp.values[left:right], columns=lp.columns,
+                     index=new_index)
 
-        values = np.eye(dim, dtype=float)
-        values = values.take(labels, axis=0)
 
-        result = LongPanel(values, columns=items, index=self.index)
+def long_apply(lp, f, axis='major', broadcast=False):
+    """
+    Aggregate over a particular axis
 
-        if prefix is None:
-            prefix = ''
+    Parameters
+    ----------
+    f : function
+        NumPy function to apply to each group
+    axis : {'major', 'minor'}
 
-        result = result.add_prefix(prefix)
+    broadcast : boolean
 
-        return result
+    Returns
+    -------
+    broadcast=True  -> LongPanel
+    broadcast=False -> DataFrame
+    """
+    try:
+        return lp._apply_level(f, axis=axis, broadcast=broadcast)
+    except Exception:
+        # ufunc
+        new_values = f(lp.values)
+        return DataFrame(new_values, columns=lp.items, index=lp.index)
 
-    def get_dummies(self, item):
-        """
-        Use unique values in column of panel to construct LongPanel
-        containing dummy
 
-        Parameters
-        ----------
-        item : object
-            Value in panel items Index
+def make_dummies(frame, item):
+    """
+    Use unique values in column of panel to construct LongPanel
+    containing dummy
 
-        Returns
-        -------
-        LongPanel
-        """
-        idx = self.items.indexMap[item]
-        values = self.values[:, idx]
+    Parameters
+    ----------
+    item : object
+        Value in panel items Index
 
-        distinct_values = np.array(sorted(set(values)))
-        mapping = distinct_values.searchsorted(values)
+    Returns
+    -------
+    LongPanel
+    """
+    from pandas import Factor
+    factor = Factor(frame[item].values)
+    values = np.eye(len(factor.levels))
+    dummy_mat = values.take(factor.labels, axis=0)
+    return DataFrame(dummy_mat, columns=factor.levels, index=frame.index)
 
-        values = np.eye(len(distinct_values))
+def make_axis_dummies(frame, axis='minor'):
+    """
+    Construct 1-0 dummy variables corresponding to designated axis
+    labels
 
-        dummy_mat = values.take(mapping, axis=0)
+    Parameters
+    ----------
+    axis : {'major', 'minor'}, default 'minor'
+    transform : function, default None
+        Function to apply to axis labels first. For example, to
+        get "day of week" dummies in a time series regression you might
+        call:
+            panel.get_axis_dummies(axis='major',
+                                   transform=lambda d: d.weekday())
+    Returns
+    -------
+    LongPanel, item names taken from chosen axis
+    """
+    numbers = {
+        'major' : 0,
+        'minor' : 1
+    }
+    num = numbers.get(axis, axis)
+    items = frame.index.levels[num]
+    labels = frame.index.labels[num]
+    values = np.eye(len(items), dtype=float)
+    values = values.take(labels, axis=0)
 
-        return LongPanel(dummy_mat, columns=distinct_values,
-                         index=self.index)
+    return DataFrame(values, columns=items, index=frame.index)
 
-    def mean(self, axis='major', broadcast=False):
-        return self.apply(lambda x: np.mean(x, axis=0), axis, broadcast)
 
-    def sum(self, axis='major', broadcast=False):
-        return self.apply(lambda x: np.sum(x, axis=0), axis, broadcast)
+class LongPanel(DataFrame):
+    """
+    Represents long or "stacked" format panel data
 
-    def apply(self, f, axis='major', broadcast=False):
-        """
-        Aggregate over a particular axis
+    Parameters
+    ----------
+    values : ndarray (N x K)
+    items : sequence
+    index : MultiIndex
 
-        Parameters
-        ----------
-        f : function
-            NumPy function to apply to each group
-        axis : {'major', 'minor'}
+    Note
+    ----
+    LongPanel will likely disappear in a future release in favor of just using
+    DataFrame objects with hierarchical indexes. You should be careful about
+    writing production code depending on LongPanel
+    """
 
-        broadcast : boolean
+    @property
+    def items(self):
+        return self.columns
 
-        Returns
-        -------
-        broadcast=True  -> LongPanel
-        broadcast=False -> DataFrame
-        """
-        try:
-            return self._apply_level(f, axis=axis, broadcast=broadcast)
-        except Exception:
-            # ufunc
-            new_values = f(self.values)
-            return LongPanel(new_values, columns=self.items,
-                             index=self.index)
 
 def _prep_ndarray(values, copy=True):
     if not isinstance(values, np.ndarray):
diff --git a/pandas/stats/interface.py b/pandas/stats/interface.py
index c0fed442e..e6c1e3824 100644
--- a/pandas/stats/interface.py
+++ b/pandas/stats/interface.py
@@ -1,6 +1,4 @@
-from pandas.core.api import (Series, DataFrame, Panel, LongPanel,
-                             MultiIndex)
-
+from pandas.core.api import Series, DataFrame, Panel, MultiIndex
 from pandas.stats.ols import OLS, MovingOLS
 from pandas.stats.plm import PanelOLS, MovingPanelOLS, NonPooledPanelOLS
 import pandas.stats.common as common
@@ -110,7 +108,7 @@ def ols(**kwargs):
     if isinstance(y, DataFrame) or (isinstance(y, Series) and
                                     isinstance(y.index, MultiIndex)):
         panel = True
-    if isinstance(x, (Panel, LongPanel)):
+    if isinstance(x, Panel):
         panel = True
 
     if window_type == 'full_sample':
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 2c8932b91..d68d0b420 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -983,62 +983,6 @@ class TestLongPanel(unittest.TestCase):
         assert_almost_equal(unpickled['ItemA'].values,
                             self.panel['ItemA'].values)
 
-    def test_len(self):
-        len(self.unfiltered_panel)
-
-    def test_constructor(self):
-        pass
-
-    def test_fromRecords_toRecords(self):
-        # structured array
-        K = 10
-
-        recs = np.zeros(K, dtype='O,O,f8,f8')
-        recs['f0'] = range(K // 2) * 2
-        recs['f1'] = np.arange(K) / (K // 2)
-        recs['f2'] = np.arange(K) * 2
-        recs['f3'] = np.arange(K)
-
-        lp = LongPanel.fromRecords(recs, 'f0', 'f1')
-        self.assertEqual(len(lp.items), 2)
-
-        lp = LongPanel.fromRecords(recs, 'f0', 'f1', exclude=['f2'])
-        self.assertEqual(len(lp.items), 1)
-
-        torecs = lp.toRecords()
-        self.assertEqual(len(torecs.dtype.names), len(lp.items) + 2)
-
-        # DataFrame
-        df = DataFrame.from_records(recs)
-        lp = LongPanel.fromRecords(df, 'f0', 'f1', exclude=['f2'])
-        self.assertEqual(len(lp.items), 1)
-
-        # dict of arrays
-        series = DataFrame.from_records(recs)._series
-        lp = LongPanel.fromRecords(series, 'f0', 'f1', exclude=['f2'])
-        self.assertEqual(len(lp.items), 1)
-        self.assert_('f2' in series)
-
-        self.assertRaises(Exception, LongPanel.fromRecords, np.zeros((3, 3)),
-                          0, 1)
-
-    def test_factors(self):
-        # structured array
-        K = 10
-
-        recs = np.zeros(K, dtype='O,O,f8,f8,O,O')
-        recs['f0'] = ['one'] * 5 + ['two'] * 5
-        recs['f1'] = ['A', 'B', 'C', 'D', 'E'] * 2
-        recs['f2'] = np.arange(K) * 2
-        recs['f3'] = np.arange(K)
-        recs['f4'] = ['A', 'B', 'C', 'D', 'E'] * 2
-        recs['f5'] = ['foo', 'bar'] * 5
-
-        lp = LongPanel.fromRecords(recs, 'f0', 'f1')
-
-    def test_columns(self):
-        self.assert_(np.array_equal(self.panel.items, self.panel.columns))
-
     def test_copy(self):
         thecopy = self.panel.copy()
         self.assert_(np.array_equal(thecopy.values, self.panel.values))
@@ -1126,23 +1070,12 @@ class TestLongPanel(unittest.TestCase):
         sorted_major = sorted_minor.sortlevel(level=0)
         self.assert_(is_sorted(sorted_major.major_labels))
 
-    def test_toCSV(self):
-        self.panel.toCSV('__tmp__')
-        os.remove('__tmp__')
-
     def test_to_string(self):
         from cStringIO import StringIO
 
         buf = StringIO()
         self.panel.to_string(buf)
 
-    def test_swapaxes(self):
-        swapped = self.panel.swapaxes()
-
-        self.assert_(swapped.major_axis is self.panel.minor_axis)
-
-        # what else to test here?
-
     def test_truncate(self):
         dates = self.panel.major_axis
         start, end = dates[1], dates[5]
@@ -1179,10 +1112,6 @@ class TestLongPanel(unittest.TestCase):
         self.assertRaises(Exception, lp2.truncate, wp.major_axis[-2],
                           wp.major_axis[2])
 
-
-    def test_filter(self):
-        pass
-
     def test_axis_dummies(self):
         minor_dummies = self.panel.get_axis_dummies('minor')
         self.assertEqual(len(minor_dummies.items),

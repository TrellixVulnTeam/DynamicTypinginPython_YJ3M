commit 2c2e8e604b423863e511a4e24c99c805c5c94bde
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Sep 23 20:30:40 2011 -0400

    ENH: bug fixes, speed enh, benchmark suite to compare with xts

diff --git a/bench/bench_take_indexing.py b/bench/bench_take_indexing.py
new file mode 100644
index 000000000..fc8a3c6b7
--- /dev/null
+++ b/bench/bench_take_indexing.py
@@ -0,0 +1,52 @@
+import numpy as np
+
+from pandas import *
+import pandas._tseries as lib
+
+from pandas import DataFrame
+import timeit
+
+setup = """
+from pandas import Series
+import pandas._tseries as lib
+import random
+import numpy as np
+
+import random
+n = %d
+k = %d
+arr = np.random.randn(n, k)
+indexer = np.arange(n, dtype=np.int32)
+indexer = indexer[::-1]
+"""
+
+sizes = [100, 1000, 10000, 100000]
+iters = [1000, 1000, 100, 1]
+
+fancy_2d = []
+take_2d = []
+cython_2d = []
+
+n = 1000
+
+def _timeit(stmt, size, k=5, iters=1000):
+    timer =  timeit.Timer(stmt=stmt, setup=setup % (sz, k))
+    return timer.timeit(n) / n
+
+for sz, its in zip(sizes, iters):
+    print sz
+    fancy_2d.append(_timeit('arr[indexer]', sz, iters=its))
+    take_2d.append(_timeit('arr.take(indexer, axis=0)', sz, iters=its))
+    cython_2d.append(_timeit('lib.take_axis0(arr, indexer)', sz, iters=its))
+
+df = DataFrame({'fancy' : fancy_2d,
+                'take' : take_2d,
+                'cython' : cython_2d})
+
+print df
+
+from pandas.rpy.common import r
+r('mat <- matrix(rnorm(50000), nrow=10000, ncol=5)')
+r('set.seed(12345')
+r('indexer <- sample(1:10000)')
+r('mat[indexer,]')
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index 902bed97e..ab0fdba93 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -376,10 +376,10 @@ def ordered_left_join_int64(ndarray[int64_t] left, ndarray[int64_t] right):
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def ordered_left_join_put(ndarray[int64_t] left, ndarray[int64_t] right,
-                          ndarray[float64_t, ndim=2] lvalues,
-                          ndarray[float64_t, ndim=2] rvalues,
-                          ndarray[float64_t, ndim=2] out):
+def left_join_2d(ndarray[int64_t] left, ndarray[int64_t] right,
+                 ndarray[float64_t, ndim=2] lvalues,
+                 ndarray[float64_t, ndim=2] rvalues,
+                 ndarray[float64_t, ndim=2] out):
     cdef:
         Py_ssize_t i, j, k, nright, nleft, kright, kleft
         int64_t val
@@ -409,6 +409,37 @@ def ordered_left_join_put(ndarray[int64_t] left, ndarray[int64_t] right,
             for k from kleft <= k < kleft + kright:
                 out[i, k] = NaN
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def left_join_1d(ndarray[int64_t] left, ndarray[int64_t] right,
+                 ndarray[float64_t] lvalues,
+                 ndarray[float64_t] rvalues,
+                 ndarray[float64_t, ndim=2] out):
+    cdef:
+        Py_ssize_t i, j, nright, nleft
+        int64_t val
+
+    nleft = len(lvalues)
+    nright = len(rvalues)
+
+    j = 0
+    for i from 0 <= i < nleft:
+        out[i, 0] = lvalues[i]
+
+        val = left[i]
+
+        while j < nright and right[j] < val:
+            j += 1
+
+        if j == nright:
+            out[i, 1] = NaN
+            continue
+
+        if val == right[j]:
+            out[i, 1] = rvalues[j]
+        else:
+            out[i, 1] = NaN
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def inner_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
@@ -528,6 +559,83 @@ def outer_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
             lindexer[:count].copy(),
             rindexer[:count].copy())
 
+# @cython.wraparound(False)
+# @cython.boundscheck(False)
+def take_axis0(ndarray[float64_t, ndim=2] values,
+               ndarray[int32_t] indexer,
+               out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = NaN
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_axis1(ndarray[float64_t, ndim=2] values,
+               ndarray[int32_t] indexer,
+               out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = NaN
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_1d(ndarray[float64_t] values, ndarray[int32_t] indexer,
+            out=None):
+    cdef:
+        Py_ssize_t i, n, idx
+        ndarray[float64_t] outbuf
+
+    n = len(indexer)
+
+    if out is None:
+        outbuf = np.empty(n, dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = NaN
+        else:
+            outbuf[i] = values[idx]
+
 def ordered_put_indexer(ndarray[int64_t] left, ndarray[int64_t] right,
                         ndarray[float64_t, ndim=2] lvalues,
                         ndarray[float64_t, ndim=2] rvalues,
diff --git a/scripts/bench_join.R b/scripts/bench_join.R
new file mode 100644
index 000000000..5f72c16d3
--- /dev/null
+++ b/scripts/bench_join.R
@@ -0,0 +1,33 @@
+library(xts)
+
+iterations <- 100
+
+ns = c(100, 1000, 10000, 100000, 1000000)
+kinds = c("outer", "left", "inner")
+
+result = matrix(0, nrow=3, ncol=length(ns))
+n <- 100000
+pct.overlap <- 0.2
+
+k <- 5
+
+for (ni in 1:length(ns)){
+  n <- ns[ni]
+  rng1 <- 1:n
+  offset <- as.integer(n * pct.overlap)
+  rng2 <- rng1 + offset
+  x <- xts(matrix(rnorm(n * k), nrow=n, ncol=k),
+           as.POSIXct(Sys.Date()) + rng1)
+  y <- xts(matrix(rnorm(n * k), nrow=n, ncol=k),
+           as.POSIXct(Sys.Date()) + rng2)
+  for (i in 1:3) {
+      kind = kinds[i]
+      timing <- system.time(for (j in 1:iterations) merge(x, y, join=kind),
+                            gcFirst=F)
+      timing <- as.list(timing)
+      result[i, ni] = (timing$elapsed / iterations) * 1000
+    }
+}
+
+rownames(result) <- kinds
+colnames(result) <- log10(ns)
diff --git a/scripts/bench_join.py b/scripts/bench_join.py
index e2db3353e..40d637be8 100644
--- a/scripts/bench_join.py
+++ b/scripts/bench_join.py
@@ -2,23 +2,26 @@ import numpy as np
 import pandas._tseries as lib
 from pandas import *
 from copy import deepcopy
+import time
 
-a = np.arange(100000, dtype=np.int64)
-b = np.arange(20000, 120000, dtype=np.int64)
+n = 100000
+K = 1
+pct_overlap = 0.2
 
-dr1 = DateRange('1/1/2000', periods=100000, offset=datetools.Minute())
-dr2 = DateRange(dr1[20000], periods=100000, offset=datetools.Minute(2))
+a = np.arange(n, dtype=np.int64)
+b = np.arange(n * pct_overlap, n*(1+pct_overlap), dtype=np.int64)
+
+dr1 = DateRange('1/1/2000', periods=n, offset=datetools.Minute())
+dr2 = DateRange(dr1[int(pct_overlap*n)], periods=n, offset=datetools.Minute(2))
 
 aobj = a.astype(object)
 bobj = b.astype(object)
 
-av = np.random.randn(100000)
-bv = np.random.randn(100000)
-
-K = 5
+av = np.random.randn(n)
+bv = np.random.randn(n)
 
-avf = np.random.randn(100000, K)
-bvf = np.random.randn(100000, K)
+avf = np.random.randn(n, K)
+bvf = np.random.randn(n, K)
 
 a_series = Series(av, index=a)
 b_series = Series(bv, index=b)
@@ -27,17 +30,30 @@ a_frame = DataFrame(avf, index=dr1, columns=range(K))
 b_frame = DataFrame(bvf, index=dr2, columns=range(K, 2 * K))
 
 def do_left_join(a, b, av, bv):
-    indexer, mask = lib.ordered_left_join_int64(a, b)
-    result = bv.take(indexer)
-    np.putmask(result, mask, np.nan)
-    return result
+    out = np.empty((len(a), 2))
+    lib.left_join_1d(a, b, av, bv, out)
+    return out
+
+def do_outer_join(a, b, av, bv):
+    result_index, aindexer, bindexer = lib.outer_join_indexer(a, b)
+    result = np.empty((2, len(result_index)))
+    lib.take_1d(av, aindexer, result[0])
+    lib.take_1d(bv, bindexer, result[1])
+    return result_index, result
+
+def do_inner_join(a, b, av, bv):
+    result_index, aindexer, bindexer = lib.inner_join_indexer(a, b)
+    result = np.empty((2, len(result_index)))
+    lib.take_1d(av, aindexer, result[0])
+    lib.take_1d(bv, bindexer, result[1])
+    return result_index, result
 
 from line_profiler import LineProfiler
 prof = LineProfiler()
 
 from pandas.util.testing import set_trace
 
-def do_left_join_multi(a, b, av, bv):
+def do_left_join_python(a, b, av, bv):
     indexer, mask = lib.ordered_left_join_int64(a, b)
 
     n, ak = av.shape
@@ -58,19 +74,40 @@ def _take_multi(data, indexer, out):
     for i in xrange(data.shape[0]):
         data[i].take(indexer, out=out[i])
 
-def do_left_join_multi_put(a, b, av, bv):
+def do_left_join_multi(a, b, av, bv):
     n, ak = av.shape
     _, bk = bv.shape
     result = np.empty((n, ak + bk), dtype=np.float64)
-    lib.ordered_left_join_put(a, b, av, bv, result)
+    lib.left_join_2d(a, b, av, bv, result)
     return result
 
+def do_outer_join_multi(a, b, av, bv):
+    n, ak = av.shape
+    _, bk = bv.shape
+    result_index, rindexer, lindexer = lib.outer_join_indexer(a, b)
+    result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
+
+    lib.take_axis0(av, rindexer, out=result[:ak].T)
+    lib.take_axis0(bv, lindexer, out=result[ak:].T)
+    return result_index, result
+
+def do_inner_join_multi(a, b, av, bv):
+    n, ak = av.shape
+    _, bk = bv.shape
+    result_index, rindexer, lindexer = lib.inner_join_indexer(a, b)
+    result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
+
+    lib.take_axis0(av, rindexer, out=result[:ak].T)
+    lib.take_axis0(bv, lindexer, out=result[ak:].T)
+    return result_index, result
+
 def do_left_join_multi_v2(a, b, av, bv):
     indexer, mask = lib.ordered_left_join_int64(a, b)
     bv_taken = bv.take(indexer, axis=0)
     np.putmask(bv_taken, mask.repeat(bv.shape[1]), np.nan)
     return np.concatenate((av, bv_taken), axis=1)
 
+
 def do_left_join_series(a, b):
     return b.reindex(a.index)
 
@@ -79,6 +116,72 @@ def do_left_join_frame(a, b):
     b.index._indexMap = None
     return a.join(b, how='left')
 
+
 # a = np.array([1, 2, 3, 4, 5], dtype=np.int64)
 # b = np.array([0, 3, 5, 7, 9], dtype=np.int64)
 # print lib.inner_join_indexer(a, b)
+
+out = np.empty((10, 120000))
+
+def join(a, b, av, bv, how="left"):
+    func_dict = {'left' : do_left_join_multi,
+                 'outer' : do_outer_join_multi,
+                 'inner' : do_inner_join_multi}
+
+    f = func_dict[how]
+    return f(a, b, av, bv)
+
+def bench_python(n=100000, pct_overlap=0.20):
+    import gc
+    ns = [2, 3, 4, 5, 6]
+    iterations = 50
+    K = 5
+    pct_overlap = 0.2
+    kinds = ['outer', 'left', 'inner']
+
+    all_results = {}
+    for logn in ns:
+        n = 10**logn
+        a = np.arange(n, dtype=np.int64)
+        b = np.arange(n * pct_overlap, n * pct_overlap + n, dtype=np.int64)
+
+        avf = np.random.randn(n, K)
+        bvf = np.random.randn(n, K)
+
+        all_results[logn] = result = {}
+
+        for kind in kinds:
+            gc.disable()
+            _s = time.clock()
+            for _ in range(iterations):
+                join(a, b, avf, bvf, how=kind)
+            elapsed = time.clock() - _s
+            gc.enable()
+            result[kind] = (elapsed / iterations) * 1000
+
+    return DataFrame(all_results, index=kinds)
+
+def bench_xts(n=100000, pct_overlap=0.20):
+    from pandas.rpy.common import r
+    r('a <- 5')
+
+    xrng = '1:%d' % n
+
+    start = n * pct_overlap + 1
+    end = n + start - 1
+    yrng = '%d:%d' % (start, end)
+
+    r('library(xts)')
+
+    iterations = 500
+
+    kinds = ['left', 'outer', 'inner']
+    result = {}
+    for kind in kinds:
+        r('x <- xts(rnorm(%d), as.POSIXct(Sys.Date()) + %s)' % (n, xrng))
+        r('y <- xts(rnorm(%d), as.POSIXct(Sys.Date()) + %s)' % (n, yrng))
+        stmt = 'for (i in 1:%d) merge(x, y, join="%s")' % (iterations, kind)
+        elapsed = r('as.list(system.time(%s, gcFirst=F))$elapsed' % stmt)[0]
+        result[kind] = (elapsed / iterations) * 1000
+    return Series(result)
+

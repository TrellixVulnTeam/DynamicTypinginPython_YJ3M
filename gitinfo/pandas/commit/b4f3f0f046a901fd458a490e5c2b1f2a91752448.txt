commit b4f3f0f046a901fd458a490e5c2b1f2a91752448
Author: jreback <jeff@reback.net>
Date:   Sat Apr 5 10:51:16 2014 -0400

    BUG: bug in timedelta ops on 32-bit platforms (GH6808)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 2576982d6..94c5570d1 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -303,6 +303,7 @@ Bug Fixes
 - Bug in unpickling ``NaT (NaTType)`` (:issue:`4606`)
 - Bug in ``DataFrame.replace()`` where regex metacharacters were being treated
   as regexs even when ``regex=False`` (:issue:`6777`).
+- Bug in timedelta ops on 32-bit platforms (:issue:`6808`)
 
 pandas 0.13.1
 -------------
diff --git a/pandas/tseries/tests/test_timedeltas.py b/pandas/tseries/tests/test_timedeltas.py
index 341feec67..628c278af 100644
--- a/pandas/tseries/tests/test_timedeltas.py
+++ b/pandas/tseries/tests/test_timedeltas.py
@@ -243,6 +243,40 @@ class TestTimedeltas(tm.TestCase):
         expected = to_timedelta('00:01:21')
         tm.assert_almost_equal(result, expected)
 
+    def test_timedelta_ops_scalar(self):
+        _skip_if_numpy_not_friendly()
+
+        # GH 6808
+        base = pd.to_datetime('20130101 09:01:12.123456')
+        expected_add = pd.to_datetime('20130101 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta(10,unit='s'),
+                       timedelta(seconds=10),
+                       np.timedelta64(10,'s'),
+                       np.timedelta64(10000000000,'ns'),
+                       pd.offsets.Second(10)]:
+            result = base + offset
+            self.assertEquals(result, expected_add)
+
+            result = base - offset
+            self.assertEquals(result, expected_sub)
+
+        base = pd.to_datetime('20130102 09:01:12.123456')
+        expected_add = pd.to_datetime('20130103 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta('1 day, 00:00:10'),
+                       pd.to_timedelta('1 days, 00:00:10'),
+                       timedelta(days=1,seconds=10),
+                       np.timedelta64(1,'D')+np.timedelta64(10,'s'),
+                       pd.offsets.Day()+pd.offsets.Second(10)]:
+            result = base + offset
+            self.assertEquals(result, expected_add)
+
+            result = base - offset
+            self.assertEquals(result, expected_sub)
+
     def test_to_timedelta_on_missing_values(self):
         _skip_if_numpy_not_friendly()
 
diff --git a/pandas/tseries/timedeltas.py b/pandas/tseries/timedeltas.py
index 78dbd2466..cc01c26f7 100644
--- a/pandas/tseries/timedeltas.py
+++ b/pandas/tseries/timedeltas.py
@@ -68,7 +68,7 @@ def to_timedelta(arg, box=True, unit='ns'):
 _short_search = re.compile(
     "^\s*(?P<neg>-?)\s*(?P<value>\d*\.?\d*)\s*(?P<unit>d|s|ms|us|ns)?\s*$",re.IGNORECASE)
 _full_search = re.compile(
-    "^\s*(?P<neg>-?)\s*(?P<days>\d+)?\s*(days|d)?,?\s*(?P<time>\d{2}:\d{2}:\d{2})?(?P<frac>\.\d+)?\s*$",re.IGNORECASE)
+    "^\s*(?P<neg>-?)\s*(?P<days>\d+)?\s*(days|d|day)?,?\s*(?P<time>\d{2}:\d{2}:\d{2})?(?P<frac>\.\d+)?\s*$",re.IGNORECASE)
 _nat_search = re.compile(
     "^\s*(nat|nan)\s*$",re.IGNORECASE)
 _whitespace = re.compile('^\s*$')
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 497c0a33e..278e8effb 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -690,19 +690,19 @@ cdef class _Timestamp(datetime):
                         dts.us, ts.tzinfo)
 
     def __add__(self, other):
-        cdef Py_ssize_t other_int
+        cdef int64_t other_int
 
         if is_timedelta64_object(other):
-            other_int = other.astype('timedelta64[ns]').astype(int)
+            other_int = other.astype('timedelta64[ns]').view('i8')
             return Timestamp(self.value + other_int, tz=self.tzinfo, offset=self.offset)
 
-        if is_integer_object(other):
+        elif is_integer_object(other):
             if self.offset is None:
                 raise ValueError("Cannot add integral value to Timestamp "
                                  "without offset.")
             return Timestamp((self.offset * other).apply(self), offset=self.offset)
 
-        if isinstance(other, timedelta) or hasattr(other, 'delta'):
+        elif isinstance(other, timedelta) or hasattr(other, 'delta'):
             nanos = _delta_to_nanoseconds(other)
             return Timestamp(self.value + nanos, tz=self.tzinfo, offset=self.offset)
 

commit d38b36e1200d3096abd69433eacfe0536dcc0570
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Nov 12 23:00:10 2011 -0500

    ENH: deep internal tinkering, cythonized cache_readonly, engines cython ext

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 7abceb47c..a8d10538d 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -22,6 +22,8 @@ def _bin_op(op):
 _CACHE_START = datetime(1950, 1, 1)
 _CACHE_END   = datetime(2030, 1, 1)
 
+_daterange_cache = {}
+
 class DateRange(Index):
     """
     Fixed frequency date range according to input parameters.
@@ -43,7 +45,6 @@ class DateRange(Index):
     tzinfo : pytz.timezone
         To endow DateRange with time zone information
     """
-    _cache = {}
     def __new__(cls, start=None, end=None, periods=None,
                 offset=datetools.bday, time_rule=None,
                 tzinfo=None, name=None, **kwds):
@@ -143,7 +144,7 @@ class DateRange(Index):
         if offset is None:
             raise Exception('Must provide a DateOffset!')
 
-        if offset not in cls._cache:
+        if offset not in _daterange_cache:
             xdr = generate_range(_CACHE_START, _CACHE_END, offset=offset)
             arr = np.array(list(xdr), dtype=object, copy=False)
 
@@ -151,9 +152,9 @@ class DateRange(Index):
             cachedRange.offset = offset
             cachedRange.tzinfo = None
             cachedRange.name = None
-            cls._cache[offset] = cachedRange
+            _daterange_cache[offset] = cachedRange
         else:
-            cachedRange = cls._cache[offset]
+            cachedRange = _daterange_cache[offset]
 
         if start is None:
             if end is None:
@@ -165,13 +166,13 @@ class DateRange(Index):
 
             end = offset.rollback(end)
 
-            endLoc = cachedRange.indexMap[end] + 1
+            endLoc = cachedRange.get_loc(end) + 1
             startLoc = endLoc - periods
         elif end is None:
             assert(isinstance(start, datetime))
             start = offset.rollforward(start)
 
-            startLoc = cachedRange.indexMap[start]
+            startLoc = cachedRange.get_loc(start)
             if periods is None:
                 raise Exception('Must provide number of periods!')
 
@@ -180,8 +181,8 @@ class DateRange(Index):
             start = offset.rollforward(start)
             end = offset.rollback(end)
 
-            startLoc = cachedRange.indexMap[start]
-            endLoc = cachedRange.indexMap[end] + 1
+            startLoc = cachedRange.get_loc(start)
+            endLoc = cachedRange.get_loc(end) + 1
 
         indexSlice = cachedRange[startLoc:endLoc]
         indexSlice.name = name
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3c6bcb6bc..936e78163 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -865,7 +865,22 @@ class DataFrame(NDFrame):
                                  columns=self.columns, copy=False)
 
     #----------------------------------------------------------------------
-    # getitem/setitem related
+    # Getting and setting elements
+
+    def get(self, index, col):
+        """
+        Retrieve single value at passed column and index
+
+        Parameters
+        ----------
+        index : row label
+        col : column label
+
+        Returns
+        -------
+        element : scalar value
+        """
+        return self._data.get_scalar((col, index))
 
     def __getitem__(self, key):
         # slice rows
diff --git a/pandas/core/index.py b/pandas/core/index.py
index f8d04d648..55900f4bf 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -9,6 +9,7 @@ from pandas.core.common import (adjoin as _adjoin, _stringify,
                                 _is_bool_indexer, _asarray_tuplesafe)
 from pandas.util.decorators import cache_readonly
 import pandas._tseries as lib
+import pandas._engines as _engines
 
 __all__ = ['Index']
 
@@ -93,19 +94,15 @@ class Index(np.ndarray):
     def is_monotonic(self):
         return self._is_monotonic(self.values)
 
-    _indexMap = None
-    _integrity = False
-
     @property
     def indexMap(self):
         "{label -> location}"
-        if self._indexMap is None:
-            self._indexMap = self._map_indices(self)
-            self._integrity = len(self._indexMap) == len(self)
+        return self._engine.get_mapping(1)
 
-        if not self._integrity:
-            raise Exception('Index cannot contain duplicate values!')
-        return self._indexMap
+    @cache_readonly
+    def _engine(self):
+        # property, for now, slow to look up
+        return _engines.DictIndexEngine(self.values, self._map_indices)
 
     def _get_level_number(self, level):
         if not isinstance(level, int):
@@ -114,12 +111,7 @@ class Index(np.ndarray):
         return level
 
     def _verify_integrity(self):
-        if self._indexMap is None:
-            try:
-                self.indexMap
-            except Exception:
-                return False
-        return len(self.indexMap) == len(self)
+        return self._engine.has_integrity
 
     def _get_duplicates(self):
         from collections import defaultdict
@@ -139,7 +131,7 @@ class Index(np.ndarray):
         return self._allDates
 
     def __iter__(self):
-        return iter(self.view(np.ndarray))
+        return iter(self.values)
 
     def __setstate__(self, state):
         """Necessary for making this object picklable"""
@@ -152,7 +144,7 @@ class Index(np.ndarray):
         return self
 
     def __contains__(self, key):
-        return key in self.indexMap
+        return key in self._engine
 
     def __hash__(self):
         return hash(self.view(np.ndarray))
@@ -238,7 +230,7 @@ class Index(np.ndarray):
         For a sorted index, return the most recent label up to and including
         the passed label. Return NaN if not found
         """
-        if label not in self.indexMap:
+        if label not in self:
             loc = self.searchsorted(label, side='left')
             if loc > 0:
                 return self[loc-1]
@@ -409,7 +401,7 @@ class Index(np.ndarray):
         -------
         loc : int
         """
-        return self.indexMap[key]
+        return self._engine.get_loc(key)
 
     def get_indexer(self, target, method=None):
         """
@@ -570,14 +562,14 @@ class Index(np.ndarray):
         if start is None:
             beg_slice = 0
         elif start in self:
-            beg_slice = self.indexMap[start]
+            beg_slice = self.get_loc(start)
         else:
             beg_slice = self.searchsorted(start, side='left')
 
         if end is None:
             end_slice = len(self)
-        elif end in self.indexMap:
-            end_slice = self.indexMap[end] + 1
+        elif end in self:
+            end_slice = self.get_loc(end) + 1
         else:
             end_slice = self.searchsorted(end, side='right')
 
@@ -893,11 +885,6 @@ class MultiIndex(Index):
     def dtype(self):
         return np.dtype('O')
 
-    def __iter__(self):
-        values = [np.asarray(lev).take(lab)
-                  for lev, lab in zip(self.levels, self.labels)]
-        return izip(*values)
-
     def _get_level_number(self, level):
         if not isinstance(level, int):
             count = self.names.count(level)
@@ -912,9 +899,9 @@ class MultiIndex(Index):
 
     @property
     def values(self):
-        result = np.empty(len(self), dtype=object)
-        result[:] = list(self)
-        return result
+        values = [np.asarray(lev).take(lab)
+                  for lev, lab in zip(self.levels, self.labels)]
+        return lib.fast_zip(values)
 
     def get_level_values(self, level):
         """
@@ -935,8 +922,7 @@ class MultiIndex(Index):
 
     def __contains__(self, key):
         try:
-            label_key = self._get_label_key(key)
-            return label_key in self.indexMap
+            return key in self.indexMap
         except Exception:
             return False
 
@@ -1033,18 +1019,6 @@ class MultiIndex(Index):
         return MultiIndex.from_arrays(arrays, sortorder=sortorder,
                                       names=names)
 
-    @property
-    def indexMap(self):
-        if self._indexMap is None:
-            zipped = zip(*self.labels)
-            self._indexMap = lib.map_indices_list(zipped)
-            self._integrity = len(self._indexMap) == len(self)
-
-        if not self._integrity:
-            raise Exception('Index cannot contain duplicate values!')
-
-        return self._indexMap
-
     @property
     def nlevels(self):
         return len(self.levels)
@@ -1399,7 +1373,7 @@ class MultiIndex(Index):
         """
         if isinstance(key, tuple):
             if len(key) == self.nlevels:
-                return self._get_tuple_loc(key)
+                return self._engine.get_loc(key)
             else:
                 result = slice(*self.slice_locs(key, key))
                 if result.start == result.stop:
@@ -1418,13 +1392,6 @@ class MultiIndex(Index):
                 j = labels.searchsorted(loc, side='right')
                 return slice(i, j)
 
-    def _get_tuple_loc(self, tup):
-        indexer = self._get_label_key(tup)
-        try:
-            return self.indexMap[indexer]
-        except KeyError:
-            raise KeyError(str(tup))
-
     def _get_label_key(self, tup):
         return tuple(lev.get_loc(v) for lev, v in zip(self.levels, tup))
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 7605f7b4e..ca5a3c51c 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -315,8 +315,7 @@ class BlockManager(object):
         return tuple(len(ax) for ax in self.axes)
 
     def _verify_integrity(self):
-        union_items = _union_block_items(self.blocks)
-
+        _union_block_items(self.blocks)
         mgr_shape = self.shape
         for block in self.blocks:
             assert(block.values.shape[1:] == mgr_shape[1:])
@@ -520,6 +519,19 @@ class BlockManager(object):
         _, block = self._find_block(item)
         return block.get(item)
 
+    def get_scalar(self, tup):
+        """
+        Retrieve single item
+        """
+        item = tup[0]
+        _, blk = self._find_block(item)
+
+        # this could obviously be seriously sped up in cython
+        item_loc = blk.items.get_loc(item),
+        full_loc = item_loc + tuple(ax.get_loc(x)
+                                    for ax, x in zip(self.axes[1:], tup[1:]))
+        return blk.values[full_loc]
+
     def delete(self, item):
         i, _ = self._find_block(item)
         loc = self.items.get_loc(item)
@@ -548,6 +560,9 @@ class BlockManager(object):
             # insert at end
             self.insert(len(self.items), item, value)
 
+    def set_scalar(self, tup, value):
+        pass
+
     def insert(self, loc, item, value):
         if item in self.items:
             raise Exception('cannot insert %s, already exists' % item)
@@ -903,23 +918,15 @@ def _blocks_to_series_dict(blocks, index=None):
     return series_dict
 
 def _interleaved_dtype(blocks):
-    have_int = False
-    have_bool = False
-    have_object = False
-    have_float = False
-
-    for block in blocks:
-        if isinstance(block, FloatBlock):
-            have_float = True
-        elif isinstance(block, IntBlock):
-            have_int = True
-        elif isinstance(block, BoolBlock):
-            have_bool = True
-        elif isinstance(block, ObjectBlock):
-            have_object = True
-        else: # pragma: no cover
-            raise Exception('Unrecognized block type')
-
+    from collections import defaultdict
+    counts = defaultdict(lambda: 0)
+    for x in blocks:
+        counts[type(x)] += 1
+
+    have_int = counts[IntBlock] > 0
+    have_bool = counts[BoolBlock] > 0
+    have_object = counts[ObjectBlock] > 0
+    have_float = counts[FloatBlock] > 0
     have_numeric = have_float or have_int
 
     if have_object:
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
new file mode 100644
index 000000000..211f1681f
--- /dev/null
+++ b/pandas/src/engines.pyx
@@ -0,0 +1,62 @@
+from numpy cimport ndarray
+
+cdef class IndexEngine:
+
+    pass
+
+cdef class DictIndexEngine(IndexEngine):
+    '''
+    For accelerating low-level internal details of indexing
+    '''
+
+    cdef readonly:
+        ndarray values
+        dict mapping
+        object mapfun
+
+    cdef:
+        bint initialized, integrity
+
+    def __init__(self, ndarray values, object mapfun):
+        self.values = values
+        self.initialized = 0
+        self.integrity = 0
+        self.mapfun = mapfun
+
+    def __contains__(self, object val):
+        self._ensure_initialized()
+        return val in self.mapping
+
+    def get_mapping(self, bint check_integrity):
+        self._ensure_initialized()
+        if check_integrity and self.integrity == 0:
+            raise Exception('Index cannot contain duplicate values!')
+
+        return self.mapping
+
+    cdef _ensure_initialized(self):
+        if not self.initialized:
+            self.initialize()
+
+    property mapping_prop:
+
+        def __get__(self):
+            self._ensure_initialized()
+            return self.mapfun
+
+    property has_integrity:
+
+        def __get__(self):
+            self._ensure_initialized()
+            return self.integrity == 1
+
+    cdef initialize(self):
+        self.mapping = self.mapfun(self.values)
+        if len(self.mapping) == len(self.values):
+            self.integrity = 1
+        self.initialized = 1
+
+    cpdef get_loc(self, object val):
+        self._ensure_initialized()
+        return self.mapping[val]
+
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 0c7b68baf..520f83ba4 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -438,6 +438,35 @@ def fast_zip(list ndarrays):
 
     return result
 
+cdef class cache_readonly(object):
+
+    cdef readonly:
+        object fget, name
+
+    def __init__(self, func):
+        self.fget = func
+        self.name = func.__name__
+
+    def __get__(self, obj, type):
+        if obj is None:
+            return self.fget
+
+        # Get the cache or set a default one if needed
+
+        cache = getattr(obj, '_cache', None)
+        if cache is None:
+            cache = obj._cache = {}
+
+        if PyDict_Contains(cache, self.name):
+            # not necessary to Py_INCREF
+            val = <object> PyDict_GetItem(cache, self.name)
+            return val
+        else:
+            val = self.fget(obj)
+            PyDict_SetItem(cache, self.name, val)
+            return val
+
+
 include "skiplist.pyx"
 include "groupby.pyx"
 include "moments.pyx"
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 56f3a2f86..4d7cb30c8 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -660,6 +660,13 @@ class CheckIndexing(object):
     def test_setitem_boolean_missing(self):
         pass
 
+    def test_get_scalar(self):
+        for idx in self.frame.index:
+            for col in self.frame.columns:
+                result = self.frame.get(idx, col)
+                expected = self.frame[col][idx]
+                self.assertEqual(result, expected)
+
 _seriesd = tm.getSeriesData()
 _tsd = tm.getTimeSeriesData()
 
diff --git a/pandas/util/decorators.py b/pandas/util/decorators.py
index ca2182254..58ee9551b 100644
--- a/pandas/util/decorators.py
+++ b/pandas/util/decorators.py
@@ -1,229 +1,2 @@
-"""
-Pierre G-M's caching decorators
-"""
+from pandas._tseries import cache_readonly
 
-import warnings
-
-__all__ = ['resettable_cache','cache_readonly', 'cache_writable']
-
-#-------------------------------------------------------------------------------
-# Pierre G-M's caching decorators
-
-class CacheWriteWarning(UserWarning):
-    pass
-
-
-class ResettableCache(dict):
-    """
-    Dictionary whose elements mey depend one from another.
-
-    If entry `B` depends on entry `A`, changing the values of entry `A` will
-    reset the value of entry `B` to a default (None); deleteing entry `A` will
-    delete entry `B`.  The connections between entries are stored in a
-    `_resetdict` private attribute.
-
-    Parameters
-    ----------
-    reset : dictionary, optional
-        An optional dictionary, associated a sequence of entries to any key
-        of the object.
-    items : var, optional
-        An optional dictionary used to initialize the dictionary
-
-    Examples
-    --------
-    >>> reset = dict(a=('b',), b=('c',))
-    >>> cache = resettable_cache(a=0, b=1, c=2, reset=reset)
-    >>> assert_equal(cache, dict(a=0, b=1, c=2))
-
-    >>> print "Try resetting a"
-    >>> cache['a'] = 1
-    >>> assert_equal(cache, dict(a=1, b=None, c=None))
-    >>> cache['c'] = 2
-    >>> assert_equal(cache, dict(a=1, b=None, c=2))
-    >>> cache['b'] = 0
-    >>> assert_equal(cache, dict(a=1, b=0, c=None))
-
-    >>> print "Try deleting b"
-    >>> del(cache['a'])
-    >>> assert_equal(cache, {})
-    """
-
-    def __init__(self, reset=None, **items):
-        self._resetdict = reset or {}
-        dict.__init__(self, **items)
-
-    def __setitem__(self, key, value):
-        dict.__setitem__(self, key, value)
-        for mustreset in self._resetdict.get(key, []):
-            self[mustreset] = None
-
-    def __delitem__(self, key):
-        dict.__delitem__(self, key)
-        for mustreset in self._resetdict.get(key, []):
-            del(self[mustreset])
-
-resettable_cache = ResettableCache
-
-class CachedAttribute(object):
-
-    def __init__(self, func, cachename=None, resetlist=None):
-        self.fget = func
-        self.name = func.__name__
-        self.cachename = cachename or '_cache'
-        self.resetlist = resetlist or ()
-
-    def __get__(self, obj, type=None):
-        if obj is None:
-            return self.fget
-        # Get the cache or set a default one if needed
-        _cachename = self.cachename
-        _cache = getattr(obj, _cachename, None)
-        if _cache is None:
-            setattr(obj, _cachename, resettable_cache())
-            _cache = getattr(obj, _cachename)
-        # Get the name of the attribute to set and cache
-        name = self.name
-        _cachedval = _cache.get(name, None)
-#        print "[_cachedval=%s]" % _cachedval
-        if _cachedval is None:
-            # Call the "fget" function
-            _cachedval = self.fget(obj)
-            # Set the attribute in obj
-#            print "Setting %s in cache to %s" % (name, _cachedval)
-            try:
-                _cache[name] = _cachedval
-            except KeyError:
-                setattr(_cache, name, _cachedval)
-            # Update the reset list if needed (and possible)
-            resetlist = self.resetlist
-            if resetlist is not ():
-                try:
-                    _cache._resetdict[name] = self.resetlist
-                except AttributeError:
-                    pass
-#        else:
-#            print "Reading %s from cache (%s)" % (name, _cachedval)
-        return _cachedval
-
-    def __set__(self, obj, value):
-        errmsg = "The attribute '%s' cannot be overwritten" % self.name
-        warnings.warn(errmsg, CacheWriteWarning)
-
-class CachedWritableAttribute(CachedAttribute):
-    #
-    def __set__(self, obj, value):
-        _cache = getattr(obj, self.cachename)
-        name = self.name
-        try:
-            _cache[name] = value
-        except KeyError:
-            setattr(_cache, name, value)
-
-class _cache_readonly(object):
-    """
-    Decorator for CachedAttribute
-    """
-
-    def __init__(self, cachename=None, resetlist=None):
-        self.func = None
-        self.cachename = cachename
-        self.resetlist = resetlist or None
-
-    def __call__(self, func):
-        return CachedAttribute(func,
-                               cachename=self.cachename,
-                               resetlist=self.resetlist)
-cache_readonly = _cache_readonly()
-
-class cache_writable(_cache_readonly):
-    """
-    Decorator for CachedWritableAttribute
-    """
-    def __call__(self, func):
-        return CachedWritableAttribute(func,
-                                       cachename=self.cachename,
-                                       resetlist=self.resetlist)
-
-def deprecate(name, alternative):
-    alt_name = alternative.func_name
-    def wrapper(*args, **kwargs):
-        warnings.warn("%s is deprecated. Use %s instead" % (name, alt_name),
-                      FutureWarning)
-        return alternative(*args, **kwargs)
-    return wrapper
-
-if __name__ == "__main__":
-### Tests resettable_cache ----------------------------------------------------
-
-    from numpy.testing import *
-
-    reset = dict(a=('b',), b=('c',))
-    cache = resettable_cache(a=0, b=1, c=2, reset=reset)
-    assert_equal(cache, dict(a=0, b=1, c=2))
-    #
-    print "Try resetting a"
-    cache['a'] = 1
-    assert_equal(cache, dict(a=1, b=None, c=None))
-    cache['c'] = 2
-    assert_equal(cache, dict(a=1, b=None, c=2))
-    cache['b'] = 0
-    assert_equal(cache, dict(a=1, b=0, c=None))
-    #
-    print "Try deleting b"
-    del(cache['a'])
-    assert_equal(cache, {})
-### ---------------------------------------------------------------------------
-
-
-    class Example(object):
-        #
-        def __init__(self):
-            self._cache = resettable_cache()
-            self.a = 0
-        #
-        @cache_readonly
-        def b(self):
-            return 1
-        @cache_writable(resetlist='d')
-        def c(self):
-            return 2
-        @cache_writable(resetlist=('e', 'f'))
-        def d(self):
-            return self.c + 1
-        #
-        @cache_readonly
-        def e(self):
-            return 4
-        @cache_readonly
-        def f(self):
-            return self.e + 1
-
-    ex = Example()
-    print "(attrs  : %s)" % str(ex.__dict__)
-    print "(cached : %s)" % str(ex._cache)
-    print "Try a   :", ex.a
-    print "Try accessing/setting a readonly attribute"
-    assert_equal(ex.__dict__, dict(a=0, _cache={}))
-    print "Try b #1:", ex.b
-    b = ex.b
-    assert_equal(b, 1)
-    assert_equal(ex.__dict__, dict(a=0, _cache=dict(b=1,)))
-#   assert_equal(ex.__dict__, dict(a=0, b=1, _cache=dict(b=1)))
-    ex.b = -1
-    print "Try dict", ex.__dict__
-    assert_equal(ex._cache, dict(b=1,))
-    #
-    print "Try accessing/resetting a cachewritable attribute"
-    c = ex.c
-    assert_equal(c, 2)
-    assert_equal(ex._cache, dict(b=1, c=2))
-    d = ex.d
-    assert_equal(d, 3)
-    assert_equal(ex._cache, dict(b=1, c=2, d=3))
-    ex.c = 0
-    assert_equal(ex._cache, dict(b=1, c=0, d=None, e=None, f=None))
-    d = ex.d
-    assert_equal(ex._cache, dict(b=1, c=0, d=1, e=None, f=None))
-    ex.d = 5
-    assert_equal(ex._cache, dict(b=1, c=0, d=5, e=None, f=None))
diff --git a/setup.py b/setup.py
index f37dddea5..fd08f5f68 100755
--- a/setup.py
+++ b/setup.py
@@ -293,7 +293,13 @@ tseries_ext = Extension('pandas._tseries',
 sparse_ext = Extension('pandas._sparse',
                        sources=[srcpath('sparse', suffix=suffix)],
                        include_dirs=[np.get_include()])
+
+engines_ext = Extension('pandas._engines',
+                       sources=[srcpath('engines', suffix=suffix)],
+                       include_dirs=[np.get_include()])
+
 extensions = [tseries_ext,
+              engines_ext,
               sparse_ext]
 
 # if _have_setuptools:

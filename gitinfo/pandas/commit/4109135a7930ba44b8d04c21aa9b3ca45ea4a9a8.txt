commit 4109135a7930ba44b8d04c21aa9b3ca45ea4a9a8
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jul 31 22:00:46 2011 -0400

    ENH: multi-level index from_arrays method, reindexing-related methods, and Series changes so alignment will work. need to write a lot of tests

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9058de15b..d710acef4 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1180,10 +1180,10 @@ class DataFrame(NDFrame):
 
         need_reindex = False
         new_columns = _union_indices(self.columns, other.columns)
-        need_reindex = (need_reindex or new_index is not self.index
-                        or new_index is not other.index)
-        need_reindex = (need_reindex or new_columns is not self.columns
-                        or new_columns is not other.columns)
+        need_reindex = (need_reindex or not new_index.equals(self.index)
+                        or not new_index.equals(other.index))
+        need_reindex = (need_reindex or not new_columns.equals(self.columns)
+                        or not new_columns.equals(other.columns))
 
         this = self
         if need_reindex:
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 507c3bb52..a1742d010 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -195,21 +195,12 @@ class GroupBy(object):
         name_list = self._get_names()
 
         if len(self.groupings) > 1:
-            levels = []
-            labels = []
-            for name, raveled in name_list:
-                factor = Factor.fromarray(raveled)
-                levels.append(factor.levels)
-                labels.append(factor.labels[mask])
-
-            index = MultiIndex(levels=levels, labels=labels)
+            masked = [raveled[mask] for _, raveled in name_list]
+            index = MultiIndex.from_arrays(*masked)
             return DataFrame(output, index=index)
         else:
             return DataFrame(output, index=name_list[0][1])
 
-    def _python_aggregate(self, func):
-        pass
-
     def _aggregate_multi_group(self, arg):
         # want to cythonize?
 
@@ -246,14 +237,8 @@ class GroupBy(object):
         name_list = self._get_names()
 
         if len(self.groupings) > 1:
-            levels = []
-            labels = []
-            for name, raveled in name_list:
-                factor = Factor.fromarray(raveled)
-                levels.append(factor.levels)
-                labels.append(factor.labels[mask])
-
-            index = MultiIndex(levels=levels, labels=labels)
+            masked = [raveled[mask] for _, raveled in name_list]
+            index = MultiIndex.from_arrays(*masked)
             return DataFrame(output, index=index)
         else:
             return DataFrame(output, index=name_list[0][1])
diff --git a/pandas/core/index.py b/pandas/core/index.py
index bdd643b38..0f9395e6b 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -395,6 +395,24 @@ class MultiIndex(Index):
         # self.labels = getattr(obj, 'labels', None)
         # self.levels = getattr(obj, 'levels', None)
 
+    @classmethod
+    def from_arrays(cls, *arrays):
+        """
+        Convert arrays to MultiIndex
+
+        Returns
+        -------
+        index : MultiIndex
+        """
+        levels = []
+        labels = []
+        for arr in arrays:
+            factor = Factor.fromarray(arr)
+            levels.append(factor.levels)
+            labels.append(factor.labels)
+
+        return MultiIndex(levels=levels, labels=labels)
+
     @property
     def indexMap(self):
         if not hasattr(self, '_cache_indexMap'):
@@ -476,12 +494,6 @@ class MultiIndex(Index):
     def sort(self, level=0):
         pass
 
-    @classmethod
-    def from_arrays(cls, *arrays):
-        levels = []
-        labels = []
-        return cls(levels, labels)
-
     def get_loc(self, key):
         if isinstance(key, tuple):
             return self._get_tuple_loc(key)
@@ -524,14 +536,26 @@ class MultiIndex(Index):
             'FFILL' : 'PAD',
             'BFILL' : 'BACKFILL'
         }
+        method = aliases.get(method, method)
 
-        target = _ensure_index(target)
+        if not isinstance(target, MultiIndex):
+            raise TypeError('Can only align with other MultiIndex objects')
 
-        method = aliases.get(method, method)
-        indexer, mask = _tseries.getFillVec(self, target, self.indexMap,
-                                            target.indexMap, method)
+        self_index = self.get_tuple_index()
+        target_index = target.get_tuple_index()
+
+        indexer, mask = _tseries.getFillVec(self_index, target_index,
+                                            self_index.indexMap,
+                                            target_index.indexMap, method)
         return indexer, mask
 
+    def get_tuple_index(self):
+        to_join = []
+        for lev, lab in zip(self.levels, self.labels):
+            to_join.append(np.asarray(lev).take(lab))
+
+        return Index(zip(*to_join))
+
     def slice_locs(self, start=None, end=None):
         """
 
@@ -588,7 +612,7 @@ class MultiIndex(Index):
 
     def equals(self, other):
         """
-        Determines if two Index objects contain the same elements.
+        Determines if two MultiIndex objects are the same
         """
         if self is other:
             return True
@@ -596,11 +620,31 @@ class MultiIndex(Index):
         if not isinstance(other, MultiIndex):
             return False
 
-        return np.array_equal(self, other)
+        if self.nlevels != other.nlevels:
+            return False
+
+        # if not self.equal_levels(other):
+        #     return False
+
+        for i in xrange(self.nlevels):
+            if not self.levels[i].equals(other.levels[i]):
+                return False
+            if not np.array_equal(self.labels[i], other.labels[i]):
+                return False
+        return True
+
+    def equal_levels(self, other):
+        if self.nlevels != other.nlevels:
+            return False
+
+        for i in xrange(self.nlevels):
+            if not self.levels[i].equals(other.levels[i]):
+                return False
+        return True
 
     def union(self, other):
         """
-        Form the union of two Index objects and sorts if possible
+        Form the union of two MultiIndex objects
 
         Parameters
         ----------
@@ -615,14 +659,11 @@ class MultiIndex(Index):
         if len(other) == 0 or self.equals(other):
             return self
 
-        new_seq = np.concatenate((self, other))
-        try:
-            new_seq = np.unique(new_seq)
-        except Exception:
-            # Not sortable / multiple types
-            pass
-
-        return MultiIndex(new_seq)
+        # TODO: optimize / make less wasteful
+        self_tuples = self.get_tuple_index()
+        other_tuples = other.get_tuple_index()
+        uniq_tuples = np.unique(np.concatenate((self_tuples, other_tuples)))
+        return MultiIndex.from_arrays(*zip(*uniq_tuples))
 
     def intersection(self, other):
         """
@@ -641,8 +682,11 @@ class MultiIndex(Index):
         if self.equals(other):
             return self
 
-        theIntersection = sorted(set(self) & set(other))
-        return Index(theIntersection)
+        # TODO: optimize / make less wasteful
+        self_tuples = self.get_tuple_index()
+        other_tuples = other.get_tuple_index()
+        uniq_tuples = sorted(set(self_tuples) & set(other_tuples))
+        return MultiIndex.from_arrays(*zip(*uniq_tuples))
 
     def _assert_can_do_setop(self, other):
         if not hasattr(other, '__iter__'):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index b22bebe29..161057cab 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -44,20 +44,9 @@ def _arith_method(op, name):
             newIndex = self.index + other.index
 
             try:
-                if self.dtype != np.float_:
-                    this = self.astype(float)
-                else:
-                    this = self
-
-                if other.dtype != np.float_:
-                    other = other.astype(float)
-
-                # buffered Cython function expects double type
-
-                arr = _tseries.combineFunc(name, newIndex,
-                                           this, other,
-                                           self.index.indexMap,
-                                           other.index.indexMap)
+                this_reindexed = self.reindex(newIndex)
+                other_reindexed = other.reindex(newIndex)
+                arr = op(this_reindexed.values, other_reindexed.values)
             except Exception:
                 arr = Series.combine(self, other, getattr(type(self[0]), name))
             result = Series(arr, index=newIndex)
diff --git a/pandas/src/operators.pyx b/pandas/src/operators.pyx
deleted file mode 100644
index 0d164625a..000000000
--- a/pandas/src/operators.pyx
+++ /dev/null
@@ -1,65 +0,0 @@
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cdef ndarray _applyFunc(double_func func, ndarray index, ndarray ao,
-                        ndarray bo, dict aMap, dict bMap):
-    '''
-    C function taking a function pointer for quickly adding two Series objects.
-    '''
-    cdef ndarray result
-    cdef double *result_data, *a_data, *b_data
-    cdef int length
-    cdef Py_ssize_t i, aidx, bidx
-    cdef double nan
-    cdef object idx
-    cdef ndarray[object, ndim=1] ibuf
-    cdef ndarray[double_t, ndim=1] A, B
-
-    A = ao
-    B = bo
-
-    ibuf = index
-
-    nan = <double> np.NaN
-    length = len(index)
-    result = <ndarray> np.empty(length, dtype=float)
-    result_data = <double *> result.data
-
-    for i from 0 <= i < length:
-        idx = ibuf[i]
-
-        if idx not in aMap or idx not in bMap:
-            result_data[i] = nan
-            continue
-
-        aidx = aMap[idx]
-        bidx = bMap[idx]
-        result_data[i] = func(A[aidx], B[bidx])
-
-    return result
-
-def combineFunc(object name, ndarray index, ndarray ao,
-                ndarray bo, dict aMap, dict bMap):
-    '''
-    Combine two series (values and index maps for each passed in) using the
-    indicated function.
-    '''
-    if name == "__add__":
-        return _applyFunc(__add, index, ao, bo, aMap, bMap)
-    elif name == "__sub__":
-        return _applyFunc(__sub, index, ao, bo, aMap, bMap)
-    elif name == "__div__":
-        return _applyFunc(__div, index, ao, bo, aMap, bMap)
-    elif name == "__mul__":
-        return _applyFunc(__mul, index, ao, bo, aMap, bMap)
-    elif name == "__eq__":
-        return _applyFunc(__eq, index, ao, bo, aMap, bMap)
-    elif name == "__ne__":
-        return _applyFunc(__ne, index, ao, bo, aMap, bMap)
-    elif name == "__lt__":
-        return _applyFunc(__lt, index, ao, bo, aMap, bMap)
-    elif name == "__gt__":
-        return _applyFunc(__gt, index, ao, bo, aMap, bMap)
-    elif name == "__pow__":
-        return _applyFunc(__pow, index, ao, bo, aMap, bMap)
-    else:
-        raise Exception('bad funcname requested of Cython code')
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index d27818a74..654d9255b 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -4,5 +4,4 @@ include "isnull.pyx"
 include "groupby.pyx"
 include "moments.pyx"
 include "reindex.pyx"
-include "operators.pyx"
 include "io.pyx"

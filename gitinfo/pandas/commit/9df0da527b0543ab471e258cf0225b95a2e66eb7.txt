commit 9df0da527b0543ab471e258cf0225b95a2e66eb7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Dec 5 23:13:24 2011 -0500

    ENH: set_value with resizing, DataFrame constructor can resize BlockManager, tweaks, #438

diff --git a/bench/bench_get_put_value.py b/bench/bench_get_put_value.py
new file mode 100644
index 000000000..8f33b5b33
--- /dev/null
+++ b/bench/bench_get_put_value.py
@@ -0,0 +1,35 @@
+from pandas import *
+from pandas.util.testing import rands
+
+N = 1000
+K = 50
+
+def _random_index(howmany):
+    return Index([rands(10) for _ in xrange(howmany)])
+
+df = DataFrame(np.random.randn(N, K), index=_random_index(N),
+               columns=_random_index(K))
+
+def get1():
+    for col in df.columns:
+        for row in df.index:
+            _ = df[col][row]
+
+def get2():
+    for col in df.columns:
+        for row in df.index:
+            _ = df.get_value(row, col)
+
+def put1():
+    for col in df.columns:
+        for row in df.index:
+            df[col][row] = 0
+
+def put2():
+    for col in df.columns:
+        for row in df.index:
+            df.set_value(row, col, 0)
+
+for col in df.columns:
+    for row in df.index:
+        value = df.get_value(row, col)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c0b2bef5c..7b2fbb405 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -32,7 +32,7 @@ from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.series import Series, _is_bool_indexer
 from pandas.util import py3compat
 import pandas.core.nanops as nanops
-import pandas.core.common as common
+import pandas.core.common as com
 import pandas.core.datetools as datetools
 import pandas._tseries as lib
 
@@ -179,13 +179,7 @@ class DataFrame(NDFrame):
             data = data._data
 
         if isinstance(data, BlockManager):
-            # do not copy BlockManager unless explicitly done
-            mgr = data
-            if copy and dtype is None:
-                mgr = mgr.copy()
-            elif dtype is not None:
-                # no choice but to copy
-                mgr = mgr.astype(dtype)
+            mgr = self._init_mgr(data, index, columns, dtype=dtype, copy=copy)
         elif isinstance(data, dict):
             mgr = self._init_dict(data, index, columns, dtype=dtype)
         elif isinstance(data, ma.MaskedArray):
@@ -211,6 +205,19 @@ class DataFrame(NDFrame):
 
         NDFrame.__init__(self, mgr)
 
+    def _init_mgr(self, mgr, index, columns, dtype=None, copy=False):
+        if columns is not None:
+            mgr = mgr.reindex_axis(columns, axis=0)
+        if index is not None:
+            mgr = mgr.reindex_axis(index, axis=1)
+        # do not copy BlockManager unless explicitly done
+        if copy and dtype is None:
+            mgr = mgr.copy()
+        elif dtype is not None:
+            # no choice but to copy
+            mgr = mgr.astype(dtype)
+        return mgr
+
     def _init_dict(self, data, index, columns, dtype=None):
         """
         Segregate Series based on type and coerce into matrices.
@@ -915,9 +922,28 @@ class DataFrame(NDFrame):
         col : column label
         value : scalar value
         """
-        series = self._get_item_cache(col)
-        engine = self.index._engine
-        return engine.set_value(series, index, value)
+        try:
+            series = self._get_item_cache(col)
+            engine = self.index._engine
+            engine.set_value(series, index, value)
+            return self
+        except KeyError:
+            if index not in self.index:
+                new_index = np.concatenate([self.index, [index]])
+            else:
+                new_index = self.index
+            if col not in self.columns:
+                new_columns = np.concatenate([self.columns, [col]])
+            else:
+                new_columns = self.columns
+            result = DataFrame(self._data, index=new_index,
+                               columns=new_columns)
+
+            likely_dtype = com._infer_dtype(value)
+            if result[col].dtype != likely_dtype:
+                result[col] = result[col].astype(likely_dtype)
+            result.set_value(index, col, value)
+            return result
 
     def __getitem__(self, key):
         # slice rows
@@ -1618,10 +1644,8 @@ class DataFrame(NDFrame):
             # Float type values
             if len(self.columns) == 0:
                 return self
-
             new_data = self._data.fillna(value)
-            return self._constructor(new_data, index=self.index,
-                                     columns=self.columns)
+            return self._constructor(new_data)
 
     #----------------------------------------------------------------------
     # Rename
@@ -1832,7 +1856,7 @@ class DataFrame(NDFrame):
                 arr = func(series, otherSeries)
 
                 if do_fill:
-                    arr = common.ensure_float(arr)
+                    arr = com.ensure_float(arr)
                     arr[this_mask & other_mask] = nan
 
                 result[col] = arr
@@ -2114,7 +2138,7 @@ class DataFrame(NDFrame):
             new_values = blk.values.take(indexer, axis=1)
             # convert integer to float if necessary. need to do a lot more than
             # that, handle boolean etc also
-            new_values = common.ensure_float(new_values)
+            new_values = com.ensure_float(new_values)
             if periods > 0:
                 new_values[:, :periods] = nan
             else:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 5dc5da7f9..a003249c9 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -331,12 +331,14 @@ copy : boolean, default False
         ----------
         label : object
             Partial indexing with MultiIndex not allowed
-
-        Returns
-        -------
-        element : scalar value
         """
-        self.index._engine.set_value(self, label, value)
+        try:
+            self.index._engine.set_value(self, label, value)
+            return self
+        except KeyError:
+            new_index = np.concatenate([self.index.values, [label]])
+            new_values = np.concatenate([self.values, [value]])
+            return Series(new_values, index=new_index, name=self.name)
 
     def _multilevel_index(self, key):
         values = self.values
@@ -368,8 +370,7 @@ copy : boolean, default False
     def __setitem__(self, key, value):
         values = self.values
         try:
-            loc = self.index.get_loc(key)
-            values[loc] = value
+            values[self.index.get_loc(key)] = value
             return
         except KeyError:
             if isinstance(key, (int, np.integer)):
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 30818858c..1850d62a4 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -1,5 +1,6 @@
 from numpy cimport ndarray
 cimport numpy as cnp
+cimport cpython
 
 cnp.import_array()
 
@@ -32,6 +33,7 @@ cdef class IndexEngine:
 cpdef inline object get_value_at(ndarray arr, object loc):
     cdef:
         Py_ssize_t i
+        void* data_ptr
     if util.is_float_object(loc):
         casted = int(loc)
         if casted == loc:
@@ -52,8 +54,8 @@ cpdef inline set_value_at(ndarray arr, object loc, object value):
     i = <Py_ssize_t> loc
     if i < 0:
         i += cnp.PyArray_SIZE(arr)
-    data_ptr = cnp.PyArray_GETPTR1(arr, loc)
-    cnp.PyArray_SETITEM(arr, data_ptr, value)
+
+    util.assign_value_1d(arr, i, value)
 
 cdef class DictIndexEngine(IndexEngine):
     '''
diff --git a/pandas/src/numpy_helper.h b/pandas/src/numpy_helper.h
index 81d3d9443..f5779dd7c 100644
--- a/pandas/src/numpy_helper.h
+++ b/pandas/src/numpy_helper.h
@@ -1,3 +1,4 @@
+#include "Python.h"
 #include "numpy/ndarrayobject.h"
 
 inline int
@@ -7,6 +8,23 @@ is_integer_object(PyObject* obj) {
 
 inline int
 is_float_object(PyObject* obj) {
-  return (PyFloat_Check(obj)
-          || PyObject_TypeCheck(obj, &PyFloatingArrType_Type));
+  return (PyFloat_Check(obj) || PyArray_IsScalar(obj, Floating));
+}
+
+inline int
+is_bool_object(PyObject* obj) {
+  return (PyBool_Check(obj) || PyArray_IsScalar(obj, Bool));
+}
+
+inline int
+is_string_object(PyObject* obj) {
+  return (PyString_Check(obj) || PyUnicode_Check(obj));
+}
+
+inline int
+assign_value_1d(PyArrayObject* ap, Py_ssize_t _i, PyObject* v) {
+  char *item;
+  npy_intp i = (npy_intp) _i;
+  item = PyArray_DATA(ap) + i * PyArray_STRIDE(ap, 0);
+  return PyArray_DESCR(ap)->f->setitem(v, item, ap);
 }
diff --git a/pandas/src/util.pxd b/pandas/src/util.pxd
new file mode 100644
index 000000000..9c42b072e
--- /dev/null
+++ b/pandas/src/util.pxd
@@ -0,0 +1,6 @@
+from numpy cimport ndarray
+
+cdef extern from "numpy_helper.h":
+    inline int is_integer_object(object)
+    inline int is_float_object(object)
+    inline int assign_value_1d (ndarray, Py_ssize_t, object) except -1
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 46a72caeb..87a5a363b 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -12,7 +12,7 @@ from numpy.random import randn
 import numpy as np
 import numpy.ma as ma
 
-import pandas.core.common as common
+import pandas.core.common as com
 import pandas.core.datetools as datetools
 from pandas.core.index import NULL_INDEX
 from pandas.core.api import (DataFrame, Index, Series, notnull, isnull,
@@ -674,12 +674,34 @@ class CheckIndexing(object):
                 self.frame.set_value(idx, col, 1)
                 assert_almost_equal(self.frame[col][idx], 1)
 
+    def test_set_value_resize(self):
+        res = self.frame.set_value('foobar', 'B', 0)
+        self.assert_(res is not self.frame)
+        self.assert_(res.index[-1] == 'foobar')
+        self.assertEqual(res.get_value('foobar', 'B'), 0)
+
+        res2 = res.set_value('foobar', 'qux', 0)
+        self.assert_(res2 is not res)
+        self.assert_(np.array_equal(res2.columns,
+                                    list(self.frame.columns) + ['qux']))
+        self.assertEqual(res2.get_value('foobar', 'qux'), 0)
+
+        res3 = res.set_value('foobar', 'baz', 'sam')
+        self.assert_(res3['baz'].dtype == np.object_)
+
+        res3 = res.set_value('foobar', 'baz', True)
+        self.assert_(res3['baz'].dtype == np.bool_)
+
+        res3 = res.set_value('foobar', 'baz', 5)
+        self.assert_(com.is_integer_dtype(res3['baz']))
+        self.assertRaises(ValueError, res3.set_value, 'foobar', 'baz', 'sam')
+
     def test_get_set_value_no_partial_indexing(self):
         # partial w/ MultiIndex raise exception
         index = MultiIndex.from_tuples([(0, 1), (0, 2), (1, 1), (1, 2)])
         df = DataFrame(index=index, columns=range(4))
         self.assertRaises(KeyError, df.get_value, 0, 1)
-        self.assertRaises(KeyError, df.set_value, 0, 1, 0)
+        # self.assertRaises(KeyError, df.set_value, 0, 1, 0)
 
     def test_single_element_ix_dont_upcast(self):
         self.frame['E'] = 1
@@ -1233,6 +1255,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assert_(df.columns[0] == 'x')
         self.assert_(df.index.equals(a.index))
 
+    def test_constructor_manager_resize(self):
+        index = list(self.frame.index[:5])
+        columns = list(self.frame.columns[:3])
+
+        result = DataFrame(self.frame._data, index=index,
+                           columns=columns)
+        self.assert_(np.array_equal(result.index, index))
+        self.assert_(np.array_equal(result.columns, columns))
+
     def test_astype(self):
         casted = self.frame.astype(int)
         expected = DataFrame(self.frame.values.astype(int),
@@ -1392,25 +1423,25 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                                index=np.arange(50))
         foo = repr(unsortable)
 
-        common.set_printoptions(precision=3, column_space=10)
+        com.set_printoptions(precision=3, column_space=10)
         repr(self.frame)
 
     def test_eng_float_formatter(self):
         self.frame.ix[5] = 0
 
-        common.set_eng_float_format()
+        com.set_eng_float_format()
 
         repr(self.frame)
 
-        common.set_eng_float_format(use_eng_prefix=True)
+        com.set_eng_float_format(use_eng_prefix=True)
 
         repr(self.frame)
 
-        common.set_eng_float_format(precision=0)
+        com.set_eng_float_format(precision=0)
 
         repr(self.frame)
 
-        common.set_printoptions(precision=4)
+        com.set_printoptions(precision=4)
 
     def test_repr_tuples(self):
         buf = StringIO()
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index f44e3c4c7..6bd827ef4 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -135,6 +135,9 @@ class CheckNameIntegration(object):
         result = self.ts.to_sparse()
         self.assertEquals(result.name, self.ts.name)
 
+class SafeForSparse(object):
+    pass
+
 class TestSeries(unittest.TestCase, CheckNameIntegration):
 
     def setUp(self):
@@ -393,6 +396,17 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertRaises(Exception, self.series.__setitem__,
                           'foobar', 1)
 
+    def test_set_value(self):
+        idx = self.ts.index[10]
+        res = self.ts.set_value(idx, 0)
+        self.assert_(res is self.ts)
+        self.assertEqual(self.ts[idx], 0)
+
+        res = self.series.set_value('foobar', 0)
+        self.assert_(res is not self.series)
+        self.assert_(res.index[-1] == 'foobar')
+        self.assertEqual(res['foobar'], 0)
+
     def test_setslice(self):
         sl = self.ts[5:20]
         self.assertEqual(len(sl), len(sl.index))
diff --git a/pandas/tests/test_sparse.py b/pandas/tests/test_sparse.py
index ed0da86eb..7b42b201f 100644
--- a/pandas/tests/test_sparse.py
+++ b/pandas/tests/test_sparse.py
@@ -1272,6 +1272,13 @@ class TestSparsePanel(TestCase,
 
         self.assertRaises(Exception, self.panel.__setitem__, 'item6', 1)
 
+    def test_set_value(self):
+        mjr = self.panel.major_axis[4]
+        mnr = self.panel.minor_axis[3]
+
+        self.assertRaises(Exception, self.panel.set_value, 'ItemA',
+                          )
+
     def test_delitem_pop(self):
         del self.panel['ItemB']
         assert_almost_equal(self.panel.items, ['ItemA', 'ItemC', 'ItemD'])

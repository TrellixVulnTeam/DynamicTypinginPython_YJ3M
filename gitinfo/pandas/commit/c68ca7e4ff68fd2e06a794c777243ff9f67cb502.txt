commit c68ca7e4ff68fd2e06a794c777243ff9f67cb502
Author: Martin Blais <blais@furius.ca>
Date:   Sat Aug 4 20:55:42 2012 -0400

    DataFormatter: Refactored to_string() in order to let the future to_latex() take advantage of it.

diff --git a/pandas/core/format.py b/pandas/core/format.py
index 01b6f3110..f825cf5ea 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -189,63 +189,79 @@ class DataFrameFormatter(object):
         else:
             self.columns = frame.columns
 
-    def to_string(self, force_unicode=False):
+    def _to_str_columns(self, force_unicode=False):
         """
-        Render a DataFrame to a console-friendly tabular output.
+        Render a DataFrame to a list of columns (as lists of strings).
         """
         frame = self.frame
 
-        to_write = []
+        # may include levels names also
+        str_index = self._get_formatted_index()
+        str_columns = self._get_formatted_column_labels()
 
-        if len(frame.columns) == 0 or len(frame.index) == 0:
-            info_line = (u'Empty %s\nColumns: %s\nIndex: %s'
-                         % (type(self.frame).__name__,
-                            frame.columns, frame.index))
-            to_write.append(info_line)
-        else:
-            # may include levels names also
-            str_index = self._get_formatted_index()
-            str_columns = self._get_formatted_column_labels()
-
-            stringified = []
-
-            for i, c in enumerate(self.columns):
-                if self.header:
-                    fmt_values = self._format_col(i)
-                    cheader = str_columns[i]
-                    max_len = max(max(_strlen(x) for x in fmt_values),
-                                  max(len(x) for x in cheader))
-                    if self.justify == 'left':
-                        cheader = [x.ljust(max_len) for x in cheader]
-                    else:
-                        cheader = [x.rjust(max_len) for x in cheader]
-                    fmt_values = cheader + fmt_values
-                    stringified.append(_make_fixed_width(fmt_values,
-                                                         self.justify))
-                else:
-                    stringified = [_make_fixed_width(self._format_col(i),
-                                                     self.justify)
-                                   for i, c in enumerate(self.columns)]
+        stringified = []
 
-            if self.index:
-                to_write.append(adjoin(1, str_index, *stringified))
+        for i, c in enumerate(self.columns):
+            if self.header:
+                fmt_values = self._format_col(i)
+                cheader = str_columns[i]
+                max_len = max(max(_strlen(x) for x in fmt_values),
+                              max(len(x) for x in cheader))
+                if self.justify == 'left':
+                    cheader = [x.ljust(max_len) for x in cheader]
+                else:
+                    cheader = [x.rjust(max_len) for x in cheader]
+                fmt_values = cheader + fmt_values
+                stringified.append(_make_fixed_width(fmt_values,
+                                                     self.justify))
             else:
-                to_write.append(adjoin(1, *stringified))
+                stringified = [_make_fixed_width(self._format_col(i),
+                                                 self.justify)
+                               for i, c in enumerate(self.columns)]
+
+        strcols = stringified
+        if self.index:
+            strcols.insert(0, str_index)
 
         if not py3compat.PY3:
             if force_unicode:
-                to_write = [unicode(s) for s in to_write]
+                strcols = map(lambda col: map(unicode, col), strcols)
             else:
                 # generally everything is plain strings, which has ascii
                 # encoding.  problem is when there is a char with value over 127
                 # - everything then gets converted to unicode.
                 try:
-                    for s in to_write:
-                        str(s)
+                    map(lambda col: map(str, col), strcols)
                 except UnicodeError:
-                    to_write = [unicode(s) for s in to_write]
+                    strcols = map(lambda col: map(unicode, col), strcols)
+
+        return strcols
+
+    def to_string(self, force_unicode=False):
+        """
+        Render a DataFrame to a console-friendly tabular output.
+        """
+        frame = self.frame
+
+        if len(frame.columns) == 0 or len(frame.index) == 0:
+            info_line = (u'Empty %s\nColumns: %s\nIndex: %s'
+                         % (type(self.frame).__name__,
+                            frame.columns, frame.index))
+            text = info_line
+        else:
+            strcols = self._to_str_columns(force_unicode)
+            text = adjoin(1, *strcols)
+            
+        self.buf.writelines(text)
+
+
+
+
+
+
+
+
 
-        self.buf.writelines(to_write)
 
     def _format_col(self, i):
         col = self.columns[i]

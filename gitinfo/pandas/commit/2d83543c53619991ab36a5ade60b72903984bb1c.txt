commit 2d83543c53619991ab36a5ade60b72903984bb1c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Sep 9 16:49:30 2011 -0400

    ENH: skipna in DataFrame stat functions

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 52cd0aa62..8a17ec1ce 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2363,19 +2363,19 @@ class DataFrame(NDFrame):
 
         return DataFrame(result, index=index, columns=columns)
 
-    def sum(self, axis=0, numeric_only=False):
+    def sum(self, axis=0, numeric_only=False, skipna=True):
         """
         Return sum over requested axis
 
-        NA/null values will be treated as 0. If an entire row/column is NA, the
-        result will be NA
-
         Parameters
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
         numeric_only : boolean, default False
             Include only float, int, boolean data
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Examples
         --------
@@ -2403,8 +2403,11 @@ class DataFrame(NDFrame):
             the_sum = y.sum(axis)
         else:
             mask = np.isfinite(y)
-            if not issubclass(y.dtype.type, np.int_):
-                y[-mask] = 0
+
+            if skipna:
+                if not issubclass(y.dtype.type, np.int_):
+                    np.putmask(y, -mask, 0)
+
             the_sum = y.sum(axis)
             the_count = mask.sum(axis)
 
@@ -2414,7 +2417,7 @@ class DataFrame(NDFrame):
 
         return Series(the_sum, index=axis_labels)
 
-    def min(self, axis=0):
+    def min(self, axis=0, skipna=True):
         """
         Return minimum over requested axis. NA/null values are excluded
 
@@ -2422,16 +2425,20 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         min : Series
         """
         values = self.values.copy()
-        np.putmask(values, -np.isfinite(values), np.inf)
+        if skipna:
+            np.putmask(values, -np.isfinite(values), np.inf)
         return Series(values.min(axis), index=self._get_agg_axis(axis))
 
-    def max(self, axis=0):
+    def max(self, axis=0, skipna=True):
         """
         Return maximum over requested axis. NA/null values are excluded
 
@@ -2439,16 +2446,20 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         max : Series
         """
         values = self.values.copy()
-        np.putmask(values, -np.isfinite(values), -np.inf)
+        if skipna:
+            np.putmask(values, -np.isfinite(values), -np.inf)
         return Series(values.max(axis), index=self._get_agg_axis(axis))
 
-    def prod(self, axis=0):
+    def prod(self, axis=0, skipna=True):
         """
         Return product over requested axis. NA/null values are treated as 1
 
@@ -2456,6 +2467,9 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
@@ -2463,20 +2477,22 @@ class DataFrame(NDFrame):
         """
         y = np.array(self.values, subok=True)
         try:
-
-            if not issubclass(y.dtype.type, np.int_):
-                y[np.isnan(y)] = 1
+            if skipna:
+                if not issubclass(y.dtype.type, np.int_):
+                    y[np.isnan(y)] = 1
             theProd = y.prod(axis)
             theCount = self.count(axis)
             theProd[theCount == 0] = nan
         except Exception:
-            theProd = self.apply(np.prod, axis=axis)
+            def wrapper(x):
+                return x.prod(skipna=skipna)
+            theProd = self.apply(wrapper, axis=axis)
 
         return Series(theProd, index=self._get_agg_axis(axis))
 
     product = prod
 
-    def mean(self, axis=0):
+    def mean(self, axis=0, skipna=True):
         """
         Return mean over requested axis. NA/null values are excluded
 
@@ -2484,12 +2500,15 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         mean : Series
         """
-        summed = self.sum(axis, numeric_only=True)
+        summed = self.sum(axis, numeric_only=True, skipna=skipna)
         count = self.count(axis, numeric_only=True).astype(float)
         return summed / count
 
@@ -2524,7 +2543,7 @@ class DataFrame(NDFrame):
 
         return self.apply(f, axis=axis)
 
-    def median(self, axis=0):
+    def median(self, axis=0, skipna=True):
         """
         Return median over requested axis, NA/null are exluded
 
@@ -2532,26 +2551,24 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         Series or TimeSeries
         """
-        def f(arr):
-            if arr.dtype != np.float_:
-                arr = arr.astype(float)
-            return _tseries.median(arr[notnull(arr)])
-
         if axis == 0:
-            med = [f(self[col].values) for col in self.columns]
+            med = [self[col].median(skipna=skipna) for col in self.columns]
             return Series(med, index=self.columns)
         elif axis == 1:
-            med = [f(self.xs(k).values) for k in self.index]
+            med = [self.xs(k).median(skipna=skipna) for k in self.index]
             return Series(med, index=self.index)
         else:
             raise Exception('Must have 0<= axis <= 1')
 
-    def mad(self, axis=0):
+    def mad(self, axis=0, skipna=True):
         """
         Return mean absolute deviation over requested axis
 
@@ -2559,30 +2576,21 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         mad : Series
         """
         if axis == 0:
-            demeaned = self - self.mean(axis=axis)
-        else:
-            demeaned = (self.T - self.mean(axis=axis)).T
-
-        y = np.array(demeaned.values, subok=True)
-
-        # TODO: is this correct?
-        if not issubclass(y.dtype.type, np.int_):
-            y[np.isnan(y)] = 0
-
-        result = np.abs(y).mean(axis=axis)
-
-        if axis == 0:
-            return Series(result, demeaned.columns)
+            demeaned = self - self.mean(axis=0)
         else:
-            return Series(result, demeaned.index)
+            demeaned = self.sub(self.mean(axis=1), axis=0)
+        return np.abs(demeaned).mean(axis=axis, skipna=skipna)
 
-    def var(self, axis=0):
+    def var(self, axis=0, skipna=True):
         """
         Return unbiased variance over requested axis
 
@@ -2590,6 +2598,9 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
@@ -2599,7 +2610,9 @@ class DataFrame(NDFrame):
 
         mask = np.isnan(y)
         count = (y.shape[axis] - mask.sum(axis)).astype(float)
-        y[mask] = 0
+
+        if skipna:
+            np.putmask(y, mask, 0)
 
         X = y.sum(axis)
         XX = (y ** 2).sum(axis)
@@ -2608,7 +2621,7 @@ class DataFrame(NDFrame):
 
         return Series(theVar, index=axis_labels)
 
-    def std(self, axis=0):
+    def std(self, axis=0, skipna=True):
         """
         Return unbiased std deviation over requested axis
 
@@ -2616,14 +2629,17 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
         std : Series
         """
-        return np.sqrt(self.var(axis=axis))
+        return np.sqrt(self.var(axis=axis, skipna=skipna))
 
-    def skew(self, axis=0):
+    def skew(self, axis=0, skipna=True):
         """
         Return unbiased skewness over requested axis
 
@@ -2631,6 +2647,9 @@ class DataFrame(NDFrame):
         ----------
         axis : {0, 1}
             0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
 
         Returns
         -------
@@ -2640,16 +2659,24 @@ class DataFrame(NDFrame):
 
         mask = np.isnan(y)
         count = (y.shape[axis] - mask.sum(axis)).astype(float)
-        y[mask] = 0
+
+        if skipna:
+            np.putmask(y, mask, 0)
 
         A = y.sum(axis) / count
         B = (y ** 2).sum(axis) / count - A ** 2
         C = (y ** 3).sum(axis) / count - A ** 3 - 3 * A * B
 
-        theSkew = ((np.sqrt((count ** 2 - count)) * C) /
-                   ((count - 2) * np.sqrt(B) ** 3))
+        # floating point error
+        B = np.where(np.abs(B) < 1e-14, 0, B)
+        C = np.where(np.abs(C) < 1e-14, 0, C)
+
+        result = ((np.sqrt((count ** 2 - count)) * C) /
+                  ((count - 2) * np.sqrt(B) ** 3))
+
+        result = np.where(B == 0, 0, result)
 
-        return Series(theSkew, index=axis_labels)
+        return Series(result, index=axis_labels)
 
     def _get_agg_data(self, axis, numeric_only=True):
         num_cols = self._get_numeric_columns()
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index c420563d7..898ca4694 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -839,7 +839,10 @@ class DataFrameGroupBy(GroupBy):
             result = DataFrame(result)
         else:
             if len(self.groupings) > 1:
-                return self._python_agg_general(arg, *args, **kwargs)
+                try:
+                    return self._python_agg_general(arg, *args, **kwargs)
+                except Exception:
+                    return self._aggregate_item_by_item(arg, *args, **kwargs)
             result = self._aggregate_generic(arg, *args, **kwargs)
 
         return result
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 297eab784..41692ebec 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -518,13 +518,13 @@ copy : boolean, default False
 
         return Series(result, index=level_index)
 
-    def sum(self, axis=0, dtype=None, out=None, omitna=True):
+    def sum(self, axis=0, dtype=None, out=None, skipna=True):
         """
         Sum of values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -533,7 +533,7 @@ copy : boolean, default False
         """
         values = self.values.copy()
 
-        if omitna:
+        if skipna:
             mask = isnull(values)
             if mask.all():
                 return np.nan
@@ -541,28 +541,28 @@ copy : boolean, default False
 
         return values.sum()
 
-    def mean(self, axis=0, dtype=None, out=None, omitna=True):
+    def mean(self, axis=0, dtype=None, out=None, skipna=True):
         """
         Mean of values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
         -------
         mean : float
         """
-        return self._ndarray_statistic('mean', dtype=dtype, omitna=omitna)
+        return self._ndarray_statistic('mean', dtype=dtype, skipna=skipna)
 
-    def median(self, omitna=True):
+    def median(self, skipna=True):
         """
         Compute median of values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -574,7 +574,7 @@ copy : boolean, default False
             arr = arr.astype(float)
         mask = notnull(arr)
 
-        if omitna:
+        if skipna:
             arr = arr[mask]
         else:
             if not mask.all():
@@ -582,28 +582,28 @@ copy : boolean, default False
 
         return _tseries.median(arr)
 
-    def prod(self, axis=0, dtype=None, out=None, omitna=True):
+    def prod(self, axis=0, dtype=None, out=None, skipna=True):
         """
         Product of all values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
         -------
         product : float
         """
-        return self._ndarray_statistic('prod', dtype=dtype, omitna=omitna)
+        return self._ndarray_statistic('prod', dtype=dtype, skipna=skipna)
 
-    def min(self, axis=None, out=None, omitna=True):
+    def min(self, axis=None, out=None, skipna=True):
         """
         Minimum of values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -611,18 +611,18 @@ copy : boolean, default False
         min : float
         """
         arr = self.values.copy()
-        if omitna:
+        if skipna:
             if not issubclass(arr.dtype.type, np.int_):
                 np.putmask(arr, isnull(arr), np.inf)
         return arr.min()
 
-    def max(self, axis=None, out=None, omitna=True):
+    def max(self, axis=None, out=None, skipna=True):
         """
         Maximum of values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -630,12 +630,12 @@ copy : boolean, default False
         max : float
         """
         arr = self.values.copy()
-        if omitna:
+        if skipna:
             if not issubclass(arr.dtype.type, np.int_):
                 np.putmask(arr, isnull(arr), -np.inf)
         return arr.max()
 
-    def std(self, axis=None, dtype=None, out=None, ddof=1, omitna=True):
+    def std(self, axis=None, dtype=None, out=None, ddof=1, skipna=True):
         """
         Unbiased standard deviation of values
 
@@ -643,14 +643,14 @@ copy : boolean, default False
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
         -------
         stdev : float
         """
-        if omitna:
+        if skipna:
             nona = remove_na(self.values)
             if len(nona) < 2:
                 return nan
@@ -658,7 +658,7 @@ copy : boolean, default False
         else:
             return self.values.std(axis, dtype, out, ddof)
 
-    def var(self, axis=None, dtype=None, out=None, ddof=1, omitna=True):
+    def var(self, axis=None, dtype=None, out=None, ddof=1, skipna=True):
         """
         Unbiased variance of non-NA/null values
 
@@ -666,14 +666,14 @@ copy : boolean, default False
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
         -------
         var : float
         """
-        if omitna:
+        if skipna:
             nona = remove_na(self.values)
             if len(nona) < 2:
                 return nan
@@ -681,13 +681,13 @@ copy : boolean, default False
         else:
             return self.values.var(axis, dtype, out, ddof)
 
-    def skew(self, omitna=True):
+    def skew(self, skipna=True):
         """
         Unbiased skewness of the non-NA/null values
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -698,7 +698,7 @@ copy : boolean, default False
         mask = notnull(y)
         count = mask.sum()
 
-        if count < len(self) and not omitna:
+        if count < len(self) and not skipna:
             return np.nan
 
         np.putmask(y, -mask, 0)
@@ -708,7 +708,7 @@ copy : boolean, default False
 
         return (np.sqrt((count**2-count))*C) / ((count-2)*np.sqrt(B)**3)
 
-    def cumsum(self, axis=0, dtype=None, out=None, omitna=True):
+    def cumsum(self, axis=0, dtype=None, out=None, skipna=True):
         """
         Cumulative sum of values. Preserves locations of NaN values
 
@@ -716,7 +716,7 @@ copy : boolean, default False
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -725,7 +725,7 @@ copy : boolean, default False
         """
         arr = self.values.copy()
 
-        do_mask = omitna and not issubclass(self.dtype.type, np.int_)
+        do_mask = skipna and not issubclass(self.dtype.type, np.int_)
         if do_mask:
             mask = isnull(arr)
             np.putmask(arr, mask, 0.)
@@ -737,7 +737,7 @@ copy : boolean, default False
 
         return Series(result, index=self.index)
 
-    def cumprod(self, axis=0, dtype=None, out=None, omitna=True):
+    def cumprod(self, axis=0, dtype=None, out=None, skipna=True):
         """
         Cumulative product of values. Preserves locations of NaN values
 
@@ -745,7 +745,7 @@ copy : boolean, default False
 
         Parameters
         ----------
-        omitna : boolean, default True
+        skipna : boolean, default True
             Exclude NA/null values
 
         Returns
@@ -754,7 +754,7 @@ copy : boolean, default False
         """
         arr = self.values.copy()
 
-        do_mask = omitna and not issubclass(self.dtype.type, np.int_)
+        do_mask = skipna and not issubclass(self.dtype.type, np.int_)
         if do_mask:
             mask = isnull(arr)
             np.putmask(arr, mask, 1.)
@@ -766,11 +766,11 @@ copy : boolean, default False
 
         return Series(result, index=self.index)
 
-    def _ndarray_statistic(self, funcname, dtype=None, omitna=True):
+    def _ndarray_statistic(self, funcname, dtype=None, skipna=True):
         arr = self.values
         retVal = getattr(arr, funcname)(dtype=dtype)
 
-        if omitna and isnull(retVal):
+        if skipna and isnull(retVal):
             arr = remove_na(arr)
             if len(arr) == 0:
                 return np.nan
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 0ccccece6..65af36a0e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2340,22 +2340,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         for col, series in self.frame.iteritems():
             self.assertEqual(sumFrame[col], series.sum())
 
-    def _check_statistic(self, frame, name, alternative):
-        f = getattr(frame, name)
-
-        result = f(axis=0)
-        assert_series_equal(result, frame.apply(alternative))
-
-        result = f(axis=1)
-        comp = frame.apply(alternative, axis=1).reindex(result.index)
-        assert_series_equal(result, comp)
-
-        self.assertRaises(Exception, f, axis=2)
-
     def test_count(self):
         f = lambda s: notnull(s).sum()
-
-        self._check_statistic(self.frame, 'count', f)
+        self._check_stat_op('count', f, has_skipna=False)
 
         # corner case
 
@@ -2367,11 +2354,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(isinstance(ct2, Series))
 
     def test_sum(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].sum()
-
-        self._check_statistic(self.frame, 'sum', f)
+        self._check_stat_op('sum', np.sum)
 
         axis0 = self.empty.sum(0)
         axis1 = self.empty.sum(1)
@@ -2394,18 +2377,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         bools.sum(0)
 
     def test_product(self):
-        def f(x):
-            x = np.asarray(x)
-            return np.prod(x[notnull(x)])
-
-        self._check_statistic(self.frame, 'product', f)
+        self._check_stat_op('product', np.prod)
 
     def test_mean(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].mean()
-
-        self._check_statistic(self.frame, 'mean', f)
+        self._check_stat_op('mean', np.mean)
 
         # unit test when have object data
         the_mean = self.mixed_frame.mean(axis=0)
@@ -2431,57 +2406,79 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.mixed_frame.skew(1)
 
     def test_median(self):
-        def f(x):
-            x = np.asarray(x)
-            return np.median(x[notnull(x)])
+        def wrapper(x):
+            if isnull(x).any():
+                return np.nan
+            return np.median(x)
 
-        self._check_statistic(self.intframe, 'median', f)
-        self._check_statistic(self.frame, 'median', f)
+        self._check_stat_op('median', wrapper, frame=self.intframe)
+        self._check_stat_op('median', wrapper)
 
     def test_min(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].min()
-
-        self._check_statistic(self.frame, 'min', f)
+        self._check_stat_op('min', np.min)
 
     def test_max(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].max()
-
-        self._check_statistic(self.frame, 'max', f)
+        self._check_stat_op('max', np.max)
 
     def test_mad(self):
         f = lambda x: np.abs(x - x.mean()).mean()
-
-        self._check_statistic(self.frame, 'mad', f)
+        self._check_stat_op('mad', f)
 
     def test_var(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].var(ddof=1)
-
-        self._check_statistic(self.frame, 'var', f)
+        alt = lambda x: np.var(x, ddof=1)
+        self._check_stat_op('var', alt)
 
     def test_std(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].std(ddof=1)
-
-        self._check_statistic(self.frame, 'std', f)
+        alt = lambda x: np.std(x, ddof=1)
+        self._check_stat_op('std', alt)
 
     def test_skew(self):
-        try:
-            from scipy.stats import skew
-        except ImportError:
-            return
+        from scipy.stats import skew
 
-        def f(x):
-            x = np.asarray(x)
-            return skew(x[notnull(x)], bias=False)
+        def alt(x):
+            if len(x) < 3:
+                return np.nan
+            return skew(x, bias=False)
 
-        self._check_statistic(self.frame, 'skew', f)
+        self._check_stat_op('skew', alt)
+
+    def _check_stat_op(self, name, alternative, frame=None, has_skipna=True):
+        if frame is None:
+            frame = self.frame
+            # set some NAs
+            frame.ix[5:10] = np.nan
+            frame.ix[15:20, -2:] = np.nan
+
+        f = getattr(frame, name)
+
+        if has_skipna:
+            def skipna_wrapper(x):
+                nona = x.dropna().values
+                if len(nona) == 0:
+                    return np.nan
+                return alternative(nona)
+
+            def wrapper(x):
+                return alternative(x.values)
+
+            result0 = f(axis=0, skipna=False)
+            result1 = f(axis=1, skipna=False)
+            assert_series_equal(result0, frame.apply(wrapper))
+            assert_series_equal(result1, frame.apply(wrapper, axis=1))
+        else:
+            skipna_wrapper = alternative
+            wrapper = alternative
+
+        result0 = f(axis=0)
+        result1 = f(axis=1)
+        assert_series_equal(result0, frame.apply(skipna_wrapper))
+        assert_series_equal(result1, frame.apply(skipna_wrapper, axis=1))
+
+        # result = f(axis=1)
+        # comp = frame.apply(alternative, axis=1).reindex(result.index)
+        # assert_series_equal(result, comp)
+
+        self.assertRaises(Exception, f, axis=2)
 
     def test_quantile(self):
         try:
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index cdccade85..97c61dc7f 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -413,9 +413,9 @@ class TestSeries(unittest.TestCase):
         # add some NaNs
         self.series[5:15] = np.NaN
 
-        # omitna or no
+        # skipna or no
         self.assert_(notnull(f(self.series)))
-        self.assert_(isnull(f(self.series, omitna=False)))
+        self.assert_(isnull(f(self.series, skipna=False)))
 
         # check the result is correct
         nona = self.series.dropna()

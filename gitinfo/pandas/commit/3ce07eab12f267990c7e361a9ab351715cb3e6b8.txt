commit 3ce07eab12f267990c7e361a9ab351715cb3e6b8
Author: Junya Hayashi <junya_hayashi@xica.net>
Date:   Tue Jan 20 03:08:01 2015 +0900

    ENH: Refactor groupby for Categorical grouper

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index fcaa5ad26..29bdbe938 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1862,7 +1862,6 @@ class Grouping(object):
             self.grouper = grouper.values
 
         # pre-computed
-        self._grouping_type = None
         self._should_compress = True
 
         # we have a single grouper which may be a myriad of things, some of which are
@@ -1887,8 +1886,6 @@ class Grouping(object):
                 level_values = index.levels[level].take(inds)
                 self.grouper = level_values.map(self.grouper)
             else:
-                self._grouping_type = "level"
-
                 # all levels may not be observed
                 labels, uniques = algos.factorize(inds, sort=True)
 
@@ -1913,17 +1910,10 @@ class Grouping(object):
 
             # a passed Categorical
             elif isinstance(self.grouper, Categorical):
-
-                factor = self.grouper
-                self._grouping_type = "categorical"
-
-                # Is there any way to avoid this?
-                self.grouper = np.asarray(factor)
-
-                self._labels = factor.codes
-                self._group_index = factor.categories
+                self._labels = self.grouper.codes
+                self._group_index = self.grouper.categories
                 if self.name is None:
-                    self.name = factor.name
+                    self.name = self.grouper.name
 
             # a passed Grouper like
             elif isinstance(self.grouper, Grouper):
@@ -1936,8 +1926,8 @@ class Grouping(object):
                     self.name = grouper.name
 
             # no level passed
-            if not isinstance(self.grouper, (Series, Index, np.ndarray)):
-                if getattr(self.grouper,'ndim', 1) != 1:
+            if not isinstance(self.grouper, (Series, Index, Categorical, np.ndarray)):
+                if getattr(self.grouper, 'ndim', 1) != 1:
                     t = self.name or str(type(self.grouper))
                     raise ValueError("Grouper for '%s' not 1-dimensional" % t)
                 self.grouper = self.index.map(self.grouper)
@@ -1988,22 +1978,15 @@ class Grouping(object):
         return self._group_index
 
     def _make_labels(self):
-        if self._grouping_type in ("level", "categorical"):  # pragma: no cover
-            raise Exception(
-                'Should not call this method grouping by level or categorical')
-        else:
+        if self._labels is None or self._group_index is None:
             labels, uniques = algos.factorize(self.grouper, sort=self.sort)
             uniques = Index(uniques, name=self.name)
             self._labels = labels
             self._group_index = uniques
 
-    _groups = None
-
-    @property
+    @cache_readonly
     def groups(self):
-        if self._groups is None:
-            self._groups = self.index.groupby(self.grouper)
-        return self._groups
+        return self.index.groupby(self.grouper)
 
 def _get_grouper(obj, key=None, axis=0, level=None, sort=True):
     """
@@ -3239,7 +3222,7 @@ class DataFrameGroupBy(NDFrameGroupBy):
             return result
         elif len(groupings) == 1:
             return result
-        elif not any([ping._grouping_type == "categorical"
+        elif not any([isinstance(ping.grouper, Categorical)
                       for ping in groupings]):
             return result
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 8803a96fd..1d309e2a6 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -3297,6 +3297,34 @@ class TestGroupBy(tm.TestCase):
         expected.index.names = ['myfactor', None]
         assert_frame_equal(desc_result, expected)
 
+    def test_groupby_datetime_categorical(self):
+        # GH9049: ensure backward compatibility
+        levels = pd.date_range('2014-01-01', periods=4)
+        codes = np.random.randint(0, 4, size=100)
+
+        cats = Categorical.from_codes(codes, levels, name='myfactor')
+
+        data = DataFrame(np.random.randn(100, 4))
+
+        result = data.groupby(cats).mean()
+
+        expected = data.groupby(np.asarray(cats)).mean()
+        expected = expected.reindex(levels)
+        expected.index.name = 'myfactor'
+
+        assert_frame_equal(result, expected)
+        self.assertEqual(result.index.name, cats.name)
+
+        grouped = data.groupby(cats)
+        desc_result = grouped.describe()
+
+        idx = cats.codes.argsort()
+        ord_labels = np.asarray(cats).take(idx)
+        ord_data = data.take(idx)
+        expected = ord_data.groupby(ord_labels, sort=False).describe()
+        expected.index.names = ['myfactor', None]
+        assert_frame_equal(desc_result, expected)
+
     def test_groupby_groups_datetimeindex(self):
         # #1430
         from pandas.tseries.api import DatetimeIndex

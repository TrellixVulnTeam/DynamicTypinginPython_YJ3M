commit ff99fdc4b1c06510d8445277548b1f787f7d3f93
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Oct 7 15:49:41 2011 -0400

    ENH: beginning name integration in Index, Series

diff --git a/RELEASE.rst b/RELEASE.rst
index b2adbba5e..c02683908 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -26,7 +26,7 @@ pandas 0.4.3
   - Fix regression from 0.4.1, `isnull` and `notnull` ceased to work on other
     kinds of Python scalar objects like `datetime.datetime`
   - Raise more helpful exception when attempting to write empty DataFrame or
-    LongPanel to `HDFStore`
+    LongPanel to `HDFStore` (GH #204)
 
 pandas 0.4.2
 ============
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 8d3e1d51a..e7f502228 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -46,7 +46,7 @@ class DateRange(Index):
     _cache = {}
     def __new__(cls, start=None, end=None, periods=None,
                 offset=datetools.bday, time_rule=None,
-                tzinfo=None, **kwds):
+                tzinfo=None, name=None, **kwds):
 
         time_rule = kwds.get('timeRule', time_rule)
         if time_rule is not None:
@@ -73,7 +73,8 @@ class DateRange(Index):
 
         if useCache:
             index = cls._cached_range(start, end, periods=periods,
-                                      offset=offset, time_rule=time_rule)
+                                      offset=offset, time_rule=time_rule,
+                                      name=name)
             if tzinfo is None:
                 return index
         else:
@@ -86,6 +87,7 @@ class DateRange(Index):
 
         index = np.array(index, dtype=object, copy=False)
         index = index.view(cls)
+        index.name = name
         index.offset = offset
         index.tzinfo = tzinfo
         return index
@@ -126,7 +128,7 @@ class DateRange(Index):
 
     @classmethod
     def _cached_range(cls, start=None, end=None, periods=None, offset=None,
-                      time_rule=None):
+                      time_rule=None, name=None):
 
         # HACK: fix this dependency later
         if time_rule is not None:
@@ -142,6 +144,7 @@ class DateRange(Index):
             cachedRange = arr.view(DateRange)
             cachedRange.offset = offset
             cachedRange.tzinfo = None
+            cachedRange.name = None
             cls._cache[offset] = cachedRange
         else:
             cachedRange = cls._cache[offset]
@@ -175,7 +178,7 @@ class DateRange(Index):
             endLoc = cachedRange.indexMap[end] + 1
 
         indexSlice = cachedRange[startLoc:endLoc]
-
+        indexSlice.name = name
         return indexSlice
 
     def __array_finalize__(self, obj):
@@ -207,9 +210,10 @@ class DateRange(Index):
                 new_index.offset = self.offset
 
             new_index.tzinfo = self.tzinfo
+            new_index.name = self.name
             return new_index
         else:
-            return Index(result)
+            return Index(result, name=self.name)
 
     def summary(self):
         if len(self) > 0:
@@ -256,7 +260,7 @@ class DateRange(Index):
 
         start = self[0] + n * self.offset
         end = self[-1] + n * self.offset
-        return DateRange(start, end, offset=self.offset)
+        return DateRange(start, end, offset=self.offset, name=self.name)
 
     def union(self, other):
         """
@@ -347,6 +351,7 @@ class DateRange(Index):
         result = ndarray.view(DateRange)
         result.offset = self.offset
         result.tzinfo = self.tzinfo
+        result.name = self.name
         return result
 
     def _wrap_union_result(self, other, result):
@@ -364,6 +369,7 @@ class DateRange(Index):
         new_dates = new_dates.view(DateRange)
         new_dates.offset = self.offset
         new_dates.tzinfo = tz
+        new_dates.name = self.name
         return new_dates
 
     def tz_localize(self, tz):
@@ -378,6 +384,7 @@ class DateRange(Index):
         new_dates = new_dates.view(DateRange)
         new_dates.offset = self.offset
         new_dates.tzinfo = tz
+        new_dates.name = self.name
         return new_dates
 
     def tz_validate(self):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index c490332bd..3fe88a599 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -40,11 +40,10 @@ class Index(np.ndarray):
     ----
     An Index instance can **only** contain hashable objects
     """
-    def __new__(cls, data, dtype=None, copy=False):
+    def __new__(cls, data, dtype=None, copy=False, name=None):
         if isinstance(data, np.ndarray):
             if dtype is None and issubclass(data.dtype.type, np.integer):
-                subarr = data.astype(np.int64)
-                return subarr.view(Int64Index)
+                return Int64Index(data, copy=copy, name=self.name)
             subarr = np.array(data, dtype=object, copy=copy)
         elif np.isscalar(data):
             raise ValueError('Index(...) must be called with a collection '
@@ -55,7 +54,13 @@ class Index(np.ndarray):
                 data = list(data)
             subarr = np.empty(len(data), dtype=object)
             subarr[:] = data
-        return subarr.view(cls)
+
+        subarr = subarr.view(cls)
+        subarr.name = name
+        return subarr
+
+    def __array_finalize__(self, obj):
+        self.name = getattr(obj, 'name', None)
 
     @property
     def dtype(self):
@@ -134,7 +139,7 @@ class Index(np.ndarray):
             if _is_bool_indexer(key):
                 key = np.asarray(key)
 
-            return Index(arr_idx[key])
+            return Index(arr_idx[key], name=self.name)
 
     def append(self, other):
         """
@@ -159,7 +164,7 @@ class Index(np.ndarray):
         Analogous to ndarray.take
         """
         taken = self.view(np.ndarray).take(*args, **kwargs)
-        return Index(taken)
+        return Index(taken, name=self.name)
 
     def format(self, vertical=False):
         """
@@ -561,7 +566,7 @@ class Index(np.ndarray):
 
 class Int64Index(Index):
 
-    def __new__(cls, data, dtype=None, copy=False):
+    def __new__(cls, data, dtype=None, copy=False, name=None):
         if not isinstance(data, np.ndarray):
             if np.isscalar(data):
                 raise ValueError('Index(...) must be called with a collection '
@@ -584,7 +589,9 @@ class Int64Index(Index):
                     raise TypeError('Unsafe NumPy casting, you must explicitly '
                                     'cast')
 
-        return subarr.view(cls)
+        subarr = subarr.view(cls)
+        subarr.name = name
+        return subarr
 
     def astype(self, dtype):
         return Index(self.values.astype(dtype))
@@ -788,6 +795,18 @@ class MultiIndex(Index):
         Integers for each level designating which label at each location
     """
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
+        assert(len(levels) == len(labels))
+        if len(levels) == 0:
+            raise Exception('Must pass non-zero number of levels/labels')
+
+        if len(levels) == 1:
+            if names:
+                name = names[0]
+            else:
+                name = None
+
+            return Index(levels[0], name=name).take(labels[0])
+
         return np.arange(len(labels[0]), dtype=object).view(cls)
 
     def __init__(self, levels, labels, sortorder=None, names=None,
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 5ec8f82e5..98b6040a5 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -568,6 +568,14 @@ class TestMultiIndex(unittest.TestCase):
         self.index = MultiIndex(levels=[major_axis, minor_axis],
                                 labels=[major_labels, minor_labels])
 
+    def test_constructor_single_level(self):
+        single_level = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux']],
+                                  labels=[[0, 1, 2, 3]],
+                                  names=['first'])
+        self.assert_(isinstance(single_level, Index))
+        self.assert_(not isinstance(single_level, MultiIndex))
+        self.assert_(single_level.name == 'first')
+
     def test_from_arrays(self):
         arrays = []
         for lev, lab in zip(self.index.levels, self.index.labels):
@@ -822,7 +830,6 @@ class TestMultiIndex(unittest.TestCase):
         index = MultiIndex(levels=self.index.levels[:-1],
                            labels=self.index.labels[:-1])
         self.assert_(not self.index.equals(index))
-        self.assert_(not self.index.equal_levels(index))
 
         # levels are different
         major_axis = Index(range(4))
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 7331b4e72..afe2fc29a 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -29,6 +29,10 @@ class TestMultiLevel(unittest.TestCase):
         self.frame = DataFrame(np.random.randn(10, 3), index=index,
                                columns=['A', 'B', 'C'])
 
+        self.single_level = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux']],
+                                       labels=[[0, 1, 2, 3]],
+                                       names=['first'])
+
         tm.N = 100
         self.tdf = tm.makeTimeDataFrame()
         self.ymd = self.tdf.groupby([lambda x: x.year, lambda x: x.month,
@@ -154,6 +158,12 @@ class TestMultiLevel(unittest.TestCase):
         expected = ft.xs('B')['foo']
         assert_series_equal(result, expected)
 
+    def test_get_loc_single_level(self):
+        s = Series(np.random.randn(len(self.single_level)),
+                   index=self.single_level)
+        for k in self.single_level.values:
+            s[k]
+
     def test_getitem_toplevel(self):
         df = self.frame.T
 

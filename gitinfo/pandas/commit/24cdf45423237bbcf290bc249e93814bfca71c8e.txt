commit 24cdf45423237bbcf290bc249e93814bfca71c8e
Author: Varun <k.varun@outlook.com>
Date:   Wed Nov 18 22:25:12 2015 -0500

    BUG: #11638 return correct dtype for int and float

diff --git a/doc/source/whatsnew/v0.17.1.txt b/doc/source/whatsnew/v0.17.1.txt
index ed3710709..9691e46e9 100755
--- a/doc/source/whatsnew/v0.17.1.txt
+++ b/doc/source/whatsnew/v0.17.1.txt
@@ -168,6 +168,7 @@ Bug Fixes
 - Bug in ``DataFrame.pct_change()`` not propagating ``axis`` keyword on ``.fillna`` method (:issue:`11150`)
 - Bug in ``.to_csv()`` when a mix of integer and string column names are passed as the ``columns`` parameter (:issue:`11637`)
 - Bug in indexing with a ``range``, (:issue:`11652`)
+- Bug in inference of numpy scalars and preserving dtype when setting columns (:issue:`11638`)
 - Bug in ``to_sql`` using unicode column names giving UnicodeEncodeError with (:issue:`11431`).
 - Fix regression in setting of ``xticks`` in ``plot`` (:issue:`11529`).
 - Bug in ``holiday.dates`` where observance rules could not be applied to holiday and doc enhancement (:issue:`11477`, :issue:`11533`)
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 4490aaf58..d8e21e8a7 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -1002,8 +1002,7 @@ def _infer_fill_value(val):
 
 
 def _infer_dtype_from_scalar(val):
-    """ interpret the dtype from a scalar, upcast floats and ints
-        return the new value and the dtype """
+    """ interpret the dtype from a scalar """
 
     dtype = np.object_
 
@@ -1037,12 +1036,17 @@ def _infer_dtype_from_scalar(val):
     elif is_bool(val):
         dtype = np.bool_
 
-    # provide implicity upcast on scalars
     elif is_integer(val):
-        dtype = np.int64
+        if isinstance(val, int):
+            dtype = np.int64
+        else:
+            dtype = type(val)
 
     elif is_float(val):
-        dtype = np.float64
+        if isinstance(val, float):
+            dtype = np.float64
+        else:
+            dtype = type(val)
 
     elif is_complex(val):
         dtype = np.complex_
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 89826209f..a26884287 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -98,6 +98,62 @@ class TestABCClasses(tm.TestCase):
         self.assertIsInstance(pd.Period('2012', freq='A-DEC'), com.ABCPeriod)
 
 
+class TestInferDtype(tm.TestCase):
+
+    def test_infer_dtype_from_scalar(self):
+        # Test that _infer_dtype_from_scalar is returning correct dtype for int and float.
+
+        for dtypec in [ np.uint8, np.int8,
+                        np.uint16, np.int16,
+                        np.uint32, np.int32,
+                        np.uint64, np.int64 ]:
+            data = dtypec(12)
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, dtypec)
+
+        data = 12
+        dtype, val = com._infer_dtype_from_scalar(data)
+        self.assertEqual(dtype, np.int64)
+
+        for dtypec in [ np.float16, np.float32, np.float64 ]:
+            data = dtypec(12)
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, dtypec)
+
+        data = np.float(12)
+        dtype, val = com._infer_dtype_from_scalar(data)
+        self.assertEqual(dtype, np.float64)
+
+        for data in [ True, False ]:
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, np.bool_)
+
+        for data in [ np.complex64(1), np.complex128(1) ]:
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, np.complex_)
+
+        import datetime
+        for data in [ np.datetime64(1,'ns'),
+                      pd.Timestamp(1),
+                      datetime.datetime(2000,1,1,0,0)
+                      ]:
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, 'M8[ns]')
+
+        for data in [ np.timedelta64(1,'ns'),
+                      pd.Timedelta(1),
+                      datetime.timedelta(1)
+                      ]:
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, 'm8[ns]')
+
+        for data in [ datetime.date(2000,1,1),
+                      pd.Timestamp(1,tz='US/Eastern'),
+                      'foo'
+                      ]:
+            dtype, val = com._infer_dtype_from_scalar(data)
+            self.assertEqual(dtype, np.object_)
+
 def test_notnull():
     assert notnull(1.)
     assert not notnull(None)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index c7ee06aee..0f6c6f0a6 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -683,6 +683,13 @@ class CheckIndexing(object):
         expected = Series({'float64' : 3, 'object' : 1 }).sort_values()
         assert_series_equal(result, expected)
 
+        # Test that data type is preserved . #5782
+        df = DataFrame({'one': np.arange(6, dtype=np.int8)})
+        df.loc[1, 'one'] = 6
+        self.assertEqual(df.dtypes.one, np.dtype(np.int8))
+        df.one = np.int8(7)
+        self.assertEqual(df.dtypes.one, np.dtype(np.int8))
+
     def test_setitem_boolean_column(self):
         expected = self.frame.copy()
         mask = self.frame['A'] > 0

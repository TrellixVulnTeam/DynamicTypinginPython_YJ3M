commit f76d3070e2d7746f730349a453353793da15379c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Dec 28 23:42:03 2011 -0500

    BUG: use Cython grouper for Series, bugfix for NA group handling

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a856292df..ddb75254a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1190,8 +1190,8 @@ class DataFrame(NDFrame):
         This allows simpler access to columns for interactive use."""
         if name in self.columns:
             return self[name]
-        raise AttributeError("'%s' object has no attribute '%s'" % \
-                                                    (type(self).__name__, name))
+        raise AttributeError("'%s' object has no attribute '%s'" %
+                             (type(self).__name__, name))
 
     def __setitem__(self, key, value):
         # support boolean setting with DataFrame input, e.g.
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 02523d2f9..d99ee24d4 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -155,13 +155,11 @@ class GroupBy(object):
     def _agg_stride_shape(self):
         raise NotImplementedError
 
-    def __getattribute__(self, attr):
-        try:
-            return object.__getattribute__(self, attr)
-        except AttributeError:
-            if hasattr(self.obj, attr):
-                return self._make_wrapper(attr)
-            raise
+    def __getattr__(self, attr):
+        if hasattr(self.obj, attr):
+            return self._make_wrapper(attr)
+        raise AttributeError("'%s' object has no attribute '%s'" %
+                             (type(self).__name__, attr))
 
     def _make_wrapper(self, name):
         f = getattr(self.obj, name)
@@ -412,24 +410,10 @@ class GroupBy(object):
 
     def _aggregate_series(self, obj, func, group_index, ngroups):
         try:
-            return self._aggregate_series_fast(obj, func, group_index, ngroups)
+            return _aggregate_series_fast(obj, func, group_index, ngroups)
         except Exception:
             return self._aggregate_series_pure_python(obj, func, ngroups)
 
-    def _aggregate_series_fast(self, obj, func, group_index, ngroups):
-        if obj.index._has_complex_internals:
-            raise TypeError('Incompatible index for Cython grouper')
-
-        # avoids object / Series creation overhead
-        dummy = obj[:0]
-        indexer = lib.groupsort_indexer(group_index, ngroups)
-        obj = obj.take(indexer)
-        group_index = group_index.take(indexer)
-        grouper = lib.SeriesGrouper(obj, func, group_index, ngroups,
-                                    dummy)
-        result, counts = grouper.get_result()
-        return result, counts
-
     def _aggregate_series_pure_python(self, obj, func, ngroups):
         counts = np.zeros(ngroups, dtype=int)
         result = np.empty(ngroups, dtype=float)
@@ -743,7 +727,7 @@ class SeriesGroupBy(GroupBy):
                 return self._python_agg_general(func_or_funcs, *args, **kwargs)
 
             try:
-                result = self._aggregate_simple(func_or_funcs, *args, **kwargs)
+                return self._python_agg_general(func_or_funcs, *args, **kwargs)
             except Exception:
                 result = self._aggregate_named(func_or_funcs, *args, **kwargs)
 
@@ -755,6 +739,17 @@ class SeriesGroupBy(GroupBy):
 
         return ret
 
+    def _aggregate_multiple_funcs(self, arg):
+        if not isinstance(arg, dict):
+            arg = dict((func.__name__, func) for func in arg)
+
+        results = {}
+
+        for name, func in arg.iteritems():
+            results[name] = self.aggregate(func)
+
+        return DataFrame(results)
+
     def _wrap_aggregated_output(self, output, mask):
         if isinstance(output, dict):
             # sort of a kludge
@@ -795,28 +790,6 @@ class SeriesGroupBy(GroupBy):
         else:
             return Series(values, index=_get_index())
 
-    def _aggregate_multiple_funcs(self, arg):
-        if not isinstance(arg, dict):
-            arg = dict((func.__name__, func) for func in arg)
-
-        results = {}
-
-        for name, func in arg.iteritems():
-            results[name] = self.aggregate(func)
-
-        return DataFrame(results)
-
-    def _aggregate_simple(self, func, *args, **kwargs):
-        values = self.obj.values
-        result = {}
-        for k, v in self.primary.indices.iteritems():
-            agged = func(values.take(v), *args, **kwargs)
-            if isinstance(agged, np.ndarray):
-                raise Exception('Must produce aggregated value')
-            result[k] = agged
-
-        return result
-
     def _aggregate_named(self, func, *args, **kwargs):
         result = {}
 
@@ -1383,6 +1356,22 @@ def get_group_index(label_list, shape):
     np.putmask(group_index, mask, -1)
     return group_index
 
+
+def _aggregate_series_fast(obj, func, group_index, ngroups):
+    if obj.index._has_complex_internals:
+        raise TypeError('Incompatible index for Cython grouper')
+
+    # avoids object / Series creation overhead
+    dummy = obj[:0]
+    indexer = lib.groupsort_indexer(group_index, ngroups)
+    obj = obj.take(indexer)
+    group_index = group_index.take(indexer)
+    grouper = lib.SeriesGrouper(obj, func, group_index, ngroups,
+                                dummy)
+    result, counts = grouper.get_result()
+    return result, counts
+
+
 #----------------------------------------------------------------------
 # Group aggregations in Cython
 
diff --git a/pandas/src/reduce.pyx b/pandas/src/reduce.pyx
index 201068f93..2ade59a72 100644
--- a/pandas/src/reduce.pyx
+++ b/pandas/src/reduce.pyx
@@ -147,6 +147,10 @@ cdef class SeriesGrouper:
                 lab = labels[i]
 
                 if i == n - 1 or lab != labels[i + 1]:
+                    if lab == -1:
+                        group_size = 0
+                        continue
+
                     islider.set_length(group_size)
                     vslider.set_length(group_size)
 
diff --git a/vb_suite/groupby.py b/vb_suite/groupby.py
index 8c4574dbd..7af41c9a7 100644
--- a/vb_suite/groupby.py
+++ b/vb_suite/groupby.py
@@ -5,7 +5,6 @@ common_setup = """from pandas_vb_common import *
 """
 
 setup = common_setup + """
-
 N = 100000
 ngroups = 100
 
@@ -39,3 +38,7 @@ groupby_multi_cython = Benchmark(stmt3, setup,
                                  name="groupby_multi_cython",
                                  start_date=datetime(2011, 7, 1))
 
+stmt = "df.groupby(['key1', 'key2'])['data1'].agg(Series.skew)"
+groupby_multi_series_op = Benchmark(stmt, setup,
+                                    name="groupby_multi_series_op",
+                                    start_date=datetime(2011, 8, 1))

commit 15f99c26f9877261823cf77b5c0f7f5f8585464e
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Feb 27 21:10:50 2012 -0500

    ENH: first pass through custom grouper for datetime binning

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 50931df15..40b259298 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -90,7 +90,8 @@ class PandasObject(Picklable):
         except KeyError:
             return default
 
-    def groupby(self, by=None, axis=0, level=None, as_index=True, sort=True):
+    def groupby(self, by=None, axis=0, level=None, as_index=True, sort=True,
+                grouper=None):
         """
         Group series using mapper (dict or key function, apply given function
         to group, return result as series) or by a series of columns
@@ -130,7 +131,7 @@ class PandasObject(Picklable):
         """
         from pandas.core.groupby import groupby
         return groupby(self, by, axis=axis, level=level, as_index=as_index,
-                       sort=sort)
+                       sort=sort, grouper=grouper)
 
     def select(self, crit, axis=0):
         """
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 4b923aa2d..cccf6ff64 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -124,6 +124,10 @@ class GroupBy(object):
     def groups(self):
         return self.grouper.groups
 
+    @property
+    def ngroups(self):
+        return self.grouper.ngroups
+
     @property
     def indices(self):
         return self.grouper.indices
@@ -618,6 +622,138 @@ class Grouper(object):
 
         return name_list
 
+def generate_bins_generic(index, binner, closed, label):
+    """
+    Generate bin edge offsets and bin labels for one array using another array
+    which has bin edge values. Both arrays must be sorted.
+
+    Parameters
+    ----------
+    values : array of values
+    binner : a comparable array of values representing bins into which to bin
+        the first array. Note, 'values' end-points must fall within 'binner'
+        end-points.
+    closed : which end of bin is closed; left (default), right
+    label : which end of bin to use as a label: left (default), right
+
+    Returns
+    -------
+    bins : array of offsets (into 'values' argument) of bins. 
+        Zero and last edge are excluded in result, so for instance the first
+        bin is values[0:bin[0]] and the last is values[bin[-1]:]
+    labels : array of labels of bins
+    """
+    lenidx = len(index)
+    lenbin = len(binner)
+
+    # check binner fits data
+    if index[0] < binner[0]:
+        raise ValueError("Index overlaps first bin")
+
+    if index[-1] > binner[-1]:
+        raise ValueError("Index overlaps last bin")
+
+    labels = np.empty(lenbin, dtype='O')
+    bins = np.empty(lenbin, dtype='i4')
+
+    j = 0
+    bc = 0 # bin count
+    vc = 0 # value count
+
+    # linear scan, presume nothing about index/binner
+    for i in range(0, len(binner)-1):
+        l_bin = binner[i]
+        r_bin = binner[i+1]
+
+        # set label of bin
+        if label == 'left':
+            labels[bc] = l_bin
+        else:
+            labels[bc] = r_bin
+
+        # check still within possible bins
+        if index[lenidx-1] < r_bin:
+            vc = lenidx - j
+            break
+
+        # advance until in correct bin
+        if closed == 'left':
+            while r_bin > index[j]:
+                j += 1
+                vc += 1
+                if j >= lenidx:
+                    break
+        else:
+            while r_bin >= index[j]:
+                j += 1
+                vc += 1
+                if j >= lenidx:
+                    break
+
+        # check we have more data to scan
+        if j < lenidx:
+            if vc != 0:
+                bins[bc] = j 
+                bc += 1
+                vc = 0
+        else:
+            break
+
+    labels = np.resize(labels, bc + 1)
+    bins = np.resize(bins, bc)
+
+    return bins, labels
+
+class CustomGrouper:
+    pass
+
+class Binner(Grouper, CustomGrouper):
+    """
+    Custom binner class (for grouping into bins)
+
+    Parameters
+    ----------
+    index : index object to bin
+    binner : index object containing bin edges 
+    closed : closed end of interval; left (default) or right
+    label : interval boundary to use for labeling; left (default) or right
+    """
+    index = None
+    bins = None
+    binlabels = None
+
+    def __init__(self, index, binner, closed='left', label='left'):
+        from pandas.core.index import DatetimeIndex
+
+        if isinstance(index, DatetimeIndex):
+            # we know nothing about frequencies
+            bins, labels = lib.generate_bins_dt64(index.asi8, binner.asi8,
+                                                  closed, label)
+            labels = labels.view('M8[us]')
+            # TODO: more speedup using freq info
+        else:
+            bins, labels = generate_bins_generic(index, binner, closed, label)
+
+        self.index = index
+        self.bins = bins
+        self.binlabels = labels
+
+    @cache_readonly
+    def groupings(self):
+        return [Grouping(self.index, self, name="Binner")]
+
+    @cache_readonly
+    def ngroups(self):
+        return len(self.binlabels)
+
+    def agg_series(self, obj, func):
+        dummy = obj[:0]
+        grouper = lib.SeriesBinGrouper(obj, func, self.bins, dummy)
+        return grouper.get_result()
+
+    @cache_readonly
+    def result_index(self):
+        return self.binlabels
 
 class Grouping(object):
     """
@@ -656,6 +792,10 @@ class Grouping(object):
         # pre-computed
         self._was_factor = False
 
+        # did we pass a custom grouper object? Do nothing
+        if isinstance(grouper, CustomGrouper):
+            return
+
         if level is not None:
             if not isinstance(level, int):
                 assert(level in index.names)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 9a0490b3a..d6b75024c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -819,7 +819,7 @@ copy : boolean, default False
         """
         return self.view(ndarray)
 
-    def copy(self):
+    def copy(self, order='C'):
         """
         Return new Series with copy of underlying values
 
@@ -827,7 +827,7 @@ copy : boolean, default False
         -------
         cp : Series
         """
-        return Series(self.values.copy(), index=self.index, name=self.name)
+        return Series(self.values.copy(order), index=self.index, name=self.name)
 
     def to_dict(self):
         """
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 99df8d745..c0292dfa6 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -381,6 +381,87 @@ def group_var(ndarray[float64_t, ndim=2] out,
                 out[i, j] = ((ct * sumxx[i, j] - sumx[i, j] * sumx[i, j]) /
                              (ct * ct - ct))
 
+# TODO: could do even better if we know something about the data. eg, index has
+# 1-min data, binner has 5-min data, then  bins are just strides in index. This
+# is a general, O(max(len(values), len(binner))) method.
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def generate_bins_dt64(ndarray[int64_t] values, ndarray[int64_t] binner,
+                       object closed='left', object label='left'):
+    """
+    Int64 (datetime64) version of generic python version in groupby.py
+    """
+    cdef:
+        Py_ssize_t lenidx, lenbin, i, j, bc, vc
+        ndarray[int64_t] labels
+        ndarray[int32_t] bins
+        int64_t l_bin, r_bin
+
+    lenidx = len(values)
+    lenbin = len(binner)
+
+    if lenidx <= 0 or lenbin <= 0:
+        raise ValueError("Invalid length for values or for binner")
+
+    # check binner fits data
+    if values[0] < binner[0]:
+        raise ValueError("Values falls before first bin")
+
+    if values[lenidx-1] > binner[lenbin-1]:
+        raise ValueError("Values falls after last bin")
+
+    labels = np.empty(lenbin, dtype=np.int64)
+    bins   = np.empty(lenbin, dtype=np.int32)
+
+    j  = 0 # index into values
+    bc = 0 # bin count
+    vc = 0 # value count
+
+    # linear scan, presume nothing about values/binner except that it
+    # fits ok
+    for i in range(0, lenbin-1):
+        l_bin = binner[i]
+        r_bin = binner[i+1]
+
+        # set label of bin
+        if label == 'left':
+            labels[bc] = l_bin
+        else:
+            labels[bc] = r_bin
+
+        # check still within possible bins
+        if values[lenidx-1] < r_bin:
+            break
+
+        # advance until in correct bin
+        if closed == 'left':
+            while r_bin > values[j]:
+                j += 1
+                vc += 1
+                if j >= lenidx:
+                    break
+        else:
+            while r_bin >= values[j]:
+                j += 1
+                vc += 1
+                if j >= lenidx:
+                    break
+
+        # if we haven't fallen off
+        if j < lenidx:
+            # and we've seen some values
+            if vc != 0:
+                bins[bc] = j 
+                bc += 1
+                vc = 0
+        else:
+            break
+
+    labels = np.resize(labels, bc + 1)
+    bins = np.resize(bins, bc)
+
+    return bins, labels
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 0b982f721..988ac56b9 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -294,6 +294,44 @@ class TestDatetime64(unittest.TestCase):
         s['1/2/2009':'2009-06-05'] = -3
         self.assert_((s[48:54] == -3).all())
 
+    def test_custom_grouper(self):
+        from pandas.core.datetools import Minute 
+        from pandas.core.groupby import Binner
+        from pandas.core.frame import DataFrame
+
+        dti = DatetimeIndex(offset='Min', start=datetime(2005,1,1),
+                            end=datetime(2005,1,10))
+
+        data = np.array([1]*len(dti))
+        s = Series(data, index=dti) 
+
+        dti2 = DatetimeIndex(offset=Minute(5), 
+                             start=datetime(2005,1,1) - Minute(5),
+                             end=datetime(2005,1,10) + Minute(5))
+
+        b = Binner(dti, dti2, closed='left', label='left')
+        g = s.groupby(grouper=b)
+
+        self.assertEquals(g.ngroups, 2593)
+        arr = [5] * 2592
+        arr.append(1)
+
+        idx = dti[0:-1:5]
+        idx = idx.append(DatetimeIndex([np.datetime64(dti[-1])]))
+
+        e = Series(arr, index=idx)
+        r = g.agg(np.sum)
+        
+        assert_series_equal(r, e)
+
+        data = np.random.rand(len(dti), 10) 
+        df = DataFrame(data, index=dti)
+        r = df.groupby(grouper=b).agg(np.sum)
+
+        self.assertEquals(len(r.columns), 10)
+        self.assertEquals(len(r.index), 2593)
+
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index acfd432ff..7b0dff7ca 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -299,6 +299,35 @@ def test_series_bin_grouper():
     exp_counts = np.array([3, 3, 4], dtype=np.int32)
     assert_almost_equal(counts, exp_counts)
 
+def test_generate_bins():
+    values = np.array([1,2,3,4,5,6])
+    binner = np.array([0,3,6,9])
+
+    bins, labels = lib.generate_bins_dt64(values, binner,
+                                          closed='left', label='left')
+
+    assert((bins == np.array([2, 5])).all())
+    assert((labels == np.array([0, 3, 6])).all())
+
+    bins, labels = lib.generate_bins_dt64(values, binner,
+                                          closed='left', label='right')
+
+    assert((bins == np.array([2, 5])).all())
+    assert((labels == np.array([3, 6, 9])).all())
+
+    bins, labels = lib.generate_bins_dt64(values, binner,
+                                          closed='right', label='left')
+
+    assert((bins == np.array([3])).all())
+    assert((labels == np.array([0, 3])).all())
+
+    bins, labels = lib.generate_bins_dt64(values, binner,
+                                          closed='right', label='right')
+
+    assert((bins == np.array([3])).all())
+    assert((labels == np.array([3, 6])).all())
+
+
 def test_group_add_bin():
     # original group_add
     obj = np.random.randn(10, 1)

commit b1687b819320e0f0d64eda58ddf6971aaebdc3fe
Author: jreback <jeff@reback.net>
Date:   Sun Feb 16 19:28:29 2014 -0500

    CLN: remove need for tz_localize, tz_convert in Series, use the generic

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index d607be6bf..f8dbe0796 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -201,6 +201,7 @@ class NDFrame(PandasObject):
 
             def set_axis(a, i):
                 setattr(cls, a, lib.AxisProperty(i))
+                cls._internal_names_set.add(a)
 
             if axes_are_reversed:
                 m = cls._AXIS_LEN - 1
@@ -392,6 +393,10 @@ class NDFrame(PandasObject):
 
         return new_axes
 
+    def set_axis(self, axis, labels):
+        """ public verson of axis assignment """
+        setattr(self,self._get_axis_name(axis),labels)
+
     def _set_axis(self, axis, labels):
         self._data.set_axis(axis, labels)
         self._clear_item_cache()
@@ -3288,7 +3293,7 @@ class NDFrame(PandasObject):
 
     def tz_convert(self, tz, axis=0, copy=True):
         """
-        Convert TimeSeries to target time zone. If it is time zone naive, it
+        Convert the axis to target time zone. If it is time zone naive, it
         will be localized to the passed time zone.
 
         Parameters
@@ -3304,24 +3309,18 @@ class NDFrame(PandasObject):
         ax = self._get_axis(axis)
 
         if not hasattr(ax, 'tz_convert'):
-            ax_name = self._get_axis_name(axis)
-            raise TypeError('%s is not a valid DatetimeIndex or PeriodIndex' %
-                            ax_name)
-
-        new_data = self._data
-        if copy:
-            new_data = new_data.copy()
-
-        new_obj = self._constructor(new_data)
-        new_ax = ax.tz_convert(tz)
-
-        if axis == 0:
-            new_obj._set_axis(1, new_ax)
-        elif axis == 1:
-            new_obj._set_axis(0, new_ax)
-            self._clear_item_cache()
+            if len(ax) > 0:
+                ax_name = self._get_axis_name(axis)
+                raise TypeError('%s is not a valid DatetimeIndex or PeriodIndex' %
+                                ax_name)
+            else:
+                ax = DatetimeIndex([],tz=tz)
+        else:
+            ax = ax.tz_convert(tz)
 
-        return new_obj.__finalize__(self)
+        result = self._constructor(self._data, copy=copy)
+        result.set_axis(axis,ax)
+        return result.__finalize__(self)
 
     def tz_localize(self, tz, axis=0, copy=True, infer_dst=False):
         """
@@ -3342,24 +3341,18 @@ class NDFrame(PandasObject):
         ax = self._get_axis(axis)
 
         if not hasattr(ax, 'tz_localize'):
-            ax_name = self._get_axis_name(axis)
-            raise TypeError('%s is not a valid DatetimeIndex or PeriodIndex' %
-                            ax_name)
-
-        new_data = self._data
-        if copy:
-            new_data = new_data.copy()
-
-        new_obj = self._constructor(new_data)
-        new_ax = ax.tz_localize(tz, infer_dst=infer_dst)
-
-        if axis == 0:
-            new_obj._set_axis(1, new_ax)
-        elif axis == 1:
-            new_obj._set_axis(0, new_ax)
-            self._clear_item_cache()
+            if len(ax) > 0:
+                ax_name = self._get_axis_name(axis)
+                raise TypeError('%s is not a valid DatetimeIndex or PeriodIndex' %
+                                ax_name)
+            else:
+                ax = DatetimeIndex([],tz=tz)
+        else:
+            ax = ax.tz_localize(tz, infer_dst=infer_dst)
 
-        return new_obj.__finalize__(self)
+        result = self._constructor(self._data, copy=copy)
+        result.set_axis(axis,ax)
+        return result.__finalize__(self)
 
     #----------------------------------------------------------------------
     # Numeric Methods
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 35acfffe5..09fc149ec 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1726,7 +1726,7 @@ class Series(generic.NDFrame):
             False for ranks by high (1) to low (N)
         pct : boolean, defeault False
             Computes percentage rank of data
-            
+
         Returns
         -------
         ranks : Series
@@ -2323,67 +2323,6 @@ class Series(generic.NDFrame):
         return self._constructor([d.weekday() for d in self.index],
                                  index=self.index).__finalize__(self)
 
-    def tz_convert(self, tz, copy=True):
-        """
-        Convert TimeSeries to target time zone
-
-        Parameters
-        ----------
-        tz : string or pytz.timezone object
-        copy : boolean, default True
-            Also make a copy of the underlying data
-
-        Returns
-        -------
-        converted : TimeSeries
-        """
-        new_index = self.index.tz_convert(tz)
-
-        new_values = self.values
-        if copy:
-            new_values = new_values.copy()
-
-        return self._constructor(new_values,
-                                 index=new_index).__finalize__(self)
-
-    def tz_localize(self, tz, copy=True, infer_dst=False):
-        """
-        Localize tz-naive TimeSeries to target time zone
-        Entries will retain their "naive" value but will be annotated as
-        being relative to the specified tz.
-
-        After localizing the TimeSeries, you may use tz_convert() to
-        get the Datetime values recomputed to a different tz.
-
-        Parameters
-        ----------
-        tz : string or pytz.timezone object
-        copy : boolean, default True
-            Also make a copy of the underlying data
-        infer_dst : boolean, default False
-            Attempt to infer fall dst-transition hours based on order
-
-        Returns
-        -------
-        localized : TimeSeries
-        """
-        from pandas.tseries.index import DatetimeIndex
-
-        if not isinstance(self.index, DatetimeIndex):
-            if len(self.index) > 0:
-                raise Exception('Cannot tz-localize non-time series')
-
-            new_index = DatetimeIndex([], tz=tz)
-        else:
-            new_index = self.index.tz_localize(tz, infer_dst=infer_dst)
-
-        new_values = self.values
-        if copy:
-            new_values = new_values.copy()
-
-        return self._constructor(new_values,
-                                 index=new_index).__finalize__(self)
-
     @cache_readonly
     def str(self):
         from pandas.core.strings import StringMethods

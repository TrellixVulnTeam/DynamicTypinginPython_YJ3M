commit c420953df9547fcc4fc15ed61708f14b8c4108ab
Author: jreback <jeff@reback.net>
Date:   Sat Sep 28 16:46:26 2013 -0400

    COMPAT: provide numpy compat with 1.7 for numeric methods when calling like: np.prod(obj)
            as numpy is now passing extra args to the pandas methods!

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 73e7e3aff..39dc5d192 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -267,6 +267,9 @@ API Changes
     ``SparsePanel``, etc.), now support the entire set of arithmetic operators
     and arithmetic flex methods (add, sub, mul, etc.). ``SparsePanel`` does not
     support ``pow`` or ``mod`` with non-scalars. (:issue:`3765`)
+  - Provide numpy compatibility with 1.7 for a calling convention like ``np.prod(pandas_object)`` as numpy
+    call with additional keyword args (:issue:`4435`)
+
 
 Internal Refactoring
 ~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c6727f916..44bb1ce19 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -3869,7 +3869,7 @@ class DataFrame(NDFrame):
         else:
             return result
 
-    def any(self, axis=0, bool_only=None, skipna=True, level=None):
+    def any(self, axis=None, bool_only=None, skipna=True, level=None, **kwargs):
         """
         Return whether any element is True over requested axis.
         %(na_action)s
@@ -3891,13 +3891,15 @@ class DataFrame(NDFrame):
         -------
         any : Series (or DataFrame if level specified)
         """
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('any', axis=axis, level=level,
                                       skipna=skipna)
         return self._reduce(nanops.nanany, axis=axis, skipna=skipna,
                             numeric_only=bool_only, filter_type='bool')
 
-    def all(self, axis=0, bool_only=None, skipna=True, level=None):
+    def all(self, axis=None, bool_only=None, skipna=True, level=None, **kwargs):
         """
         Return whether all elements are True over requested axis.
         %(na_action)s
@@ -3919,6 +3921,8 @@ class DataFrame(NDFrame):
         -------
         any : Series (or DataFrame if level specified)
         """
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('all', axis=axis, level=level,
                                       skipna=skipna)
@@ -3928,7 +3932,9 @@ class DataFrame(NDFrame):
     @Substitution(name='sum', shortname='sum', na_action=_doc_exclude_na,
                   extras=_numeric_only_doc)
     @Appender(_stat_doc)
-    def sum(self, axis=0, numeric_only=None, skipna=True, level=None):
+    def sum(self, axis=None, numeric_only=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('sum', axis=axis, level=level,
                                       skipna=skipna)
@@ -3938,7 +3944,9 @@ class DataFrame(NDFrame):
     @Substitution(name='mean', shortname='mean', na_action=_doc_exclude_na,
                   extras='')
     @Appender(_stat_doc)
-    def mean(self, axis=0, skipna=True, level=None):
+    def mean(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('mean', axis=axis, level=level,
                                       skipna=skipna)
@@ -3948,7 +3956,7 @@ class DataFrame(NDFrame):
     @Substitution(name='minimum', shortname='min', na_action=_doc_exclude_na,
                   extras='')
     @Appender(_stat_doc)
-    def min(self, axis=0, skipna=True, level=None):
+    def min(self, axis=None, skipna=True, level=None, **kwargs):
         """
         Notes
         -----
@@ -3961,6 +3969,8 @@ class DataFrame(NDFrame):
         DataFrame.idxmin
         Series.idxmin
         """
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('min', axis=axis, level=level,
                                       skipna=skipna)
@@ -3970,7 +3980,7 @@ class DataFrame(NDFrame):
     @Substitution(name='maximum', shortname='max', na_action=_doc_exclude_na,
                   extras='')
     @Appender(_stat_doc)
-    def max(self, axis=0, skipna=True, level=None):
+    def max(self, axis=None, skipna=True, level=None, **kwargs):
         """
         Notes
         -----
@@ -3983,6 +3993,8 @@ class DataFrame(NDFrame):
         DataFrame.idxmax
         Series.idxmax
         """
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('max', axis=axis, level=level,
                                       skipna=skipna)
@@ -3992,7 +4004,9 @@ class DataFrame(NDFrame):
     @Substitution(name='product', shortname='product',
                   na_action='NA/null values are treated as 1', extras='')
     @Appender(_stat_doc)
-    def prod(self, axis=0, skipna=True, level=None):
+    def prod(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('prod', axis=axis, level=level,
                                       skipna=skipna)
@@ -4004,7 +4018,9 @@ class DataFrame(NDFrame):
     @Substitution(name='median', shortname='median', na_action=_doc_exclude_na,
                   extras='')
     @Appender(_stat_doc)
-    def median(self, axis=0, skipna=True, level=None):
+    def median(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('median', axis=axis, level=level,
                                       skipna=skipna)
@@ -4014,7 +4030,9 @@ class DataFrame(NDFrame):
     @Substitution(name='mean absolute deviation', shortname='mad',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def mad(self, axis=0, skipna=True, level=None):
+    def mad(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('mad', axis=axis, level=level,
                                       skipna=skipna)
@@ -4034,7 +4052,9 @@ class DataFrame(NDFrame):
               """
         Normalized by N-1 (unbiased estimator).
         """)
-    def var(self, axis=0, skipna=True, level=None, ddof=1):
+    def var(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('var', axis=axis, level=level,
                                       skipna=skipna, ddof=ddof)
@@ -4047,7 +4067,9 @@ class DataFrame(NDFrame):
               """
         Normalized by N-1 (unbiased estimator).
         """)
-    def std(self, axis=0, skipna=True, level=None, ddof=1):
+    def std(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('std', axis=axis, level=level,
                                       skipna=skipna, ddof=ddof)
@@ -4056,7 +4078,9 @@ class DataFrame(NDFrame):
     @Substitution(name='unbiased skewness', shortname='skew',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def skew(self, axis=0, skipna=True, level=None):
+    def skew(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('skew', axis=axis, level=level,
                                       skipna=skipna)
@@ -4066,7 +4090,9 @@ class DataFrame(NDFrame):
     @Substitution(name='unbiased kurtosis', shortname='kurt',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def kurt(self, axis=0, skipna=True, level=None):
+    def kurt(self, axis=None, skipna=True, level=None, **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
         if level is not None:
             return self._agg_by_level('kurt', axis=axis, level=level,
                                       skipna=skipna)
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 705679136..060873e72 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1949,33 +1949,6 @@ class NDFrame(PandasObject):
     #----------------------------------------------------------------------
     # Action Methods
 
-    def abs(self):
-        """
-        Return an object with absolute value taken. Only applicable to objects
-        that are all numeric
-
-        Returns
-        -------
-        abs: type of caller
-        """
-        obj = np.abs(self)
-
-        # suprimo numpy 1.6 hacking
-        if _np_version_under1p7:
-            if self.ndim == 1:
-                if obj.dtype == 'm8[us]':
-                    obj = obj.astype('m8[ns]')
-            elif self.ndim == 2:
-                def f(x):
-                    if x.dtype == 'm8[us]':
-                        x = x.astype('m8[ns]')
-                    return x
-
-                if 'm8[us]' in obj.dtypes.values:
-                    obj = obj.apply(f)
-
-        return obj
-
     def clip(self, lower=None, upper=None, out=None):
         """
         Trim values at input threshold(s)
@@ -2550,178 +2523,6 @@ class NDFrame(PandasObject):
         """
         return self.where(~cond, np.nan)
 
-    def pct_change(self, periods=1, fill_method='pad', limit=None, freq=None,
-                   **kwds):
-        """
-        Percent change over given number of periods
-
-        Parameters
-        ----------
-        periods : int, default 1
-            Periods to shift for forming percent change
-        fill_method : str, default 'pad'
-            How to handle NAs before computing percent changes
-        limit : int, default None
-            The number of consecutive NAs to fill before stopping
-        freq : DateOffset, timedelta, or offset alias string, optional
-            Increment to use from time series API (e.g. 'M' or BDay())
-
-        Returns
-        -------
-        chg : Series or DataFrame
-        """
-        if fill_method is None:
-            data = self
-        else:
-            data = self.fillna(method=fill_method, limit=limit)
-        rs = data / data.shift(periods=periods, freq=freq, **kwds) - 1
-        if freq is None:
-            mask = com.isnull(_values_from_object(self))
-            np.putmask(rs.values, mask, np.nan)
-        return rs
-
-    def cumsum(self, axis=None, skipna=True):
-        """
-        Return DataFrame of cumulative sums over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, 0.)
-
-            result = y.cumsum(axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = y.cumsum(axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cumprod(self, axis=None, skipna=True):
-        """
-        Return cumulative product over requested axis as DataFrame
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, 1.)
-            result = y.cumprod(axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = y.cumprod(axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cummax(self, axis=None, skipna=True):
-        """
-        Return DataFrame of cumulative max over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, -np.inf)
-
-            result = np.maximum.accumulate(y, axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = np.maximum.accumulate(y, axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cummin(self, axis=None, skipna=True):
-        """
-        Return DataFrame of cumulative min over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, np.inf)
-
-            result = np.minimum.accumulate(y, axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = np.minimum.accumulate(y, axis)
-        return self._wrap_array(result, self.axes, copy=False)
 
     def shift(self, periods=1, freq=None, axis=0, **kwds):
         """
@@ -2928,6 +2729,209 @@ class NDFrame(PandasObject):
 
         return new_obj
 
+    #----------------------------------------------------------------------
+    # Numeric Methods
+
+    def abs(self):
+        """
+        Return an object with absolute value taken. Only applicable to objects
+        that are all numeric
+
+        Returns
+        -------
+        abs: type of caller
+        """
+        obj = np.abs(self)
+
+        # suprimo numpy 1.6 hacking
+        if _np_version_under1p7:
+            if self.ndim == 1:
+                if obj.dtype == 'm8[us]':
+                    obj = obj.astype('m8[ns]')
+            elif self.ndim == 2:
+                def f(x):
+                    if x.dtype == 'm8[us]':
+                        x = x.astype('m8[ns]')
+                    return x
+
+                if 'm8[us]' in obj.dtypes.values:
+                    obj = obj.apply(f)
+
+        return obj
+
+    def pct_change(self, periods=1, fill_method='pad', limit=None, freq=None,
+                   **kwds):
+        """
+        Percent change over given number of periods
+
+        Parameters
+        ----------
+        periods : int, default 1
+            Periods to shift for forming percent change
+        fill_method : str, default 'pad'
+            How to handle NAs before computing percent changes
+        limit : int, default None
+            The number of consecutive NAs to fill before stopping
+        freq : DateOffset, timedelta, or offset alias string, optional
+            Increment to use from time series API (e.g. 'M' or BDay())
+
+        Returns
+        -------
+        chg : Series or DataFrame
+        """
+        if fill_method is None:
+            data = self
+        else:
+            data = self.fillna(method=fill_method, limit=limit)
+        rs = data / data.shift(periods=periods, freq=freq, **kwds) - 1
+        if freq is None:
+            mask = com.isnull(_values_from_object(self))
+            np.putmask(rs.values, mask, np.nan)
+        return rs
+
+    def cumsum(self, axis=None, skipna=True, **kwargs):
+        """
+        Return DataFrame of cumulative sums over requested axis.
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        if axis is None:
+            axis = self._stat_axis_number
+        else:
+            axis = self._get_axis_number(axis)
+
+        y = _values_from_object(self).copy()
+        if not issubclass(y.dtype.type, np.integer):
+            mask = np.isnan(_values_from_object(self))
+
+            if skipna:
+                np.putmask(y, mask, 0.)
+
+            result = y.cumsum(axis)
+
+            if skipna:
+                np.putmask(result, mask, np.nan)
+        else:
+            result = y.cumsum(axis)
+        return self._wrap_array(result, self.axes, copy=False)
+
+    def cumprod(self, axis=None, skipna=True, **kwargs):
+        """
+        Return cumulative product over requested axis as DataFrame
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        if axis is None:
+            axis = self._stat_axis_number
+        else:
+            axis = self._get_axis_number(axis)
+
+        y = _values_from_object(self).copy()
+        if not issubclass(y.dtype.type, np.integer):
+            mask = np.isnan(_values_from_object(self))
+
+            if skipna:
+                np.putmask(y, mask, 1.)
+            result = y.cumprod(axis)
+
+            if skipna:
+                np.putmask(result, mask, np.nan)
+        else:
+            result = y.cumprod(axis)
+        return self._wrap_array(result, self.axes, copy=False)
+
+    def cummax(self, axis=None, skipna=True, **kwargs):
+        """
+        Return DataFrame of cumulative max over requested axis.
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        if axis is None:
+            axis = self._stat_axis_number
+        else:
+            axis = self._get_axis_number(axis)
+
+        y = _values_from_object(self).copy()
+        if not issubclass(y.dtype.type, np.integer):
+            mask = np.isnan(_values_from_object(self))
+
+            if skipna:
+                np.putmask(y, mask, -np.inf)
+
+            result = np.maximum.accumulate(y, axis)
+
+            if skipna:
+                np.putmask(result, mask, np.nan)
+        else:
+            result = np.maximum.accumulate(y, axis)
+        return self._wrap_array(result, self.axes, copy=False)
+
+    def cummin(self, axis=None, skipna=True, **kwargs):
+        """
+        Return DataFrame of cumulative min over requested axis.
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+        skipna : boolean, default True
+            Exclude NA/null values. If an entire row/column is NA, the result
+            will be NA
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        if axis is None:
+            axis = self._stat_axis_number
+        else:
+            axis = self._get_axis_number(axis)
+
+        y = _values_from_object(self).copy()
+        if not issubclass(y.dtype.type, np.integer):
+            mask = np.isnan(_values_from_object(self))
+
+            if skipna:
+                np.putmask(y, mask, np.inf)
+
+            result = np.minimum.accumulate(y, axis)
+
+            if skipna:
+                np.putmask(result, mask, np.nan)
+        else:
+            result = np.minimum.accumulate(y, axis)
+        return self._wrap_array(result, self.axes, copy=False)
+
 # install the indexerse
 for _name, _indexer in indexing.get_indexers_list():
     NDFrame._create_indexer(_name, _indexer)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 7208ceff7..b4748c86a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1233,61 +1233,81 @@ If all values are NA, result will be NA"""
 
         @Substitution(desc='sum', outname='sum')
         @Appender(_agg_doc)
-        def sum(self, axis='major', skipna=True):
+        def sum(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nansum, axis=axis, skipna=skipna)
         cls.sum = sum
 
         @Substitution(desc='mean', outname='mean')
         @Appender(_agg_doc)
-        def mean(self, axis='major', skipna=True):
+        def mean(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanmean, axis=axis, skipna=skipna)
         cls.mean = mean
 
         @Substitution(desc='unbiased variance', outname='variance')
         @Appender(_agg_doc)
-        def var(self, axis='major', skipna=True):
+        def var(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanvar, axis=axis, skipna=skipna)
         cls.var = var
 
         @Substitution(desc='unbiased standard deviation', outname='stdev')
         @Appender(_agg_doc)
-        def std(self, axis='major', skipna=True):
+        def std(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self.var(axis=axis, skipna=skipna).apply(np.sqrt)
         cls.std = std
 
         @Substitution(desc='unbiased skewness', outname='skew')
         @Appender(_agg_doc)
-        def skew(self, axis='major', skipna=True):
+        def skew(self, axis=None, skipna=True, **wwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanskew, axis=axis, skipna=skipna)
         cls.skew = skew
 
         @Substitution(desc='product', outname='prod')
         @Appender(_agg_doc)
-        def prod(self, axis='major', skipna=True):
+        def prod(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanprod, axis=axis, skipna=skipna)
         cls.prod = prod
 
         @Substitution(desc='compounded percentage', outname='compounded')
         @Appender(_agg_doc)
-        def compound(self, axis='major', skipna=True):
+        def compound(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return (1 + self).prod(axis=axis, skipna=skipna) - 1
         cls.compound = compound
 
         @Substitution(desc='median', outname='median')
         @Appender(_agg_doc)
-        def median(self, axis='major', skipna=True):
+        def median(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanmedian, axis=axis, skipna=skipna)
         cls.median = median
 
         @Substitution(desc='maximum', outname='maximum')
         @Appender(_agg_doc)
-        def max(self, axis='major', skipna=True):
+        def max(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanmax, axis=axis, skipna=skipna)
         cls.max = max
 
         @Substitution(desc='minimum', outname='minimum')
         @Appender(_agg_doc)
-        def min(self, axis='major', skipna=True):
+        def min(self, axis=None, skipna=True, **kwargs):
+            if axis is None:
+                axis = self._stat_axis_number
             return self._reduce(nanops.nanmin, axis=axis, skipna=skipna)
         cls.min = min
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 38e22e7a9..972f654fe 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -104,7 +104,7 @@ def _make_stat_func(nanop, name, shortname, na_action=_doc_exclude_na,
     @Substitution(name=name, shortname=shortname,
                   na_action=na_action, extras=extras)
     @Appender(_stat_doc)
-    def f(self, axis=0, dtype=None, out=None, skipna=True, level=None):
+    def f(self, axis=0, dtype=None, out=None, skipna=True, level=None, **kwargs):
         if level is not None:
             return self._agg_by_level(shortname, level=level, skipna=skipna)
         return nanop(_values_from_object(self), skipna=skipna)
@@ -1202,7 +1202,7 @@ class Series(generic.NDFrame):
     @Substitution(name='mean absolute deviation', shortname='mad',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def mad(self, skipna=True, level=None):
+    def mad(self, skipna=True, level=None, **kwargs):
         if level is not None:
             return self._agg_by_level('mad', level=level, skipna=skipna)
 
@@ -1212,7 +1212,7 @@ class Series(generic.NDFrame):
     @Substitution(name='minimum', shortname='min',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def min(self, axis=None, out=None, skipna=True, level=None):
+    def min(self, axis=None, out=None, skipna=True, level=None, **kwargs):
         """
         Notes
         -----
@@ -1232,7 +1232,7 @@ class Series(generic.NDFrame):
     @Substitution(name='maximum', shortname='max',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def max(self, axis=None, out=None, skipna=True, level=None):
+    def max(self, axis=None, out=None, skipna=True, level=None, **kwargs):
         """
         Notes
         -----
@@ -1256,7 +1256,7 @@ class Series(generic.NDFrame):
         Normalized by N-1 (unbiased estimator).
         """)
     def std(self, axis=None, dtype=None, out=None, ddof=1, skipna=True,
-            level=None):
+            level=None, **kwargs):
         if level is not None:
             return self._agg_by_level('std', level=level, skipna=skipna,
                                       ddof=ddof)
@@ -1269,7 +1269,7 @@ class Series(generic.NDFrame):
         Normalized by N-1 (unbiased estimator).
         """)
     def var(self, axis=None, dtype=None, out=None, ddof=1, skipna=True,
-            level=None):
+            level=None, **kwargs):
         if level is not None:
             return self._agg_by_level('var', level=level, skipna=skipna,
                                       ddof=ddof)
@@ -1278,7 +1278,7 @@ class Series(generic.NDFrame):
     @Substitution(name='unbiased skewness', shortname='skew',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def skew(self, skipna=True, level=None):
+    def skew(self, skipna=True, level=None, **kwargs):
         if level is not None:
             return self._agg_by_level('skew', level=level, skipna=skipna)
 
@@ -1287,7 +1287,7 @@ class Series(generic.NDFrame):
     @Substitution(name='unbiased kurtosis', shortname='kurt',
                   na_action=_doc_exclude_na, extras='')
     @Appender(_stat_doc)
-    def kurt(self, skipna=True, level=None):
+    def kurt(self, skipna=True, level=None, **kwargs):
         if level is not None:
             return self._agg_by_level('kurt', level=level, skipna=skipna)
 
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index 6ea58ec99..5a215d405 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -9,7 +9,7 @@ import numpy as np
 import pandas as pd
 
 from pandas import (Index, Series, DataFrame, Panel,
-                    isnull, notnull,date_range)
+                    isnull, notnull,date_range, _np_version_under1p7)
 from pandas.core.index import Index, MultiIndex
 from pandas.tseries.index import Timestamp, DatetimeIndex
 
@@ -118,6 +118,7 @@ class Generic(object):
         self._compare(result, o)
 
         # _get_numeric_data is includes _get_bool_data, so can't test for non-inclusion
+
     def test_nonzero(self):
 
         # GH 4633
@@ -154,6 +155,24 @@ class Generic(object):
         self.assertRaises(ValueError, lambda : obj1 or obj2)
         self.assertRaises(ValueError, lambda : not obj1)
 
+    def test_numpy_1_7_compat_numeric_methods(self):
+        if _np_version_under1p7:
+            raise nose.SkipTest("numpy < 1.7")
+
+        # GH 4435
+        # numpy in 1.7 tries to pass addtional arguments to pandas functions
+
+        o = self._construct(shape=4)
+        for op in ['min','max','max','var','std','prod','sum',
+                   'median','skew','kurt','compound','cummax','cummin','all','any']:
+            f = getattr(np,op,None)
+            if f is not None:
+                f(o)
+
+        # numpy broken methods, since these are not passed by keywords, they
+        # won't work
+        #'cumsum','cumprod',
+
 class TestSeries(unittest.TestCase, Generic):
     _typ = Series
     _comparator = lambda self, x, y: assert_series_equal(x,y)

commit e1710c9aac1d2e04933d252aa947b9f125b9a38a
Author: jreback <jeff@reback.net>
Date:   Fri Jun 7 15:01:26 2013 -0400

    BUG: (GH3795) better error messages for invalid dtype specifications in read_csv
    
         accept 'str' as a dtype in read_csv to provide correct parsing
    
    BUG: py3k support for str dtype (which is actually unicode)

diff --git a/RELEASE.rst b/RELEASE.rst
index 7a7797254..4d8583470 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -219,6 +219,7 @@ pandas 0.11.1
   - Incorrectly read a HDFStore multi-index Frame witha column specification (GH3748_)
   - ``read_html`` now correctly skips tests (GH3741_)
   - Fix incorrect arguments passed to concat that are not list-like (e.g. concat(df1,df2)) (GH3481_)
+  - Correctly parse when passed the ``dtype=str`` (or other variable-len string dtypes) in ``read_csv`` (GH3795_)
 
 .. _GH3164: https://github.com/pydata/pandas/issues/3164
 .. _GH2786: https://github.com/pydata/pandas/issues/2786
@@ -307,6 +308,7 @@ pandas 0.11.1
 .. _GH3741: https://github.com/pydata/pandas/issues/3741
 .. _GH3750: https://github.com/pydata/pandas/issues/3750
 .. _GH3726: https://github.com/pydata/pandas/issues/3726
+.. _GH3795: https://github.com/pydata/pandas/issues/3795
 
 pandas 0.11.0
 =============
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 55abef2fd..cae4c0902 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -485,6 +485,36 @@ skip
         except Exception, inst:
             self.assert_('Expected 3 fields in line 6, saw 5' in str(inst))
 
+    def test_passing_dtype(self):
+
+        df = DataFrame(np.random.rand(5,2),columns=list('AB'),index=['1A','1B','1C','1D','1E'])
+
+        with ensure_clean('__passing_str_as_dtype__.csv') as path:
+            df.to_csv(path)
+
+            # GH 3795
+            # passing 'str' as the dtype
+            result = pd.read_csv(path, dtype=str, index_col=0)
+            tm.assert_series_equal(result.dtypes,Series({ 'A' : 'object', 'B' : 'object' }))
+
+            # we expect all object columns, so need to convert to test for equivalence
+            result = result.astype(float)
+            tm.assert_frame_equal(result,df)
+
+            # invalid dtype
+            self.assertRaises(TypeError, pd.read_csv, path, dtype={'A' : 'foo', 'B' : 'float64' },
+                              index_col=0)
+
+            # valid but we don't support it (date)
+            self.assertRaises(TypeError, pd.read_csv, path, dtype={'A' : 'datetime64', 'B' : 'float64' },
+                              index_col=0)
+            self.assertRaises(TypeError, pd.read_csv, path, dtype={'A' : 'datetime64', 'B' : 'float64' },
+                              index_col=0, parse_dates=['B'])
+
+            # valid but we don't support it
+            self.assertRaises(TypeError, pd.read_csv, path, dtype={'A' : 'timedelta64', 'B' : 'float64' },
+                              index_col=0)
+
     def test_quoting(self):
         bad_line_small = """printer\tresult\tvariant_name
 Klosterdruckerei\tKlosterdruckerei <Salem> (1611-1804)\tMuller, Jacob
diff --git a/pandas/parser.pyx b/pandas/parser.pyx
index ee92e2e60..004c23d09 100644
--- a/pandas/parser.pyx
+++ b/pandas/parser.pyx
@@ -990,20 +990,36 @@ cdef class TextReader:
                                              na_filter, na_hashset)
             return result, na_count
         elif dtype[1] == 'c':
-            raise NotImplementedError
+            raise NotImplementedError("the dtype %s is not supported for parsing" % dtype)
 
         elif dtype[1] == 'S':
             # TODO: na handling
             width = int(dtype[2:])
-            result = _to_fw_string(self.parser, i, start, end, width)
-            return result, 0
+            if width > 0:
+                result = _to_fw_string(self.parser, i, start, end, width)
+                return result, 0
+
+            # treat as a regular string parsing
+            return self._string_convert(i, start, end, na_filter,
+                                       na_hashset)
         elif dtype[1] == 'U':
             width = int(dtype[2:])
-            raise NotImplementedError
+            if width > 0:
+                raise NotImplementedError("the dtype %s is not supported for parsing" % dtype)
+
+            # unicode variable width
+            return self._string_convert(i, start, end, na_filter,
+                                        na_hashset)
+
 
         elif dtype[1] == 'O':
             return self._string_convert(i, start, end, na_filter,
                                         na_hashset)
+        else:
+            if dtype[1] == 'M':
+                 raise TypeError("the dtype %s is not supported for parsing, "
+                                 "pass this column using parse_dates instead" % dtype)
+            raise TypeError("the dtype %s is not supported for parsing" % dtype)
 
     cdef _string_convert(self, Py_ssize_t i, int start, int end,
                          bint na_filter, kh_str_t *na_hashset):

commit 4cf02506d62d7ddfe5a9f81c4d29871c5f227524
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Apr 26 21:11:52 2012 -0400

    ENH: conversion to UTC between differently indexed datetime indexes, close #864

diff --git a/RELEASE.rst b/RELEASE.rst
index f8d2eef66..b50b72e52 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -31,6 +31,8 @@ pandas 0.8.0
     conversion method (#1018)
   - Implement robust frequency inference function and `inferred_freq` attribute
     on DatetimeIndex (#391)
+  - Convert DatetimeIndexes to UTC if time zones are different in join/setops
+    (#864)
 
 **Improvements to existing features**
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index ee1a2382f..88b7840e0 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2540,6 +2540,31 @@ class TimeSeries(Series):
         namestr = "Name: %s, " % str(self.name) if self.name else ""
         return '%s%sLength: %d' % (freqstr, namestr, len(self))
 
+    def tz_convert(self, tz, copy=True):
+        """
+        Convert TimeSeries to target time zone. If it is time zone naive, it
+        will be localized to the passed time zone.
+
+        Parameters
+        ----------
+        tz : string or pytz.timezone object
+        copy : boolean, default True
+            Also make a copy of the underlying data
+
+        Returns
+        -------
+        """
+        if self.index.tz is None:
+            new_index = self.index.tz_localize(tz)
+        else:
+            new_index = self.index.tz_normalize(tz)
+
+        new_values = self.values
+        if copy:
+            new_values = new_values.copy()
+
+        return Series(new_values, index=new_index, name=self.name)
+
     def to_timestamp(self, freq='D', how='start', copy=True):
         """
         Cast to datetimeindex of timestamps, at *beginning* of period
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 7362732e0..6b056602d 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -765,79 +765,84 @@ except:
 trans_cache = {}
 utc_offset_cache = {}
 
-cdef ndarray[int64_t] _get_transitions(object tz):
+def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
+    cdef:
+        ndarray[int64_t] utc_dates, result, trans, deltas
+        Py_ssize_t i, pos, n = len(vals)
+        int64_t v, offset
+
+    if not have_pytz:
+        import pytz
+
+    # Convert to UTC
+
+    if tz1.zone != 'UTC':
+        utc_dates = np.empty(n, dtype=np.int64)
+        deltas = _get_deltas(tz1)
+        trans = _get_transitions(tz1)
+        pos = trans.searchsorted(vals[0])
+        offset = deltas[pos]
+        for i in range(n):
+            v = vals[i]
+            if v >= trans[pos + 1]:
+                pos += 1
+                offset = deltas[pos]
+            utc_dates[i] = v - offset
+    else:
+        utc_dates = vals
+
+    if tz2.zone == 'UTC':
+        return utc_dates
+
+    # Convert UTC to other timezone
+
+    result = np.empty(n, dtype=np.int64)
+    trans = _get_transitions(tz2)
+    deltas = _get_deltas(tz2)
+    pos = trans.searchsorted(utc_dates[0])
+    offset = deltas[pos]
+    for i in range(n):
+        v = utc_dates[i]
+        if v >= trans[pos + 1]:
+            pos += 1
+            offset = deltas[pos]
+        result[i] = v + offset
+
+    return result
+
+trans_cache = {}
+utc_offset_cache = {}
+
+def _get_transitions(object tz):
     """
     Get UTC times of DST transitions
     """
     if tz not in trans_cache:
         arr = np.array(tz._utc_transition_times, dtype='M8[us]')
-        trans_cache[tz] = np.array(arr.view('i8'))
+        trans_cache[tz] = arr.view('i8')
     return trans_cache[tz]
 
-cdef ndarray[int64_t] _unbox_utcoffsets(object transinfo):
-    cdef:
-        Py_ssize_t i, sz
-        ndarray[int64_t] arr
-
-    sz = len(transinfo)
-    arr = np.empty(sz, dtype='i8')
-
-    for i in range(sz):
-        arr[i] = int(transinfo[i][0].total_seconds()) * 1000000
-
-    return arr
-
-cdef int64_t get_utcoffset(object tz, Py_ssize_t idx):
+def _get_deltas(object tz):
     """
     Get UTC offsets in microseconds corresponding to DST transitions
     """
-    cdef:
-        ndarray[int64_t] arr
     if tz not in utc_offset_cache:
         utc_offset_cache[tz] = _unbox_utcoffsets(tz._transition_info)
-    arr = utc_offset_cache[tz]
-    return arr[idx]
-
-def tz_normalize_array(ndarray[int64_t] vals, object tz1, object tz2):
-    """
-    Convert DateRange from one time zone to another (using pytz)
+    return utc_offset_cache[tz]
 
-    Returns
-    -------
-    normalized : DateRange
-    """
+cdef ndarray _unbox_utcoffsets(object transinfo):
     cdef:
-        ndarray[int64_t] result
-        ndarray[int64_t] trans
-        Py_ssize_t i, sz, tzidx
-        int64_t v, tz1offset, tz2offset
-
-    if not have_pytz:
-        raise Exception("Could not find pytz module")
-
-    sz = len(vals)
-
-    if sz == 0:
-        return np.empty(0, dtype=np.int64)
-
-    result = np.empty(sz, dtype=np.int64)
-    trans = _get_transitions(tz1)
-
-    tzidx = np.searchsorted(trans, vals[0])
+        Py_ssize_t i, sz
+        ndarray[int64_t] arr
 
-    tz1offset = get_utcoffset(tz1, tzidx)
-    tz2offset = get_utcoffset(tz2, tzidx)
+    sz = len(transinfo)
+    arr = np.empty(sz, dtype='i8')
 
     for i in range(sz):
-        v = vals[i]
-        if v >= trans[tzidx + 1]:
-            tzidx += 1
-            tz1offset = get_utcoffset(tz1, tzidx)
-            tz2offset = get_utcoffset(tz2, tzidx)
+        arr[i] = int(transinfo[i][0].total_seconds()) * 1000000
 
-        result[i] = (v - tz1offset) + tz2offset
+    return arr
 
-    return result
 
 def tz_localize_array(ndarray[int64_t] vals, object tz):
     """
@@ -849,9 +854,9 @@ def tz_localize_array(ndarray[int64_t] vals, object tz):
     localized : DatetimeIndex
     """
     cdef:
-        ndarray[int64_t] trans
-        Py_ssize_t i, sz, tzidx
-        int64_t v, t1, t2, currtrans, tmp
+        ndarray[int64_t] trans, deltas
+        Py_ssize_t i, pos, n = len(vals)
+        int64_t v, t1, t2, tmp
 
     if not have_pytz:
         raise Exception("Could not find pytz module")
@@ -859,33 +864,24 @@ def tz_localize_array(ndarray[int64_t] vals, object tz):
     if tz == pytz.utc or tz is None:
         return vals
 
-    sz = len(vals)
-
-    if sz == 0:
-        return np.empty(0, dtype=np.int64)
-
-    result = np.empty(sz, dtype=np.int64)
     trans = _get_transitions(tz)
-    tzidx = np.searchsorted(trans, vals[0])
+    deltas = _get_deltas(tz)
 
-    currtrans = trans[tzidx]
-    t1 = currtrans + get_utcoffset(tz, tzidx-1)
-    t2 = currtrans + get_utcoffset(tz, tzidx)
+    pos = np.searchsorted(trans, vals[0])
+    dst_start = trans[pos] + deltas[pos - 1]
+    dst_end = trans[pos] + deltas[pos]
 
-    for i in range(sz):
+    for i in range(n):
         v = vals[i]
-        if v >= trans[tzidx + 1]:
-            tzidx += 1
-            currtrans = trans[tzidx]
-            t1 = currtrans + get_utcoffset(tz, tzidx-1)
-            t2 = currtrans + get_utcoffset(tz, tzidx)
-
-        if t1 > t2:
-            tmp = t1
-            t1 = t2
-            t2 = tmp
-
-        if t1 <= v and v <= t2:
+        if v >= trans[pos + 1]:
+            pos += 1
+            dst_start = trans[pos] + deltas[pos - 1]
+            dst_end = trans[pos] + deltas[pos]
+
+        if dst_start > dst_end:
+            dst_end, dst_start = dst_start, dst_end
+
+        if dst_start <= v and v <= dst_end:
             msg = "Cannot localize, ambiguous time %s found" % Timestamp(v)
             raise pytz.AmbiguousTimeError(msg)
 
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index 3865f3a46..cc3954ffc 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -540,6 +540,94 @@ from datetime cimport getAbsTime
 #         int64_t *a
 
 
+def test_foo(ndarray[int64_t] values):
+    cdef int64_t val
+
+    val = values[0]
+    print val
 
 def get_abs_time(freq, dailyDate, originalDate):
     return getAbsTime(freq, dailyDate, originalDate)
+
+have_pytz = 1
+import pytz
+
+def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
+    cdef:
+        ndarray[int64_t] utc_dates, result, trans, deltas
+        Py_ssize_t i, pos, n = len(vals)
+        int64_t v, offset
+
+    print 'int64 is: %d' % sizeof(int64_t)
+
+    if not have_pytz:
+        import pytz
+
+    # Convert to UTC
+
+    if tz1.zone != 'UTC':
+        utc_dates = np.empty(n, dtype=np.int64)
+        deltas = _get_deltas(tz1)
+        trans = _get_transitions(tz1)
+        pos = trans.searchsorted(vals[0])
+        offset = deltas[pos]
+        for i in range(n):
+            v = vals[i]
+            if v >= trans[pos + 1]:
+                pos += 1
+                offset = deltas[pos]
+            utc_dates[i] = v - offset
+    else:
+        utc_dates = vals
+
+    if tz2.zone == 'UTC':
+        return utc_dates
+
+    # Convert UTC to other timezone
+
+    result = np.empty(n, dtype=np.int64)
+    trans = _get_transitions(tz2)
+    deltas = _get_deltas(tz2)
+    offset = deltas[pos]
+    pos = max(0, trans.searchsorted(utc_dates[0], side='right') - 1)
+    for i in range(n):
+        v = utc_dates[i]
+        if v >= trans[pos + 1]:
+            pos += 1
+            offset = deltas[pos]
+        result[i] = v + offset
+
+    return result
+
+trans_cache = {}
+utc_offset_cache = {}
+
+def _get_transitions(object tz):
+    """
+    Get UTC times of DST transitions
+    """
+    if tz not in trans_cache:
+        arr = np.array(tz._utc_transition_times, dtype='M8[us]')
+        trans_cache[tz] = arr.view('i8')
+    return trans_cache[tz]
+
+def _get_deltas(object tz):
+    """
+    Get UTC offsets in microseconds corresponding to DST transitions
+    """
+    if tz not in utc_offset_cache:
+        utc_offset_cache[tz] = _unbox_utcoffsets(tz._transition_info)
+    return utc_offset_cache[tz]
+
+cdef ndarray _unbox_utcoffsets(object transinfo):
+    cdef:
+        Py_ssize_t i, sz
+        ndarray[int64_t] arr
+
+    sz = len(transinfo)
+    arr = np.empty(sz, dtype='i8')
+
+    for i in range(sz):
+        arr[i] = int(transinfo[i][0].total_seconds()) * 1000000
+
+    return arr
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 1cae0a8e9..e5ed97540 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -574,10 +574,14 @@ class DatetimeIndex(Int64Index):
         -------
         y : Index or DatetimeIndex
         """
-        if self._can_fast_union(other):
-            return self._fast_union(other)
+        this, other = self._maybe_utc_convert(other)
+
+        if this._can_fast_union(other):
+            return this._fast_union(other)
         else:
-            return Index.union(self, other)
+            result = Index.union(this, other)
+            result.tz = self.tz
+            return result
 
     def join(self, other, how='left', level=None, return_indexers=False):
         """
@@ -589,9 +593,17 @@ class DatetimeIndex(Int64Index):
             except ValueError:
                 pass
 
-        return Index.join(self, other, how=how, level=level,
+        this, other = self._maybe_utc_convert(other)
+        return Index.join(this, other, how=how, level=level,
                           return_indexers=return_indexers)
 
+    def _maybe_utc_convert(self, other):
+        this = self
+        if isinstance(other, DatetimeIndex):
+            if self.tz != other.tz:
+                this = self.tz_normalize('UTC')
+                other = other.tz_normalize('UTC')
+        return this, other
 
     def _wrap_joined_index(self, joined, other):
         name = self.name if self.name == other.name else None
@@ -613,6 +625,9 @@ class DatetimeIndex(Int64Index):
         if offset is None:
             return False
 
+        if not self.is_monotonic or not other.is_monotonic:
+            return False
+
         if len(other) == 0:
             return True
 
@@ -681,7 +696,8 @@ class DatetimeIndex(Int64Index):
             except TypeError:
                 pass
             return Index.intersection(self, other)
-        elif other.offset != self.offset:
+        elif other.offset != self.offset or (not self.is_monotonic or
+                                             not other.is_monotonic):
             return Index.intersection(self, other)
 
         # to make our life easier, "sort" the two ranges
@@ -914,7 +930,7 @@ class DatetimeIndex(Int64Index):
             except:
                 return False
 
-        return np.array_equal(self.asi8, other.asi8)
+        return self.tz == other.tz and np.array_equal(self.asi8, other.asi8)
 
     def insert(self, loc, item):
         """
@@ -952,9 +968,12 @@ class DatetimeIndex(Int64Index):
         -------
         normalized : DatetimeIndex
         """
-        new_dates = lib.tz_normalize_array(self.asi8, self.tz, tz)
+        from pandas._tseries import tz_convert
+        tz = tools._maybe_get_tz(tz)
+        new_dates = tz_convert(self.asi8, self.tz, tz)
         new_dates = new_dates.view('M8[us]')
-        new_dates = new_dates.view(self.__class__)
+
+        new_dates = new_dates.view(type(self))
         new_dates.offset = self.offset
         new_dates.tz = tz
         new_dates.name = self.name
@@ -971,6 +990,7 @@ class DatetimeIndex(Int64Index):
         if self.tz is not None:
             raise ValueError("Already have timezone info, "
                              "use tz_normalize to convert.")
+        tz = tools._maybe_get_tz(tz)
 
         new_dates = lib.tz_localize_array(self.asi8, tz)
         new_dates = new_dates.view('M8[us]')
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index f392325d8..95c2805cb 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -725,6 +725,71 @@ class TestLegacySupport(unittest.TestCase):
 
         self.assert_(result.index.equals(exp_index))
 
+
+class TestTimeZones(unittest.TestCase):
+
+    def setUp(self):
+        _skip_if_no_pytz()
+
+    def test_index_equals_with_tz(self):
+        left = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+        right = date_range('1/1/2011', periods=100, freq='H',
+                           tz='US/Eastern')
+
+        self.assert_(not left.equals(right))
+
+    def test_tz_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H')
+        ts = Series(1, index=rng)
+
+        result = ts.tz_convert('utc')
+        self.assert_(result.index.tz.zone == 'UTC')
+
+    def test_join_utc_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        left = rng.tz_normalize('US/Eastern')
+        right = rng.tz_normalize('Europe/Berlin')
+
+        for how in ['inner', 'outer', 'left', 'right']:
+            result = left.join(left[:-5], how=how)
+            self.assert_(isinstance(result, DatetimeIndex))
+            self.assert_(result.tz == left.tz)
+
+            result = left.join(right[:-5], how=how)
+            self.assert_(isinstance(result, DatetimeIndex))
+            self.assert_(result.tz.zone == 'UTC')
+
+    def test_arith_utc_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        perm = np.random.permutation(100)[:90]
+        ts1 = Series(np.random.randn(90),
+                     index=rng.take(perm).tz_normalize('US/Eastern'))
+
+        perm = np.random.permutation(100)[:90]
+        ts2 = Series(np.random.randn(90),
+                     index=rng.take(perm).tz_normalize('Europe/Berlin'))
+
+        result = ts1 + ts2
+
+        uts1 = ts1.tz_convert('utc')
+        uts2 = ts2.tz_convert('utc')
+        expected = uts1 + uts2
+
+        self.assert_(result.index.tz == pytz.UTC)
+        assert_series_equal(result, expected)
+
+    def test_intersection(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        left = rng[10:90][::-1]
+        right = rng[20:80][::-1]
+
+        self.assert_(left.tz == rng.tz)
+        result = left.intersection(right)
+        self.assert_(result.tz == left.tz)
+
 class TestLegacyCompat(unittest.TestCase):
 
     def setUp(self):
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index f114a3825..26eb71276 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -40,6 +40,12 @@ def _infer_tzinfo(start, end):
     return tz
 
 
+def _maybe_get_tz(tz):
+    if isinstance(tz, (str, unicode)):
+        import pytz
+        tz = pytz.timezone(tz)
+    return tz
+
 def _figure_out_timezone(start, end, tzinfo):
     inferred_tz = _infer_tzinfo(start, end)
     tz = inferred_tz
@@ -49,9 +55,7 @@ def _figure_out_timezone(start, end, tzinfo):
         assert(inferred_tz == tzinfo)
         # make tz naive for now
 
-    if isinstance(tz, (str, unicode)):
-        import pytz
-        tz = pytz.timezone(tz)
+    tz = _maybe_get_tz(tz)
 
     start = start if start is None else start.replace(tzinfo=None)
     end = end if end is None else end.replace(tzinfo=None)

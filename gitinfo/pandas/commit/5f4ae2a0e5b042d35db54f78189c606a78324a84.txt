commit 5f4ae2a0e5b042d35db54f78189c606a78324a84
Author: Andy Hayden <andyhayden1@gmail.com>
Date:   Sat Jan 5 13:03:20 2013 +0000

    shortened lines over 140 chars where appropriate

diff --git a/bench/bench_join_panel.py b/bench/bench_join_panel.py
index 7979bfff5..0e484fb49 100644
--- a/bench/bench_join_panel.py
+++ b/bench/bench_join_panel.py
@@ -1,4 +1,4 @@
-# reasonably effecient
+# reasonably efficient
 
 
 def create_panels_append(cls, panels):
@@ -36,7 +36,8 @@ def create_panels_append(cls, panels):
         try:
                 values = np.concatenate([p.values for p in panels], axis=1)
         except (Exception), detail:
-                raise Exception("cannot append values that dont' match dimensions! -> [%s] %s" % (','.join(["%s" % p for p in panels]), str(detail)))
+                raise Exception("cannot append values that dont' match dimensions! -> [%s] %s"
+                                % (','.join(["%s" % p for p in panels]), str(detail)))
         # pm('append - create_panel')
         p = Panel(values, items=items, major_axis=major,
                   minor_axis=minor)
@@ -75,7 +76,10 @@ def create_panels_join(cls, panels):
         major = sorted(list(major))
         items = sorted(list(items))
         # create the 3d stack (items x columns x indicies)
-        data = np.dstack([np.asarray([np.asarray([d.get((minor_i, major_i, item), np.nan) for item in items]) for major_i in major]).transpose() for minor_i in minor])
+        data = np.dstack([np.asarray([np.asarray([d.get((minor_i, major_i, item), np.nan)
+                                                  for item in items])
+                                      for major_i in major]).transpose()
+                          for minor_i in minor])
         # construct the panel
         return Panel(data, items, major, minor)
 add_class_method(Panel, create_panels_join, 'join_many')
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 1a62bc2e2..1469620ea 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -517,10 +517,12 @@ class HDFStore(object):
 
         Parameters
         ----------
-        d : a dict of table_name to table_columns, None is acceptable as the values of one node (this will get all the remaining columns)
+        d : a dict of table_name to table_columns, None is acceptable as the values of
+            one node (this will get all the remaining columns)
         value : a pandas object
-        selector : a string that designates the indexable table; all of its columns will be designed as data_columns, unless data_columns is passed,
-                   in which case these are used
+        selector : a string that designates the indexable table; all of its columns will
+                   be designed as data_columns, unless data_columns is passed, in which
+                   case these are used
 
         Notes
         -----
@@ -1051,7 +1053,8 @@ class IndexCol(object):
     is_data_indexable = True
     is_searchable = False
 
-    def __init__(self, values=None, kind=None, typ=None, cname=None, itemsize=None, name=None, axis=None, kind_attr=None, pos=None, **kwargs):
+    def __init__(self, values=None, kind=None, typ=None, cname=None, itemsize=None,
+                 name=None, axis=None, kind_attr=None, pos=None, **kwargs):
         self.values = values
         self.kind = kind
         self.typ = typ
@@ -1182,7 +1185,8 @@ class IndexCol(object):
                 if itemsize is None:
                     itemsize = self.itemsize
                 if c.itemsize < itemsize:
-                    raise Exception("[%s] column has a min_itemsize of [%s] but itemsize [%s] is required!" % (self.cname, itemsize, c.itemsize))
+                    raise Exception("[%s] column has a min_itemsize of [%s] but itemsize [%s] is required!"
+                                    % (self.cname, itemsize, c.itemsize))
                 return c.itemsize
 
         return None
@@ -1524,7 +1528,8 @@ class Table(object):
 
         for c in ['index_axes', 'non_index_axes', 'values_axes']:
             if getattr(self, c, None) != getattr(other, c, None):
-                raise Exception("invalid combinate of [%s] on appending data [%s] vs current table [%s]" % (c, getattr(self, c, None), getattr(other, c, None)))
+                raise Exception("invalid combinate of [%s] on appending data [%s] vs current table [%s]"
+                    % (c, getattr(self, c, None), getattr(other, c, None)))
 
     @property
     def nrows(self):
@@ -1616,7 +1621,8 @@ class Table(object):
         """ are we trying to operate on an old version? """
         if where is not None:
             if self.version[0] <= 0 and self.version[1] <= 10 and self.version[2] < 1:
-                warnings.warn("where criteria is being ignored as we this version is too old (or not-defined) [%s]" % '.'.join([str(x) for x in self.version]), IncompatibilityWarning)
+                warnings.warn("where criteria is being ignored as we this version is too old (or not-defined) [%s]"
+                    % '.'.join([str(x) for x in self.version]), IncompatibilityWarning)
 
     @property
     def indexables(self):
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 90f88573d..1c8ec54b6 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1013,7 +1013,9 @@ class TestHDFStore(unittest.TestCase):
         tm.assert_panel_equal(result, expected)
 
         # p4d
-        result = self.store.select('p4d', [Term('major_axis<20000108'), Term('minor_axis', '=', ['A', 'B']), Term('items', '=', ['ItemA', 'ItemB'])])
+        result = self.store.select('p4d', [Term('major_axis<20000108'),
+                                           Term('minor_axis', '=', ['A', 'B']),
+                                           Term('items', '=', ['ItemA', 'ItemB'])])
         expected = p4d.truncate(after='20000108').reindex(
             minor=['A', 'B'], items=['ItemA', 'ItemB'])
         tm.assert_panel4d_equal(result, expected)

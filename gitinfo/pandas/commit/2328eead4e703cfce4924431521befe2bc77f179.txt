commit 2328eead4e703cfce4924431521befe2bc77f179
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 17 15:21:15 2010 +0000

    fixed issue 9; miscellaneous refactorings and unit tests
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@168 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index b4910a19d..c9341b632 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -153,7 +153,13 @@ class DateOffset(object):
         return self.__add__(other)
 
     def __sub__(self, other):
-        return self.__class__(-self.n, **self.kwds) + other
+        if isinstance(other, datetime):
+            raise Exception('Cannot subtract datetime from offset!')
+        elif type(other) == type(self):
+            return self.__class__(self.n - other.n, **self.kwds)
+        else:
+            raise Exception('Cannot subtract %s from %s'
+                            % (type(other), type(self)))
 
     def __rsub__(self, other):
         return self.__class__(-self.n, **self.kwds) + other
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index da0740337..2f12ecd8a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -74,7 +74,9 @@ class DataFrame(Picklable, Groupable):
         elif isinstance(data, (np.ndarray, list)):
             self._series, self.index = self._initMatrix(data, index,
                                                         columns, dtype)
-
+        elif isinstance(data, DataFrame):
+            self._series = data._series.copy()
+            self.index = data.index
         elif data is None:
             if index is None:
                 index = NULL_INDEX
@@ -87,7 +89,7 @@ class DataFrame(Picklable, Groupable):
             colset = set(columns)
             data = dict((k, v) for k, v in data.iteritems() if k in colset)
 
-        index = self._extract_index(data, index)
+        index = _extract_index(data, index)
 
         series = {}
         for k, v in data.iteritems():
@@ -113,51 +115,6 @@ class DataFrame(Picklable, Groupable):
 
         return series, index
 
-    @staticmethod
-    def _extract_index(data, index):
-        if len(data) == 0:
-            if index is None:
-                index = NULL_INDEX
-        elif len(data) > 0 and index is None:
-            # aggregate union of indices
-            need_labels = False
-
-            # this is pretty kludgy, better way?
-            for k, v in data.iteritems():
-                if isinstance(v, Series):
-                    if index is None:
-                        index = v.index
-                    elif need_labels:
-                        raise Exception('Cannot mix Series / dict objects'
-                                        ' with ndarray / sequence input')
-                    elif not index.equals(v.index):
-                        index = index + v.index
-
-                elif isinstance(v, dict):
-                    if index is None:
-                        index = Index(_try_sort(v))
-                    elif need_labels:
-                        raise Exception('Cannot mix Series / dict objects'
-                                        ' with ndarray / sequence input')
-                    else:
-                        index = index + Index(v.keys())
-
-                else: # not dict-like, assign integer labels
-                    if index is not None and not need_labels:
-                        raise Exception('Cannot mix Series / dict objects'
-                                        ' with ndarray / sequence input')
-
-                    need_labels = True
-                    index = Index(np.arange(len(v)))
-
-        if len(index) == 0 or index is None:
-            index = NULL_INDEX
-
-        if not isinstance(index, Index):
-            index = Index(index)
-
-        return index
-
     def _initMatrix(self, data, index, columns, dtype):
         if not isinstance(data, np.ndarray):
             arr = np.array(data)
@@ -443,8 +400,9 @@ class DataFrame(Picklable, Groupable):
         if len(other) == 0:
             return self * NaN
 
-        if not self:
-            return DataFrame(index=NULL_INDEX)
+        if len(self) == 0:
+            # Ambiguous case
+            return DataFrame(index=self.index, columns=self.cols())
 
         if self.index._allDates and other.index._allDates:
             if self.index.equals(other.index):
@@ -489,18 +447,18 @@ class DataFrame(Picklable, Groupable):
         --------
         frame._combineFunc(otherFrame, lambda x, y: x + y)
         """
-        newColumns = {}
-        newIndex = self.index
-
         if isinstance(other, DataFrame):    # Another DataFrame
             return self._combineFrame(other, func)
         elif isinstance(other, Series):
             return self._combineSeries(other, func)
         else:
+            newColumns = {}
+            newIndex = self.index
+
             for col, series in self.iteritems():
                 newColumns[col] = func(series, other)
 
-        return DataFrame(data=newColumns, index=newIndex)
+            return DataFrame(data=newColumns, index=newIndex)
 
 #-------------------------------------------------------------------------------
 # Public methods
@@ -766,7 +724,7 @@ class DataFrame(Picklable, Groupable):
         if minObs is None:
             minObs = N
 
-        newIndex = self.index[theCount >= N]
+        newIndex = self.index[theCount >= minObs]
         return self.reindex(newIndex)
 
     def fill(self, value=None, method='pad'):
@@ -1808,3 +1766,48 @@ def _try_sort(iterable):
         return sorted(listed)
     except Exception:
         return listed
+
+def _extract_index(data, index):
+    if len(data) == 0:
+        if index is None:
+            index = NULL_INDEX
+    elif len(data) > 0 and index is None:
+        # aggregate union of indices
+        need_labels = False
+
+        # this is pretty kludgy, better way?
+        for v in data.values():
+            if isinstance(v, Series):
+                if index is None:
+                    index = v.index
+                elif need_labels:
+                    raise Exception('Cannot mix Series / dict objects'
+                                    ' with ndarray / sequence input')
+                elif not index.equals(v.index):
+                    index = index + v.index
+
+            elif isinstance(v, dict):
+                if index is None:
+                    index = Index(_try_sort(v))
+                elif need_labels:
+                    raise Exception('Cannot mix Series / dict objects'
+                                    ' with ndarray / sequence input')
+                else:
+                    index = index + Index(v.keys())
+
+            else: # not dict-like, assign integer labels
+                if index is not None and not need_labels:
+                    raise Exception('Cannot mix Series / dict objects'
+                                    ' with ndarray / sequence input')
+
+                need_labels = True
+                index = Index(np.arange(len(v)))
+
+    if len(index) == 0 or index is None:
+        index = NULL_INDEX
+
+    if not isinstance(index, Index):
+        index = Index(index)
+
+    return index
+
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 306dd911e..bc8b0cb33 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -8,7 +8,7 @@ from numpy import NaN
 import numpy as np
 
 from pandas.core.common import _pfixed, _pickle_array, _unpickle_array
-from pandas.core.frame import DataFrame, _try_sort
+from pandas.core.frame import DataFrame, _try_sort, _extract_index
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series
 from pandas.lib.tseries import isnull
@@ -106,7 +106,7 @@ class DataMatrix(DataFrame):
             colset = set(columns)
             data = dict((k, v) for k, v in data.iteritems() if k in colset)
 
-        index = self._extract_index(data, index)
+        index = _extract_index(data, index)
 
         objectDict = {}
         if objects is not None and isinstance(objects, dict):
@@ -391,8 +391,10 @@ class DataMatrix(DataFrame):
         newIndex = self.index
         newCols = self.columns
 
-        if not self:
-            return DataFrame(index=NULL_INDEX)
+        if len(self) == 0:
+            # Ambiguous case
+            return DataMatrix(index=self.index, columns=self.columns,
+                              objects=self.objects)
 
         if self.index._allDates and other.index._allDates:
             # Operate row-wise
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index f951addb4..834e172b5 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -114,7 +114,7 @@ class TestBusinessDay(unittest.TestCase):
         myAssert(self.d - self.offset2,  self.d + BDay(-2))
 
     def testRSub(self):
-        myAssert(self.d - self.offset2, self.offset2 - self.d)
+        myAssert(self.d - self.offset2, (-self.offset2).apply(self.d))
 
     def testMult1(self):
         myAssert(self.d + 10*self.offset, self.d + BDay(10))
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index e85f09dbc..6f0e99e39 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -495,6 +495,11 @@ class TestDataFrame(unittest.TestCase):
         result = self.tsframe[:0] + ts
         self.assertEqual(len(result), 0)
 
+        # empty but with non-empty index
+        frame = self.tsframe[:1].reindex(columns=[])
+        result = frame * ts
+        self.assertEqual(len(result), len(ts))
+
     def test_combineFunc(self):
         result = self.frame * 2
         self.assert_(np.array_equal(result.values, self.frame.values * 2))
@@ -503,7 +508,6 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(result.index is self.empty.index)
         self.assertEqual(len(result.columns), 0)
 
-
     def test_toCSV(self):
         path = '__tmp__'
 
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 2afbd54aa..8c294c654 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -1137,7 +1137,7 @@ def _combine_rhs(rhs):
     if isinstance(rhs, Series):
         series['x'] = rhs
     elif isinstance(rhs, DataFrame):
-        return rhs
+        series = rhs
     elif isinstance(rhs, dict):
         for name, value in rhs.iteritems():
             if isinstance(value, Series):
@@ -1149,6 +1149,9 @@ def _combine_rhs(rhs):
     else:
         raise Exception('Invalid RHS type: %s' % type(rhs))
 
+    if not isinstance(series, DataFrame):
+        series = DataMatrix(series)
+
     return series
 
 def _filter_data(lhs, rhs):
@@ -1170,10 +1173,7 @@ def _filter_data(lhs, rhs):
     if not isinstance(lhs, Series):
         raise Exception('lhs must be a Series')
 
-    combined_rhs = _combine_rhs(rhs)
-
-    if not isinstance(combined_rhs, DataFrame):
-        rhs = DataMatrix(combined_rhs)
+    rhs = _combine_rhs(rhs)
 
     rhs_valid = np.isfinite(rhs.values).sum(1) == len(rhs.columns)
 
diff --git a/pandas/stats/var.py b/pandas/stats/var.py
index 55ca67b7a..b1a8a8745 100644
--- a/pandas/stats/var.py
+++ b/pandas/stats/var.py
@@ -12,13 +12,15 @@ from pandas.stats.math import chain_dot, inv
 from pandas.stats.ols import _combine_rhs
 
 class VAR(object):
-    def __init__(self, data, lags):
+    def __init__(self, data, lags, intercept=True):
         self._data = DataFrame(_combine_rhs(data))
         self._p = lags
 
         self._columns = self._data.columns
         self._index = self._data.index
 
+        self._intercept = intercept
+
     @cache_readonly
     def aic(self):
         """Returns the Akaike information criterion."""
@@ -179,7 +181,7 @@ class VAR(object):
             for col, series in self._lagged_data[i].iteritems():
                 d[_make_param_name(i, col)] = series
 
-        result = dict([(col, ols(y=y, x=d))
+        result = dict([(col, ols(y=y, x=d, intercept=self._intercept))
                        for col, y in self._data.iteritems()])
 
         return result
@@ -230,7 +232,10 @@ BIC:                            %(bic).3f
         Returns array where the i-th element contains the intercept
         when regressing the i-th column of self._data with the lagged data.
         """
-        return self._beta_raw[-1]
+        if self._intercept:
+            return self._beta_raw[-1]
+        else:
+            return np.zeros(self._k)
 
     @cache_readonly
     def _beta_raw(self):
@@ -266,9 +271,7 @@ BIC:                            %(bic).3f
         return result
 
     @cache_readonly
-    def _cov_beta(self):
-        cov_resid = self._sigma
-
+    def _x(self):
         values = np.array([
             self._lagged_data[i][col].values()
             for i in xrange(1, 1 + self._p)
@@ -277,6 +280,14 @@ BIC:                            %(bic).3f
 
         x = np.hstack((np.ones((len(values), 1)), values))[self._p:]
 
+        return x
+
+    @cache_readonly
+    def _cov_beta(self):
+        cov_resid = self._sigma
+
+        x = self._x
+
         inv_cov_x = inv(np.dot(x.T, x))
 
         return np.kron(inv_cov_x, cov_resid)
@@ -288,10 +299,13 @@ BIC:                            %(bic).3f
         return self._data.values[i]
 
     def _forecast_cov_raw(self, n):
-        beta = self._forecast_cov_beta_raw(n)
         resid = self._forecast_cov_resid_raw(n)
+        #beta = self._forecast_cov_beta_raw(n)
+
+        #return [a + b for a, b in izip(resid, beta)]
+        # TODO: ignore the beta forecast std err until it's verified
 
-        return [a + b for a, b in izip(beta, resid)]
+        return resid
 
     def _forecast_cov_beta_raw(self, n):
         """
@@ -462,9 +476,10 @@ class PanelVAR(VAR):
     data: WidePanel or dict of DataFrame
     lags: int
     """
-    def __init__(self, data, lags):
+    def __init__(self, data, lags, intercept=True):
         self._data = PanelVAR._prepare_data(data)
         self._p = lags
+        self._intercept = intercept
 
         self._columns = self._data.items
 

commit 0251f945a82f7faea42f1ed60c3545e156ca72b5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Mar 24 21:47:59 2010 +0000

    test coverage
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@146 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 6fc76b379..b4910a19d 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -372,7 +372,7 @@ class BQuarterEnd(DateOffset):
         self.startingMonth = kwds.get('startingMonth', 3)
 
         if self.startingMonth < 1 or self.startingMonth > 3:
-            raise Exception('Start month must be 1<=day<=12, got %d'
+            raise Exception('Start month must be 1<=day<=3, got %d'
                             % self.startingMonth)
 
         self.offset = BMonthEnd(3)
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 46c0572e9..b346645a1 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -60,7 +60,7 @@ def groupby(obj, grouper):
         klass = DataMatrixGroupBy
     elif isinstance(obj, DataFrame):
         klass = DataFrameGroupBy
-    else:
+    else: # pragma: no cover
         raise TypeError('invalid type: %s' % type(obj))
 
     return klass(obj, grouper)
@@ -75,21 +75,6 @@ class GroupBy(object):
     DataFrame / DataMatrix (and derivatives thereof)
     """
     _groups = None
-    def __new__(cls, obj, grouper):
-        """
-        Intercepts creation and dispatches to the appropriate class based
-        on type.
-        """
-        klass = None
-
-        if isinstance(obj, Series):
-            klass = SeriesGroupBy
-        elif isinstance(obj, DataMatrix):
-            klass = DataMatrixGroupBy
-        elif isinstance(obj, DataFrame):
-            klass = DataFrameGroupBy
-
-        return object.__new__(klass)
 
     def __init__(self, obj, grouper):
         self.obj = obj
@@ -117,7 +102,7 @@ class GroupBy(object):
         """
         try:
             groupNames = sorted(self.groups)
-        except Exception, e:
+        except Exception: # pragma: no cover
             groupNames = self.groups.keys()
 
         for groupName in groupNames:
@@ -133,9 +118,6 @@ class GroupBy(object):
     def transform(self, func):
         raise NotImplementedError
 
-    def apply(self, func):
-        return self.transform(func)
-
     def __getitem__(self, key):
         return self.getGroup(self.groups[key])
 
@@ -160,25 +142,24 @@ class SeriesGroupBy(GroupBy):
         -------
         Series or DataFrame
         """
-        from pandas.lib.tseries import groupbyfunc as groupby
+        from pandas.lib.tseries import groupbyfunc
 
         if hasattr(applyfunc,'__iter__'):
-            results = {}
 
-            for func in applyfunc:
-                result = self.aggregate(func)
+            if not isinstance(applyfunc, dict):
+                applyfunc = dict((func.__name__, func) for func in applyfunc)
 
-                if isinstance(result, Series):
-                    raise Exception('Given applyfunc did not return a value '
-                                    'from the subseries as expected!')
+            results = {}
 
-                results[func.__name__] = result
+            for name, func in applyfunc.iteritems():
+                result = self.aggregate(func)
+                results[name] = result
 
             retVal = DataFrame(results)
         else:
             try:
-                result = groupby(self.obj.index, self.obj,
-                                 self.grouper, applyfunc)
+                result = groupbyfunc(self.obj.index, self.obj,
+                                     self.grouper, applyfunc)
             except Exception:
                 result = {}
                 theUnion = set([])
@@ -250,15 +231,10 @@ class SeriesGroupBy(GroupBy):
 
 class DataFrameGroupBy(GroupBy):
     def __init__(self, obj, grouper):
-        self.obj = obj
-
-        if hasattr(grouper, 'get'):
-            grouper = grouper.get
-
         if isinstance(grouper, basestring) and grouper in obj:
             grouper = obj[grouper].get
 
-        self.grouper = grouper
+        GroupBy.__init__(self, obj, grouper)
 
     def aggregate(self, applyfunc):
         """
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 01da4707e..f26481ea8 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -1177,9 +1177,15 @@ class DataMatrix(DataFrame):
             newValues = self.values.copy()
 
         if self.objects is not None:
-            pass
+            shifted_objects = self.objects.shift(periods, offset=offset,
+                                                 timeRule=timeRule)
+
+            shifted_objects.index = newIndex
+        else:
+            shifted_objects = None
 
-        return DataMatrix(data=newValues, index=newIndex, columns=self.columns)
+        return DataMatrix(data=newValues, index=newIndex, columns=self.columns,
+                          objects=shifted_objects)
 
     def apply(self, func, axis=0):
         """
diff --git a/pandas/core/mixins.py b/pandas/core/mixins.py
index 208723681..0f0ccb583 100644
--- a/pandas/core/mixins.py
+++ b/pandas/core/mixins.py
@@ -24,6 +24,7 @@ class Picklable(object):
 
 
 class Groupable(object):
+
     def groupby(self, mapper):
         """
         Goup series using mapper (dict or key function, apply given
@@ -41,7 +42,5 @@ class Groupable(object):
         GroupBy object
         """
 
-        from pandas.core.groupby import GroupBy
-        return GroupBy(self, mapper)
-
-
+        from pandas.core.groupby import groupby
+        return groupby(self, mapper)
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index 25fcb7616..ed10c21f2 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -197,6 +197,16 @@ def assertOnOffset(offset, date, expected):
     assert actual == expected
 
 class TestWeek(unittest.TestCase):
+    def test_corner(self):
+        self.assertRaises(Exception, Week, weekday=7)
+        self.assertRaises(Exception, Week, weekday=-1)
+
+    def test_isAnchored(self):
+        self.assert_(Week(weekday=0).isAnchored())
+        self.assert_(not Week().isAnchored())
+        self.assert_(not Week(2, weekday=2).isAnchored())
+        self.assert_(not Week(2).isAnchored())
+
     def test_offset(self):
         tests = []
 
@@ -385,6 +395,15 @@ class TestMonthEnd(unittest.TestCase):
             assertOnOffset(offset, date, expected)
 
 class TestBQuarterEnd(unittest.TestCase):
+    def test_corner(self):
+        self.assertRaises(Exception, BQuarterEnd, startingMonth=4)
+        self.assertRaises(Exception, BQuarterEnd, startingMonth=-1)
+
+    def test_isAnchored(self):
+        self.assert_(BQuarterEnd(startingMonth=1).isAnchored())
+        self.assert_(BQuarterEnd().isAnchored())
+        self.assert_(not BQuarterEnd(2, startingMonth=1).isAnchored())
+
     def test_offset(self):
         tests = []
 
@@ -441,6 +460,10 @@ class TestBQuarterEnd(unittest.TestCase):
             for baseDate, expected in cases.iteritems():
                 assertEq(dateOffset, baseDate, expected)
 
+        # corner
+        offset = BQuarterEnd(n=-1, startingMonth=1)
+        self.assertEqual(datetime(2010, 1, 31) + offset, datetime(2010, 1, 29))
+
     def test_onOffset(self):
 
         tests = [(BQuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
@@ -701,6 +724,10 @@ def test_inferTimeRule():
     assert_raises(Exception, datetools.inferTimeRule, index1[:2])
     assert_raises(Exception, datetools.inferTimeRule, index3)
 
+def test_hasOffsetName():
+    assert datetools.hasOffsetName(BDay())
+    assert not datetools.hasOffsetName(BDay(2))
+
 def test_getOffsetName():
     assert_raises(Exception, datetools.getOffsetName, BDay(2))
 
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index ae9896db6..a09b2582b 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -139,8 +139,13 @@ class TestDataMatrix(test_frame.TestDataFrame):
         dm['A'] = 'bar'
         self.assertEqual('bar', dm['A'][0])
 
-    def test_more_fromDict(self):
-        pass
+    def test_shift_objects(self):
+        tsf = self.tsframe.copy()
+        tsf['foo'] = 'bar'
+
+        shifted = tsf.shift(1)
+        self.assert_(shifted.objects is not None)
+        self.assert_(shifted.objects.index is shifted.index)
 
     def test_more_asMatrix(self):
         values = self.mixed_frame.asMatrix()
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index f3a7f9b2e..7ce1e803a 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -734,5 +734,39 @@ class TestSeries(unittest.TestCase):
     def test_lastValid(self):
         pass
 
+#-------------------------------------------------------------------------------
+# GroupBy
+
+    def test_groupby(self):
+        data = Series(np.arange(9) / 3, index=np.arange(9))
+
+        index = np.arange(9)
+        np.random.shuffle(index)
+        data = data.reindex(index)
+
+        grouped = data.groupby(lambda x: x // 3)
+
+        repr(grouped.groups) # nothing else here
+
+        for k, v in grouped:
+            self.assertEqual(len(v), 3)
+
+        agged = grouped.aggregate(np.mean)
+        self.assertEqual(agged[1], 1)
+
+        assert_series_equal(agged, grouped.agg(np.mean)) # shorthand
+
+        transformed = grouped.transform(lambda x: x * x.sum())
+        self.assertEqual(transformed[7], 12)
+
+        value_grouped = data.groupby(data)
+        assert_series_equal(value_grouped.aggregate(np.mean), agged)
+
+        # complex agg
+        agged = grouped.aggregate([np.mean, np.std])
+        agged = grouped.aggregate({'one' : np.mean,
+                                   'two' : np.std})
+
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 76b19be00..fa709355c 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -16,6 +16,8 @@ import pandas.lib.tseries as tseries
 import pandas.stats.common as common
 import pandas.stats.math as math
 
+_FP_ERR = 1e-13
+
 class OLS(object):
     """
     Runs a full sample ordinary least squares regression

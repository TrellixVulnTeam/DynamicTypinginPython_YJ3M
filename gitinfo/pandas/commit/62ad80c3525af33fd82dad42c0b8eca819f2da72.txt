commit 62ad80c3525af33fd82dad42c0b8eca819f2da72
Author: Kieran O'Mahony <kieranom@gmail.com>
Date:   Mon May 28 13:34:00 2012 +0100

    ujson Python 3 support

diff --git a/pandas/src/ujson/python/JSONtoObj.c b/pandas/src/ujson/python/JSONtoObj.c
index 8a72164db..0f58ca060 100644
--- a/pandas/src/ujson/python/JSONtoObj.c
+++ b/pandas/src/ujson/python/JSONtoObj.c
@@ -1,4 +1,4 @@
-#include <Python.h>
+#include "py_defines.h"
 #define PY_ARRAY_UNIQUE_SYMBOL UJSON_NUMPY
 #define NO_IMPORT_ARRAY
 #include <numpy/arrayobject.h>
diff --git a/pandas/src/ujson/python/objToJSON.c b/pandas/src/ujson/python/objToJSON.c
index 5efffee89..fa4de44bb 100644
--- a/pandas/src/ujson/python/objToJSON.c
+++ b/pandas/src/ujson/python/objToJSON.c
@@ -1,6 +1,6 @@
 #define PY_ARRAY_UNIQUE_SYMBOL UJSON_NUMPY
 
-#include <Python.h>
+#include "py_defines.h"
 #include <numpy/arrayobject.h>
 #include <np_datetime.h>
 #include <numpy/halffloat.h>
@@ -8,8 +8,6 @@
 #include <datetime.h>
 #include <ultrajson.h>
 
-#define EPOCH_ORD 719163
-
 #define NPY_JSON_BUFSIZE 32768
 
 static PyObject* cls_dataframe;
@@ -173,7 +171,7 @@ static void *PyStringToUTF8(JSOBJ _obj, JSONTypeContext *tc, void *outValue, siz
 static void *PyUnicodeToUTF8(JSOBJ _obj, JSONTypeContext *tc, void *outValue, size_t *_outLen)
 {
     PyObject *obj = (PyObject *) _obj;
-    PyObject *newObj = PyUnicode_EncodeUTF8 (PyUnicode_AS_UNICODE(obj), PyUnicode_GET_SIZE(obj), NULL);
+    PyObject *newObj = PyUnicode_AsUTF8String (obj);
 
     GET_TC(tc)->newObj = newObj;
 
@@ -481,6 +479,12 @@ void Dir_iterEnd(JSOBJ obj, JSONTypeContext *tc)
         GET_TC(tc)->itemValue = NULL;
     }
 
+    if (GET_TC(tc)->itemName)
+    {
+        Py_DECREF(GET_TC(tc)->itemName);
+        GET_TC(tc)->itemName = NULL;
+    }
+
     Py_DECREF( (PyObject *) GET_TC(tc)->attrList);
     PRINTMARK();
 }
@@ -489,8 +493,9 @@ int Dir_iterNext(JSOBJ _obj, JSONTypeContext *tc)
 {
     PyObject *obj = (PyObject *) _obj;
     PyObject *itemValue = GET_TC(tc)->itemValue;
-    PyObject *itemName = NULL;
+    PyObject *itemName = GET_TC(tc)->itemName;
     PyObject* attr;
+    PyObject* attrName;
     char* attrStr;
 
 
@@ -500,21 +505,35 @@ int Dir_iterNext(JSOBJ _obj, JSONTypeContext *tc)
         GET_TC(tc)->itemValue = itemValue = NULL;
     }
 
+    if (itemName)
+    {
+        Py_DECREF(GET_TC(tc)->itemName);
+        GET_TC(tc)->itemName = itemName = NULL;
+    }
+
     for (; GET_TC(tc)->index  < GET_TC(tc)->size; GET_TC(tc)->index ++)
     {
-        attr = PyList_GET_ITEM(GET_TC(tc)->attrList, GET_TC(tc)->index);
+        attrName = PyList_GET_ITEM(GET_TC(tc)->attrList, GET_TC(tc)->index);
+#if PY_MAJOR_VERSION >= 3
+        attr = PyUnicode_AsUTF8String(attrName);
+#else 
+        attr = attrName;
+        Py_INCREF(attr);
+#endif
         attrStr = PyString_AS_STRING(attr);
 
         if (attrStr[0] == '_')
         {
             PRINTMARK();
+            Py_DECREF(attr);
             continue;
         }
 
-        itemValue = PyObject_GetAttr(obj, attr);
+        itemValue = PyObject_GetAttr(obj, attrName);
         if (itemValue == NULL)
         {
             PyErr_Clear();
+            Py_DECREF(attr);
             PRINTMARK();
             continue;
         }
@@ -522,6 +541,7 @@ int Dir_iterNext(JSOBJ _obj, JSONTypeContext *tc)
         if (PyCallable_Check(itemValue))
         {
             Py_DECREF(itemValue);
+            Py_DECREF(attr);
             PRINTMARK();
             continue;
         }
@@ -832,6 +852,10 @@ void Dict_iterBegin(JSOBJ obj, JSONTypeContext *tc)
 
 int Dict_iterNext(JSOBJ obj, JSONTypeContext *tc)
 {
+#if PY_MAJOR_VERSION >= 3
+    PyObject* itemNameTmp;
+#endif
+
     if (GET_TC(tc)->itemName)
     {
         Py_DECREF(GET_TC(tc)->itemName);
@@ -847,16 +871,17 @@ int Dict_iterNext(JSOBJ obj, JSONTypeContext *tc)
 
     if (PyUnicode_Check(GET_TC(tc)->itemName))
     {
-        GET_TC(tc)->itemName = PyUnicode_EncodeUTF8 (
-            PyUnicode_AS_UNICODE(GET_TC(tc)->itemName),
-            PyUnicode_GET_SIZE(GET_TC(tc)->itemName),
-            NULL
-        );
+        GET_TC(tc)->itemName = PyUnicode_AsUTF8String (GET_TC(tc)->itemName);
     }
     else
     if (!PyString_Check(GET_TC(tc)->itemName))
     {
         GET_TC(tc)->itemName = PyObject_Str(GET_TC(tc)->itemName);
+#if PY_MAJOR_VERSION >= 3
+        itemNameTmp = GET_TC(tc)->itemName; 
+        GET_TC(tc)->itemName = PyUnicode_AsUTF8String (GET_TC(tc)->itemName);
+        Py_DECREF(itemNameTmp);
+#endif
     }
     else
     {
@@ -1035,17 +1060,6 @@ void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
         return;
     }
     else
-    if (PyInt_Check(obj))
-    {
-        PRINTMARK();
-#ifdef _LP64
-        pc->PyTypeToJSON = PyIntToINT64; tc->type = JT_LONG;
-#else
-        pc->PyTypeToJSON = PyIntToINT32; tc->type = JT_INT;
-#endif
-        return;
-    }
-    else
     if (PyLong_Check(obj))
     {
         PRINTMARK();
@@ -1065,6 +1079,17 @@ void Object_beginTypeContext (JSOBJ _obj, JSONTypeContext *tc)
         return;
     }
     else
+    if (PyInt_Check(obj))
+    {
+        PRINTMARK();
+#ifdef _LP64
+        pc->PyTypeToJSON = PyIntToINT64; tc->type = JT_LONG;
+#else
+        pc->PyTypeToJSON = PyIntToINT32; tc->type = JT_INT;
+#endif
+        return;
+    }
+    else
     if (PyArray_IsScalar(obj, Integer))
     {
         PRINTMARK();
diff --git a/pandas/src/ujson/python/py_defines.h b/pandas/src/ujson/python/py_defines.h
index e00fd1508..1544c2e3c 100644
--- a/pandas/src/ujson/python/py_defines.h
+++ b/pandas/src/ujson/python/py_defines.h
@@ -1,24 +1,15 @@
 #include <Python.h>
 
 #if PY_MAJOR_VERSION >= 3
-#define PyIntObject                  PyLongObject
-#define PyInt_Type                   PyLong_Type
-#define PyInt_Check(op)              PyLong_Check(op)
-#define PyInt_CheckExact(op)         PyLong_CheckExact(op)
-#define PyInt_FromString             PyLong_FromString
-#define PyInt_FromUnicode            PyLong_FromUnicode
-#define PyInt_FromLong               PyLong_FromLong
-#define PyInt_FromSize_t             PyLong_FromSize_t
-#define PyInt_FromSsize_t            PyLong_FromSsize_t
-#define PyInt_AsLong                 PyLong_AsLong
-#define PyInt_AS_LONG                PyLong_AS_LONG
-#define PyInt_AsSsize_t              PyLong_AsSsize_t
-#define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
-#define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
 
-#define PyString_Check       PyUnicode_Check
-#define PyString_GET_SIZE    PyBytes_GET_SIZE
-#define PyString_AS_STRING   PyBytes_AS_STRING
-#define PyString_FromString  PyUnicode_FromString
+#define PyInt_Check             PyLong_Check
+#define PyInt_AS_LONG           PyLong_AsLong
+#define PyInt_FromLong          PyLong_FromLong
+
+#define PyString_Check          PyBytes_Check
+#define PyString_GET_SIZE       PyBytes_GET_SIZE
+#define PyString_AS_STRING      PyBytes_AS_STRING
+
+#define PyString_FromString     PyUnicode_FromString
 
 #endif
diff --git a/pandas/src/ujson/python/ujson.c b/pandas/src/ujson/python/ujson.c
index b7c5e0c9f..c9493d477 100644
--- a/pandas/src/ujson/python/ujson.c
+++ b/pandas/src/ujson/python/ujson.c
@@ -1,4 +1,4 @@
-#include <Python.h>
+#include "py_defines.h"
 #include "version.h"
 
 /* objToJSON */
@@ -25,17 +25,49 @@ static PyMethodDef ujsonMethods[] = {
     {NULL, NULL, 0, NULL}       /* Sentinel */
 };
 
+#if PY_MAJOR_VERSION >= 3
 
+static struct PyModuleDef moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "_ujson",
+    0,              /* m_doc */
+    -1,             /* m_size */
+    ujsonMethods,   /* m_methods */
+    NULL,           /* m_reload */
+    NULL,           /* m_traverse */
+    NULL,           /* m_clear */
+    NULL            /* m_free */
+};
+
+#define PYMODINITFUNC       PyObject *PyInit__ujson(void)
+#define PYMODULE_CREATE()   PyModule_Create(&moduledef)
+#define MODINITERROR        return NULL
+
+#else
+
+#define PYMODINITFUNC       PyMODINIT_FUNC init_ujson(void)
+#define PYMODULE_CREATE()   Py_InitModule("_ujson", ujsonMethods)
+#define MODINITERROR        return
 
-PyMODINIT_FUNC
-init_ujson(void)
+#endif
+
+PYMODINITFUNC
 {
     PyObject *module;
     PyObject *version_string;
 
-    initObjToJSON();
-    module = Py_InitModule("_ujson", ujsonMethods);
+    initObjToJSON();   
+    module = PYMODULE_CREATE();
+
+    if (module == NULL)
+    {
+        MODINITERROR;
+    }
 
     version_string = PyString_FromString (UJSON_VERSION);
     PyModule_AddObject (module, "__version__", version_string);
+
+#if PY_MAJOR_VERSION >= 3
+    return module;
+#endif
 }
diff --git a/pandas/tests/test_ujson.py b/pandas/tests/test_ujson.py
index ab441fce7..2375f7585 100644
--- a/pandas/tests/test_ujson.py
+++ b/pandas/tests/test_ujson.py
@@ -8,6 +8,7 @@ try:
 except ImportError:
     import simplejson as json
 import math
+import nose
 import platform
 import sys
 import time
@@ -15,6 +16,7 @@ import datetime
 import calendar
 import StringIO
 import re
+from functools import partial
 
 import numpy as np
 from numpy.testing import (assert_array_equal, assert_array_almost_equal_nulp,
@@ -23,12 +25,15 @@ from pandas import DataFrame, Series, Index
 import pandas.util.testing as tm
 
 
-def _skip_if_python25():
-    import nose
+def _skip_if_python_ver(skip_major, skip_minor=None):
     major, minor = sys.version_info[:2]
-    if major == 2 and minor == 5:
+    if major == skip_major and (skip_minor is None or minor == skip_minor):
         raise nose.SkipTest
-        
+
+json_unicode = (json.dumps if sys.version_info[0] >= 3
+                else partial(json.dumps, encoding="utf-8"))
+
+
 class UltraJSONTests(TestCase):
     def test_encodeDictWithUnicodeKeys(self):
         input = { u"key1": u"value1", u"key1": u"value1", u"key1": u"value1", u"key1": u"value1", u"key1": u"value1", u"key1": u"value1" }
@@ -124,7 +129,7 @@ class UltraJSONTests(TestCase):
         input = "Räksmörgås اسامة بن محمد بن عوض بن لادن"
         enc = ujson.encode(input)
         dec = ujson.decode(enc)
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
         self.assertEquals(dec, json.loads(enc))
 
     def test_encodeControlEscaping(self):
@@ -132,42 +137,45 @@ class UltraJSONTests(TestCase):
         enc = ujson.encode(input)
         dec = ujson.decode(enc)
         self.assertEquals(input, dec)
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
 
 
     def test_encodeUnicodeConversion2(self):
         input = "\xe6\x97\xa5\xd1\x88"
         enc = ujson.encode(input)
         dec = ujson.decode(enc)
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
         self.assertEquals(dec, json.loads(enc))
 
     def test_encodeUnicodeSurrogatePair(self):
-        _skip_if_python25()
+        _skip_if_python_ver(2, 5)
+        _skip_if_python_ver(2, 6)
         input = "\xf0\x90\x8d\x86"
         enc = ujson.encode(input)
         dec = ujson.decode(enc)
 
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
         self.assertEquals(dec, json.loads(enc))
 
     def test_encodeUnicode4BytesUTF8(self):
-        _skip_if_python25()
+        _skip_if_python_ver(2, 5)
+        _skip_if_python_ver(2, 6)
         input = "\xf0\x91\x80\xb0TRAILINGNORMAL"
         enc = ujson.encode(input)
         dec = ujson.decode(enc)
 
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
         self.assertEquals(dec, json.loads(enc))
 
     def test_encodeUnicode4BytesUTF8Highest(self):
-        _skip_if_python25()
+        _skip_if_python_ver(2, 5)
+        _skip_if_python_ver(2, 6)
         input = "\xf3\xbf\xbf\xbfTRAILINGNORMAL"
         enc = ujson.encode(input)
 
         dec = ujson.decode(enc)
 
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8"))
+        self.assertEquals(enc, json_unicode(input))
         self.assertEquals(dec, json.loads(enc))
 
 
@@ -281,11 +289,11 @@ class UltraJSONTests(TestCase):
         self.assert_(roundtrip == stamp.value)
 
     def test_encodeToUTF8(self):
-        _skip_if_python25()    
+        _skip_if_python_ver(2, 5)
         input = "\xe6\x97\xa5\xd1\x88"
         enc = ujson.encode(input, ensure_ascii=False)
         dec = ujson.decode(enc)
-        self.assertEquals(enc, json.dumps(input, encoding="utf-8", ensure_ascii=False))
+        self.assertEquals(enc, json_unicode(input, ensure_ascii=False))
         self.assertEquals(dec, json.loads(enc))
 
     def test_decodeFromUnicode(self):
@@ -500,6 +508,7 @@ class UltraJSONTests(TestCase):
         self.assertEquals (-31337, ujson.decode(input))
 
     def test_encodeUnicode4BytesUTF8Fail(self):
+        _skip_if_python_ver(3)
         input = "\xfd\xbf\xbf\xbf\xbf\xbf"
         try:
             enc = ujson.encode(input)
@@ -534,7 +543,8 @@ class UltraJSONTests(TestCase):
         output = ujson.encode(input)
         self.assertEquals(input, json.loads(output))
         self.assertEquals(input, ujson.decode(output))
-        assert_array_equal(np.array(input), ujson.decode(output, numpy=True))
+        assert_array_equal(np.array(input), ujson.decode(output, numpy=True,
+                                                         dtype=np.int64))
         pass
 
     def test_encodeLongConversion(self):

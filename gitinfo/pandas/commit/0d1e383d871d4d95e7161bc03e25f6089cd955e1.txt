commit 0d1e383d871d4d95e7161bc03e25f6089cd955e1
Author: Jeff Tratner <jeffrey.tratner@gmail.com>
Date:   Tue Nov 5 00:20:07 2013 -0500

    CLN: Mode result needs to be sorted, otherwise hit weirdness with hashing

diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 8c15fbd9a..6ab6f15aa 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -3,6 +3,7 @@ Generic data algorithms. This module is experimental at the moment and not
 intended for public consumption
 """
 
+from warnings import warn
 import numpy as np
 
 import pandas.core.common as com
@@ -222,6 +223,8 @@ def value_counts(values, sort=True, ascending=False, normalize=False, bins=None)
 
 
 def mode(values):
+    "Returns the mode or mode(s) of the passed Series or ndarray (sorted)"
+    # must sort because hash order isn't necessarily defined.
     from pandas.core.series import Series
 
     if isinstance(values, Series):
@@ -234,17 +237,22 @@ def mode(values):
     dtype = values.dtype
     if com.is_integer_dtype(values.dtype):
         values = com._ensure_int64(values)
-        result = constructor(htable.mode_int64(values), dtype=dtype)
+        result = constructor(sorted(htable.mode_int64(values)), dtype=dtype)
 
     elif issubclass(values.dtype.type, (np.datetime64,np.timedelta64)):
         dtype = values.dtype
         values = values.view(np.int64)
-        result = constructor(htable.mode_int64(values), dtype=dtype)
+        result = constructor(sorted(htable.mode_int64(values)), dtype=dtype)
 
     else:
         mask = com.isnull(values)
         values = com._ensure_object(values)
-        result = constructor(htable.mode_object(values, mask), dtype=dtype)
+        res = htable.mode_object(values, mask)
+        try:
+            res = sorted(res)
+        except TypeError as e:
+            warn("Unable to sort modes: %s" % e)
+        result = constructor(res, dtype=dtype)
 
     return result
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 44e82595d..1cb0c4adc 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -4096,6 +4096,10 @@ class DataFrame(NDFrame):
             1/'columns' : get mode of each row
         numeric_only : bool, default False
             if True, only apply to numeric columns
+
+        Returns
+        -------
+        modes : DataFrame (sorted)
         """
         data = self if not numeric_only else self._get_numeric_data()
         f = lambda s: s.mode()
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 8381d0728..3fe9540ba 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1133,9 +1133,15 @@ class Series(generic.NDFrame):
         Empty if nothing occurs at least 2 times.  Always returns Series even
         if only one value.
 
+        Parameters
+        ----------
+        sort : bool, default True
+            if True, will lexicographically sort values, if False skips
+            sorting. Result ordering when ``sort=False`` is not defined.
+
         Returns
         -------
-        modes : Series
+        modes : Series (sorted)
         """
         # TODO: Add option for bins like value_counts()
         from pandas.core.algorithms import mode
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index ca3d3c836..e0abe7700 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -10052,28 +10052,38 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
     def test_mode(self):
         df = pd.DataFrame({"A": [12, 12, 11, 12, 19, 11],
-                           "B": [10, 10, 10, 5, 3, 4],
+                           "B": [10, 10, 10, np.nan, 3, 4],
                            "C": [8, 8, 8, 9, 9, 9],
-                           "D": range(6)})
+                           "D": range(6),
+                           "E": [8, 8, 1, 1, 3, 3]})
         assert_frame_equal(df[["A"]].mode(),
                            pd.DataFrame({"A": [12]}))
         assert_frame_equal(df[["D"]].mode(),
                            pd.DataFrame(pd.Series([], dtype="int64"),
                                         columns=["D"]))
+        assert_frame_equal(df[["E"]].mode(),
+                           pd.DataFrame(pd.Series([1, 3, 8], dtype="int64"),
+                                        columns=["E"]))
         assert_frame_equal(df[["A", "B"]].mode(),
-                           pd.DataFrame({"A": [12], "B": [10]}))
+                           pd.DataFrame({"A": [12], "B": [10.]}))
         assert_frame_equal(df.mode(),
-                           pd.DataFrame({"A": [12, np.nan],
-                                         "B": [10, np.nan],
-                                         "C": [8, 9],
-                                         "D": [np.nan, np.nan]}))
+                           pd.DataFrame({"A": [12, np.nan, np.nan],
+                                         "B": [10, np.nan, np.nan],
+                                         "C": [8, 9, np.nan],
+                                         "D": [np.nan, np.nan, np.nan],
+                                         "E": [1, 3, 8]}))
 
-        # should preserve order
+        # outputs in sorted order
         df["C"] = list(reversed(df["C"]))
-        assert_frame_equal(df[["A", "B", "C"]].mode(),
+        print(df["C"])
+        print(df["C"].mode())
+        a, b = (df[["A", "B", "C"]].mode(),
                            pd.DataFrame({"A": [12, np.nan],
                                          "B": [10, np.nan],
-                                         "C": [9, 8]}))
+                                         "C": [8, 9]}))
+        print(a)
+        print(b)
+        assert_frame_equal(a, b)
         # should work with heterogeneous types
         df = pd.DataFrame({"A": range(6),
                            "B": pd.date_range('2011', periods=6),

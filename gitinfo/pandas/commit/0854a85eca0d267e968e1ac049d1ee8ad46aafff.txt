commit 0854a85eca0d267e968e1ac049d1ee8ad46aafff
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 14 10:29:37 2011 -0400

    CRLF fix, optimization

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index fddd80e6f..51131e2f1 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -1,700 +1,704 @@
-"""A collection of random tools for dealing with dates in Python"""
-
-from datetime import datetime, timedelta
-
-try:
-    from dateutil import parser
-    from dateutil.relativedelta import relativedelta
-except ImportError: # pragma: no cover
-    print 'Please install python-dateutil via easy_install or some method!'
-
-import calendar
-
-#-------------------------------------------------------------------------------
-# Miscellaneous date functions
-
-def format(dt):
-    """Returns date in YYYYMMDD format."""
-    return dt.strftime('%Y%m%d')
-
-OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
-
-def ole2datetime(oledt):
-    """function for converting excel date to normal date format"""
-    val = float(oledt)
-
-    # Excel has a bug where it thinks the date 2/29/1900 exists
-    # we just reject any date before 3/1/1900.
-    if val < 61:
-        raise Exception("Value is outside of acceptable range: %s " % val)
-
-    return OLE_TIME_ZERO + timedelta(days=val)
-
-def to_datetime(arg):
-    """Attempts to convert arg to datetime"""
-    if arg is None or isinstance(arg, datetime):
-        return arg
-    try:
-        return parser.parse(arg)
-    except Exception:
-        return arg
-
-def normalize_date(dt):
-    return datetime(dt.year, dt.month, dt.day)
-
-#-------------------------------------------------------------------------------
-# DateOffset
-
-class CacheableOffset(object):
-    pass
-
-class DateOffset(object):
-    """
-    Standard kind of date increment used for a date range.
-
-    Works exactly like relativedelta in terms of the keyword args you
-    pass in, use of the keyword n is discouraged-- you would be better
-    off specifying n in the keywords you use, but regardless it is
-    there for you. n is needed for DateOffset subclasses.
-
-    DateOffets work as follows.  Each offset specify a set of dates
-    that conform to the DateOffset.  For example, Bday defines this
-    set to be the set of dates that are weekdays (M-F).  To test if a
-    date is in the set of a DateOffset dateOffset we can use the
-    onOffset method: dateOffset.onOffset(date).
-
-    If a date is not on a valid date, the rollback and rollforward
-    methods can be used to roll the date to the nearest valid date
-    before/after the date.
-
-    DateOffsets can be created to move dates forward a given number of
-    valid dates.  For example, Bday(2) can be added to a date to move
-    it two business days forward.  If the date does not start on a
-    valid date, first it is moved to a valid date.  Thus psedo code
-    is:
-
-    def __add__(date):
-      date = rollback(date) # does nothing is date is valid
-      return date + <n number of periods>
-
-    When a date offset is created for a negitive number of periods,
-    the date is first rolled forward.  The pseudo code is:
-
-    def __add__(date):
-      date = rollforward(date) # does nothing is date is valid
-      return date + <n number of periods>
-
-    Zero presents a problem.  Should it roll forward or back?  We
-    arbitrarily have it rollforward:
-
-    date + BDay(0) == BDay.rollforward(date)
-
-    Since 0 is a bit weird, we suggest avoiding its use.
-    """
-    # For some offsets, want to drop the time information off the
-    # first date
-    _normalizeFirst = False
-    def __init__(self, n=1, **kwds):
-        self.n = int(n)
-        self.kwds = kwds
-
-    def apply(self, other):
-        if len(self.kwds) > 0:
-            if self.n > 0:
-                for i in xrange(self.n):
-                    other = other + relativedelta(**self.kwds)
-            else:
-                for i in xrange(-self.n):
-                    other = other - relativedelta(**self.kwds)
-            return other
-        else:
-            return other + timedelta(self.n)
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def copy(self):
-        return self.__class__(self.n, **self.kwds)
-
-    def _params(self):
-        attrs = sorted((item for item in self.__dict__.iteritems()
-                        if item[0] != 'kwds'))
-        params = tuple([str(self.__class__)] + attrs)
-        return params
-
-    def __repr__(self):
-        className = getattr(self, '_outputName', type(self).__name__)
-        exclude = set(['n', 'inc'])
-        attrs = []
-        for attr in self.__dict__:
-            if ((attr == 'kwds' and len(self.kwds) == 0)
-                or attr.startswith('_')):
-                continue
-            if attr not in exclude:
-                attrs.append('='.join((attr, repr(getattr(self, attr)))))
-
-        if abs(self.n) != 1:
-            plural = 's'
-        else:
-            plural = ''
-
-        out = '<%s ' % self.n + className + plural
-        if attrs:
-            out += ': ' + ', '.join(attrs)
-        out += '>'
-        return out
-
-    def __eq__(self, other):
-        return self._params() == other._params()
-
-    def __hash__(self):
-        return hash(self._params())
-
-    def __call__(self, other):
-        return self.apply(other)
-
-    def __add__(self, other):
-        return self.apply(other)
-
-    def __radd__(self, other):
-        return self.__add__(other)
-
-    def __sub__(self, other):
-        if isinstance(other, datetime):
-            raise TypeError('Cannot subtract datetime from offset!')
-        elif type(other) == type(self):
-            return self.__class__(self.n - other.n, **self.kwds)
-        else: # pragma: no cover
-            raise TypeError('Cannot subtract %s from %s'
-                            % (type(other), type(self)))
-
-    def __rsub__(self, other):
-        return self.__class__(-self.n, **self.kwds) + other
-
-    def __mul__(self, someInt):
-        return self.__class__(n=someInt * self.n, **self.kwds)
-
-    def __rmul__(self, someInt):
-        return self.__mul__(someInt)
-
-    def __neg__(self):
-        return self.__class__(-self.n, **self.kwds)
-
-    def rollback(self, someDate):
-        """Roll provided date backward to next offset only if not on offset"""
-        if self._normalizeFirst:
-            someDate = normalize_date(someDate)
-
-        if not self.onOffset(someDate):
-            someDate = someDate - self.__class__(1, **self.kwds)
-        return someDate
-
-    def rollforward(self, someDate):
-        """Roll provided date forward to next offset only if not on offset"""
-        if self._normalizeFirst:
-            someDate = normalize_date(someDate)
-
-        if not self.onOffset(someDate):
-            someDate = someDate + self.__class__(1, **self.kwds)
-        return someDate
-
-    def onOffset(self, someDate):
-        # Default (slow) method for determining if some date is a
-        # member of the DateRange generated by this offset. Subclasses
-        # may have this re-implemented in a nicer way.
-        return someDate == ((someDate + self) - self)
-
-
-class BDay(DateOffset, CacheableOffset):
-    """
-    DateOffset subclass representing possibly n business days
-    """
-    _normalizeFirst = True
-    _outputName = 'BusinessDay'
-    def __init__(self, n=1, **kwds):
-        self.n = int(n)
-        self.kwds = kwds
-        self.offset = kwds.get('offset', timedelta(0))
-        self.normalize = kwds.get('normalize', True)
-
-    def __repr__(self):
-        className = getattr(self, '_outputName', self.__class__.__name__)
-        attrs = []
-
-        if self.offset:
-            attrs = ['offset=%s' % repr(self.offset)]
-
-        if abs(self.n) != 1:
-            plural = 's'
-        else:
-            plural = ''
-
-        out = '<%s ' % self.n + className + plural
-        if attrs:
-            out += ': ' + ', '.join(attrs)
-        out += '>'
-        return out
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def apply(self, other):
-        if isinstance(other, datetime):
-            n = self.n
-
-            if n == 0 and other.weekday() > 4:
-                n = 1
-
-            result = other
-
-            while n != 0:
-                k = n // abs(n)
-                result = result + timedelta(k)
-                if result.weekday() < 5:
-                    n -= k
-
-            if self.normalize:
-                result = datetime(result.year, result.month, result.day)
-
-            if self.offset:
-                result = result + self.offset
-
-            return result
-
-        elif isinstance(other, (timedelta, Tick)):
-            return BDay(self.n, offset=self.offset + other,
-                        normalize=self.normalize)
-        else:
-            raise Exception('Only know how to combine business day with '
-                            'datetime or timedelta!')
-    @classmethod
-    def onOffset(cls, someDate):
-        return someDate.weekday() < 5
-
-
-class MonthEnd(DateOffset, CacheableOffset):
-    _normalizeFirst = True
-    """DateOffset of one month end"""
-
-    def apply(self, other):
-        n = self.n
-        _, nDaysInMonth = calendar.monthrange(other.year, other.month)
-        if other.day != nDaysInMonth:
-            other = other + relativedelta(months=-1, day=31)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(months=n, day=31)
-        return other
-
-    @classmethod
-    def onOffset(cls, someDate):
-        __junk, nDaysInMonth = calendar.monthrange(someDate.year,
-                                                   someDate.month)
-        return someDate.day == nDaysInMonth
-
-class BMonthEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business EOM dates"""
-    _outputName = 'BusinessMonthEnd'
-    _normalizeFirst = True
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
-        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
-
-        if n > 0 and not other.day >= lastBDay:
-            n = n - 1
-        elif n <= 0 and other.day > lastBDay:
-            n = n + 1
-        other = other + relativedelta(months=n, day=31)
-
-        if other.weekday() > 4:
-            other = other - BDay()
-        return other
-
-
-class Week(DateOffset, CacheableOffset):
-    """
-    weekday
-    0: Mondays
-    1: Tuedays
-    2: Wednesdays
-    3: Thursdays
-    4: Fridays
-    5: Saturdays
-    6: Sundays
-    """
-    _normalizeFirst = True
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.weekday = kwds.get('weekday', None)
-
-        if self.weekday is not None:
-            if self.weekday < 0 or self.weekday > 6:
-                raise Exception('Day must be 0<=day<=6, got %d' %
-                                self.weekday)
-
-        self.inc = timedelta(weeks=1)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.weekday is not None)
-
-    def apply(self, other):
-        if self.weekday is None:
-            return other + self.n * self.inc
-
-        if self.n > 0:
-            k = self.n
-            otherDay = other.weekday()
-            if otherDay != self.weekday:
-                other = other + timedelta((self.weekday - otherDay) % 7)
-                k = k - 1
-            for i in xrange(k):
-                other = other + self.inc
-        else:
-            k = self.n
-            otherDay = other.weekday()
-            if otherDay != self.weekday:
-                other = other + timedelta((self.weekday - otherDay) % 7)
-            for i in xrange(-k):
-                other = other - self.inc
-        return other
-
-    def onOffset(self, someDate):
-        return someDate.weekday() == self.weekday
-
-
-
-class WeekOfMonth(DateOffset, CacheableOffset):
-    """
-    Describes monthly dates like "the Tuesday of the 2nd week of each month"
-
-    Parameters
-    ----------
-    n : int
-    week : {0, 1, 2, 3, ...}
-        0 is 1st week of month, 1 2nd week, etc.
-    weekday : {0, 1, ..., 6}
-        0: Mondays
-        1: Tuedays
-        2: Wednesdays
-        3: Thursdays
-        4: Fridays
-        5: Saturdays
-        6: Sundays
-    """
-    _normalizeFirst = True
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.weekday = kwds['weekday']
-        self.week = kwds['week']
-
-        if self.n != 1 and self.n != -1:
-            raise Exception('N must be -1 or 1, got %d' % self.n)
-
-        if self.weekday < 0 or self.weekday > 6:
-            raise Exception('Day must be 0<=day<=6, got %d' %
-                            self.weekday)
-        if self.week < 0 or self.week > 3:
-            raise Exception('Week must be 0<=day<=3, got %d' %
-                            self.week)
-
-        self.kwds = kwds
-
-    def apply(self, other):
-        offsetOfMonth = self.getOffsetOfMonth(other)
-
-        one_month = relativedelta(months=1, day=1)
-        offsetOfPrevMonth = self.getOffsetOfMonth(other - one_month)
-        offsetOfNextMonth = self.getOffsetOfMonth(other + one_month)
-
-        if other < offsetOfMonth:
-            if self.n == 1:
-                return offsetOfMonth
-            elif self.n == -1:
-                return offsetOfPrevMonth
-        elif other == offsetOfMonth:
-            delta = relativedelta(months=self.n, day=1)
-            return self.getOffsetOfMonth(other + delta)
-        else:
-            if self.n == 1:
-                return offsetOfNextMonth
-            else:
-                return offsetOfMonth
-
-    def getOffsetOfMonth(self, someDate):
-        w = Week(weekday=self.weekday)
-        d = datetime(someDate.year, someDate.month, 1)
-
-        d = w.rollforward(d)
-
-        for i in xrange(self.week):
-            d = w.apply(d)
-
-        return d
-
-    def onOffset(self, someDate):
-        return someDate == self.getOffsetOfMonth(someDate)
-
-class BQuarterEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business Quarter dates
-    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
-    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
-    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
-    """
-    _outputName = 'BusinessQuarterEnd'
-    _normalizeFirst = True
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        if self.startingMonth < 1 or self.startingMonth > 3:
-            raise Exception('Start month must be 1<=day<=3, got %d'
-                            % self.startingMonth)
-
-        self.offset = BMonthEnd(3)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
-        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
-
-        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
-        if monthsToGo == 3:
-            monthsToGo = 0
-
-        if n > 0 and not (other.day >= lastBDay and monthsToGo == 0):
-            n = n - 1
-        elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
-            n = n + 1
-
-        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
-
-        if other.weekday() > 4:
-            other = other - BDay()
-
-        return other
-
-    def onOffset(self, someDate):
-        modMonth = (someDate.month - self.startingMonth) % 3
-        return BMonthEnd().onOffset(someDate) and modMonth == 0
-
-class BYearEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business EOM dates"""
-    _outputName = 'BusinessYearEnd'
-    _normalizeFirst = True
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', 12)
-
-        if self.month < 1 or self.month > 12:
-            raise Exception('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    def apply(self, other):
-        n = self.n
-
-        if self._normalizeFirst:
-            other = normalize_date(other)
-
-        wkday, nDaysInMonth = calendar.monthrange(other.year, self.month)
-        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
-
-        years = n
-        if n > 0:
-            if (other.month < self.month or
-                (other.month == self.month and other.day < lastBDay)):
-                years -= 1
-        elif n <= 0:
-            if (other.month > self.month or
-                (other.month == self.month and other.day > lastBDay)):
-                years += 1
-
-        other = other + relativedelta(years=years)
-
-        _, days_in_month = calendar.monthrange(other.year, self.month)
-        result = datetime(other.year, self.month, days_in_month)
-
-        if result.weekday() > 4:
-            result = result - BDay()
-
-        return result
-
-class YearEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between calendar year ends"""
-    _normalizeFirst = True
-
-    def apply(self, other):
-        n = self.n
-        if other.month != 12 or other.day != 31:
-            other = datetime(other.year - 1, 12, 31)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(years=n)
-        return other
-
-    @classmethod
-    def onOffset(cls, someDate):
-        return someDate.month == 12 and someDate.day == 31
-
-
-class YearBegin(DateOffset, CacheableOffset):
-    """DateOffset increments between calendar year begin dates"""
-    _normalizeFirst = True
-
-    def apply(self, other):
-        n = self.n
-        if other.month != 1 or other.day != 1:
-            other = datetime(other.year, 1, 1)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(years = n, day=1)
-        return other
-
-    @classmethod
-    def onOffset(cls, someDate):
-        return someDate.month == 1 and someDate.day == 1
-
-#-------------------------------------------------------------------------------
-# Ticks
-
-class Tick(DateOffset):
-    _normalizeFirst = False
-    _delta = None
-    _inc = timedelta(microseconds=1000)
-
-    @property
-    def delta(self):
-        if self._delta is None:
-            self._delta = self.n * self._inc
-
-        return self._delta
-
-    def apply(self, other):
-        if isinstance(other, (datetime, timedelta)):
-            return other + self.delta
-        elif isinstance(other, type(self)):
-            return type(self)(self.n + other.n)
-
-class Hour(Tick):
-    _inc = timedelta(0, 3600)
-
-class Minute(Tick):
-    _inc = timedelta(0, 60)
-
-class Second(Tick):
-    _inc = timedelta(0, 1)
-
-day = DateOffset()
-bday = BDay(normalize=True)
-businessDay = bday
-monthEnd = MonthEnd()
-yearEnd = YearEnd()
-yearBegin = YearBegin()
-bmonthEnd = BMonthEnd()
-businessMonthEnd = bmonthEnd
-bquarterEnd = BQuarterEnd()
-byearEnd = BYearEnd()
-week = Week()
-
-# Functions/offsets to roll dates forward
-thisMonthEnd = MonthEnd(0)
-thisBMonthEnd = BMonthEnd(0)
-thisYearEnd = YearEnd(0)
-thisYearBegin = YearBegin(0)
-thisBQuarterEnd = BQuarterEnd(0)
-
-# Functions to check where a date lies
-isBusinessDay = BDay().onOffset
-isMonthEnd = MonthEnd().onOffset
-isBMonthEnd = BMonthEnd().onOffset
-
-#-------------------------------------------------------------------------------
-# Offset names ("time rules") and related functions
-
-_offsetMap = {
-    "WEEKDAY"  : BDay(1),
-    "EOM"      : BMonthEnd(1),
-    "W@MON"    : Week(weekday=0),
-    "W@TUE"    : Week(weekday=1),
-    "W@WED"    : Week(weekday=2),
-    "W@THU"    : Week(weekday=3),
-    "W@FRI"    : Week(weekday=4),
-    "Q@JAN"    : BQuarterEnd(startingMonth=1),
-    "Q@FEB"    : BQuarterEnd(startingMonth=2),
-    "Q@MAR"    : BQuarterEnd(startingMonth=3),
-    "A@JAN"    : BYearEnd(month=1),
-    "A@FEB"    : BYearEnd(month=2),
-    "A@MAR"    : BYearEnd(month=3),
-    "A@APR"    : BYearEnd(month=4),
-    "A@MAY"    : BYearEnd(month=5),
-    "A@JUN"    : BYearEnd(month=6),
-    "A@JUL"    : BYearEnd(month=7),
-    "A@AUG"    : BYearEnd(month=8),
-    "A@SEP"    : BYearEnd(month=9),
-    "A@OCT"    : BYearEnd(month=10),
-    "A@NOV"    : BYearEnd(month=11),
-    "A@DEC"    : BYearEnd()
-}
-
-
-for i, weekday in enumerate(['MON', 'TUE', 'WED', 'THU', 'FRI']):
-    for week in xrange(4):
-        _offsetMap['WOM@%d%s' % (week + 1, weekday)] = \
-            WeekOfMonth(week=week, weekday=i)
-
-_offsetNames = dict([(v, k) for k, v in _offsetMap.iteritems()])
-
-def inferTimeRule(index):
-    if len(index) < 3:
-        raise Exception('Need at least three dates to infer time rule!')
-
-    first, second, third = index[:3]
-    for rule, offset in _offsetMap.iteritems():
-        if second == (first + offset) and third == (second + offset):
-            return rule
-
-    raise Exception('Could not infer time rule from data!')
-
-def getOffset(name):
-    """
-    Return DateOffset object associated with rule name
-
-    Example
-    -------
-    getOffset('EOM') --> BMonthEnd(1)
-    """
-    offset = _offsetMap.get(name)
-    if offset is not None:
-        return offset
-    else:
-        raise Exception('Bad rule name requested: %s!' % name)
-
-def hasOffsetName(offset):
-    return offset in _offsetNames
-
-def getOffsetName(offset):
-    """
-    Return rule name associated with a DateOffset object
-
-    Example
-    -------
-    getOffsetName(BMonthEnd(1)) --> 'EOM'
-    """
-    name = _offsetNames.get(offset)
-    if name is not None:
-        return name
-    else:
-        raise Exception('Bad offset name requested: %s!' % offset)
+"""A collection of random tools for dealing with dates in Python"""
+
+from datetime import datetime, timedelta
+
+try:
+    from dateutil import parser
+    from dateutil.relativedelta import relativedelta
+except ImportError: # pragma: no cover
+    print 'Please install python-dateutil via easy_install or some method!'
+
+import calendar
+
+#-------------------------------------------------------------------------------
+# Miscellaneous date functions
+
+def format(dt):
+    """Returns date in YYYYMMDD format."""
+    return dt.strftime('%Y%m%d')
+
+OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
+
+def ole2datetime(oledt):
+    """function for converting excel date to normal date format"""
+    val = float(oledt)
+
+    # Excel has a bug where it thinks the date 2/29/1900 exists
+    # we just reject any date before 3/1/1900.
+    if val < 61:
+        raise Exception("Value is outside of acceptable range: %s " % val)
+
+    return OLE_TIME_ZERO + timedelta(days=val)
+
+def to_datetime(arg):
+    """Attempts to convert arg to datetime"""
+    if arg is None or isinstance(arg, datetime):
+        return arg
+    try:
+        return parser.parse(arg)
+    except Exception:
+        return arg
+
+def normalize_date(dt):
+    return datetime(dt.year, dt.month, dt.day)
+
+#-------------------------------------------------------------------------------
+# DateOffset
+
+class CacheableOffset(object):
+    pass
+
+class DateOffset(object):
+    """
+    Standard kind of date increment used for a date range.
+
+    Works exactly like relativedelta in terms of the keyword args you
+    pass in, use of the keyword n is discouraged-- you would be better
+    off specifying n in the keywords you use, but regardless it is
+    there for you. n is needed for DateOffset subclasses.
+
+    DateOffets work as follows.  Each offset specify a set of dates
+    that conform to the DateOffset.  For example, Bday defines this
+    set to be the set of dates that are weekdays (M-F).  To test if a
+    date is in the set of a DateOffset dateOffset we can use the
+    onOffset method: dateOffset.onOffset(date).
+
+    If a date is not on a valid date, the rollback and rollforward
+    methods can be used to roll the date to the nearest valid date
+    before/after the date.
+
+    DateOffsets can be created to move dates forward a given number of
+    valid dates.  For example, Bday(2) can be added to a date to move
+    it two business days forward.  If the date does not start on a
+    valid date, first it is moved to a valid date.  Thus psedo code
+    is:
+
+    def __add__(date):
+      date = rollback(date) # does nothing is date is valid
+      return date + <n number of periods>
+
+    When a date offset is created for a negitive number of periods,
+    the date is first rolled forward.  The pseudo code is:
+
+    def __add__(date):
+      date = rollforward(date) # does nothing is date is valid
+      return date + <n number of periods>
+
+    Zero presents a problem.  Should it roll forward or back?  We
+    arbitrarily have it rollforward:
+
+    date + BDay(0) == BDay.rollforward(date)
+
+    Since 0 is a bit weird, we suggest avoiding its use.
+    """
+    # For some offsets, want to drop the time information off the
+    # first date
+    _normalizeFirst = False
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        if len(kwds) > 0:
+            self._offset = relativedelta(**kwds)
+        else:
+            self._offset = timedelta(1)
+
+    def apply(self, other):
+        if len(self.kwds) > 0:
+            if self.n > 0:
+                for i in xrange(self.n):
+                    other = other + self._offset
+            else:
+                for i in xrange(-self.n):
+                    other = other - self._offset
+            return other
+        else:
+            return other + timedelta(self.n)
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def copy(self):
+        return self.__class__(self.n, **self.kwds)
+
+    def _params(self):
+        attrs = sorted((item for item in self.__dict__.iteritems()
+                        if item[0] not in ('kwds', '_offset')))
+        params = tuple([str(self.__class__)] + attrs)
+        return params
+
+    def __repr__(self):
+        className = getattr(self, '_outputName', type(self).__name__)
+        exclude = set(['n', 'inc'])
+        attrs = []
+        for attr in self.__dict__:
+            if ((attr == 'kwds' and len(self.kwds) == 0)
+                or attr.startswith('_')):
+                continue
+            if attr not in exclude:
+                attrs.append('='.join((attr, repr(getattr(self, attr)))))
+
+        if abs(self.n) != 1:
+            plural = 's'
+        else:
+            plural = ''
+
+        out = '<%s ' % self.n + className + plural
+        if attrs:
+            out += ': ' + ', '.join(attrs)
+        out += '>'
+        return out
+
+    def __eq__(self, other):
+        return self._params() == other._params()
+
+    def __hash__(self):
+        return hash(self._params())
+
+    def __call__(self, other):
+        return self.apply(other)
+
+    def __add__(self, other):
+        return self.apply(other)
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __sub__(self, other):
+        if isinstance(other, datetime):
+            raise TypeError('Cannot subtract datetime from offset!')
+        elif type(other) == type(self):
+            return self.__class__(self.n - other.n, **self.kwds)
+        else: # pragma: no cover
+            raise TypeError('Cannot subtract %s from %s'
+                            % (type(other), type(self)))
+
+    def __rsub__(self, other):
+        return self.__class__(-self.n, **self.kwds) + other
+
+    def __mul__(self, someInt):
+        return self.__class__(n=someInt * self.n, **self.kwds)
+
+    def __rmul__(self, someInt):
+        return self.__mul__(someInt)
+
+    def __neg__(self):
+        return self.__class__(-self.n, **self.kwds)
+
+    def rollback(self, someDate):
+        """Roll provided date backward to next offset only if not on offset"""
+        if self._normalizeFirst:
+            someDate = normalize_date(someDate)
+
+        if not self.onOffset(someDate):
+            someDate = someDate - self.__class__(1, **self.kwds)
+        return someDate
+
+    def rollforward(self, someDate):
+        """Roll provided date forward to next offset only if not on offset"""
+        if self._normalizeFirst:
+            someDate = normalize_date(someDate)
+
+        if not self.onOffset(someDate):
+            someDate = someDate + self.__class__(1, **self.kwds)
+        return someDate
+
+    def onOffset(self, someDate):
+        # Default (slow) method for determining if some date is a
+        # member of the DateRange generated by this offset. Subclasses
+        # may have this re-implemented in a nicer way.
+        return someDate == ((someDate + self) - self)
+
+
+class BDay(DateOffset, CacheableOffset):
+    """
+    DateOffset subclass representing possibly n business days
+    """
+    _normalizeFirst = True
+    _outputName = 'BusinessDay'
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        self.offset = kwds.get('offset', timedelta(0))
+        self.normalize = kwds.get('normalize', True)
+
+    def __repr__(self):
+        className = getattr(self, '_outputName', self.__class__.__name__)
+        attrs = []
+
+        if self.offset:
+            attrs = ['offset=%s' % repr(self.offset)]
+
+        if abs(self.n) != 1:
+            plural = 's'
+        else:
+            plural = ''
+
+        out = '<%s ' % self.n + className + plural
+        if attrs:
+            out += ': ' + ', '.join(attrs)
+        out += '>'
+        return out
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        if isinstance(other, datetime):
+            n = self.n
+
+            if n == 0 and other.weekday() > 4:
+                n = 1
+
+            result = other
+
+            while n != 0:
+                k = n // abs(n)
+                result = result + timedelta(k)
+                if result.weekday() < 5:
+                    n -= k
+
+            if self.normalize:
+                result = datetime(result.year, result.month, result.day)
+
+            if self.offset:
+                result = result + self.offset
+
+            return result
+
+        elif isinstance(other, (timedelta, Tick)):
+            return BDay(self.n, offset=self.offset + other,
+                        normalize=self.normalize)
+        else:
+            raise Exception('Only know how to combine business day with '
+                            'datetime or timedelta!')
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.weekday() < 5
+
+
+class MonthEnd(DateOffset, CacheableOffset):
+    _normalizeFirst = True
+    """DateOffset of one month end"""
+
+    def apply(self, other):
+        n = self.n
+        _, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        if other.day != nDaysInMonth:
+            other = other + relativedelta(months=-1, day=31)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(months=n, day=31)
+        return other
+
+    @classmethod
+    def onOffset(cls, someDate):
+        __junk, nDaysInMonth = calendar.monthrange(someDate.year,
+                                                   someDate.month)
+        return someDate.day == nDaysInMonth
+
+class BMonthEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessMonthEnd'
+    _normalizeFirst = True
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+
+        if n > 0 and not other.day >= lastBDay:
+            n = n - 1
+        elif n <= 0 and other.day > lastBDay:
+            n = n + 1
+        other = other + relativedelta(months=n, day=31)
+
+        if other.weekday() > 4:
+            other = other - BDay()
+        return other
+
+
+class Week(DateOffset, CacheableOffset):
+    """
+    weekday
+    0: Mondays
+    1: Tuedays
+    2: Wednesdays
+    3: Thursdays
+    4: Fridays
+    5: Saturdays
+    6: Sundays
+    """
+    _normalizeFirst = True
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.weekday = kwds.get('weekday', None)
+
+        if self.weekday is not None:
+            if self.weekday < 0 or self.weekday > 6:
+                raise Exception('Day must be 0<=day<=6, got %d' %
+                                self.weekday)
+
+        self.inc = timedelta(weeks=1)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.weekday is not None)
+
+    def apply(self, other):
+        if self.weekday is None:
+            return other + self.n * self.inc
+
+        if self.n > 0:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.weekday:
+                other = other + timedelta((self.weekday - otherDay) % 7)
+                k = k - 1
+            for i in xrange(k):
+                other = other + self.inc
+        else:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.weekday:
+                other = other + timedelta((self.weekday - otherDay) % 7)
+            for i in xrange(-k):
+                other = other - self.inc
+        return other
+
+    def onOffset(self, someDate):
+        return someDate.weekday() == self.weekday
+
+
+
+class WeekOfMonth(DateOffset, CacheableOffset):
+    """
+    Describes monthly dates like "the Tuesday of the 2nd week of each month"
+
+    Parameters
+    ----------
+    n : int
+    week : {0, 1, 2, 3, ...}
+        0 is 1st week of month, 1 2nd week, etc.
+    weekday : {0, 1, ..., 6}
+        0: Mondays
+        1: Tuedays
+        2: Wednesdays
+        3: Thursdays
+        4: Fridays
+        5: Saturdays
+        6: Sundays
+    """
+    _normalizeFirst = True
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.weekday = kwds['weekday']
+        self.week = kwds['week']
+
+        if self.n != 1 and self.n != -1:
+            raise Exception('N must be -1 or 1, got %d' % self.n)
+
+        if self.weekday < 0 or self.weekday > 6:
+            raise Exception('Day must be 0<=day<=6, got %d' %
+                            self.weekday)
+        if self.week < 0 or self.week > 3:
+            raise Exception('Week must be 0<=day<=3, got %d' %
+                            self.week)
+
+        self.kwds = kwds
+
+    def apply(self, other):
+        offsetOfMonth = self.getOffsetOfMonth(other)
+
+        one_month = relativedelta(months=1, day=1)
+        offsetOfPrevMonth = self.getOffsetOfMonth(other - one_month)
+        offsetOfNextMonth = self.getOffsetOfMonth(other + one_month)
+
+        if other < offsetOfMonth:
+            if self.n == 1:
+                return offsetOfMonth
+            elif self.n == -1:
+                return offsetOfPrevMonth
+        elif other == offsetOfMonth:
+            delta = relativedelta(months=self.n, day=1)
+            return self.getOffsetOfMonth(other + delta)
+        else:
+            if self.n == 1:
+                return offsetOfNextMonth
+            else:
+                return offsetOfMonth
+
+    def getOffsetOfMonth(self, someDate):
+        w = Week(weekday=self.weekday)
+        d = datetime(someDate.year, someDate.month, 1)
+
+        d = w.rollforward(d)
+
+        for i in xrange(self.week):
+            d = w.apply(d)
+
+        return d
+
+    def onOffset(self, someDate):
+        return someDate == self.getOffsetOfMonth(someDate)
+
+class BQuarterEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business Quarter dates
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
+    """
+    _outputName = 'BusinessQuarterEnd'
+    _normalizeFirst = True
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+
+        if self.startingMonth < 1 or self.startingMonth > 3:
+            raise Exception('Start month must be 1<=day<=3, got %d'
+                            % self.startingMonth)
+
+        self.offset = BMonthEnd(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+
+        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
+        if monthsToGo == 3:
+            monthsToGo = 0
+
+        if n > 0 and not (other.day >= lastBDay and monthsToGo == 0):
+            n = n - 1
+        elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
+            n = n + 1
+
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+
+        if other.weekday() > 4:
+            other = other - BDay()
+
+        return other
+
+    def onOffset(self, someDate):
+        modMonth = (someDate.month - self.startingMonth) % 3
+        return BMonthEnd().onOffset(someDate) and modMonth == 0
+
+class BYearEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessYearEnd'
+    _normalizeFirst = True
+
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 12)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    def apply(self, other):
+        n = self.n
+
+        if self._normalizeFirst:
+            other = normalize_date(other)
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, self.month)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+
+        years = n
+        if n > 0:
+            if (other.month < self.month or
+                (other.month == self.month and other.day < lastBDay)):
+                years -= 1
+        elif n <= 0:
+            if (other.month > self.month or
+                (other.month == self.month and other.day > lastBDay)):
+                years += 1
+
+        other = other + relativedelta(years=years)
+
+        _, days_in_month = calendar.monthrange(other.year, self.month)
+        result = datetime(other.year, self.month, days_in_month)
+
+        if result.weekday() > 4:
+            result = result - BDay()
+
+        return result
+
+class YearEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between calendar year ends"""
+    _normalizeFirst = True
+
+    def apply(self, other):
+        n = self.n
+        if other.month != 12 or other.day != 31:
+            other = datetime(other.year - 1, 12, 31)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years=n)
+        return other
+
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.month == 12 and someDate.day == 31
+
+
+class YearBegin(DateOffset, CacheableOffset):
+    """DateOffset increments between calendar year begin dates"""
+    _normalizeFirst = True
+
+    def apply(self, other):
+        n = self.n
+        if other.month != 1 or other.day != 1:
+            other = datetime(other.year, 1, 1)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years = n, day=1)
+        return other
+
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.month == 1 and someDate.day == 1
+
+#-------------------------------------------------------------------------------
+# Ticks
+
+class Tick(DateOffset):
+    _normalizeFirst = False
+    _delta = None
+    _inc = timedelta(microseconds=1000)
+
+    @property
+    def delta(self):
+        if self._delta is None:
+            self._delta = self.n * self._inc
+
+        return self._delta
+
+    def apply(self, other):
+        if isinstance(other, (datetime, timedelta)):
+            return other + self.delta
+        elif isinstance(other, type(self)):
+            return type(self)(self.n + other.n)
+
+class Hour(Tick):
+    _inc = timedelta(0, 3600)
+
+class Minute(Tick):
+    _inc = timedelta(0, 60)
+
+class Second(Tick):
+    _inc = timedelta(0, 1)
+
+day = DateOffset()
+bday = BDay(normalize=True)
+businessDay = bday
+monthEnd = MonthEnd()
+yearEnd = YearEnd()
+yearBegin = YearBegin()
+bmonthEnd = BMonthEnd()
+businessMonthEnd = bmonthEnd
+bquarterEnd = BQuarterEnd()
+byearEnd = BYearEnd()
+week = Week()
+
+# Functions/offsets to roll dates forward
+thisMonthEnd = MonthEnd(0)
+thisBMonthEnd = BMonthEnd(0)
+thisYearEnd = YearEnd(0)
+thisYearBegin = YearBegin(0)
+thisBQuarterEnd = BQuarterEnd(0)
+
+# Functions to check where a date lies
+isBusinessDay = BDay().onOffset
+isMonthEnd = MonthEnd().onOffset
+isBMonthEnd = BMonthEnd().onOffset
+
+#-------------------------------------------------------------------------------
+# Offset names ("time rules") and related functions
+
+_offsetMap = {
+    "WEEKDAY"  : BDay(1),
+    "EOM"      : BMonthEnd(1),
+    "W@MON"    : Week(weekday=0),
+    "W@TUE"    : Week(weekday=1),
+    "W@WED"    : Week(weekday=2),
+    "W@THU"    : Week(weekday=3),
+    "W@FRI"    : Week(weekday=4),
+    "Q@JAN"    : BQuarterEnd(startingMonth=1),
+    "Q@FEB"    : BQuarterEnd(startingMonth=2),
+    "Q@MAR"    : BQuarterEnd(startingMonth=3),
+    "A@JAN"    : BYearEnd(month=1),
+    "A@FEB"    : BYearEnd(month=2),
+    "A@MAR"    : BYearEnd(month=3),
+    "A@APR"    : BYearEnd(month=4),
+    "A@MAY"    : BYearEnd(month=5),
+    "A@JUN"    : BYearEnd(month=6),
+    "A@JUL"    : BYearEnd(month=7),
+    "A@AUG"    : BYearEnd(month=8),
+    "A@SEP"    : BYearEnd(month=9),
+    "A@OCT"    : BYearEnd(month=10),
+    "A@NOV"    : BYearEnd(month=11),
+    "A@DEC"    : BYearEnd()
+}
+
+
+for i, weekday in enumerate(['MON', 'TUE', 'WED', 'THU', 'FRI']):
+    for week in xrange(4):
+        _offsetMap['WOM@%d%s' % (week + 1, weekday)] = \
+            WeekOfMonth(week=week, weekday=i)
+
+_offsetNames = dict([(v, k) for k, v in _offsetMap.iteritems()])
+
+def inferTimeRule(index):
+    if len(index) < 3:
+        raise Exception('Need at least three dates to infer time rule!')
+
+    first, second, third = index[:3]
+    for rule, offset in _offsetMap.iteritems():
+        if second == (first + offset) and third == (second + offset):
+            return rule
+
+    raise Exception('Could not infer time rule from data!')
+
+def getOffset(name):
+    """
+    Return DateOffset object associated with rule name
+
+    Example
+    -------
+    getOffset('EOM') --> BMonthEnd(1)
+    """
+    offset = _offsetMap.get(name)
+    if offset is not None:
+        return offset
+    else:
+        raise Exception('Bad rule name requested: %s!' % name)
+
+def hasOffsetName(offset):
+    return offset in _offsetNames
+
+def getOffsetName(offset):
+    """
+    Return rule name associated with a DateOffset object
+
+    Example
+    -------
+    getOffsetName(BMonthEnd(1)) --> 'EOM'
+    """
+    name = _offsetNames.get(offset)
+    if name is not None:
+        return name
+    else:
+        raise Exception('Bad offset name requested: %s!' % offset)
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index 96c3e7849..24a6daa2b 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -1,816 +1,822 @@
-from datetime import datetime, timedelta
-import unittest
-
-from pandas.core.datetools import (
-    bday, BDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd,
-    DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second,
-    WeekOfMonth, format, ole2datetime, to_datetime, normalize_date,
-    getOffset, getOffsetName, inferTimeRule, hasOffsetName)
-
-from nose.tools import assert_raises
-
-####
-## Misc function tests
-####
-def test_format():
-    actual = format(datetime(2008, 1, 15))
-    assert actual == '20080115'
-
-def test_ole2datetime():
-    actual = ole2datetime(60000)
-    assert actual == datetime(2064, 4, 8)
-
-    assert_raises(Exception, ole2datetime, 60)
-
-def test_to_datetime1():
-    actual = to_datetime(datetime(2008, 1, 15))
-    assert actual == datetime(2008, 1, 15)
-
-    actual = to_datetime('20080115')
-    assert actual == datetime(2008, 1, 15)
-
-    # unparseable
-    s = 'Month 1, 1999'
-    assert to_datetime(s) == s
-
-def test_normalize_date():
-    actual = normalize_date(datetime(2007, 10, 1, 1, 12, 5, 10))
-    assert actual == datetime(2007, 10, 1)
-
-#####
-### DateOffset Tests
-#####
-
-class TestDateOffset(object):
-
-    def setUp(self):
-        self.d = datetime(2008, 1, 2)
-
-    def test_repr(self):
-        repr(DateOffset())
-        repr(DateOffset(2))
-        repr(2 * DateOffset())
-        repr(2 * DateOffset(months=2))
-
-    def test_mul(self):
-        assert DateOffset(2) == 2 * DateOffset(1)
-        assert DateOffset(2) == DateOffset(1) * 2
-
-    def test_constructor(self):
-
-        assert((self.d + DateOffset(months=2)) == datetime(2008, 3, 2))
-        assert((self.d - DateOffset(months=2)) == datetime(2007, 11, 2))
-
-        assert((self.d + DateOffset(2)) == datetime(2008, 1, 4))
-
-        assert not DateOffset(2).isAnchored()
-        assert DateOffset(1).isAnchored()
-
-        d = datetime(2008, 1, 31)
-        assert((d + DateOffset(months=1)) == datetime(2008, 2, 29))
-
-    def test_copy(self):
-        assert(DateOffset(months=2).copy() == DateOffset(months=2))
-
-class TestBusinessDay(unittest.TestCase):
-
-    def setUp(self):
-        self.d = datetime(2008, 1, 1)
-
-        self.offset = BDay()
-        self.offset2 = BDay(2)
-
-    def test_repr(self):
-        assert repr(self.offset) == '<1 BusinessDay>'
-        assert repr(self.offset2) == '<2 BusinessDays>'
-
-        expected = '<1 BusinessDay: offset=datetime.timedelta(1)>'
-        assert repr(self.offset + timedelta(1)) == expected
-
-    def test_with_offset(self):
-        offset = self.offset + timedelta(hours=2)
-
-        assert (self.d + offset) == datetime(2008, 1, 2, 2)
-
-    def testEQ(self):
-        self.assertEqual(self.offset2, self.offset2)
-
-    def test_mul(self):
-        pass
-
-    def test_hash(self):
-        self.assertEqual(hash(self.offset2), hash(self.offset2))
-
-    def testCall(self):
-        self.assertEqual(self.offset2(self.d), datetime(2008, 1, 3))
-
-    def testRAdd(self):
-        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
-
-    def testSub(self):
-        off = self.offset2
-        self.assertRaises(Exception, off.__sub__, self.d)
-        self.assertEqual(2 * off - off, off)
-
-        self.assertEqual(self.d - self.offset2,  self.d + BDay(-2))
-
-    def testRSub(self):
-        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
-
-    def testMult1(self):
-        self.assertEqual(self.d + 10*self.offset, self.d + BDay(10))
-
-    def testMult2(self):
-        self.assertEqual(self.d + (-5*BDay(-10)),
-                         self.d + BDay(50))
-
-
-    def testRollback1(self):
-        self.assertEqual(BDay(10).rollback(self.d), self.d)
-
-    def testRollback2(self):
-        self.assertEqual(BDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
-
-    def testRollforward1(self):
-        self.assertEqual(BDay(10).rollforward(self.d), self.d)
-
-    def testRollforward2(self):
-        self.assertEqual(BDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
-
-    def test_onOffset(self):
-        tests = [(BDay(), datetime(2008, 1, 1), True),
-                 (BDay(), datetime(2008, 1, 5), False)]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-    def test_apply(self):
-        tests = []
-
-        tests.append((bday,
-                      {datetime(2008, 1, 1): datetime(2008, 1, 2),
-                       datetime(2008, 1, 4): datetime(2008, 1, 7),
-                       datetime(2008, 1, 5): datetime(2008, 1, 7),
-                       datetime(2008, 1, 6): datetime(2008, 1, 7),
-                       datetime(2008, 1, 7): datetime(2008, 1, 8)}))
-
-        tests.append((2*bday,
-                      {datetime(2008, 1, 1): datetime(2008, 1, 3),
-                       datetime(2008, 1, 4): datetime(2008, 1, 8),
-                       datetime(2008, 1, 5): datetime(2008, 1, 8),
-                       datetime(2008, 1, 6): datetime(2008, 1, 8),
-                       datetime(2008, 1, 7): datetime(2008, 1, 9)}))
-
-        tests.append((-bday,
-                      {datetime(2008, 1, 1): datetime(2007, 12, 31),
-                       datetime(2008, 1, 4): datetime(2008, 1, 3),
-                       datetime(2008, 1, 5): datetime(2008, 1, 4),
-                       datetime(2008, 1, 6): datetime(2008, 1, 4),
-                       datetime(2008, 1, 7): datetime(2008, 1, 4),
-                       datetime(2008, 1, 8): datetime(2008, 1, 7)}))
-
-        tests.append((-2*bday,
-                      {datetime(2008, 1, 1): datetime(2007, 12, 28),
-                       datetime(2008, 1, 4): datetime(2008, 1, 2),
-                       datetime(2008, 1, 5): datetime(2008, 1, 3),
-                       datetime(2008, 1, 6): datetime(2008, 1, 3),
-                       datetime(2008, 1, 7): datetime(2008, 1, 3),
-                       datetime(2008, 1, 8): datetime(2008, 1, 4),
-                       datetime(2008, 1, 9): datetime(2008, 1, 7)}))
-
-        tests.append((BDay(0),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
-                       datetime(2008, 1, 4): datetime(2008, 1, 4),
-                       datetime(2008, 1, 5): datetime(2008, 1, 7),
-                       datetime(2008, 1, 6): datetime(2008, 1, 7),
-                       datetime(2008, 1, 7): datetime(2008, 1, 7)}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_apply_corner(self):
-        self.assertRaises(Exception, BDay().apply, BMonthEnd())
-
-def assertOnOffset(offset, date, expected):
-    actual = offset.onOffset(date)
-    assert actual == expected
-
-class TestWeek(unittest.TestCase):
-    def test_corner(self):
-        self.assertRaises(Exception, Week, weekday=7)
-        self.assertRaises(Exception, Week, weekday=-1)
-
-    def test_isAnchored(self):
-        self.assert_(Week(weekday=0).isAnchored())
-        self.assert_(not Week().isAnchored())
-        self.assert_(not Week(2, weekday=2).isAnchored())
-        self.assert_(not Week(2).isAnchored())
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((Week(), # not business week
-                      {datetime(2008, 1, 1): datetime(2008, 1, 8),
-                       datetime(2008, 1, 4): datetime(2008, 1, 11),
-                       datetime(2008, 1, 5): datetime(2008, 1, 12),
-                       datetime(2008, 1, 6): datetime(2008, 1, 13),
-                       datetime(2008, 1, 7): datetime(2008, 1, 14)}))
-
-        tests.append((Week(weekday=0), # Mon
-                      {datetime(2007, 12, 31): datetime(2008, 1, 7),
-                       datetime(2008, 1, 4): datetime(2008, 1, 7),
-                       datetime(2008, 1, 5): datetime(2008, 1, 7),
-                       datetime(2008, 1, 6): datetime(2008, 1, 7),
-                       datetime(2008, 1, 7): datetime(2008, 1, 14)}))
-
-        tests.append((Week(0, weekday=0), # n=0 -> roll forward. Mon
-                      {datetime(2007, 12, 31): datetime(2007, 12, 31),
-                       datetime(2008, 1, 4): datetime(2008, 1, 7),
-                       datetime(2008, 1, 5): datetime(2008, 1, 7),
-                       datetime(2008, 1, 6): datetime(2008, 1, 7),
-                       datetime(2008, 1, 7): datetime(2008, 1, 7)}))
-
-        tests.append((Week(-2, weekday=1), # n=0 -> roll forward. Mon
-                      {datetime(2010, 4, 6): datetime(2010, 3, 23),
-                       datetime(2010, 4, 8): datetime(2010, 3, 30),
-                       datetime(2010, 4, 5): datetime(2010, 3, 23)}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_onOffset(self):
-        for weekday in range(7):
-            offset = Week(weekday=weekday)
-
-            for day in range(1, 8):
-                date = datetime(2008, 1, day)
-
-                if day % 7 == weekday:
-                    expected = True
-                else:
-                    expected = False
-            assertOnOffset(offset, date, expected)
-
-class TestWeekOfMonth(unittest.TestCase):
-
-    def test_constructor(self):
-        self.assertRaises(Exception, WeekOfMonth, n=2, week=0, weekday=0)
-        self.assertRaises(Exception, WeekOfMonth, n=1, week=4, weekday=0)
-        self.assertRaises(Exception, WeekOfMonth, n=1, week=-1, weekday=0)
-        self.assertRaises(Exception, WeekOfMonth, n=1, week=0, weekday=-1)
-        self.assertRaises(Exception, WeekOfMonth, n=1, week=0, weekday=7)
-
-    def test_offset(self):
-        date1 = datetime(2011, 1, 11) # 1st Tuesday of Month
-        date2 = datetime(2011, 1, 11) # 2nd Tuesday of Month
-        date3 = datetime(2011, 1, 18) # 3rd Tuesday of Month
-        date4 = datetime(2011, 1, 25) # 3rd Tuesday of Month
-
-        # see for loop for structure
-        test_cases = [
-            (0, 0, date1, datetime(2011, 2, 7)),
-            (0, 0, date2, datetime(2011, 2, 7)),
-            (0, 0, date3, datetime(2011, 2, 7)),
-            (0, 0, date4, datetime(2011, 2, 7)),
-            (0, 1, date1, datetime(2011, 2, 1)),
-            (0, 1, date2, datetime(2011, 2, 1)),
-            (0, 1, date3, datetime(2011, 2, 1)),
-            (0, 1, date4, datetime(2011, 2, 1)),
-            (0, 2, date1, datetime(2011, 2, 2)),
-            (0, 2, date2, datetime(2011, 2, 2)),
-            (0, 2, date3, datetime(2011, 2, 2)),
-            (0, 2, date4, datetime(2011, 2, 2)),
-
-            (2, 1, date1, datetime(2011, 1, 18)),
-            (2, 1, date2, datetime(2011, 1, 18)),
-            (2, 1, date3, datetime(2011, 2, 15)),
-            (2, 1, date4, datetime(2011, 2, 15)),
-        ]
-
-        for week, weekday, date, expected in test_cases:
-            offset = WeekOfMonth(week=week, weekday=weekday)
-            assertEq(offset, date, expected)
-
-        # try subtracting
-        result = datetime(2011, 2, 1) - WeekOfMonth(week=1, weekday=2)
-        self.assertEqual(result, datetime(2011, 1, 12))
-        result = datetime(2011, 2, 3) - WeekOfMonth(week=0, weekday=2)
-        self.assertEqual(result, datetime(2011, 2, 2))
-
-    def test_onOffset(self):
-        test_cases = [
-            (0, 0, datetime(2011, 2, 7), True),
-            (0, 0, datetime(2011, 2, 6), False),
-            (0, 0, datetime(2011, 2, 14), False),
-            (1, 0, datetime(2011, 2, 14), True),
-            (0, 1, datetime(2011, 2, 1), True),
-            (0, 1, datetime(2011, 2, 8), False),
-        ]
-
-        for week, weekday, date, expected in test_cases:
-            offset = WeekOfMonth(week=week, weekday=weekday)
-            self.assert_(offset.onOffset(date) == expected)
-
-class TestBMonthEnd(unittest.TestCase):
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((BMonthEnd(),
-                     {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                      datetime(2008, 1, 31): datetime(2008, 2, 29),
-                      datetime(2006, 12, 29): datetime(2007, 1, 31),
-                      datetime(2006, 12, 31): datetime(2007, 1, 31),
-                      datetime(2007, 1, 1): datetime(2007, 1, 31),
-                      datetime(2006, 12, 1): datetime(2006, 12, 29)}))
-
-        tests.append((BMonthEnd(0),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                       datetime(2008, 1, 31): datetime(2008, 1, 31),
-                       datetime(2006, 12, 29): datetime(2006, 12, 29),
-                       datetime(2006, 12, 31): datetime(2007, 1, 31),
-                       datetime(2007, 1, 1): datetime(2007, 1, 31)}))
-
-        tests.append((BMonthEnd(2),
-                     {datetime(2008, 1, 1): datetime(2008, 2, 29),
-                      datetime(2008, 1, 31): datetime(2008, 3, 31),
-                      datetime(2006, 12, 29): datetime(2007, 2, 28),
-                      datetime(2006, 12, 31): datetime(2007, 2, 28),
-                      datetime(2007, 1, 1): datetime(2007, 2, 28),
-                      datetime(2006, 11, 1): datetime(2006, 12, 29)}))
-
-        tests.append((BMonthEnd(-1),
-                     {datetime(2007, 1, 1): datetime(2006, 12, 29),
-                      datetime(2008, 6, 30): datetime(2008, 5, 30),
-                      datetime(2008, 12, 31): datetime(2008, 11, 28),
-                      datetime(2006, 12, 29): datetime(2006, 11, 30),
-                      datetime(2006, 12, 30): datetime(2006, 12, 29),
-                      datetime(2007, 1, 1): datetime(2006, 12, 29)}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_onOffset(self):
-
-        tests = [(BMonthEnd(), datetime(2007, 12, 31), True),
-                 (BMonthEnd(), datetime(2008, 1, 1), False)]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-class TestMonthEnd(unittest.TestCase):
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((MonthEnd(),
-                     {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                      datetime(2008, 1, 31): datetime(2008, 2, 29),
-                      datetime(2006, 12, 29): datetime(2006, 12, 31),
-                      datetime(2006, 12, 31): datetime(2007, 1, 31),
-                      datetime(2007, 1, 1): datetime(2007, 1, 31),
-                      datetime(2006, 12, 1): datetime(2006, 12, 31)}))
-
-        tests.append((MonthEnd(0),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                       datetime(2008, 1, 31): datetime(2008, 1, 31),
-                       datetime(2006, 12, 29): datetime(2006, 12, 31),
-                       datetime(2006, 12, 31): datetime(2006, 12, 31),
-                       datetime(2007, 1, 1): datetime(2007, 1, 31)}))
-
-        tests.append((MonthEnd(2),
-                     {datetime(2008, 1, 1): datetime(2008, 2, 29),
-                      datetime(2008, 1, 31): datetime(2008, 3, 31),
-                      datetime(2006, 12, 29): datetime(2007, 1, 31),
-                      datetime(2006, 12, 31): datetime(2007, 2, 28),
-                      datetime(2007, 1, 1): datetime(2007, 2, 28),
-                      datetime(2006, 11, 1): datetime(2006, 12, 31)}))
-
-        tests.append((MonthEnd(-1),
-                     {datetime(2007, 1, 1): datetime(2006, 12, 31),
-                      datetime(2008, 6, 30): datetime(2008, 5, 31),
-                      datetime(2008, 12, 31): datetime(2008, 11, 30),
-                      datetime(2006, 12, 29): datetime(2006, 11, 30),
-                      datetime(2006, 12, 30): datetime(2006, 11, 30),
-                      datetime(2007, 1, 1): datetime(2006, 12, 31)}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_onOffset(self):
-
-        tests = [(MonthEnd(), datetime(2007, 12, 31), True),
-                 (MonthEnd(), datetime(2008, 1, 1), False)]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-class TestBQuarterEnd(unittest.TestCase):
-    def test_corner(self):
-        self.assertRaises(Exception, BQuarterEnd, startingMonth=4)
-        self.assertRaises(Exception, BQuarterEnd, startingMonth=-1)
-
-    def test_isAnchored(self):
-        self.assert_(BQuarterEnd(startingMonth=1).isAnchored())
-        self.assert_(BQuarterEnd().isAnchored())
-        self.assert_(not BQuarterEnd(2, startingMonth=1).isAnchored())
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((BQuarterEnd(startingMonth=1),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                       datetime(2008, 1, 31): datetime(2008, 4, 30),
-                       datetime(2008, 2, 15): datetime(2008, 4, 30),
-                       datetime(2008, 2, 29): datetime(2008, 4, 30),
-                       datetime(2008, 3, 15): datetime(2008, 4, 30),
-                       datetime(2008, 3, 31): datetime(2008, 4, 30),
-                       datetime(2008, 4, 15): datetime(2008, 4, 30),
-                       datetime(2008, 4, 30): datetime(2008, 7, 31),}))
-
-        tests.append((BQuarterEnd(startingMonth=2),
-                      {datetime(2008, 1, 1): datetime(2008, 2, 29),
-                       datetime(2008, 1, 31): datetime(2008, 2, 29),
-                       datetime(2008, 2, 15): datetime(2008, 2, 29),
-                       datetime(2008, 2, 29): datetime(2008, 5, 30),
-                       datetime(2008, 3, 15): datetime(2008, 5, 30),
-                       datetime(2008, 3, 31): datetime(2008, 5, 30),
-                       datetime(2008, 4, 15): datetime(2008, 5, 30),
-                       datetime(2008, 4, 30): datetime(2008, 5, 30),}))
-
-        tests.append((BQuarterEnd(startingMonth=1, n=0),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
-                       datetime(2008, 1, 31): datetime(2008, 1, 31),
-                       datetime(2008, 2, 15): datetime(2008, 4, 30),
-                       datetime(2008, 2, 29): datetime(2008, 4, 30),
-                       datetime(2008, 3, 15): datetime(2008, 4, 30),
-                       datetime(2008, 3, 31): datetime(2008, 4, 30),
-                       datetime(2008, 4, 15): datetime(2008, 4, 30),
-                       datetime(2008, 4, 30): datetime(2008, 4, 30),}))
-
-        tests.append((BQuarterEnd(startingMonth=1, n=-1),
-                      {datetime(2008, 1, 1): datetime(2007, 10, 31),
-                       datetime(2008, 1, 31): datetime(2007, 10, 31),
-                       datetime(2008, 2, 15): datetime(2008, 1, 31),
-                       datetime(2008, 2, 29): datetime(2008, 1, 31),
-                       datetime(2008, 3, 15): datetime(2008, 1, 31),
-                       datetime(2008, 3, 31): datetime(2008, 1, 31),
-                       datetime(2008, 4, 15): datetime(2008, 1, 31),
-                       datetime(2008, 4, 30): datetime(2008, 1, 31),}))
-
-        tests.append((BQuarterEnd(startingMonth=1, n=2),
-                      {datetime(2008, 1, 31): datetime(2008, 7, 31),
-                       datetime(2008, 2, 15): datetime(2008, 7, 31),
-                       datetime(2008, 2, 29): datetime(2008, 7, 31),
-                       datetime(2008, 3, 15): datetime(2008, 7, 31),
-                       datetime(2008, 3, 31): datetime(2008, 7, 31),
-                       datetime(2008, 4, 15): datetime(2008, 7, 31),
-                       datetime(2008, 4, 30): datetime(2008, 10, 31),}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-        # corner
-        offset = BQuarterEnd(n=-1, startingMonth=1)
-        self.assertEqual(datetime(2010, 1, 31) + offset, datetime(2010, 1, 29))
-
-    def test_onOffset(self):
-
-        tests = [(BQuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 30), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 31), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 5, 30), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 29), False),
-                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 30), False),
-
-                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 30), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 31), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 29), False),
-                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 30), False),
-
-                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), True),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), True),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 29), True),
-                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 30), False),
-             ]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-
-
-class TestYearBegin(unittest.TestCase):
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((YearBegin(),
-                      {datetime(2008, 1, 1): datetime(2009, 1, 1),
-                       datetime(2008, 6, 30): datetime(2009, 1, 1),
-                       datetime(2008, 12, 31): datetime(2009, 1, 1),
-                       datetime(2005, 12, 30): datetime(2006, 1, 1),
-                       datetime(2005, 12, 31): datetime(2006, 1, 1),}))
-
-        tests.append((YearBegin(0),
-                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
-                       datetime(2008, 6, 30): datetime(2009, 1, 1),
-                       datetime(2008, 12, 31): datetime(2009, 1, 1),
-                       datetime(2005, 12, 30): datetime(2006, 1, 1),
-                       datetime(2005, 12, 31): datetime(2006, 1, 1),}))
-
-
-        tests.append((YearBegin(-1),
-                      {datetime(2007, 1, 1): datetime(2006, 1, 1),
-                       datetime(2008, 6, 30): datetime(2008, 1, 1),
-                       datetime(2008, 12, 31): datetime(2008, 1, 1),
-                       datetime(2006, 12, 29): datetime(2006, 1, 1),
-                       datetime(2006, 12, 30): datetime(2006, 1, 1),
-                       datetime(2007, 1, 1): datetime(2006, 1, 1),}))
-
-        tests.append((YearBegin(-2),
-                      {datetime(2007, 1, 1): datetime(2005, 1, 1),
-                       datetime(2008, 6, 30): datetime(2007, 1, 1),
-                       datetime(2008, 12, 31): datetime(2007, 1, 1),}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-
-    def test_onOffset(self):
-
-        tests = [
-            (YearBegin(), datetime(2007, 1, 3), False),
-            (YearBegin(), datetime(2008, 1, 1), True),
-            (YearBegin(), datetime(2006, 12, 31), False),
-            (YearBegin(), datetime(2006, 1, 2), False),
-        ]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-class TestBYearEndLagged(unittest.TestCase):
-
-    def test_bad_month_fail(self):
-        self.assertRaises(Exception, BYearEnd, month=13)
-        self.assertRaises(Exception, BYearEnd, month=0)
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((BYearEnd(month=6),
-                      {datetime(2008, 1, 1): datetime(2008, 6, 30),
-                      datetime(2007, 6, 30): datetime(2008, 6, 30)},
-                      ))
-
-        tests.append((BYearEnd(n=-1, month=6),
-                      {datetime(2008, 1, 1): datetime(2007, 6, 29),
-                      datetime(2007, 6, 30): datetime(2007, 6, 29)},
-                      ))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                self.assertEqual(baseDate + dateOffset, expected)
-
-    def test_roll(self):
-        offset = BYearEnd(month=6)
-        date = datetime(2009, 11, 30)
-
-        self.assertEqual(offset.rollforward(date), datetime(2010, 6, 30))
-        self.assertEqual(offset.rollback(date), datetime(2009, 6, 30))
-
-    def test_onOffset(self):
-
-        tests = [
-            (BYearEnd(month=2), datetime(2007, 2, 28), True),
-            (BYearEnd(month=6), datetime(2007, 6, 30), False),
-        ]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-class TestBYearEnd(unittest.TestCase):
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((BYearEnd(),
-                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
-                       datetime(2008, 6, 30): datetime(2008, 12, 31),
-                       datetime(2008, 12, 31): datetime(2009, 12, 31),
-                       datetime(2005, 12, 30): datetime(2006, 12, 29),
-                       datetime(2005, 12, 31): datetime(2006, 12, 29),}))
-
-        tests.append((BYearEnd(0),
-                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
-                       datetime(2008, 6, 30): datetime(2008, 12, 31),
-                       datetime(2008, 12, 31): datetime(2008, 12, 31),
-                       datetime(2005, 12, 31): datetime(2006, 12, 29),}))
-
-        tests.append((BYearEnd(-1),
-                      {datetime(2007, 1, 1): datetime(2006, 12, 29),
-                       datetime(2008, 6, 30): datetime(2007, 12, 31),
-                       datetime(2008, 12, 31): datetime(2007, 12, 31),
-                       datetime(2006, 12, 29): datetime(2005, 12, 30),
-                       datetime(2006, 12, 30): datetime(2006, 12, 29),
-                       datetime(2007, 1, 1): datetime(2006, 12, 29),}))
-
-        tests.append((BYearEnd(-2),
-                      {datetime(2007, 1, 1): datetime(2005, 12, 30),
-                       datetime(2008, 6, 30): datetime(2006, 12, 29),
-                       datetime(2008, 12, 31): datetime(2006, 12, 29),}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_onOffset(self):
-
-        tests = [
-            (BYearEnd(), datetime(2007, 12, 31), True),
-            (BYearEnd(), datetime(2008, 1, 1), False),
-            (BYearEnd(), datetime(2006, 12, 31), False),
-            (BYearEnd(), datetime(2006, 12, 29), True),
-        ]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-class TestYearEnd(unittest.TestCase):
-
-    def test_offset(self):
-        tests = []
-
-        tests.append((YearEnd(),
-                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
-                       datetime(2008, 6, 30): datetime(2008, 12, 31),
-                       datetime(2008, 12, 31): datetime(2009, 12, 31),
-                       datetime(2005, 12, 30): datetime(2005, 12, 31),
-                       datetime(2005, 12, 31): datetime(2006, 12, 31),}))
-
-        tests.append((YearEnd(0),
-                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
-                       datetime(2008, 6, 30): datetime(2008, 12, 31),
-                       datetime(2008, 12, 31): datetime(2008, 12, 31),
-                       datetime(2005, 12, 30): datetime(2005, 12, 31),}))
-
-        tests.append((YearEnd(-1),
-                      {datetime(2007, 1, 1): datetime(2006, 12, 31),
-                       datetime(2008, 6, 30): datetime(2007, 12, 31),
-                       datetime(2008, 12, 31): datetime(2007, 12, 31),
-                       datetime(2006, 12, 29): datetime(2005, 12, 31),
-                       datetime(2006, 12, 30): datetime(2005, 12, 31),
-                       datetime(2007, 1, 1): datetime(2006, 12, 31),}))
-
-        tests.append((YearEnd(-2),
-                      {datetime(2007, 1, 1): datetime(2005, 12, 31),
-                       datetime(2008, 6, 30): datetime(2006, 12, 31),
-                       datetime(2008, 12, 31): datetime(2006, 12, 31),}))
-
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
-
-    def test_onOffset(self):
-
-        tests = [
-            (YearEnd(), datetime(2007, 12, 31), True),
-            (YearEnd(), datetime(2008, 1, 1), False),
-            (YearEnd(), datetime(2006, 12, 31), True),
-            (YearEnd(), datetime(2006, 12, 29), False),
-        ]
-
-        for offset, date, expected in tests:
-            assertOnOffset(offset, date, expected)
-
-def testOnOffset():
-
-    tests = [#(QuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
-             #(QuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
-             #(QuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
-             #(QuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True),
-             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False),
-
-             #(QuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
-             #(QuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
-             #(QuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
-             #(QuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False),
-             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False),
-
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), True),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
-             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), True),
-         ]
-
-    for offset, date, expected in tests:
-        assertOnOffset(offset, date, expected)
-
-def assertEq(dateOffset, baseDate, expected):
-    actual = dateOffset + baseDate
-    assert actual == expected
-
-def test_Hour():
-    assertEq(Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 1))
-    assertEq(Hour(-1), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
-    assertEq(2 * Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 2))
-    assertEq(-1 * Hour(), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
-
-    assert (Hour(3) + Hour(2)) == Hour(5)
-    assert (Hour(3) - Hour(2)) == Hour()
-
-def test_Minute():
-    assertEq(Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 1))
-    assertEq(Minute(-1), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
-    assertEq(2 * Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 2))
-    assertEq(-1 * Minute(), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
-
-    assert (Minute(3) + Minute(2)) == Minute(5)
-    assert (Minute(3) - Minute(2)) == Minute()
-
-def test_Second():
-    assertEq(Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 1))
-    assertEq(Second(-1), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
-    assertEq(2 * Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 2))
-    assertEq(-1 * Second(), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
-
-    assert (Second(3) + Second(2)) == Second(5)
-    assert (Second(3) - Second(2)) == Second()
-
-def test_inferTimeRule():
-    index1 = [datetime(2010, 1, 29, 0, 0),
-              datetime(2010, 2, 26, 0, 0),
-              datetime(2010, 3, 31, 0, 0)]
-
-    index2 = [datetime(2010, 3, 26, 0, 0),
-              datetime(2010, 3, 29, 0, 0),
-              datetime(2010, 3, 30, 0, 0)]
-
-    index3 = [datetime(2010, 3, 26, 0, 0),
-              datetime(2010, 3, 27, 0, 0),
-              datetime(2010, 3, 29, 0, 0)]
-
-    assert inferTimeRule(index1) == 'EOM'
-    assert inferTimeRule(index2) == 'WEEKDAY'
-
-    assert_raises(Exception, inferTimeRule, index1[:2])
-    assert_raises(Exception, inferTimeRule, index3)
-
-def test_hasOffsetName():
-    assert hasOffsetName(BDay())
-    assert not hasOffsetName(BDay(2))
-
-def test_getOffsetName():
-    assert_raises(Exception, getOffsetName, BDay(2))
-
-    assert getOffsetName(BDay()) == 'WEEKDAY'
-    assert getOffsetName(BMonthEnd()) == 'EOM'
-    assert getOffsetName(Week(weekday=0)) == 'W@MON'
-    assert getOffsetName(Week(weekday=1)) == 'W@TUE'
-    assert getOffsetName(Week(weekday=2)) == 'W@WED'
-    assert getOffsetName(Week(weekday=3)) == 'W@THU'
-    assert getOffsetName(Week(weekday=4)) == 'W@FRI'
-
-
-def test_getOffset():
-    assert_raises(Exception, getOffset, 'gibberish')
-
-    assert getOffset('WEEKDAY') == BDay()
-    assert getOffset('EOM') == BMonthEnd()
-    assert getOffset('W@MON') == Week(weekday=0)
-    assert getOffset('W@TUE') == Week(weekday=1)
-    assert getOffset('W@WED') == Week(weekday=2)
-    assert getOffset('W@THU') == Week(weekday=3)
-    assert getOffset('W@FRI') == Week(weekday=4)
-
+from datetime import datetime, timedelta
+import unittest
+
+from pandas.core.datetools import (
+    bday, BDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd,
+    DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second,
+    WeekOfMonth, format, ole2datetime, to_datetime, normalize_date,
+    getOffset, getOffsetName, inferTimeRule, hasOffsetName)
+
+from nose.tools import assert_raises
+
+####
+## Misc function tests
+####
+def test_format():
+    actual = format(datetime(2008, 1, 15))
+    assert actual == '20080115'
+
+def test_ole2datetime():
+    actual = ole2datetime(60000)
+    assert actual == datetime(2064, 4, 8)
+
+    assert_raises(Exception, ole2datetime, 60)
+
+def test_to_datetime1():
+    actual = to_datetime(datetime(2008, 1, 15))
+    assert actual == datetime(2008, 1, 15)
+
+    actual = to_datetime('20080115')
+    assert actual == datetime(2008, 1, 15)
+
+    # unparseable
+    s = 'Month 1, 1999'
+    assert to_datetime(s) == s
+
+def test_normalize_date():
+    actual = normalize_date(datetime(2007, 10, 1, 1, 12, 5, 10))
+    assert actual == datetime(2007, 10, 1)
+
+#####
+### DateOffset Tests
+#####
+
+class TestDateOffset(object):
+
+    def setUp(self):
+        self.d = datetime(2008, 1, 2)
+
+    def test_repr(self):
+        repr(DateOffset())
+        repr(DateOffset(2))
+        repr(2 * DateOffset())
+        repr(2 * DateOffset(months=2))
+
+    def test_mul(self):
+        assert DateOffset(2) == 2 * DateOffset(1)
+        assert DateOffset(2) == DateOffset(1) * 2
+
+    def test_constructor(self):
+
+        assert((self.d + DateOffset(months=2)) == datetime(2008, 3, 2))
+        assert((self.d - DateOffset(months=2)) == datetime(2007, 11, 2))
+
+        assert((self.d + DateOffset(2)) == datetime(2008, 1, 4))
+
+        assert not DateOffset(2).isAnchored()
+        assert DateOffset(1).isAnchored()
+
+        d = datetime(2008, 1, 31)
+        assert((d + DateOffset(months=1)) == datetime(2008, 2, 29))
+
+    def test_copy(self):
+        assert(DateOffset(months=2).copy() == DateOffset(months=2))
+
+class TestBusinessDay(unittest.TestCase):
+
+    def setUp(self):
+        self.d = datetime(2008, 1, 1)
+
+        self.offset = BDay()
+        self.offset2 = BDay(2)
+
+    def test_repr(self):
+        assert repr(self.offset) == '<1 BusinessDay>'
+        assert repr(self.offset2) == '<2 BusinessDays>'
+
+        expected = '<1 BusinessDay: offset=datetime.timedelta(1)>'
+        assert repr(self.offset + timedelta(1)) == expected
+
+    def test_with_offset(self):
+        offset = self.offset + timedelta(hours=2)
+
+        assert (self.d + offset) == datetime(2008, 1, 2, 2)
+
+    def testEQ(self):
+        self.assertEqual(self.offset2, self.offset2)
+
+    def test_mul(self):
+        pass
+
+    def test_hash(self):
+        self.assertEqual(hash(self.offset2), hash(self.offset2))
+
+    def testCall(self):
+        self.assertEqual(self.offset2(self.d), datetime(2008, 1, 3))
+
+    def testRAdd(self):
+        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
+
+    def testSub(self):
+        off = self.offset2
+        self.assertRaises(Exception, off.__sub__, self.d)
+        self.assertEqual(2 * off - off, off)
+
+        self.assertEqual(self.d - self.offset2,  self.d + BDay(-2))
+
+    def testRSub(self):
+        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
+
+    def testMult1(self):
+        self.assertEqual(self.d + 10*self.offset, self.d + BDay(10))
+
+    def testMult2(self):
+        self.assertEqual(self.d + (-5*BDay(-10)),
+                         self.d + BDay(50))
+
+
+    def testRollback1(self):
+        self.assertEqual(BDay(10).rollback(self.d), self.d)
+
+    def testRollback2(self):
+        self.assertEqual(BDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
+
+    def testRollforward1(self):
+        self.assertEqual(BDay(10).rollforward(self.d), self.d)
+
+    def testRollforward2(self):
+        self.assertEqual(BDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
+
+    def test_onOffset(self):
+        tests = [(BDay(), datetime(2008, 1, 1), True),
+                 (BDay(), datetime(2008, 1, 5), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+    def test_apply(self):
+        tests = []
+
+        tests.append((bday,
+                      {datetime(2008, 1, 1): datetime(2008, 1, 2),
+                       datetime(2008, 1, 4): datetime(2008, 1, 7),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 8)}))
+
+        tests.append((2*bday,
+                      {datetime(2008, 1, 1): datetime(2008, 1, 3),
+                       datetime(2008, 1, 4): datetime(2008, 1, 8),
+                       datetime(2008, 1, 5): datetime(2008, 1, 8),
+                       datetime(2008, 1, 6): datetime(2008, 1, 8),
+                       datetime(2008, 1, 7): datetime(2008, 1, 9)}))
+
+        tests.append((-bday,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 31),
+                       datetime(2008, 1, 4): datetime(2008, 1, 3),
+                       datetime(2008, 1, 5): datetime(2008, 1, 4),
+                       datetime(2008, 1, 6): datetime(2008, 1, 4),
+                       datetime(2008, 1, 7): datetime(2008, 1, 4),
+                       datetime(2008, 1, 8): datetime(2008, 1, 7)}))
+
+        tests.append((-2*bday,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 28),
+                       datetime(2008, 1, 4): datetime(2008, 1, 2),
+                       datetime(2008, 1, 5): datetime(2008, 1, 3),
+                       datetime(2008, 1, 6): datetime(2008, 1, 3),
+                       datetime(2008, 1, 7): datetime(2008, 1, 3),
+                       datetime(2008, 1, 8): datetime(2008, 1, 4),
+                       datetime(2008, 1, 9): datetime(2008, 1, 7)}))
+
+        tests.append((BDay(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                       datetime(2008, 1, 4): datetime(2008, 1, 4),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 7)}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_apply_corner(self):
+        self.assertRaises(Exception, BDay().apply, BMonthEnd())
+
+def assertOnOffset(offset, date, expected):
+    actual = offset.onOffset(date)
+    assert actual == expected
+
+class TestWeek(unittest.TestCase):
+    def test_corner(self):
+        self.assertRaises(Exception, Week, weekday=7)
+        self.assertRaises(Exception, Week, weekday=-1)
+
+    def test_isAnchored(self):
+        self.assert_(Week(weekday=0).isAnchored())
+        self.assert_(not Week().isAnchored())
+        self.assert_(not Week(2, weekday=2).isAnchored())
+        self.assert_(not Week(2).isAnchored())
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((Week(), # not business week
+                      {datetime(2008, 1, 1): datetime(2008, 1, 8),
+                       datetime(2008, 1, 4): datetime(2008, 1, 11),
+                       datetime(2008, 1, 5): datetime(2008, 1, 12),
+                       datetime(2008, 1, 6): datetime(2008, 1, 13),
+                       datetime(2008, 1, 7): datetime(2008, 1, 14)}))
+
+        tests.append((Week(weekday=0), # Mon
+                      {datetime(2007, 12, 31): datetime(2008, 1, 7),
+                       datetime(2008, 1, 4): datetime(2008, 1, 7),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 14)}))
+
+        tests.append((Week(0, weekday=0), # n=0 -> roll forward. Mon
+                      {datetime(2007, 12, 31): datetime(2007, 12, 31),
+                       datetime(2008, 1, 4): datetime(2008, 1, 7),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 7)}))
+
+        tests.append((Week(-2, weekday=1), # n=0 -> roll forward. Mon
+                      {datetime(2010, 4, 6): datetime(2010, 3, 23),
+                       datetime(2010, 4, 8): datetime(2010, 3, 30),
+                       datetime(2010, 4, 5): datetime(2010, 3, 23)}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+        for weekday in range(7):
+            offset = Week(weekday=weekday)
+
+            for day in range(1, 8):
+                date = datetime(2008, 1, day)
+
+                if day % 7 == weekday:
+                    expected = True
+                else:
+                    expected = False
+            assertOnOffset(offset, date, expected)
+
+class TestWeekOfMonth(unittest.TestCase):
+
+    def test_constructor(self):
+        self.assertRaises(Exception, WeekOfMonth, n=2, week=0, weekday=0)
+        self.assertRaises(Exception, WeekOfMonth, n=1, week=4, weekday=0)
+        self.assertRaises(Exception, WeekOfMonth, n=1, week=-1, weekday=0)
+        self.assertRaises(Exception, WeekOfMonth, n=1, week=0, weekday=-1)
+        self.assertRaises(Exception, WeekOfMonth, n=1, week=0, weekday=7)
+
+    def test_offset(self):
+        date1 = datetime(2011, 1, 11) # 1st Tuesday of Month
+        date2 = datetime(2011, 1, 11) # 2nd Tuesday of Month
+        date3 = datetime(2011, 1, 18) # 3rd Tuesday of Month
+        date4 = datetime(2011, 1, 25) # 3rd Tuesday of Month
+
+        # see for loop for structure
+        test_cases = [
+            (0, 0, date1, datetime(2011, 2, 7)),
+            (0, 0, date2, datetime(2011, 2, 7)),
+            (0, 0, date3, datetime(2011, 2, 7)),
+            (0, 0, date4, datetime(2011, 2, 7)),
+            (0, 1, date1, datetime(2011, 2, 1)),
+            (0, 1, date2, datetime(2011, 2, 1)),
+            (0, 1, date3, datetime(2011, 2, 1)),
+            (0, 1, date4, datetime(2011, 2, 1)),
+            (0, 2, date1, datetime(2011, 2, 2)),
+            (0, 2, date2, datetime(2011, 2, 2)),
+            (0, 2, date3, datetime(2011, 2, 2)),
+            (0, 2, date4, datetime(2011, 2, 2)),
+
+            (2, 1, date1, datetime(2011, 1, 18)),
+            (2, 1, date2, datetime(2011, 1, 18)),
+            (2, 1, date3, datetime(2011, 2, 15)),
+            (2, 1, date4, datetime(2011, 2, 15)),
+        ]
+
+        for week, weekday, date, expected in test_cases:
+            offset = WeekOfMonth(week=week, weekday=weekday)
+            assertEq(offset, date, expected)
+
+        # try subtracting
+        result = datetime(2011, 2, 1) - WeekOfMonth(week=1, weekday=2)
+        self.assertEqual(result, datetime(2011, 1, 12))
+        result = datetime(2011, 2, 3) - WeekOfMonth(week=0, weekday=2)
+        self.assertEqual(result, datetime(2011, 2, 2))
+
+    def test_onOffset(self):
+        test_cases = [
+            (0, 0, datetime(2011, 2, 7), True),
+            (0, 0, datetime(2011, 2, 6), False),
+            (0, 0, datetime(2011, 2, 14), False),
+            (1, 0, datetime(2011, 2, 14), True),
+            (0, 1, datetime(2011, 2, 1), True),
+            (0, 1, datetime(2011, 2, 8), False),
+        ]
+
+        for week, weekday, date, expected in test_cases:
+            offset = WeekOfMonth(week=week, weekday=weekday)
+            self.assert_(offset.onOffset(date) == expected)
+
+class TestBMonthEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((BMonthEnd(),
+                     {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                      datetime(2008, 1, 31): datetime(2008, 2, 29),
+                      datetime(2006, 12, 29): datetime(2007, 1, 31),
+                      datetime(2006, 12, 31): datetime(2007, 1, 31),
+                      datetime(2007, 1, 1): datetime(2007, 1, 31),
+                      datetime(2006, 12, 1): datetime(2006, 12, 29)}))
+
+        tests.append((BMonthEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 1, 31): datetime(2008, 1, 31),
+                       datetime(2006, 12, 29): datetime(2006, 12, 29),
+                       datetime(2006, 12, 31): datetime(2007, 1, 31),
+                       datetime(2007, 1, 1): datetime(2007, 1, 31)}))
+
+        tests.append((BMonthEnd(2),
+                     {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                      datetime(2008, 1, 31): datetime(2008, 3, 31),
+                      datetime(2006, 12, 29): datetime(2007, 2, 28),
+                      datetime(2006, 12, 31): datetime(2007, 2, 28),
+                      datetime(2007, 1, 1): datetime(2007, 2, 28),
+                      datetime(2006, 11, 1): datetime(2006, 12, 29)}))
+
+        tests.append((BMonthEnd(-1),
+                     {datetime(2007, 1, 1): datetime(2006, 12, 29),
+                      datetime(2008, 6, 30): datetime(2008, 5, 30),
+                      datetime(2008, 12, 31): datetime(2008, 11, 28),
+                      datetime(2006, 12, 29): datetime(2006, 11, 30),
+                      datetime(2006, 12, 30): datetime(2006, 12, 29),
+                      datetime(2007, 1, 1): datetime(2006, 12, 29)}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+
+        tests = [(BMonthEnd(), datetime(2007, 12, 31), True),
+                 (BMonthEnd(), datetime(2008, 1, 1), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+class TestMonthEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((MonthEnd(),
+                     {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                      datetime(2008, 1, 31): datetime(2008, 2, 29),
+                      datetime(2006, 12, 29): datetime(2006, 12, 31),
+                      datetime(2006, 12, 31): datetime(2007, 1, 31),
+                      datetime(2007, 1, 1): datetime(2007, 1, 31),
+                      datetime(2006, 12, 1): datetime(2006, 12, 31)}))
+
+        tests.append((MonthEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 1, 31): datetime(2008, 1, 31),
+                       datetime(2006, 12, 29): datetime(2006, 12, 31),
+                       datetime(2006, 12, 31): datetime(2006, 12, 31),
+                       datetime(2007, 1, 1): datetime(2007, 1, 31)}))
+
+        tests.append((MonthEnd(2),
+                     {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                      datetime(2008, 1, 31): datetime(2008, 3, 31),
+                      datetime(2006, 12, 29): datetime(2007, 1, 31),
+                      datetime(2006, 12, 31): datetime(2007, 2, 28),
+                      datetime(2007, 1, 1): datetime(2007, 2, 28),
+                      datetime(2006, 11, 1): datetime(2006, 12, 31)}))
+
+        tests.append((MonthEnd(-1),
+                     {datetime(2007, 1, 1): datetime(2006, 12, 31),
+                      datetime(2008, 6, 30): datetime(2008, 5, 31),
+                      datetime(2008, 12, 31): datetime(2008, 11, 30),
+                      datetime(2006, 12, 29): datetime(2006, 11, 30),
+                      datetime(2006, 12, 30): datetime(2006, 11, 30),
+                      datetime(2007, 1, 1): datetime(2006, 12, 31)}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+
+        tests = [(MonthEnd(), datetime(2007, 12, 31), True),
+                 (MonthEnd(), datetime(2008, 1, 1), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+class TestBQuarterEnd(unittest.TestCase):
+    def test_corner(self):
+        self.assertRaises(Exception, BQuarterEnd, startingMonth=4)
+        self.assertRaises(Exception, BQuarterEnd, startingMonth=-1)
+
+    def test_isAnchored(self):
+        self.assert_(BQuarterEnd(startingMonth=1).isAnchored())
+        self.assert_(BQuarterEnd().isAnchored())
+        self.assert_(not BQuarterEnd(2, startingMonth=1).isAnchored())
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((BQuarterEnd(startingMonth=1),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 1, 31): datetime(2008, 4, 30),
+                       datetime(2008, 2, 15): datetime(2008, 4, 30),
+                       datetime(2008, 2, 29): datetime(2008, 4, 30),
+                       datetime(2008, 3, 15): datetime(2008, 4, 30),
+                       datetime(2008, 3, 31): datetime(2008, 4, 30),
+                       datetime(2008, 4, 15): datetime(2008, 4, 30),
+                       datetime(2008, 4, 30): datetime(2008, 7, 31),}))
+
+        tests.append((BQuarterEnd(startingMonth=2),
+                      {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                       datetime(2008, 1, 31): datetime(2008, 2, 29),
+                       datetime(2008, 2, 15): datetime(2008, 2, 29),
+                       datetime(2008, 2, 29): datetime(2008, 5, 30),
+                       datetime(2008, 3, 15): datetime(2008, 5, 30),
+                       datetime(2008, 3, 31): datetime(2008, 5, 30),
+                       datetime(2008, 4, 15): datetime(2008, 5, 30),
+                       datetime(2008, 4, 30): datetime(2008, 5, 30),}))
+
+        tests.append((BQuarterEnd(startingMonth=1, n=0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 1, 31): datetime(2008, 1, 31),
+                       datetime(2008, 2, 15): datetime(2008, 4, 30),
+                       datetime(2008, 2, 29): datetime(2008, 4, 30),
+                       datetime(2008, 3, 15): datetime(2008, 4, 30),
+                       datetime(2008, 3, 31): datetime(2008, 4, 30),
+                       datetime(2008, 4, 15): datetime(2008, 4, 30),
+                       datetime(2008, 4, 30): datetime(2008, 4, 30),}))
+
+        tests.append((BQuarterEnd(startingMonth=1, n=-1),
+                      {datetime(2008, 1, 1): datetime(2007, 10, 31),
+                       datetime(2008, 1, 31): datetime(2007, 10, 31),
+                       datetime(2008, 2, 15): datetime(2008, 1, 31),
+                       datetime(2008, 2, 29): datetime(2008, 1, 31),
+                       datetime(2008, 3, 15): datetime(2008, 1, 31),
+                       datetime(2008, 3, 31): datetime(2008, 1, 31),
+                       datetime(2008, 4, 15): datetime(2008, 1, 31),
+                       datetime(2008, 4, 30): datetime(2008, 1, 31),}))
+
+        tests.append((BQuarterEnd(startingMonth=1, n=2),
+                      {datetime(2008, 1, 31): datetime(2008, 7, 31),
+                       datetime(2008, 2, 15): datetime(2008, 7, 31),
+                       datetime(2008, 2, 29): datetime(2008, 7, 31),
+                       datetime(2008, 3, 15): datetime(2008, 7, 31),
+                       datetime(2008, 3, 31): datetime(2008, 7, 31),
+                       datetime(2008, 4, 15): datetime(2008, 7, 31),
+                       datetime(2008, 4, 30): datetime(2008, 10, 31),}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+        # corner
+        offset = BQuarterEnd(n=-1, startingMonth=1)
+        self.assertEqual(datetime(2010, 1, 31) + offset, datetime(2010, 1, 29))
+
+    def test_onOffset(self):
+
+        tests = [(BQuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 30), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 31), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2008, 5, 30), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 29), False),
+                 (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 30), False),
+
+                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 30), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 31), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 29), False),
+                 (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 30), False),
+
+                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), True),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), True),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 29), True),
+                 (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 30), False),
+             ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+
+
+class TestYearBegin(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((YearBegin(),
+                      {datetime(2008, 1, 1): datetime(2009, 1, 1),
+                       datetime(2008, 6, 30): datetime(2009, 1, 1),
+                       datetime(2008, 12, 31): datetime(2009, 1, 1),
+                       datetime(2005, 12, 30): datetime(2006, 1, 1),
+                       datetime(2005, 12, 31): datetime(2006, 1, 1),}))
+
+        tests.append((YearBegin(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                       datetime(2008, 6, 30): datetime(2009, 1, 1),
+                       datetime(2008, 12, 31): datetime(2009, 1, 1),
+                       datetime(2005, 12, 30): datetime(2006, 1, 1),
+                       datetime(2005, 12, 31): datetime(2006, 1, 1),}))
+
+
+        tests.append((YearBegin(-1),
+                      {datetime(2007, 1, 1): datetime(2006, 1, 1),
+                       datetime(2008, 6, 30): datetime(2008, 1, 1),
+                       datetime(2008, 12, 31): datetime(2008, 1, 1),
+                       datetime(2006, 12, 29): datetime(2006, 1, 1),
+                       datetime(2006, 12, 30): datetime(2006, 1, 1),
+                       datetime(2007, 1, 1): datetime(2006, 1, 1),}))
+
+        tests.append((YearBegin(-2),
+                      {datetime(2007, 1, 1): datetime(2005, 1, 1),
+                       datetime(2008, 6, 30): datetime(2007, 1, 1),
+                       datetime(2008, 12, 31): datetime(2007, 1, 1),}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+
+    def test_onOffset(self):
+
+        tests = [
+            (YearBegin(), datetime(2007, 1, 3), False),
+            (YearBegin(), datetime(2008, 1, 1), True),
+            (YearBegin(), datetime(2006, 12, 31), False),
+            (YearBegin(), datetime(2006, 1, 2), False),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+class TestBYearEndLagged(unittest.TestCase):
+
+    def test_bad_month_fail(self):
+        self.assertRaises(Exception, BYearEnd, month=13)
+        self.assertRaises(Exception, BYearEnd, month=0)
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((BYearEnd(month=6),
+                      {datetime(2008, 1, 1): datetime(2008, 6, 30),
+                      datetime(2007, 6, 30): datetime(2008, 6, 30)},
+                      ))
+
+        tests.append((BYearEnd(n=-1, month=6),
+                      {datetime(2008, 1, 1): datetime(2007, 6, 29),
+                      datetime(2007, 6, 30): datetime(2007, 6, 29)},
+                      ))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                self.assertEqual(baseDate + dateOffset, expected)
+
+    def test_roll(self):
+        offset = BYearEnd(month=6)
+        date = datetime(2009, 11, 30)
+
+        self.assertEqual(offset.rollforward(date), datetime(2010, 6, 30))
+        self.assertEqual(offset.rollback(date), datetime(2009, 6, 30))
+
+    def test_onOffset(self):
+
+        tests = [
+            (BYearEnd(month=2), datetime(2007, 2, 28), True),
+            (BYearEnd(month=6), datetime(2007, 6, 30), False),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+class TestBYearEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((BYearEnd(),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2009, 12, 31),
+                       datetime(2005, 12, 30): datetime(2006, 12, 29),
+                       datetime(2005, 12, 31): datetime(2006, 12, 29),}))
+
+        tests.append((BYearEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2008, 12, 31),
+                       datetime(2005, 12, 31): datetime(2006, 12, 29),}))
+
+        tests.append((BYearEnd(-1),
+                      {datetime(2007, 1, 1): datetime(2006, 12, 29),
+                       datetime(2008, 6, 30): datetime(2007, 12, 31),
+                       datetime(2008, 12, 31): datetime(2007, 12, 31),
+                       datetime(2006, 12, 29): datetime(2005, 12, 30),
+                       datetime(2006, 12, 30): datetime(2006, 12, 29),
+                       datetime(2007, 1, 1): datetime(2006, 12, 29),}))
+
+        tests.append((BYearEnd(-2),
+                      {datetime(2007, 1, 1): datetime(2005, 12, 30),
+                       datetime(2008, 6, 30): datetime(2006, 12, 29),
+                       datetime(2008, 12, 31): datetime(2006, 12, 29),}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+
+        tests = [
+            (BYearEnd(), datetime(2007, 12, 31), True),
+            (BYearEnd(), datetime(2008, 1, 1), False),
+            (BYearEnd(), datetime(2006, 12, 31), False),
+            (BYearEnd(), datetime(2006, 12, 29), True),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+class TestYearEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((YearEnd(),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2009, 12, 31),
+                       datetime(2005, 12, 30): datetime(2005, 12, 31),
+                       datetime(2005, 12, 31): datetime(2006, 12, 31),}))
+
+        tests.append((YearEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2008, 12, 31),
+                       datetime(2005, 12, 30): datetime(2005, 12, 31),}))
+
+        tests.append((YearEnd(-1),
+                      {datetime(2007, 1, 1): datetime(2006, 12, 31),
+                       datetime(2008, 6, 30): datetime(2007, 12, 31),
+                       datetime(2008, 12, 31): datetime(2007, 12, 31),
+                       datetime(2006, 12, 29): datetime(2005, 12, 31),
+                       datetime(2006, 12, 30): datetime(2005, 12, 31),
+                       datetime(2007, 1, 1): datetime(2006, 12, 31),}))
+
+        tests.append((YearEnd(-2),
+                      {datetime(2007, 1, 1): datetime(2005, 12, 31),
+                       datetime(2008, 6, 30): datetime(2006, 12, 31),
+                       datetime(2008, 12, 31): datetime(2006, 12, 31),}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+
+        tests = [
+            (YearEnd(), datetime(2007, 12, 31), True),
+            (YearEnd(), datetime(2008, 1, 1), False),
+            (YearEnd(), datetime(2006, 12, 31), True),
+            (YearEnd(), datetime(2006, 12, 29), False),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+def testOnOffset():
+
+    tests = [#(QuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
+             #(QuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
+             #(QuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True),
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False),
+
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False),
+
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), True),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), True),
+         ]
+
+    for offset, date, expected in tests:
+        assertOnOffset(offset, date, expected)
+
+def assertEq(dateOffset, baseDate, expected):
+    actual = dateOffset + baseDate
+    assert actual == expected
+
+def test_Hour():
+    assertEq(Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 1))
+    assertEq(Hour(-1), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
+    assertEq(2 * Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 2))
+    assertEq(-1 * Hour(), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
+
+    assert (Hour(3) + Hour(2)) == Hour(5)
+    assert (Hour(3) - Hour(2)) == Hour()
+
+def test_Minute():
+    assertEq(Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 1))
+    assertEq(Minute(-1), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
+    assertEq(2 * Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 2))
+    assertEq(-1 * Minute(), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
+
+    assert (Minute(3) + Minute(2)) == Minute(5)
+    assert (Minute(3) - Minute(2)) == Minute()
+
+def test_Second():
+    assertEq(Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 1))
+    assertEq(Second(-1), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
+    assertEq(2 * Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 2))
+    assertEq(-1 * Second(), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
+
+    assert (Second(3) + Second(2)) == Second(5)
+    assert (Second(3) - Second(2)) == Second()
+
+def test_inferTimeRule():
+    index1 = [datetime(2010, 1, 29, 0, 0),
+              datetime(2010, 2, 26, 0, 0),
+              datetime(2010, 3, 31, 0, 0)]
+
+    index2 = [datetime(2010, 3, 26, 0, 0),
+              datetime(2010, 3, 29, 0, 0),
+              datetime(2010, 3, 30, 0, 0)]
+
+    index3 = [datetime(2010, 3, 26, 0, 0),
+              datetime(2010, 3, 27, 0, 0),
+              datetime(2010, 3, 29, 0, 0)]
+
+    assert inferTimeRule(index1) == 'EOM'
+    assert inferTimeRule(index2) == 'WEEKDAY'
+
+    assert_raises(Exception, inferTimeRule, index1[:2])
+    assert_raises(Exception, inferTimeRule, index3)
+
+def test_hasOffsetName():
+    assert hasOffsetName(BDay())
+    assert not hasOffsetName(BDay(2))
+
+def test_getOffsetName():
+    assert_raises(Exception, getOffsetName, BDay(2))
+
+    assert getOffsetName(BDay()) == 'WEEKDAY'
+    assert getOffsetName(BMonthEnd()) == 'EOM'
+    assert getOffsetName(Week(weekday=0)) == 'W@MON'
+    assert getOffsetName(Week(weekday=1)) == 'W@TUE'
+    assert getOffsetName(Week(weekday=2)) == 'W@WED'
+    assert getOffsetName(Week(weekday=3)) == 'W@THU'
+    assert getOffsetName(Week(weekday=4)) == 'W@FRI'
+
+
+def test_getOffset():
+    assert_raises(Exception, getOffset, 'gibberish')
+
+    assert getOffset('WEEKDAY') == BDay()
+    assert getOffset('EOM') == BMonthEnd()
+    assert getOffset('W@MON') == Week(weekday=0)
+    assert getOffset('W@TUE') == Week(weekday=1)
+    assert getOffset('W@WED') == Week(weekday=2)
+    assert getOffset('W@THU') == Week(weekday=3)
+    assert getOffset('W@FRI') == Week(weekday=4)
+
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
+

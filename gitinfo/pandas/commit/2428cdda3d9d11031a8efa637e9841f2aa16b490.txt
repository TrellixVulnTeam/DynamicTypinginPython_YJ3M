commit 2428cdda3d9d11031a8efa637e9841f2aa16b490
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Jun 1 08:40:17 2020 -0700

    BUG: Period.to_timestamp not matching PeriodArray.to_timestamp (#34449)

diff --git a/pandas/_libs/tslibs/period.pyx b/pandas/_libs/tslibs/period.pyx
index b2b7eb000..bc1908252 100644
--- a/pandas/_libs/tslibs/period.pyx
+++ b/pandas/_libs/tslibs/period.pyx
@@ -1702,10 +1702,7 @@ cdef class _Period:
 
     @property
     def end_time(self) -> Timestamp:
-        # freq.n can't be negative or 0
-        # ordinal = (self + self.freq.n).start_time.value - 1
-        ordinal = (self + self.freq).start_time.value - 1
-        return Timestamp(ordinal)
+        return self.to_timestamp(how="end")
 
     def to_timestamp(self, freq=None, how='start', tz=None) -> Timestamp:
         """
@@ -1727,18 +1724,22 @@ cdef class _Period:
         -------
         Timestamp
         """
-        if freq is not None:
-            freq = self._maybe_convert_freq(freq)
         how = validate_end_alias(how)
 
         end = how == 'E'
         if end:
+            if freq == "B" or self.freq == "B":
+                # roll forward to ensure we land on B date
+                adjust = Timedelta(1, "D") - Timedelta(1, "ns")
+                return self.to_timestamp(how="start") + adjust
             endpoint = (self + self.freq).to_timestamp(how='start')
             return endpoint - Timedelta(1, 'ns')
 
         if freq is None:
             base, mult = get_freq_code(self.freq)
             freq = get_to_timestamp_base(base)
+        else:
+            freq = self._maybe_convert_freq(freq)
 
         base, mult = get_freq_code(freq)
         val = self.asfreq(freq, how)
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 4601e7fa5..3d4b42de0 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -430,7 +430,7 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
 
         end = how == "E"
         if end:
-            if freq == "B":
+            if freq == "B" or self.freq == "B":
                 # roll forward to ensure we land on B date
                 adjust = Timedelta(1, "D") - Timedelta(1, "ns")
                 return self.to_timestamp(how="start") + adjust
diff --git a/pandas/tests/indexes/period/test_scalar_compat.py b/pandas/tests/indexes/period/test_scalar_compat.py
index 0f92b7a4e..e9d17e7e2 100644
--- a/pandas/tests/indexes/period/test_scalar_compat.py
+++ b/pandas/tests/indexes/period/test_scalar_compat.py
@@ -17,3 +17,12 @@ class TestPeriodIndexOps:
         expected_index = date_range("2016-01-01", end="2016-05-31", freq="M")
         expected_index += Timedelta(1, "D") - Timedelta(1, "ns")
         tm.assert_index_equal(index.end_time, expected_index)
+
+    def test_end_time_business_friday(self):
+        # GH#34449
+        pi = period_range("1990-01-05", freq="B", periods=1)
+        result = pi.end_time
+
+        dti = date_range("1990-01-05", freq="D", periods=1)._with_freq(None)
+        expected = dti + Timedelta(days=1, nanoseconds=-1)
+        tm.assert_index_equal(result, expected)
diff --git a/pandas/tests/scalar/period/test_period.py b/pandas/tests/scalar/period/test_period.py
index e81f2ee55..41909b4b1 100644
--- a/pandas/tests/scalar/period/test_period.py
+++ b/pandas/tests/scalar/period/test_period.py
@@ -589,6 +589,8 @@ class TestPeriodMethods:
         from_lst = ["A", "Q", "M", "W", "B", "D", "H", "Min", "S"]
 
         def _ex(p):
+            if p.freq == "B":
+                return p.start_time + Timedelta(days=1, nanoseconds=-1)
             return Timestamp((p + p.freq).start_time.value - 1)
 
         for i, fcode in enumerate(from_lst):
@@ -632,6 +634,13 @@ class TestPeriodMethods:
         result = p.to_timestamp("5S", how="start")
         assert result == expected
 
+    def test_to_timestamp_business_end(self):
+        per = pd.Period("1990-01-05", "B")  # Friday
+        result = per.to_timestamp("B", how="E")
+
+        expected = pd.Timestamp("1990-01-06") - pd.Timedelta(nanoseconds=1)
+        assert result == expected
+
     # --------------------------------------------------------------
     # Rendering: __repr__, strftime, etc
 
@@ -786,6 +795,14 @@ class TestPeriodProperties:
         xp = _ex(2012, 1, 2, 1)
         assert xp == p.end_time
 
+    def test_end_time_business_friday(self):
+        # GH#34449
+        per = Period("1990-01-05", "B")
+        result = per.end_time
+
+        expected = pd.Timestamp("1990-01-06") - pd.Timedelta(nanoseconds=1)
+        assert result == expected
+
     def test_anchor_week_end_time(self):
         def _ex(*args):
             return Timestamp(Timestamp(datetime(*args)).value - 1)

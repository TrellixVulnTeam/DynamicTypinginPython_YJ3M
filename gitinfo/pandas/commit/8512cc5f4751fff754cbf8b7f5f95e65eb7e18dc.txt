commit 8512cc5f4751fff754cbf8b7f5f95e65eb7e18dc
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Nov 20 19:30:37 2017 -0500

    COMPAT: astype(object) and dtype=object should be reflexive for Series constructor with datetimelikes (#18231)
    
    closes #17449

diff --git a/doc/source/whatsnew/v0.22.0.txt b/doc/source/whatsnew/v0.22.0.txt
index e868c7391..19b722f7f 100644
--- a/doc/source/whatsnew/v0.22.0.txt
+++ b/doc/source/whatsnew/v0.22.0.txt
@@ -38,11 +38,18 @@ Backwards incompatible API changes
 -
 -
 
+
+
+
+
+
 .. _whatsnew_0220.api:
 
 Other API Changes
 ^^^^^^^^^^^^^^^^^
 
+- :func:`Series.astype` and :func:`Index.astype` with an incompatible dtype will now raise a ``TypeError`` rather than a ``ValueError`` (:issue:`18231`)
+- ``Series`` construction with an ``object`` dtyped tz-aware datetime and ``dtype=object`` specified, will now return an ``object`` dtyped ``Series``, previously this would infer the datetime dtype (:issue:`18231`)
 - ``NaT`` division with :class:`datetime.timedelta` will now return ``NaN`` instead of raising (:issue:`17876`)
 - All-NaN levels in a ``MultiIndex`` are now assigned ``float`` rather than ``object`` dtype, promoting consistency with ``Index`` (:issue:`17929`).
 - :class:`Timestamp` will no longer silently ignore unused or invalid ``tz`` or ``tzinfo`` keyword arguments (:issue:`17690`)
@@ -80,6 +87,7 @@ Performance Improvements
 - :class`DateOffset` arithmetic performance is improved (:issue:`18218`)
 - Converting a ``Series`` of ``Timedelta`` objects to days, seconds, etc... sped up through vectorization of underlying methods (:issue:`18092`)
 - The overriden ``Timedelta`` properties of days, seconds and microseconds have been removed, leveraging their built-in Python versions instead (:issue:`18242`)
+- ``Series`` construction will reduce the number of copies made of the input data in certain cases (:issue:`17449`)
 
 .. _whatsnew_0220.docs:
 
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index eae283e9b..4b9991475 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -13,7 +13,9 @@ from .common import (_ensure_object, is_bool, is_integer, is_float,
                      is_datetimelike,
                      is_extension_type, is_object_dtype,
                      is_datetime64tz_dtype, is_datetime64_dtype,
-                     is_timedelta64_dtype, is_dtype_equal,
+                     is_datetime64_ns_dtype,
+                     is_timedelta64_dtype, is_timedelta64_ns_dtype,
+                     is_dtype_equal,
                      is_float_dtype, is_complex_dtype,
                      is_integer_dtype,
                      is_datetime_or_timedelta_dtype,
@@ -829,8 +831,10 @@ def maybe_castable(arr):
     # check datetime64[ns]/timedelta64[ns] are valid
     # otherwise try to coerce
     kind = arr.dtype.kind
-    if kind == 'M' or kind == 'm':
-        return is_datetime64_dtype(arr.dtype)
+    if kind == 'M':
+        return is_datetime64_ns_dtype(arr.dtype)
+    elif kind == 'm':
+        return is_timedelta64_ns_dtype(arr.dtype)
 
     return arr.dtype.name not in _POSSIBLY_CAST_DTYPES
 
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 1359a938e..50f03aca9 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -1027,13 +1027,16 @@ class Index(IndexOpsMixin, PandasObject):
             result.index = self
         return result
 
-    def _to_embed(self, keep_tz=False):
+    def _to_embed(self, keep_tz=False, dtype=None):
         """
         *this is an internal non-public method*
 
         return an array repr of this object, potentially casting to object
 
         """
+        if dtype is not None:
+            return self.astype(dtype)._to_embed(keep_tz=keep_tz)
+
         return self.values.copy()
 
     _index_shared_docs['astype'] = """
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 64b5b9f95..3a11c80ec 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -917,7 +917,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
             return Index(self.format(), name=self.name, dtype=object)
         elif is_period_dtype(dtype):
             return self.to_period(freq=dtype.freq)
-        raise ValueError('Cannot cast DatetimeIndex to dtype %s' % dtype)
+        raise TypeError('Cannot cast DatetimeIndex to dtype %s' % dtype)
 
     def _get_time_micros(self):
         values = self.asi8
@@ -957,12 +957,15 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
                       index=self._shallow_copy(),
                       name=self.name)
 
-    def _to_embed(self, keep_tz=False):
+    def _to_embed(self, keep_tz=False, dtype=None):
         """
         return an array repr of this object, potentially casting to object
 
         This is for internal compat
         """
+        if dtype is not None:
+            return self.astype(dtype)._to_embed(keep_tz=keep_tz)
+
         if keep_tz and self.tz is not None:
 
             # preserve the tz & copy
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 85e330091..76004994a 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -464,10 +464,14 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
     def _box_func(self):
         return lambda x: Period._from_ordinal(ordinal=x, freq=self.freq)
 
-    def _to_embed(self, keep_tz=False):
+    def _to_embed(self, keep_tz=False, dtype=None):
         """
         return an array repr of this object, potentially casting to object
         """
+
+        if dtype is not None:
+            return self.astype(dtype)._to_embed(keep_tz=keep_tz)
+
         return self.asobject.values
 
     @property
@@ -510,7 +514,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
             return self.to_timestamp(how=how).tz_localize(dtype.tz)
         elif is_period_dtype(dtype):
             return self.asfreq(freq=dtype.freq)
-        raise ValueError('Cannot cast PeriodIndex to dtype %s' % dtype)
+        raise TypeError('Cannot cast PeriodIndex to dtype %s' % dtype)
 
     @Substitution(klass='PeriodIndex')
     @Appender(_shared_docs['searchsorted'])
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index c592aa960..eb4a9ce7e 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -495,7 +495,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
         elif is_integer_dtype(dtype):
             return Index(self.values.astype('i8', copy=copy), dtype='i8',
                          name=self.name)
-        raise ValueError('Cannot cast TimedeltaIndex to dtype %s' % dtype)
+        raise TypeError('Cannot cast TimedeltaIndex to dtype %s' % dtype)
 
     def union(self, other):
         """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 6142ccdd2..be1de4c68 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -29,7 +29,8 @@ from pandas.core.dtypes.common import (
     _is_unorderable_exception,
     _ensure_platform_int,
     pandas_dtype)
-from pandas.core.dtypes.generic import ABCSparseArray, ABCDataFrame
+from pandas.core.dtypes.generic import (
+    ABCSparseArray, ABCDataFrame, ABCIndexClass)
 from pandas.core.dtypes.cast import (
     maybe_upcast, infer_dtype_from_scalar,
     maybe_convert_platform,
@@ -184,8 +185,8 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 if name is None:
                     name = data.name
 
-                data = data._to_embed(keep_tz=True)
-                copy = True
+                data = data._to_embed(keep_tz=True, dtype=dtype)
+                copy = False
             elif isinstance(data, np.ndarray):
                 pass
             elif isinstance(data, Series):
@@ -3139,7 +3140,9 @@ def _sanitize_index(data, index, copy=False):
     if len(data) != len(index):
         raise ValueError('Length of values does not match length of ' 'index')
 
-    if isinstance(data, PeriodIndex):
+    if isinstance(data, ABCIndexClass) and not copy:
+        pass
+    elif isinstance(data, PeriodIndex):
         data = data.asobject
     elif isinstance(data, DatetimeIndex):
         data = data._to_embed(keep_tz=True)
@@ -3209,12 +3212,11 @@ def _sanitize_array(data, index, dtype=None, copy=False,
             # e.g. indexes can have different conversions (so don't fast path
             # them)
             # GH 6140
-            subarr = _sanitize_index(data, index, copy=True)
+            subarr = _sanitize_index(data, index, copy=copy)
         else:
-            subarr = _try_cast(data, True)
 
-        if copy:
-            subarr = data.copy()
+            # we will try to copy be-definition here
+            subarr = _try_cast(data, True)
 
     elif isinstance(data, Categorical):
         subarr = data
diff --git a/pandas/tests/frame/test_block_internals.py b/pandas/tests/frame/test_block_internals.py
index 3ca185cf1..c29821ba5 100644
--- a/pandas/tests/frame/test_block_internals.py
+++ b/pandas/tests/frame/test_block_internals.py
@@ -233,10 +233,6 @@ class TestDataFrameBlockInternals(TestData):
 
         # convert from a numpy array of non-ns timedelta64
         arr = np.array([1, 2, 3], dtype='timedelta64[s]')
-        s = Series(arr)
-        expected = Series(pd.timedelta_range('00:00:01', periods=3, freq='s'))
-        assert_series_equal(s, expected)
-
         df = DataFrame(index=range(3))
         df['A'] = arr
         expected = DataFrame({'A': pd.timedelta_range('00:00:01', periods=3,
@@ -244,21 +240,6 @@ class TestDataFrameBlockInternals(TestData):
                              index=range(3))
         assert_frame_equal(df, expected)
 
-        # convert from a numpy array of non-ns datetime64
-        # note that creating a numpy datetime64 is in LOCAL time!!!!
-        # seems to work for M8[D], but not for M8[s]
-
-        s = Series(np.array(['2013-01-01', '2013-01-02',
-                             '2013-01-03'], dtype='datetime64[D]'))
-        assert_series_equal(s, Series(date_range('20130101', periods=3,
-                                                 freq='D')))
-
-        # s = Series(np.array(['2013-01-01 00:00:01','2013-01-01
-        # 00:00:02','2013-01-01 00:00:03'],dtype='datetime64[s]'))
-
-        # assert_series_equal(s,date_range('20130101
-        # 00:00:01',period=3,freq='s'))
-
         expected = DataFrame({
             'dt1': Timestamp('20130101'),
             'dt2': date_range('20130101', periods=3),
@@ -467,7 +448,7 @@ starting,ending,measure
         self.mixed_frame['I'] = '1'
 
         # add in some items that will be nan
-        l = len(self.mixed_frame)
+        length = len(self.mixed_frame)
         self.mixed_frame['J'] = '1.'
         self.mixed_frame['K'] = '1'
         self.mixed_frame.loc[0:5, ['J', 'K']] = 'garbled'
@@ -476,8 +457,8 @@ starting,ending,measure
         assert converted['I'].dtype == 'int64'
         assert converted['J'].dtype == 'float64'
         assert converted['K'].dtype == 'float64'
-        assert len(converted['J'].dropna()) == l - 5
-        assert len(converted['K'].dropna()) == l - 5
+        assert len(converted['J'].dropna()) == length - 5
+        assert len(converted['K'].dropna()) == length - 5
 
         # via astype
         converted = self.mixed_frame.copy()
diff --git a/pandas/tests/indexes/datetimes/test_astype.py b/pandas/tests/indexes/datetimes/test_astype.py
index 0197fc4c5..e211807b6 100644
--- a/pandas/tests/indexes/datetimes/test_astype.py
+++ b/pandas/tests/indexes/datetimes/test_astype.py
@@ -130,11 +130,11 @@ class TestDatetimeIndex(object):
         # GH 13149, GH 13209
         idx = DatetimeIndex(['2016-05-16', 'NaT', NaT, np.NaN])
 
-        pytest.raises(ValueError, idx.astype, float)
-        pytest.raises(ValueError, idx.astype, 'timedelta64')
-        pytest.raises(ValueError, idx.astype, 'timedelta64[ns]')
-        pytest.raises(ValueError, idx.astype, 'datetime64')
-        pytest.raises(ValueError, idx.astype, 'datetime64[D]')
+        pytest.raises(TypeError, idx.astype, float)
+        pytest.raises(TypeError, idx.astype, 'timedelta64')
+        pytest.raises(TypeError, idx.astype, 'timedelta64[ns]')
+        pytest.raises(TypeError, idx.astype, 'datetime64')
+        pytest.raises(TypeError, idx.astype, 'datetime64[D]')
 
     def test_index_convert_to_datetime_array(self):
         def _check_rng(rng):
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index e5ee078d3..7fefcc859 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -47,10 +47,10 @@ class TestPeriodIndex(DatetimeLike):
         # GH 13149, GH 13209
         idx = PeriodIndex(['2016-05-16', 'NaT', NaT, np.NaN], freq='D')
 
-        pytest.raises(ValueError, idx.astype, str)
-        pytest.raises(ValueError, idx.astype, float)
-        pytest.raises(ValueError, idx.astype, 'timedelta64')
-        pytest.raises(ValueError, idx.astype, 'timedelta64[ns]')
+        pytest.raises(TypeError, idx.astype, str)
+        pytest.raises(TypeError, idx.astype, float)
+        pytest.raises(TypeError, idx.astype, 'timedelta64')
+        pytest.raises(TypeError, idx.astype, 'timedelta64[ns]')
 
     def test_pickle_compat_construction(self):
         pass
diff --git a/pandas/tests/indexes/timedeltas/test_astype.py b/pandas/tests/indexes/timedeltas/test_astype.py
index 7a761cfe3..0fa0e0360 100644
--- a/pandas/tests/indexes/timedeltas/test_astype.py
+++ b/pandas/tests/indexes/timedeltas/test_astype.py
@@ -66,10 +66,10 @@ class TestTimedeltaIndex(DatetimeLike):
         # GH 13149, GH 13209
         idx = TimedeltaIndex([1e14, 'NaT', pd.NaT, np.NaN])
 
-        pytest.raises(ValueError, idx.astype, float)
-        pytest.raises(ValueError, idx.astype, str)
-        pytest.raises(ValueError, idx.astype, 'datetime64')
-        pytest.raises(ValueError, idx.astype, 'datetime64[ns]')
+        pytest.raises(TypeError, idx.astype, float)
+        pytest.raises(TypeError, idx.astype, str)
+        pytest.raises(TypeError, idx.astype, 'datetime64')
+        pytest.raises(TypeError, idx.astype, 'datetime64[ns]')
 
     def test_pickle_compat_construction(self):
         pass
diff --git a/pandas/tests/series/test_constructors.py b/pandas/tests/series/test_constructors.py
index d29608602..e62b19294 100644
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -14,9 +14,9 @@ from pandas.api.types import CategoricalDtype
 from pandas.core.dtypes.common import (
     is_categorical_dtype,
     is_datetime64tz_dtype)
-from pandas import (Index, Series, isna, date_range,
-                    NaT, period_range, MultiIndex, IntervalIndex)
-from pandas.core.indexes.datetimes import Timestamp, DatetimeIndex
+from pandas import (Index, Series, isna, date_range, Timestamp,
+                    NaT, period_range, timedelta_range, MultiIndex,
+                    IntervalIndex)
 
 from pandas._libs import lib
 from pandas._libs.tslib import iNaT
@@ -289,6 +289,25 @@ class TestSeriesConstructors(TestData):
             assert x[0] == 2.
             assert y[0] == 1.
 
+    @pytest.mark.parametrize(
+        "index",
+        [
+            pd.date_range('20170101', periods=3, tz='US/Eastern'),
+            pd.date_range('20170101', periods=3),
+            pd.timedelta_range('1 day', periods=3),
+            pd.period_range('2012Q1', periods=3, freq='Q'),
+            pd.Index(list('abc')),
+            pd.Int64Index([1, 2, 3]),
+            pd.RangeIndex(0, 3)],
+        ids=lambda x: type(x).__name__)
+    def test_constructor_limit_copies(self, index):
+        # GH 17449
+        # limit copies of input
+        s = pd.Series(index)
+
+        # we make 1 copy; this is just a smoke test here
+        assert s._data.blocks[0].values is not index
+
     def test_constructor_pass_none(self):
         s = Series(None, index=lrange(5))
         assert s.dtype == np.float64
@@ -524,25 +543,6 @@ class TestSeriesConstructors(TestData):
         result = pd.concat([s.iloc[0:1], s.iloc[1:]])
         assert_series_equal(result, s)
 
-        # astype
-        result = s.astype(object)
-        expected = Series(DatetimeIndex(s._values).asobject)
-        assert_series_equal(result, expected)
-
-        result = Series(s.values).dt.tz_localize('UTC').dt.tz_convert(s.dt.tz)
-        assert_series_equal(result, s)
-
-        # astype - datetime64[ns, tz]
-        result = Series(s.values).astype('datetime64[ns, US/Eastern]')
-        assert_series_equal(result, s)
-
-        result = Series(s.values).astype(s.dtype)
-        assert_series_equal(result, s)
-
-        result = s.astype('datetime64[ns, CET]')
-        expected = Series(date_range('20130101 06:00:00', periods=3, tz='CET'))
-        assert_series_equal(result, expected)
-
         # short str
         assert 'datetime64[ns, US/Eastern]' in str(s)
 
@@ -807,17 +807,67 @@ class TestSeriesConstructors(TestData):
         series = Series(list(date_range('1/1/2000', periods=10)))
         assert series.dtype == 'M8[ns]'
 
-    def test_constructor_cant_cast_datetime64(self):
-        msg = "Cannot cast datetime64 to "
-        with tm.assert_raises_regex(TypeError, msg):
-            Series(date_range('1/1/2000', periods=10), dtype=float)
+    def test_convert_non_ns(self):
+        # convert from a numpy array of non-ns timedelta64
+        arr = np.array([1, 2, 3], dtype='timedelta64[s]')
+        s = Series(arr)
+        expected = Series(pd.timedelta_range('00:00:01', periods=3, freq='s'))
+        assert_series_equal(s, expected)
+
+        # convert from a numpy array of non-ns datetime64
+        # note that creating a numpy datetime64 is in LOCAL time!!!!
+        # seems to work for M8[D], but not for M8[s]
+
+        s = Series(np.array(['2013-01-01', '2013-01-02',
+                             '2013-01-03'], dtype='datetime64[D]'))
+        assert_series_equal(s, Series(date_range('20130101', periods=3,
+                                                 freq='D')))
+
+        # s = Series(np.array(['2013-01-01 00:00:01','2013-01-01
+        # 00:00:02','2013-01-01 00:00:03'],dtype='datetime64[s]'))
+
+        # assert_series_equal(s,date_range('20130101
+        # 00:00:01',period=3,freq='s'))
+
+    @pytest.mark.parametrize(
+        "index",
+        [
+            date_range('1/1/2000', periods=10),
+            timedelta_range('1 day', periods=10),
+            period_range('2000-Q1', periods=10, freq='Q')],
+        ids=lambda x: type(x).__name__)
+    def test_constructor_cant_cast_datetimelike(self, index):
 
+        # floats are not ok
+        msg = "Cannot cast {} to ".format(type(index).__name__)
         with tm.assert_raises_regex(TypeError, msg):
-            Series(date_range('1/1/2000', periods=10), dtype=int)
+            Series(index, dtype=float)
+
+        # ints are ok
+        # we test with np.int64 to get similar results on
+        # windows / 32-bit platforms
+        result = Series(index, dtype=np.int64)
+        expected = Series(index.astype(np.int64))
+        tm.assert_series_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "index",
+        [
+            date_range('1/1/2000', periods=10),
+            timedelta_range('1 day', periods=10),
+            period_range('2000-Q1', periods=10, freq='Q')],
+        ids=lambda x: type(x).__name__)
+    def test_constructor_cast_object(self, index):
+        s = Series(index, dtype=object)
+        exp = Series(index).astype(object)
+        tm.assert_series_equal(s, exp)
+
+        s = Series(pd.Index(index, dtype=object), dtype=object)
+        exp = Series(index).astype(object)
+        tm.assert_series_equal(s, exp)
 
-    def test_constructor_cast_object(self):
-        s = Series(date_range('1/1/2000', periods=10), dtype=object)
-        exp = Series(date_range('1/1/2000', periods=10))
+        s = Series(index.astype(object), dtype=object)
+        exp = Series(index).astype(object)
         tm.assert_series_equal(s, exp)
 
     def test_constructor_generic_timestamp_deprecated(self):
diff --git a/pandas/tests/series/test_dtypes.py b/pandas/tests/series/test_dtypes.py
index b20c1817e..ad6d019b5 100644
--- a/pandas/tests/series/test_dtypes.py
+++ b/pandas/tests/series/test_dtypes.py
@@ -17,6 +17,7 @@ from pandas import (
     Categorical, Index
 )
 from pandas.api.types import CategoricalDtype
+import pandas._libs.tslib as tslib
 
 from pandas.compat import lrange, range, u
 from pandas import compat
@@ -69,8 +70,7 @@ class TestSeriesDtypes(TestData):
 
         tm.assert_series_equal(result, Series(np.arange(1, 5)))
 
-    def test_astype_datetimes(self):
-        import pandas._libs.tslib as tslib
+    def test_astype_datetime(self):
         s = Series(tslib.iNaT, dtype='M8[ns]', index=lrange(5))
 
         s = s.astype('O')
@@ -89,6 +89,33 @@ class TestSeriesDtypes(TestData):
         s = s.astype('O')
         assert s.dtype == np.object_
 
+    def test_astype_datetime64tz(self):
+        s = Series(date_range('20130101', periods=3, tz='US/Eastern'))
+
+        # astype
+        result = s.astype(object)
+        expected = Series(s.astype(object), dtype=object)
+        tm.assert_series_equal(result, expected)
+
+        result = Series(s.values).dt.tz_localize('UTC').dt.tz_convert(s.dt.tz)
+        tm.assert_series_equal(result, s)
+
+        # astype - object, preserves on construction
+        result = Series(s.astype(object))
+        expected = s.astype(object)
+        tm.assert_series_equal(result, expected)
+
+        # astype - datetime64[ns, tz]
+        result = Series(s.values).astype('datetime64[ns, US/Eastern]')
+        tm.assert_series_equal(result, s)
+
+        result = Series(s.values).astype(s.dtype)
+        tm.assert_series_equal(result, s)
+
+        result = s.astype('datetime64[ns, CET]')
+        expected = Series(date_range('20130101 06:00:00', periods=3, tz='CET'))
+        tm.assert_series_equal(result, expected)
+
     @pytest.mark.parametrize("dtype", [compat.text_type, np.str_])
     @pytest.mark.parametrize("series", [Series([string.digits * 10,
                                                 tm.rands(63),

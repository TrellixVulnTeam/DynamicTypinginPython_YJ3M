commit 253869cc242ffc2b457f80276d71a6d7b78841b4
Author: Alex Rothberg <agrothberg@gmail.com>
Date:   Mon Nov 4 20:40:06 2013 -0500

    Reordered DateOffset classes after merge

diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index 04e87e43a..b763fc6b1 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -978,211 +978,329 @@ class BQuarterEnd(CacheableOffset, QuarterOffset):
         return BMonthEnd().onOffset(dt) and modMonth == 0
 
 
-class FY5253(CacheableOffset, DateOffset):
-    """
-    Describes 52-53 week fiscal year. This is also known as a 4-4-5 calendar.
+_int_to_month = {
+    1: 'JAN',
+    2: 'FEB',
+    3: 'MAR',
+    4: 'APR',
+    5: 'MAY',
+    6: 'JUN',
+    7: 'JUL',
+    8: 'AUG',
+    9: 'SEP',
+    10: 'OCT',
+    11: 'NOV',
+    12: 'DEC'
+}
 
-    It is used by companies that desire that their
-    fiscal year always end on the same day of the week.
+_month_to_int = dict((v, k) for k, v in _int_to_month.items())
 
-    It is a method of managing accounting periods.
-    It is a common calendar structure for some industries,
-    such as retail, manufacturing and parking industry.
 
-    For more information see:
-    http://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar
+# TODO: This is basically the same as BQuarterEnd
+class BQuarterBegin(CacheableOffset, QuarterOffset):
+    _outputName = "BusinessQuarterBegin"
+    # I suspect this is wrong for *all* of them.
+    _default_startingMonth = 3
+    _from_name_startingMonth = 1
+    _prefix = 'BQS'
 
+    def apply(self, other):
+        n = self.n
+        other = as_datetime(other)
 
-    The year may either:
-    - end on the last X day of the Y month.
-    - end on the last X day closest to the last day of the Y month.
+        wkday, _ = tslib.monthrange(other.year, other.month)
 
-    X is a specific day of the week.
-    Y is a certain month of the year
+        first = _get_firstbday(wkday)
 
-    Parameters
-    ----------
-    n : int
-    weekday : {0, 1, ..., 6}
-        0: Mondays
-        1: Tuesdays
-        2: Wednesdays
-        3: Thursdays
-        4: Fridays
-        5: Saturdays
-        6: Sundays
-    startingMonth : The month in which fiscal years end. {1, 2, ... 12}
-    variation : str
-        {"nearest", "last"} for "LastOfMonth" or "NearestEndMonth"
-    """
+        monthsSince = (other.month - self.startingMonth) % 3
 
-    _prefix = 'RE'
-    _suffix_prefix_last = 'L'
-    _suffix_prefix_nearest = 'N'
+        if n <= 0 and monthsSince != 0:  # make sure to roll forward so negate
+            monthsSince = monthsSince - 3
 
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds['startingMonth']
-        self.weekday = kwds["weekday"]
+        # roll forward if on same month later than first bday
+        if n <= 0 and (monthsSince == 0 and other.day > first):
+            n = n + 1
+        # pretend to roll back if on same month but before firstbday
+        elif n > 0 and (monthsSince == 0 and other.day < first):
+            n = n - 1
 
-        self.variation = kwds["variation"]
+        # get the first bday for result
+        other = other + relativedelta(months=3 * n - monthsSince)
+        wkday, _ = tslib.monthrange(other.year, other.month)
+        first = _get_firstbday(wkday)
+        result = datetime(other.year, other.month, first,
+                          other.hour, other.minute, other.second,
+                          other.microsecond)
+        return as_timestamp(result)
 
-        self.kwds = kwds
 
-        if self.n == 0:
-            raise ValueError('N cannot be 0')
+class QuarterEnd(CacheableOffset, QuarterOffset):
+    """DateOffset increments between business Quarter dates
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...
+    """
+    _outputName = 'QuarterEnd'
+    _default_startingMonth = 3
+    _prefix = 'Q'
 
-        if self.variation not in ["nearest", "last"]:
-            raise ValueError('%s is not a valid variation' % self.variation)
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
 
-        if self.variation == "nearest":
-            weekday_offset = weekday(self.weekday)
-            self._rd_forward = relativedelta(weekday=weekday_offset)
-            self._rd_backward = relativedelta(weekday=weekday_offset(-1))
-        else:
-            self._offset_lwom = LastWeekOfMonth(n=1, weekday=self.weekday)
+        self.kwds = kwds
 
     def isAnchored(self):
-        return self.n == 1 \
-                and self.startingMonth is not None \
-                and self.weekday is not None
-
-    def onOffset(self, dt):
-        year_end = self.get_year_end(dt)
-
-        if self.variation == "nearest":
-            # We have to check the year end of "this" cal year AND the previous
-            return year_end == dt or \
-                self.get_year_end(dt - relativedelta(months=1)) == dt
-        else:
-            return year_end == dt
+        return (self.n == 1 and self.startingMonth is not None)
 
     def apply(self, other):
         n = self.n
-        prev_year = self.get_year_end(
-                        datetime(other.year - 1, self.startingMonth, 1))
-        cur_year = self.get_year_end(
-                        datetime(other.year, self.startingMonth, 1))
-        next_year = self.get_year_end(
-                        datetime(other.year + 1, self.startingMonth, 1))
+        other = as_datetime(other)
 
-        if n > 0:
-            if other == prev_year:
-                year = other.year - 1
-            elif other == cur_year:
-                year = other.year
-            elif other == next_year:
-                year = other.year + 1
-            elif other < prev_year:
-                year = other.year - 1
-                n -= 1
-            elif other < cur_year:
-                year = other.year
-                n -= 1
-            elif other < next_year:
-                year = other.year + 1
-                n -= 1
-            else:
-                assert False
+        wkday, days_in_month = tslib.monthrange(other.year, other.month)
 
-            return self.get_year_end(datetime(year + n, self.startingMonth, 1))
-        else:
-            n = -n
-            if other == prev_year:
-                year = other.year - 1
-            elif other == cur_year:
-                year = other.year
-            elif other == next_year:
-                year = other.year + 1
-            elif other > next_year:
-                year = other.year + 1
-                n -= 1
-            elif other > cur_year:
-                year = other.year
-                n -= 1
-            elif other > prev_year:
-                year = other.year - 1
-                n -= 1
-            else:
-                assert False
+        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
+        if monthsToGo == 3:
+            monthsToGo = 0
 
-            return self.get_year_end(datetime(year - n, self.startingMonth, 1))
+        if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
+            n = n - 1
 
-    def get_year_end(self, dt):
-        if self.variation == "nearest":
-            return self._get_year_end_nearest(dt)
-        else:
-            return self._get_year_end_last(dt)
+        other = other + relativedelta(months=monthsToGo + 3 * n, day=31)
 
-    def get_target_month_end(self, dt):
-        target_month = datetime(year=dt.year, month=self.startingMonth, day=1)
-        next_month_first_of = target_month + relativedelta(months=+1)
-        return next_month_first_of + relativedelta(days=-1)
+        return as_timestamp(other)
 
-    def _get_year_end_nearest(self, dt):
-        target_date = self.get_target_month_end(dt)
-        if target_date.weekday() == self.weekday:
-            return target_date
-        else:
-            forward = target_date + self._rd_forward
-            backward = target_date + self._rd_backward
+    def onOffset(self, dt):
+        modMonth = (dt.month - self.startingMonth) % 3
+        return MonthEnd().onOffset(dt) and modMonth == 0
 
-            if forward - target_date < target_date - backward:
-                return forward
-            else:
-                return backward
 
-    def _get_year_end_last(self, dt):
-        current_year = datetime(year=dt.year, month=self.startingMonth, day=1)
-        return current_year + self._offset_lwom
+class QuarterBegin(CacheableOffset, QuarterOffset):
+    _outputName = 'QuarterBegin'
+    _default_startingMonth = 3
+    _from_name_startingMonth = 1
+    _prefix = 'QS'
 
-    @property
-    def rule_code(self):
-        suffix = self.get_rule_code_suffix()
-        return "%s-%s" % (self._get_prefix(), suffix)
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
 
-    def _get_prefix(self):
-        return self._prefix
+    def apply(self, other):
+        n = self.n
+        other = as_datetime(other)
 
-    def _get_suffix_prefix(self):
-        if self.variation == "nearest":
-            return self._suffix_prefix_nearest
-        else:
-            return self._suffix_prefix_last
+        wkday, days_in_month = tslib.monthrange(other.year, other.month)
 
-    def get_rule_code_suffix(self):
-        return '%s-%s-%s' % (self._get_suffix_prefix(), \
-                           _int_to_month[self.startingMonth], \
-                         _int_to_weekday[self.weekday])
+        monthsSince = (other.month - self.startingMonth) % 3
 
-    @classmethod
-    def _parse_suffix(cls, varion_code, startingMonth_code, weekday_code):
-        if varion_code == "N":
-            variation = "nearest"
-        elif varion_code == "L":
-            variation = "last"
-        else:
-            raise ValueError(
-                "Unable to parse varion_code: %s" % (varion_code,))
+        if n <= 0 and monthsSince != 0:
+            # make sure you roll forward, so negate
+            monthsSince = monthsSince - 3
 
-        startingMonth = _month_to_int[startingMonth_code]
-        weekday = _weekday_to_int[weekday_code]
+        if n < 0 and (monthsSince == 0 and other.day > 1):
+            # after start, so come back an extra period as if rolled forward
+            n = n + 1
 
-        return {
-                "weekday": weekday,
-                "startingMonth": startingMonth,
-                "variation": variation,
-                }
+        other = other + relativedelta(months=3 * n - monthsSince, day=1)
+        return as_timestamp(other)
 
-    @classmethod
-    def _from_name(cls, *args):
-        return cls(**cls._parse_suffix(*args))
 
+class YearOffset(DateOffset):
+    """DateOffset that just needs a month"""
 
-class FY5253Quarter(CacheableOffset, DateOffset):
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', self._default_month)
+
+        if self.month < 1 or self.month > 12:
+            raise ValueError('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    @classmethod
+    def _from_name(cls, suffix=None):
+        kwargs = {}
+        if suffix:
+            kwargs['month'] = _month_to_int[suffix]
+        return cls(**kwargs)
+
+    @property
+    def rule_code(self):
+        return '%s-%s' % (self._prefix, _int_to_month[self.month])
+
+
+class BYearEnd(CacheableOffset, YearOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessYearEnd'
+    _default_month = 12
+    _prefix = 'BA'
+
+    def apply(self, other):
+        n = self.n
+        other = as_datetime(other)
+
+        wkday, days_in_month = tslib.monthrange(other.year, self.month)
+        lastBDay = (days_in_month -
+                    max(((wkday + days_in_month - 1) % 7) - 4, 0))
+
+        years = n
+        if n > 0:
+            if (other.month < self.month or
+                    (other.month == self.month and other.day < lastBDay)):
+                years -= 1
+        elif n <= 0:
+            if (other.month > self.month or
+                    (other.month == self.month and other.day > lastBDay)):
+                years += 1
+
+        other = other + relativedelta(years=years)
+
+        _, days_in_month = tslib.monthrange(other.year, self.month)
+        result = datetime(other.year, self.month, days_in_month,
+                          other.hour, other.minute, other.second,
+                          other.microsecond)
+
+        if result.weekday() > 4:
+            result = result - BDay()
+
+        return result
+
+
+class BYearBegin(CacheableOffset, YearOffset):
+    """DateOffset increments between business year begin dates"""
+    _outputName = 'BusinessYearBegin'
+    _default_month = 1
+    _prefix = 'BAS'
+
+    def apply(self, other):
+        n = self.n
+        other = as_datetime(other)
+
+        wkday, days_in_month = tslib.monthrange(other.year, self.month)
+
+        first = _get_firstbday(wkday)
+
+        years = n
+
+        if n > 0:  # roll back first for positive n
+            if (other.month < self.month or
+                    (other.month == self.month and other.day < first)):
+                years -= 1
+        elif n <= 0:  # roll forward
+            if (other.month > self.month or
+                    (other.month == self.month and other.day > first)):
+                years += 1
+
+        # set first bday for result
+        other = other + relativedelta(years=years)
+        wkday, days_in_month = tslib.monthrange(other.year, self.month)
+        first = _get_firstbday(wkday)
+        return as_timestamp(datetime(other.year, self.month, first))
+
+
+class YearEnd(CacheableOffset, YearOffset):
+    """DateOffset increments between calendar year ends"""
+    _default_month = 12
+    _prefix = 'A'
+
+    def apply(self, other):
+        def _increment(date):
+            if date.month == self.month:
+                _, days_in_month = tslib.monthrange(date.year, self.month)
+                if date.day != days_in_month:
+                    year = date.year
+                else:
+                    year = date.year + 1
+            elif date.month < self.month:
+                year = date.year
+            else:
+                year = date.year + 1
+            _, days_in_month = tslib.monthrange(year, self.month)
+            return datetime(year, self.month, days_in_month,
+                            date.hour, date.minute, date.second,
+                            date.microsecond)
+
+        def _decrement(date):
+            year = date.year if date.month > self.month else date.year - 1
+            _, days_in_month = tslib.monthrange(year, self.month)
+            return datetime(year, self.month, days_in_month,
+                            date.hour, date.minute, date.second,
+                            date.microsecond)
+
+        def _rollf(date):
+            if date.month != self.month or\
+               date.day < tslib.monthrange(date.year, date.month)[1]:
+                date = _increment(date)
+            return date
+
+        n = self.n
+        result = other
+        if n > 0:
+            while n > 0:
+                result = _increment(result)
+                n -= 1
+        elif n < 0:
+            while n < 0:
+                result = _decrement(result)
+                n += 1
+        else:
+            # n == 0, roll forward
+            result = _rollf(result)
+
+        return as_timestamp(result)
+
+    def onOffset(self, dt):
+        wkday, days_in_month = tslib.monthrange(dt.year, self.month)
+        return self.month == dt.month and dt.day == days_in_month
+
+
+class YearBegin(CacheableOffset, YearOffset):
+    """DateOffset increments between calendar year begin dates"""
+    _default_month = 1
+    _prefix = 'AS'
+
+    def apply(self, other):
+        def _increment(date):
+            year = date.year
+            if date.month >= self.month:
+                year += 1
+            return datetime(year, self.month, 1, date.hour, date.minute,
+                            date.second, date.microsecond)
+
+        def _decrement(date):
+            year = date.year
+            if date.month < self.month or (date.month == self.month and
+                                           date.day == 1):
+                year -= 1
+            return datetime(year, self.month, 1, date.hour, date.minute,
+                            date.second, date.microsecond)
+
+        def _rollf(date):
+            if (date.month != self.month) or date.day > 1:
+                date = _increment(date)
+            return date
+
+        n = self.n
+        result = other
+        if n > 0:
+            while n > 0:
+                result = _increment(result)
+                n -= 1
+        elif n < 0:
+            while n < 0:
+                result = _decrement(result)
+                n += 1
+        else:
+            # n == 0, roll forward
+            result = _rollf(result)
+
+        return as_timestamp(result)
+
+    def onOffset(self, dt):
+        return dt.month == self.month and dt.day == 1
+
+
+class FY5253(CacheableOffset, DateOffset):
     """
-    DateOffset increments between business quarter dates
-    for 52-53 week fiscal year (also known as a 4-4-5 calendar).
+    Describes 52-53 week fiscal year. This is also known as a 4-4-5 calendar.
 
     It is used by companies that desire that their
     fiscal year always end on the same day of the week.
@@ -1194,6 +1312,7 @@ class FY5253Quarter(CacheableOffset, DateOffset):
     For more information see:
     http://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar
 
+
     The year may either:
     - end on the last X day of the Y month.
     - end on the last X day closest to the last day of the Y month.
@@ -1201,10 +1320,6 @@ class FY5253Quarter(CacheableOffset, DateOffset):
     X is a specific day of the week.
     Y is a certain month of the year
 
-    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
-    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
-    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
-
     Parameters
     ----------
     n : int
@@ -1217,48 +1332,253 @@ class FY5253Quarter(CacheableOffset, DateOffset):
         5: Saturdays
         6: Sundays
     startingMonth : The month in which fiscal years end. {1, 2, ... 12}
-    qtr_with_extra_week : The quarter number that has the leap
-        or 14 week when needed. {1,2,3,4}
     variation : str
         {"nearest", "last"} for "LastOfMonth" or "NearestEndMonth"
     """
 
-    _prefix = 'REQ'
+    _prefix = 'RE'
+    _suffix_prefix_last = 'L'
+    _suffix_prefix_nearest = 'N'
 
     def __init__(self, n=1, **kwds):
         self.n = n
+        self.startingMonth = kwds['startingMonth']
+        self.weekday = kwds["weekday"]
 
-        self.qtr_with_extra_week = kwds["qtr_with_extra_week"]
+        self.variation = kwds["variation"]
 
         self.kwds = kwds
 
         if self.n == 0:
             raise ValueError('N cannot be 0')
 
-        self._offset = FY5253( \
-                            startingMonth=kwds['startingMonth'], \
-                            weekday=kwds["weekday"],
-                            variation=kwds["variation"])
+        if self.variation not in ["nearest", "last"]:
+            raise ValueError('%s is not a valid variation' % self.variation)
+
+        if self.variation == "nearest":
+            weekday_offset = weekday(self.weekday)
+            self._rd_forward = relativedelta(weekday=weekday_offset)
+            self._rd_backward = relativedelta(weekday=weekday_offset(-1))
+        else:
+            self._offset_lwom = LastWeekOfMonth(n=1, weekday=self.weekday)
 
     def isAnchored(self):
-        return self.n == 1 and self._offset.isAnchored()
+        return self.n == 1 \
+                and self.startingMonth is not None \
+                and self.weekday is not None
+
+    def onOffset(self, dt):
+        year_end = self.get_year_end(dt)
+
+        if self.variation == "nearest":
+            # We have to check the year end of "this" cal year AND the previous
+            return year_end == dt or \
+                self.get_year_end(dt - relativedelta(months=1)) == dt
+        else:
+            return year_end == dt
 
     def apply(self, other):
-        other = as_datetime(other)
         n = self.n
+        prev_year = self.get_year_end(
+                        datetime(other.year - 1, self.startingMonth, 1))
+        cur_year = self.get_year_end(
+                        datetime(other.year, self.startingMonth, 1))
+        next_year = self.get_year_end(
+                        datetime(other.year + 1, self.startingMonth, 1))
 
         if n > 0:
-            while n > 0:
-                if not self._offset.onOffset(other):
-                    qtr_lens = self.get_weeks(other)
-                    start = other - self._offset
-                else:
-                    start = other
-                    qtr_lens = self.get_weeks(other + self._offset)
-
-                for weeks in qtr_lens:
-                    start += relativedelta(weeks=weeks)
-                    if start > other:
+            if other == prev_year:
+                year = other.year - 1
+            elif other == cur_year:
+                year = other.year
+            elif other == next_year:
+                year = other.year + 1
+            elif other < prev_year:
+                year = other.year - 1
+                n -= 1
+            elif other < cur_year:
+                year = other.year
+                n -= 1
+            elif other < next_year:
+                year = other.year + 1
+                n -= 1
+            else:
+                assert False
+
+            return self.get_year_end(datetime(year + n, self.startingMonth, 1))
+        else:
+            n = -n
+            if other == prev_year:
+                year = other.year - 1
+            elif other == cur_year:
+                year = other.year
+            elif other == next_year:
+                year = other.year + 1
+            elif other > next_year:
+                year = other.year + 1
+                n -= 1
+            elif other > cur_year:
+                year = other.year
+                n -= 1
+            elif other > prev_year:
+                year = other.year - 1
+                n -= 1
+            else:
+                assert False
+
+            return self.get_year_end(datetime(year - n, self.startingMonth, 1))
+
+    def get_year_end(self, dt):
+        if self.variation == "nearest":
+            return self._get_year_end_nearest(dt)
+        else:
+            return self._get_year_end_last(dt)
+
+    def get_target_month_end(self, dt):
+        target_month = datetime(year=dt.year, month=self.startingMonth, day=1)
+        next_month_first_of = target_month + relativedelta(months=+1)
+        return next_month_first_of + relativedelta(days=-1)
+
+    def _get_year_end_nearest(self, dt):
+        target_date = self.get_target_month_end(dt)
+        if target_date.weekday() == self.weekday:
+            return target_date
+        else:
+            forward = target_date + self._rd_forward
+            backward = target_date + self._rd_backward
+
+            if forward - target_date < target_date - backward:
+                return forward
+            else:
+                return backward
+
+    def _get_year_end_last(self, dt):
+        current_year = datetime(year=dt.year, month=self.startingMonth, day=1)
+        return current_year + self._offset_lwom
+
+    @property
+    def rule_code(self):
+        suffix = self.get_rule_code_suffix()
+        return "%s-%s" % (self._get_prefix(), suffix)
+
+    def _get_prefix(self):
+        return self._prefix
+
+    def _get_suffix_prefix(self):
+        if self.variation == "nearest":
+            return self._suffix_prefix_nearest
+        else:
+            return self._suffix_prefix_last
+
+    def get_rule_code_suffix(self):
+        return '%s-%s-%s' % (self._get_suffix_prefix(), \
+                           _int_to_month[self.startingMonth], \
+                         _int_to_weekday[self.weekday])
+
+    @classmethod
+    def _parse_suffix(cls, varion_code, startingMonth_code, weekday_code):
+        if varion_code == "N":
+            variation = "nearest"
+        elif varion_code == "L":
+            variation = "last"
+        else:
+            raise ValueError(
+                "Unable to parse varion_code: %s" % (varion_code,))
+
+        startingMonth = _month_to_int[startingMonth_code]
+        weekday = _weekday_to_int[weekday_code]
+
+        return {
+                "weekday": weekday,
+                "startingMonth": startingMonth,
+                "variation": variation,
+                }
+
+    @classmethod
+    def _from_name(cls, *args):
+        return cls(**cls._parse_suffix(*args))
+
+
+class FY5253Quarter(CacheableOffset, DateOffset):
+    """
+    DateOffset increments between business quarter dates
+    for 52-53 week fiscal year (also known as a 4-4-5 calendar).
+
+    It is used by companies that desire that their
+    fiscal year always end on the same day of the week.
+
+    It is a method of managing accounting periods.
+    It is a common calendar structure for some industries,
+    such as retail, manufacturing and parking industry.
+
+    For more information see:
+    http://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar
+
+    The year may either:
+    - end on the last X day of the Y month.
+    - end on the last X day closest to the last day of the Y month.
+
+    X is a specific day of the week.
+    Y is a certain month of the year
+
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
+
+    Parameters
+    ----------
+    n : int
+    weekday : {0, 1, ..., 6}
+        0: Mondays
+        1: Tuesdays
+        2: Wednesdays
+        3: Thursdays
+        4: Fridays
+        5: Saturdays
+        6: Sundays
+    startingMonth : The month in which fiscal years end. {1, 2, ... 12}
+    qtr_with_extra_week : The quarter number that has the leap
+        or 14 week when needed. {1,2,3,4}
+    variation : str
+        {"nearest", "last"} for "LastOfMonth" or "NearestEndMonth"
+    """
+
+    _prefix = 'REQ'
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+
+        self.qtr_with_extra_week = kwds["qtr_with_extra_week"]
+
+        self.kwds = kwds
+
+        if self.n == 0:
+            raise ValueError('N cannot be 0')
+
+        self._offset = FY5253( \
+                            startingMonth=kwds['startingMonth'], \
+                            weekday=kwds["weekday"],
+                            variation=kwds["variation"])
+
+    def isAnchored(self):
+        return self.n == 1 and self._offset.isAnchored()
+
+    def apply(self, other):
+        other = as_datetime(other)
+        n = self.n
+
+        if n > 0:
+            while n > 0:
+                if not self._offset.onOffset(other):
+                    qtr_lens = self.get_weeks(other)
+                    start = other - self._offset
+                else:
+                    start = other
+                    qtr_lens = self.get_weeks(other + self._offset)
+
+                for weeks in qtr_lens:
+                    start += relativedelta(weeks=weeks)
+                    if start > other:
                         other = start
                         n -= 1
                         break
@@ -1331,326 +1651,6 @@ class FY5253Quarter(CacheableOffset, DateOffset):
                           qtr_with_extra_week=int(args[-1])))
 
 
-_int_to_month = {
-    1: 'JAN',
-    2: 'FEB',
-    3: 'MAR',
-    4: 'APR',
-    5: 'MAY',
-    6: 'JUN',
-    7: 'JUL',
-    8: 'AUG',
-    9: 'SEP',
-    10: 'OCT',
-    11: 'NOV',
-    12: 'DEC'
-}
-
-_month_to_int = dict((v, k) for k, v in _int_to_month.items())
-
-
-# TODO: This is basically the same as BQuarterEnd
-class BQuarterBegin(CacheableOffset, QuarterOffset):
-    _outputName = "BusinessQuarterBegin"
-    # I suspect this is wrong for *all* of them.
-    _default_startingMonth = 3
-    _from_name_startingMonth = 1
-    _prefix = 'BQS'
-
-    def apply(self, other):
-        n = self.n
-        other = as_datetime(other)
-
-        wkday, _ = tslib.monthrange(other.year, other.month)
-
-        first = _get_firstbday(wkday)
-
-        monthsSince = (other.month - self.startingMonth) % 3
-
-        if n <= 0 and monthsSince != 0:  # make sure to roll forward so negate
-            monthsSince = monthsSince - 3
-
-        # roll forward if on same month later than first bday
-        if n <= 0 and (monthsSince == 0 and other.day > first):
-            n = n + 1
-        # pretend to roll back if on same month but before firstbday
-        elif n > 0 and (monthsSince == 0 and other.day < first):
-            n = n - 1
-
-        # get the first bday for result
-        other = other + relativedelta(months=3 * n - monthsSince)
-        wkday, _ = tslib.monthrange(other.year, other.month)
-        first = _get_firstbday(wkday)
-        result = datetime(other.year, other.month, first,
-                          other.hour, other.minute, other.second,
-                          other.microsecond)
-        return as_timestamp(result)
-
-
-class QuarterEnd(CacheableOffset, QuarterOffset):
-    """DateOffset increments between business Quarter dates
-    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
-    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
-    startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...
-    """
-    _outputName = 'QuarterEnd'
-    _default_startingMonth = 3
-    _prefix = 'Q'
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-        other = as_datetime(other)
-
-        wkday, days_in_month = tslib.monthrange(other.year, other.month)
-
-        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
-        if monthsToGo == 3:
-            monthsToGo = 0
-
-        if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
-            n = n - 1
-
-        other = other + relativedelta(months=monthsToGo + 3 * n, day=31)
-
-        return as_timestamp(other)
-
-    def onOffset(self, dt):
-        modMonth = (dt.month - self.startingMonth) % 3
-        return MonthEnd().onOffset(dt) and modMonth == 0
-
-
-class QuarterBegin(CacheableOffset, QuarterOffset):
-    _outputName = 'QuarterBegin'
-    _default_startingMonth = 3
-    _from_name_startingMonth = 1
-    _prefix = 'QS'
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-        other = as_datetime(other)
-
-        wkday, days_in_month = tslib.monthrange(other.year, other.month)
-
-        monthsSince = (other.month - self.startingMonth) % 3
-
-        if n <= 0 and monthsSince != 0:
-            # make sure you roll forward, so negate
-            monthsSince = monthsSince - 3
-
-        if n < 0 and (monthsSince == 0 and other.day > 1):
-            # after start, so come back an extra period as if rolled forward
-            n = n + 1
-
-        other = other + relativedelta(months=3 * n - monthsSince, day=1)
-        return as_timestamp(other)
-
-
-class YearOffset(DateOffset):
-    """DateOffset that just needs a month"""
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', self._default_month)
-
-        if self.month < 1 or self.month > 12:
-            raise ValueError('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    @classmethod
-    def _from_name(cls, suffix=None):
-        kwargs = {}
-        if suffix:
-            kwargs['month'] = _month_to_int[suffix]
-        return cls(**kwargs)
-
-    @property
-    def rule_code(self):
-        return '%s-%s' % (self._prefix, _int_to_month[self.month])
-
-
-class BYearEnd(CacheableOffset, YearOffset):
-    """DateOffset increments between business EOM dates"""
-    _outputName = 'BusinessYearEnd'
-    _default_month = 12
-    _prefix = 'BA'
-
-    def apply(self, other):
-        n = self.n
-        other = as_datetime(other)
-
-        wkday, days_in_month = tslib.monthrange(other.year, self.month)
-        lastBDay = (days_in_month -
-                    max(((wkday + days_in_month - 1) % 7) - 4, 0))
-
-        years = n
-        if n > 0:
-            if (other.month < self.month or
-                    (other.month == self.month and other.day < lastBDay)):
-                years -= 1
-        elif n <= 0:
-            if (other.month > self.month or
-                    (other.month == self.month and other.day > lastBDay)):
-                years += 1
-
-        other = other + relativedelta(years=years)
-
-        _, days_in_month = tslib.monthrange(other.year, self.month)
-        result = datetime(other.year, self.month, days_in_month,
-                          other.hour, other.minute, other.second,
-                          other.microsecond)
-
-        if result.weekday() > 4:
-            result = result - BDay()
-
-        return result
-
-
-class BYearBegin(CacheableOffset, YearOffset):
-    """DateOffset increments between business year begin dates"""
-    _outputName = 'BusinessYearBegin'
-    _default_month = 1
-    _prefix = 'BAS'
-
-    def apply(self, other):
-        n = self.n
-        other = as_datetime(other)
-
-        wkday, days_in_month = tslib.monthrange(other.year, self.month)
-
-        first = _get_firstbday(wkday)
-
-        years = n
-
-        if n > 0:  # roll back first for positive n
-            if (other.month < self.month or
-                    (other.month == self.month and other.day < first)):
-                years -= 1
-        elif n <= 0:  # roll forward
-            if (other.month > self.month or
-                    (other.month == self.month and other.day > first)):
-                years += 1
-
-        # set first bday for result
-        other = other + relativedelta(years=years)
-        wkday, days_in_month = tslib.monthrange(other.year, self.month)
-        first = _get_firstbday(wkday)
-        return as_timestamp(datetime(other.year, self.month, first))
-
-
-class YearEnd(CacheableOffset, YearOffset):
-    """DateOffset increments between calendar year ends"""
-    _default_month = 12
-    _prefix = 'A'
-
-    def apply(self, other):
-        def _increment(date):
-            if date.month == self.month:
-                _, days_in_month = tslib.monthrange(date.year, self.month)
-                if date.day != days_in_month:
-                    year = date.year
-                else:
-                    year = date.year + 1
-            elif date.month < self.month:
-                year = date.year
-            else:
-                year = date.year + 1
-            _, days_in_month = tslib.monthrange(year, self.month)
-            return datetime(year, self.month, days_in_month,
-                            date.hour, date.minute, date.second,
-                            date.microsecond)
-
-        def _decrement(date):
-            year = date.year if date.month > self.month else date.year - 1
-            _, days_in_month = tslib.monthrange(year, self.month)
-            return datetime(year, self.month, days_in_month,
-                            date.hour, date.minute, date.second,
-                            date.microsecond)
-
-        def _rollf(date):
-            if date.month != self.month or\
-               date.day < tslib.monthrange(date.year, date.month)[1]:
-                date = _increment(date)
-            return date
-
-        n = self.n
-        result = other
-        if n > 0:
-            while n > 0:
-                result = _increment(result)
-                n -= 1
-        elif n < 0:
-            while n < 0:
-                result = _decrement(result)
-                n += 1
-        else:
-            # n == 0, roll forward
-            result = _rollf(result)
-
-        return as_timestamp(result)
-
-    def onOffset(self, dt):
-        wkday, days_in_month = tslib.monthrange(dt.year, self.month)
-        return self.month == dt.month and dt.day == days_in_month
-
-
-class YearBegin(CacheableOffset, YearOffset):
-    """DateOffset increments between calendar year begin dates"""
-    _default_month = 1
-    _prefix = 'AS'
-
-    def apply(self, other):
-        def _increment(date):
-            year = date.year
-            if date.month >= self.month:
-                year += 1
-            return datetime(year, self.month, 1, date.hour, date.minute,
-                            date.second, date.microsecond)
-
-        def _decrement(date):
-            year = date.year
-            if date.month < self.month or (date.month == self.month and
-                                           date.day == 1):
-                year -= 1
-            return datetime(year, self.month, 1, date.hour, date.minute,
-                            date.second, date.microsecond)
-
-        def _rollf(date):
-            if (date.month != self.month) or date.day > 1:
-                date = _increment(date)
-            return date
-
-        n = self.n
-        result = other
-        if n > 0:
-            while n > 0:
-                result = _increment(result)
-                n -= 1
-        elif n < 0:
-            while n < 0:
-                result = _decrement(result)
-                n += 1
-        else:
-            # n == 0, roll forward
-            result = _rollf(result)
-
-        return as_timestamp(result)
-
-    def onOffset(self, dt):
-        return dt.month == self.month and dt.day == 1
-
-
 #----------------------------------------------------------------------
 # Ticks
 

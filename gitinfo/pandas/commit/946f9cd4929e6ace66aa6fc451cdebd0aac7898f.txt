commit 946f9cd4929e6ace66aa6fc451cdebd0aac7898f
Author: jreback <jeff@reback.net>
Date:   Thu Jun 5 08:33:14 2014 -0400

    BUG: Bug in .loc with a list of indexers on a single-multi index level (that is not nested) (GH7349)

diff --git a/doc/source/v0.14.1.txt b/doc/source/v0.14.1.txt
index f83cd50bb..0bc30e14e 100644
--- a/doc/source/v0.14.1.txt
+++ b/doc/source/v0.14.1.txt
@@ -21,8 +21,6 @@ users upgrade to this version.
 
 - :ref:`Deprecations <whatsnew_0141.deprecations>`
 
-- :ref:`Known Issues <whatsnew_0141.knownissues>`
-
 - :ref:`Bug Fixes <whatsnew_0141.bug_fixes>`
 
 .. _whatsnew_0141.api:
@@ -36,22 +34,21 @@ API changes
   containing ``NaN`` values - now also has ``dtype=object`` instead of
   ``float`` (:issue:`7242`)
 
+- `StringMethods`` now work on empty Series (:issue:`7242`)
+
 .. _whatsnew_0141.prior_deprecations:
 
 Prior Version Deprecations/Changes
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-There are prior version deprecations that are taking effect as of 0.14.1.
+There are no prior version deprecations that are taking effect as of 0.14.1.
 
 .. _whatsnew_0141.deprecations:
 
 Deprecations
 ~~~~~~~~~~~~
 
-.. _whatsnew_0141.knownissues:
-
-Known Issues
-~~~~~~~~~~~~
+There are no deprecations that are taking effect as of 0.14.1.
 
 .. _whatsnew_0141.enhancements:
 
@@ -118,4 +115,4 @@ Bug Fixes
 - Bug in broadcasting with ``.div``, integer dtypes and divide-by-zero (:issue:`7325`)
 - Bug in ``CustomBusinessDay.apply`` raiases ``NameError`` when ``np.datetime64`` object is passed (:issue:`7196`)
 - Bug in ``MultiIndex.append``, ``concat`` and ``pivot_table`` don't preserve timezone (:issue:`6606`)
-- Bug all ``StringMethods`` now work on empty Series (:issue:`7242`)
+- Bug in ``.loc`` with a list of indexers on a single-multi index level (that is not nested) (:issue:`7349`)
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 518879105..68e581075 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1243,23 +1243,37 @@ class _LocIndexer(_LocationIndexer):
             return self._get_slice_axis(key, axis=axis)
         elif com._is_bool_indexer(key):
             return self._getbool_axis(key, axis=axis)
-        elif _is_list_like(key) and not (isinstance(key, tuple) and
-                                         isinstance(labels, MultiIndex)):
+        elif _is_list_like(key):
 
-            if hasattr(key, 'ndim') and key.ndim > 1:
-                raise ValueError('Cannot index with multidimensional key')
+            # GH 7349
+            # possibly convert a list-like into a nested tuple
+            # but don't convert a list-like of tuples
+            if isinstance(labels, MultiIndex):
+                if not isinstance(key, tuple) and len(key) > 1 and not isinstance(key[0], tuple):
+                    key = tuple([key])
 
-            if validate_iterable:
-                self._has_valid_type(key, axis)
-            return self._getitem_iterable(key, axis=axis)
-        elif _is_nested_tuple(key, labels):
-            locs = labels.get_locs(key)
-            indexer = [ slice(None) ] * self.ndim
-            indexer[axis] = locs
-            return self.obj.iloc[tuple(indexer)]
-        else:
-            self._has_valid_type(key, axis)
-            return self._get_label(key, axis=axis)
+            # an iterable multi-selection
+            if not (isinstance(key, tuple) and
+                    isinstance(labels, MultiIndex)):
+
+                if hasattr(key, 'ndim') and key.ndim > 1:
+                    raise ValueError('Cannot index with multidimensional key')
+
+                if validate_iterable:
+                    self._has_valid_type(key, axis)
+
+                return self._getitem_iterable(key, axis=axis)
+
+            # nested tuple slicing
+            if _is_nested_tuple(key, labels):
+                locs = labels.get_locs(key)
+                indexer = [ slice(None) ] * self.ndim
+                indexer[axis] = locs
+                return self.obj.iloc[tuple(indexer)]
+
+        # fall thru to straight lookup
+        self._has_valid_type(key, axis)
+        return self._get_label(key, axis=axis)
 
 
 class _iLocIndexer(_LocationIndexer):
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index b61b1ab92..062950cad 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -1317,6 +1317,15 @@ class TestIndexing(tm.TestCase):
         result = df[attributes]
         assert_frame_equal(result, df)
 
+        # GH 7349
+        # loc with a multi-index seems to be doing fallback
+        df = DataFrame(np.arange(12).reshape(-1,1),index=pd.MultiIndex.from_product([[1,2,3,4],[1,2,3]]))
+
+        expected = df.loc[([1,2],),:]
+        result = df.loc[[1,2]]
+        assert_frame_equal(result, expected)
+
+
     def test_series_getitem_multiindex(self):
 
         # GH 6018

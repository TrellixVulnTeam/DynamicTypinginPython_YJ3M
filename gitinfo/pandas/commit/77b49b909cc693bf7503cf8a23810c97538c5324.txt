commit 77b49b909cc693bf7503cf8a23810c97538c5324
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jul 11 18:16:39 2012 -0400

    ENH: always apply functions when passed to how option in resample, close #1596

diff --git a/RELEASE.rst b/RELEASE.rst
index abeb363c9..7069cf907 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -38,6 +38,7 @@ pandas 0.8.1
 
   - Add ability to append hierarchical index levels with ``set_index`` and to
     drop single levels with ``reset_index`` (#1569, #1577)
+  - Always apply passed functions in ``resample``, even if upsampling (#1596)
 
 **Bug fixes**
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index f00610441..f0c70522d 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -155,7 +155,7 @@ class PandasObject(object):
         from pandas.tseries.resample import asfreq
         return asfreq(self, freq, method=method, how=how)
 
-    def resample(self, rule, how='mean', axis=0, fill_method=None,
+    def resample(self, rule, how=None, axis=0, fill_method=None,
                  closed='right', label='right', convention=None,
                  kind=None, loffset=None, limit=None, base=0):
         """
@@ -165,7 +165,8 @@ class PandasObject(object):
         Parameters
         ----------
         rule : the offset string or object representing target conversion
-        how : string, method for down- or re-sampling, default 'mean'
+        how : string, method for down- or re-sampling, default to 'mean' for
+              downsampling
         fill_method : string, fill_method for upsampling, default None
         axis : int, optional, default 0
         closed : {'right', 'left'}, default 'right'
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 20700ac89..9ecaeb5d8 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -13,6 +13,9 @@ from pandas.lib import Timestamp
 import pandas.lib as lib
 
 
+_DEFAULT_METHOD = 'mean'
+
+
 class TimeGrouper(CustomGrouper):
     """
     Custom groupby class for time-interval grouping
@@ -153,6 +156,10 @@ class TimeGrouper(CustomGrouper):
 
         return binner, bins, labels
 
+    @property
+    def _agg_method(self):
+        return self.how if self.how else _DEFAULT_METHOD
+
     def _resample_timestamps(self, obj):
         axlabels = obj._get_axis(self.axis)
 
@@ -160,9 +167,9 @@ class TimeGrouper(CustomGrouper):
 
         # Determine if we're downsampling
         if axlabels.freq is not None or axlabels.inferred_freq is not None:
-            if len(grouper.binlabels) < len(axlabels):
+            if len(grouper.binlabels) < len(axlabels) or self.how is not None:
                 grouped  = obj.groupby(grouper, axis=self.axis)
-                result = grouped.aggregate(self.how)
+                result = grouped.aggregate(self._agg_method)
             else:
                 # upsampling shortcut
                 assert(self.axis == 0)
@@ -171,7 +178,7 @@ class TimeGrouper(CustomGrouper):
         else:
             # Irregular data, have to use groupby
             grouped  = obj.groupby(grouper, axis=self.axis)
-            result = grouped.aggregate(self.how)
+            result = grouped.aggregate(self._agg_method)
 
             if self.fill_method is not None:
                 result = result.fillna(method=self.fill_method, limit=self.limit)
@@ -202,14 +209,14 @@ class TimeGrouper(CustomGrouper):
         # Start vs. end of period
         memb = axlabels.asfreq(self.freq, how=self.convention)
 
-        if is_subperiod(axlabels.freq, self.freq):
+        if is_subperiod(axlabels.freq, self.freq) or self.how is not None:
             # Downsampling
             rng = np.arange(memb.values[0], memb.values[-1])
             bins = memb.searchsorted(rng, side='right')
             grouper = BinGrouper(bins, new_index)
 
             grouped = obj.groupby(grouper, axis=self.axis)
-            return grouped.aggregate(self.how)
+            return grouped.aggregate(self._agg_method)
         elif is_superperiod(axlabels.freq, self.freq):
             # Get the fill indexer
             indexer = memb.get_indexer(new_index, method=self.fill_method,
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index 1311b9ca4..db466f82a 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -576,6 +576,17 @@ class TestMonthEnd(unittest.TestCase):
             for base, expected in cases.iteritems():
                 assertEq(offset, base, expected)
 
+    # def test_day_of_month(self):
+    #     dt = datetime(2007, 1, 1)
+
+    #     offset = MonthEnd(day=20)
+
+    #     result = dt + offset
+    #     self.assertEqual(result, datetime(2007, 1, 20))
+
+    #     result = result + offset
+    #     self.assertEqual(result, datetime(2007, 2, 20))
+
     def test_normalize(self):
         dt = datetime(2007, 1, 1, 3)
 
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index ddf101072..216eb9232 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -501,6 +501,15 @@ class TestResample(unittest.TestCase):
         # it works!
         ts.resample('d')
 
+    def test_upsample_apply_functions(self):
+        # #1596
+        rng = pd.date_range('2012-06-12', periods=4, freq='h')
+
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        result = ts.resample('20min', how=['mean', 'sum'])
+        self.assert_(isinstance(result, DataFrame))
+
 def _simple_ts(start, end, freq='D'):
     rng = date_range(start, end, freq=freq)
     return Series(np.random.randn(len(rng)), index=rng)

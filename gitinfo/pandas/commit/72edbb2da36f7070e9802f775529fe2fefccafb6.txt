commit 72edbb2da36f7070e9802f775529fe2fefccafb6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 2 01:41:14 2011 -0400

    further sparse unit testing

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 15bb1e668..d4c56faa3 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -416,19 +416,20 @@ class DataFrame(Picklable, Groupable):
 
     def to_sparse(self, fill_value=None, kind='block'):
         """
+        Convert to SparseDataFrame
 
         Parameters
         ----------
         fill_value : float, default NaN
         kind : {'block', 'integer'}
+
+        Returns
+        -------
+        y : SparseDataFrame
         """
         from pandas.core.sparse import SparseDataFrame
-
-        sparse_data = {}
-        for k, v in self.iteritems():
-            sparse_data[k] = v.to_sparse(fill_value=fill_value, kind=kind)
-
-        return SparseDataFrame(sparse_data, index=self.index)
+        return SparseDataFrame(self._series, index=self.index,
+                               kind=kind, default_fill_value=fill_value)
 
 #-------------------------------------------------------------------------------
 # Magic methods
@@ -863,14 +864,14 @@ class DataFrame(Picklable, Groupable):
             assert(len(cols) == len(counts))
             for col, count in counts.iteritems():
                 col_counts.append('%s%d  non-null values' %
-                                  (_pfixed(col, space), count))
+                                  (_put_str(col, space), count))
 
             print >> buf, '\n'.join(col_counts)
         else:
-            if len(columns) <= 2:
-                print >> buf, 'Columns: %s' % repr(columns)
+            if len(cols) <= 2:
+                print >> buf, 'Columns: %s' % repr(cols)
             else:
-                print >> buf, 'Columns: %s to %s' % (columns[0], columns[-1])
+                print >> buf, 'Columns: %s to %s' % (cols[0], cols[-1])
 
         counts = self._get_dtype_counts()
         dtypes = ['%s(%d)' % k for k in sorted(counts.iteritems())]
@@ -962,7 +963,7 @@ class DataFrame(Picklable, Groupable):
         if len(columns) == 0:
             return np.zeros((0, 0))
 
-        return np.array([self[col] for col in columns]).T
+        return np.array([self[col].values for col in columns]).T
 
     asMatrix = as_matrix
     # For DataMatrix compatibility
@@ -2450,20 +2451,20 @@ def _pfixed(s, space, nanRep=None, float_format=None):
     if isinstance(s, float):
         if nanRep is not None and isnull(s):
             if np.isnan(s):
-                return nanRep.ljust(space)
-            else:
-                return ('%s' % s).ljust(space)
+                s = nanRep
+            return (' %s' % s).ljust(space)
 
         if float_format:
             formatted = float_format(s)
         else:
-            is_pos = s >= 0
+            is_neg = s < 0
             formatted = '%.4g' % np.abs(s)
 
-            if is_pos:
-                formatted = ' ' + formatted
-            else:
+            if is_neg:
                 formatted = '-' + formatted
+            else:
+                formatted = ' ' + formatted
+
         return formatted.ljust(space)
     else:
         return (' %s' % s)[:space].ljust(space)
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 87c409d15..600a78164 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -55,11 +55,11 @@ def make_sparse(arr, kind='block', fill_value=nan):
 #-------------------------------------------------------------------------------
 # Wrapper function for Series arithmetic methods
 _MIRROR_OPS = {
-    '__add__' : '__radd__',
-    '__sub__' : '__rsub__',
-    '__div__' : '__rdiv__',
-    '__truediv__' : '__rdiv__',
-    '__mul__' : '__rmul__',
+    'add' : '__radd__',
+    'sub' : '__rsub__',
+    'div' : '__rdiv__',
+    'truediv' : '__rdiv__',
+    'mul' : '__rmul__',
 }
 
 def _sparse_op_wrap(name):
@@ -102,7 +102,7 @@ def _sparse_op_wrap(name):
 
         elif isinstance(other, SparseDataFrame):
             reverse_op = _MIRROR_OPS.get(name)
-            if reverse_op is None:
+            if reverse_op is None: # pragma: no cover
                 raise Exception('Cannot do %s op, sorry!')
             return getattr(other, reverse_op)(self)
         elif np.isscalar(other):
@@ -346,32 +346,37 @@ class SparseSeries(Series):
     def _null_fill_value(self):
         return np.isnan(self.fill_value)
 
+    @property
+    def _valid_sp_values(self):
+        sp_vals = self.sp_values
+        mask = np.isfinite(sp_vals)
+        return sp_vals[mask]
+
     def sum(self, axis=None, dtype=None, out=None):
         """
         Sum of non-null values
         """
-        sp_vals = self.sp_values
-        mask = np.isfinite(sp_vals)
-        sp_sum = sp_vals[mask].sum()
-        num_sparse = len(self) - len(sp_vals)
+        valid_vals = self._valid_sp_values
+        sp_sum = valid_vals.sum()
         if self._null_fill_value:
             return sp_sum
         else:
-            return sp_sum + self.fill_value * num_sparse
+            nsparse = self.sp_index.npoints
+            return sp_sum + self.fill_value * nsparse
 
     def mean(self, axis=None, dtype=None, out=None):
         """
         Mean of non-null values
         """
-        sp_vals = self.sp_values
-        mask = np.isfinite(sp_vals)
-        ct = mask.sum()
-        sp_sum = sp_vals[mask].sum()
-        num_sparse = len(self) - len(sp_vals)
+        valid_vals = self._valid_sp_values
+        sp_sum = valid_vals.sum()
+        ct = len(valid_vals)
+
         if self._null_fill_value:
             return sp_sum / ct
         else:
-            return (sp_sum + self.fill_value * num_sparse) / (ct + num_sparse)
+            nsparse = self.sp_index.npoints
+            return (sp_sum + self.fill_value * nsparse) / (ct + nsparse)
 
 class SparseTimeSeries(SparseSeries, TimeSeries):
     pass
@@ -384,9 +389,13 @@ class SparseDataFrame(DataFrame):
     _columns = None
 
     def __init__(self, data=None, index=None, columns=None, kind='block',
-                 fill_value=None):
-        self.kind = kind
-        self.fill_value = fill_value
+                 default_fill_value=None):
+        if default_fill_value is None:
+            default_fill_value = nan
+
+        self.default_kind = kind
+        self.default_fill_value = default_fill_value
+
         DataFrame.__init__(self, data, index=index, columns=columns,
                            dtype=None)
 
@@ -406,29 +415,51 @@ class SparseDataFrame(DataFrame):
 
         index = extract_index(data, index)
 
+        sp_maker = lambda x: SparseSeries(x, index=index,
+                                          kind=self.default_kind,
+                                          fill_value=self.default_fill_value)
+
         sdict = {}
         for k, v in data.iteritems():
             if isinstance(v, Series):
                 # Forces alignment and copies data
                 v = v.reindex(index)
-                v = v.to_sparse()
+
+                if not isinstance(v, SparseSeries):
+                    v = sp_maker(v)
             else:
                 if isinstance(v, dict):
                     v = [v.get(i, nan) for i in index]
 
-                v = SparseSeries(v, index=index, kind=self.kind).copy()
-
+                v = sp_maker(v).copy()
             sdict[k] = v
 
         # TODO: figure out how to handle this case, all nan's?
         # add in any other columns we want to have (completeness)
         for c in columns:
             if c not in sdict:
-                sdict[c] = SparseSeries([], index=index,
-                                        fill_value=self.fill_value)
+                sdict[c] = sp_maker([])
 
         return sdict, columns, index
 
+    def _insert_item(self, key, value):
+        if hasattr(value, '__iter__'):
+            if isinstance(value, Series):
+                cleanSeries = value.reindex(self.index)
+                if not isinstance(value, SparseSeries):
+                    cleanSeries = SparseSeries(cleanSeries)
+            else:
+                cleanSeries = Series(value, index=self.index)
+
+            self._series[key] = cleanSeries
+        # Scalar
+        else:
+            self._series[key] = SparseSeries(value, index=self.index)
+
+        if key not in self.columns:
+            loc = self._get_insert_loc(key)
+            self._insert_column_index(key, loc)
+
     def to_dense(self):
         """
         Convert to dense DataFrame
@@ -437,7 +468,7 @@ class SparseDataFrame(DataFrame):
         -------
         df : DataFrame
         """
-        data = dict((k, v.to_dense) for k, v in self.iteritems())
+        data = dict((k, v.to_dense()) for k, v in self.iteritems())
         return DataFrame(data, index=self.index)
 
     def _reindex_index(self, index, method):
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index d7024f52b..bad824198 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -309,6 +309,8 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(df)
 
     def test_repr(self):
+        buf = StringIO()
+
         # empty
         foo = repr(self.empty)
 
@@ -318,6 +320,11 @@ class TestDataFrame(unittest.TestCase):
 
         # small one
         foo = repr(self.frame)
+        self.frame.info(verbose=False, buf=buf)
+
+        # even smaller
+        self.frame.reindex(columns=['A']).info(verbose=False, buf=buf)
+        self.frame.reindex(columns=['A', 'B']).info(verbose=False, buf=buf)
 
         # big one
         biggie = self.klass(np.zeros((1000, 4)), columns=range(4),
@@ -326,6 +333,7 @@ class TestDataFrame(unittest.TestCase):
 
         # mixed
         foo = repr(self.mixed_frame)
+        self.mixed_frame.info(verbose=False, buf=buf)
 
         # big mixed
         biggie = self.klass({'A' : randn(1000),
@@ -343,7 +351,6 @@ class TestDataFrame(unittest.TestCase):
         foo = repr(no_index)
 
         # no columns or index
-        buf = StringIO()
         self.empty.info(buf=buf)
 
         # columns are not sortable
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index 094709c45..317e66dd4 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -9,10 +9,12 @@ import numpy as np
 from pandas.util.testing import assert_almost_equal, assert_series_equal
 from numpy.testing import assert_equal
 
-from pandas import DateRange
+from pandas import DataFrame, DateRange
 from pandas.core.series import remove_na
-from pandas.core.sparse import (IntIndex, BlockIndex, SparseSeries)
+from pandas.core.sparse import (IntIndex, BlockIndex,
+                                SparseSeries, SparseDataFrame)
 import pandas.core.sparse as spm
+import pandas.util.testing as testing
 
 """
 Testing TODO
@@ -57,10 +59,19 @@ def assert_sp_series_equal(a, b):
     else:
         assert(a.fill_value == b.fill_value)
 
-def assert_sp_frame_equal(left, right):
+def assert_sp_frame_equal(left, right, exact_indices=True):
+    """
+    exact: Series SparseIndex objects must be exactly the same, otherwise just
+    compare dense representations
+    """
     for col, series in left.iteritems():
         assert(col in right)
-        assert_sp_series_equal(series, right[col])
+        # trade-off?
+
+        if exact_indices:
+            assert_sp_series_equal(series, right[col])
+        else:
+            assert_series_equal(series.to_dense(), right[col].to_dense())
 
     for col in right:
         assert(col in left)
@@ -88,15 +99,25 @@ class TestSparseSeries(TestCase):
         self.ziseries2 = SparseSeries(arr, index=index, kind='integer',
                                       fill_value=0)
 
-    def test_to_dense(self):
+    def test_sparse_to_dense(self):
         arr, index = _test_data1()
         series = self.bseries.to_dense()
         assert_equal(series, arr)
 
+        series = self.bseries.to_dense(sparse_only=True)
+        assert_equal(series, arr[np.isfinite(arr)])
+
         series = self.iseries.to_dense()
         assert_equal(series, arr)
 
-    def test_to_sparse(self):
+        arr, index = _test_data1_zero()
+        series = self.zbseries.to_dense()
+        assert_equal(series, arr)
+
+        series = self.ziseries.to_dense()
+        assert_equal(series, arr)
+
+    def test_dense_to_sparse(self):
         series = self.bseries.to_dense()
         bseries = series.to_sparse(kind='block')
         iseries = series.to_sparse(kind='integer')
@@ -272,31 +293,124 @@ class TestSparseSeries(TestCase):
         pass
 
     def test_reductions(self):
-        self.assertEquals(self.bseries.count(), len(self.bseries.sp_values))
-        self.assertEquals(self.bseries.sum(), self.bseries.sp_values.sum())
-        self.assertEquals(self.bseries.mean(), self.bseries.sp_values.mean())
-
+        def _compare_with_series(obj, op):
+            sparse_result = getattr(obj, op)()
+            series = obj.to_dense()
+            dense_result = getattr(series, op)()
+            self.assertEquals(sparse_result, dense_result)
+
+        to_compare = ['count', 'sum', 'mean', 'std', 'var', 'skew']
+        def _compare_all(obj):
+            for op in to_compare:
+                _compare_with_series(obj, op)
+
+        _compare_all(self.bseries)
         self.bseries.sp_values[5:10] = np.NaN
-        self.assertEquals(self.bseries.count(), len(self.bseries.sp_values) - 5)
-        self.assertEquals(self.bseries.sum(), remove_na(self.bseries.sp_values).sum())
+        _compare_all(self.bseries)
 
-        self.assertEquals(self.zbseries.count(), len(self.zbseries))
+        _compare_all(self.zbseries)
         self.zbseries.sp_values[5:10] = np.NaN
-        self.assertEquals(self.zbseries.count(), len(self.zbseries) - 5)
+        _compare_all(self.zbseries)
 
         series = self.zbseries.copy()
         series.fill_value = 2
-        num_sparse = len(self.zbseries) - len(self.zbseries.sp_values)
-        self.assertEquals(series.sum(), self.zbseries.sum() + 2 * num_sparse)
+        _compare_all(series)
 
     def test_mean(self):
         pass
 
+    def test_valid(self):
+        pass
+
 class TestSparseTimeSeries(TestCase):
     pass
 
 class TestSparseDataFrame(TestCase):
-    pass
+    klass = SparseDataFrame
+
+    def setUp(self):
+        self.data = {'A' : [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],
+                     'B' : [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],
+                     'C' : np.arange(10),
+                     'D' : [0, 1, 2, 3, 4, 5, nan, nan, nan, nan]}
+
+        self.dates = DateRange('1/1/2011', periods=10)
+
+        self.frame = SparseDataFrame(self.data, index=self.dates)
+
+        values = self.frame.values.copy()
+        values[np.isnan(values)] = 0
+
+        self.zframe = SparseDataFrame(values, columns=['A', 'B', 'C', 'D'],
+                                      default_fill_value=0,
+                                      index=self.dates)
+
+    def test_constructor(self):
+        for col, series in self.frame.iteritems():
+            self.assert_(isinstance(series, SparseSeries))
+
+    def test_dense_to_sparse(self):
+        df = DataFrame({'A' : [nan, nan, nan, 1, 2],
+                        'B' : [1, 2, nan, nan, nan]})
+        sdf = df.to_sparse()
+        self.assert_(isinstance(sdf, SparseDataFrame))
+        self.assert_(np.isnan(sdf.default_fill_value))
+        self.assert_(isinstance(sdf['A'].sp_index, BlockIndex))
+        testing.assert_frame_equal(sdf.to_dense(), df)
+
+        sdf = df.to_sparse(kind='integer')
+        self.assert_(isinstance(sdf['A'].sp_index, IntIndex))
+
+        df = DataFrame({'A' : [0, 0, 0, 1, 2],
+                        'B' : [1, 2, 0, 0, 0]})
+        sdf = df.to_sparse(fill_value=0)
+        self.assertEquals(sdf.default_fill_value, 0)
+        testing.assert_frame_equal(sdf.to_dense(), df)
+
+    def test_sparse_to_dense(self):
+        pass
+
+    def test_sparse_series_ops(self):
+        def _compare_to_dense(a, b, op, fill=np.NaN):
+            sparse_result = op(a, b)
+            dense_result = op(a.to_dense(), b.to_dense())
+            dense_result = dense_result.to_sparse(fill_value=fill)
+            assert_sp_frame_equal(sparse_result, dense_result,
+                                  exact_indices=False)
+
+        def _compare_to_dense_rev(a, b, op):
+            sparse_result = op(b, a)
+            dense_result = op(b.to_dense(), a.to_dense())
+            dense_result = dense_result.to_sparse(fill_value=a.fill_value)
+            assert_sp_frame_equal(sparse_result, dense_result,
+                                  exact_indices=False)
+
+        opnames = ['add', 'sub', 'mul', 'div']
+        ops = [getattr(operator, name) for name in opnames]
+
+        fidx = self.frame.index
+
+        # time series operations
+
+        series = [self.frame['A'],
+                  self.frame['B'],
+                  self.frame['C'],
+                  self.frame['D'],
+                  self.frame['A'].reindex(fidx[:7]),
+                  self.frame['A'].reindex(fidx[::2])]
+
+        for op in ops:
+            for s in series:
+                _compare_to_dense(self.frame, s, op)
+                _compare_to_dense(s, self.frame, op)
+
+        # cross-sectional operations
+
+
+        # TODO: fill value consistency?
+
+    def test_scalar_ops(self):
+        pass
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index d4205267b..e8c3dacd5 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -13,6 +13,7 @@ ctypedef Py_ssize_t pyst
 # Preamble stuff
 
 cdef float64_t NaN = <float64_t> np.NaN
+cdef float64_t INF = <float64_t> np.inf
 
 cdef inline int int_max(int a, int b): return a if a >= b else b
 cdef inline int int_min(int a, int b): return a if a <= b else b
@@ -23,7 +24,7 @@ cdef inline float64_t __sub(float64_t a, float64_t b):
     return a - b
 cdef inline float64_t __div(float64_t a, float64_t b):
     if b == 0:
-        return NaN
+        return INF
     else:
         return a / b
 
@@ -49,7 +50,9 @@ ctypedef float64_t (* double_func)(float64_t a, float64_t b)
 #-------------------------------------------------------------------------------
 
 cdef class SparseIndex:
-
+    '''
+    Abstract superclass for sparse index types
+    '''
     def __init__(self):
         raise NotImplementedError
 

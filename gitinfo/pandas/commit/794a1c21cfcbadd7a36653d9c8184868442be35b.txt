commit 794a1c21cfcbadd7a36653d9c8184868442be35b
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Wed Nov 13 01:16:21 2019 +0200

    CLN:F-string formatting (#29554)

diff --git a/pandas/_libs/parsers.pyx b/pandas/_libs/parsers.pyx
index 601b81556..a2c7d0da5 100644
--- a/pandas/_libs/parsers.pyx
+++ b/pandas/_libs/parsers.pyx
@@ -589,8 +589,7 @@ cdef class TextReader:
 
         if not isinstance(quote_char, (str, bytes)) and quote_char is not None:
             dtype = type(quote_char).__name__
-            raise TypeError('"quotechar" must be string, '
-                            'not {dtype}'.format(dtype=dtype))
+            raise TypeError(f'"quotechar" must be string, not {dtype}')
 
         if quote_char is None or quote_char == '':
             if quoting != QUOTE_NONE:
@@ -685,7 +684,7 @@ cdef class TextReader:
                 if not os.path.exists(source):
                     raise FileNotFoundError(
                         ENOENT,
-                        'File {source} does not exist'.format(source=source),
+                        f'File {source} does not exist',
                         source)
                 raise IOError('Initializing from file failed')
 
@@ -741,8 +740,8 @@ cdef class TextReader:
                           self.parser.lines < hr):
                     msg = self.orig_header
                     if isinstance(msg, list):
-                        msg = "[%s], len of %d," % (
-                            ','.join(str(m) for m in msg), len(msg))
+                        joined = ','.join(str(m) for m in msg)
+                        msg = f"[{joined}], len of {len(msg)},"
                     raise ParserError(
                         f'Passed header={msg} but only '
                         f'{self.parser.lines} lines in file')
@@ -768,10 +767,9 @@ cdef class TextReader:
 
                     if name == '':
                         if self.has_mi_columns:
-                            name = ('Unnamed: {i}_level_{lvl}'
-                                    .format(i=i, lvl=level))
+                            name = f'Unnamed: {i}_level_{level}'
                         else:
-                            name = 'Unnamed: {i}'.format(i=i)
+                            name = f'Unnamed: {i}'
                         unnamed_count += 1
 
                     count = counts.get(name, 0)
@@ -990,7 +988,7 @@ cdef class TextReader:
     cdef _end_clock(self, what):
         if self.verbose:
             elapsed = time.time() - self.clocks.pop(-1)
-            print('%s took: %.2f ms' % (what, elapsed * 1000))
+            print(f'{what} took: {elapsed * 1000:.2f} ms')
 
     def set_noconvert(self, i):
         self.noconvert.add(i)
@@ -1028,11 +1026,9 @@ cdef class TextReader:
                 (num_cols >= self.parser.line_fields[i]) * num_cols
 
         if self.table_width - self.leading_cols > num_cols:
-            raise ParserError(
-                "Too many columns specified: expected {expected} and "
-                "found {found}"
-                .format(expected=self.table_width - self.leading_cols,
-                        found=num_cols))
+            raise ParserError(f"Too many columns specified: expected "
+                              f"{self.table_width - self.leading_cols} "
+                              f"and found {num_cols}")
 
         results = {}
         nused = 0
@@ -1075,9 +1071,9 @@ cdef class TextReader:
 
             if conv:
                 if col_dtype is not None:
-                    warnings.warn(("Both a converter and dtype were specified "
-                                   "for column {0} - only the converter will "
-                                   "be used").format(name), ParserWarning,
+                    warnings.warn((f"Both a converter and dtype were specified "
+                                   f"for column {name} - only the converter will "
+                                   f"be used"), ParserWarning,
                                   stacklevel=5)
                 results[i] = _apply_converter(conv, self.parser, i, start, end,
                                               self.c_encoding)
@@ -1118,7 +1114,7 @@ cdef class TextReader:
                 col_res = _maybe_upcast(col_res)
 
             if col_res is None:
-                raise ParserError('Unable to parse column {i}'.format(i=i))
+                raise ParserError(f'Unable to parse column {i}')
 
             results[i] = col_res
 
@@ -1178,12 +1174,9 @@ cdef class TextReader:
                 col_res = col_res.astype(col_dtype)
                 if (col_res != col_res_orig).any():
                     raise ValueError(
-                        "cannot safely convert passed user dtype of "
-                        "{col_dtype} for {col_res} dtyped data in "
-                        "column {column}".format(
-                            col_dtype=col_dtype,
-                            col_res=col_res_orig.dtype.name,
-                            column=i))
+                        f"cannot safely convert passed user dtype of "
+                        f"{col_dtype} for {col_res_orig.dtype.name} dtyped data in "
+                        f"column {i}")
 
         return col_res, na_count
 
@@ -1216,9 +1209,9 @@ cdef class TextReader:
                                                               dtype=dtype)
             except NotImplementedError:
                 raise NotImplementedError(
-                    "Extension Array: {ea} must implement "
-                    "_from_sequence_of_strings in order "
-                    "to be used in parser methods".format(ea=array_type))
+                    f"Extension Array: {array_type} must implement "
+                    f"_from_sequence_of_strings in order "
+                    f"to be used in parser methods")
 
             return result, na_count
 
@@ -1228,8 +1221,7 @@ cdef class TextReader:
                                               end, na_filter, na_hashset)
                 if user_dtype and na_count is not None:
                     if na_count > 0:
-                        raise ValueError("Integer column has NA values in "
-                                         "column {column}".format(column=i))
+                        raise ValueError(f"Integer column has NA values in column {i}")
             except OverflowError:
                 result = _try_uint64(self.parser, i, start, end,
                                      na_filter, na_hashset)
@@ -1253,8 +1245,7 @@ cdef class TextReader:
                                               self.true_set, self.false_set)
             if user_dtype and na_count is not None:
                 if na_count > 0:
-                    raise ValueError("Bool column has NA values in "
-                                     "column {column}".format(column=i))
+                    raise ValueError(f"Bool column has NA values in column {i}")
             return result, na_count
 
         elif dtype.kind == 'S':
@@ -1270,8 +1261,7 @@ cdef class TextReader:
         elif dtype.kind == 'U':
             width = dtype.itemsize
             if width > 0:
-                raise TypeError("the dtype {dtype} is not "
-                                "supported for parsing".format(dtype=dtype))
+                raise TypeError(f"the dtype {dtype} is not supported for parsing")
 
             # unicode variable width
             return self._string_convert(i, start, end, na_filter,
@@ -1280,12 +1270,11 @@ cdef class TextReader:
             return self._string_convert(i, start, end, na_filter,
                                         na_hashset)
         elif is_datetime64_dtype(dtype):
-            raise TypeError("the dtype {dtype} is not supported "
-                            "for parsing, pass this column "
-                            "using parse_dates instead".format(dtype=dtype))
+            raise TypeError(f"the dtype {dtype} is not supported "
+                            f"for parsing, pass this column "
+                            f"using parse_dates instead")
         else:
-            raise TypeError("the dtype {dtype} is not "
-                            "supported for parsing".format(dtype=dtype))
+            raise TypeError(f"the dtype {dtype} is not supported for parsing")
 
     cdef _string_convert(self, Py_ssize_t i, int64_t start, int64_t end,
                          bint na_filter, kh_str_starts_t *na_hashset):
@@ -2132,7 +2121,7 @@ cdef raise_parser_error(object base, parser_t *parser):
                 Py_XDECREF(type)
                 raise old_exc
 
-    message = '{base}. C error: '.format(base=base)
+    message = f'{base}. C error: '
     if parser.error_msg != NULL:
         message += parser.error_msg.decode('utf-8')
     else:
diff --git a/pandas/_libs/testing.pyx b/pandas/_libs/testing.pyx
index f848310d9..141735a97 100644
--- a/pandas/_libs/testing.pyx
+++ b/pandas/_libs/testing.pyx
@@ -204,12 +204,12 @@ cpdef assert_almost_equal(a, b,
         # case for zero
         if abs(fa) < 1e-5:
             if not decimal_almost_equal(fa, fb, decimal):
-                assert False, ('(very low values) expected %.5f but '
-                               'got %.5f, with decimal %d' % (fb, fa, decimal))
+                assert False, (f'(very low values) expected {fb:.5f} '
+                               f'but got {fa:.5f}, with decimal {decimal}')
         else:
             if not decimal_almost_equal(1, fb / fa, decimal):
-                assert False, ('expected %.5f but got %.5f, '
-                               'with decimal %d' % (fb, fa, decimal))
+                assert False, (f'expected {fb:.5f} but got {fa:.5f}, '
+                               f'with decimal {decimal}')
         return True
 
     raise AssertionError(f"{a} != {b}")
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index d101a2976..01d90900c 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -279,7 +279,7 @@ def format_array_from_datetime(ndarray[int64_t] values, object tz=None,
             elif show_us:
                 res += '.%.6d' % dts.us
             elif show_ms:
-                res += '.%.3d' % (dts.us /1000)
+                res += '.%.3d' % (dts.us / 1000)
 
             result[i] = res
 

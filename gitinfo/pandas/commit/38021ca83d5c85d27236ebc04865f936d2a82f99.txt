commit 38021ca83d5c85d27236ebc04865f936d2a82f99
Author: behzad nouri <behzadnouri@gmail.com>
Date:   Sat Nov 22 09:46:15 2014 -0500

    refactor **kwargs usage

diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index fd9ef5d2e..73d6a17f4 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -913,7 +913,7 @@ class Categorical(PandasObject):
             result = result[::-1]
         return result
 
-    def order(self, inplace=False, ascending=True, na_position='last', **kwargs):
+    def order(self, inplace=False, ascending=True, na_position='last'):
         """ Sorts the Category by category value returning a new Categorical by default.
 
         Only ordered Categoricals can be sorted!
@@ -972,7 +972,7 @@ class Categorical(PandasObject):
                                name=self.name, fastpath=True)
 
 
-    def sort(self, inplace=True, ascending=True, na_position='last', **kwargs):
+    def sort(self, inplace=True, ascending=True, na_position='last'):
         """ Sorts the Category inplace by category value.
 
         Only ordered Categoricals can be sorted!
@@ -997,7 +997,8 @@ class Categorical(PandasObject):
         --------
         Category.order
         """
-        return self.order(inplace=inplace, ascending=ascending, **kwargs)
+        return self.order(inplace=inplace, ascending=ascending,
+                na_position=na_position)
 
     def ravel(self, order='C'):
         """ Return a flattened (numpy) array.
@@ -1033,7 +1034,7 @@ class Categorical(PandasObject):
         """
         return np.asarray(self)
 
-    def fillna(self, fill_value=None, method=None, limit=None, **kwargs):
+    def fillna(self, fill_value=None, method=None, limit=None):
         """ Fill NA/NaN values using the specified method.
 
         Parameters
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 4de63cf59..2298fbe4a 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -1559,7 +1559,7 @@ def backfill_2d(values, limit=None, mask=None, dtype=None):
     return values
 
 
-def _clean_interp_method(method, order=None, **kwargs):
+def _clean_interp_method(method, order=None):
     valid = ['linear', 'time', 'index', 'values', 'nearest', 'zero', 'slinear',
              'quadratic', 'cubic', 'barycentric', 'polynomial',
              'krogh', 'piecewise_polynomial',
@@ -1574,7 +1574,7 @@ def _clean_interp_method(method, order=None, **kwargs):
 
 
 def interpolate_1d(xvalues, yvalues, method='linear', limit=None,
-                   fill_value=None, bounds_error=False, **kwargs):
+                   fill_value=None, bounds_error=False, order=None):
     """
     Logic for the 1-d interpolation.  The result should be 1-d, inputs
     xvalues and yvalues will each be 1-d arrays of the same length.
@@ -1657,14 +1657,14 @@ def interpolate_1d(xvalues, yvalues, method='linear', limit=None,
 
         result[firstIndex:][invalid] = _interpolate_scipy_wrapper(
             valid_x, valid_y, new_x, method=method, fill_value=fill_value,
-            bounds_error=bounds_error, **kwargs)
+            bounds_error=bounds_error, order=order)
         if limit:
             result[violate_limit] = np.nan
         return result
 
 
 def _interpolate_scipy_wrapper(x, y, new_x, method, fill_value=None,
-                               bounds_error=False, order=None, **kwargs):
+                               bounds_error=False, order=None):
     """
     passed off to scipy.interpolate.interp1d. method is scipy's kind.
     Returns an array interpolated at new_x.  Add any new methods to
diff --git a/pandas/core/config.py b/pandas/core/config.py
index b59e07251..e97468947 100644
--- a/pandas/core/config.py
+++ b/pandas/core/config.py
@@ -109,7 +109,11 @@ def _set_option(*args, **kwargs):
                              "arguments")
 
     # default to false
-    silent = kwargs.get('silent', False)
+    silent = kwargs.pop('silent', False)
+
+    if kwargs:
+        raise TypeError('_set_option() got an unexpected keyword '
+                'argument "{0}"'.format(list(kwargs.keys())[0]))
 
     for k, v in zip(args[::2], args[1::2]):
         key = _get_single_key(k, silent)
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 18500fd05..c5668f497 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -267,7 +267,7 @@ class NDFrame(PandasObject):
                         raise TypeError(
                             "not enough/duplicate arguments specified!")
 
-        axes = dict([(a, kwargs.get(a)) for a in self._AXIS_ORDERS])
+        axes = dict([(a, kwargs.pop(a, None)) for a in self._AXIS_ORDERS])
         return axes, kwargs
 
     @classmethod
@@ -444,8 +444,13 @@ class NDFrame(PandasObject):
         new_axes = self._construct_axes_dict_from(
             self, [self._get_axis(x) for x in axes_names])
         new_values = self.values.transpose(axes_numbers)
-        if kwargs.get('copy') or (len(args) and args[-1]):
+        if kwargs.pop('copy', None) or (len(args) and args[-1]):
             new_values = new_values.copy()
+
+        if kwargs:
+            raise TypeError('transpose() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
+
         return self._constructor(new_values, **new_axes).__finalize__(self)
 
     def swapaxes(self, axis1, axis2, copy=True):
@@ -540,8 +545,12 @@ class NDFrame(PandasObject):
     def rename(self, *args, **kwargs):
 
         axes, kwargs = self._construct_axes_from_arguments(args, kwargs)
-        copy = kwargs.get('copy', True)
-        inplace = kwargs.get('inplace', False)
+        copy = kwargs.pop('copy', True)
+        inplace = kwargs.pop('inplace', False)
+
+        if kwargs:
+            raise TypeError('rename() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
 
         if (com._count_not_none(*axes.values()) == 0):
             raise TypeError('must pass an index to rename')
@@ -1531,10 +1540,12 @@ class NDFrame(PandasObject):
         -------
         reindexed : same as input
         """
-        d = other._construct_axes_dict(method=method, copy=copy, limit=limit)
+        d = other._construct_axes_dict(axes=self._AXIS_ORDERS,
+                method=method, copy=copy, limit=limit)
+
         return self.reindex(**d)
 
-    def drop(self, labels, axis=0, level=None, inplace=False, **kwargs):
+    def drop(self, labels, axis=0, level=None, inplace=False):
         """
         Return new object with labels in requested axis removed
 
@@ -1708,11 +1719,15 @@ class NDFrame(PandasObject):
 
         # construct the args
         axes, kwargs = self._construct_axes_from_arguments(args, kwargs)
-        method = com._clean_reindex_fill_method(kwargs.get('method'))
-        level = kwargs.get('level')
-        copy = kwargs.get('copy', True)
-        limit = kwargs.get('limit')
-        fill_value = kwargs.get('fill_value', np.nan)
+        method = com._clean_reindex_fill_method(kwargs.pop('method', None))
+        level = kwargs.pop('level', None)
+        copy = kwargs.pop('copy', True)
+        limit = kwargs.pop('limit', None)
+        fill_value = kwargs.pop('fill_value', np.nan)
+
+        if kwargs:
+            raise TypeError('reindex() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
 
         self._consolidate_inplace()
 
@@ -1917,7 +1932,7 @@ class NDFrame(PandasObject):
     #----------------------------------------------------------------------
     # Attribute access
 
-    def __finalize__(self, other, method=None, **kwargs):
+    def __finalize__(self, other, method=None):
         """
         propagate metadata from other to self
 
@@ -3422,7 +3437,7 @@ class NDFrame(PandasObject):
 
         return self._constructor(new_data).__finalize__(self)
 
-    def slice_shift(self, periods=1, axis=0, **kwds):
+    def slice_shift(self, periods=1, axis=0):
         """
         Equivalent to `shift` without copying data. The shifted data will
         not include the dropped periods and the shifted axis will be smaller
@@ -4053,7 +4068,7 @@ equivalent of the ``numpy.ndarray`` method ``argmin``.""", nanops.nanmin)
                       desc="Return the mean absolute deviation of the values "
                            "for the requested axis")
         @Appender(_num_doc)
-        def mad(self,  axis=None, skipna=None, level=None, **kwargs):
+        def mad(self,  axis=None, skipna=None, level=None):
             if skipna is None:
                 skipna = True
             if axis is None:
@@ -4111,7 +4126,7 @@ equivalent of the ``numpy.ndarray`` method ``argmin``.""", nanops.nanmin)
                       desc="Return the compound percentage of the values for "
                            "the requested axis")
         @Appender(_num_doc)
-        def compound(self, axis=None, skipna=None, level=None, **kwargs):
+        def compound(self, axis=None, skipna=None, level=None):
             if skipna is None:
                 skipna = True
             return (1 + self).prod(axis=axis, skipna=skipna, level=level) - 1
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 0be046bbd..d2d40f01c 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -910,7 +910,7 @@ class GroupBy(PandasObject):
 
         return result
 
-    def cumcount(self, **kwargs):
+    def cumcount(self, ascending=True):
         """
         Number each item in each group from 0 to the length of that group - 1.
 
@@ -955,7 +955,6 @@ class GroupBy(PandasObject):
 
         """
         self._set_selection_from_grouper()
-        ascending = kwargs.pop('ascending', True)
 
         index = self._selected_obj.index
         cumcounts = self._cumcount_array(ascending=ascending)
@@ -1016,15 +1015,13 @@ class GroupBy(PandasObject):
         tail = obj[in_tail]
         return tail
 
-    def _cumcount_array(self, arr=None, **kwargs):
+    def _cumcount_array(self, arr=None, ascending=True):
         """
         arr is where cumcount gets its values from
 
         note: this is currently implementing sort=False (though the default is sort=True)
               for groupby in general
         """
-        ascending = kwargs.pop('ascending', True)
-
         if arr is None:
             arr = np.arange(self.grouper._max_groupsize, dtype='int64')
 
@@ -3094,7 +3091,7 @@ class NDFrameGroupBy(GroupBy):
         for name, group in gen:
             object.__setattr__(group, 'name', name)
 
-            res = func(group)
+            res = func(group, *args, **kwargs)
 
             try:
                 res = res.squeeze()
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 0cad53785..da94a8d64 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -415,7 +415,7 @@ class Index(IndexOpsMixin, PandasObject):
                                  quote_strings=True)
         return "%s(%s, dtype='%s')" % (type(self).__name__, prepr, self.dtype)
 
-    def to_series(self, **kwargs):
+    def to_series(self):
         """
         Create a Series with both index and values equal to the index keys
         useful with map for returning an indexer based on an index
@@ -1604,7 +1604,7 @@ class Index(IndexOpsMixin, PandasObject):
                            left_indexer, right_indexer)
         return indexer
 
-    def get_indexer_non_unique(self, target, **kwargs):
+    def get_indexer_non_unique(self, target):
         """ return an indexer suitable for taking from a non unique index
             return the labels in the same order as the target, and
             return a missing indexer into the target (missing are marked as -1
@@ -3766,7 +3766,7 @@ class MultiIndex(Index):
             return Index(new_tuples)
 
     def argsort(self, *args, **kwargs):
-        return self.values.argsort()
+        return self.values.argsort(*args, **kwargs)
 
     def repeat(self, n):
         return MultiIndex(levels=self.levels,
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 4453c7eaf..d5c39a8e2 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -278,7 +278,7 @@ class Block(PandasObject):
 
     def apply(self, func, **kwargs):
         """ apply the function to my values; return a block if we are not one """
-        result = func(self.values)
+        result = func(self.values, **kwargs)
         if not isinstance(result, Block):
             result = make_block(values=_block_shape(result), placement=self.mgr_locs,)
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 2b2d28d62..f77ed59df 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -145,7 +145,12 @@ class Panel(NDFrame):
         if dtype is not None:
             dtype = self._validate_dtype(dtype)
 
-        passed_axes = [kwargs.get(a) for a in self._AXIS_ORDERS]
+        passed_axes = [kwargs.pop(a, None) for a in self._AXIS_ORDERS]
+
+        if kwargs:
+            raise TypeError('_init_data() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
+
         axes = None
         if isinstance(data, BlockManager):
             if any(x is not None for x in passed_axes):
@@ -471,7 +476,11 @@ class Panel(NDFrame):
             raise TypeError('There must be an argument for each axis, you gave'
                             ' {0} args, but {1} are required'.format(nargs,
                                                                      nreq))
-        takeable = kwargs.get('takeable')
+        takeable = kwargs.pop('takeable', None)
+
+        if kwargs:
+            raise TypeError('get_value() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
 
         if takeable is True:
             lower = self._iget_item_cache(args[0])
@@ -506,7 +515,11 @@ class Panel(NDFrame):
             raise TypeError('There must be an argument for each axis plus the '
                             'value provided, you gave {0} args, but {1} are '
                             'required'.format(nargs, nreq))
-        takeable = kwargs.get('takeable')
+        takeable = kwargs.pop('takeable', None)
+
+        if kwargs:
+            raise TypeError('set_value() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
 
         try:
             if takeable is True:
@@ -607,7 +620,7 @@ class Panel(NDFrame):
         """ don't allow a multi reindex on Panel or above ndim """
         return False
 
-    def dropna(self, axis=0, how='any', inplace=False, **kwargs):
+    def dropna(self, axis=0, how='any', inplace=False):
         """
         Drop 2D from panel, holding passed axis constant
 
@@ -1065,7 +1078,7 @@ class Panel(NDFrame):
 
         return self._construct_return_type(result, axes)
 
-    def _construct_return_type(self, result, axes=None, **kwargs):
+    def _construct_return_type(self, result, axes=None):
         """ return the type for the ndim of the result """
         ndim = getattr(result,'ndim',None)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 901faef48..a929b8eeb 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2374,6 +2374,11 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         inplace : boolean, default False
             Do operation in place.
         """
+        kwargs.pop('how', None)
+        if kwargs:
+            raise TypeError('dropna() got an unexpected keyword '
+                    'argument "{0}"'.format(list(kwargs.keys())[0]))
+
         axis = self._get_axis_number(axis or 0)
         result = remove_na(self)
         if inplace:
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index 40d6d2151..3dd8c2594 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -369,6 +369,26 @@ class Generic(object):
         self.assertTrue(len(np.array_split(o,5)) == 5)
         self.assertTrue(len(np.array_split(o,2)) == 2)
 
+    def test_unexpected_keyword(self):  # GH8597
+        from pandas.util.testing import assertRaisesRegexp
+
+        df = DataFrame(np.random.randn(5, 2), columns=['jim', 'joe'])
+        ca = pd.Categorical([0, 0, 2, 2, 3, np.nan])
+        ts = df['joe'].copy()
+        ts[2] = np.nan
+
+        with assertRaisesRegexp(TypeError, 'unexpected keyword'):
+            df.drop('joe', axis=1, in_place=True)
+
+        with assertRaisesRegexp(TypeError, 'unexpected keyword'):
+            df.reindex([1, 0], inplace=True)
+
+        with assertRaisesRegexp(TypeError, 'unexpected keyword'):
+            ca.fillna(0, inplace=True)
+
+        with assertRaisesRegexp(TypeError, 'unexpected keyword'):
+            ts.fillna(0, in_place=True)
+
 class TestSeries(tm.TestCase, Generic):
     _typ = Series
     _comparator = lambda self, x, y: assert_series_equal(x,y)
@@ -602,7 +622,7 @@ class TestSeries(tm.TestCase, Generic):
         result = s.interpolate(method='slinear')
         assert_series_equal(result, expected)
 
-        result = s.interpolate(method='slinear', donwcast='infer')
+        result = s.interpolate(method='slinear', downcast='infer')
         assert_series_equal(result, expected)
         # nearest
         expected = Series([1, 3, 3, 12, 12, 25])
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 9534bc5dd..9498c7e12 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -4708,26 +4708,6 @@ class TestGroupBy(tm.TestCase):
                 expected = getattr(frame,op)(level=level,axis=axis)
                 assert_frame_equal(result, expected)
 
-    def test_regression_kwargs_whitelist_methods(self):
-        # GH8733
-
-        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
-                                   ['one', 'two', 'three']],
-                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
-                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
-                           names=['first', 'second'])
-        raw_frame = DataFrame(np.random.randn(10, 3), index=index,
-                               columns=Index(['A', 'B', 'C'], name='exp'))
-
-        grouped = raw_frame.groupby(level=0, axis=1)
-        grouped.all(test_kwargs='Test kwargs')
-        grouped.any(test_kwargs='Test kwargs')
-        grouped.cumcount(test_kwargs='Test kwargs')
-        grouped.mad(test_kwargs='Test kwargs')
-        grouped.cummin(test_kwargs='Test kwargs')
-        grouped.skew(test_kwargs='Test kwargs')
-        grouped.cumprod(test_kwargs='Test kwargs')
-
     def test_groupby_blacklist(self):
         from string import ascii_lowercase
         letters = np.array(list(ascii_lowercase))

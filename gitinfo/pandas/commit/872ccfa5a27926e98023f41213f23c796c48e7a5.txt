commit 872ccfa5a27926e98023f41213f23c796c48e7a5
Author: Chang She <chang@lambdafoundry.com>
Date:   Tue May 1 03:09:02 2012 -0400

    ENH: small refactor of tseries.plotting and adding specialized PeriodIndex/DatetimeIndex plotting back in

diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 4af3f7fef..f388f142d 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -309,6 +309,11 @@ class LinePlot(MPLPlot):
 
     def __init__(self, data, **kwargs):
         MPLPlot.__init__(self, data, **kwargs)
+        self.has_ts_index = False
+        from pandas.tseries.index import DatetimeIndex
+        from pandas.tseries.period import PeriodIndex
+        if isinstance(data.index, (DatetimeIndex, PeriodIndex)):
+            self.has_ts_index = True
 
     def _get_plot_function(self):
         if self.logy:
@@ -324,22 +329,71 @@ class LinePlot(MPLPlot):
 
     def _make_plot(self):
         # this is slightly deceptive
-        x = self._get_xticks()
+        if self.use_index and self.has_ts_index:
+            data = self._maybe_convert_index(self.data)
+            self._make_ts_plot(data)
+        else:
+            x = self._get_xticks()
+
+            plotf = self._get_plot_function()
+
+            for i, (label, y) in enumerate(self._iter_data()):
+                if self.subplots:
+                    ax = self.axes[i]
+                    style = 'k'
+                else:
+                    style = ''  # empty string ignored
+                    ax = self.ax
+                if self.style:
+                    style = self.style
+
+                plotf(ax, x, y, style, label=label, **self.kwds)
+                ax.grid(self.grid)
+
+    def _maybe_convert_index(self, data):
+        # tsplot converts automatically, but don't want to convert index
+        # over and over for DataFrames
+        from pandas.tseries.offsets import DateOffset
+        from pandas.tseries.index import DatetimeIndex
+        from pandas.core.frame import DataFrame
 
-        plotf = self._get_plot_function()
+        if (isinstance(data.index, DatetimeIndex) and
+            isinstance(data, DataFrame)):
+            freq = getattr(data.index, 'freq', None)
+            if freq is None and hasattr(data.index, 'inferred_freq'):
+                freq = data.index.inferred_freq
 
-        for i, (label, y) in enumerate(self._iter_data()):
-            if self.subplots:
-                ax = self.axes[i]
-                style = 'k'
+            if isinstance(freq, DateOffset):
+                freq = freq.rule_code
+
+            data = DataFrame(data.values,
+                             index=data.index.to_period(freq=freq),
+                             columns=data.columns)
+        return data
+
+    def _make_ts_plot(self, data, **kwargs):
+        from pandas.core.series import Series
+        from pandas.core.frame import DataFrame
+        import pandas.tseries.plotting as plot
+
+        if isinstance(data, Series):
+            if self.subplots: # shouldn't even allow users to specify
+                ax = self.axes[0]
             else:
-                style = ''  # empty string ignored
                 ax = self.ax
-            if self.style:
-                style = self.style
 
-            plotf(ax, x, y, style, label=label, **self.kwds)
+            label = com._stringify(self.label)
+            plot.tsplot(ax, data, label=label, **kwargs)
             ax.grid(self.grid)
+        else:
+            for i, col in enumerate(data.columns):
+                if self.subplots:
+                    ax = self.axes[i]
+                else:
+                    ax = self.ax
+                label = com._stringify(col)
+                plot.tsplot(ax, data[col], label=label, **kwargs)
+                ax.grid(self.grid)
 
     def _post_plot_logic(self):
         df = self.data
@@ -602,24 +656,6 @@ def plot_series(series, label=None, kind='line', use_index=True, rot=None,
 
     return plot_obj.ax
 
-# if use_index:
-#     # custom datetime/interval plotting
-#     from pandas import IntervalIndex, DatetimeIndex
-#     if isinstance(self.index, IntervalIndex):
-#         return tsp.tsplot(self)
-#     if isinstance(self.index, DatetimeIndex):
-#         offset = self.index.freq
-#         name = datetools._newOffsetNames.get(offset, None)
-#         if name is not None:
-#             try:
-#                 code = datetools._interval_str_to_code(name)
-#                 s_ = Series(self.values,
-#                             index=self.index.to_interval(freq=code),
-#                             name=self.name)
-#                 tsp.tsplot(s_)
-#             except:
-#                 pass
-
 def boxplot(data, column=None, by=None, ax=None, fontsize=None,
             rot=0, grid=True, figsize=None):
     """
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index c2608b60c..a5b22e2b9 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -8,6 +8,29 @@ from pandas.util.decorators import cache_readonly
 import pandas.tseries.offsets as offsets
 import pandas._tseries as lib
 
+class FreqGroup(object):
+    FR_ANN = 1000
+    FR_QTR = 2000
+    FR_MTH = 3000
+    FR_WK = 4000
+    FR_BUS = 5000
+    FR_DAY = 6000
+    FR_HR = 7000
+    FR_MIN = 8000
+    FR_SEC = 9000
+    FR_UND = -10000
+
+def get_freq_group(freq):
+    if isinstance(freq, basestring):
+        base, mult = get_freq_code(freq)
+        freq = base
+    return (freq // 1000) * 1000
+
+def get_freq(freq):
+    if isinstance(freq, basestring):
+        base, mult = get_freq_code(freq)
+        freq = base
+    return freq
 
 def get_freq_code(freqstr):
     """
diff --git a/pandas/tseries/plotting.py b/pandas/tseries/plotting.py
index fb7f7bb67..16efb0eab 100644
--- a/pandas/tseries/plotting.py
+++ b/pandas/tseries/plotting.py
@@ -6,17 +6,17 @@ Adapted from scikits.timeseries by Pierre GF Gerard-Marchant & Matt Knox
 
 
 from matplotlib import pylab
-from matplotlib.axes import Subplot
-from matplotlib.figure import Figure
 from matplotlib.ticker import Formatter, Locator
 from matplotlib.transforms import nonsingular
 
 import numpy as np
 
-import pandas.core.datetools as datetools
+from pandas.tseries.offsets import DateOffset
+import pandas.tseries.frequencies as frequencies
+from pandas.tseries.frequencies import FreqGroup
 
-from pandas.core.datetools import Period
-from pandas.core.index import PeriodIndex
+from pandas.tseries.period import Period, PeriodIndex
+from pandas.tseries.index import DatetimeIndex
 from pandas.core.series import Series
 
 import warnings
@@ -50,58 +50,191 @@ mandatoryplotargs="""args : var
 
 
 #####---------------------------------------------------------------------------
-#---- --- Matplotlib extensions ---
+#---- Plotting functions and monkey patches
 #####---------------------------------------------------------------------------
-
-def add_generic_subplot(figure_instance, *args, **kwargs):
+def tsplot(axes, series, *args, **kwargs):
     """
-    Generalizes the :meth:`matplotlib.Figure.add_subplot` method
-    of :class:`~matplotlib.figure.Figure` to generic subplots.
-    The specific Subplot object class to add is given through the keywords
-    ``SubplotClass`` or ``class``.
+    Plots a Series on the given Matplotlib axes object
 
     Parameters
     ----------
-    figure_instance : Figure object
-        Figure to which the generic subplot should be attached.
-    args : {var}
-        Miscellaneous arguments to the subplot.
-    kwargs : {Dictionary}
-        Optional keywords.
-        The same keywords as ``Subplot`` are recognized, with the addition of:
-
-        + *SubplotClass* : {string}
-          Type of subplot.
-        + *subclass* : {string}
-          Shortcut to SubplotClass.
-        + any keyword required by the ``SubplotClass`` subclass.
+    axes : Axes
+    series : Series
+
+    Notes
+    _____
+    Supports same args and kwargs as Axes.plot
 
     """
-    key = figure_instance._make_key(*args, ** kwargs)
-    #!!!: Find why, sometimes, key is not hashable (even if tuple)
-    # else, there's a fix below
-    try:
-        key.__hash__()
-    except TypeError:
-        key = str(key)
-
-    if figure_instance._axstack.get(key):
-        ax = figure_instance._axstack[key]
-        figure_instance.sca(ax)
-        return ax
-
-    SubplotClass = kwargs.pop("SubplotClass", Subplot)
-    SubplotClass = kwargs.pop("subclass", SubplotClass)
-    if isinstance(args[0], Subplot):
-        a = args[0]
-        assert(a.get_figure() is figure_instance)
-    else:
-        a = SubplotClass(figure_instance, *args, **kwargs)
+    freq = getattr(series.index, 'freq', None)
+    if freq is None and hasattr(series.index, 'inferred_freq'):
+        freq = series.index.inferred_freq
+    if isinstance(freq, DateOffset):
+        freq = freq.rule_code
+
+    if isinstance(series.index, DatetimeIndex):
+        idx = series.index.to_period(freq=freq)
+        series = Series(series.values, idx, series.name)
+
+    if not isinstance(series.index, PeriodIndex):
+        raise TypeError('series argument to tsplot must have DatetimeIndex or '
+                        'PeriodIndex')
+
+    args = _check_plot_params(series, series.index, freq, *args)
+
+    axes.freq = freq
+    axes.legendlabels = [kwargs.get('label', None)]
+    axes.view_interval = None
+    axes.date_axis_info = None
+
+    plotted = axes.plot(*args,  **kwargs)
+
+    format_dateaxis(axes, axes.freq)
+
+    # when adding a right axis (using add_yaxis), for some reason the
+    # x axis limits don't get properly set. This gets around the problem
+    xlim = axes.get_xlim()
+    if xlim[0] == 0.0 and xlim[1] == 1.0:
+        # if xlim still at default values, autoscale the axis
+        axes.autoscale_view()
+
+    left = get_datevalue(series.index[0], freq)
+    right = get_datevalue(series.index[-1], freq)
+    axes.set_xlim(left, right)
+
+    return plotted
+
+tsplot.__doc__ %= _doc_parameters
+
+def get_datevalue(date, freq):
+    if isinstance(date, Period):
+        return date.asfreq(freq).ordinal
+    elif isinstance(date, str):
+        return Period(date, freq).ordinal
+    elif isinstance(date, (int, float)) or \
+            (isinstance(date, np.ndarray) and (date.size == 1)):
+        return date
+    elif date is None:
+        return None
+    raise ValueError("Unrecognizable date '%s'" % date)
+
+def format_dateaxis(subplot, freq):
+    """
+    Pretty-formats the date axis (x-axis).
+
+    Major and minor ticks are automatically set for the frequency of the
+    current underlying series.  As the dynamic mode is activated by
+    default, changing the limits of the x axis will intelligently change
+    the positions of the ticks.
+    """
+    majlocator = TimeSeries_DateLocator(freq, dynamic_mode=True,
+                                        minor_locator=False,
+                                        plot_obj=subplot)
+    minlocator = TimeSeries_DateLocator(freq, dynamic_mode=True,
+                                        minor_locator=True,
+                                        plot_obj=subplot)
+    subplot.xaxis.set_major_locator(majlocator)
+    subplot.xaxis.set_minor_locator(minlocator)
+
+    majformatter = TimeSeries_DateFormatter(freq, dynamic_mode=True,
+                                            minor_locator=False,
+                                            plot_obj=subplot)
+    minformatter = TimeSeries_DateFormatter(freq, dynamic_mode=True,
+                                            minor_locator=True,
+                                            plot_obj=subplot)
+    subplot.xaxis.set_major_formatter(majformatter)
+    subplot.xaxis.set_minor_formatter(minformatter)
+    pylab.draw_if_interactive()
+
+def _check_plot_params(series, xdata, freq, *args):
+    """
+    Defines the plot coordinates (and basic plotting arguments).
+    """
+    # TODO clean up this massive method
+    remaining = list(args)
+    noinfo_msg = "No date information available!"
+    # No args ? Use defaults, if any
+    if len(args) == 0:
+        if xdata is None:
+            raise ValueError(noinfo_msg)
+        return (xdata, series)
+    output = []
+    while len(remaining) > 0:
+        a = remaining.pop(0)
+
+        # The argument is a format: use default dates/
+        if isinstance(a, str):
+            if xdata is None:
+                raise ValueError(noinfo_msg)
+            else:
+                output.extend([xdata, series, a])
+
+        # The argument is a Series: use its dates for x
+        elif isinstance(a, Series):
+            (x, y) = (a.index, a.values)
+            if len(remaining) > 0 and isinstance(remaining[0], str):
+                b = remaining.pop(0)
+                output.extend([x, y, b])
+            else:
+                output.extend([x, y])
+
+        # The argument is a PeriodIndex............
+        elif isinstance(a, PeriodIndex):
+            # Force to current freq
+            if freq is not None:
+                if a.freq != freq:
+                    a = a.asfreq(freq)
+
+            # There's an argument after
+            if len(remaining) > 0:
+
+                #...and it's a format string
+                if isinstance(remaining[0], str):
+                    b = remaining.pop(0)
+                    if series is None:
+                        raise ValueError(noinfo_msg)
+                    else:
+                        output.extend([a, series, b])
+
+                #... and it's another date: use the default
+                elif isinstance(remaining[0], PeriodIndex):
+                    if series is None:
+                        raise ValueError(noinfo_msg)
+                    else:
+                        output.extend([a, series])
+
+                #... and it must be some data
+                else:
+                    b = remaining.pop(0)
+                    if len(remaining) > 0:
+                        if isinstance(remaining[0], str):
+                            c = remaining.pop(0)
+                            output.extend([a, b, c])
+                        else:
+                            output.extend([a, b])
+            else:
+                if series is None:
+                    raise ValueError(noinfo_msg)
 
-    figure_instance.axes.append(a)
-    figure_instance._axstack.add(key, a)
-    figure_instance.sca(a)
-    return a
+        # Otherwise..............................
+        elif len(remaining) > 0 and isinstance(remaining[0], str):
+            b = remaining.pop(0)
+            if xdata is None:
+                raise ValueError(noinfo_msg)
+            else:
+                output.extend([xdata, a, b])
+        elif xdata is None:
+            raise ValueError(noinfo_msg)
+        else:
+            output.extend([xdata, a])
+    # Reinitialize the plot if needed ...........
+    if xdata is None:
+        xdata = output[0]
+    # Force the xdata to the current frequency
+    elif output[0].freq != freq:
+        output = list(output)
+        output[0] = output[0].asfreq(freq)
+    return output
 
 ##### -------------------------------------------------------------------------
 #---- --- Locators ---
@@ -141,7 +274,7 @@ def period_break(dates, period):
         Name of the period to monitor.
     """
     current = getattr(dates, period)
-    previous = getattr(dates-1, period)
+    previous = getattr(dates - 1, period)
     return (current - previous).nonzero()[0]
 
 
@@ -160,54 +293,32 @@ def has_level_label(label_flags, vmin):
     else:
         return True
 
-FR_ANN = 1000
-FR_QTR = 2000
-FR_MTH = 3000
-FR_WK = 4000
-FR_BUS = 5000
-FR_DAY = 6000
-FR_HR = 7000
-FR_MIN = 8000
-FR_SEC = 9000
-FR_UND = -10000
-
-def get_freq_group(freq):
-    if isinstance(freq, basestring):
-        base, mult = datetools._get_freq_code(freq)
-        freq = base
-    return (freq // 1000) * 1000
-
-def get_freq(freq):
-    if isinstance(freq, basestring):
-        base, mult = datetools._get_freq_code(freq)
-        freq = base
-    return freq
 
 def _daily_finder(vmin, vmax, freq):
     periodsperday = -1
 
-    if freq >= FR_HR:
-        if freq == FR_SEC:
+    if freq >= FreqGroup.FR_HR:
+        if freq == FreqGroup.FR_SEC:
             periodsperday = 24 * 60 * 60
-        elif freq == FR_MIN:
+        elif freq == FreqGroup.FR_MIN:
             periodsperday = 24 * 60
-        elif freq == FR_HR:
+        elif freq == FreqGroup.FR_HR:
             periodsperday = 24
         else:
             raise ValueError("unexpected frequency: %s" % freq)
         periodsperyear = 365 * periodsperday
         periodspermonth = 28 * periodsperday
 
-    elif freq == FR_BUS:
+    elif freq == FreqGroup.FR_BUS:
         periodsperyear = 261
         periodspermonth = 19
-    elif freq == FR_DAY:
+    elif freq == FreqGroup.FR_DAY:
         periodsperyear = 365
         periodspermonth = 28
-    elif get_freq_group(freq) == FR_WK:
+    elif frequencies.get_freq_group(freq) == FreqGroup.FR_WK:
         periodsperyear = 52
         periodspermonth = 3
-    elif freq == FR_UND:
+    elif freq == FreqGroup.FR_UND:
         periodsperyear = 100
         periodspermonth = 10
     else:
@@ -318,7 +429,7 @@ def _daily_finder(vmin, vmax, freq):
     elif span <= periodsperyear // 4:
         month_start = period_break(dates_, 'month')
         info_maj[month_start] = True
-        if freq < FR_HR:
+        if freq < FreqGroup.FR_HR:
             info['min'] = True
         else:
             day_start = period_break(dates_, 'day')
@@ -378,7 +489,7 @@ def _daily_finder(vmin, vmax, freq):
     # Case 6. More than 12 years ................
     else:
         year_start = period_break(dates_, 'year')
-        year_break = dates_[year_start].years
+        year_break = dates_[year_start].year
         nyears = span / periodsperyear
         (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
         major_idx = year_start[(year_break % maj_anndef == 0)]
@@ -393,9 +504,9 @@ def _daily_finder(vmin, vmax, freq):
 
 def _monthly_finder(vmin, vmax, freq):
     if isinstance(freq, basestring):
-        freq = get_freq(freq)
+        freq = frequencies.get_freq(freq)
 
-    if freq != FR_MTH:
+    if freq != FreqGroup.FR_MTH:
         raise ValueError("Unexpected frequency")
     periodsperyear = 12
 
@@ -468,9 +579,9 @@ def _monthly_finder(vmin, vmax, freq):
 
 def _quarterly_finder(vmin, vmax, freq):
     if isinstance(freq, basestring):
-        freq = get_freq(freq)
+        freq = frequencies.get_freq(freq)
 
-    if get_freq_group(freq) != FR_QTR:
+    if frequencies.get_freq_group(freq) != FreqGroup.FR_QTR:
         raise ValueError("Unexpected frequency")
     periodsperyear = 4
     vmin_orig = vmin
@@ -519,8 +630,8 @@ def _quarterly_finder(vmin, vmax, freq):
 
 def _annual_finder(vmin, vmax, freq):
     if isinstance(freq, basestring):
-        freq = get_freq(freq)
-    if get_freq_group(freq) != FR_ANN:
+        freq = frequencies.get_freq(freq)
+    if frequencies.get_freq_group(freq) != FreqGroup.FR_ANN:
         raise ValueError("Unexpected frequency")
     (vmin, vmax) = (int(vmin), int(vmax + 1))
     span = vmax - vmin + 1
@@ -543,16 +654,17 @@ def _annual_finder(vmin, vmax, freq):
 
 def get_finder(freq):
     if isinstance(freq, basestring):
-        freq = get_freq(freq)
-    fgroup = get_freq_group(freq)
+        freq = frequencies.get_freq(freq)
+    fgroup = frequencies.get_freq_group(freq)
 
-    if fgroup == FR_ANN:
+    if fgroup == FreqGroup.FR_ANN:
         return _annual_finder
-    elif fgroup == FR_QTR:
+    elif fgroup == FreqGroup.FR_QTR:
         return _quarterly_finder
-    elif freq ==FR_MTH:
+    elif freq ==FreqGroup.FR_MTH:
         return _monthly_finder
-    elif (freq >= FR_BUS) or (freq == FR_UND) or fgroup == FR_WK:
+    elif ((freq >= FreqGroup.FR_BUS) or (freq == FreqGroup.FR_UND) or
+          fgroup == FreqGroup.FR_WK):
         return _daily_finder
     else:
         errmsg = "Unsupported frequency: %s" % (freq)
@@ -579,7 +691,7 @@ class TimeSeries_DateLocator(Locator):
     def __init__(self, freq, minor_locator=False, dynamic_mode=True,
                  base=1, quarter=1, month=1, day=1, plot_obj=None):
         if isinstance(freq, basestring):
-            freq = get_freq(freq)
+            freq = frequencies.get_freq(freq)
         self.freq = freq
         self.base = base
         (self.quarter, self.month, self.day) = (quarter, month, day)
@@ -589,16 +701,6 @@ class TimeSeries_DateLocator(Locator):
         self.plot_obj = plot_obj
         self.finder = get_finder(freq)
 
-    def asminor(self):
-        "Returns the locator set to minor mode."
-        self.isminor = True
-        return self
-
-    def asmajor(self):
-        "Returns the locator set to major mode."
-        self.isminor = False
-        return self
-
     def _get_default_locs(self, vmin, vmax):
         "Returns the default locations of ticks."
 
@@ -613,7 +715,7 @@ class TimeSeries_DateLocator(Locator):
 
     def __call__(self):
         'Return the locations of the ticks.'
-
+        # axis calls Locator.set_axis inside set_m<xxxx>_formatter
         vi = tuple(self.axis.get_view_interval())
         if vi != self.plot_obj.view_interval:
             self.plot_obj.date_axis_info = None
@@ -667,7 +769,7 @@ class TimeSeries_DateFormatter(Formatter):
     def __init__(self, freq, minor_locator=False, dynamic_mode=True,
                  plot_obj=None):
         if isinstance(freq, basestring):
-            freq = get_freq(freq)
+            freq = frequencies.get_freq(freq)
         self.format = None
         self.freq = freq
         self.locs = []
@@ -678,16 +780,6 @@ class TimeSeries_DateFormatter(Formatter):
         self.plot_obj = plot_obj
         self.finder = get_finder(freq)
 
-    def asminor(self):
-        "Returns the formatter set to minor mode."
-        self.isminor = True
-        return self
-
-    def asmajor(self):
-        "Returns the fromatter set to major mode."
-        self.isminor = False
-        return self
-
     def _set_default_format(self, vmin, vmax):
         "Returns the default ticks spacing."
 
@@ -724,355 +816,20 @@ class TimeSeries_DateFormatter(Formatter):
             fmt = self.formatdict.pop(x, '')
             return Period(int(x), self.freq).strftime(fmt)
 
-
-#####--------------------------------------------------------------------------
-#---- --- TimeSeries plots ---
-#####--------------------------------------------------------------------------
-
-class TimeSeriesPlot(Subplot, object):
-    """
-    Based on : :class:`~matplotlib.axes.SubPlot`
-
-    Defines a subclass of :class:`matplotlib.axes.Subplot` to plot time series.
-
-    A :class:`~Series` is associated with the plot.  This time series is
-    usually specified at the creation of the plot, through the optional
-    parameter ``series``.  If no series is given at the creation, the first
-    time series being plotted will be used as associated series.
-
-    The associated series is stored in the :attr:`~TimeSeriesPlot.series`
-    attribute.  It gives its frequency to the plot.  This frequency can be
-    accessed through the attribute :attr:`freq`.  All the other series that
-    will be plotted will be first converted to the :attr:`freq` frequency,
-    using their :meth:`~asfreq` method.
-
-    The same parameters used for the instanciation of a standard
-    :class:`matplotlib.axes.Subplot` are recognized.
-
-    Parameters
-    ----------
-    series : {None, Series}, optional
-        The time series allocated to the plot.
-
-    Attributes
-    ----------
-    freq : int
-        Frequency of the plot.
-    xdata : PeriodIndex
-        The array of dates corresponding to the x axis.
-    legendsymbols : list
-    legendlabels : list
-        List of the labels associated with each plot.
-        The first label corresponds to the first plot, the second label to the
-        second plot, and so forth.
-
-    Warnings
-    --------
-    * Because the series to plot are first converted to the plot frequency, it
-    * is recommended when plotting several series to associate the plot with
-    * the series with the highest frequency, in order to keep a good level of
-    * detail.
-
-    """
-    def __init__(self, fig=None, *args, **kwargs):
-
-        # Retrieve the series ...................
-        _series = kwargs.pop('series', getattr(fig, 'series', None))
-        Subplot.__init__(self, fig, *args, **kwargs)
-
-        # Process options .......................
-        self.set_series(series=_series)
-
-        self._austoscale = False
-        # Get the data to plot
-        self.legendsymbols = []
-        self.legendlabels = []
-        # keep track of axis format and tick info
-        self.date_axis_info = None
-        # used to keep track of current view interval to determine if we need
-        # to reset date_axis_info
-        self.view_interval = None
-
-
-    def set_series(self, series=None):
-        """
-        Sets the time series associated with the plot.  If ``series`` is a
-        valid :class:`~Series` object, the :attr:`xdata` attribute is updated
-        to the ``_dates`` part of ``series``.
-        """
-        if series is not None:
-            self._series = series.values
-            self.xdata = series.index
-        else:
-            self._series = None
-            self.xdata = None
-    #
-    def get_series(self):
-        """
-        Returns the data part of the time series associated with the plot,
-        as a (subclass of) :class:`ndarray`.
-        """
-        return self._series
-    #
-    series = property(fget=get_series, fset=set_series,
-                      doc="Underlying time series.")
-
-
-    def set_ydata(self, series=None):
-        errmsg = ("The use of 'set_ydata' is deprecated. "
-                  "Please use 'set_series' instead")
-        warnings.DepreciationWarning(errmsg)
-        return self.set_series(series)
-    #
-    def get_ydata(self):
-        errmsg = ("The use of 'get_ydata' is deprecated. "
-                  "Please use 'get_series' instead")
-        warnings.DepreciationWarning(errmsg)
-        return self.get_series()
-    #
-    ydata = property(fget=get_ydata, fset=set_ydata,
-                     doc="Underlying time series.")
-
-
-    def get_freq(self):
-        """
-        Returns the underlying frequency of the plot
-        """
-        return getattr(self.xdata, 'freq', None)
-    #
-    freq = property(fget=get_freq, doc="Underlying frequency.")
-
-    #......................................................
-    def _check_plot_params(self, *args):
-        """
-        Defines the plot coordinates (and basic plotting arguments).
-        """
-        remaining = list(args)
-        noinfo_msg = "No date information available!"
-        # No args ? Use defaults, if any
-        if len(args) == 0:
-            if self.xdata is None:
-                raise ValueError(noinfo_msg)
-            return (self.xdata, self.series)
-        output = []
-        while len(remaining) > 0:
-            a = remaining.pop(0)
-            # The argument is a format: use default dates/
-            if isinstance(a, str):
-                if self.xdata is None:
-                    raise ValueError(noinfo_msg)
-                else:
-                    output.extend([self.xdata, self.series, a])
-            # The argument is a Series: use its dates for x
-            elif isinstance(a, Series):
-                (x, y) = (a.index, a.values)
-                if len(remaining) > 0 and isinstance(remaining[0], str):
-                    b = remaining.pop(0)
-                    output.extend([x, y, b])
-                else:
-                    output.extend([x, y])
-            # The argument is a PeriodIndex............
-            elif isinstance(a, PeriodIndex):
-                # Force to current freq
-                if self.freq is not None:
-                    if a.freq != self.freq:
-                        a = a.asfreq(self.freq)
-                # There's an argument after
-                if len(remaining) > 0:
-                    #...and it's a format string
-                    if isinstance(remaining[0], str):
-                        b = remaining.pop(0)
-                        if self.series is None:
-                            raise ValueError(noinfo_msg)
-                        else:
-                            output.extend([a, self.series, b])
-                    #... and it's another date: use the default
-                    elif isinstance(remaining[0], PeriodIndex):
-                        if self.series is None:
-                            raise ValueError(noinfo_msg)
-                        else:
-                            output.extend([a, self.series])
-                    #... and it must be some data
-                    else:
-                        b = remaining.pop(0)
-                        if len(remaining) > 0:
-                            if isinstance(remaining[0], str):
-                                c = remaining.pop(0)
-                                output.extend([a, b, c])
-                            else:
-                                output.extend([a, b])
-                else:
-                    if self.series is None:
-                        raise ValueError(noinfo_msg)
-            # Otherwise..............................
-            elif len(remaining) > 0 and isinstance(remaining[0], str):
-                b = remaining.pop(0)
-                if self.xdata is None:
-                    raise ValueError(noinfo_msg)
-                else:
-                    output.extend([self.xdata, a, b])
-            elif self.xdata is None:
-                raise ValueError(noinfo_msg)
-            else:
-                output.extend([self.xdata, a])
-        # Reinitialize the plot if needed ...........
-        if self.xdata is None:
-            self.xdata = output[0]
-        # Force the xdata to the current frequency
-        elif output[0].freq != self.freq:
-            output = list(output)
-            output[0] = output[0].asfreq(self.freq)
-        return output
-    #......................................................
-    def tsplot(self, *args,  **kwargs):
-        """
-        Plots the data parsed in argument to the current axes.  This command
-        accepts the same optional keywords as :func:`matplotlib.pyplot.plot`.
-
-        The argument ``args`` is a variable length argument, allowing for
-        multiple data to be plotted at once. Acceptable combinations are:
-
-        No arguments or a format string: The time series associated with the
-        subplot is plotted with the given format.  If no format string is
-        given, the default format is used instead.  For example, to plot the
-        underlying time series with the default format, use:
-
-            >>> tsplot()
-
-        To plot the underlying time series with a red solid line, use the
-        command:
-
-            >>> tsplot('r-')
-
-        a :class:`~Series` object or one of its subclass with or without a
-        format string: The given time series is plotted with the given format.
-        If no format string is given, the default format is used instead.
-
-        an array or sequence, with or without a format string: The data is
-        plotted with the given format using the :attr:`~TimeSeriesPlot.xdata`
-        attribute of the plot as abscissae.
-
-        two arrays or sequences, with or without a format string: The data are
-        plotted with the given format, using the first array as abscissae and
-        the second as ordinates.
-
-
-        Parameters
-        ----------
-        args : var
-            Sequence of arguments, as described previously.
-        kwargs : var
-            Optional parameters.
-            The same parameters are accepted as for
-            :meth:`matplotlib.axes.Subplot.plot`.
-
-        """
-        args = self._check_plot_params(*args)
-        self.legendlabels.append(kwargs.get('label', None))
-        plotted = Subplot.plot(self, *args,  **kwargs)
-        self.format_dateaxis()
-
-        # when adding a right axis (using add_yaxis), for some reason the
-        # x axis limits don't get properly set. This gets around the problem
-        xlim = self.get_xlim()
-        if xlim[0] == 0.0 and xlim[1] == 1.0:
-            # if xlim still at default values, autoscale the axis
-            self.autoscale_view()
-        self.reset_datelimits()
-        return plotted
-    #......................................................
-    def format_dateaxis(self):
-        """
-        Pretty-formats the date axis (x-axis).
-
-        Major and minor ticks are automatically set for the frequency of the
-        current underlying series.  As the dynamic mode is activated by
-        default, changing the limits of the x axis will intelligently change
-        the positions of the ticks.
-        """
-        # Get the locator class .................
-        majlocator = TimeSeries_DateLocator(self.freq, dynamic_mode=True,
-                                            minor_locator=False, plot_obj=self)
-        minlocator = TimeSeries_DateLocator(self.freq, dynamic_mode=True,
-                                            minor_locator=True, plot_obj=self)
-        self.xaxis.set_major_locator(majlocator)
-        self.xaxis.set_minor_locator(minlocator)
-        # Get the formatter .....................
-        majformatter = TimeSeries_DateFormatter(self.freq, dynamic_mode=True,
-                                                minor_locator=False,
-                                                plot_obj=self)
-        minformatter = TimeSeries_DateFormatter(self.freq, dynamic_mode=True,
-                                                minor_locator=True,
-                                                plot_obj=self)
-        self.xaxis.set_major_formatter(majformatter)
-        self.xaxis.set_minor_formatter(minformatter)
-        pylab.draw_if_interactive()
-    #......................................................
-    def set_dlim(self, start_date=None, end_date=None):
-        """
-        Sets the date limits of the plot to ``start_date`` and ``end_date``.
-        The dates can be given as :class:`~Period` objects, strings or
-        integers.
-
-        Parameters
-        ----------
-        start_date : {var}
-            Starting date of the plot. If None, the current left limit
-            (earliest date) is used.
-        end_date : {var}
-            Ending date of the plot. If None, the current right limit (latest
-            date) is used.
-        """
-        freq = self.freq
-        if freq is None:
-            raise ValueError("Undefined frequency! Date limits can't be set!")
-        # TODO : Shouldn't we make get_datevalue a more generic function ?
-        def get_datevalue(date, freq):
-            if isinstance(date, Period):
-                return date.asfreq(freq).value
-            elif isinstance(date, str):
-                return Period(date, freq).value
-            elif isinstance(date, (int, float)) or \
-                (isinstance(date, np.ndarray) and (date.size == 1)):
-                return date
-            elif date is None:
-                return None
-            raise ValueError("Unrecognizable date '%s'" % date)
-        # Fix left limit ..............
-        xleft = get_datevalue(start_date, freq)
-        # Fix right limit .......
-        xright = get_datevalue(end_date, freq)
-        self.set_xlim(xleft, xright)
-        return (xleft, xright)
-
-    def reset_datelimits(self):
-        """
-        Reset the date range of the x axis to the date range of the underlying
-        time series.
-        """
-        return self.set_xlim(self.xdata[[0, -1]])
-
-    def get_dlim(self):
-        """
-        Returns the limits of the x axis as a :class:`~PeriodIndex`.
-        """
-        xlims = self.get_xlim()
-        return PeriodIndex(xlims, freq=self.freq)
-
-TSPlot = TimeSeriesPlot
+# Do we need these monkey patch methods for convenience?
 
 def add_yaxis(fsp=None, position='right', yscale=None, basey=10, subsy=None):
     """
-    Adds a second y-axis to a :class:`TimeSeriesPlot`.
+    Adds a second y-axis to a :class:`Subplot`.
     This function can also be used as a method.
 
     Parameters
     ----------
-    fsp : {None, TimeSeriesPlot}
+    fsp : {None, Subplot}
         Subplot to which the secondary y-axis is added.
         If None, the current subplot is selected: in that case, it should be
-        a valid :class:`TimeSeriesPlot`.
-        When used as a :class:`TimeSeriesPlot` method, this parameter points
+        a valid :class:`Subplot`.
+        When used as a :class:`Subplot` method, this parameter points
         automatically to the calling subplot.
     position : {string}
         Position of the new axis, as either ``'left'`` or ``'right'``.
@@ -1092,18 +849,17 @@ def add_yaxis(fsp=None, position='right', yscale=None, basey=10, subsy=None):
     Raises
     ------
     TypeError
-        If the selected subplot is not a valid :class:`TimeSeriesPlot` object.
+        If the selected subplot is not a valid :class:`Subplot` object.
 
     """
     if fsp is None:
         fsp = pylab.gca()
-    if not isinstance(fsp, TimeSeriesPlot):
-        raise TypeError("The current plot is not a TimeSeriesPlot")
+
     fig = fsp.figure
     axisini = fsp.axis()
     fsp_alt_args = (fsp._rows, fsp._cols, fsp._num + 1)
-    fsp_alt = fig.add_tsplot(frameon=False, position=fsp.get_position(),
-                             sharex=fsp, *fsp_alt_args)
+    fsp_alt = fig.add_subplot(frameon=False, position=fsp.get_position(),
+                              sharex=fsp, *fsp_alt_args)
     # Set position ....................
     if position.lower() == 'right':
         (inipos, newpos) = ('left', 'right')
@@ -1127,139 +883,35 @@ def add_yaxis(fsp=None, position='right', yscale=None, basey=10, subsy=None):
     pylab.draw_if_interactive()
     return fsp_alt
 
-TimeSeriesPlot.add_yaxis = add_yaxis
-
-#####--------------------------------------------------------------------------
-#---- --- TimeSeries Figures ---
-#####--------------------------------------------------------------------------
-class TimeSeriesFigure(Figure):
+def set_dlim(subplot, start_date=None, end_date=None):
     """
-    Based on :class:`matplotlib.figure.Figure`
-
-    Create a new :class:`~matplotlib.figure.Figure` object.
-    All the subplots share the same time series.
-
-    The same parameters used for the creation of a standard
-    :class:`~matplotlib.figure.Figure` are accepted.
+    Sets the date limits of the plot to ``start_date`` and ``end_date``.
+    The dates can be given as :class:`~Period` objects, strings or
+    integers.
 
     Parameters
     ----------
-    series : {None, TimeSeries}, optional
-        Underlying time series.
-        All the subplots of the figure will share the same series.
-    figsize : {None, tuple}
-        Size of the figure, as a tuple (width, height) in inches.
-        If None, defaults to rc figure.figsize.
-    dpi : {None, int}, optional
-        Resolution in dots per inches.
-        If None, defaults to rc figure.dpi
-    facecolor : {None, string}, optional
-        Background color.
-        If None, defaults to rc figure.facecolor.
-    edgecolor : {None, string}, optional
-        Border color.
-        If None, defaults to rc figure.edgecolor.
-    linewidth : {float, None}
-        Width of the patch edge line.
-    frameon : {True, False}
-        Whether to draw the frame around the figure.
-
+    start_date : {var}
+        Starting date of the plot. If None, the current left limit
+        (earliest date) is used.
+    end_date : {var}
+        Ending date of the plot. If None, the current right limit (latest
+        date) is used.
     """
-    def __init__(self, **kwargs):
-        self._series = series = kwargs.pop('series', None)
-        Figure.__init__(self, **kwargs)
-        fspnum = kwargs.pop('fspnum', None)
-        if fspnum is not None:
-            self.add_tsplot(fspnum, series=series)
-    #.........
-    def add_tsplot(self, *args, **kwargs):
-        """
-        Adds a :class:`TimeSeriesPlot` subplot to the current figure.
-
-        Parameters
-        ----------
-        args : var
-            Mandatory arguments for the creation of the subplot.
-            These arguments should be given as ``nb_of_rows``,
-            ``nb_of_columns``, ``plot_number``, or as a single 3-digit number
-            if the 3 previous numbers are all lower than 10.
-        kwargs : var
-            Optional arguments, as recognized by `add_subplot`.
-        """
-        kwargs.update(SubplotClass=TimeSeriesPlot)
-        if self._series is not None:
-            kwargs.update(series=self._series)
-        return add_generic_subplot(self, *args, **kwargs)
-
-    add_subplot = add_tsplot
-
-TSFigure = TimeSeriesFigure
-
-#................................................
-def tsfigure(num=None, figsize=None, dpi=None, facecolor=None,
-             edgecolor=None, frameon=True, subplotpars=None,
-             FigureClass=TSFigure):
+    freq = getattr(subplot, 'freq', None)
+    if freq is None:
+        raise ValueError("Undefined frequency! Date limits can't be set!")
+    xleft = get_datevalue(start_date, freq)
+    xright = get_datevalue(end_date, freq)
+    subplot.set_xlim(xleft, xright)
+    return (xleft, xright)
+
+def get_dlim(subplot):
     """
-    Creates a new :class:`TimeSeriesFigure` object.
-
-    Parameters
-    ----------
-    num : {None, int}, optional
-        Number of the figure.
-        If None, a new figure is created and ``num`` is incremented.
-    %(figsize)s
-    %(dpi)s
-    %(facecolor)s
-    %(edgecolor)s
-    %(frameon)s
-    %(subplotpars)s
-    FigureClass : FigureClass
-        Class of the figure to create
-    """
-    figargs = dict(num=num, figsize=figsize, dpi=dpi, facecolor=facecolor,
-                   frameon=frameon, FigureClass=FigureClass,
-                   subplotpars=subplotpars)
-    fig = pylab.figure(**figargs)
-    return fig
-
-tsfigure.__doc__ %= _doc_parameters
-
-def tsplot(series=None, num=None, figsize=None, dpi=None,
-           facecolor=None, edgecolor=None, frameon=True, subplotpars=None,
-           FigureClass=TSFigure):
-    """
-    Creates a new :class:`TimeSeriesFigure` object and plots a series
-
-    Parameters
-    ----------
-    num : {None, int}, optional
-        Number of the figure.
-        If None, a new figure is created and ``num`` is incremented.
-    %(figsize)s
-    %(dpi)s
-    %(facecolor)s
-    %(edgecolor)s
-    %(frameon)s
-    %(subplotpars)s
-    FigureClass : FigureClass
-        Class of the figure to create
-
-    Parameters
-    ----------
-
+    Returns the limits of the x axis as a :class:`~PeriodIndex`.
     """
-    # deal with kwargs
-    fig = tsfigure(num=num, figsize=figsize, dpi=dpi,
-                facecolor=facecolor, edgecolor=edgecolor,
-                frameon=frameon, subplotpars=subplotpars,
-                FigureClass=FigureClass)
-
-    sub = fig.add_tsplot(111)
-    ret = sub.tsplot(series)
-
-    return ret
-
-tsplot.__doc__ %= _doc_parameters
-
-###############################################################################
-
+    freq = getattr(subplot, 'freq', None)
+    xlims = subplot.get_xlim()
+    if freq is None:
+        return xlims
+    return PeriodIndex(xlims, freq=freq)

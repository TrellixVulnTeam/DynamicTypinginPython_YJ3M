commit ca6adc6e73fe7f7624454d95de5114b99afb336c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Dec 11 23:28:51 2011 -0500

    ENH: DataFrame.from_items alternate constructor for sequence of (key, value) pairs, per #444

diff --git a/RELEASE.rst b/RELEASE.rst
index 8260914a1..63c6592da 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -85,6 +85,7 @@ pandas 0.6.1
   - Use Cython map_infer function in DataFrame.applymap to properly infer
     output type, handle tuple return values and other things that were breaking
     (GH #465)
+  - Handle floating point index values in HDFStore (GH #454)
 
 Thanks
 ------
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a92c4a186..4fad90c93 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -172,8 +172,15 @@ class DataFrame(NDFrame):
         >>> df2 = DataFrame(np.random.randn(10, 5))
         >>> df3 = DataFrame(np.random.randn(10, 5),
         ...                 columns=['a', 'b', 'c', 'd', 'e'])
-        """
 
+        See also
+        --------
+        DataFrame.from_records: constructor from tuples, also record arrays
+        DataFrame.from_dict: from dicts of Series, arrays, or dicts
+        DataFrame.from_csv: from CSV files
+        DataFrame.from_items: from sequence of (key, value) pairs
+        read_csv / read_table / read_clipboard
+        """
         if data is None:
             data = {}
 
@@ -580,6 +587,47 @@ class DataFrame(NDFrame):
 
         return np.rec.fromarrays(arrays, names=names)
 
+    @classmethod
+    def from_items(cls, items, columns=None, orient='columns'):
+        """
+        Convert (key, value) pairs to DataFrame. The keys will be the axis
+        index (usually the columns, but depends on the specified
+        orientation). The values should be arrays or Series
+
+        Parameters
+        ----------
+        items : sequence of (key, value) pairs
+            Values should be arrays or Series
+        columns : sequence, optional
+            Must be passed in the
+        orient : {'columns', 'index'}, default 'items'
+            The "orientation" of the data. If the keys of the passed dict
+            should be the items of the result panel, pass 'items'
+            (default). Otherwise if the columns of the values of the passed
+            DataFrame objects should be the items (which in the case of
+            mixed-dtype data you should do), instead pass 'minor'
+
+        Returns
+        -------
+        frame : DataFrame
+        """
+        keys, values = zip(*items)
+
+        if orient == 'columns':
+            cols_to_use = columns if columns is not None else keys
+            # iterable may have been consumed
+            return DataFrame(dict(zip(keys, values)), columns=cols_to_use)
+        elif orient == 'index':
+            if columns is None:
+                raise ValueError("Must pass columns with orient='index'")
+
+            arr = np.array(values, dtype=object).T
+            new_data = dict((k, lib.maybe_convert_objects(v))
+                            for k, v in zip(columns, arr))
+            return DataFrame(new_data, index=keys, columns=columns)
+        elif orient != 'columns':  # pragma: no cover
+            raise ValueError('only recognize index or columns for orient')
+
     @classmethod
     def from_csv(cls, path, header=0, sep=',', index_col=0,
                  parse_dates=True):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index d39932cbd..d594c39de 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -24,6 +24,7 @@ from pandas.util.testing import (assert_almost_equal,
                                  assert_frame_equal)
 
 import pandas.util.testing as tm
+import pandas._tseries as lib
 
 #-------------------------------------------------------------------------------
 # DataFrame test cases
@@ -1270,6 +1271,41 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assert_(np.array_equal(result.index, index))
         self.assert_(np.array_equal(result.columns, columns))
 
+    def test_constructor_from_items(self):
+        items = [(c, self.frame[c]) for c in self.frame.columns]
+        recons = DataFrame.from_items(items)
+        assert_frame_equal(recons, self.frame)
+
+        # pass some columns
+        recons = DataFrame.from_items(items, columns=['C', 'B', 'A'])
+        assert_frame_equal(recons, self.frame.ix[:, ['C', 'B', 'A']])
+
+        # orient='index'
+
+        row_items = [(idx, self.mixed_frame.xs(idx))
+                     for idx in self.mixed_frame.index]
+
+        recons = DataFrame.from_items(row_items,
+                                      columns=self.mixed_frame.columns,
+                                      orient='index')
+        assert_frame_equal(recons, self.mixed_frame)
+        self.assert_(recons['A'].dtype == np.float64)
+
+        self.assertRaises(ValueError, DataFrame.from_items, row_items,
+                          orient='index')
+
+        # orient='index', but thar be tuples
+        arr = lib.list_to_object_array([('bar', 'baz')] * len(self.mixed_frame))
+        self.mixed_frame['foo'] = arr
+        row_items = [(idx, list(self.mixed_frame.xs(idx)))
+                     for idx in self.mixed_frame.index]
+        recons = DataFrame.from_items(row_items,
+                                      columns=self.mixed_frame.columns,
+                                      orient='index')
+        foo
+        assert_frame_equal(recons, self.mixed_frame)
+        self.assert_(isinstance(recons['foo'][0], tuple))
+
     def test_astype(self):
         casted = self.frame.astype(int)
         expected = DataFrame(self.frame.values.astype(int),

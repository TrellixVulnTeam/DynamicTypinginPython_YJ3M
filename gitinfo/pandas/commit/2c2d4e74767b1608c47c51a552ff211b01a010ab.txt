commit 2c2d4e74767b1608c47c51a552ff211b01a010ab
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Fri Aug 14 22:14:11 2015 +0200

    DEPR/TST: correct stacklevels (GH9584)
    
    Only check stacklevel for FutureWarnings/DeprecationWarnings for now

diff --git a/pandas/computation/align.py b/pandas/computation/align.py
index 9834dd1a9..b5f730378 100644
--- a/pandas/computation/align.py
+++ b/pandas/computation/align.py
@@ -101,7 +101,8 @@ def _align_core(terms):
                                   'than an order of magnitude on term {1!r}, '
                                   'by more than {2:.4g}; performance may '
                                   'suffer'.format(axis, terms[i].name, ordm),
-                                  category=pd.io.common.PerformanceWarning)
+                                  category=pd.io.common.PerformanceWarning,
+                                  stacklevel=6)
 
                 if transpose:
                     f = partial(ti.reindex, index=reindexer, copy=False)
diff --git a/pandas/computation/pytables.py b/pandas/computation/pytables.py
index 4290be3e1..bc4e60f70 100644
--- a/pandas/computation/pytables.py
+++ b/pandas/computation/pytables.py
@@ -535,7 +535,7 @@ class Expr(expr.Expr):
                 w, op, value = w
             warnings.warn("passing a tuple into Expr is deprecated, "
                           "pass the where as a single string",
-                          DeprecationWarning)
+                          DeprecationWarning, stacklevel=10)
 
         if op is not None:
             if not isinstance(w, string_types):
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 4a6a26f21..2f465ded1 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -414,7 +414,7 @@ class Categorical(PandasObject):
 
         Deprecated, use .codes!
         """
-        warn("'labels' is deprecated. Use 'codes' instead", FutureWarning, stacklevel=3)
+        warn("'labels' is deprecated. Use 'codes' instead", FutureWarning, stacklevel=2)
         return self.codes
 
     labels = property(fget=_get_labels, fset=_set_codes)
@@ -456,7 +456,7 @@ class Categorical(PandasObject):
                 # NaNs in cats deprecated in 0.17, remove in 0.18 or 0.19 GH 10748
                 msg = ('\nSetting NaNs in `categories` is deprecated and '
                        'will be removed in a future version of pandas.')
-                warn(msg, FutureWarning, stacklevel=5)
+                warn(msg, FutureWarning, stacklevel=3)
 
             # categories must be unique
 
@@ -491,12 +491,12 @@ class Categorical(PandasObject):
 
     def _set_levels(self, levels):
         """ set new levels (deprecated, use "categories") """
-        warn("Assigning to 'levels' is deprecated, use 'categories'", FutureWarning, stacklevel=3)
+        warn("Assigning to 'levels' is deprecated, use 'categories'", FutureWarning, stacklevel=2)
         self.categories = levels
 
     def _get_levels(self):
         """ Gets the levels (deprecated, use "categories") """
-        warn("Accessing 'levels' is deprecated, use 'categories'", FutureWarning, stacklevel=3)
+        warn("Accessing 'levels' is deprecated, use 'categories'", FutureWarning, stacklevel=2)
         return self.categories
 
     # TODO: Remove after deprecation period in 2017/ after 0.18
@@ -507,7 +507,7 @@ class Categorical(PandasObject):
     def _set_ordered(self, value):
         """ Sets the ordered attribute to the boolean value """
         warn("Setting 'ordered' directly is deprecated, use 'set_ordered'", FutureWarning,
-             stacklevel=3)
+             stacklevel=2)
         self.set_ordered(value, inplace=True)
 
     def set_ordered(self, value, inplace=False):
@@ -1200,7 +1200,7 @@ class Categorical(PandasObject):
         Category.sort
         """
         warn("order is deprecated, use sort_values(...)",
-             FutureWarning, stacklevel=3)
+             FutureWarning, stacklevel=2)
         return self.sort_values(inplace=inplace, ascending=ascending, na_position=na_position)
 
     def sort(self, inplace=True, ascending=True, na_position='last'):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3394d814d..c5c0f9e82 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2919,7 +2919,7 @@ class DataFrame(NDFrame):
             return result
 
     @deprecate_kwarg('take_last', 'keep', mapping={True: 'last', False: 'first'})
-    @deprecate_kwarg(old_arg_name='cols', new_arg_name='subset')
+    @deprecate_kwarg(old_arg_name='cols', new_arg_name='subset', stacklevel=3)
     def drop_duplicates(self, subset=None, keep='first', inplace=False):
         """
         Return DataFrame with duplicate rows removed, optionally only
@@ -2953,7 +2953,7 @@ class DataFrame(NDFrame):
             return self[-duplicated]
 
     @deprecate_kwarg('take_last', 'keep', mapping={True: 'last', False: 'first'})
-    @deprecate_kwarg(old_arg_name='cols', new_arg_name='subset')
+    @deprecate_kwarg(old_arg_name='cols', new_arg_name='subset', stacklevel=3)
     def duplicated(self, subset=None, keep='first'):
         """
         Return boolean Series denoting duplicate rows, optionally only
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 966ea94b3..d3a63f9f5 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -706,7 +706,7 @@ class NDFrame(PandasObject):
         "iteritems alias used to get around 2to3. Deprecated"
         warnings.warn("iterkv is deprecated and will be removed in a future "
                       "release, use ``iteritems`` instead.",
-                      FutureWarning)
+                      FutureWarning, stacklevel=2)
         return self.iteritems(*args, **kwargs)
 
     def __len__(self):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index a7674771e..14ba2dea0 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -842,14 +842,14 @@ class Index(IndexOpsMixin, PandasObject):
             elif is_float(key):
                 key = to_int()
                 warnings.warn("scalar indexers for index type {0} should be integers and not floating point".format(
-                    type(self).__name__),FutureWarning, stacklevel=2)
+                    type(self).__name__), FutureWarning, stacklevel=5)
                 return key
             return self._invalid_indexer('label', key)
 
         if is_float(key):
             if not self.is_floating():
                 warnings.warn("scalar indexers for index type {0} should be integers and not floating point".format(
-                    type(self).__name__),FutureWarning, stacklevel=2)
+                    type(self).__name__), FutureWarning, stacklevel=3)
             return to_int()
 
         return key
@@ -887,7 +887,7 @@ class Index(IndexOpsMixin, PandasObject):
                 # warn if it's a convertible float
                 if v == int(v):
                     warnings.warn("slice indexers when using iloc should be integers "
-                                  "and not floating point",FutureWarning, stacklevel=2)
+                                  "and not floating point", FutureWarning, stacklevel=7)
                     return int(v)
 
                 self._invalid_indexer('slice {0} value'.format(c), v)
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index 7837fb60d..dddc1f489 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -204,7 +204,7 @@ def str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):
 
         if regex.groups > 0:
             warnings.warn("This pattern has match groups. To actually get the"
-                          " groups, use str.extract.", UserWarning)
+                          " groups, use str.extract.", UserWarning, stacklevel=3)
 
         f = lambda x: bool(regex.search(x))
     else:
@@ -377,11 +377,12 @@ def str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=False):
         # Do this first, to make sure it happens even if the re.compile
         # raises below.
         warnings.warn("In future versions of pandas, match will change to"
-                      " always return a bool indexer.", UserWarning)
+                      " always return a bool indexer.", FutureWarning,
+                      stacklevel=3)
 
     if as_indexer and regex.groups > 0:
         warnings.warn("This pattern has match groups. To actually get the"
-                      " groups, use str.extract.", UserWarning)
+                      " groups, use str.extract.", UserWarning, stacklevel=3)
 
     # If not as_indexer and regex.groups == 0, this returns empty lists
     # and is basically useless, so we will not warn.
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 6801e8935..f0c994ba1 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -647,7 +647,7 @@ class TextFileReader(object):
             warnings.warn(("Falling back to the 'python' engine because"
                            " {0}; you can avoid this warning by specifying"
                            " engine='python'.").format(fallback_reason),
-                          ParserWarning)
+                          ParserWarning, stacklevel=5)
 
         index_col = options['index_col']
         names = options['names']
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index ea0a59ce2..b5a3577b3 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -1596,7 +1596,7 @@ class IndexCol(StringMixin):
                 # frequency/name just warn
                 if key in ['freq', 'index_name']:
                     ws = attribute_conflict_doc % (key, existing_value, value)
-                    warnings.warn(ws, AttributeConflictWarning)
+                    warnings.warn(ws, AttributeConflictWarning, stacklevel=6)
 
                     # reset
                     idx[key] = None
@@ -2581,7 +2581,7 @@ class GenericFixed(Fixed):
                 except:
                     pass
                 ws = performance_doc % (inferred_type, key, items)
-                warnings.warn(ws, PerformanceWarning)
+                warnings.warn(ws, PerformanceWarning, stacklevel=7)
 
             vlarr = self._handle.create_vlarray(self.group, key,
                                                _tables().ObjectAtom())
@@ -3716,7 +3716,7 @@ class LegacyTable(Table):
                 objs.append(obj)
 
         else:
-            warnings.warn(duplicate_doc, DuplicateWarning)
+            warnings.warn(duplicate_doc, DuplicateWarning, stacklevel=5)
 
             # reconstruct
             long_index = MultiIndex.from_arrays(
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 7cc5ea142..c0b69e435 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -328,7 +328,7 @@ def read_sql_table(table_name, con, schema=None, index_col=None,
     read_sql
 
     """
-    
+
     con = _engine_builder(con)
     if not _is_sqlalchemy_connectable(con):
         raise NotImplementedError("read_sql_table only supported for "
@@ -364,7 +364,7 @@ def read_sql_query(sql, con, index_col=None, coerce_float=True, params=None,
     ----------
     sql : string
         SQL query to be executed
-    con : SQLAlchemy connectable(engine/connection) or database string URI 
+    con : SQLAlchemy connectable(engine/connection) or database string URI
         or sqlite3 DBAPI2 connection
         Using SQLAlchemy makes it possible to use any DB supported by that
         library.
@@ -618,7 +618,7 @@ def pandasSQL_builder(con, flavor=None, schema=None, meta=None,
         return SQLDatabase(con, schema=schema, meta=meta)
     else:
         if flavor == 'mysql':
-            warnings.warn(_MYSQL_WARNING, FutureWarning, stacklevel=2)
+            warnings.warn(_MYSQL_WARNING, FutureWarning, stacklevel=3)
         return SQLiteDatabase(con, flavor, is_cursor=is_cursor)
 
 
@@ -957,7 +957,7 @@ class SQLTable(PandasObject):
         if col_type == 'timedelta64':
             warnings.warn("the 'timedelta' type is not supported, and will be "
                           "written as integer values (ns frequency) to the "
-                          "database.", UserWarning)
+                          "database.", UserWarning, stacklevel=8)
             return BigInteger
         elif col_type == 'floating':
             if col.dtype == 'float32':
@@ -1409,7 +1409,7 @@ class SQLiteTable(SQLTable):
         pat = re.compile('\s+')
         column_names = [col_name for col_name, _, _ in column_names_and_types]
         if any(map(pat.search, column_names)):
-            warnings.warn(_SAFE_NAMES_WARNING)
+            warnings.warn(_SAFE_NAMES_WARNING, stacklevel=6)
 
         flv = self.pd_sql.flavor
         escape = _SQL_GET_IDENTIFIER[flv]
@@ -1450,7 +1450,7 @@ class SQLiteTable(SQLTable):
         if col_type == 'timedelta64':
             warnings.warn("the 'timedelta' type is not supported, and will be "
                           "written as integer values (ns frequency) to the "
-                          "database.", UserWarning)
+                          "database.", UserWarning, stacklevel=8)
             col_type = "integer"
 
         elif col_type == "datetime64":
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index b4f1e6a42..0fb323715 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -122,7 +122,7 @@ def _maybe_remove(store, key):
         pass
 
 
-def compat_assert_produces_warning(w,f):
+def compat_assert_produces_warning(w, f):
     """ don't produce a warning under PY3 """
     if compat.PY3:
         f()
@@ -2516,7 +2516,8 @@ class TestHDFStore(Base):
                 [ "minor_axis=['A','B']", dict(field='major_axis', op='>', value='20121114') ]
                 ]
             for t in terms:
-                with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+                with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                                check_stacklevel=False):
                     Term(t)
 
             # valid terms
@@ -2609,7 +2610,8 @@ class TestHDFStore(Base):
                        major_axis=date_range('1/1/2000', periods=5),
                        minor_axis=['A', 'B', 'C', 'D'])
             store.append('wp',wp)
-            with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+            with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                            check_stacklevel=not compat.PY3):
                 result = store.select('wp', [('major_axis>20000102'),
                                              ('minor_axis', '=', ['A','B']) ])
             expected = wp.loc[:,wp.major_axis>Timestamp('20000102'),['A','B']]
@@ -2628,20 +2630,24 @@ class TestHDFStore(Base):
             store.append('wp',wp)
 
             # stringified datetimes
-            with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+            with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                            check_stacklevel=not compat.PY3):
                 result = store.select('wp', [('major_axis','>',datetime.datetime(2000,1,2))])
             expected = wp.loc[:,wp.major_axis>Timestamp('20000102')]
             assert_panel_equal(result, expected)
-            with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+            with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                            check_stacklevel=not compat.PY3):
                 result = store.select('wp', [('major_axis','>',datetime.datetime(2000,1,2,0,0))])
             expected = wp.loc[:,wp.major_axis>Timestamp('20000102')]
             assert_panel_equal(result, expected)
-            with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+            with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                            check_stacklevel=not compat.PY3):
                 result = store.select('wp', [('major_axis','=',[datetime.datetime(2000,1,2,0,0),
                                                                 datetime.datetime(2000,1,3,0,0)])])
             expected = wp.loc[:,[Timestamp('20000102'),Timestamp('20000103')]]
             assert_panel_equal(result, expected)
-            with tm.assert_produces_warning(expected_warning=DeprecationWarning):
+            with tm.assert_produces_warning(expected_warning=DeprecationWarning,
+                                            check_stacklevel=not compat.PY3):
                 result = store.select('wp', [('minor_axis','=',['A','B'])])
             expected = wp.loc[:,:,['A','B']]
             assert_panel_equal(result, expected)
@@ -4528,7 +4534,7 @@ class TestHDFStore(Base):
             s = Series(np.random.randn(len(unicode_values)), unicode_values)
             self._check_roundtrip(s, tm.assert_series_equal)
 
-        compat_assert_produces_warning(PerformanceWarning,f)
+        compat_assert_produces_warning(PerformanceWarning, f)
 
     def test_store_datetime_mixed(self):
 
diff --git a/pandas/parser.pyx b/pandas/parser.pyx
index 5baef2e4f..c2916f2c0 100644
--- a/pandas/parser.pyx
+++ b/pandas/parser.pyx
@@ -1838,7 +1838,7 @@ def _concatenate_chunks(list chunks):
         warning_message = " ".join(["Columns (%s) have mixed types." % warning_names,
             "Specify dtype option on import or set low_memory=False."
           ])
-        warnings.warn(warning_message, DtypeWarning)
+        warnings.warn(warning_message, DtypeWarning, stacklevel=8)
     return result
 
 #----------------------------------------------------------------------
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index d847638ff..f687ecbef 100755
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -1590,7 +1590,7 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         # Changing categories should also make the replaced category np.nan
         s3 = Series(Categorical(["a","b","c","a"]))
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             s3.cat.categories = ["a","b",np.nan]
         self.assert_numpy_array_equal(s3.cat.categories,
                                       np.array(["a","b",np.nan], dtype=np.object_))
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index 19fd45cdf..3bd76dfb9 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -382,32 +382,32 @@ class TestExpressions(tm.TestCase):
             fe = getattr(operator, sub_funcs[subs[op]])
 
             with tm.use_numexpr(True, min_elements=5):
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(df, df)
                     e = fe(df, df)
                     tm.assert_frame_equal(r, e)
 
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(df.a, df.b)
                     e = fe(df.a, df.b)
                     tm.assert_series_equal(r, e)
 
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(df.a, True)
                     e = fe(df.a, True)
                     tm.assert_series_equal(r, e)
 
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(False, df.a)
                     e = fe(False, df.a)
                     tm.assert_series_equal(r, e)
 
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(False, df)
                     e = fe(False, df)
                     tm.assert_frame_equal(r, e)
 
-                with tm.assert_produces_warning():
+                with tm.assert_produces_warning(check_stacklevel=False):
                     r = f(df, True)
                     e = fe(df, True)
                     tm.assert_frame_equal(r, e)
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index 7877ee3c5..6c92bb709 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -2734,7 +2734,7 @@ $1$,$2$
         non_int_round_dict = {'col1': 1, 'col2': 0.5}
         if sys.version < LooseVersion('2.7'):
             # np.round([1.123, 2.123], 0.5) is only a warning in Python 2.6
-            with self.assert_produces_warning(DeprecationWarning):
+            with self.assert_produces_warning(DeprecationWarning, check_stacklevel=False):
                 df.round(non_int_round_dict)
         else:
             with self.assertRaises(TypeError):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 659a5925b..aea165b90 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1440,7 +1440,8 @@ class CheckIndexing(object):
         df = DataFrame(np.random.randn(5, 5), index=index)
 
         # positional slicing only via iloc!
-        with tm.assert_produces_warning(FutureWarning):
+        # stacklevel=False -> needed stacklevel depends on index type
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             result = df.iloc[1.0:5]
 
         expected = df.reindex([2.5, 3.5, 4.5, 5.0])
diff --git a/pandas/tests/test_graphics_others.py b/pandas/tests/test_graphics_others.py
index f461a8ab6..641180c80 100644
--- a/pandas/tests/test_graphics_others.py
+++ b/pandas/tests/test_graphics_others.py
@@ -677,7 +677,7 @@ class TestDataFrameGroupByPlots(TestPlotBase):
                                     expected_keys=['height', 'weight', 'category'])
 
         # now for groupby
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             result = df.groupby('gender').boxplot()
         self._check_box_return_type(result, 'dict', expected_keys=['Male', 'Female'])
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 30a571683..9b2c1bf1a 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -1884,7 +1884,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
         self.assertFalse(0 in ci)
         self.assertFalse(1 in ci)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             ci = CategoricalIndex(list('aabbca'), categories=list('cabdef') + [np.nan])
         self.assertFalse(np.nan in ci)
 
@@ -2101,7 +2101,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
         # tests
         # make sure that we are testing for category inclusion properly
         self.assertTrue(CategoricalIndex(list('aabca'),categories=['c','a','b']).equals(list('aabca')))
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assertTrue(CategoricalIndex(list('aabca'),categories=['c','a','b',np.nan]).equals(list('aabca')))
 
         self.assertFalse(CategoricalIndex(list('aabca') + [np.nan],categories=['c','a','b']).equals(list('aabca')))
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 6a9d4096a..c48807365 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -4180,11 +4180,16 @@ Region_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No"""
 
         def check_iloc_compat(s):
             # invalid type for iloc (but works with a warning)
-            with self.assert_produces_warning(FutureWarning):
+            # check_stacklevel=False -> impossible to get it right for all
+            # index types
+            with self.assert_produces_warning(
+                    FutureWarning, check_stacklevel=False):
                 s.iloc[6.0:8]
-            with self.assert_produces_warning(FutureWarning):
+            with self.assert_produces_warning(
+                    FutureWarning, check_stacklevel=False):
                 s.iloc[6.0:8.0]
-            with self.assert_produces_warning(FutureWarning):
+            with self.assert_produces_warning(
+                    FutureWarning, check_stacklevel=False):
                 s.iloc[6:8.0]
 
         def check_slicing_positional(index):
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index 7886a63c6..31623d5c2 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -1896,10 +1896,8 @@ class TestStringMethods(tm.TestCase):
 
         pat = pattern = r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,4})'
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning(FutureWarning):
             result = data.str.match(pat, flags=re.IGNORECASE)
-            assert issubclass(w[-1].category, UserWarning)
         self.assertEqual(result[0], ('dave', 'google', 'com'))
 
         result = data.str.findall(pat, flags=re.IGNORECASE)
@@ -1908,10 +1906,8 @@ class TestStringMethods(tm.TestCase):
         result = data.str.count(pat, flags=re.IGNORECASE)
         self.assertEqual(result[0], 1)
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning(UserWarning):
             result = data.str.contains(pat, flags=re.IGNORECASE)
-            assert issubclass(w[-1].category, UserWarning)
         self.assertEqual(result[0], True)
 
     def test_encode_decode(self):
diff --git a/pandas/tests/test_testing.py b/pandas/tests/test_testing.py
index 466ad3f22..2b5443e6f 100644
--- a/pandas/tests/test_testing.py
+++ b/pandas/tests/test_testing.py
@@ -597,22 +597,22 @@ class TestDeprecatedTests(tm.TestCase):
 
     def test_warning(self):
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assertEquals(1, 1)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assertNotEquals(1, 2)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assert_(True)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assertAlmostEquals(1.0, 1.0000000001)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.assertNotAlmostEquals(1, 2)
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             tm.assert_isinstance(Series([1, 2]), Series, msg='xxx')
 
 
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 3c3c20e2c..e0d13287f 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -592,7 +592,7 @@ def bootstrap_plot(series, fig=None, size=50, samples=500, **kwds):
     return fig
 
 @deprecate_kwarg(old_arg_name='colors', new_arg_name='color')
-@deprecate_kwarg(old_arg_name='data', new_arg_name='frame')
+@deprecate_kwarg(old_arg_name='data', new_arg_name='frame', stacklevel=3)
 def parallel_coordinates(frame, class_column, cols=None, ax=None, color=None,
                          use_columns=False, xticks=None, colormap=None,
                          axvlines=True, **kwds):
@@ -2624,7 +2624,7 @@ def boxplot(data, column=None, by=None, ax=None, fontsize=None,
                    "now, set return_type='axes'.\n To keep the previous "
                    "behavior and silence this warning, set "
                    "return_type='dict'.")
-            warnings.warn(msg, FutureWarning, stacklevel=2)
+            warnings.warn(msg, FutureWarning, stacklevel=3)
             return_type = 'dict'
         if ax is None:
             ax = _gca()
@@ -2972,7 +2972,7 @@ def _grouped_plot(plotf, data, column=None, by=None, numeric_only=True,
     if figsize == 'default':
         # allowed to specify mpl default with 'default'
         warnings.warn("figsize='default' is deprecated. Specify figure"
-                      "size by tuple instead", FutureWarning, stacklevel=2)
+                      "size by tuple instead", FutureWarning, stacklevel=4)
         figsize = None
 
     grouped = data.groupby(by)
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 9349e440e..e471e6661 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -525,12 +525,12 @@ def get_offset(name):
         if name in _rule_aliases:
             new = _rule_aliases[name]
             warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning)
+                          FutureWarning, stacklevel=2)
             name = new
         elif name.lower() in _rule_aliases:
             new = _rule_aliases[name.lower()]
             warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning)
+                          FutureWarning, stacklevel=2)
             name = new
 
         name = _lite_rule_alias.get(name, name)
@@ -540,7 +540,7 @@ def get_offset(name):
         if name in _rule_aliases:
             new = _rule_aliases[name]
             warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning)
+                          FutureWarning, stacklevel=2)
             name = new
         name = _lite_rule_alias.get(name, name)
 
@@ -784,7 +784,7 @@ def _period_str_to_code(freqstr):
     if freqstr in _rule_aliases:
         new = _rule_aliases[freqstr]
         warnings.warn(_LEGACY_FREQ_WARNING.format(freqstr, new),
-                      FutureWarning)
+                      FutureWarning, stacklevel=6)
         freqstr = new
     freqstr = _lite_rule_alias.get(freqstr, freqstr)
 
@@ -793,7 +793,7 @@ def _period_str_to_code(freqstr):
         if lower in _rule_aliases:
             new = _rule_aliases[lower]
             warnings.warn(_LEGACY_FREQ_WARNING.format(lower, new),
-                          FutureWarning)
+                          FutureWarning, stacklevel=6)
             freqstr = new
         freqstr = _lite_rule_alias.get(lower, freqstr)
 
@@ -805,7 +805,7 @@ def _period_str_to_code(freqstr):
         try:
             alias = _period_alias_dict[freqstr]
             warnings.warn(_LEGACY_FREQ_WARNING.format(freqstr, alias),
-                          FutureWarning)
+                          FutureWarning, stacklevel=3)
         except KeyError:
             raise ValueError("Unknown freqstr: %s" % freqstr)
 
diff --git a/pandas/tseries/tests/test_frequencies.py b/pandas/tseries/tests/test_frequencies.py
index b783459cb..a642c1278 100644
--- a/pandas/tseries/tests/test_frequencies.py
+++ b/pandas/tseries/tests/test_frequencies.py
@@ -589,7 +589,7 @@ class TestFrequencyInference(tm.TestCase):
             s = Series(period_range('2013',periods=10,freq=freq))
             self.assertRaises(TypeError, lambda : frequencies.infer_freq(s))
         for freq in ['Y']:
-            with tm.assert_produces_warning(FutureWarning):
+            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
                 s = Series(period_range('2013',periods=10,freq=freq))
             self.assertRaises(TypeError, lambda : frequencies.infer_freq(s))
 
@@ -610,7 +610,7 @@ class TestFrequencyInference(tm.TestCase):
             exp = frequencies.get_offset(v)
             self.assertEqual(result, exp)
 
-            with tm.assert_produces_warning(FutureWarning):
+            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
                 idx = date_range('2011-01-01', periods=5, freq=k)
             exp = date_range('2011-01-01', periods=5, freq=v)
             self.assert_index_equal(idx, exp)
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index b3ec88f4d..fada4a966 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -3670,14 +3670,14 @@ def test_get_standard_freq():
     assert fstr == get_standard_freq('1w')
     assert fstr == get_standard_freq(('W', 1))
 
-    with tm.assert_produces_warning(FutureWarning):
+    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
         result = get_standard_freq('WeEk')
     assert fstr == result
 
     fstr = get_standard_freq('5Q')
     assert fstr == get_standard_freq('5q')
 
-    with tm.assert_produces_warning(FutureWarning):
+    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
         result = get_standard_freq('5QuarTer')
     assert fstr == result
 
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index c828d6d7e..4b5d5dfed 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -2715,7 +2715,7 @@ class TestPeriodIndex(tm.TestCase):
             prng = rng.to_period()
             self.assertEqual(prng.freq, 'M')
 
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             rng = date_range('01-Jan-2012', periods=8, freq='EOM')
         prng = rng.to_period()
         self.assertEqual(prng.freq, 'M')
diff --git a/pandas/util/decorators.py b/pandas/util/decorators.py
index ab4785c75..49806491e 100644
--- a/pandas/util/decorators.py
+++ b/pandas/util/decorators.py
@@ -15,7 +15,7 @@ def deprecate(name, alternative, alt_name=None):
     return wrapper
 
 
-def deprecate_kwarg(old_arg_name, new_arg_name, mapping=None):
+def deprecate_kwarg(old_arg_name, new_arg_name, mapping=None, stacklevel=2):
     """Decorator to deprecate a keyword argument of a function
 
     Parameters
@@ -79,7 +79,7 @@ def deprecate_kwarg(old_arg_name, new_arg_name, mapping=None):
                     msg = "the '%s' keyword is deprecated, " \
                           "use '%s' instead" % (old_arg_name, new_arg_name)
 
-                warnings.warn(msg, FutureWarning, stacklevel=2)
+                warnings.warn(msg, FutureWarning, stacklevel=stacklevel)
                 if kwargs.get(new_arg_name, None) is not None:
                     msg = "Can only specify '%s' or '%s', not both" % \
                       (old_arg_name, new_arg_name)
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 2fabdf745..a195455c1 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -1968,7 +1968,8 @@ def assert_produces_warning(expected_warning=Warning, filter_level="always",
                                                 expected_warning)):
                 saw_warning = True
 
-                if check_stacklevel:
+                if check_stacklevel and issubclass(actual_warning.category,
+                                                   (FutureWarning, DeprecationWarning)):
                     from inspect import getframeinfo, stack
                     caller = getframeinfo(stack()[2][0])
                     msg = ("Warning not set with correct stacklevel. File were warning"

commit b061f02b52aacfa410949076d7a61dc6630d4f91
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat May 5 18:00:38 2012 -0400

    TST: vbench for #1152, some work on improving performance of asfreq

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 3a0860b97..5860daf3c 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1212,7 +1212,7 @@ cdef inline int64_t ts_dayofweek(_TSObject ts):
 # Period logic
 #----------------------------------------------------------------------
 
-cdef int64_t apply_mult(int64_t period_ord, int64_t mult):
+cdef inline int64_t apply_mult(int64_t period_ord, int64_t mult):
     """
     Get base+multiple ordinal value from corresponding base-only ordinal value.
     For example, 5min ordinal will be 1/5th the 1min ordinal (rounding down to
@@ -1223,7 +1223,7 @@ cdef int64_t apply_mult(int64_t period_ord, int64_t mult):
 
     return (period_ord - 1) // mult
 
-cdef int64_t remove_mult(int64_t period_ord_w_mult, int64_t mult):
+cdef inline int64_t remove_mult(int64_t period_ord_w_mult, int64_t mult):
     """
     Get base-only ordinal value from corresponding base+multiple ordinal.
     """
@@ -1271,8 +1271,11 @@ def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int base, int64_t mult):
 
     return out
 
+cdef char START = 'S'
+cdef char END = 'E'
+
 cpdef int64_t period_asfreq(int64_t period_ordinal, int base1, int64_t mult1,
-                           int base2, int64_t mult2, object relation=b'E'):
+                            int base2, int64_t mult2, bint end):
     """
     Convert period ordinal from one frequency to another, and if upsampling,
     choose to use start ('S') or end ('E') of period.
@@ -1280,37 +1283,35 @@ cpdef int64_t period_asfreq(int64_t period_ordinal, int base1, int64_t mult1,
     cdef:
         int64_t retval
 
-    if relation not in (b'S', b'E'):
-        raise ValueError('relation argument must be one of S or E')
-
     period_ordinal = remove_mult(period_ordinal, mult1)
 
-    if mult1 != 1 and relation == b'E':
+    if mult1 != 1 and end:
         period_ordinal += (mult1 - 1)
 
-    retval = asfreq(period_ordinal, base1, base2, (<char*>relation)[0])
+    if end:
+        retval = asfreq(period_ordinal, base1, base2, END)
+    else:
+        retval = asfreq(period_ordinal, base1, base2, START)
     retval = apply_mult(retval, mult2)
 
     return retval
 
-def period_asfreq_arr(ndarray[int64_t] arr, int base1, int64_t mult1, int base2,
-                        int64_t mult2, object relation=b'E'):
+def period_asfreq_arr(ndarray[int64_t] arr, int base1, int64_t mult1,
+                      int base2, int64_t mult2, bint end):
     """
-    Convert int64-array of period ordinals from one frequency to another, and if
-    upsampling, choose to use start ('S') or end ('E') of period.
+    Convert int64-array of period ordinals from one frequency to another, and
+    if upsampling, choose to use start ('S') or end ('E') of period.
     """
     cdef:
         ndarray[int64_t] new_arr
         Py_ssize_t i, sz
 
-    if relation not in (b'S', b'E'):
-        raise ValueError('relation argument must be one of S or E')
-
     sz = len(arr)
     new_arr = np.empty(sz, dtype=np.int64)
 
     for i in range(sz):
-        new_arr[i] = period_asfreq(arr[i], base1, mult1, base2, mult2, relation)
+        new_arr[i] = period_asfreq(arr[i], base1, mult1,
+                                   base2, mult2, end)
 
     return new_arr
 
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 3d49fd691..3556a231e 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -213,8 +213,12 @@ class Period(object):
         base1, mult1 = _gfc(self.freq)
         base2, mult2 = _gfc(freq)
 
+        if how not in ('S', 'E'):
+            raise ValueError('relation argument must be one of S or E')
+
+        end = how == 'E'
         new_ordinal = lib.period_asfreq(self.ordinal, base1, mult1,
-                                        base2, mult2, py3compat.str_to_bytes(how))
+                                        base2, mult2, end)
 
         return Period(ordinal=new_ordinal, freq=(base2, mult2))
 
@@ -556,9 +560,8 @@ class PeriodIndex(Int64Index):
                 else:
                     base1, mult1 = _gfc(data.freq)
                     base2, mult2 = _gfc(freq)
-                    how = py3compat.str_to_bytes('E')
                     data = lib.period_asfreq_arr(data.values, base1, mult1,
-                                                 base2, mult2, how)
+                                                 base2, mult2, 1)
             else:
                 if freq is None and len(data) > 0:
                     freq = getattr(data[0], 'freq')
@@ -611,9 +614,12 @@ class PeriodIndex(Int64Index):
         else:
             base2, mult2 = freq
 
+        if how not in ('S', 'E'):
+            raise ValueError('relation argument must be one of S or E')
+
+        end = how == 'E'
         new_data = lib.period_asfreq_arr(self.values, base1, mult1,
-                                         base2, mult2,
-                                         py3compat.str_to_bytes(how))
+                                         base2, mult2, end)
 
         return PeriodIndex(new_data, freq=freq)
 
diff --git a/vb_suite/timeseries.py b/vb_suite/timeseries.py
index 8ae22c97a..773ee0b74 100644
--- a/vb_suite/timeseries.py
+++ b/vb_suite/timeseries.py
@@ -93,3 +93,24 @@ rng = date_range('1/1/2000', '3/1/2000', tz='US/Eastern')
 
 timeseries_timestamp_tzinfo_cons = \
     Benchmark('rng[0]', setup, start_date=datetime(2012, 5, 5))
+
+#----------------------------------------------------------------------
+# Resampling period
+
+setup = common_setup + """
+rng = period_range('1/1/2000', '1/1/2001', freq='T')
+ts = Series(np.random.randn(len(rng)), index=rng)
+"""
+
+timeseries_period_resample_mean = \
+    Benchmark("ts.resample('D', how='mean')", setup,
+              start_date=datetime(2012, 4, 25))
+
+setup = common_setup + """
+rng = date_range('1/1/2000', '1/1/2001', freq='T')
+ts = Series(np.random.randn(len(rng)), index=rng)
+"""
+
+timeseries_timestamp_resample_mean = \
+    Benchmark("ts.resample('D', how='mean')", setup,
+              start_date=datetime(2012, 4, 25))

commit c2cc68d6eb233bc74c6bd032650704030c4b9a9d
Author: sinhrks <sinhrks@gmail.com>
Date:   Sun Jul 10 18:02:26 2016 -0400

    BUG: Block/DTI doesnt handle tzlocal properly
    
    Author: sinhrks <sinhrks@gmail.com>
    
    Closes #13583 from sinhrks/tzlocal and squashes the following commits:
    
    93f59a3 [sinhrks] BUG: DTI doesnt handle tzlocal properly

diff --git a/doc/source/whatsnew/v0.19.0.txt b/doc/source/whatsnew/v0.19.0.txt
index 3e0500338..70c466ed5 100644
--- a/doc/source/whatsnew/v0.19.0.txt
+++ b/doc/source/whatsnew/v0.19.0.txt
@@ -492,6 +492,8 @@ Bug Fixes
 - Bug in ``.resample(..)`` with a ``PeriodIndex`` not retaining its type or name with an empty ``DataFrame`` appropriately when empty (:issue:`13212`)
 - Bug in ``groupby(..).resample(..)`` where passing some keywords would raise an exception (:issue:`13235`)
 - Bug in ``.tz_convert`` on a tz-aware ``DateTimeIndex`` that relied on index being sorted for correct results (:issue:`13306`)
+- Bug in ``.tz_localize`` with ``dateutil.tz.tzlocal`` may return incorrect result (:issue:`13583`)
+- Bug in ``DatetimeTZDtype`` dtype with ``dateutil.tz.tzlocal`` cannot be regarded as valid dtype (:issue:`13583`)
 - Bug in ``pd.read_hdf()`` where attempting to load an HDF file with a single dataset, that had one or more categorical columns, failed unless the key argument was set to the name of the dataset. (:issue:`13231`)
 - Bug in ``.rolling()`` that allowed a negative integer window in contruction of the ``Rolling()`` object, but would later fail on aggregation (:issue:`13383`)
 
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index c8d1bae78..6c448de74 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -1263,6 +1263,18 @@ class TestMerge(tm.TestCase):
         result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
         tm.assert_series_equal(result, pd.Series(x + y, dtype='object'))
 
+    def test_concat_tz_series_tzlocal(self):
+        # GH 13583
+        tm._skip_if_no_dateutil()
+        import dateutil
+        x = [pd.Timestamp('2011-01-01', tz=dateutil.tz.tzlocal()),
+             pd.Timestamp('2011-02-01', tz=dateutil.tz.tzlocal())]
+        y = [pd.Timestamp('2012-01-01', tz=dateutil.tz.tzlocal()),
+             pd.Timestamp('2012-02-01', tz=dateutil.tz.tzlocal())]
+        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
+        tm.assert_series_equal(result, pd.Series(x + y))
+        self.assertEqual(result.dtype, 'datetime64[ns, tzlocal()]')
+
     def test_concat_period_series(self):
         x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
         y = Series(pd.PeriodIndex(['2015-10-01', '2016-01-01'], freq='D'))
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index d68ff793c..71a041d51 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -1061,6 +1061,46 @@ class TestTimeZoneSupportDateutil(TestTimeZoneSupportPytz):
         self.assert_numpy_array_equal(idx.hour,
                                       np.array([4, 4], dtype=np.int32))
 
+    def test_tzlocal(self):
+        # GH 13583
+        ts = Timestamp('2011-01-01', tz=dateutil.tz.tzlocal())
+        self.assertEqual(ts.tz, dateutil.tz.tzlocal())
+        self.assertTrue("tz='tzlocal()')" in repr(ts))
+
+        tz = tslib.maybe_get_tz('tzlocal()')
+        self.assertEqual(tz, dateutil.tz.tzlocal())
+
+        # get offset using normal datetime for test
+        offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
+        offset = offset.total_seconds() * 1000000000
+        self.assertEqual(ts.value + offset, Timestamp('2011-01-01').value)
+
+    def test_tz_localize_tzlocal(self):
+        # GH 13583
+        offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
+        offset = int(offset.total_seconds() * 1000000000)
+
+        dti = date_range(start='2001-01-01', end='2001-03-01')
+        dti2 = dti.tz_localize(dateutil.tz.tzlocal())
+        tm.assert_numpy_array_equal(dti2.asi8 + offset, dti.asi8)
+
+        dti = date_range(start='2001-01-01', end='2001-03-01',
+                         tz=dateutil.tz.tzlocal())
+        dti2 = dti.tz_localize(None)
+        tm.assert_numpy_array_equal(dti2.asi8 - offset, dti.asi8)
+
+    def test_tz_convert_tzlocal(self):
+        # GH 13583
+        # tz_convert doesn't affect to internal
+        dti = date_range(start='2001-01-01', end='2001-03-01', tz='UTC')
+        dti2 = dti.tz_convert(dateutil.tz.tzlocal())
+        tm.assert_numpy_array_equal(dti2.asi8, dti.asi8)
+
+        dti = date_range(start='2001-01-01', end='2001-03-01',
+                         tz=dateutil.tz.tzlocal())
+        dti2 = dti.tz_convert(None)
+        tm.assert_numpy_array_equal(dti2.asi8, dti.asi8)
+
 
 class TestTimeZoneCacheKey(tm.TestCase):
     def test_cache_keys_are_distinct_for_pytz_vs_dateutil(self):
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index e45523be7..62f8b10e3 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -1595,7 +1595,9 @@ cpdef inline object maybe_get_tz(object tz):
     Otherwise, just return tz.
     """
     if isinstance(tz, string_types):
-        if tz.startswith('dateutil/'):
+        if tz == 'tzlocal()':
+            tz = _dateutil_tzlocal()
+        elif tz.startswith('dateutil/'):
             zone = tz[9:]
             tz = _dateutil_gettz(zone)
             # On Python 3 on Windows, the filename is not always set correctly.
@@ -3771,7 +3773,6 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
         return np.array([], dtype=np.int64)
 
     # Convert to UTC
-
     if _get_zone(tz1) != 'UTC':
         utc_dates = np.empty(n, dtype=np.int64)
         if _is_tzlocal(tz1):
@@ -3825,7 +3826,7 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
                               dts.min, dts.sec, dts.us, tz2)
                 delta = int(total_seconds(_get_utcoffset(tz2, dt))) * 1000000000
                 result[i] = v + delta
-            return result
+        return result
 
     # Convert UTC to other timezone
     trans, deltas, typ = _get_dst_info(tz2)

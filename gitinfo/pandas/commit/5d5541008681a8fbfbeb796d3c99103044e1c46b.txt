commit 5d5541008681a8fbfbeb796d3c99103044e1c46b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Feb 4 23:55:09 2012 -0500

    TST: test coverage, refactored hash table unique into nanops for now

diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 63ad11b74..30cd0d67b 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -346,3 +346,26 @@ nanlt = make_nancomp(operator.lt)
 nanle = make_nancomp(operator.le)
 naneq = make_nancomp(operator.eq)
 nanne = make_nancomp(operator.ne)
+
+def unique1d(values):
+    """
+    Hash table-based unique
+    """
+    if issubclass(values.dtype.type, np.floating):
+        if values.dtype != np.float64:
+            values = values.astype(np.float64)
+        table = lib.Float64HashTable(len(values))
+        uniques = np.array(table.unique(values), dtype=np.float64)
+    elif issubclass(values.dtype.type, np.integer):
+        if values.dtype != np.int64:
+            values = values.astype(np.int64)
+        table = lib.Int64HashTable(len(values))
+        uniques = np.array(table.unique(values), dtype=np.int64)
+    else:
+        if not values.dtype == np.object_:
+            values = values.astype(np.object_)
+        table = lib.PyObjectHashTable(len(values))
+        uniques = lib.list_to_object_array(table.unique(values))
+        uniques = lib.maybe_convert_objects(uniques)
+    return uniques
+
diff --git a/pandas/core/series.py b/pandas/core/series.py
index dcb816124..0db939213 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -349,13 +349,9 @@ copy : boolean, default False
         if not isinstance(self.index, MultiIndex):
             raise ValueError('Can only tuple-index with a MultiIndex')
 
+        # If key is contained, would have returned by now
         indexer, new_index = self.index.get_loc_level(key)
-
-        if com.is_integer(indexer):
-            return self.values[indexer]
-        else:
-            return Series(self.values[indexer], index=new_index,
-                          name=self.name)
+        return Series(self.values[indexer], index=new_index, name=self.name)
 
     def _get_values(self, indexer):
         try:
@@ -647,10 +643,7 @@ copy : boolean, default False
         """
         Lazily iterate over (index, value) tuples
         """
-        if index:
-            return izip(iter(self.index), iter(self))
-        else:
-            return izip(iter(self))
+        return izip(iter(self.index), iter(self))
 
     iterkv = iteritems
     if py3compat.PY3:  # pragma: no cover
@@ -833,19 +826,7 @@ copy : boolean, default False
         -------
         uniques : ndarray
         """
-        values = self.values
-        if issubclass(values.dtype.type, np.floating):
-            if values.dtype != np.float64:
-                values = values.astype(np.float64)
-            table = lib.Float64HashTable(len(values))
-            uniques = np.array(table.unique(values), dtype=np.float64)
-        else:
-            if not values.dtype == np.object_:
-                values = values.astype(np.object_)
-            table = lib.PyObjectHashTable(len(values))
-            uniques = lib.list_to_object_array(table.unique(values))
-            uniques = lib.maybe_convert_objects(uniques)
-        return uniques
+        return nanops.unique1d(self.values)
 
     def nunique(self):
         """
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index b7e0182a2..740d6718c 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -977,6 +977,13 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         self.assert_(unstacked['E', 1].dtype == np.object_)
         self.assert_(unstacked['F', 1].dtype == np.float64)
 
+    def test_getitem_lowerdim_corner(self):
+        self.assertRaises(KeyError, self.frame.ix.__getitem__,
+                          (('bar', 'three'), 'B'))
+
+        self.assertRaises(KeyError, self.frame.ix.__setitem__,
+                          (('bar', 'three'), 'B'), 0)
+
     #----------------------------------------------------------------------
     # AMBIGUOUS CASES!
 
@@ -1007,6 +1014,8 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         expected = ft.xs('B')['foo']
         assert_series_equal(result, expected)
 
+    #----------------------------------------------------------------------
+
     def test_to_html(self):
         self.ymd.columns.name = 'foo'
         self.ymd.to_html()
@@ -1028,6 +1037,8 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         assert_series_equal(result, expected)
         assert_series_equal(result2, expected)
 
+        self.assertRaises(KeyError, series.__getitem__, (('foo', 'bar', 0), 2))
+
         result = frame.ix[('foo', 'bar', 0)]
         result2 = frame.xs(('foo', 'bar', 0))
         expected = frame[:2]
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 91459d93a..40326f020 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -13,7 +13,10 @@ import numpy.ma as ma
 
 from pandas import Index, Series, TimeSeries, DataFrame, isnull, notnull
 from pandas.core.index import MultiIndex
+
 import pandas.core.datetools as datetools
+import pandas.core.nanops as nanops
+
 from pandas.util import py3compat
 from pandas.util.testing import assert_series_equal, assert_almost_equal
 import pandas.util.testing as tm
@@ -145,6 +148,19 @@ class CheckNameIntegration(object):
         result = self.ts.to_sparse()
         self.assertEquals(result.name, self.ts.name)
 
+class TestNanops(unittest.TestCase):
+
+    def test_comparisons(self):
+        left = np.random.randn(10)
+        right = np.random.randn(10)
+        left[:3] = np.nan
+
+        result = nanops.nangt(left, right)
+        expected = (left > right).astype('O')
+        expected[:3] = np.nan
+
+        assert_almost_equal(result, expected)
+
 class SafeForSparse(object):
     pass
 
@@ -1430,6 +1446,23 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         result = s.unique()
         self.assert_(len(result) == 2)
 
+        # integers
+        s = Series(np.random.randint(0, 100, size=100))
+        result = np.sort(s.unique())
+        expected = np.unique(s.values)
+        self.assert_(np.array_equal(result, expected))
+
+        s = Series(np.random.randint(0, 100, size=100).astype(np.int32))
+        result = np.sort(s.unique())
+        expected = np.unique(s.values)
+        self.assert_(np.array_equal(result, expected))
+
+        # test string arrays for coverage
+        strings = np.tile(np.array([tm.rands(10) for _ in xrange(10)]), 10)
+        result = np.sort(nanops.unique1d(strings))
+        expected = np.unique(strings)
+        self.assert_(np.array_equal(result, expected))
+
     def test_sort(self):
         ts = self.ts.copy()
         ts.sort()

commit c6b236db73ff81007909be6406f0e484edc4a9eb
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Aug 5 03:30:16 2009 +0000

    first commit with cleaned up code
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@5 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 000000000..b9151db8c
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,30 @@
+Copyright (c) 2008-2009 AQR Capital Management, LLC
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+    * Redistributions of source code must retain the above copyright
+       notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above
+       copyright notice, this list of conditions and the following
+       disclaimer in the documentation and/or other materials provided
+       with the distribution.
+
+    * Neither the name of the copyright holder nor the names of any
+       contributors may be used to endorse or promote products derived
+       from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/MANIFEST.in b/MANIFEST.in
new file mode 100644
index 000000000..d45ecf8c9
--- /dev/null
+++ b/MANIFEST.in
@@ -0,0 +1,4 @@
+include TODO LICENSE README
+include setup.py setupegg.py
+include examples/data/*
+recursive-include examples *
\ No newline at end of file
diff --git a/README b/README
new file mode 100644
index 000000000..e69de29bb
diff --git a/TODO b/TODO
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/__init__.py b/pandas/__init__.py
new file mode 100644
index 000000000..024bcc144
--- /dev/null
+++ b/pandas/__init__.py
@@ -0,0 +1,36 @@
+"""
+Pandas - a library for panel, time series, or cross-sectional data analysis
+===========================================================================
+
+Main data structures (see docstrings for detailed documentation)
+--------------------
+Index
+    Represent row or column labels in Series / DataFrame structures
+
+Series / TimeSeries
+    Represents standard 1-dimensional cross-section (resp. time series)
+    As an numpy.ndarray subclass, compatible with ufuncs and other NumPy
+    functions
+
+DataFrame / DataMatrix
+    Represent collections of Series objects, enable easy management
+    of multiple time series / cross-sections
+
+DateRange
+    Index subclass for generating arrays of fixed frequency dates
+    
+Subpackages
+-----------
+core
+    Implementations of core data structures, basic building blocks. Most of
+    the user-relevant code is accessible through the top-level namespace
+io
+    Persistence, parsing, and data loading tools
+lib
+    C, Cython, and Fortran extensions for other components
+stats
+    Standard 
+"""
+
+from pandas.core.api import *
+from pandas.io.parsers import parseCSV, parseText, parseExcel
diff --git a/pandas/core/__init__.py b/pandas/core/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/core/api.py b/pandas/core/api.py
new file mode 100644
index 000000000..f0717d3c2
--- /dev/null
+++ b/pandas/core/api.py
@@ -0,0 +1,12 @@
+import numpy as np
+
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import DateOffset
+from pandas.core.frame import DataFrame
+from pandas.core.index import Index
+from pandas.core.matrix import DataMatrix
+from pandas.core.series import Series, TimeSeries
+
+import pandas.core.datetools as datetools
+
+from pandas.lib.tseries import isnull, notnull
diff --git a/pandas/core/collection.py b/pandas/core/collection.py
new file mode 100644
index 000000000..e200e718f
--- /dev/null
+++ b/pandas/core/collection.py
@@ -0,0 +1,88 @@
+from __future__ import with_statement
+
+from collections import defaultdict
+from pandas.core.mixins import Picklable
+from pandas.core.index import Index
+from pandas.core.pytools import rands, adjoin, groupby
+import cPickle
+import os
+
+__all__ = ['PickleContainer']
+
+class PickleContainer(Picklable):
+    """
+    Store collection of objects on disk with this dict-like object.
+    
+    Parameters
+    ----------
+    dirPath: string
+       Directory where to store the objects
+    lruSize: int
+       Number of objects to keep in memory (not implemented yet)
+    """
+    def __init__(self, dirPath, lruSize=5):
+        self.dirPath = dirPath
+        if not os.path.exists(dirPath):
+            os.mkdir(dirPath)
+    
+        self._lruSize = lruSize
+        
+        self._paths = {}
+        self._classes = {}
+        self._lru = {}
+
+    def __repr__(self):
+        output = str(self.__class__) + '\n'
+        keys, values = zip(*self._classes.iteritems())
+        output += adjoin(5, map(str, keys), map(str, values))
+        return output
+    
+    def __setitem__(self, key, value):
+        theKey = rands(10)
+        filePath = self.dirPath + '/' + theKey
+
+        self._paths[key] = filePath
+        
+        if isinstance(value, Picklable):
+            value.save(filePath)
+        else:
+            with open(filePath, 'w') as f:
+                cPickle.dump(value, f)
+
+        self._paths[key] = filePath
+        self._classes[key] = value.__class__
+        
+    def __getitem__(self, key):
+        if key not in self._paths:
+            raise Exception('Requested key not in this container!')
+        
+        thePath = self._paths[key]
+        theClass = self._classes[key]
+        
+        if issubclass(theClass, Picklable):
+            obj = theClass.load(thePath)
+        else:
+            with open(thePath, 'rb') as f:
+                obj = cPickle.load(f)
+        
+        return obj
+
+    def __delitem__(self, key):
+        del self._paths[key]
+        del self._classes[key]
+    
+    def __iter__(self):
+        return iter(self._paths)
+    
+    def iteritems(self):
+        for key, path in self._paths.iteritems():
+            yield key, self[key]
+    
+    def keys(self):
+        return self._paths.keys()
+
+    def values(self):
+        result = []
+        for key in self._paths:
+            result.append(self[key])
+        return result
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
new file mode 100644
index 000000000..e224f4c80
--- /dev/null
+++ b/pandas/core/daterange.py
@@ -0,0 +1,270 @@
+from datetime import datetime
+
+import numpy as np
+
+from pandas.core.index import Index
+from pandas.lib.tseries import map_indices
+import pandas.core.datetools as datetools
+
+#-------------------------------------------------------------------------------
+# XDateRange class
+
+class XDateRange(object):
+    """
+    XDateRange/DateRange generate a sequence of dates corresponding to the 
+    specified time interval.
+    
+    Inputs:
+         - toDate and/or fromDate and/or nPeriods (but not all 3)
+         - offset: a DateOffset object used to determine the dates returned
+         
+    Note that if both fromDate and toDate are specified, the returned dates
+    will satisfy:
+    
+    fromDate <= date <= toDate
+            
+    In other words, dates are constrained to lie in the specifed range as you
+    would expect, though no dates which do NOT lie on the offset will be 
+    returned.
+    
+    NOTE: XDateRange is a generator, use if you do not intend to reuse the date
+    range, or if you are doing lazy iteration, or if the number of dates you
+    are generating is very large. If you intend to reuse the range,
+    use DateRange, which will be the list of dates generated by XDateRange.
+    """
+    _cache = {}
+    _cacheStart = {}
+    _cacheEnd = {}
+    def __init__(self, fromDate=None, toDate=None, nPeriods=None, 
+                 offset=datetools.BDay()):
+
+        fromDate = datetools.to_datetime(fromDate)
+        toDate = datetools.to_datetime(toDate)
+
+        if fromDate and not offset.onOffset(fromDate):
+            fromDate = fromDate + offset.__class__(n=1, **offset.kwds)
+        if toDate and not offset.onOffset(toDate):
+            toDate = toDate - offset.__class__(n=1, **offset.kwds)
+            if nPeriods == None and toDate < fromDate:
+                toDate = None
+                nPeriods = 0
+
+        if toDate is None:
+            toDate = fromDate + (nPeriods - 1) * offset
+        
+        if fromDate is None:
+            fromDate = toDate - (nPeriods - 1) * offset
+        
+        self.offset = offset
+        self.fromDate = fromDate
+        self.toDate = toDate
+        self.nPeriods = nPeriods
+        
+    def __iter__(self):
+        offset = self.offset
+        cur = self.fromDate
+        if offset._normalizeFirst:
+            cur = datetools.normalize_date(cur)
+        while cur <= self.toDate:
+            yield cur
+            cur = cur + offset
+            
+#-------------------------------------------------------------------------------
+# DateRange cache    
+    
+CACHE_START = datetime(1950, 1, 1)
+CACHE_END   = datetime(2030, 1, 1)
+    
+def _getIndexLoc(index, date):
+    if date in index.indexMap:
+        return index.indexMap[date]
+    else:
+        asOf = index.asOfDate(date)
+        return index.indexMap[asOf] + 1
+        
+#-------------------------------------------------------------------------------
+# DateRange class
+    
+class DateRange(Index):
+    """
+    Fixed frequency date range according to input parameters.
+    
+    Input dates satisfy:
+        begin <= d <= end, where d lies on the given offset
+    
+    Parameters
+    ----------
+    fromDate: {datetime, None}
+        left boundary for range
+    toDate: {datetime, None}
+        right boundary for range
+    periods: int   
+        Number of periods to generate.
+    offset: DateOffset, default is 1 BusinessDay
+        Used to determine the dates returned
+    """
+    _cache = {}
+    def __new__(cls, fromDate=None, toDate=None, periods=None, 
+                offset=datetools.bday, **kwds):
+        
+        # Allow us to circumvent hitting the cache
+        index = kwds.get('index')
+        if index is None:
+            # Cachable
+            if not fromDate:
+                fromDate = kwds.get('begin')
+            if not toDate:
+                toDate = kwds.get('end')
+            if not periods:
+                periods = kwds.get('nPeriods')
+
+            if offset.isAnchored() and not isinstance(offset, datetools.Tick):
+                index = cls.getCachedRange(fromDate, toDate, periods=periods,
+                                           offset=offset)
+            else:
+                xdr = XDateRange(fromDate=fromDate, toDate=toDate, 
+                                 nPeriods=periods, offset=offset)
+                
+                index = np.array(list(xdr), dtype=object, copy=False)
+                
+                index = index.view(cls)
+                index.offset = offset
+        else:
+            index = index.view(cls)
+        
+        return index
+
+    @classmethod
+    def getCachedRange(cls, start=None, end=None, periods=None, offset=None):
+        if offset is None:
+            raise Exception('Must provide a DateOffset!')
+
+        start = datetools.to_datetime(start)
+        end = datetools.to_datetime(end)
+        
+        if start is not None and not isinstance(start, datetime):
+            raise Exception('%s is not a valid date!' % start)
+        
+        if end is not None and not isinstance(end, datetime):
+            raise Exception('%s is not a valid date!' % end)
+        
+        if offset not in cls._cache:
+            xdr = XDateRange(CACHE_START, CACHE_END, offset=offset)
+            arr = np.array(list(xdr), dtype=object, copy=False)
+            
+            cachedRange = DateRange.fromIndex(arr)
+            cachedRange.offset = offset
+                        
+            cls._cache[offset] = cachedRange
+        else:
+            cachedRange = cls._cache[offset]
+        
+        if start is None:
+            if end is None:
+                raise Exception('Must provide start or end date!')
+            if periods is None:
+                raise Exception('Must provide number of periods!')
+            
+            if end not in cachedRange:
+                endLoc = _getIndexLoc(cachedRange, end)
+            else:
+                endLoc = cachedRange.indexMap[end] + 1
+
+            startLoc = endLoc - periods            
+        elif end is None:
+            startLoc = _getIndexLoc(cachedRange, start)
+            if periods is None:
+                raise Exception('Must provide number of periods!')
+            
+            endLoc = startLoc + periods
+        else:
+            startLoc = _getIndexLoc(cachedRange, start)
+            
+            if end not in cachedRange:
+                endLoc = _getIndexLoc(cachedRange, end)
+            else:
+                endLoc = cachedRange.indexMap[end] + 1
+            
+        indexSlice = cachedRange[startLoc:endLoc]
+        indexSlice._parent = cachedRange
+        
+        return indexSlice
+    
+    @classmethod
+    def fromIndex(cls, index):
+        index = cls(index=index)
+        return index
+
+    def __array_finalize__(self, obj):
+        if self.ndim == 0:
+            return self.item()
+        
+        if len(self) > 0:
+            self.indexMap = map_indices(self)
+        else:
+            self.indexMap = {}        
+        
+        self.offset = getattr(obj, 'offset', None)
+        self._parent = getattr(obj, '_parent',  None)
+        self._allDates = True
+        
+    def __lt__(self, other):
+        return self.view(np.ndarray) < other
+
+    def __le__(self, other):
+        return self.view(np.ndarray) <= other
+
+    def __gt__(self, other):
+        return self.view(np.ndarray) > other
+
+    def __ge__(self, other):
+        return self.view(np.ndarray) >= other
+
+    def __eq__(self, other):
+        return self.view(np.ndarray) == other
+    
+    def __getitem__(self, key):
+        """Override numpy.ndarray's __getitem__ method to work as desired"""
+        if isinstance(key, (int, np.int32)):
+            return self.view(np.ndarray)[key]
+        elif isinstance(key, slice):
+            if self.offset is None:
+                return Index.__getitem__(self, key)
+            
+            if key.step is not None:
+                newOffset = key.step * self.offset
+                newRule = None
+            else:
+                newOffset = self.offset
+            newIndex = Index(self.view(np.ndarray)[key]).view(DateRange)
+            newIndex.offset = newOffset
+            return newIndex
+        else:
+            return Index(self.view(np.ndarray)[key])
+        
+    def __repr__(self):
+        output = str(self.__class__) + '\n'
+        output += 'offset: %s\n' % self.offset
+        output += '[%s, ..., %s]\n' % (self[0], self[-1]) 
+        output += 'length: %d' % len(self)
+        return output
+    
+    def __str__(self):
+        return self.__repr__()
+    
+    def shift(self, n):
+        if n > 0:
+            start = self[-1] + self.offset
+            tail = DateRange(fromDate=start, periods=n)
+            newArr = np.concatenate((self[n:], tail)).view(DateRange)
+            newArr.offset = self.offset
+            return newArr
+        elif n < 0:
+            end = self[0] - self.offset
+            head = DateRange(toDate=end, periods=-n)
+            
+            newArr = np.concatenate((head, self[:n])).view(DateRange)
+            newArr.offset = self.offset
+            return newArr
+        else:
+            return self
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
new file mode 100644
index 000000000..2567bd3ea
--- /dev/null
+++ b/pandas/core/datetools.py
@@ -0,0 +1,490 @@
+"""A collection of random tools for dealing with dates in Python"""
+
+from datetime import datetime, timedelta
+from dateutil import parser
+from dateutil.relativedelta import relativedelta
+import calendar
+
+#-------------------------------------------------------------------------------
+# Miscellaneous date functions
+
+def format(dt):
+    """Returns date in YYYYMMDD format."""
+    return dt.strftime('%Y%m%d')
+
+OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
+
+def ole2datetime(oledt):
+    """function for converting excel date to normal date format"""
+    # Excel has a bug where it thinks the date 2/29/1900 exists
+    # we just reject any date before 3/1/1900.
+    val = float(oledt)
+    if val < 61:
+        raise Exception("Value is outside of acceptable range: %s " % val)
+    return OLE_TIME_ZERO + timedelta(days=val)  
+            
+def to_datetime(input):
+    """Attempts to convert input to datetime"""
+    if input is None or isinstance(input, datetime):
+        return input
+    try:
+        return parser.parse(input)
+    except:
+        return input
+
+def normalize_date(dt):
+    return datetime(dt.year, dt.month, dt.day)
+
+#-------------------------------------------------------------------------------
+# DateOffset
+
+class DateOffset(object):
+    """
+    Standard kind of date increment used for a date range.
+    
+    Works exactly like relativedelta in terms of the keyword args you pass in,
+    use of the keyword n is discouraged-- you would be better off specifying
+    n in the keywords you use, but regardless it is there for you. n is needed
+    for DateOffset subclasses.
+    
+    DateOffets work as follows.  Each offset specify a set of dates that 
+    conform to the DateOffset.  For example, Bday defines this set to be the
+    set of dates that are weekdays (M-F).  To test if a date is in the set
+    of a DateOffset dateOffset we can use the onOffset method:
+    dateOffset.onOffset(date).  
+    
+    If a date is not on a valid date, the rollback and rollforward methods can
+    be used to roll the date to the nearest valid date before/after the date.
+    
+    DateOffsets can be created to move dates forward a given number of valid
+    dates.  For example, Bday(2) can be added to a date to move it two 
+    business days forward.  If the date does not start on a valid date, first
+    it is moved to a valid date.  Thus psedo code is:
+    
+    def __add__(date):
+      date = rollback(date) # does nothing is date is valid
+      return date + <n number of periods>
+
+    When a date offset is created for a negitive number of periods, the date
+    is first rolled forward.  The psedo code is:
+    
+    def __add__(date):
+      date = rollforward(date) # does nothing is date is valid
+      return date + <n number of periods>      
+      
+    Zero presents a problem.  Should it roll forward or back?  We arbitrarily 
+    have it rollforward:
+    
+    date + BDay(0) == BDay.rollforward(date)
+    
+    Since 0 is a bit weird, we suggest avoiding its use.
+    """    
+    # For some offsets, want to drop the time information off the first date
+    _normalizeFirst = False
+    def __init__(self, n = 1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+
+    def apply(self, other):
+        if len(self.kwds) > 0:
+            if self.n > 0:
+                for i in xrange(self.n):
+                    other = other + relativedelta(**self.kwds)
+            else:
+                for i in xrange(-self.n):
+                    other = other - relativedelta(**self.kwds)
+            return other
+        else:
+            return other + timedelta(self.n)
+
+    def isAnchored(self):
+        return (self.n == 1)
+        
+    def copy(self):
+        return self.__class__(self.n, **self.kwds)
+
+    def _params(self):
+        attrs = sorted((item for item in self.__dict__.iteritems()
+                        if item[0] != 'kwds'))
+        params = tuple([str(self.__class__)] + attrs)
+        return params
+
+    def __repr__(self):
+        className = getattr(self, '_outputName', self.__class__.__name__)
+        exclude = set(['n', 'inc'])
+        attrs = []
+        for attr in self.__dict__:
+            if attr == 'kwds' and len(self.kwds) == 0:
+                continue
+            if attr not in exclude:
+                attrs.append('='.join((attr, repr(getattr(self, attr)))))
+        out = '<%s ' % self.n + className + ('s' if abs(self.n) != 1 else '')
+        if attrs:
+            out += ': ' + ', '.join(attrs)
+        out += '>'
+        return out
+
+    def __eq__(self, other):        
+        return self._params() == other._params() 
+
+    def __hash__(self):
+        return hash(self._params())
+
+    def __call__(self, other):
+        return self.apply(other)
+
+    def __add__(self, other):
+        return self.apply(other)        
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __sub__(self, other):
+        return self.__class__(-self.n, **self.kwds) + other
+
+    def __rsub__(self, other):
+        return self.__class__(-self.n, **self.kwds) + other
+
+    def __mul__(self, someInt):
+        return self.__class__(n = someInt * self.n, **self.kwds)
+
+    def __rmul__(self, someInt):
+        return self.__class__(n = someInt * self.n, **self.kwds)
+    
+    def __neg__(self):
+        return self.__class__(-self.n, **self.kwds)
+    
+    def __contains__(self, other):
+        return self.onOffset(other)
+
+    def rollback(self, someDate):
+        """Roll provided date backward to next offset only if not on offset"""
+        if self._normalizeFirst:
+            someDate = normalize_date(someDate)
+        
+        if not self.onOffset(someDate):
+            someDate = someDate - self.__class__(1, **self.kwds)
+        return someDate
+
+    def rollforward(self, someDate):
+        """Roll provided date forward to next offset only if not on offset"""
+        if self._normalizeFirst:
+            someDate = normalize_date(someDate)
+
+        if not self.onOffset(someDate):
+            someDate = someDate + self.__class__(1, **self.kwds)
+        return someDate
+        
+    @classmethod
+    def onOffset(cls, someDate):
+        # Default (slow) method for determining if some date is a member of 
+        # the DateRange generated by this offset. Subclasses may have this
+        # re-implemented in a nicer way. 
+        obj = cls()
+        return someDate == ((someDate + obj) - obj)
+
+    
+class BDay(DateOffset):
+    """
+    DateOffset subclass representing possibly n business days
+    """
+    _normalizeFirst = True
+    _outputName = 'BusinessDay'
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        if not isinstance(other, datetime):
+            raise Exception('Only know how to add business day to a datetime!')
+        n = self.n
+        if n == 0 and other.weekday() > 4:
+            n = 1
+        while n != 0:
+            other = other + timedelta(n/abs(n))
+            if other.weekday() < 5: n -= n/abs(n)
+        return datetime(other.year, other.month, other.day)
+
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.weekday() < 5
+
+    
+class MonthEnd(DateOffset):
+    _normalizeFirst = True
+    """DateOffset of one month end"""
+
+    def apply(self, other):
+        n = self.n
+        __junk, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        if other.day != nDaysInMonth:
+            other = other + relativedelta(months=-1, day=31)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(months=n, day=31)
+        #other = datetime(other.year, other.month, nDaysInMonth)
+        return other
+
+    @classmethod
+    def onOffset(cls, someDate):
+        __junk, nDaysInMonth = calendar.monthrange(someDate.year, someDate.month)
+        return someDate.day == nDaysInMonth
+        
+class BMonthEnd(DateOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessMonthEnd'
+    _normalizeFirst = True
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        n = self.n
+        
+        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+        
+        if n > 0 and not other.day >= lastBDay:
+            n = n - 1      
+        elif n <= 0 and other.day > lastBDay:
+            n = n + 1
+        other = other + relativedelta(months=n, day=31)
+        
+        if other.weekday() > 4:
+            other = other - BDay()        
+        return other 
+
+
+class Week(DateOffset):
+    """
+    dayOfWeek
+    0: Mondays
+    1: Tuedays
+    2: Wednesdays
+    3: Thursdays
+    4: Fridays
+    5: Saturdays
+    6: Sundays
+    """
+    _normalizeFirst = True
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.dayOfWeek = kwds.get('dayOfWeek', None)
+        
+        if self.dayOfWeek is not None:
+            if self.dayOfWeek < 0 or self.dayOfWeek > 6:
+                raise Exception('Day must be 0<=day<=6, got %d' % self.dayOfWeek)
+            
+        self.inc = timedelta(weeks=1)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.dayOfWeek is not None)
+        
+    def apply(self, other):
+        if self.dayOfWeek is None:
+            return other + self.n * self.inc
+        
+        if self.n > 0:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.dayOfWeek:
+                other = other + timedelta((self.dayOfWeek - otherDay) % 7)
+                k = k - 1
+            for i in xrange(k):
+                other = other + self.inc
+        else:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.dayOfWeek:
+                other = other + timedelta((self.dayOfWeek - otherDay) % 7)
+            for i in xrange(-k):
+                other = other - self.inc
+        return other
+    
+    def onOffset(self, someDate):
+        return someDate.weekday() == self.dayOfWeek
+
+
+class BQuarterEnd(DateOffset):
+    """DateOffset increments between business Quarter dates
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
+    """
+    _outputName = 'BusinessQuarterEnd'
+    _normalizeFirst = True
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+        
+        if self.startingMonth < 1 or self.startingMonth > 3:
+            raise Exception('Start month must be 1<=day<=12, got %d' 
+                            % self.startingMonth)
+            
+        self.offset = BMonthEnd(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+        
+    def apply(self, other):
+        n = self.n
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+        
+        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
+        if monthsToGo == 3:
+            monthsToGo = 0
+        
+        if n > 0 and not (other.day >= lastBDay and monthsToGo == 0):
+            n = n - 1      
+        elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
+            n = n + 1
+
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+        
+        if other.weekday() > 4:
+            other = other - BDay()
+        
+        return other 
+
+    def onOffset(self, someDate):
+        modMonth = (someDate.month - self.startingMonth) % 3
+        return BMonthEnd().onOffset(someDate) and modMonth == 0
+        
+class BYearEnd(DateOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessYearEnd'
+    _normalizeFirst = True
+    
+    def apply(self, other):
+        n = self.n
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, 12)
+        lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
+        
+        if n > 0 and not (other.month == 12 and other.day >= lastBDay):
+            n = n - 1      
+        elif n <= 0 and other.month == 12 and other.day > lastBDay:
+            n = n + 1
+
+        other = other + relativedelta(years=n, month=12, day=31)
+        
+        if other.weekday() > 4:
+            other = other - BDay()
+        
+        return other                
+
+
+class YearEnd(DateOffset):
+    """DateOffset increments between calendar year ends"""
+    _normalizeFirst = True
+
+    def apply(self, other):
+        n = self.n
+        if other.month != 12 or other.day != 31:
+            other = datetime(other.year - 1, 12, 31)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years = n)
+        return other
+
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.month == 12 and someDate.day == 31    
+
+
+class YearBegin(DateOffset):
+    """DateOffset increments between calendar year begin dates"""
+    _normalizeFirst = True
+
+    def apply(self, other):
+        n = self.n
+        if other.month != 1 or other.day != 1:
+            other = datetime(other.year, 1, 1)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years = n, day=1)
+        return other
+    
+    @classmethod
+    def onOffset(cls, someDate):
+        return someDate.month == 1 and someDate.day == 1    
+
+#-------------------------------------------------------------------------------
+# Ticks
+    
+class Tick(DateOffset):
+    pass
+    
+class Hour(Tick):
+    _normalizeFirst = False
+    _delta = None
+    _inc = timedelta(60)
+    
+    @property
+    def delta(self):
+        if self._delta is None:
+            self._delta = self.n * self._inc
+            
+        return self._delta
+    
+    def apply(self, other):
+        return other + self.delta
+
+class Minute(Tick):
+    _normalizeFirst = False
+    _delta = None
+    _inc = timedelta(0, 60)
+    
+    @property
+    def delta(self):
+        if self._delta is None:
+            self._delta = self.n * self._inc
+            
+        return self._delta
+    
+    def apply(self, other):
+        return other + self.delta
+
+class Second(Tick):
+    _normalizeFirst = False
+    _delta = None
+    _inc = timedelta(0, 1)
+    
+    @property
+    def delta(self):
+        if self._delta is None:
+            self._delta = self.n * self._inc
+            
+        return self._delta
+    
+    def apply(self, other):
+        return other + self.delta
+    
+day = DateOffset()
+bday = BDay()
+businessDay = bday
+monthEnd = MonthEnd()
+yearEnd = YearEnd()
+yearBegin = YearBegin()
+bmonthEnd = BMonthEnd()
+businessMonthEnd = bmonthEnd
+bquarterEnd = BQuarterEnd()
+byearEnd = BYearEnd()
+week = Week()
+
+# Functions/offsets to roll dates forward
+thisMonthEnd = MonthEnd(0)
+thisBMonthEnd = BMonthEnd(0)
+thisYearEnd = YearEnd(0)
+thisYearBegin = YearBegin(0)
+thisBQuarterEnd = BQuarterEnd(0)
+
+# Functions to check where a date lies
+isBusinessDay = BDay.onOffset
+isMonthEnd = MonthEnd.onOffset
+isBMonthEnd = BMonthEnd.onOffset
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
new file mode 100644
index 000000000..88b35ed13
--- /dev/null
+++ b/pandas/core/frame.py
@@ -0,0 +1,1577 @@
+import operator
+
+from numpy import NaN
+import numpy as np
+
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import DateOffset, to_datetime
+from pandas.core.index import Index, NULL_INDEX
+from pandas.core.mixins import Picklable, Groupable
+from pandas.core.series import Series, remove_na
+from pandas.lib.tseries import isnull, notnull
+import pandas.lib.tseries as tseries
+
+#-------------------------------------------------------------------------------
+# DataFrame class
+
+class DataFrame(Picklable, Groupable):
+    """
+    Homogenously indexed table with named columns, with intelligent
+    arithmetic operations, slicing, reindexing, aggregation, etc. Can
+    function interchangeably as a dictionary.
+
+    Parameters
+    ----------
+    data: dict
+        Mapping of column name --> array or Series/TimeSeries objects
+    index: array-like
+        Specific index to use for the Frame, Series will be conformed to this
+        if you provide it.
+
+    Notes
+    -----
+    Data contained within is COPIED from input arrays, this is to prevent silly
+    behavior like altering the original arrays and having those changes
+    reflected in the frame.
+
+    See also
+    --------
+    DataMatrix: more efficient version of DataFrame for most operations
+
+    Example usage
+    -------------
+        >>> d = {'col1' : ts1, 'col2' : ts2}
+        >>> df = DataFrame(data=d, index=someIndex)
+    """
+    def __init__(self, data = None, index = None):
+        series = data
+        self._series = {}
+        if series is not None and len(series) > 0:
+            if index is None:
+                for s in series.values(): break
+                if hasattr(s, 'index'):
+                    self.index = s.index
+                else:
+                    self.index = Index(np.arange(len(s)))
+            else:
+                if isinstance(index, Index):
+                    self.index = index
+                else:
+                    self.index = Index(index)
+            for k, v in series.iteritems():
+                if isinstance(v, Series):
+                    self._series[k] = v.reindex(self.index) # Forces homogoneity
+                else:
+                    assert(len(v) == len(self.index))
+                    try:
+                        s = Series(v, index=self.index, dtype=float)
+                    except:
+                        s = Series(v, index=self.index)
+
+                    self._series[k] = s
+        elif index is not None:
+            if isinstance(index, Index):
+                self.index = index
+            else:
+                self.index = Index(index)
+        else:
+            raise Exception('DataFrame constructor not properly called!')
+
+    # Alternate constructors
+    @classmethod
+    def fromDict(cls, inputDict={}, castFloat=True, **kwds):
+        """
+        Convert a two-level tree representation of a series or time series
+        to a DataFrame.
+
+        tree is structured as:
+            {'col1' : {
+                idx1 : value1,
+                ...
+                idxn : valueN
+                    },
+            ...}
+        e.g. tree['returns'][curDate] --> return value for curDate
+
+        Parameters
+        ----------
+        input: dict object
+            Keys become column names of returned frame
+        kwds: optionally provide arguments as keywords
+
+        Returns
+        -------
+        DataFrame
+
+        Example
+        -------
+        df1 = DataFrame.fromDict(myDict)
+        df2 = DataFrame.fromDict(A=seriesA, B=seriesB)
+        """
+        if not hasattr(inputDict, 'iteritems'):
+            raise Exception('Input must be dict or dict-like!')
+
+        inputDict = inputDict.copy()
+        inputDict.update(kwds)
+
+        if len(inputDict) == 0:
+            return DataFrame(index=NULL_INDEX)
+
+        # Get set of indices
+        indices = set([])
+        for key, branch in inputDict.iteritems():
+            indices = indices | set(branch.keys())
+        index = Index(sorted(indices))
+
+        columns = {}
+        for key, branch in inputDict.iteritems():
+            tmp = [branch.get(i, NaN) for i in index]
+            try:
+                if castFloat:
+                    columns[key] = Series(tmp, dtype=float, index=index)
+                else:
+                    columns[key] = Series(tmp, index=index)
+            except:
+                columns[key] = Series(tmp, index=index)
+
+        return DataFrame(data=columns, index=index)
+
+    @classmethod
+    def fromMatrix(cls, mat, colNames, rowNames):
+        """
+        Convert input matrix to DataFrame given column and row names (index)
+
+        Parameters
+        ----------
+        mat: ndarray
+            Dimension T x N
+        colNames: iterable
+            Dimension N
+        rowNames: iterable
+            Dimension T
+
+        Returns
+        -------
+        DataFrame
+        """
+        rows, cols = mat.shape
+        try:
+            assert(rows == len(rowNames))
+            assert(cols == len(colNames))
+        except AssertionError:
+            raise Exception('Dimensions do not match: %s, %s, %s' %
+                            (mat.shape, len(rowNames), len(colNames)))
+
+        index = Index(rowNames)
+        colIndex = Index(colNames)
+
+        idxMap = colIndex.indexMap
+
+        return DataFrame(data = dict([(idx, mat[:, idxMap[idx]])
+                                      for idx in colIndex]),
+                         index = index)
+
+    @classmethod
+    def load(cls, baseFile):
+        """
+        Load DataFrame from file.
+
+        Parameters
+        ----------
+        baseFile: string
+            Filename base where index/values are stored.
+            e.g. baseFile='myfile' --> 'myfile_index.npy', 'myfile_values.npy'
+
+        Returns
+        -------
+        DataFrame
+        """
+        cacheLoad = np.load(baseFile + '.npz')
+
+        values = cacheLoad['v']
+        index = Index(cacheLoad['i'])
+        cols = cacheLoad['c']
+
+        return cls.fromMatrix(values, cols, index)
+
+    def save(self, baseFile):
+        """
+        Write DataFrame efficiently to file using NumPy serialization,
+        which is easily 100x faster than cPickle.
+
+        Note
+        ----
+        Saves data to 3 files, one for index, columns, and values matrix.
+        """
+        np.savez(baseFile, i=self.index, v=self.values, c=self.columns)
+
+#-------------------------------------------------------------------------------
+# Magic methods
+
+    def __nonzero__(self):
+        return len(self._series) > 0 and len(self.index) > 0
+
+    def __repr__(self):
+        """
+        Return a string representation for a particular DataFrame
+        """
+        if len(self.index) < 1000 and len(self._series) < 10:
+            return self.toString(to_stdout=False)
+        else:
+            output = str(self.__class__) + '\n'
+            return output + self.info(to_stdout=False)
+
+    def __getitem__(self, item):
+        """
+        Retrieve column or slice from DataFrame
+        """
+        if isinstance(item, slice):
+            start, stop = item.start, item.stop
+            start = 0 if start is None else start
+            stop = len(self) if stop is None else stop
+            if start < 0:
+                start += len(self)
+            if stop < 0:
+                stop += len(self)
+
+            dateRange = self.index[start:stop]
+            newColumns = {}
+            for col, series in self.iteritems():
+                newColumns[col] = series[start:stop]
+            return DataFrame(data=newColumns, index=dateRange)
+        elif isinstance(item, np.ndarray):
+            if len(item) != len(self.index):
+                raise Exception('Item wrong length %d instead of %d!' %
+                                (len(item), len(self.index)))
+            newIndex = self.index[item]
+            return self.reindex(newIndex)
+        else:
+            return self._series[item]
+
+    def __setitem__(self, key, value):
+        """
+        Add series to DataFrame in specified column.
+
+        If series is a numpy-array (not a Series/TimeSeries), it must be the
+        same length as the DataFrame's index or an error will be thrown.
+
+        Series/TimeSeries will be conformed to the DataFrame's index to
+        ensure homogeneity.
+        """
+        # Array
+        try:
+            if hasattr(value, '__iter__'):
+                if hasattr(value, 'reindex'):
+                    cleanSeries = value.reindex(self.index)
+                else:
+                    cleanSeries = Series(value, index=self.index)
+                assert(len(cleanSeries) == len(self.index))
+                self._series[key] = cleanSeries
+
+            # Scalar
+            else:
+                self._series[key] = Series.fromValue(value, index=self.index)
+        except AssertionError:
+            raise
+        except:
+            raise Exception('Could not put key, value pair in Frame!')
+
+    def __delitem__(self, key):
+        """
+        Delete column from DataFrame (only deletes the reference)
+        """
+        r = self._series.pop(key, None)
+        del r   # need to delete the reference
+
+    def __iter__(self):
+        """
+        Iterate over columns of the frame.
+        """
+        return self._series.__iter__()
+
+    def __len__(self):
+        """
+        Returns number of columns/Series inside
+        """
+        return len(self.index)
+
+    def __contains__(self, key):
+        """
+        True if DataFrame has this column
+        """
+        return key in self._series
+
+    def arith_method(func, name):
+        def f(self, other):
+            return self._combineFunc(other, func)
+
+        f.__name__ = name
+        f.__doc__ = 'Wrapper for arithmetic method %s' % name
+
+        return f
+
+    __add__ = arith_method(operator.add, '__add__')
+    __sub__ = arith_method(operator.sub, '__sub__')
+    __mul__ = arith_method(operator.mul, '__mul__')
+    __div__ = arith_method(operator.div, '__div__')
+    __pow__ = arith_method(operator.pow, '__pow__')
+
+    __radd__ = arith_method(operator.add, '__radd__')
+    __rmul__ = arith_method(operator.mul, '__rmul__')
+    __rsub__ = arith_method(lambda x, y: y - x, '__rsub__')
+    __rdiv__ = arith_method(lambda x, y: y / x, '__rdiv__')
+    __rpow__ = arith_method(lambda x, y: y ** x, '__rpow__')
+
+    del arith_method
+
+    def __neg__(self):
+        mycopy = self.copy()
+        myseries = mycopy._series
+        for col in myseries:
+            mycopy[col] = -myseries[col]
+        return mycopy
+
+#-------------------------------------------------------------------------------
+# Private / helper methods
+
+    def _firstTimeWithNValues(self):
+        # Need to test this!
+        N = len(self._series)
+        theCount = np.isfinite(self.asMatrix()).sum(1)
+        selector = (theCount == N)
+        if not selector.any():
+            raise Exception('No time has %d values!' % N)
+
+        return self.index[selector][0]
+
+    def _firstTimeWithValue(self):
+        return self.index[self.count(1) > 0][0]
+
+    def _lastTimeWithValue(self):
+        return self.index[self.count(1) > 0][-1]
+
+    def _combineFrame(self, other, func):
+        newColumns = {}
+        newIndex = self.index
+
+        if self.index is other.index:
+            newIndex = self.index
+        else:
+            newIndex = self.index + other.index
+
+        if not self and not other:
+            return DataFrame(index=newIndex)
+
+        if not other:
+            return self * NaN
+
+        if not self:
+            return other * NaN
+
+        for col, series in self.iteritems():
+            if col in other:
+                newSeries = func(series, other[col])
+                newColumns[col] = newSeries.reindex(newIndex)
+            else:
+                cls = series.__class__
+                newColumns[col] = cls(np.repeat(NaN, len(newIndex)),
+                                          index=newIndex)
+        for col, series in other.iteritems():
+            if col not in self:
+                cls = series.__class__
+                newColumns[col] = cls(np.repeat(NaN, len(newIndex)),
+                                      index=newIndex)
+
+        return DataFrame(data=newColumns, index=newIndex)
+
+    def _combineSeries(self, other, func):
+        newColumns = {}
+        newIndex = self.index
+
+        if len(other) == 0:
+            return self * NaN
+
+        if self.index._allDates and other.index._allDates:
+            if not self:
+                return DataFrame(index=other.index)
+
+            if self.index is other.index:
+                newIndex = self.index
+            else:
+                newIndex = self.index + other.index
+
+            other = other.reindex(newIndex)
+            for col, series in self.iteritems():
+                newColumns[col] = func(series.reindex(newIndex), other)
+
+        else:
+            for col, series in self.iteritems():
+                if col in other.index:
+                    newColumns[col] = func(series, other[col])
+                else:
+                    cls = series.__class__
+                    newColumns[col] = cls(np.repeat(NaN, len(self.index)),
+                                          index=self.index)
+
+        return DataFrame(data=newColumns, index=newIndex)
+
+    def _combineFunc(self, other, func):
+        """
+        Combine DataFrame objects or a single DataFrame and a constant
+        or other object using the supplied function.
+
+        This is the core method used for all the 'magic' DataFrame methods.
+
+        Parameters
+        ----------
+        other: constant, array, or DataFrame/Matrix
+        func: function taking two arguments
+
+        Example
+        -------
+        frame._combineFunc(otherFrame, lambda x, y: x + y)
+        """
+        newColumns = {}
+        newIndex = self.index
+
+        if isinstance(other, DataFrame):    # Another DataFrame
+            return self._combineFrame(other, func)
+        elif isinstance(other, Series):
+            return self._combineSeries(other, func)
+        else:
+            for col, series in self.iteritems():
+                newColumns[col] = func(series, other)
+
+        return DataFrame(data=newColumns, index=newIndex)
+
+#-------------------------------------------------------------------------------
+# Public methods
+
+    def toCSV(self, path=None, nanRep='', cols=None, inclHeader=True,
+              inclIndex=True):
+        """
+        Write the DataFrame to a CSV file
+        """
+        if path is None:
+            import sys
+            f = sys.stdout
+        else:
+            f = open(path, 'w')
+        cols = self.cols() if cols is None else cols
+        if inclHeader:
+            if inclIndex:
+                f.write(',' + ','.join([str(c) for c in cols]))
+            else:
+                f.write(','.join([str(c) for c in cols]))
+            f.write('\n')
+        for idx in self.index:
+            if inclIndex:
+                f.write(str(idx) + ',')
+            for col in cols:
+                val = self._series[col].get(idx)
+                if isnull(val):
+                    val = nanRep
+                else:
+                    val = str(val)
+                f.write(val + ',')
+            f.write('\n')
+        if path is not None:
+            f.close()
+        print 'CSV file written successfully: %s' % path
+
+    def toDict(self):
+        """
+        Simpler pseudo-inverse operation of dictToDataFrame, NaN values will be
+        included in the resulting dict-tree.
+
+        Return
+        ------
+        nested dict mapping: {column -> index -> value}
+        """
+        tree = {}
+        for col, series in self.iteritems():
+            tree[col] = branch = {}
+            for i in self.index:
+                branch[i] = series[i]
+        return tree
+
+    def toDataMatrix(self):
+        from pandas.core.matrix import DataMatrix
+
+        return DataMatrix(self.asMatrix(), index=self.index,
+                          columns=self.cols())
+
+    def toString(self, to_stdout=True, verbose=False, colSpace=15, nanRep=None):
+        """Output a tab-separated version of this DataFrame"""
+        series = self._series
+        skeys = sorted(series.keys())
+        if len(skeys) == 0 or len(self.index) == 0:
+            output = 'Empty DataFrame\n'
+            output += self.index.__repr__()
+        else:
+            idxSpace = max([len(str(idx)) for idx in self.index]) + 4
+            head = _pfixed('', idxSpace)
+            if verbose:
+                colSpace = max([len(c) for c in self.columns]) + 4
+            for h in skeys:
+                head += _pfixed(h, colSpace)
+            output = head + '\n'
+            for idx in self.index:
+                ot = _pfixed(idx, idxSpace)
+                for k in skeys:
+                    ot += _pfixed(series[k][idx], colSpace, nanRep=nanRep)
+                output += ot + '\n'
+        if to_stdout:
+            print output
+        else:
+            return output
+
+    def info(self, to_stdout=True):
+        """Concise summary of a DataFrame, used in __repr__ when very large."""
+        if len(self._series) == 0:
+            output = 'DataFrame is empty!\n'
+            output += self.index.__repr__()
+            return output
+
+        output = 'Index: %s entries, %s to %s\n' % (len(self.index),
+                                                    min(self.index),
+                                                    max(self.index))
+        output += 'Columns:\n'
+        series = self._series
+        skeys = sorted(series.keys())
+        space = max([len(str(k)) for k in skeys]) + 4
+        for k in skeys:
+            out = _pfixed(k, space)
+            N = notnull(series[k]).sum()
+            out += '%d  non-null values\n' % N
+            output += out
+        if to_stdout:
+            print output
+        else:
+            return output
+
+    def rows(self):
+        """Alias for the frame's index"""
+        return self.index
+
+    def cols(self):
+        """Return sorted list of frame's columns"""
+        return sorted(self._series.keys())
+
+    # For DataMatrix compatibility
+    columns = property(lambda self: Index(self.cols()))
+
+    def iteritems(self):
+        """Iterator over (column, series) pairs"""
+        return self._series.iteritems()
+
+    def append(self, otherFrame):
+        """
+        Append columns of otherFrame to end of this frame's columns and index.
+
+        Columns not in this frame are added as new columns.
+        """
+        newIndex = np.concatenate((self.index, otherFrame.index))
+        newValues = {}
+        for column, series in self.iteritems():
+            if column in otherFrame:
+                newValues[column] = series.append(otherFrame[column])
+            else:
+                newValues[column] = series
+        for column, series in otherFrame.iteritems():
+            if column not in self:
+                newValues[column] = series
+        return DataFrame(data=newValues, index=newIndex)
+
+    def asfreq(self, freq, fillMethod = None):
+        """
+        Convert all TimeSeries inside to specified frequency using DateOffset
+        objects. Optionally provide fill method to pad/backfill/interpolate
+        missing values.
+
+        Parameters
+        ----------
+        offset: DateOffset object, or string in {'WEEKDAY', 'EOM'}
+            DateOffset object or subclass (e.g. monthEnd)
+
+        fillMethod: {'backfill', 'pad', 'interpolate', None}
+                    Method to use for filling holes in new inde
+        """
+        if not isinstance(freq, datetools.DateOffset):
+            raise Exception('Must pass DateOffset!')
+
+        dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        
+        return self.reindex(dateRange, fillMethod=fillMethod)
+
+    def asMatrix(self, columns=None):
+        """
+        Convert the frame to its Numpy-array matrix representation
+
+        Columns are presented in sorted order unless a specific list
+        of columns is provided.
+        """
+        if columns is None:
+            return np.array([self[col] for col in self.cols()]).T
+        else:
+            return np.array([self[col] for col in columns]).T
+
+    # For DataMatrix compatibility
+    values = property(asMatrix)
+
+    def copy(self, deep=False):
+        """
+        Make a shallow copy of this frame
+
+        Copies series dict but does not copy data / index.
+        """
+        newFrame = DataFrame(index=self.index)
+        newFrame._series = dict((k, v.copy())
+                                for k, v in self._series.iteritems())
+        return newFrame
+
+    def corr(self):
+        """
+        Compute correlation of columns. Returns DataFrame of result matrix.
+
+        In the presence of NaN values in any column, tries to compute the
+        pairwise correlation between the column and the other columns.
+        """
+        cols = self.columns
+        mat = self.asMatrix(cols).T
+        baseCov = np.cov(mat)
+
+        sigma = np.sqrt(np.diag(baseCov))
+        correl = baseCov / np.outer(sigma, sigma)
+
+        # Get the covariance with items that have NaN values
+        for i, A in enumerate(mat):
+            bada = np.isnan(A)
+            if np.any(bada):
+                for j, B in enumerate(mat):
+                    commonVec = (- bada) & (- np.isnan(B))
+                    if any(commonVec):
+                        ac, bc = A[commonVec], B[commonVec]
+                        c = np.corrcoef(ac, bc)[0, 1]
+                        correl[i, j] = c
+                        correl[j, i] = c
+
+        return self.fromMatrix(correl, cols, cols)
+
+    def dropEmptyRows(self, specificColumns=None):
+        """
+        Return DataFrame with rows omitted containing ALL NaN values
+        for optionally specified set of columns.
+
+        Parameters
+        ----------
+        specificColumns: list-like, optional keyword
+            Columns to consider in removing NaN values. As a typical
+            application, you might provide the list of the columns involved in
+            a regression to exlude all the missing data in one shot.
+
+        Returns
+        -------
+        This DataFrame with rows containing any NaN values deleted
+        """
+        newIndex = self.index[self.count(1) != 0]
+        return self.reindex(newIndex)
+
+    def dropIncompleteRows(self, specificColumns=None, minObs=None):
+        """
+        Return DataFrame with rows omitted containing ANY NaN values for
+        optionally specified set of columns.
+
+        Parameters
+        ----------
+        minObs: int or None (default)
+           Instead of requiring all the columns to have observations, require
+           only minObs observations
+        specificColumns: list-like, optional keyword
+            Columns to consider in removing NaN values. As a typical
+            application, you might provide the list of the columns involved in
+            a regression to exlude all the missing data in one shot.
+
+        Returns
+        -------
+        This DataFrame with rows containing any NaN values deleted
+        """
+        N = len(self._series)
+
+        if specificColumns:
+            colSet = set(specificColumns)
+            intersection= set(self.cols()) & colSet
+
+            N = len(intersection)
+
+            #if len(cols) < N:
+                #diff = str(set(specificColumns) - set(cols))
+                #raise Exception('Missing columns: %s' % diff)
+
+            filtered = self.filterItems(intersection)
+            theCount = filtered.count(axis=1, asarray=True)
+        else:
+            theCount = self.count(axis=1, asarray=True)
+
+        if minObs is None:
+            minObs = N
+
+        newIndex = self.index[theCount >= N]
+        return self.reindex(newIndex)
+
+    def fill(self, value=None, method='pad'):
+        """
+        Fill NaN values using the specified method.
+
+        Member Series / TimeSeries are filled separately.
+
+        Parameters
+        ----------
+        method: {'backfill', 'pad', None}
+            Method to use for filling holes in new inde
+
+        value: any kind (should be same type as array)
+            Value to use to fill holes (e.g. 0)
+
+        Returns
+        -------
+        DataFrame with NaN's filled
+
+        See also
+        --------
+        reindex, asfreq
+        """
+        mycopy = self.copy()
+        for col in mycopy._series.keys():
+            series = mycopy._series[col]
+            filledSeries = series.fill(method=method, value=value)
+            mycopy._series[col] = filledSeries
+
+        return mycopy
+
+    def getTS(self, colName=None, fromDate=None, toDate=None, nPeriods=None):
+        """
+        Return a DataFrame / TimeSeries corresponding to given arguments
+
+        Parameters
+        ----------
+        colName: particular column name requested
+        fromDate: datetime
+        toDate: datetime
+        nPeriods: int/float
+
+        NOTE: Error thrown if all of fromDate, toDate, nPeriods specified.
+        """
+        if toDate:
+            if toDate not in self.index:
+                if toDate > self.index[0]:
+                    toDate = self.index.asOfDate(toDate)
+                else:
+                    raise Exception('End date after last date in this index!')
+        if fromDate:
+            if fromDate not in self.index:
+                if fromDate < self.index[-1]:
+                    fromDate = self.index.asOfDate(fromDate)
+                else:
+                    raise Exception('Begin date after last date in this index!')
+        if fromDate and toDate:
+            if nPeriods:
+                raise Exception('fromDate/toDate, toDate/nPeriods, ' + \
+                                ' fromDate/nPeriods are mutually exclusive')
+            beg_slice = self.index.indexMap[fromDate]
+            end_slice = self.index.indexMap[toDate] + 1
+        elif fromDate and nPeriods:
+            beg_slice = self.index.indexMap[fromDate]
+            end_slice = self.index.indexMap[fromDate] + nPeriods
+        elif toDate and nPeriods:
+            beg_slice = self.index.indexMap[toDate] - nPeriods + 1
+            end_slice = self.index.indexMap[toDate] + 1
+        else:
+            raise Exception('Not enough arguments provided to getTS')
+
+        # Fix indices in case they fall out of the boundaries
+        beg_slice = max(0, beg_slice)
+        end_slice = min(len(self.index), end_slice)
+        dateRange = self.index[beg_slice:end_slice]
+
+        if colName:
+            return self[colName][beg_slice:end_slice]
+        else:
+            newColumns = {}
+            for col, series in self.iteritems():
+                newColumns[col] = series[beg_slice:end_slice]
+            return DataFrame(data=newColumns, index=dateRange)
+
+    def truncate(self, before = None, after = None):
+        """
+        Placeholder for documentation
+        """
+        import bisect
+
+        before = to_datetime(before)
+        after = to_datetime(after)
+
+        if before is not None:
+            binsearch = bisect.bisect_left(self.index, before)
+            cur = self.index[binsearch]
+            next = self.index[min(binsearch + 1, len(self.index) - 1)]
+            leftDate = cur if cur >= before else next
+        else:
+            leftDate = self.index[0]
+
+        if after is not None:
+            if after < self.index[-1]:
+                binsearch = bisect.bisect_right(self.index, after)
+                cur = self.index[binsearch]
+                prior = self.index[max(binsearch - 1, 0)]
+                rightDate = cur if cur <= after else prior
+            else:
+                rightDate = self.index[-1]
+        else:
+            rightDate = self.index[-1]
+
+        return self.getTS(fromDate=leftDate, toDate=rightDate)
+
+    def getXS(self, key, subset=None, asOf=False):
+        """
+        Returns a row from the DataFrame as a Series object.
+
+        Parameters
+        ----------
+        key: some index contained in the index
+        subset: iterable (list, array, set, etc.), optional
+            columns to be included
+        asOf: boolean, optional
+            Whether to use asOf values for TimeSeries objects
+            Won't do anything for Series objects.
+
+        Note
+        ----
+        Will try to return a TimeSeries if the columns are dates.
+        """
+        subset = np.unique(subset) if subset else np.unique(self._series.keys())
+
+        rowValues = [self._series[k].get(key) for k in subset]
+
+        if len(set(map(type, rowValues))) > 1:
+            return Series(np.array(rowValues, dtype=np.object_), index=subset)
+        else:
+            return Series(np.array(rowValues), index=subset)
+
+    def pivot(self, index=None, columns=None, values=None):
+        """
+        Produce 'pivot' table based on 3 columns of this DataFrame.
+        Uses unique values from index / columns and fills with values.
+
+        Parameters
+        ----------
+        index: string or object
+            Column name to use to make new frame's index
+        columns: string or object
+            Column name to use to make new frame's columns
+        values: string or object
+            Column name to use for populating new frame's values
+        """
+        from itertools import izip
+        tree = {}
+        for i, (idx, col) in enumerate(izip(self[index], self[columns])):
+            if col not in tree:
+                tree[col] = {}
+            branch = tree[col]
+            branch[idx] = self[values][i]
+
+        return self.fromDict(tree)
+
+    def reindex(self, newIndex, fillMethod = None):
+        """
+        Reindex data inside, optionally filling according to some rule.
+
+        Parameters
+        ----------
+        newIndex:   array-like
+            preferably an Index object (to avoid duplicating data)
+        fillMethod: {'backfill', 'pad', 'interpolate', None}
+            Method to use for filling holes in reindexed DataFrame
+        """
+        if newIndex is self.index:
+            return self
+
+        if len(newIndex) == 0:
+            return DataFrame(index=NULL_INDEX)
+
+        if not isinstance(newIndex, Index):
+            newIndex = Index(newIndex)
+
+        if len(self.index) == 0:
+            return DataFrame(index=newIndex)
+
+        selfM = self.asMatrix()
+
+        oldMap = self.index.indexMap
+        newMap = newIndex.indexMap
+
+        if not fillMethod:
+            fillMethod = ''
+
+        fillMethod = fillMethod.upper()
+
+        if fillMethod not in ['BACKFILL', 'PAD', '']:
+            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
+
+        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap,
+                                           newMap, fillMethod)
+
+        tmpMatrix = selfM[fillVec]
+        tmpMatrix[-mask] = NaN
+
+        return DataFrame(data=dict([(col, tmpMatrix[:, j])
+                                        for j, col in enumerate(self.cols())]),
+                                        index=newIndex)
+
+    @property
+    def T(self):
+        """
+        Returns a DataFrame with the rows/columns switched.
+        """
+        # Need to do some 'type inference' to avoid casting
+        # float to string in weird cases
+        dtypes = list(set([x.dtype for x in self._series.values()]))
+        if len(dtypes) > 1:
+            theDtype = np.object_
+        else:
+            theDtype = dtypes[0]
+
+        selfM = np.array([self[col] for col in self.cols()], dtype=theDtype)
+        idxMap = self.index.indexMap
+        return DataFrame(data=dict([(idx, selfM[:, idxMap[idx]])
+                                        for idx in self.index]),
+                                        index=Index(self.cols()))
+
+    def diff(self, periods = 1):
+        temp = self.values
+        temp = temp[periods:] - temp[:-periods]
+        return self.fromMatrix(temp, self.cols(), self.index[periods:])
+
+    def shift(self, periods, offset=None):
+        """
+        Shift the underlying series of the DataFrame and Series objects within
+        by given number (positive or negative) of business/weekdays.
+
+        Note, nan values inserted at beginning of series.
+        """
+        if periods == 0:
+            return self
+
+        if offset is None:
+            if periods > 0:
+                newIndex = self.index[periods:]
+                newValues = dict([(col, np.asarray(series)[:-periods])
+                                   for col, series in self.iteritems()])
+            else:
+                newIndex = self.index[:periods]
+                newValues = dict([(col, np.asarray(series)[-periods:])
+                                   for col, series in self.iteritems()])
+        else:
+            offset = periods * offset
+            newIndex = Index([idx + offset for idx in self.index])
+            newValues = dict([(col, np.asarray(series))
+                               for col, series in self.iteritems()])
+        return DataFrame(data = newValues, index= newIndex)
+
+    def apply(self, func):
+        """
+        Applies func to columns (Series) of this DataFrame and returns either
+        a DataFrame (if the function produces another series) or a Series
+        indexed on the column names of the DataFrame if the function produces
+        a value.
+
+        Parameters
+        ----------
+        func: function
+            Function to apply to each column
+
+        Example
+        -------
+
+            >>> df.apply(numpy.sqrt) --> DataFrame
+            >>> df.apply(numpy.sum) --> Series
+
+        N.B.: Do NOT use functions that might toy with the index.
+        """
+        if not len(self.cols()):
+            return self
+
+        results = {}
+        for col, series in self.iteritems():
+            result = func(series)
+
+            # WORKAROUND FOR NUMPY/SCIPY FUNCTIONS RETURNING UNSIZED NDARRAY
+            if isinstance(result, np.ndarray) and result.ndim == 0:
+                result = result.item()
+
+            results[col] = result
+
+        if hasattr(results.values()[0], '__iter__'):
+            return DataFrame(data=results, index=self.index)
+        else:
+            newIndex = Index(np.unique(np.asarray(results.keys(),
+                                                  dtype=object)))
+
+            arr = np.array([results[idx] for idx in newIndex])
+
+            return Series(arr, index=newIndex)
+
+    def tapply(self, func):
+        """
+        Apply func to the transposed DataFrame, results as per apply
+        """
+        return self.T.apply(func)
+
+    def applymap(self, func):
+        """
+        Apply a function to a DataFrame that is intended to operate elementwise
+
+        Please try to use apply if possible
+
+        Parameters
+        ----------
+        func: function
+            Python function to apply to each element
+        """
+        results = {}
+        for col, series in self.iteritems():
+            results[col] = map(func, series)
+        return DataFrame(data=results, index=self.index)
+
+    def filterItems(self, items):
+        """
+        Restrict frame's columns to input set of items.
+
+        Parameters
+        ----------
+        items: list-like
+            List of columns to restrict to (must not all be present)
+
+        Returns
+        -------
+        DataFrame with filtered columns
+        """
+        data = dict([(r, self[r]) for r in items if r in self])
+        return DataFrame(data=data, index=self.index)
+
+    def stack(self, indexCombineFunc= (lambda x, y: str(y.toordinal())+';'+x)):
+        """
+        Converts a DataFrame object with columns [col1, col2, ..., colN] and
+        indices [idx1, ... idxT] into a series with indices [col1:idx1,
+        col1:idx2, ... colN:idxT]
+
+        For doing pooled cross-sectional regressions.
+        """
+        cols = self.cols()
+        mat = self.asMatrix()
+
+        newIndices = {}
+        for i, index in enumerate(self.index):
+            theOrd = str(index.toordinal()) + ';'
+            newIndices[i] = [theOrd + col for col in cols]
+
+        N = len(self.index)
+
+        newIndex = np.concatenate([newIndices[i] for i in xrange(N)])
+        newValues = np.concatenate([mat[i, :] for i in xrange(N)])
+
+        return Series(newValues, index=newIndex)
+
+    def sortUp(self, column=None):
+        """
+        Sort DataFrame in ascending order according to specified column,
+        otherwise by the index.
+        """
+        if column:
+            series = self[column].order(missingAtEnd=True)
+            return self.reindex(series.index)
+        else:
+            idx = np.array(np.argsort(self.index))
+            newIndex = self.index[idx.astype(int)]
+            return self.reindex(newIndex)
+
+    def sortDown(self, column=None):
+        """
+        Sort DataFrame in ascending order according to specified column,
+        otherwise by the index.
+        """
+        if column:
+            series = self[column].order(missingAtEnd=False)
+            return self.reindex(series.index[::-1])
+        else:
+            idx = np.array(np.argsort(self.index))
+            idx = idx[::-1]  # Reverses array
+            newIndex = self.index[idx.astype(int)]
+            return self.reindex(newIndex)
+
+    def filterLike(self, arg):
+        """
+        Filter to columns partially matching the import argument.
+
+        Keep columns where "arg in col == True"
+
+        Parameter
+        ---------
+        arg: string
+
+        Return
+        ------
+        DataFrame with matching columns
+        """
+        mycopy = self.copy()
+        for col in mycopy._series.keys():
+            series = mycopy._series.pop(col)
+            if arg in col:
+                mycopy._series[col] = series
+        return mycopy
+
+    def combineFirst(self, otherFrame):
+        """
+        Combine two DataFrame / DataMatrix objects and default to value
+        in frame calling the method.
+
+        Example: a.combineFirst(b)
+            a's values prioritized, use values from b to fill holes
+
+        Parameters
+        ----------
+        otherFrame: DataFrame / Matrix
+
+        Returns
+        -------
+        DataFrmae
+        """
+        if not otherFrame:
+            return self
+
+        if not self:
+            return otherFrame
+
+        if self.index is not otherFrame.index:
+            unionIndex = self.index + otherFrame.index
+            frame = self.reindex(unionIndex)
+            otherFrame = otherFrame.reindex(unionIndex)
+        else:
+            unionIndex = self.index
+            frame = self
+
+        result = {}
+        for col, series in frame.iteritems():
+            otherSeries = otherFrame[col] if col in otherFrame else None
+            if otherSeries is not None:
+                result[col] = series.__class__(np.where(isnull(series),
+                                                        otherSeries, series),
+                                               index=unionIndex)
+            else:
+                result[col] = series
+
+        for col, series in otherFrame.iteritems():
+            if col not in self:
+                result[col] = series
+
+        return DataFrame(result, index = unionIndex)
+
+    def combineAdd(self, otherFrame):
+        """
+        Add two DataFrame / DataMatrix objects and do not propagate NaN values,
+        so if for a (column, time) one frame is missing a value, it will
+        default to the other frame's value (which might be NaN as well)
+
+        Parameters
+        ----------
+        otherFrame: DataFrame / Matrix
+
+        Returns
+        -------
+        DataFrame
+        """
+        if not otherFrame:
+            return self
+
+        if not self:
+            return otherFrame
+
+        if self.index is not otherFrame.index:
+            unionIndex = self.index + otherFrame.index
+            frame = self.reindex(unionIndex)
+            otherFrame = otherFrame.reindex(unionIndex)
+        else:
+            unionIndex = self.index
+            frame = self
+
+        unionCols = sorted(set(frame.cols() + otherFrame.cols()))
+
+        result = {}
+        for col in unionCols:
+            if col in frame and col in otherFrame:
+                series = frame[col].view(np.ndarray)
+                otherSeries = otherFrame[col].view(np.ndarray)
+                sok = np.isfinite(series)
+                ook = np.isfinite(otherSeries)
+
+                result[col] = np.where(sok & ook, series + otherSeries,
+                                       np.where(sok, series, otherSeries))
+
+            elif col in frame:
+                result[col] = frame[col]
+            elif col in otherFrame:
+                result[col]= otherFrame[col]
+            else:
+                raise Exception('Phantom column, be very afraid')
+
+        return DataFrame(result, index = unionIndex)
+
+    def combineMult(self, otherFrame):
+        return (self * otherFrame).combineFirst(self)
+
+    def outerJoin(self, *frames):
+        mergedSeries = self._series.copy()
+
+        unionIndex = self.index
+        for frame in frames:
+            unionIndex  = unionIndex + frame.index
+
+        for frame in frames:
+            for col, series in frame.iteritems():
+                if col in mergedSeries:
+                    raise Exception('Overlapping columns!')
+                mergedSeries[col] = series
+
+        return DataFrame.fromDict(mergedSeries)
+
+    def leftJoin(self, *frames):
+        """
+        Insert columns of input DataFrames / dicts into this one.
+
+        Columns must not overlap. Returns a copy.
+
+        Parameters
+        ----------
+        *frames: list-like
+            List of frames (DataMatrix or DataFrame) as function arguments
+
+        Returns
+        -------
+        DataFrame
+        """
+        mergedSeries = DataFrame(index=self.index)
+        mergedSeries._series = self._series.copy()
+
+        for frame in frames:
+            for col, series in frame.iteritems():
+                if col in mergedSeries:
+                    raise Exception('Overlapping columns!')
+                mergedSeries[col] = series
+
+        return mergedSeries
+
+    def merge(self, otherFrame, on):
+        """
+        Merge DataFrame or DataMatrix with this one on some many-to-one index
+
+        Parameters
+        ----------
+        otherFrame: DataFrame
+            Index should be similar to one of the columns in this one
+        on: string
+            Column name to use
+
+        Example
+        -------
+        This frame         Other frame
+            c1                 q1
+        a   1              0   v1
+        b   0              1   v2
+        c   1
+        d   0
+        """
+        if len(otherFrame.index) == 0:
+            return self
+
+        if on not in self:
+            raise Exception('%s column not contained in this frame!' % on)
+
+        otherM = otherFrame.asMatrix()
+        indexMap = otherFrame.index.indexMap
+
+        fillVec, mask = tseries.getMergeVec(self[on], indexMap)
+
+        tmpMatrix = otherM[fillVec]
+        tmpMatrix[-mask] = NaN
+
+        seriesDict = dict((col, tmpMatrix[:, j])
+                           for j, col in enumerate(otherFrame.cols()))
+
+        filledFrame = DataFrame(data=seriesDict, index=self.index)
+
+        return self.leftJoin(filledFrame)
+
+    def plot(self, kind='line', **kwds):
+        """
+        Plot the DataFrame's series with the index on the x-axis using
+        matplotlib / pylab.
+
+        Params
+        ------
+        kind: {'line', 'bar', 'hist'}
+            Default: line for TimeSeries, hist for Series
+
+        kwds: other plotting keyword arguments
+
+        NOTE: This method doesn't make much sense for cross-sections,
+        and will error.
+        """
+        try:
+            plot
+        except:
+            from pylab import plot
+
+        for col in sorted(self.columns):
+            s = self[col]
+            plot(s.index, s, label=col)
+
+    # ndarray-like stats methods
+    def count(self, axis=0, asarray=False):
+        """
+        Return array or Series of # observations over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        theCount = np.isfinite(self.values).sum(axis)
+        if asarray:
+            return theCount
+        else:
+            if axis == 0:
+                return Series(theCount, index=self.columns)
+            elif axis == 1:
+                return Series(theCount, index=self.index)
+            else:
+                raise Exception('Must have 0<= axis <= 1')
+
+    def sum(self, axis=0, asarray=False):
+        """
+        Return array or Series of sums over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        y = np.array(self.values, subok=True)
+        if not issubclass(y.dtype.type, np.int_):
+            y[np.isnan(y)] = 0
+        theSum = y.sum(axis)
+        theCount = self.count(axis)
+        theSum[theCount==0] = NaN
+        if asarray:
+            return theSum
+        if axis == 0:
+            return Series(theSum, index=self.columns)
+        elif axis == 1:
+            return Series(theSum, index=self.index)
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    def product(self, axis=0, asarray=False):
+        """
+        Return array or Series of products over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        y = np.array(self.values, subok=True)
+        if not issubclass(y.dtype.type, np.int_):
+            y[np.isnan(y)] = 1
+        theProd = y.prod(axis)
+        theCount = self.count(axis)
+        theProd[theCount==0] = NaN
+        if asarray:
+            return theProd
+        if axis == 0:
+            return Series(theProd, index=self.columns)
+        elif axis == 1:
+            return Series(theProd, index=self.index)
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    def mean(self, axis=0):
+        """
+        Return array or Series of means over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        return self.sum(axis) / self.count(axis, asarray=True).astype(float)
+
+    def median(self, axis=0):
+        """
+        Return array or Series of medians over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        if axis == 0:
+            med = [np.median(remove_na(self[col])) for col in self.columns]
+            return Series(med, index=self.columns)
+        elif axis == 1:
+            med = [np.median(remove_na(self.getXS(k))) for k in self.index]
+            return Series(med, index=self.index)
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    def var(self, axis=0, asarray=False):
+        """
+        Return array or Series of unbiased variance over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        y = np.array(self.values, subok=True)
+        mask = np.isnan(y)
+        count = (y.shape[axis] - mask.sum(axis)).astype(float)
+        y[mask] = 0
+
+        X = y.sum(axis)
+        XX = (y**2).sum(axis)
+
+        theVar = (XX - X**2 / count) / (count - 1)
+        if asarray:
+            return theVar
+        if axis == 0:
+            return Series(theVar, index=self.columns)
+        elif axis == 1:
+            return Series(theVar, index=self.index)
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    def std(self, axis=0, asarray=False):
+        """
+        Return array or Series of unbiased std deviation over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        return np.sqrt(self.var(axis=axis, asarray=asarray))
+
+    def skew(self, axis=0, asarray=False):
+        """
+        Return array or Series of unbiased skewness over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        y = np.array(self.values, subok=True)
+        mask = np.isnan(y)
+        count = (y.shape[axis] - mask.sum(axis)).astype(float)
+        y[mask] = 0
+
+        A = y.sum(axis) / count
+        B = (y**2).sum(axis) / count  - A**2
+        C = (y**3).sum(axis) / count - A**3 - 3*A*B
+
+        theSkew = (np.sqrt((count**2-count))*C) / ((count-2)*np.sqrt(B)**3)
+
+        if asarray:
+            return theSkew
+        if axis == 0:
+            return Series(theSkew, index=self.columns)
+        elif axis == 1:
+            return Series(theSkew, index=self.index)
+        else:
+            raise Exception('Must have 0<= axis <= 1')
+
+    # TODO
+    def kurtosis(self, axis=0):
+        """
+        Return array or Series of unbiased kurtosis over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        raise Exception('Not implemented yet!')
+
+def _pfixed(s, space, nanRep=None):
+    if isinstance(s, float):
+        fstring = '%-' + str(space-4) + 'g'
+        if nanRep is not None and isnull(s):
+            return nanRep.ljust(space)
+        return (fstring % s).ljust(space)
+    else:
+        return str(s)[:space-4].ljust(space)
+
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
new file mode 100644
index 000000000..1a6ba671d
--- /dev/null
+++ b/pandas/core/groupby.py
@@ -0,0 +1,377 @@
+import numpy as np
+
+from collections import defaultdict
+from cStringIO import StringIO
+
+from pandas.core.frame import DataFrame
+from pandas.core.matrix import DataMatrix
+from pandas.core.series import Series
+from pandas.lib.tseries import isnull
+
+def groupby_withnull(index, mapper):
+    index = np.asarray(index)
+    mapped_index = np.array([mapper(x) for x in index])
+
+    result = GroupDict(list)
+    
+    mask = isnull(mapped_index)
+    nullkeys = index[mask]    
+
+    if any(nullkeys):
+        result[np.NaN] = nullkeys
+    
+    notmask = -mask
+    index = index[notmask]
+    mapped_index = mapped_index[notmask]
+    
+    for idx, key in zip(index, mapped_index):
+        result[key].append(idx)
+        
+    return result
+
+class GroupDict(defaultdict):    
+    def __repr__(self):
+        stringDict = dict((str(x), x) for x in self)
+        sortedKeys = sorted(stringDict)
+        
+        maxLen = max(len(x) for x in stringDict)
+        
+        output = StringIO()
+        output.write(str(self.__class__))
+        
+        for k in sortedKeys:
+            key = stringDict[k]
+            size = len(self[key])
+            output.write('\n %s -> %d values' % (str(k).ljust(maxLen), size))
+        
+        return output.getvalue()
+    
+class GroupBy(object):
+    """
+    Class for grouping and aggregating relational data.
+    
+    Supported classes
+    -----------------
+    Series / TimeSeries
+    DataFrame / DataMatrix (and derivatives thereof)
+    """
+    _groups = None
+    def __new__(cls, obj, grouper):
+        """
+        Intercepts creation and dispatches to the appropriate class based
+        on type.
+        """
+        klass = None
+        
+        if isinstance(obj, Series):
+            klass = SeriesGroupBy
+        elif isinstance(obj, DataMatrix):
+            klass = DataMatrixGroupBy
+        elif isinstance(obj, DataFrame):
+            klass = DataFrameGroupBy
+            
+        return object.__new__(klass, obj, grouper)
+    
+    def __init__(self, obj, grouper):
+        self.obj = obj                    
+        if hasattr(grouper, 'get'):
+            grouper = grouper.get            
+        self.grouper = grouper
+
+    @property
+    def groups(self):
+        if self._groups is None:
+            self._groups = groupby_withnull(self.obj.index, self.grouper)
+
+        return self._groups            
+        
+    def getGroup(self, groupList):
+        return self.obj.reindex(groupList)
+    
+    def __iter__(self):        
+        """
+        Groupby iterator
+        
+        Yields
+        ------
+        Sequence of (groupName, subsetted object) for each group
+        """
+        for groupName, groupList in self.groups.iteritems():
+            yield groupName, self.getGroup(groupList)
+    
+    def aggregate(self, func):
+        raise NotImplementedError
+
+    def agg(self, func):
+        return self.aggregate(func)
+    
+    def transform(self, func):
+        raise NotImplementedError
+    
+    def apply(self, func):
+        return self.transform(func)
+
+    
+class SeriesGroupBy(GroupBy):
+    
+    def aggregate(self, applyfunc):
+        """
+        See doc for DataFrame.groupby, group series using mapper (dict or key
+        function, apply given function to group, return result as series).
+        
+        Main difference here is that applyfunc must return a value, so that the
+        result is a sensible series.
+        
+        Parameters
+        ----------
+        mapper: function 
+            Called on each element of the Series index to determine the groups
+        applyfunc: function 
+            Function to use to aggregate each group
+        
+        Returns
+        -------
+        Series or DataFrame
+        """
+        from pandas.lib.tseries import groupbyfunc as groupby
+        
+        if hasattr(applyfunc,'__iter__'):
+            results = {}
+        
+            for func in applyfunc:
+                result = self.aggregate(func)
+                
+                if isinstance(result, Series):
+                    raise Exception('Given applyfunc did not return a value '
+                                    'from the subseries as expected!')
+                
+                results[func.__name__] = result
+            
+            retVal = DataFrame.fromDict(results)
+        else:
+            try:
+                result = groupby(self.obj.index, self.obj, 
+                                 self.grouper, applyfunc)
+            except:
+                result = {}
+                theUnion = set([])
+                for groupName, groupList in self.groups.iteritems():
+                    groupList = list(groupList)
+                    theUnion.update(groupList)
+                    output = applyfunc(self.getGroup(groupList))
+                    
+                    if isinstance(output, Series):
+                        raise Exception('Given applyfunc did not return a '
+                                        'value from the subseries as expected!')
+
+                    result[groupName] = output
+                    
+                for missingIdx in (self.obj.index - list(theUnion)):
+                    result[missingIdx] = np.nan
+                    
+            retVal = Series.fromDict(result)
+            
+        return retVal
+
+    def transform(self, applyfunc):
+        """
+        For given Series, group index by given mapper function or dict, take
+        the sub-Series (reindex) for this group and call apply(applyfunc)
+        on this sub-Series. Return a Series of the results for each 
+        key.
+        
+        Note: this function does not aggregate like groupby/tgroupby,
+        the results of the given function on the subSeries should be another
+        Series.
+        
+        Parameters
+        ----------
+        mapper:    function which, on being called on each element of the Series
+                   index, determines the groups.
+        applyfunc: function to apply to each group
+
+        Example
+        -------
+        series.fgroupby(lambda x: mapping[x], 
+                        lambda x: (x - mean(x)) / std(x))    
+                    
+        Returns
+        -------
+        Series standardized by each unique value of mapping
+        """
+        
+        result = {}
+        for val, subseries in iter(self):
+            subseries.groupName = val
+            result[val] = applyfunc(subseries)
+
+        if not isinstance(result.values()[0], Series):
+            raise Exception('Given applyfunc did not return a Series from '
+                            ' the subseries as expected!')
+        
+        allSeries = {}
+        for val, subseries in result.iteritems():
+            allSeries.update(subseries.iteritems())
+        
+        return Series.fromDict(allSeries)
+    
+
+class DataFrameGroupBy(GroupBy):
+    def __init__(self, obj, grouper):
+        self.obj = obj
+                    
+        if hasattr(grouper, 'get'):
+            grouper = grouper.get
+
+        if isinstance(grouper, basestring) and grouper in obj:
+            grouper = obj[grouper].get
+        
+        self.grouper = grouper
+        
+    def aggregate(self, applyfunc):
+        """
+        For given DataFrame, group index by given mapper function or dict, take
+        the sub-DataFrame (reindex) for this group and call apply(applyfunc)
+        on this sub-DataFrame. Return a DataFrame of the results for each 
+        key.
+
+        Parameters
+        ----------
+        mapper: function, dict-like, or string
+            Mapping or mapping function. If string given, must be a column
+            name in the frame
+        applyfunc: function
+            Function to use for aggregating groups
+        
+        N.B.: applyfunc must produce one value from a Series, otherwise
+        an error will occur.
+        
+        Optional: provide set mapping as dictionary
+        """
+        result = {}
+        theUnion = set([])
+        for val, group in self.groups.iteritems():
+            groupList = list(group)
+            theUnion.update(groupList)
+            result[val] = self.getGroup(groupList).apply(applyfunc)
+            assert(isinstance(result[val], Series))
+        for missingIdx in (set(self.obj.index) - theUnion):
+            result[missingIdx] = np.repeat(np.nan, len(self.obj.cols()))
+        
+        return DataFrame(data=result).T
+    
+    def transform(self, applyfunc):
+        """
+        For given DataFrame, group index by given mapper function or dict, take
+        the sub-DataFrame (reindex) for this group and call apply(applyfunc)
+        on this sub-DataFrame. Return a DataFrame of the results for each 
+        key.
+
+        Note: this function does not aggregate like groupby/tgroupby,
+        the results of the given function on the subDataFrame should be another
+        DataFrame.
+
+        Parameters
+        ----------
+        mapper: function, dict-like, or string
+            Mapping or mapping function. If string given, must be a column
+            name in the frame
+        applyfunc: function
+            Function to apply to each subframe
+
+        Note
+        ----
+        Each subframe is endowed the attribute 'groupName' in case
+        you need to know which group you are working on.
+
+        Example
+        --------
+        df.fgroupby(lambda x: mapping[x], 
+                    lambda x: (x - x.apply(mean)) / x.apply(std))    
+
+            DataFrame standardized by each unique value of mapping
+        """
+        result = {}
+        for val, group in self.groups.iteritems():
+            subframe = self.obj.reindex(list(group))
+            subframe.groupName = val
+            result[val] = applyfunc(subframe).T
+        
+        allSeries = {}
+        for val, frame in result.iteritems():
+            allSeries.update(frame._series)
+        
+        return DataFrame(data=allSeries).T        
+
+
+class DataMatrixGroupBy(DataFrameGroupBy):
+    def aggregate(self, applyfunc):
+        """
+        Group series using mapper function (dict or key function, apply 
+        given function to group, return result as series)
+        
+        Main difference here is that applyfunc must return a value, so that the
+        result is a sensible series.
+        
+        Parameters
+        ----------
+        mapper: function, dict-like, or string
+            Mapping or mapping function. If string given, must be a column
+            name in the frame
+        applyfunc: function 
+            Function to use to aggregate each group
+        """
+        result = {}
+        theUnion = set([])
+        for val, group in self.groups.iteritems():
+            groupList = list(group)
+            theUnion.update(groupList)
+            result[val] = self.getGroup(groupList).apply(applyfunc)
+            assert(isinstance(result[val], Series))
+        for missingIdx in (set(self.obj.index) - theUnion):
+            result[missingIdx] = np.repeat(np.nan, len(self.obj.cols()))
+
+        return DataMatrix(data=result).T
+    
+    def transform(self, applyfunc):
+        """
+        For given DataMatrix, group index by given mapper function or dict, take
+        the sub-DataMatrix (reindex) for this group and call apply(applyfunc)
+        on this sub-DataMatrix. Return a DataMatrix of the results for each 
+        key.
+
+        Note: this function does not aggregate like groupby/tgroupby,
+        the results of the given function on the subDataMatrix should be another
+        DataMatrix.
+
+        Parameters
+        ----------
+        mapper: function
+            Function to apply to each index value
+        applyfunc: function
+            Function to apply to each subframe
+
+        Note
+        ----
+        Each subframe is endowed the attribute 'groupName' in case
+        you need to know which group you are working on.
+
+        Example
+        --------
+        df.fgroupby(lambda x: mapping[x], 
+                    lambda x: (x - x.apply(mean)) / x.apply(std))    
+
+        DataMatrix standardized by each unique value of mapping
+        """
+        result = {}
+        for val, group in self.groups.iteritems():
+            subframe = self.obj.reindex(list(group))
+            subframe.groupName = val
+            result[val] = applyfunc(subframe).T
+
+        allSeries = {}
+        for val, frame in result.iteritems():
+            allSeries.update(frame._series)
+            
+        return DataMatrix(data = allSeries).T
+
diff --git a/pandas/core/index.py b/pandas/core/index.py
new file mode 100644
index 000000000..3234f10f8
--- /dev/null
+++ b/pandas/core/index.py
@@ -0,0 +1,187 @@
+import numpy as np
+from pandas.lib.tdates import isAllDates
+from pandas.lib.tseries import map_indices
+
+
+class Index(np.ndarray):
+    """Extension of numpy-array to represent a series index, 
+    dates or otherwise.
+    
+    Index is immutable always (don't even try to change elements!).
+    
+    Note that the Index can ONLY contain immutable objects. Mutable objects are not
+    hashable, and that's bad!
+    """
+    _md5 = None
+    def __new__(cls, data, dtype=object, copy=False):
+        subarr = np.array(data, dtype=dtype, copy=copy)
+        
+        if subarr.ndim == 0:
+            raise Exception('Index(...) must be called with a collection '
+                            'of some kind, %s was passed' % repr(data))
+            
+        subarr = subarr.view(cls)
+        return subarr
+    
+    def __array_finalize__(self, obj):
+        if self.ndim == 0:
+            return self.item()
+
+        if len(self) > 0:
+            self.indexMap = map_indices(self)
+            
+            if hasattr(obj, '_allDates'):
+                self._allDates = obj._allDates
+            else:
+                self._allDates = isAllDates(self)
+        else:
+            self.indexMap = {}
+            self._allDates = False
+    
+    def __setstate__(self,state):
+        """Necessary for making this object picklable"""
+        np.ndarray.__setstate__(self,state)
+        self.indexMap = map_indices(self)
+        self._allDates = isAllDates(self)
+        
+    def __deepcopy__(self, memo={}):
+        """
+        Index is not mutable, so disabling deepcopy
+        """
+        return self
+        
+    def __contains__(self, date):
+        return date in self.indexMap
+        
+    def __setitem__(self, key, value):
+        """Disable the setting of values."""
+        raise Exception(str(self.__class__) + ' object is immutable' ) 
+
+    def __getitem__(self, key):
+        """Override numpy.ndarray's __getitem__ method to work as desired"""
+        result = self.view(np.ndarray)[key]
+        if isinstance(result, np.ndarray):
+            return Index(result)
+        else:
+            return result
+
+    def equals(self, other):
+        """
+        Determines if two Index objects contain the same elements.
+
+        If the compared object is of the right type and length, the MD5
+        checksum is compared
+        """
+        if self is other:
+            return True
+        
+        if not isinstance(other, np.ndarray):
+            return False
+
+        if len(self) != len(other):
+            return False
+
+        return self.getMD5() == other.getMD5()
+
+    def _computeMD5(self):
+        import hashlib
+        m = hashlib.md5(self.tostring())
+        return m.hexdigest()        
+    
+    def getMD5(self):
+        """
+        Return MD5 hex-digested hash for the Index elements. Note that
+        this quantity is only computed once.
+        """
+        if self._md5 is None:
+            self._md5 = self._computeMD5()
+            
+        return self._md5
+    
+    def asOfDate(self, date):
+        import bisect
+        
+        if date not in self.indexMap:
+            loc = bisect.bisect(self, date)
+            if loc > 0:
+                return self[loc-1]
+            else:
+                return None
+        return date
+        
+    def sort(self, *args, **kwargs):
+        raise Exception('Tried to sort an Index object, too dangerous to be OK!')
+
+    def __add__(self, other):
+        if isinstance(other, Index):
+            return self.union(other)
+        else:
+            return np.ndarray.__add__(self, other)
+
+    def union(self, other):
+        """
+        Form the union of two Index objects and sorts if possible
+        
+        Parameters
+        ----------
+        other: Index or array-like
+        
+        Returns
+        -------
+        Index
+        """
+        if not hasattr(other, '__iter__'):
+            raise Exception('Input must be iterable!')
+        
+        if other is self:
+            return self
+        newElts = filter(lambda x: x not in self.indexMap, other)
+        if len(newElts) > 0:
+            newSeq = np.concatenate((self, newElts))
+            try:
+                newSeq = np.unique(newSeq)
+            except:
+                # Not sortable / multiple types
+                pass
+            return Index(newSeq)
+        else:
+            return self
+    
+    def intersection(self, other):
+        """
+        Form the intersection of two Index objects and sorts if possible
+        
+        Parameters
+        ----------
+        other: Index or array-like
+        
+        Returns
+        -------
+        Index
+        """
+        if not hasattr(other, '__iter__'):
+            raise Exception('Input must be iterable!')
+
+        if other is self:
+            return self        
+        otherArr = np.asarray(other)
+        theIntersection = sorted(set(self) & set(other))
+        return Index(theIntersection)
+
+    def diff(self, other):
+        if not hasattr(other, '__iter__'):
+            raise Exception('Input must be iterable!')
+        
+        if other is self:
+            return Index([])
+
+        otherArr = np.asarray(other)
+        theDiff = sorted(set(self) - set(otherArr))
+        return Index(theDiff)
+    
+    __sub__ = diff
+
+# For utility purposes
+
+NULL_INDEX = Index([])
+        
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
new file mode 100644
index 000000000..b5d07df03
--- /dev/null
+++ b/pandas/core/matrix.py
@@ -0,0 +1,1630 @@
+from numpy import NaN
+import numpy as np
+
+from pandas.core.datetools import DateOffset
+from pandas.core.frame import DataFrame, _pfixed
+from pandas.core.index import Index, NULL_INDEX
+from pandas.core.series import Series, remove_na
+from pandas.lib.tseries import isnull, notnull
+import pandas.lib.tseries as tseries
+
+#-------------------------------------------------------------------------------
+# DataMatrix class
+
+class DataMatrix(DataFrame):
+    """
+    Matrix version of DataFrame, optimized for cross-section operations,
+    numerical computation, and other operations that do not require the 
+    frame to change size.
+    
+    Constructor params
+    ------------------
+    data: numpy ndarray or dict of Series
+        Constructor can understand various kinds of inputs
+    index: Index or array-like
+        Index to use for resulting frame (optional if provided dict of Series)
+    columns: Index or array-like
+    dtype: dtype, default=float
+        Data type to use 
+
+    Notes
+    -----
+    Transposing is much faster in this regime, as is calling getXS, so please
+    take note of this. 
+    """
+    values = None
+    _columns = None
+    _index = None
+    objects = None
+    def __init__(self, data=None, index=None, columns=None, dtype=None,
+                 objects=None):        
+
+        def handleDict(data, index, columns, objects, dtype):
+            """
+            Segregate Series based on type and coerce into matrices.
+            
+            Needs to handle a lot of exceptional cases.
+            """
+            if len(data) == 0:
+                if index is None:
+                    index = NULL_INDEX
+                values = np.empty((len(index), 0), dtype=dtype)
+                columns = NULL_INDEX
+            else:
+                if index is None:
+                    s = data.values()[0]
+                    if isinstance(s, Series):
+                        index = s.index
+                    else:
+                        index = Index(np.arange(len(s)))
+
+                if not isinstance(index, Index):
+                    index = Index(index)
+                        
+                objectDict = {}
+                if objects is not None:
+                    objectDict.update(objects)
+                
+                valueDict = {}
+                for k, v in data.iteritems():
+                    # Forces homogoneity
+                    if isinstance(v, Series):
+                        v = v.reindex(index) 
+                    else:
+                        assert(len(v) == len(index))
+                        v = Series(v, index=index)
+                    
+                    if issubclass(v.dtype.type, (float, int, bool)):
+                        valueDict[k] = v
+                    else:
+                        objectDict[k] = v
+                
+                if len(valueDict) == 0:
+                    dtype = np.object_
+                    valueDict = objectDict
+                else:
+                    dtype = np.float_
+                    if len(objectDict) > 0:
+                        objects = DataMatrix(objectDict, dtype=np.object_,
+                                             index=index)
+                    else:
+                        objects = None
+                
+                columns = Index(sorted(valueDict))
+                values = np.array([valueDict[k] for k in columns], 
+                                  dtype=dtype).T                  
+            
+            return index, columns, values, objects
+        
+        if isinstance(data, dict):
+            index, columns, values, objects = handleDict(data, index, 
+                                                         columns, objects, 
+                                                         dtype)
+        elif isinstance(data, np.ndarray):
+            if data.ndim == 1:
+                # Assume is only one column
+                data = data.reshape((data.shape[0], 1))
+            values = np.asarray(data)
+            
+        elif data is None:
+            if index is None:
+                values = np.empty((0, 0), dtype=dtype)
+                index = NULL_INDEX
+            else:
+                values = np.empty((len(index), 0), dtype=dtype)
+            columns = NULL_INDEX
+        else:
+            raise Exception('DataMatrix constructor not properly called!')
+        
+        if objects is not None:
+            if isinstance(objects, DataMatrix):
+                if objects.index is not index:
+                    self.objects = objects.reindex(index)
+            else:
+                objects = DataMatrix(objects, index=index)
+        
+        self.values = values
+        self.index = index
+        self.columns = columns
+        self.objects = objects
+    
+#-------------------------------------------------------------------------------
+# Alternate constructors
+
+    @classmethod
+    def fromDict(cls, inputDict={}, castFloat=True, **kwds):
+        """
+        Convert a two-level tree representation of a series or time series
+        to a DataMatrix.
+
+        tree is structured as:
+            {'col1' : {
+                idx1 : value1,
+                ...
+                idxn : valueN
+                    },
+            ...}
+        e.g. tree['returns'][curDate] --> return value for curDate
+
+        Parameters
+        ----------
+        input: dict object
+            Keys become column names of returned frame
+        kwds: optionally provide arguments as keywords
+
+        Example
+        -------
+        df1 = DataMatrix.fromDict(myDict)
+        df2 = DataMatrix.fromDict(A=seriesA, B=seriesB)
+        """
+        inputDict.update(kwds)
+        
+        # Get set of indices
+        indices = set([])
+        for key, branch in inputDict.iteritems():
+            indices = indices | set(branch.keys())
+        
+        index = Index(sorted(indices))
+        columns = Index(sorted(inputDict))
+        
+        if castFloat:
+            mat = np.empty((len(index), len(columns)), dtype=float)
+            
+            for j, col in enumerate(columns):
+                values = inputDict[col]
+                for i, idx in enumerate(index):
+                    mat[i, j] = values.get(idx, NaN)
+            return DataMatrix(data=mat, index=index, columns=columns)
+        else:
+            df = DataFrame.fromDict(inputDict, castFloat=False)
+            return df.toDataMatrix()
+
+    @classmethod
+    def fromMatrix(cls, mat, colNames, rowNames):        
+        """
+        Compatibility method for operations in DataFrame that use
+        fromMatrix.
+        
+        Parameters
+        ----------
+        mat: ndarray
+            Dimension T x N
+        colNames: iterable
+            Dimension N
+        rowNames: iterable
+            Dimension T
+        
+        Returns
+        -------
+        DataMatrix
+        
+        See also
+        --------
+        DataFrame.fromMatrix
+        """
+        rows, cols = mat.shape
+        try:
+            assert(rows == len(rowNames))
+            assert(cols == len(colNames))
+        except AssertionError:
+            raise Exception('Dimensions do not match: %s, %s, %s' % 
+                            (mat.shape, len(rowNames), len(colNames)))
+        
+        index = Index(rowNames)
+        colIndex = Index(colNames)
+                
+        idxMap = colIndex.indexMap
+        
+        return DataMatrix(mat, index=index, columns=colIndex)
+         
+    @classmethod
+    def load(cls, baseFile):
+        """
+        Load DataMatrix from file.
+        
+        Parameters
+        ----------
+        baseFile: string    
+            Filename base where index/values are stored.
+            e.g. baseFile='myfile' --> 'myfile_index.npy' and 
+                                       'myfile_values.npy'
+
+        Returns
+        -------
+        DataMatrix
+        """
+        import os
+        
+        objectsFile = baseFile + '_objects'
+        cacheLoad = np.load(baseFile + '.npz')
+                
+        if os.path.exists(objectsFile + '.npz'):
+            objectData = np.load(objectsFile + '.npz')        
+            objects = DataMatrix(objectData['v'], columns=objectData['c'], 
+                                 index=Index(objectData['i']))
+        else:
+            objects = None
+                
+        return DataMatrix(cacheLoad['v'], index=Index(cacheLoad['i']), 
+                          columns=cacheLoad['c'], objects=objects)
+
+    def save(self, baseFile):
+        """
+        Write DataFrame efficiently to file using NumPy serialization,
+        which is easily 100x faster than cPickle.
+
+        Note
+        ----
+        Saves data to 3 files, one for index, columns, and values matrix.
+        """        
+        
+        objectsFile = baseFile + '_objects'       
+        np.savez(baseFile, i=self.index, v=self.values, c=self.columns)
+        
+        if self.objects is not None and len(self.objects.columns) > 0:
+            self.objects.save(objectsFile)
+
+#-------------------------------------------------------------------------------
+# Outputting
+            
+    def toCSV(self, path=None, nanRep='', writeMode='wb', index=True, 
+              header=True, cols=None):
+        """
+        Write the DataMatrix to a CSV file
+
+        Parameters
+        ----------
+        path: string
+            Output file path
+        nanRep: string, default=''
+            Appearance of NaN values in output
+        index: boolean, default=True
+            Prints index if True
+        header: boolean, default=True
+            Prints header if True
+        cols: list of strings
+            Prints the values in order specified by cols.
+            By default, prints all columns in lexicographical order.
+        """
+        if path is None:
+            import sys
+            f = sys.stdout
+        else:
+            f = open(path, writeMode)
+        if cols is None:
+            cols = self.cols()
+        serDict = self._series
+
+        if header:
+            if index:
+                f.write(',')
+            f.write(','.join([str(c) for c in cols]))
+            f.write('\n')
+        for i, idx in enumerate(self.index):
+            if index:
+                f.write(str(idx) + ',')
+            for col in cols:
+                val = serDict[col].get(idx)
+                if isinstance(val, float) and np.isnan(val) == True:
+                    val = nanRep
+                else:
+                    val = str(val)
+                f.write(val + ',')
+            f.write('\n')
+        if path is not None:
+            f.close()
+        print 'CSV file written successfully: %s' % path
+
+    def toString(self, to_stdout=True, verbose=False, 
+                 colSpace=15, formatters=None):
+        """
+        Output a tab-separated version of this DataMatrix
+        """
+        from cStringIO import StringIO
+
+        output = StringIO()
+
+        if formatters is not None:
+            return self._toStringFormatted(formatters)
+        
+        mat = self.values
+        cols = self.columns
+        jinds = range(len(cols))
+        totaljinds = range(len(self.cols()))
+        
+        if self.objects is None:
+            obj_jinds = range(0)
+        else:
+            obj_jinds = range(len(self.objects.cols()))
+
+        idxSpace = max([len(str(idx)) for idx in self.index]) + 4
+        if len(self.cols()) == 0:
+            output.write('DataMatrix is empty!\n')
+            output.write(self.index.__repr__())
+
+        else:
+            output.write(_pfixed('', idxSpace))
+            for h in self.cols():
+                output.write(_pfixed(h, colSpace))
+          
+            output.write('\n')
+            
+            for i, idx in enumerate(self.index):
+                output.write(_pfixed(idx, idxSpace))
+                objcounter = 0
+                floatcounter = 0
+                for cName in self.cols():
+                    if cName in cols:
+                        vals = mat[i, floatcounter]
+                        output.write(_pfixed(vals, colSpace))
+                        floatcounter += 1
+                    else:
+                        vals = self.objects.values[i, objcounter]
+                        output.write(_pfixed(vals, colSpace))
+                        objcounter += 1
+                    
+                output.write('\n')
+                
+        if to_stdout:
+            print output.getvalue()
+        else:
+            return output.getvalue()
+        
+    def info(self, to_stdout=True):
+        """
+        Concise summary of a DataMatrix, used in __repr__ when very large.
+        """        
+        if len(self.columns) == 0:
+            output = 'DataMatrix is empty!\n'
+            output += repr(self.index)
+            return output
+
+        output = 'Index: %s entries, %s to %s\n' \
+                    % (len(self.index), self.index[0], self.index[-1])
+        output += 'Data columns:\n'
+        space = max([len(str(k)) for k in self.columns]) + 4
+        
+        isObjects = False
+        try:
+            counts = isfinite(self.values).sum(0)
+        except:
+            counts = np.repeat(self.values.shape[0], len(self.columns))
+            isObjects = True
+
+        columns = []
+        if isObjects:
+            for j, col in enumerate(self.columns):
+                columns.append('%s%d  non-null values' % 
+                               (_pfixed(col, space), counts[j]))
+        else:
+            for j, col in enumerate(self.columns):
+                columns.append('%s%d  non-null values' % 
+                               (_pfixed(col, space), counts[j]))
+    
+        if self.objects is not None and len(self.objects.columns) > 0:
+            n = len(self.objects.index)
+            for col in self.objects:
+                line = '%s%d  non-null values' % (_pfixed(col, space), n)
+                columns.append(line)
+        
+        columns.sort()
+        
+        dtypeLine = ''
+        
+        nf = len(self.columns)
+        df = self.values.dtype        
+        if self.objects is not None:
+            no = len(self.objects.columns)
+            do = self.objects.values.dtype
+            dtypeLine = '\ndtypes: %s(%d), %s(%d)' % (df, nf, do, no)
+        else:
+            dtypeLine = '\ndtype: %s(%d)' % (df, nf)
+        
+        output += '\n'.join(columns) + dtypeLine
+        
+        if to_stdout:
+            print output
+        else:
+            return output
+
+#-------------------------------------------------------------------------------
+# Properties for index and columns
+        
+    def _get_columns(self):
+        return self._columns
+
+    def _set_columns(self, cols):
+        if cols is None:
+            if self.values is not None and self.values.shape[1] > 0:
+                raise Exception('Columns cannot be None here!')
+            else:
+                self._columns = NULL_INDEX
+                return
+    
+        if len(cols) != self.values.shape[1]:
+            raise Exception('Columns length %d did not match values %d!' %
+                            (len(cols), self.values.shape[1]))
+        
+        if not isinstance(cols, Index):
+            cols = Index(cols)
+            
+        self._columns = cols
+    
+    columns = property(fget=_get_columns, fset=_set_columns)
+
+    def _set_index(self, index):
+        if index is None:
+            if self.values is not None and self.values.shape[0] > 0:
+                raise Exception('Index cannot be None here!')
+            else:
+                self._index = NULL_INDEX
+                return
+
+        if len(index) > 0:
+            if len(index) != self.values.shape[0]:
+                raise Exception('Index length %d did not match values %d!' %
+                                (len(index), self.values.shape[0]))
+            
+        if not isinstance(index, Index):
+            index = Index(index)
+            
+        self._index = index
+        
+    def _get_index(self):
+        return self._index
+    
+    index = property(fget=_get_index, fset=_set_index)
+
+#-------------------------------------------------------------------------------
+# "Magic methods"
+        
+    def __nonzero__(self):
+        if self.values is not None:
+            N, K = self.values.shape
+            if N == 0 or K == 0:
+                if self.objects is None:
+                    return False
+                else:
+                    return self.objects.__nonzero__()
+            else:
+                return True
+        else:
+            if self.objects is None:
+                return False
+            else:
+                return self.objects.__nonzero__()
+        
+    def __neg__(self):
+        mycopy = self.copy()
+        mycopy.values = -mycopy.values
+        return mycopy
+
+    def __repr__(self):
+        """Return a string representation for a particular DataMatrix"""
+        if self.values is None or len(self.values) == 0:
+            return 'Empty DataMatrix\nIndex: %s' % repr(self.index)
+        if len(self.index) < 1000 and self.values.shape[1] < 10:
+            output = self.toString(to_stdout=False)
+        else:
+            output = str(self.__class__) + '\n'
+            output = output + self.info(to_stdout=False)
+                
+        return output
+    
+    def __getitem__(self, item):
+        """
+        Retrieve column, slice, or subset from DataMatrix.
+        
+        Possible inputs
+        ---------------
+        single value: retrieve a column as a Series
+        slice: reindex to indices specified by slice
+        boolean vector: like slice but more general, reindex to indices
+          where the input vector is True
+        
+        Examples
+        --------
+        column = dm['A']
+        
+        dmSlice = dm[:20] # First 20 rows
+        
+        dmSelect = dm[dm.count(axis=1) > 10]
+        
+        Note
+        ----
+        This is a magic method. Do NOT call explicity. 
+        """
+        if isinstance(item, slice):
+            start, stop = item.start, item.stop
+            start = 0 if start is None else start
+            stop = len(self) if stop is None else stop
+            if start < 0:
+                start += len(self)
+            if stop < 0:
+                stop += len(self)
+
+            indexRange = self.index[start:stop]
+            if self.objects is not None:
+                newObjects = self.objects.reindex(indexRange)
+            else:
+                newObjects = None
+                
+            return DataMatrix(data=self.values[start:stop], index=indexRange,
+                              columns=self.columns, objects=newObjects)
+        elif isinstance(item, np.ndarray):
+            if len(item) != len(self.index):
+                raise Exception('Item wrong length %d instead of %d!' %
+                                (len(item), len(self.index)))
+            newIndex = self.index[item]
+            return self.reindex(newIndex)
+        else:
+            if self.objects is not None and item in self.objects:
+                return self.objects[item]
+            else:
+                return self._getSeries(item)
+    
+    _dataTypes = [np.float_, np.bool_, np.int_]
+    def __setitem__(self, key, value):
+        """
+        Add series to DataMatrix in specified column.
+
+        If series is a numpy-array (not a Series/TimeSeries), it must be the
+        same length as the DataMatrix's index or an error will be thrown.
+
+        Series/TimeSeries will be conformed to the DataMatrix's index to
+        ensure homogeneity. 
+        """
+        import bisect
+        
+        isObject = False
+        if hasattr(value, '__iter__'):
+            if isinstance(value, Series):
+                value = np.asarray(value.reindex(self.index))
+                
+            else:
+                assert(len(value) == len(self.index))
+                
+                if not isinstance(value, np.ndarray):
+                    value = np.array(value)
+                    if value.dtype.type == np.str_:
+                        value = np.array(value, dtype=object)
+        else:
+            try:
+                value = np.repeat(value, len(self.index))
+            except:
+                raise Exception('Could not put %s in the matrix!' % value)
+
+        if value.dtype not in self._dataTypes:
+            isObject = True
+            
+        if self.values is None:
+            if isObject:
+                if self.objects is None:
+                    self.objects = DataMatrix({key : value},
+                                              index=self.index)
+                else:
+                    self.objects[key] = value
+            else:
+                self.values = value.reshape((len(value), 1))
+                self.columns = Index([key])
+            return
+                
+        if self.values.dtype == np.object_:
+            if key in self.columns:
+                loc = self.columns.indexMap[key]
+                self.values[:, loc] = value
+            elif len(self.columns) == 0:
+                self.values = value.reshape((len(value), 1))
+                self.columns = Index([key])
+            else:
+                loc = bisect.bisect_right(self.columns, key)
+                if loc == self.values.shape[1]:
+                    newValues = np.c_[self.values, value]
+                    newColumns = Index(np.concatenate((self.columns, [key])))
+                elif loc == 0:
+                    newValues = np.c_[value, self.values]
+                    newColumns = Index(np.concatenate(([key], self.columns)))
+                else:
+                    newValues = np.c_[self.values[:, :loc], value, 
+                                      self.values[:, loc:]]
+                    toConcat = (self.columns[:loc], [key], self.columns[loc:])
+                    newColumns = Index(np.concatenate(toConcat))
+                self.values = newValues            
+                self.columns = newColumns
+        else:
+            if key in self.columns:
+                loc = self.columns.indexMap[key]
+                self.values[:, loc] = value
+            elif isObject:
+                if self.objects is None:
+                    self.objects = DataMatrix({key : value},
+                                              index=self.index)
+                else:
+                    self.objects[key] = value
+            elif len(self.columns) == 0:
+                self.values = value.reshape((len(value), 1)).astype(np.float)
+                self.columns = Index([key])
+            else:
+                loc = bisect.bisect_right(self.columns, key)
+                if loc == self.values.shape[1]:
+                    newValues = np.c_[self.values, value]
+                    newColumns = Index(np.concatenate((self.columns, [key])))
+                elif loc == 0:
+                    newValues = np.c_[value, self.values]
+                    newColumns = Index(np.concatenate(([key], self.columns)))
+                else:
+                    newValues = np.c_[self.values[:, :loc], value, 
+                                      self.values[:, loc:]]
+                    toConcat = (self.columns[:loc], [key], self.columns[loc:])
+                    newColumns = Index(np.concatenate(toConcat))
+                self.values = newValues
+                self.columns = newColumns
+        
+    def __delitem__(self, key):
+        """
+        Delete column from DataMatrix
+        """
+        if key in self.columns:
+            loc = self.columns.indexMap[key]
+            T, N = self.values.shape
+            if loc == N:
+                newValues = self.values[:, :loc]
+                newColumns = self.columns[:loc]
+            else:
+                newValues = np.c_[self.values[:, :loc], self.values[:, loc+1:]]
+                newColumns = Index(np.concatenate((self.columns[:loc], 
+                                                   self.columns[loc+1:])))
+            self.values = newValues
+            self.columns = newColumns
+        
+        if self.objects is not None and key in self.objects:
+            del self.objects[key]
+                
+    def __iter__(self):
+        """Iterate over columns of the frame."""
+        return iter(self.columns)
+
+    def __contains__(self, key):
+        """True if DataMatrix has this column"""
+        hasCol = key in self.columns
+        if hasCol:
+            return True
+        else:
+            if self.objects is not None and key in self.objects:
+                return True
+            return False
+
+    def iteritems(self):
+        return self._series.iteritems()
+
+#-------------------------------------------------------------------------------
+# Helper methods
+
+    # For DataFrame compatibility
+    def _getSeries(self, item=None, loc=None):
+        if loc is None:
+            try:
+                loc = self.columns.indexMap[item]
+            except KeyError:
+                raise Exception('%s not here!' % item)
+        return Series(self.values[:, loc], index=self.index)
+        
+    def _getSeriesDict(self):
+        series = {}
+        for i, col in enumerate(self.columns):
+            series[col] = self._getSeries(loc=i)
+        if self.objects is not None:
+            for i, col in enumerate(self.objects.columns):
+                series[col] = self.objects._getSeries(loc=i)
+                
+        return series
+    _series = property(_getSeriesDict)
+
+    def _firstTimeWithNValues(self):
+        # Need to test this!
+        N = len(self._series)        
+        selector = (self.count(1) == N)
+        if not selector.any():
+            raise Exception('No time has %d values!' % N)
+
+        return self.index[selector][0]
+
+    def _withColumns(self, newCols):
+        """
+        Utility method, force values matrix to have particular columns
+        Can make this as cute as we like
+        """
+        if len(newCols) == 0:
+            return DataMatrix(index=self.index)
+        
+        T, N = len(self.index), len(newCols)
+
+        resultMatrix = np.empty((T, N), dtype=self.values.dtype)
+        resultMatrix.fill(NaN)
+
+        if not isinstance(newCols, Index):
+            newCols = Index(newCols)
+
+        overlap = self.columns.intersection(newCols)
+        thisIndexer = [self.columns.indexMap[col] for col in overlap]
+        resultIndexer = [newCols.indexMap[idx] for idx in overlap]
+
+        resultMatrix[:, resultIndexer] = self.values[:, thisIndexer]
+        
+        return DataMatrix(resultMatrix, index=self.index, columns=newCols,
+                          objects=self.objects)
+
+    def _combineFrame(self, other, func):
+        """
+        Methodology, briefly
+        - Really concerned here about speed, space
+        
+        - Get new index
+        - Reindex to new index
+        - Determine newColumns and commonColumns
+        - Add common columns over all (new) indices
+        - Fill to new set of columns            
+        
+        Could probably deal with some Cython action in here at some point
+        """
+        if self.index is other.index:
+            newIndex = self.index
+            myReindex = self
+            hisReindex = other
+        else:
+            newIndex = self.index.union(other.index)                
+            myReindex = self.reindex(newIndex)
+            hisReindex = other.reindex(newIndex)
+
+        if not self and not other:
+            return DataMatrix(index=newIndex)
+        elif not self:
+            return other * NaN
+        elif not other:
+            return self * NaN
+            
+        myValues = myReindex.values
+        if self.columns is other.columns:
+            newCols = self.columns
+            commonCols = self.columns
+        else:
+            newCols = self.columns.union(other.columns)
+            commonCols = self.columns.intersection(other.columns)
+        hisValues = hisReindex.values
+        hisCols = hisReindex.columns
+
+        if len(newCols) == len(commonCols):
+            resultMatrix = func(myValues, hisValues)
+        else:
+            T, N = len(newIndex), len(newCols)
+            resultMatrix = np.empty((T, N), dtype=self.values.dtype)
+            resultMatrix.fill(NaN)
+                
+            myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
+            hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
+            resultIndexer = [newCols.indexMap[idx] for idx in commonCols]
+                
+            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer], 
+                                                  hisValues[:, hisIndexer])
+
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+
+    def _combineSeries(self, other, func):
+        newIndex = self.index
+        newCols = self.columns
+        if self.index._allDates and other.index._allDates:
+            # Operate row-wise
+            if self.index is other.index:
+                newIndex = self.index
+            else:
+                newIndex = self.index + other.index
+                
+            if not self:
+                return DataMatrix(index=newIndex)
+                
+            other = other.reindex(newIndex).view(np.ndarray)
+            myReindex = self.reindex(newIndex)
+            resultMatrix = func(myReindex.values.T, other).T
+        else:
+            if len(other) == 0:
+                return self * NaN
+            
+            # Operate column-wise
+            other = other.reindex(self.columns).view(np.ndarray)
+            resultMatrix = func(self.values, other)                
+        
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+
+    def _combineFunc(self, other, func):
+        """
+        Combine DataMatrix objects with other Series- or DataFrame-like objects
+        
+        This is the core method used for the overloaded arithmetic methods
+
+        Result hierarchy
+        ----------------
+        DataMatrix + DataFrame --> DataMatrix
+        DataMatrix + DataMatrix --> DataMatrix 
+        DataMatrix + Series --> DataMatrix
+        DataMatrix + constant --> DataMatrix
+
+        The reason for 'upcasting' the result is that if addition succeed,
+        we can assume that the input DataFrame was homogeneous. 
+        """
+        newIndex = self.index
+        if isinstance(other, DataFrame):
+            return self._combineFrame(other, func)
+        
+        elif isinstance(other, Series):
+            return self._combineSeries(other, func)
+
+        else:
+            if not self:
+                return self
+
+            # Constant of some kind
+            newCols = self.columns
+            try:
+                resultMatrix = func(self.values, other)
+            except:
+                raise Exception('Bad operator value: %s' % other)
+
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+
+#-------------------------------------------------------------------------------
+# Public methods
+
+    def asMatrix(self, columns=None):
+        """
+        Convert the DataMatrix to its Numpy-array matrix representation
+        
+        Columns are presented in sorted order unless a specific list
+        of columns is provided.
+        
+        Parameters
+        ----------
+        columns: list-like
+            columns to use in producing matrix, must all be contained
+            
+        Returns
+        -------
+        ndarray
+        """
+        if columns is None:
+            return self.values.copy()
+        else:
+            idxMap = self.columns.indexMap
+            indexer = [idxMap[col] for col in columns]
+            return self.values[:, indexer].copy()
+
+    def cols(self):
+        """Return sorted list of frame's columns"""
+        if self.objects is not None and len(self.objects.columns) > 0:
+            return list(self.columns.union(self.objects.columns))
+        else:
+            return list(self.columns)
+
+    def copy(self, deep=False):
+        """
+        Make a deep copy of this DataMatrix
+        """
+        if self.values is not None:
+            valsCopy = self.values.copy()
+        else:
+            valsCopy = None
+        return DataMatrix(valsCopy, index=self.index, 
+                          columns=self.columns, objects=self.objects)
+
+    def cumsum(self, axis=0, asarray=False):
+        """
+        Return DataMatrix of cumulative sums over requested axis.
+
+        Parameters
+        ----------
+        axis: {0, 1}
+            0 for row-wise, 1 for column-wise
+        asarray: boolean, default False
+            Choose to return as ndarray or have index attached
+        """
+        y = array(self.values, subok=True)
+        if not issubclass(y.dtype.type, np.int_):
+            y[np.isnan(self.values)] = 0
+        theSum = y.cumsum(axis)
+        if asarray:
+            return theSum
+        return DataMatrix(theSum, index=self.index, 
+                          columns=self.columns, objects=self.objects)
+
+    def dropEmptyRows(self, specificColumns=None):
+        """
+        Return DataMatrix with rows omitted containing ALL NaN values 
+        for optionally specified set of columns.
+
+        Parameters
+        ----------
+        specificColumns: list-like, optional keyword
+            Columns to consider in removing NaN values. As a typical 
+            application, you might provide the list of the columns involved in 
+            a regression to exclude all the missing data in one shot.
+
+        Returns
+        -------
+        DataMatrix with rows containing any NaN values deleted    
+        """
+        T, N = self.values.shape
+        
+        if specificColumns:
+            theCount = self.filterItems(specificColumns).count(axis=1,
+                                                               asarray=True)
+        else:
+            theCount = self.count(axis=1, asarray=True)
+
+        return self.reindex(self.index[theCount > 0])
+    
+    def dropIncompleteRows(self, specificColumns=None, minObs=None):
+        """
+        Return DataFrame with rows omitted containing ANY NaN values for 
+        optionally specified set of columns.
+    
+        Parameters
+        ----------
+        minObs: int or None (default)
+           Instead of requiring all the columns to have observations, require
+           only minObs observations
+        specificColumns: list-like, optional keyword
+            Columns to consider in removing NaN values. As a typical 
+            application, you might provide the list of the columns involved in 
+            a regression to exlude all the missing data in one shot.
+        
+        Returns
+        -------
+        This DataFrame with rows containing any NaN values deleted    
+        """
+        T, N = self.values.shape
+        if specificColumns:
+            cols = self.columns.intersection(specificColumns)
+            theCount = self.filterItems(cols).count(axis=1, asarray=True)
+            N = len(cols)
+        else:
+            theCount = self.count(axis=1, asarray=True)
+        
+        if minObs is None:
+            minObs = N
+
+        return self.reindex(self.index[theCount >= minObs])
+
+    def fill(self, value=None, method='pad'):
+        """
+        Fill NaN values using the specified method.
+
+        Member Series / TimeSeries are filled separately.
+        
+        Parameters
+        ----------        
+        value: any kind (should be same type as array)
+            Value to use to fill holes (e.g. 0)
+            
+        method: {'backfill', 'pad', None}
+            Method to use for filling holes in new inde
+        
+        Returns
+        -------
+        DataMatrix with NaN's filled
+            
+        See also
+        --------
+        reindex, asfreq
+        """
+        if value is None:
+            result = {}
+            for col in self._series:
+                series = self._series[col]
+                filledSeries = series.fill(method=method, value=value)
+    
+                result[col] = filledSeries            
+            return DataMatrix(result, index=self.index, objects=self.objects)
+        else:
+            def fillfunc(vec):
+                vec[isnull(vec)] = value
+                return vec
+
+            gotFloat = isinstance(value, (int, float))
+            if gotFloat and self.values.dtype == np.float64:
+                # Float type values
+                if len(self.columns) == 0:
+                    return self
+                
+                vals = self.values.copy()
+                vals[-np.isfinite(self.values)] = value
+                objectsToUse = None
+                if self.objects is not None:
+                    objectsToUse = self.objects.copy()
+                return DataMatrix(vals, index=self.index, columns=self.columns,
+                                  objects=objectsToUse)
+            
+            elif self.values.dtype == np.object_:
+                # Object type values
+                if len(self.columns) == 0:
+                    return self
+                
+                myCopy = self.copy()
+                                
+                vals = myCopy.values
+                myCopy.values = np.apply_along_axis(fillfunc, 0, vals)
+                
+                return myCopy
+            else:
+                # Object type values
+                if len(self.objects.columns) == 0:
+                    return self
+                
+                myCopy = self.copy()                    
+                vals = myCopy.objects.values
+                myCopy.objects.values = np.apply_along_axis(fillfunc, 0, vals)
+                
+                return myCopy    
+        
+    def getTS(self, colName=None, fromDate=None, toDate=None, nPeriods=None):
+        """
+        Return a DataMatrix / TimeSeries corresponding to given arguments
+
+        Parameters
+        ----------
+        colName: string or None 
+            particular column name requested, fine to leave blank
+        fromDate: datetime
+        toDate: datetime
+        nPeriods: int/float
+
+        Note
+        ----
+        Error thrown if all of fromDate, toDate, nPeriods specified.
+        
+        Returns
+        -------
+        DataMatrix or TimeSeries 
+        """
+        # Should use bisect in here
+        
+        if toDate:
+            if toDate not in self.index:
+                if toDate > self.index[0]:
+                    toDate = self.index.asOfDate(toDate)
+                else:
+                    raise Exception('End date after last date in this index!')
+        if fromDate:
+            if fromDate not in self.index:
+                if fromDate < self.index[-1]:
+                    fromDate = self.index.asOfDate(fromDate)
+                else:
+                    raise Exception('Begin date after last date in this index!')
+
+        if fromDate and toDate:
+            if nPeriods:
+                raise Exception('fromDate/toDate, toDate/nPeriods, ' +
+                                'fromDate/nPeriods are mutually exclusive')
+            beg_slice = self.index.indexMap[fromDate]    
+            end_slice = self.index.indexMap[toDate] + 1
+        elif fromDate and nPeriods:
+            beg_slice = self.index.indexMap[fromDate]
+            end_slice = self.index.indexMap[fromDate] + nPeriods
+        elif toDate and nPeriods:
+            beg_slice = self.index.indexMap[toDate] - nPeriods + 1
+            end_slice = self.index.indexMap[toDate] + 1
+        else:
+            raise Exception('Not enough arguments provided to getTS')
+
+        # Fix indices in case they fall out of the boundaries
+        beg_slice = max(0, beg_slice)
+        end_slice = min(len(self.index), end_slice)
+        dateRange = self.index[beg_slice:end_slice]
+
+        if colName:
+            return self[colName][beg_slice:end_slice]
+        else:
+            newValues = self.values[beg_slice:end_slice]
+
+            newLinks = None
+            if self.objects is not None and len(self.objects.columns) > 0:
+                newLinks = self.objects.reindex(dateRange)
+            
+            return DataMatrix(newValues, index=dateRange, 
+                              columns=self.columns, objects=newLinks)
+
+    def getXS(self, key, subset=None, asOf=False):
+        """
+        Returns a row from the DataMatrix as a Series object.
+
+        Parameters
+        ----------
+        key: some index contained in the index
+        subset: iterable (list, array, set, etc.), optional
+            columns to be included
+        asOf: boolean, optional
+            Whether to use asOf values for TimeSeries objects 
+            Won't do anything for Series objects.
+
+        Note
+        ----
+        Will try to return a TimeSeries if the columns are dates.
+        """
+        if key not in self.index:
+            raise Exception('No cross-section for %s' % key)
+        
+        loc = self.index.indexMap[key]
+        
+        if subset:
+            subset = np.unique(subset)
+            indexer = [self.columns.indexMap[col] for col in subset]
+            theSlice = self.values[loc, indexer].copy()
+            xsIndex = subset
+        else:
+            theSlice = self.values[loc, :].copy()
+            xsIndex = self.columns
+            
+        result = Series(theSlice, index=xsIndex)
+        
+        if self.objects is not None and len(self.objects.columns) > 0:
+            result = result.append(self.objects.getXS(key))
+        
+        return result
+
+    def merge(self, otherFrame, on=None):
+        """
+        Merge DataFrame or DataMatrix with this one on some many-to-one index
+        
+        Parameters
+        ----------
+        otherFrame: DataFrame
+            Index should be similar to one of the columns in this one
+        on: string
+            Column name to use
+        
+        Example
+        -------
+        This frame         Other frame
+            c1                 q1
+        a   1              0   v1  
+        b   0              1   v2
+        c   1
+        d   0
+        """
+        if len(otherFrame.index) == 0:
+            return self
+
+        if on not in self:
+            raise Exception('%s column not contained in this frame!' % on)
+        
+        otherM = otherFrame.asMatrix()
+        indexMap = otherFrame.index.indexMap
+        
+        fillVec, mask = tseries.getMergeVec(self[on], indexMap)
+
+        tmpMatrix = otherM[fillVec]
+        tmpMatrix[-mask] = NaN
+        
+        seriesDict = dict((col, tmpMatrix[:, j]) 
+                           for j, col in enumerate(otherFrame.columns))
+        
+        if getattr(otherFrame, 'objects'):
+            objects = otherFrame.objects
+            
+            objM = objects.asMatrix()
+            cols = objects.columns
+            
+            tmpMat = objM[fillVec]
+            tmpMat[-mask] = NaN
+            objDict = dict((col, tmpMat[:, j])
+                           for j, col in enumerate(objects.columns))
+            
+            seriesDict.update(objDict)
+        
+        filledFrame = DataFrame(data=seriesDict, index=self.index)
+        
+        return self.leftJoin(filledFrame)
+
+    def reindex(self, newIndex, fillMethod = None):
+        """
+        Reindex data inside, optionally filling according to some rule.
+
+        Parameters
+        ----------
+        newIndex:   array-like
+            preferably an Index object (to avoid duplicating data)
+        fillMethod: {'backfill', 'pad', 'interpolate', None}
+            Method to use for filling holes in reindexed DataFrame
+
+        Returns
+        -------
+        DataMatrix
+        """
+        if newIndex is self.index:
+            return self
+        
+        if len(newIndex) == 0:
+            return DataMatrix(index=NULL_INDEX)
+
+        if not isinstance(newIndex, Index):
+            newIndex = Index(newIndex)
+
+        if len(self.index) == 0:
+            return DataMatrix(index=newIndex)
+                    
+        selfM = self.values
+
+        oldMap = self.index.indexMap
+        newMap = newIndex.indexMap
+
+        if not fillMethod:
+            fillMethod = ''
+
+        fillMethod = fillMethod.upper()
+
+        if fillMethod not in ['BACKFILL', 'PAD', '']:
+            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
+
+        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap, 
+                                           newMap, fillMethod)
+
+        tmpMatrix = selfM[fillVec]
+        tmpMatrix[-mask] = NaN
+
+        if self.objects is not None and len(self.objects.columns) > 0:
+            newLinks = self.objects.reindex(newIndex)
+        else:
+            newLinks = None
+
+        return DataMatrix(tmpMatrix, index=newIndex, 
+                          columns=self.columns, objects=newLinks)
+
+    @property
+    def T(self):
+        """
+        Returns a DataMatrix with the rows/columns switched. 
+        """
+        if self.objects is not None:
+            objectsT = self.objects.values.T
+            valuesT = self.values.T
+            newValues = np.concatenate((valuesT, objectsT), axis=0)
+            newIndex = Index(np.concatenate((self.columns,
+                                             self.objects.columns)))
+            
+            return DataMatrix(newValues, index=newIndex, columns=self.index)
+        else:
+            return DataMatrix(data=self.values.T, index=self.columns,
+                              columns=self.index)
+
+    def shift(self, periods, offset=None):
+        """
+        Shift the underlying series of the DataMatrix and Series objects within 
+        by given number (positive or negative) of business/weekdays.
+
+        Parameters
+        ----------
+        periods: int (+ or -)
+            Number of periods to move
+        offset: DateOffset, optional
+            Increment to use from datetools module
+
+        Returns
+        -------
+        DataMatrix
+        """
+        if periods == 0:
+            return self
+
+        if offset is None:
+            if periods > 0:
+                newIndex = self.index[periods:]
+                newValues = self.values[:-periods].copy()
+            else:
+                newIndex = self.index[:periods]
+                newValues = self.values[-periods:].copy()
+        else:
+            offset = periods * offset
+            newIndex = Index([idx + offset for idx in self.index])
+            newValues = self.values.copy()
+        return DataMatrix(data=newValues, index=newIndex, columns=self.columns)
+
+    def apply(self, func, axis=0):
+        """
+        Applies func to columns (Series) of this DataMatrix and returns either
+        a DataMatrix (if the function produces another series) or a Series 
+        indexed on the column names of the DataFrame if the function produces
+        a value.
+
+        Parameters
+        ----------
+        func: function
+            Function to apply to each column
+        
+        Example
+        -------
+            
+            >>> df.apply(numpy.sqrt) --> DataMatrix
+            >>> df.apply(numpy.sum) --> Series
+
+        N.B.: Do NOT use functions that might toy with the index. 
+        """
+        if not len(self.cols()):
+            return self
+        
+        results = {}
+        
+        if isinstance(func, np.ufunc):
+            results = func(self.values)
+        else:
+            if axis == 0:
+                results = dict([(k, func(v)) for k, v in self.iteritems()])
+            elif axis == 1:
+                results = dict([(k, func(v)) for k, v in self.T.iteritems()])
+                
+        if isinstance(results, np.ndarray):
+            return DataMatrix(data=results, index=self.index, 
+                              columns=self.columns, objects=self.objects)
+        elif isinstance(results, dict):
+            if isinstance(results.values()[0], np.ndarray):
+                return DataMatrix(results, objects=self.objects)
+            else:
+                return Series.fromDict(results)
+        else:
+            raise Exception('This is ridiculous')
+    
+    def tapply(self, func):
+        """
+        Apply func to the transposed DataMatrix, results as per above.
+        """
+        return self.apply(func, axis=1)
+
+    def applymap(self, func):
+        """
+        Apply a function to a DataMatrix that is intended to operate 
+        elementwise, i.e. like doing
+            map(func, series) for each series in the DataMatrix
+
+        Parameters
+        ----------
+        func: function
+            Python function, returns a single value from a single value
+        
+        Note: try to avoid using this function if you can, very slow.
+        """
+        npfunc = np.frompyfunc(func, 1, 1)
+        results = npfunc(self.values)
+        try:
+            results = results.astype(self.values.dtype)
+        except:
+            return DataFrame.fromMatrix(results, self.columns, self.index)
+        return DataMatrix(data=results, index=self.index, columns=self.columns)
+
+    # Utility methods
+
+    def filterItems(self, items):
+        """
+        Restrict frame's columns to input set of items.
+        
+        Parameters
+        ----------
+        items: list-like
+            List of columns to restrict to (must not all be present)
+            
+        Returns
+        -------
+        DataMatrix with filtered columns
+        """
+        if len(self.columns) == 0:
+            return self
+        intersection = self.columns.intersection(items)
+        indexer = [self.columns.indexMap[col] for col in intersection]
+        newValues = self.values[:, indexer].copy()
+        return DataMatrix(newValues, index=self.index, columns=intersection)
+
+    def filterLike(self, arg):
+        """
+        Filter to columns partially matching the import argument.
+        
+        Keep columns where "arg in col == True"
+        
+        Parameter
+        ---------
+        arg: string        
+
+        Return
+        ------
+        DataMatrix with matching columns
+        """
+        newCols = Index([c for c in self.columns if arg in c])
+        return self._withColumns(newCols)
+        
+    def combineFirst(self, otherFrame):
+        """
+        Combine two DataFrame / DataMatrix objects and default to value
+        in frame calling the method.
+        
+        Example: a.combineFirst(b)
+            a's values prioritized, use values from b to fill holes
+
+        Parameters
+        ----------
+        otherFrame: DataFrame / Matrix
+        
+        Returns
+        -------
+        DataMatrix
+        """
+        if not otherFrame:
+            return self
+        
+        if not self:
+            return otherFrame
+        
+        if self.index is not otherFrame.index:
+            unionIndex = self.index + otherFrame.index
+            frame = self.reindex(unionIndex)
+            otherFrame = otherFrame.reindex(unionIndex)
+        else:
+            unionIndex = self.index
+            frame = self
+        
+        colSet = set(frame.cols())
+        if colSet - set(otherFrame.cols()) == colSet:
+            return frame.T.append(otherFrame.T).T
+            
+        result = {}
+        for col, series in frame.iteritems():
+            otherSeries = otherFrame[col] if col in otherFrame else None
+            if otherSeries is not None:
+                result[col] = series.__class__(np.where(isnull(series), 
+                                                        otherSeries, series),
+                                               index=unionIndex)
+            else:
+                result[col] = series
+
+        for col, series in otherFrame.iteritems():
+            if col not in self:
+                result[col] = series
+
+        return DataMatrix(result, index = unionIndex)    
+    
+    def combineAdd(self, otherFrame):
+        """
+        Add two DataFrame / DataMatrix objects and do not propagate NaN values,
+        so if for a (column, time) one frame is missing a value, it will 
+        default to the other frame's value (which might be NaN as well)
+
+        Parameters
+        ----------
+        otherFrame: DataFrame / Matrix
+        
+        Returns
+        -------
+        DataMatrix
+        """
+        if not otherFrame:
+            return self
+        
+        if not self:
+            return otherFrame
+
+        if self.index is not otherFrame.index:
+            unionIndex = self.index + otherFrame.index
+            frame = self.reindex(unionIndex)
+            otherFrame = otherFrame.reindex(unionIndex)
+        else:
+            unionIndex = self.index
+            frame = self
+
+        unionCols = sorted(set(frame.cols() + otherFrame.cols()))
+        
+        result = {}
+        for col in unionCols:
+            if col in frame and col in otherFrame:
+                series = frame[col].view(ndarray)
+                otherSeries = otherFrame[col].view(ndarray)
+                sok = np.isfinite(series)
+                ook = np.isfinite(otherSeries)
+
+                result[col] = np.where(sok & ook, series + otherSeries,
+                                       np.where(sok, series, otherSeries))
+
+            elif col in frame:
+                result[col] = frame[col]
+            elif col in otherFrame:
+                result[col]= otherFrame[col]
+            else:
+                raise Exception('Phantom column, be very afraid')
+
+        return DataMatrix(result, index=unionIndex, columns=unionCols)
+
+    # TODO, works though.
+    def outerJoin(self, *frames):
+        """
+        Form union of input frames.
+        
+        Columns must not overlap. Returns a copy.
+        
+        Parameters
+        ----------
+        *frames: list-like
+            List of frames (DataMatrix or DataFrame) as function arguments
+        
+        Returns
+        -------
+        DataMatrix
+        """
+        mergedSeries = self._series.copy()
+
+        unionIndex = self.index
+        for frame in frames:
+            unionIndex  = unionIndex + frame.index
+
+        for frame in frames:
+            for col, series in frame.iteritems():
+                if col in mergedSeries:
+                    raise Exception('Overlapping columns!')
+                mergedSeries[col] = series
+
+        return DataMatrix.fromDict(mergedSeries)        
+    
+    def leftJoin(self, *frames, **kwds):
+        """
+        Insert columns of input DataFrames / dicts into this one.
+        
+        Columns must not overlap. Returns a copy.
+        
+        Parameters
+        ----------
+        *frames: list-like
+            List of frames (DataMatrix or DataFrame) as function arguments
+        
+        Keyword args
+        ------------
+        coerceTo: type or dtype
+            
+        Returns
+        -------
+        DataMatrix
+        """
+        
+        unionCols = set(self.columns)            
+        frames = list(frames)
+        
+        for frame in frames:
+            cols = set(frame.columns)
+            if any(unionCols & cols):
+                raise Exception('Overlapping columns!')
+            unionCols |= cols                
+        
+        newColumns = Index(sorted(unionCols))
+        seriesDict = self._series
+        
+        for frame in frames:
+            frame = frame.reindex(self.index)
+            seriesDict.update(frame._series)
+            
+        return DataMatrix(seriesDict, index=self.index)
+
+    def append(self, otherDM):
+        if not otherDM:
+            return self
+        if not self:
+            return otherFrame
+        if (isinstance(otherDM, DataMatrix) and
+            list(self.columns) == list(otherDM.columns)):
+            if len(self.index.diff(otherDM.index)) != len(self.index):
+                raise ValueError('Index cannot overlap')
+            idx = self.index + otherDM.index
+            mat = np.vstack((self.values, otherDM.values))
+            dm = DataMatrix(mat, idx, self.columns)
+            if otherDM.objects is None:                
+                dm.objects = self.objects
+            elif self.objects is None:
+                dm.objects = otherDM.objects
+            else:
+                dm.objects = self.objects.append(otherDM.objects)
+            return dm
+        else:
+            return super(DataMatrix, self).append(otherDM)
diff --git a/pandas/core/mixins.py b/pandas/core/mixins.py
new file mode 100644
index 000000000..57ce70fc8
--- /dev/null
+++ b/pandas/core/mixins.py
@@ -0,0 +1,27 @@
+from __future__ import with_statement
+
+import cPickle
+
+#-------------------------------------------------------------------------------
+# Picklable mixin
+
+class Picklable(object):
+    def save(self, fileName):
+        with open(fileName, 'wb') as f:
+            cPickle.dump(self, f)
+
+    @classmethod
+    def load(cls, fileName):
+        with open(fileName, 'rb') as f:
+            obj = cPickle.load(f)        
+            return obj
+        raise Exception("Error trying to unpickle %s" % fileName)
+    
+#-------------------------------------------------------------------------------
+# Groupable mixin
+
+class Groupable(object):
+    def groupby(self, mapper):
+        from panda.core.groupby import GroupBy
+        return GroupBy(self, mapper)
+
diff --git a/pandas/core/pytools.py b/pandas/core/pytools.py
new file mode 100644
index 000000000..f675ae080
--- /dev/null
+++ b/pandas/core/pytools.py
@@ -0,0 +1,60 @@
+"""A collection of tools for various purely Python operations"""
+from random import Random
+import base64
+import os
+import string
+
+# In theory should be few to no imports outside perhaps stdlib here
+
+def rands(n):
+    """Generates a random alphanumeric string of length *n*"""
+    return ''.join(Random().sample(string.letters+string.digits, n))
+
+def adjoin(space, *lists):
+    """
+    Glues together two sets of strings using the amount of space requested.
+    The idea is to prettify.
+    """
+    outLines = []
+    newLists = []
+    lengths = [max(map(len, x)) + space for x in lists]
+    maxLen = max(map(len, lists))
+    for i, lst in enumerate(lists):
+        nl = [x.ljust(lengths[i]) for x in lst]
+        nl.extend([' ' * lengths[i]] * (maxLen - len(lst)))
+        newLists.append(nl)
+    toJoin = zip(*newLists)
+    for lines in toJoin:
+        outLines.append(''.join(lines))
+    return '\n'.join(outLines)
+
+def indent(string, spaces=4):
+    dent = ' ' * spaces
+    return '\n'.join([dent + x for x in string.split('\n')])
+
+def banner(message):
+    bar = '=' * 80
+    return '%s\n%s\n%s' % (bar, message, bar)
+
+
+class groupby(dict):
+    """
+    A simple groupby different from the one in itertools.
+    
+    Does not require the sequence elements to be sorted by keys,
+    however it is slower. 
+    """
+    def __init__(self, seq, key=lambda x:x):
+        for value in seq:
+            k = key(value)
+            self.setdefault(k, []).append(value)
+    __iter__ = dict.iteritems
+
+    
+def map_indices_py(arr):
+    """
+    Returns a dictionary with (element, index) pairs for each element in the 
+    given array/list
+    """
+    return dict([(x, i) for i, x in enumerate(arr)])
+
diff --git a/pandas/core/series.py b/pandas/core/series.py
new file mode 100644
index 000000000..dfd6d14b9
--- /dev/null
+++ b/pandas/core/series.py
@@ -0,0 +1,984 @@
+from datetime import datetime
+from itertools import izip
+import operator
+
+from numpy import NaN, ndarray
+import numpy as np
+
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import DateOffset, to_datetime
+from pandas.core.index import Index, NULL_INDEX
+from pandas.core.mixins import Picklable, Groupable
+
+from pandas.lib.tseries import isnull, notnull
+import pandas.lib.tseries as tseries
+
+#-------------------------------------------------------------------------------
+# Series class
+    
+class Series(np.ndarray, Picklable, Groupable):
+    """Generic indexed series (time series or otherwise) object.
+
+    Parameters
+    ----------
+    data:  array-like
+        Underlying values of Series, preferably as numpy ndarray
+    index: array-like, optional
+        Index object (or other iterable of same length as data)
+
+    Contains values in a numpy-ndarray with an optional bound index (also 
+    an array of dates, strings, or whatever you want the 'row names' of 
+    your series to be)
+
+    Rows can be retrieved by index value (date, string, etc.) or 
+    relative position in the underlying array.
+
+    Operations between Series (+, -, /, *, **) objects are *index-safe*,
+    meaning that values will be combined by their respective index positions
+    rather than relative positions in the underlying ndarray. In other words,
+    there is no 'matching' or 'aligning' to do, it's all taken care of for you.
+
+    NOTE: If you combine two series, all values for an index position must
+    be present or the value for that index position will be nan. The new index
+    is the sorted union of the two Series indices.
+
+    ALSO NOTE: There is currently no restriction on what can be in the index.
+
+    Example usage:
+        >>> s = Series(arr, index=Index(dates))
+        >>> t = Series(otherArr, index=Index(otherDates))
+        >>> s / t # --> new Series resulting from by-index division of elements
+        >>> d = s.index[5]
+        >>> s[5]
+        >>> s[d]    # Valid
+    """
+    def __new__(cls, data, index=None, dtype=None, copy=False):
+        indexTypes = np.ndarray, Index, list, tuple, type(None)
+        if not isinstance(index, indexTypes):
+            raise TypeError("Expected index to be in %s; was %s."
+                            % (indexTypes, type(index)))
+        
+        # Make a copy of the data, infer type
+        subarr = np.array(data, dtype=dtype, copy=copy)
+
+        if not subarr.shape:
+            return np.float64(subarr)
+        
+        """
+        This is to prevent mixed-type Series getting all casted
+        to NumPy string type, e.g. NaN --> '-1#IND'.
+        """
+        if subarr.dtype.type == np.str_:
+            subarr = np.array(data, dtype=object, copy=copy)
+
+        # Change the class of the array to be the subclass type.
+        subarr = subarr.view(cls)
+
+        # Deal with the index
+        if index is not None:
+            try:
+                assert(len(data) == len(index))
+            except AssertionError:
+                raise Exception('Lengths of index and values did not match!') 
+            if isinstance(index, Index):
+                subarr.index = index
+            else:
+                subarr.index = Index(index)        
+        elif hasattr(data, 'index'):
+            subarr.index = data.index
+        else:
+            raise Exception('Index cannot be None!')
+        
+        if subarr.index._allDates:
+            subarr = subarr.view(TimeSeries)
+            
+        return subarr
+
+    def __array_finalize__(self, obj):
+        """
+        Gets called after any ufunc or other array operations, necessary
+        to pass on the index.
+        """
+        self.index = getattr(obj, 'index', None)
+        
+    @classmethod
+    def fromDict(cls, input={}, castFloat=True, **kwds):
+        """
+        Analogous to asDataFrame, but turns dict into Series
+        
+        Parameters
+        ----------
+        input: dict object
+            Keys become indices of returned Series
+        kwds: optionally provide arguments as keywords
+        
+        Returns
+        -------
+        Series
+        """
+        input = input.copy()
+        input.update(kwds)
+        
+        index = Index(sorted(input.keys()))
+        if castFloat:
+            try:
+                useData = [float(input[idx]) for idx in index]
+            except:
+                useData = [input[idx] for idx in index]
+        else:
+            useData = [input[idx] for idx in index]
+        return Series(useData, index=index) 
+
+    @classmethod
+    def fromValue(cls, value=np.NaN, index=None, dtype=None):
+        """
+        Analogous to asDataFrame, but turns dict into Series
+        
+        Parameters
+        ----------
+        input: dict object
+            Keys become indices of returned Series
+        kwds: optionally provide arguments as keywords
+        
+        Returns
+        -------
+        Series
+        """        
+        if not isinstance(index, Index):
+            index = Index(index)
+        
+        # If we create an empty array using a string to infer
+        # the dtype, NumPy will only allocate one character per entry
+        # so this is kind of bad. Alternately we could use np.repeat
+        # instead of np.empty (but then you still don't want things
+        # coming out as np.str_!
+        if isinstance(value, basestring):
+            dtype = np.object_
+        
+        if dtype is None:    
+            arr = np.empty(len(index), dtype=type(value))
+        else:
+            arr = np.empty(len(index), dtype=dtype)
+        arr.fill(value)
+        
+        return Series(arr, index=index) 
+
+    @classmethod
+    def load(cls, baseFile):
+        """
+        Load Series from file.
+        
+        Parameters
+        ----------
+        baseFile: string    
+            Filename base where index/values are stored.
+            e.g. baseFile='myfile' --> 'myfile_index.npy', 'myfile_values.npy'
+
+        Returns
+        -------
+        Series or TimeSeries
+        """
+        indexFile = baseFile + '_index.npy'
+        valuesFile = baseFile + '_values.npy'
+        index = np.load(indexFile)
+        values = np.load(valuesFile)
+
+        return cls(values, index=index)
+    
+    def save(self, baseFile):
+        """
+        Save Series to file.
+        
+        Parameters
+        ----------
+        baseFile: string    
+            Filename base where index/values are stored.
+            e.g. baseFile='myfile' --> 'myfile_index.npy', 'myfile_values.npy'
+        """
+        indexFile = baseFile + '_index'
+        valuesFile = baseFile + '_values'
+
+        np.save(indexFile, self.index)
+        np.save(valuesFile, self)
+    
+    def __contains__(self, key):
+        return key in self.index
+        
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(ndarray.__reduce__(self))
+        subclass_state = (self.index, )
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
+    def __setstate__(self, state):
+        """Necessary for making this object picklable"""
+        nd_state, own_state = state
+        ndarray.__setstate__(self, nd_state)
+        index, = own_state
+        self.index = index
+
+    def __getitem__(self, key):
+        """
+        Returns item(s) for requested index/sequence, overrides default behavior
+        for series[key]. 
+        
+        Logic is as follows:
+            - If key is in the index, return the value corresponding 
+              to that index
+            - Otherwise, use key (presumably one integer or a sequence 
+              of integers) to obtain values from the series. In the case 
+              of a sequence, a 'slice' of the series (with corresponding dates) 
+              will be returned, otherwise a single value.
+        """
+        if key is None and key not in self.index:
+            raise Exception('None/Null object requested of Series!')
+        if not hasattr(key, '__iter__'):
+            try:
+                # Check that we can even look for this in the index
+                if key in self.index: 
+                    return self.get(key)
+                if not isinstance(key, int):
+                    raise Exception('Requested index not in this series!')
+            except TypeError:
+                # Could not hash item
+                pass
+        dataSlice = self.view(ndarray)[key]
+        if self.index is not None:
+            indices = self.index.view(ndarray)[key]    
+            if isinstance(indices, ndarray):
+                indexSlice = Index(indices)
+                return self.__class__(dataSlice, index=indexSlice)
+            else:
+                return dataSlice
+        else:
+            if isinstance(dataSlice, ndarray):
+                return self.__class__(dataSlice)
+            else:
+                return dataSlice    # Just one element
+
+    def __getslice__(self, i, j):
+        """
+        Returns a slice of the Series. 
+        
+        Note that the underlying values are COPIES.
+        
+        The reason that the getslice returns copies is that otherwise you 
+        will have a reference to the original series which could be 
+        inadvertently changed if the slice were altered (made mutable).
+        """
+        newArr = self.view(ndarray)[i:j].copy()
+    
+        if self.index is not None:
+            newIndex = self.index[i:j]
+            return self.__class__(newArr, index = newIndex)
+        else:
+            return self.__class__(newArr)
+
+    def __setitem__(self, key, value):
+        """
+        If this series is mutable, set specified indices equal to given values. 
+        """
+        if isinstance(key, int):
+            ndarray.__setitem__(self, key, value)
+        else:
+            try:
+                # Check that we can even look for this in the index
+                if key in self.index:
+                    ndarray.__setitem__(self, self.index.indexMap[key], value)
+                    return
+            except:
+                pass
+            ndarray.__setitem__(self, key, value)
+
+    def __setslice__(self, i, j, value):
+        """Set slice equal to given value(s)"""
+        ndarray.__setslice__(self, i, j, value)
+
+    def __repr__(self):
+        """Clean string representation of a Series"""
+        vals = self.view(ndarray)
+        index = self.index
+        if index is not None and len(index) > 0:
+            if len(index) > 500:
+                head = _seriesRepr(index[:50], vals[:50])
+                tail = _seriesRepr(index[-50:], vals[-50:])                
+                return head + '\n...\n' + tail + '\nlength: %d' % len(vals)
+            else:
+                return _seriesRepr(index, vals)
+        else:
+            return 'No index!\n' + ndarray.__repr__(self)
+    
+    def __str__(self):
+        return self.__repr__()
+    
+    def __iter__(self):
+        return self.view(ndarray).__iter__()
+    
+#-------------------------------------------------------------------------------
+#   Arithmetic operators
+    
+    def _seriesOpWrap(opname, comp=False):
+        """
+        Wrapper function for Series arithmetic operations, to avoid
+        code duplication. 
+        """
+        MIRROR_OPS = {
+            '__add__' : '__radd__',    
+            '__sub__' : '__rsub__',    
+            '__div__' : '__rdiv__',    
+            '__mul__' : '__rmul__'
+        }
+        def wrapper(self, other):
+            from pandas.core.frame import DataFrame
+            
+            func = getattr(self.view(ndarray), opname)
+            cls = self.__class__
+            if isinstance(other, Series):
+                if self.index is other.index:
+                    return cls(func(other), index=self.index)    
+                if len(self.index) + len(other.index) > 0:
+                    newIndex = self.index + other.index
+                else:
+                    newIndex = NULL_INDEX
+                try:
+                    arr = tseries.combineFunc(opname, newIndex, self, other, 
+                                              self.index.indexMap, 
+                                              other.index.indexMap)
+                except:
+                    arr = Series.combineFunc(self, other,
+                                             getattr(type(self[0]), opname))
+                result = cls(arr, index=newIndex)
+                if comp:
+                    result[isnull(result)] = 0
+                    return result.astype(np.bool)
+                else:
+                    return result
+            elif isinstance(other, DataFrame):
+                reverse_op = MIRROR_OPS.get(opname)
+                if reverse_op is None:
+                    raise Exception('Cannot do %s op, sorry!')
+                return getattr(other, reverse_op)(self)
+            else:
+                return cls(func(other), index=self.index)
+        return wrapper
+    
+    __add__ = _seriesOpWrap('__add__')
+    __sub__ = _seriesOpWrap('__sub__')
+    __mul__ = _seriesOpWrap('__mul__')
+    __div__ = _seriesOpWrap('__div__')
+    __pow__ = _seriesOpWrap('__pow__')
+    
+    # Inplace operators
+    __iadd__ = __add__
+    __isub__ = __sub__
+    __imul__ = __mul__
+    __idiv__ = __div__
+    __ipow__ = __pow__
+        
+    del _seriesOpWrap
+    
+#-------------------------------------------------------------------------------
+# Overridden ndarray methods
+    
+    def sum(self, axis=None, dtype=None, out=None):
+        arr = self.view(ndarray)       
+        retVal = arr.sum(axis, dtype, out)
+        
+        if isnull(retVal):    
+            arr = remove_na(arr)
+            retVal = arr.sum(axis, dtype, out)
+        
+        return retVal
+
+    def mean(self, axis=None, dtype=None, out=None):
+        arr = self.view(ndarray)       
+        retVal = arr.mean(axis, dtype, out)
+        
+        if isnull(retVal):    
+            arr = remove_na(arr)
+            retVal = arr.mean(axis, dtype, out)
+        
+        return retVal
+    
+    def std(self, axis=None, dtype=None, out=None, ddof=1):
+        nona = remove_na(self.view(ndarray))
+        if len(nona) < 2:
+            return NaN
+        return ndarray.std(nona, axis, dtype, out, ddof)
+
+    def var(self, axis=None, dtype=None, out=None, ddof=1):
+        nona = remove_na(self.view(ndarray))
+        if len(nona) < 2:
+            return NaN
+        return ndarray.var(nona, axis, dtype, out, ddof)
+        
+    def keys(self):
+        """
+        Return Series index
+        
+        Analogous to dict.keys()
+        """
+        return self.index
+    
+    def values(self):
+        """
+        Return Series values
+        
+        Analogous to dict.values()
+        """
+        return self.view(ndarray)
+
+    def iteritems(self):
+        """
+        Iterate over (index, value) tuples
+        """
+        if self.index is not None:
+            return izip(self.index.__iter__(), self.__iter__())
+        else:
+            raise Exception('This series has no index!')    
+        
+    def get(self, key, missingVal=None):
+        """
+        Returns value occupying requested index, and
+        return missingVal if not in Index
+        
+        Parameters
+        ----------
+        key: object
+            Index value looking for
+        missingVal: object, optional
+            Value to return if key not in index
+        """
+        if key in self.index:
+            return ndarray.__getitem__(self, self.index.indexMap[key])
+        else:
+            return missingVal
+                        
+    def append(self, other):
+        """
+        Concatenate two Series
+        """
+        newIndex = np.concatenate((self.index, other.index))
+        newValues = np.concatenate((self, other))
+        return self.__class__(newValues, index = newIndex)
+
+    def combineFunc(self, other, func):
+        """
+        Combines this Series with another Series index by index using
+        the given function.
+        """
+        if self.index is other.index:
+            newIndex = self.index
+        else:
+            newIndex = self.index + other.index
+        newArr = np.empty(len(newIndex), dtype = self.dtype)
+        for i, idx in enumerate(newIndex):
+            newArr[i] = func(self.get(idx, nan), other.get(idx, nan))
+        return self.__class__(newArr, index=newIndex)
+    
+    def argsort(self, axis = 0, kind='quicksort', order=None):
+        """
+        Overriding numpy's built-in cumsum functionality
+        """
+        arr = self.view(ndarray).copy()
+        okLocs = notnull(arr)
+        arr[okLocs] = np.argsort(arr[okLocs])        
+        return self.__class__(arr, index=self.index)
+    
+    def cumsum(self, axis = 0, dtype = None, out = None):
+        """
+        Overriding numpy's built-in cumsum functionality
+        """
+        arr = self.copy()
+        okLocs = notnull(arr)
+        result = np.cumsum(arr.view(ndarray)[okLocs])
+        arr = arr.astype(result.dtype)
+        arr[okLocs] = result
+        return arr
+    
+    def cumprod(self, axis = 0, dtype = None, out = None):
+        """
+        Overriding numpy's built-in cumprod functionality
+        """
+        arr = self.copy()
+        okLocs = notnull(arr)
+        arr[okLocs] = np.cumprod(arr.view(ndarray)[okLocs])
+        return arr
+
+    def copy(self):
+        return self.__class__(self.view(ndarray).copy(), index=self.index)
+    
+    def corr(self, other):
+        """
+        Correlation of this Series with another Series, NaN excluded
+        
+        Parameters
+        ----------
+        other: Series object
+        
+        Returns
+        -------
+        float (the correlation coefficient)
+        """
+        commonIdx = list(set(remove_na(self).index) & 
+                         set(remove_na(other).index))
+        
+        if len(commonIdx) == 0:
+            return NaN
+                
+        this = self.reindex(commonIdx)
+        that = other.reindex(commonIdx)
+        
+        return np.corrcoef(this, that)[0, 1]
+
+    def median(self):
+        """
+        Return median of Series. 
+        
+        Returns
+        -------
+        The median value
+        """
+        selfExNaN = remove_na(self.view(ndarray))
+        return np.median(selfExNaN)
+
+    def sort(self, axis=0, kind='quicksort', order=None):
+        sortedSeries = self.order(missingAtEnd = True)
+        self[:] = sortedSeries
+        self.index = sortedSeries.index
+    
+    def order(self, missingAtEnd = True):
+        """
+        Sorts Series object, by value, maintaining index-value object
+
+        Parameters
+        ----------
+        missingAtEnd: boolean (optional, default=True)
+            Put NaN's at beginning or end
+        
+        In general, AVOID sorting Series unless you absolutely need to.
+        
+        Returns
+        -------
+        SORTED series by values (indices correspond to the appropriate values)
+        """
+        arr = self.view(ndarray)
+        sortedIdx = np.empty(len(self), dtype=np.int32)
+
+        bad = isnull(arr)
+
+        good = -bad
+        idx = np.arange(len(self))
+        if missingAtEnd:
+            n = sum(good)
+            sortedIdx[:n] = idx[good][arr[good].argsort()]        
+            sortedIdx[n:] = idx[bad]
+        else:
+            n = sum(bad)
+            sortedIdx[n:] = idx[good][arr[good].argsort()]        
+            sortedIdx[:n] = idx[bad]
+            
+        return Series(arr[sortedIdx], index=self.index[sortedIdx])
+
+    def map(self, func):
+        """
+        Apply input Python function element-wise to each element of 
+        Series.
+        
+        Parameters
+        ----------
+        func: function
+            Element-wise function to apply
+            
+        Returns
+        -------
+        Series with same index
+        """
+        return Series([func(x) for x in self], index = self.index)
+
+    def plot(self, label=None, kind='line', **kwds):
+        """
+        Plot the input series with the index on the x-axis using 
+        matplotlib / pylab.
+
+        Params
+        ------
+        label: label argument to provide to plot
+        
+        kind: {'line', 'bar', 'hist'}
+            Default: line for TimeSeries, hist for Series
+
+        kwds: other plotting keyword arguments
+
+        Default plot-types:
+            TimeSeries: line chart
+            Series: histogram
+                Also support for bar charts
+    
+        Type show() (make sure to do 'from pylab import *') to see graph if you
+        do not.
+
+        Note
+        ----
+        See matplotlib documentation online for more on this subject
+        """
+        import pylab
+
+        if label is not None:
+            kwds = kwds.copy()
+            kwds['label'] = label 
+        
+        # I can't get this to work
+        
+        #fig = pylab.gcf()
+        #fig.autofmt_xdate(bottom=0.1)
+        
+        #ax = fig.gca()
+        #if not ax.has_data():
+            #ax = fig.add_subplot(111)
+        
+        #ax.plot(self.index, self, **kwds)
+        
+        pylab.plot(self.index, self, **kwds)
+
+    def remapIndex(self, mapping):
+        raise Exception('Not implemented!')
+
+    def unstack(self):
+        """
+        Inverse operator for *stack*
+        """
+        from pandas.core.frame import DataFrame
+        data = {}
+        for idx, value in self.iteritems():
+            row, col = idx.split(';')
+            try:
+                row = datetime.fromordinal(int(row))
+            except:
+                pass
+            data.setdefault(row, {})[col] = value
+        return DataFrame.fromDict(data)    
+
+    def toCSV(self, path=None):
+        """
+        Write the Series to a CSV file
+        
+        Parameters
+        ----------
+        path: string or None
+            Output filepath. If None, write to stdout
+        """
+        if not path:
+            import sys
+            f = sys.stdout
+        else:
+            f = open(path, 'wb')
+        for idx, value in self.iteritems():
+            f.write(str(idx) + ',' + str(value) + ',\n')
+        if path is not None:
+            f.close()
+            
+    def toClipboard(self):
+        txt = ''
+        for idx, value in self.iteritems():
+            txt += (str(idx) + '\t' + str(value) + '\n')
+        setText(txt)
+
+    def toDict(self):
+        return dict(self.iteritems())
+            
+    def cap(self, value):
+        """Return copy of series with values above given value truncated"""
+        myCopy = self.copy()
+        myCopy[notnull(myCopy) & (myCopy > value)] = value
+        return myCopy
+
+    def floor(self, value):
+        """Return copy of series with values BELOW given value truncated"""
+        myCopy = self.copy()
+        myCopy[notnull(myCopy) & (myCopy < value)] = value
+        return myCopy
+
+#-------------------------------------------------------------------------------
+# TimeSeries methods
+
+    def shift(self, periods, offset=None):
+        """
+        Shift the underlying series of the DataMatrix and Series objects within 
+        by given number (positive or negative) of business/weekdays.
+
+        Parameters
+        ----------
+        periods: int (+ or -)
+            Number of periods to move
+        offset: DateOffset, optional
+            Increment to use from datetools module
+
+        Returns
+        -------
+        TimeSeries
+        """
+        if periods == 0:
+            return self
+        
+        if offset is None:
+            if periods > 0:
+                newIndex = self.index[periods:]
+                newValues = np.array(self)[:-periods]
+            else:
+                newIndex = self.index[:periods]
+                newValues = np.array(self)[-periods:]                
+            return self.__class__(newValues, index=newIndex)
+        else:
+            offset = periods * offset
+            newIndex = Index([idx + offset for idx in self.index])
+            return self.__class__(self, index=newIndex)
+
+    def slice(self, before, after): 
+        import bisect 
+         
+        if before is not None: 
+            binsearch = bisect.bisect_left(self.index, before) 
+            cur = self.index[binsearch] 
+            next = self.index[min(binsearch + 1, len(self.index) - 1)] 
+            leftDate = cur if cur >= before else next 
+        else: 
+            leftDate = self.index[0] 
+         
+        if after is not None: 
+            if after < self.index[-1]: 
+                binsearch = bisect.bisect_right(self.index, after) 
+                cur = self.index[binsearch] 
+                prior = self.index[max(binsearch - 1, 0)]             
+                rightDate = cur if cur <= after else prior 
+            else: 
+                rightDate = self.index[-1]             
+        else: 
+            rightDate = self.index[-1] 
+  
+        beg_slice = max(0, self.index.indexMap[leftDate])             
+        end_slice = min(len(self.index), self.index.indexMap[rightDate] + 1)
+        
+        return self[beg_slice:end_slice]
+
+    def asOf(self, date):
+        """
+        Return last good (non-NaN) value in TimeSeries if value is NaN for 
+        requested date. 
+                
+        If there is no good value, NaN is returned.
+        """
+        if isinstance(date, basestring):
+            date = datetools.to_datetime(date)
+        v = self.get(date)
+        if isnull(v):
+            candidates = self.index[notnull(self)]
+            candidates = candidates[candidates <= date]
+            if any(candidates):
+                asOfDate = max(candidates)
+            else:
+                return nan
+            return self.get(asOfDate)
+        else:
+            return v
+
+    def fill(self, value=None, method='pad'):
+        """
+        Fill NaN values using the specified method.
+
+        Parameters
+        ----------
+        value: any kind (should be same type as array)
+            Value to use to fill holes (e.g. 0)
+        
+        method: {'backfill', 'pad', None}
+            Method to use for filling holes in new inde
+        
+        Returns
+        -------
+        TimeSeries with NaN's filled
+            
+        See also
+        --------
+        reindex, asfreq
+        """
+        if value is not None:
+            newSeries = self.copy()
+            newSeries[isnull(newSeries)] = value
+            return newSeries
+        else: # Using reindex to pad / backfill        
+            withoutna = remove_na(self)
+            return withoutna.reindex(self.index, fillMethod=method)
+        
+    def asfreq(self, freq, fillMethod=None):
+        """
+        Convert this TimeSeries to the provided frequency using DateOffset
+        objects. Optionally provide fill method to pad/backfill/interpolate
+        missing values.
+
+        Parameters
+        ----------
+        offset: DateOffset object, or string in {'WEEKDAY', 'EOM'}
+            DateOffset object or subclass (e.g. monthEnd)
+        
+        fillMethod: {'backfill', 'pad', 'interpolate', None}
+                    Method to use for filling holes in new inde
+        
+        Returns
+        -------
+        TimeSeries
+        """
+        if not isinstance(freq, datetools.DateOffset):
+            raise Exception('Must pass DateOffset!')
+
+        dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        
+        return self.reindex(dateRange, fillMethod=fillMethod)
+
+    def reindex(self, newIndex, fillMethod=None):
+        """Overloaded version of reindex for TimeSeries. Supports filling
+        with values based on new index. 
+
+        See analogous method for DataFrame, will be faster for multiple
+        TimeSeries
+
+        Parameters
+        ----------
+        newIndex:   array-like, preferably an Index object (to avoid
+                    duplicating data)
+        fillMethod: {'backfill', 'pad', 'interpolate', None}
+                    Method to use for filling holes in reindexed Series
+        
+        Returns
+        -------
+        TimeSeries
+        """
+        if fillMethod is None:
+            if self.index is newIndex:
+                return self
+            if not isinstance(newIndex, Index):
+                newIndex = Index(newIndex)
+
+            idxMap = self.index.indexMap        
+
+            if self.dtype == float:
+                return self.__class__(tseries.reindex(newIndex, self, idxMap), 
+                                      index=newIndex)
+            elif self.dtype == int:
+                # This could be unsafe, but NaN will not work in int arrays.
+                reindexed = tseries.reindex(newIndex, self.astype(float), 
+                                            idxMap)
+                return self.__class__(reindexed, index=newIndex)
+            
+            else:
+                if self.dtype.type == np.object_:
+                    result = tseries.reindexObj(newIndex, self, idxMap)
+                    return self.__class__(result, index=newIndex)
+                else:
+                    thisVals = self.view(np.ndarray).astype(object)
+                    vals = tseries.reindexObj(newIndex, thisVals, idxMap)
+                    vals = vals.astype(self.dtype)
+                    return self.__class__(vals, index=newIndex)
+            
+        if not isinstance(newIndex, Index):
+            newIndex = Index(newIndex)
+
+        oldMap = self.index.indexMap
+        newMap = newIndex.indexMap
+
+        if not fillMethod:
+            fillMethod = ''
+
+        fillMethod = fillMethod.upper()
+
+        if fillMethod not in ['BACKFILL', 'PAD', '']:
+            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
+
+        # Cython for blazing speed
+        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap, 
+                                           newMap, kind=fillMethod)
+
+        newValues = self.view(ndarray)[fillVec]
+        newValues[-mask] = nan
+
+        return self.__class__(newValues, index = newIndex)
+    
+    def _weekday(self):
+        return self.__class__([d.weekday() for d in self.index], 
+                              index = self.index)
+        
+    weekday = property(_weekday)
+    
+    def truncate(self, before = None, after = None):
+        """Function truncate a TimeSeries before and/or after some
+        particular dates.
+        
+        Parameters
+        ----------
+        before: date
+            Truncate before date
+        after: date
+            Truncate after date
+        
+        Note
+        ----
+        If TimeSeries is contained in a DataFrame, consider using the version
+        of the function there. 
+
+        Returns
+        -------
+        TimeSeries
+        """
+        before = to_datetime(before)
+        after = to_datetime(after)
+        
+        if before is None:
+            before = min(self.index)
+        if after is None:
+            after = max(self.index)
+        return self.slice(before, after)
+        
+    def autocorr(self):
+        """
+        1st period autocorrelation coefficient
+        
+        Returns
+        -------
+        TimeSeries
+        """
+        return self.corr(self.shift(1))
+
+    def _firstTimeWithValue(self):
+        noNA = remove_na(self)
+        
+        if len(noNA) > 0:        
+            return noNA.index[0]
+        else:
+            return None
+
+    def _lastTimeWithValue(self):
+        noNA = remove_na(self)
+        
+        if len(noNA) > 0:        
+            return noNA.index[-1]
+        else:
+            return None
+        
+class TimeSeries(Series):
+    pass
+
+#-------------------------------------------------------------------------------
+# Supplementary functions
+
+def remove_na(arr):
+    """
+    Return array containing only true/non-NaN values, possibly empty.
+    """
+    return arr[notnull(arr)]
+
+def _seriesRepr(index, vals):
+    maxlen = max([len(str(idx)) for idx in index])
+    padSpace = min(maxlen, 60)
+    return '\n'.join([str(x).ljust(padSpace) + '\t' + str(v)
+                      for x, v in izip(index, vals)])
diff --git a/pandas/core/tests/__init__.py b/pandas/core/tests/__init__.py
new file mode 100644
index 000000000..0f65ad168
--- /dev/null
+++ b/pandas/core/tests/__init__.py
@@ -0,0 +1 @@
+                
diff --git a/pandas/core/tests/test_dataframe.py b/pandas/core/tests/test_dataframe.py
new file mode 100644
index 000000000..caabbebb6
--- /dev/null
+++ b/pandas/core/tests/test_dataframe.py
@@ -0,0 +1,251 @@
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import bday
+from pandas.core.frame import DataFrame
+from pandas.core.index import Index, NULL_INDEX
+from pandas.core.series import Series
+from pandas.lib.tseries import map_indices
+from copy import deepcopy
+from datetime import datetime
+from numpy import isnan, array, NaN, alltrue
+from numpy import random
+from random import choice
+import numpy as np
+import os
+import pickle
+import string
+import sys
+import unittest
+
+def rands(n):
+    return ''.join([choice(string.letters + string.digits) for i in range(n)])
+def equalContents(arr1, arr2):
+    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
+    """
+    return frozenset(arr1) == frozenset(arr2)
+
+#-------------------------------------------------------------------------------
+# DataFrame test cases
+
+class TestDataFrame(unittest.TestCase):
+    def setUp(self):
+        index1 = DateRange(datetime(2008,4,22), periods=50)
+        index2 = DateRange(datetime(2008,4,29), periods=50)
+        index3 = DateRange(datetime(2008,4,28), periods=50)
+        ts1 = Series(random.random(50), index=index1)
+        ts2 = Series(random.random(50), index=index2)
+        ts3 = Series(random.random(50), index=index3)
+        ts4 = Series(random.random(50), index=index1)
+        data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
+        self.frame = DataFrame(data=data, index=index3)
+        self.ts1 = ts1
+        self.ts2 = ts2
+        self.ts3 = ts3
+        self.ts4 = ts4
+
+    def testReindex(self):
+        newFrame = self.frame.reindex(self.ts1.index)
+        for col in newFrame.cols():
+            for idx, val in newFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if isnan(val):
+                        self.assert_(isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(isnan(val))
+        for col, series in newFrame.iteritems():
+            self.assert_(equalContents(series.index, newFrame.index))    
+        emptyFrame = self.frame.reindex(Index([]))
+        self.assert_(len(emptyFrame.index) == 0)
+
+        nonContigFrame = self.frame.reindex(self.ts1.index[::2])
+        for col in nonContigFrame.cols():
+            for idx, val in nonContigFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if isnan(val):
+                        self.assert_(isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(isnan(val))
+        for col, series in nonContigFrame.iteritems():
+            self.assert_(equalContents(series.index, nonContigFrame.index))    
+
+    def testShift(self):
+        shiftedFrame = self.frame.shift(5)
+        for i, idx in enumerate(shiftedFrame.index):
+            self.assert_(idx-5*bday == self.frame.index[i])
+        series = shiftedFrame['col1']
+        for i, idx in enumerate(series.index):
+            self.assert_(idx-5*bday == self.frame.index[i])        
+
+    def testOperators(self):
+        garbage = random.random(4)
+        colSeries = Series(garbage, index=array(self.frame.cols()))
+        idSum = self.frame + self.frame
+        seriesSum = self.frame + colSeries
+        for col, series in idSum.iteritems():
+            for idx, val in series.iteritems():
+                origVal = self.frame[col][idx] * 2
+                if not isnan(val):
+                    self.assertEqual(val, origVal)
+                else:
+                    self.assert_(isnan(origVal))
+        for col, series in seriesSum.iteritems():
+            for idx, val in series.iteritems():
+                origVal = self.frame[col][idx] + colSeries[col]
+                if not isnan(val):
+                    self.assertEqual(val, origVal)
+                else:
+                    self.assert_(isnan(origVal))
+
+    def testSlice(self):
+        """Slicing NOT intended for production code"""
+        slice = self.frame[:20]
+        self.assertEqual(20, len(slice.index))
+        for col, series in slice.iteritems():
+            self.assertEqual(20, len(series.index))
+            self.assert_(equalContents(series.index, slice.index))
+
+    def testGetItem(self):
+        for key, value in self.frame._series.iteritems():
+            self.assert_(self.frame[key] is not None)
+        self.assert_('random' not in self.frame)
+        
+    def testStack(self):
+        frameSlice = self.frame.getTS(fromDate=self.frame.index[0], nPeriods=5)
+        stacked = frameSlice.stack()
+        for idx, value in stacked.iteritems():
+            date, col = idx.split(';')
+            date = datetime.fromordinal(int(date))
+            if isnan(value):
+                self.assert_(isnan(frameSlice[col][date]))
+            else:
+                self.assertEquals(value, frameSlice[col][date])
+
+        unstacked = stacked.unstack().T
+        
+        for i, idx in enumerate(unstacked.index):
+            self.assertEquals(idx, frameSlice.index[i])
+        for col, series in unstacked.iteritems():
+            for idx, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frameSlice[col][idx]))
+                else:                
+                    self.assertEquals(value, frameSlice[col][idx])
+
+    def testSetItem(self):
+        # not sure what else to do here
+        series = self.frame['col1']
+        self.frame['col5'] = series
+        self.assert_('col5' in self.frame)
+
+    def testStatistics(self):
+        sumFrame = self.frame.apply(np.sum)
+        for col, series in self.frame.iteritems():
+            self.assertEqual(sumFrame[col], series.sum())
+        
+    def testDelItem(self):
+        del self.frame['col1']
+        self.assert_('col1' not in self.frame)
+        self.assert_('col1' not in self.frame._series)
+
+    def testGetXS(self):
+        idx = self.frame.index[5]
+        xs = self.frame.getXS(idx)
+        for item, value in xs.iteritems():
+            if isnan(value):
+                self.assert_(isnan(self.frame[item][idx]))
+            else:
+                self.assertEqual(value, self.frame[item][idx])
+
+    def testGetTS(self):
+        frame = self.frame
+        tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
+        for i, idx in enumerate(tsFrame.index):
+            self.assertEqual(idx, frame.index[5+i])
+            for col, series in tsFrame.iteritems():
+                self.assertEqual(idx, series.index[i])
+        for col, series in frame.iteritems():
+            for idx, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frame[col][idx]))
+                else:
+                    self.assertEqual(value, frame[col][idx])
+
+    def testTranspose(self):
+        frame = self.frame
+        dft = frame.T
+        for idx, series in dft.iteritems():
+            for col, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frame[col][idx]))
+                else:
+                    self.assertEqual(value, frame[col][idx])
+
+    def testAsMatrix(self):
+        frame = self.frame
+        mat = frame.asMatrix()
+        smallerCols = ['col3', 'col1']
+        smallerMat = frame.asMatrix(smallerCols)
+        frameCols = frame.cols()
+        for i, row in enumerate(mat):
+            for j, value in enumerate(row):
+                col = frameCols[j]
+                if isnan(value):
+                    self.assert_(isnan(frame[col][i]))
+                else:
+                    self.assertEqual(value, frame[col][i])
+        
+    def testDeepcopy(self):
+        cp = deepcopy(self.frame)
+        series = cp['col1']
+        series[:] = 10
+        for idx, value in series.iteritems():
+            self.assertNotEqual(self.frame['col1'][idx], value)
+
+    def testFilterItems(self):
+        pass
+    
+    def testGroupBy(self):
+        
+        pass
+
+    def testApply(self):
+        pass    
+
+    def testSort(self):
+        pass    
+
+    def testToCSV(self):
+        pass
+
+    def testPickle(self):
+        pass
+
+    def testToDictList(self):
+        pass
+    
+    def testDictToDataFrame(self):
+        pass
+
+    def testDataFrameToDict(self):
+        pass
+
+    def testFromDict(self):
+        newFrame = DataFrame.fromDict(col1=self.ts1, col2 = self.ts2)
+        for idx in newFrame.index:
+            if idx in self.ts1.index:
+                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
+            if idx in self.ts2.index:
+                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
+            
+    
+    def testPreserveReferences(self):        
+        pass
+    
+    def testCleanNaN(self):
+        pass
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pandas/core/tests/test_datamatrix.py b/pandas/core/tests/test_datamatrix.py
new file mode 100644
index 000000000..f27855545
--- /dev/null
+++ b/pandas/core/tests/test_datamatrix.py
@@ -0,0 +1,260 @@
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import bday
+from pandas.core.index import Index, NULL_INDEX
+from pandas.core.matrix import DataMatrix
+from pandas.core.series import Series
+from pandas.lib.tseries import map_indices
+from copy import deepcopy
+from datetime import datetime
+from numpy import isnan, array, NaN, alltrue
+from numpy import random
+from random import choice
+import numpy as np
+import pickle
+import string
+import unittest
+
+def rands(n):
+    return ''.join([choice(string.letters + string.digits) for i in range(n)])
+def equalContents(arr1, arr2):
+    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
+    """
+    return frozenset(arr1) == frozenset(arr2)
+
+#-------------------------------------------------------------------------------
+# DataMatrix test cases
+
+class TestDataMatrix(unittest.TestCase):
+    def setUp(self):
+        index1 = DateRange(datetime(2008,4,22), periods=50)
+        index2 = DateRange(datetime(2008,4,29), periods=50)
+        index3 = DateRange(datetime(2008,4,28), periods=50)
+        ts1 = Series(random.random(50), index=index1)
+        ts2 = Series(random.random(50), index=index2)
+        ts3 = Series(random.random(50), index=index3)
+        ts4 = Series(random.random(50), index=index1)
+        data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
+        self.frame = DataMatrix(data=data, index=index3)
+        self.ts1 = ts1
+        self.ts2 = ts2
+        self.ts3 = ts3
+        self.ts4 = ts4
+
+    def testReindex(self):
+        newFrame = self.frame.reindex(self.ts1.index)
+        for col in newFrame.cols():
+            for idx, val in newFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if isnan(val):
+                        self.assert_(isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(isnan(val))
+        for col, series in newFrame.iteritems():
+            self.assert_(equalContents(series.index, newFrame.index))    
+        emptyFrame = self.frame.reindex(Index([]))
+        self.assert_(len(emptyFrame.index) == 0)
+
+        nonContigFrame = self.frame.reindex(self.ts1.index[::2])
+        for col in nonContigFrame.cols():
+            for idx, val in nonContigFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if isnan(val):
+                        self.assert_(isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(isnan(val))
+        for col, series in nonContigFrame.iteritems():
+            self.assert_(equalContents(series.index, nonContigFrame.index))    
+
+    def testShift(self):
+        shiftedFrame = self.frame.shift(5)
+        for i, idx in enumerate(shiftedFrame.index):
+            self.assert_(idx-5*bday == self.frame.index[i])
+        series = shiftedFrame['col1']
+        for i, idx in enumerate(series.index):
+            self.assert_(idx-5*bday == self.frame.index[i])        
+
+    def testOperators(self):
+        garbage = random.random(4)
+        colSeries = Series(garbage, index=array(self.frame.cols()))
+        idSum = self.frame + self.frame
+        seriesSum = self.frame + colSeries
+        for col, series in idSum.iteritems():
+            for idx, val in series.iteritems():
+                origVal = self.frame[col][idx] * 2
+                if not isnan(val):
+                    self.assertEqual(val, origVal)
+                else:
+                    self.assert_(isnan(origVal))
+        for col, series in seriesSum.iteritems():
+            for idx, val in series.iteritems():
+                origVal = self.frame[col][idx] + colSeries[col]
+                if not isnan(val):
+                    self.assertEqual(val, origVal)
+                else:
+                    self.assert_(isnan(origVal))
+
+    def testSlice(self):
+        """Slicing NOT intended for production code"""
+        slice = self.frame[:20]
+        self.assertEqual(20, len(slice.index))
+        for col, series in slice.iteritems():
+            self.assertEqual(20, len(series.index))
+            self.assert_(equalContents(series.index, slice.index))
+
+    def testGetItem(self):
+        for key, value in self.frame._series.iteritems():
+            self.assert_(self.frame[key] is not None)
+        self.assert_('random' not in self.frame)
+        
+#    def testGetRow(self):
+#        rowFrame = self.frame.getRow(self.frame.index[5])
+#        idx = rowFrame.index[0]
+#        self.assertEquals(idx, self.frame.index[5])
+#        for key, values in rowFrame.iteritems():
+#            self.assertEquals(self.frame[key][idx], values[0])
+#            self.assertEquals(self.frame[key][idx], values[idx])
+        
+    def testStack(self):
+        frameSlice = self.frame.getTS(fromDate=self.frame.index[0], nPeriods=5)
+        stacked = frameSlice.stack()
+        for idx, value in stacked.iteritems():
+            date, col = idx.split(';')
+            date = datetime.fromordinal(int(date))
+            if isnan(value):
+                self.assert_(isnan(frameSlice[col][date]))
+            else:
+                self.assertEquals(value, frameSlice[col][date])
+        
+        unstacked = stacked.unstack().T
+        
+        for i, idx in enumerate(unstacked.index):
+            self.assertEquals(idx, frameSlice.index[i])
+        for col, series in unstacked.iteritems():
+            for idx, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frameSlice[col][idx]))
+                else:                
+                    self.assertEquals(value, frameSlice[col][idx])
+
+    def testSetItem(self):
+        # not sure what else to do here
+        series = self.frame['col1']
+        self.frame['col5'] = series
+        self.assert_('col5' in self.frame)
+
+    def testStatistics(self):
+        sumFrame = self.frame.apply(np.sum)
+        for col, series in self.frame.iteritems():
+            val = sumFrame[col]
+            if isnan(val):
+                print self.frame[col]
+            self.assertEqual(val, series.sum())
+        
+    def testDelItem(self):
+        del self.frame['col1']
+        self.assert_('col1' not in self.frame)
+        self.assert_('col1' not in self.frame._series)
+
+    def testGetXS(self):
+        idx = self.frame.index[5]
+        xs = self.frame.getXS(idx)
+        for item, value in xs.iteritems():
+            if isnan(value):
+                self.assert_(isnan(self.frame[item][idx]))
+            else:
+                self.assertEqual(value, self.frame[item][idx])
+
+    def testGetTS(self):
+        frame = self.frame
+        tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
+        for i, idx in enumerate(tsFrame.index):
+            self.assertEqual(idx, frame.index[5+i])
+            for col, series in tsFrame.iteritems():
+                self.assertEqual(idx, series.index[i])
+        for col, series in frame.iteritems():
+            for idx, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frame[col][idx]))
+                else:
+                    self.assertEqual(value, frame[col][idx])
+
+    def testTranspose(self):
+        frame = self.frame
+        dft = frame.T
+        for idx, series in dft.iteritems():
+            for col, value in series.iteritems():
+                if isnan(value):
+                    self.assert_(isnan(frame[col][idx]))
+                else:
+                    self.assertEqual(value, frame[col][idx])
+
+    def testAsMatrix(self):
+        frame = self.frame
+        mat = frame.asMatrix()
+        smallerCols = ['col3', 'col1']
+        smallerMat = frame.asMatrix(smallerCols)
+        frameCols = frame.cols()
+        for i, row in enumerate(mat):
+            for j, value in enumerate(row):
+                col = frameCols[j]
+                if isnan(value):
+                    self.assert_(isnan(frame[col][i]))
+                else:
+                    self.assertEqual(value, frame[col][i])
+        
+    def testDeepcopy(self):
+        cp = deepcopy(self.frame)
+        series = cp['col1']
+        series[:] = 10
+        for idx, value in series.iteritems():
+            self.assertNotEqual(self.frame['col1'][idx], value)
+
+    def testFilterItems(self):
+        pass
+    
+    def testGroupBy(self):
+        
+        pass
+
+    def testApply(self):
+        pass    
+
+    def testSort(self):
+        pass    
+
+    def testToCSV(self):
+        pass
+
+    def testPickle(self):
+        pass
+
+    def testToDictList(self):
+        pass
+    
+    def testDictToDataFrame(self):
+        pass
+
+    def testDataFrameToDict(self):
+        pass
+
+    def testFromDict(self):
+        newFrame = DataMatrix.fromDict(col1=self.ts1, col2 = self.ts2)
+        for idx in newFrame.index:
+            if idx in self.ts1.index:
+                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
+            if idx in self.ts2.index:
+                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
+            
+    
+    def testPreserveReferences(self):        
+        pass
+    
+    def testCleanNaN(self):
+        pass
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
new file mode 100644
index 000000000..4f05a671e
--- /dev/null
+++ b/pandas/core/tests/test_datetools.py
@@ -0,0 +1,545 @@
+from pandas.core.datetools import BDay
+from datetime import datetime
+from pandas.core.datetools import *
+from pandas.core.daterange import XDateRange, DateRange
+import pandas.core.datetools as datetools
+
+####
+## Misc function tests
+####
+def testFormat():
+    actual = datetools.format(datetime(2008, 1, 15))
+    assert actual == '20080115'
+
+def testOle2datetime():
+    actual = datetools.ole2datetime(60000)
+    assert actual == datetime(2064, 4, 8)
+
+def testTto_datetime1():
+    actual = datetools.to_datetime(datetime(2008, 1, 15))
+    assert actual == datetime(2008, 1, 15)
+    
+def testTto_datetime2():
+    actual = datetools.to_datetime('20080115')
+    assert actual == datetime(2008, 1, 15)
+
+def testNormalize_date():
+    actual = datetools.normalize_date(datetime(2007, 10, 1, 1, 12, 5, 10))
+    assert actual == datetime(2007, 10, 1)
+    
+#####
+### DateOffset Tests
+#####
+
+def myAssert(actual, expected):
+    assert actual == expected
+
+def testEQ():
+    myAssert(datetools.BDay(2), datetools.BDay(2))
+    
+def testHash():
+    myAssert(datetools.BDay(2).__hash__(), datetools.BDay(2).__hash__())
+    
+def testCall():
+    myAssert(BDay(2)(datetime(2008, 1, 1)), datetime(2008, 1, 3))
+    
+def testRAdd():
+    myAssert(datetime(2008, 1, 1) + BDay(2), BDay(2) + datetime(2008, 1, 1))
+
+def testSub():
+    myAssert(datetime(2008, 1, 1) - BDay(2),  datetime(2008, 1, 1) + BDay(-2))
+    
+def testRSub():
+    myAssert(datetime(2008, 1, 1) - BDay(2), BDay(2) - datetime(2008, 1, 1))
+    
+def testMult1():
+    myAssert(datetime(2008, 1, 1) + 10*BDay(), datetime(2008, 1, 1) + BDay(10))
+
+def testMult2():    
+    myAssert(datetime(2008, 1, 1) + (-5*BDay(-10)), 
+             datetime(2008, 1, 1) + BDay(50))
+
+    
+def testRollback1():
+    myAssert(BDay(10).rollback(datetime(2008, 1, 1)), datetime(2008, 1, 1))
+    
+def testRollback2():
+    myAssert(BDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
+    
+def testRollforward1():
+    myAssert(BDay(10).rollforward(datetime(2008, 1, 1)), datetime(2008, 1, 1))
+    
+def testRollforward2():
+    myAssert(BDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
+
+def assertOnOffset(offset, date, expected):
+    actual = offset.onOffset(date)
+    assert actual == expected
+    
+def testOnOffset():
+    
+    tests = [(BDay(), datetime(2008, 1, 1), True),
+             (BDay(), datetime(2008, 1, 5), False),
+         
+             (BMonthEnd(), datetime(2007, 12, 31), True),
+             (BMonthEnd(), datetime(2008, 1, 1), False),
+         
+             (BQuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
+             (BQuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
+             (BQuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
+             (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 30), False), 
+             (BQuarterEnd(1, startingMonth=1), datetime(2007, 3, 31), False), 
+             (BQuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True), 
+             (BQuarterEnd(1, startingMonth=1), datetime(2008, 5, 30), False), 
+             (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 29), False), 
+             (BQuarterEnd(1, startingMonth=1), datetime(2007, 6, 30), False), 
+             
+             (BQuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
+             (BQuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
+             (BQuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 30), False), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2007, 3, 31), False), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 29), False), 
+             (BQuarterEnd(1, startingMonth=2), datetime(2007, 6, 30), False), 
+         
+             (BQuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
+             (BQuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), True),
+             (BQuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
+             (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), True), 
+             (BQuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False), 
+             (BQuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False), 
+             (BQuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
+             (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 29), True), 
+             (BQuarterEnd(1, startingMonth=3), datetime(2007, 6, 30), False), 
+             
+             (BYearEnd(), datetime(2007, 12, 31), True),
+             (BYearEnd(), datetime(2008, 1, 1), False),
+             (BYearEnd(), datetime(2006, 12, 31), False),
+             (BYearEnd(), datetime(2006, 12, 29), True),
+             
+             (MonthEnd(), datetime(2007, 3, 30), False),
+             (MonthEnd(), datetime(2007, 3, 31), True),
+
+             #(QuarterEnd(1, startingMonth=1), datetime(2008, 1, 31), True),
+             #(QuarterEnd(1, startingMonth=1), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=1), datetime(2008, 2, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False), 
+             #(QuarterEnd(1, startingMonth=1), datetime(2008, 4, 30), True), 
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False), 
+             
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 1, 31), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 2, 29), True), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), False), 
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 4, 30), False), 
+             #(QuarterEnd(1, startingMonth=2), datetime(2008, 5, 30), True), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), False), 
+         
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 1, 31), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 12, 31), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 2, 29), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 30), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2007, 3, 31), True), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 4, 30), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 5, 30), False),
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 29), False), 
+             #(QuarterEnd(1, startingMonth=3), datetime(2008, 6, 30), True), 
+             
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=0), datetime(2008, 1, 7), True),
+
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 1), True),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=1), datetime(2008, 1, 7), False),
+
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 2), True),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=2), datetime(2008, 1, 7), False),
+
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 3), True),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=3), datetime(2008, 1, 7), False),
+             
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 4), True),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=4), datetime(2008, 1, 7), False),
+             
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 5), True),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 6), False),
+             (datetools.Week(dayOfWeek=5), datetime(2008, 1, 7), False),
+             
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 1), False),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 2), False),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 3), False),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 4), False),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 5), False),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 6), True),
+             (datetools.Week(dayOfWeek=6), datetime(2008, 1, 7), False),
+         ]
+
+    for offset, date, expected in tests:
+        yield assertOnOffset, offset, date, expected
+
+
+def assertEq(dateOffset, baseDate, expected):
+    actual = dateOffset + baseDate
+    assert actual == expected
+
+def testBday():
+    tests = []
+    
+    tests.append((datetools.bday,
+                  {datetime(2008, 1, 1): datetime(2008, 1, 2),
+                   datetime(2008, 1, 4): datetime(2008, 1, 7),
+                   datetime(2008, 1, 5): datetime(2008, 1, 7),
+                   datetime(2008, 1, 6): datetime(2008, 1, 7),
+                   datetime(2008, 1, 7): datetime(2008, 1, 8)}))
+    
+    tests.append((2*datetools.bday,
+                  {datetime(2008, 1, 1): datetime(2008, 1, 3),
+                   datetime(2008, 1, 4): datetime(2008, 1, 8),
+                   datetime(2008, 1, 5): datetime(2008, 1, 8),
+                   datetime(2008, 1, 6): datetime(2008, 1, 8),
+                   datetime(2008, 1, 7): datetime(2008, 1, 9)}))
+    
+    tests.append((-datetools.bday,
+                  {datetime(2008, 1, 1): datetime(2007, 12, 31),
+                   datetime(2008, 1, 4): datetime(2008, 1, 3),
+                   datetime(2008, 1, 5): datetime(2008, 1, 4),
+                   datetime(2008, 1, 6): datetime(2008, 1, 4),
+                   datetime(2008, 1, 7): datetime(2008, 1, 4),
+                   datetime(2008, 1, 8): datetime(2008, 1, 7)}))
+
+    tests.append((-2*datetools.bday,
+                  {datetime(2008, 1, 1): datetime(2007, 12, 28),
+                   datetime(2008, 1, 4): datetime(2008, 1, 2),
+                   datetime(2008, 1, 5): datetime(2008, 1, 3),
+                   datetime(2008, 1, 6): datetime(2008, 1, 3),
+                   datetime(2008, 1, 7): datetime(2008, 1, 3),
+                   datetime(2008, 1, 8): datetime(2008, 1, 4),
+                   datetime(2008, 1, 9): datetime(2008, 1, 7)}))
+
+    tests.append((datetools.BDay(0),
+                  {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                   datetime(2008, 1, 4): datetime(2008, 1, 4),
+                   datetime(2008, 1, 5): datetime(2008, 1, 7),
+                   datetime(2008, 1, 6): datetime(2008, 1, 7),
+                   datetime(2008, 1, 7): datetime(2008, 1, 7)}))
+
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+    
+def testWeek():
+    tests = []
+    
+    tests.append((datetools.week, # not business week
+                  {datetime(2008, 1, 1): datetime(2008, 1, 8),
+                   datetime(2008, 1, 4): datetime(2008, 1, 11),
+                   datetime(2008, 1, 5): datetime(2008, 1, 12),
+                   datetime(2008, 1, 6): datetime(2008, 1, 13),
+                   datetime(2008, 1, 7): datetime(2008, 1, 14)}))
+    
+    tests.append((datetools.Week(dayOfWeek=0), # Mon
+                  {datetime(2007, 12, 31): datetime(2008, 1, 7),
+                   datetime(2008, 1, 4): datetime(2008, 1, 7),
+                   datetime(2008, 1, 5): datetime(2008, 1, 7),
+                   datetime(2008, 1, 6): datetime(2008, 1, 7),
+                   datetime(2008, 1, 7): datetime(2008, 1, 14)}))
+    
+    tests.append((datetools.Week(0, dayOfWeek=0), # n=0 -> roll forward. Mon
+                  {datetime(2007, 12, 31): datetime(2007, 12, 31),
+                   datetime(2008, 1, 4): datetime(2008, 1, 7),
+                   datetime(2008, 1, 5): datetime(2008, 1, 7),
+                   datetime(2008, 1, 6): datetime(2008, 1, 7),
+                   datetime(2008, 1, 7): datetime(2008, 1, 7)}))
+    
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+            
+def testBMonthEnd():        
+    tests = []
+    
+    tests.append((datetools.BMonthEnd(), 
+                 {datetime(2008, 1, 1): datetime(2008, 1, 31), 
+                  datetime(2008, 1, 31): datetime(2008, 2, 29),
+                  datetime(2006, 12, 29): datetime(2007, 1, 31), 
+                  datetime(2006, 12, 31): datetime(2007, 1, 31),
+                  datetime(2007, 1, 1): datetime(2007, 1, 31), 
+                  datetime(2006, 12, 1): datetime(2006, 12, 29)}))
+        
+    tests.append((datetools.BMonthEnd(0), 
+                  {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                   datetime(2008, 1, 31): datetime(2008, 1, 31),
+                   datetime(2006, 12, 29): datetime(2006, 12, 29),
+                   datetime(2006, 12, 31): datetime(2007, 1, 31),
+                   datetime(2007, 1, 1): datetime(2007, 1, 31)}))
+    
+    tests.append((datetools.BMonthEnd(2),
+                 {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                  datetime(2008, 1, 31): datetime(2008, 3, 31),
+                  datetime(2006, 12, 29): datetime(2007, 2, 28),
+                  datetime(2006, 12, 31): datetime(2007, 2, 28),
+                  datetime(2007, 1, 1): datetime(2007, 2, 28),
+                  datetime(2006, 11, 1): datetime(2006, 12, 29)}))
+
+    tests.append((datetools.BMonthEnd(-1),
+                 {datetime(2007, 1, 1): datetime(2006, 12, 29),
+                  datetime(2008, 6, 30): datetime(2008, 5, 30),
+                  datetime(2008, 12, 31): datetime(2008, 11, 28),
+                  datetime(2006, 12, 29): datetime(2006, 11, 30),
+                  datetime(2006, 12, 30): datetime(2006, 12, 29),
+                  datetime(2007, 1, 1): datetime(2006, 12, 29)}))
+        
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+  
+
+def testBYearEnd():
+    tests = []
+    
+    tests.append((datetools.BYearEnd(),
+                  {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                   datetime(2008, 6, 30): datetime(2008, 12, 31),
+                   datetime(2008, 12, 31): datetime(2009, 12, 31),
+                   datetime(2005, 12, 30): datetime(2006, 12, 29),
+                   datetime(2005, 12, 31): datetime(2006, 12, 29),}))
+
+    tests.append((datetools.BYearEnd(0),
+                  {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                   datetime(2008, 6, 30): datetime(2008, 12, 31),
+                   datetime(2008, 12, 31): datetime(2008, 12, 31),
+                   datetime(2005, 12, 31): datetime(2006, 12, 29),}))
+
+    tests.append((datetools.BYearEnd(-1),
+                  {datetime(2007, 1, 1): datetime(2006, 12, 29),
+                   datetime(2008, 6, 30): datetime(2007, 12, 31),
+                   datetime(2008, 12, 31): datetime(2007, 12, 31),
+                   datetime(2006, 12, 29): datetime(2005, 12, 30),
+                   datetime(2006, 12, 30): datetime(2006, 12, 29),
+                   datetime(2007, 1, 1): datetime(2006, 12, 29),}))
+
+    tests.append((datetools.BYearEnd(-2),
+                  {datetime(2007, 1, 1): datetime(2005, 12, 30),
+                   datetime(2008, 6, 30): datetime(2006, 12, 29),
+                   datetime(2008, 12, 31): datetime(2006, 12, 29),}))
+    
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+
+def testYearBegin():
+    tests = []
+    
+    tests.append((datetools.YearBegin(),
+                  {datetime(2008, 1, 1): datetime(2009, 1, 1),
+                   datetime(2008, 6, 30): datetime(2009, 1, 1),
+                   datetime(2008, 12, 31): datetime(2009, 1, 1),
+                   datetime(2005, 12, 30): datetime(2006, 1, 1),
+                   datetime(2005, 12, 31): datetime(2006, 1, 1),}))
+
+    tests.append((datetools.YearBegin(0),
+                  {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                   datetime(2008, 6, 30): datetime(2009, 1, 1),
+                   datetime(2008, 12, 31): datetime(2009, 1, 1),
+                   datetime(2005, 12, 30): datetime(2006, 1, 1),
+                   datetime(2005, 12, 31): datetime(2006, 1, 1),}))
+
+
+    tests.append((datetools.YearBegin(-1),
+                  {datetime(2007, 1, 1): datetime(2006, 1, 1),
+                   datetime(2008, 6, 30): datetime(2008, 1, 1),
+                   datetime(2008, 12, 31): datetime(2008, 1, 1),
+                   datetime(2006, 12, 29): datetime(2006, 1, 1),
+                   datetime(2006, 12, 30): datetime(2006, 1, 1),
+                   datetime(2007, 1, 1): datetime(2006, 1, 1),}))
+
+    tests.append((datetools.YearBegin(-2),
+                  {datetime(2007, 1, 1): datetime(2005, 1, 1),
+                   datetime(2008, 6, 30): datetime(2007, 1, 1),
+                   datetime(2008, 12, 31): datetime(2007, 1, 1),}))
+    
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected            
+            
+            
+def testBQuarterEnd():
+    tests = []
+    
+    tests.append((datetools.BQuarterEnd(),
+                  {datetime(2008, 1, 1): datetime(2008, 3, 31),
+                   datetime(2008, 1, 31): datetime(2008, 3, 31),
+                   datetime(2008, 2, 15): datetime(2008, 3, 31),
+                   datetime(2008, 2, 29): datetime(2008, 3, 31),        
+                   datetime(2008, 3, 15): datetime(2008, 3, 31),
+                   datetime(2008, 3, 31): datetime(2008, 6, 30),
+                   datetime(2008, 4, 15): datetime(2008, 6, 30),
+                   datetime(2008, 4, 30): datetime(2008, 6, 30),}))
+    
+    tests.append((datetools.BQuarterEnd(n = 0),
+                  {datetime(2008, 1, 1): datetime(2008, 3, 31),
+                   datetime(2008, 1, 31): datetime(2008, 3, 31),
+                   datetime(2008, 2, 15): datetime(2008, 3, 31),
+                   datetime(2008, 2, 29): datetime(2008, 3, 31),        
+                   datetime(2008, 3, 15): datetime(2008, 3, 31),
+                   datetime(2008, 3, 31): datetime(2008, 3, 31),
+                   datetime(2008, 4, 15): datetime(2008, 6, 30),
+                   datetime(2008, 4, 30): datetime(2008, 6, 30),}))
+    
+    tests.append((datetools.BQuarterEnd(n = -1),
+                  {datetime(2008, 1, 1): datetime(2007, 12, 31),
+                   datetime(2008, 1, 31): datetime(2007, 12, 31),
+                   datetime(2008, 2, 15): datetime(2007, 12, 31),
+                   datetime(2008, 2, 29): datetime(2007, 12, 31),        
+                   datetime(2008, 3, 15): datetime(2007, 12, 31),
+                   datetime(2008, 3, 31): datetime(2007, 12, 31),
+                   datetime(2008, 4, 15): datetime(2008, 3, 31),
+                  datetime(2008, 4, 30): datetime(2008, 3, 31),}))
+    
+    tests.append((datetools.BQuarterEnd(n = 2),
+                  {datetime(2008, 1, 1): datetime(2008, 6, 30),
+                   datetime(2008, 1, 31): datetime(2008, 6, 30),
+                   datetime(2008, 2, 15): datetime(2008, 6, 30),
+                   datetime(2008, 2, 29): datetime(2008, 6, 30),        
+                   datetime(2008, 3, 15): datetime(2008, 6, 30),
+                   datetime(2008, 3, 31): datetime(2008, 9, 30),
+                   datetime(2008, 4, 15): datetime(2008, 9, 30),
+                   datetime(2008, 4, 30): datetime(2008, 9, 30),}))
+    
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+
+def testBQuarterEndOffsets():
+    tests = []
+    
+    tests.append((datetools.BQuarterEnd(startingMonth=1),
+                  {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                   datetime(2008, 1, 31): datetime(2008, 4, 30),
+                   datetime(2008, 2, 15): datetime(2008, 4, 30),
+                   datetime(2008, 2, 29): datetime(2008, 4, 30),        
+                   datetime(2008, 3, 15): datetime(2008, 4, 30),
+                   datetime(2008, 3, 31): datetime(2008, 4, 30),
+                   datetime(2008, 4, 15): datetime(2008, 4, 30),
+                   datetime(2008, 4, 30): datetime(2008, 7, 31),}))
+
+    tests.append((datetools.BQuarterEnd(startingMonth=2),
+                  {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                   datetime(2008, 1, 31): datetime(2008, 2, 29),
+                   datetime(2008, 2, 15): datetime(2008, 2, 29),
+                   datetime(2008, 2, 29): datetime(2008, 5, 30),        
+                   datetime(2008, 3, 15): datetime(2008, 5, 30),
+                   datetime(2008, 3, 31): datetime(2008, 5, 30),
+                   datetime(2008, 4, 15): datetime(2008, 5, 30),
+                   datetime(2008, 4, 30): datetime(2008, 5, 30),}))
+    
+    tests.append((datetools.BQuarterEnd(startingMonth=1, n=0),
+                  {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                   datetime(2008, 1, 31): datetime(2008, 1, 31),
+                   datetime(2008, 2, 15): datetime(2008, 4, 30),
+                   datetime(2008, 2, 29): datetime(2008, 4, 30),        
+                   datetime(2008, 3, 15): datetime(2008, 4, 30),
+                   datetime(2008, 3, 31): datetime(2008, 4, 30),
+                   datetime(2008, 4, 15): datetime(2008, 4, 30),
+                   datetime(2008, 4, 30): datetime(2008, 4, 30),}))
+     
+    tests.append((datetools.BQuarterEnd(startingMonth=1, n=-1),
+                  {datetime(2008, 1, 1): datetime(2007, 10, 31),
+                   datetime(2008, 1, 31): datetime(2007, 10, 31),
+                   datetime(2008, 2, 15): datetime(2008, 1, 31),
+                   datetime(2008, 2, 29): datetime(2008, 1, 31),        
+                   datetime(2008, 3, 15): datetime(2008, 1, 31),
+                   datetime(2008, 3, 31): datetime(2008, 1, 31),
+                   datetime(2008, 4, 15): datetime(2008, 1, 31),
+                   datetime(2008, 4, 30): datetime(2008, 1, 31),}))
+    
+    tests.append((datetools.BQuarterEnd(startingMonth=1, n=2),
+                  {datetime(2008, 1, 31): datetime(2008, 7, 31),
+                   datetime(2008, 2, 15): datetime(2008, 7, 31),
+                   datetime(2008, 2, 29): datetime(2008, 7, 31),        
+                   datetime(2008, 3, 15): datetime(2008, 7, 31),
+                   datetime(2008, 3, 31): datetime(2008, 7, 31),
+                   datetime(2008, 4, 15): datetime(2008, 7, 31),
+                   datetime(2008, 4, 30): datetime(2008, 10, 31),}))
+
+    for dateOffset, cases in tests:
+        for baseDate, expected in cases.iteritems():
+            yield assertEq, dateOffset, baseDate, expected
+
+
+        
+####
+## XDateRange Tests
+####
+def eqXDateRange(kwargs, expected):
+    actual = list(XDateRange(**kwargs))
+    assert actual == expected
+    
+def testXDateRange1():    
+    eqXDateRange(dict(fromDate = datetime(2009, 3, 25),
+                      nPeriods = 2), 
+                 [datetime(2009, 3, 25), datetime(2009, 3, 26)])
+
+def testXDateRange2():    
+    eqXDateRange(dict(fromDate = datetime(2008, 1, 1),
+                      toDate = datetime(2008, 1, 3)),
+                 [datetime(2008, 1, 1),
+                  datetime(2008, 1, 2),
+                  datetime(2008, 1, 3)])
+    
+def testXDateRange3():    
+    eqXDateRange(dict(fromDate = datetime(2008, 1, 5),
+                      toDate = datetime(2008, 1, 6)),
+                 [])
+    
+
+    
+# DateRange test
+
+def assertEqual(a, b):
+    actual = dateOffset + baseDate
+    assert actual == expected
+
+def testDateRange1():
+    toDate = datetime(2009, 5, 13)
+    dr = DateRange(toDate=toDate, periods=20)
+    firstDate = toDate - 19 * datetools.bday
+    
+    assert len(dr) == 20
+    assert dr[0] == firstDate
+    assert dr[-1] == toDate
diff --git a/pandas/core/tests/test_groupby.py b/pandas/core/tests/test_groupby.py
new file mode 100644
index 000000000..066ef06f5
--- /dev/null
+++ b/pandas/core/tests/test_groupby.py
@@ -0,0 +1,64 @@
+import unittest
+
+from pandas.core.daterange import DateRange
+from pandas.core.index import Index
+from pandas.core.groupby import GroupBy
+from pandas.core.pytools import rands, groupby
+from pandas.core.frame import DataFrame
+from pandas.core.matrix import DataMatrix
+from pandas.core.series import Series
+import pandas.core.datetools as dt
+import pandas.lib.tseries as tseries
+import numpy as np
+
+# unittest.TestCase
+
+def commonSetUp(self):    
+    self.dateRange = DateRange('1/1/2005', periods=250, offset=dt.bday)
+    self.stringIndex = Index([rands(8).upper() for x in xrange(250)])
+
+    self.groupId = Series([x[0] for x in self.stringIndex],
+                              index=self.stringIndex)
+    self.groupDict = dict((k, v) for k, v in self.groupId.iteritems())
+    
+    self.columnIndex = Index(['A', 'B', 'C', 'D', 'E'])
+    
+    randMat = np.random.randn(250, 5)
+    self.stringMatrix = DataMatrix(randMat, columns=self.columnIndex,
+                                  index=self.stringIndex)
+    
+    self.timeMatrix = DataMatrix(randMat, columns=self.columnIndex,
+                                 index=self.dateRange)
+
+
+class GroupByTestCase(unittest.TestCase):
+    setUp = commonSetUp
+    
+    def testPythonGrouper(self):
+        groupFunc = self.groupDict.get
+
+        groups = groupby(self.stringIndex, groupFunc)
+        
+        setDict = dict((k, set(v)) for k, v in groups.iteritems())
+        for idx in self.stringIndex:
+            key = groupFunc(idx)
+            groupSet = setDict[key]        
+            self.assert_(idx in groupSet)
+        
+    def testCythonGrouper(self):
+        pass
+        
+    def testNaNGrouping(self):
+        pass
+    
+    def testMembership(self):
+        pass
+        
+    def testByColumnName(self):
+        pass
+        
+class TestAggregate(unittest.TestCase):
+    setUp = commonSetUp
+    
+class TestTransform(unittest.TestCase):
+    setUp = commonSetUp
diff --git a/pandas/core/tests/test_index.py b/pandas/core/tests/test_index.py
new file mode 100644
index 000000000..406e1edeb
--- /dev/null
+++ b/pandas/core/tests/test_index.py
@@ -0,0 +1,94 @@
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import bday
+from pandas.core.index import Index
+from pandas.core.series import Series
+from pandas.lib.tseries import map_indices
+from copy import deepcopy
+from datetime import datetime
+from numpy import isnan, array, NaN, alltrue
+from numpy import random
+from random import choice
+import numpy as np
+import os
+import pickle
+import string
+import sys
+import unittest
+
+def rands(n):
+    return ''.join([choice(string.letters + string.digits) for i in range(n)])
+def equalContents(arr1, arr2):
+    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
+    """
+    return frozenset(arr1) == frozenset(arr2)
+
+class TestIndex(unittest.TestCase):
+    def setUp(self):
+        self.strIndex = Index([rands(10) for i in range(50)])
+        self.dateIndex = DateRange(datetime(2008,4,22), periods=50, offset=bday)
+        self.intIndex = Index(np.arange(50))
+        
+    def testSlice(self):
+        strSlice = self.strIndex[10:20]
+        dateSlice = self.dateIndex[10:20]
+        intSlice = self.intIndex[10:20]
+        strMap = map_indices(array(strSlice))
+        dateMap = map_indices(array(dateSlice))
+        intMap = map_indices(array(intSlice))
+        for key, value in strMap.iteritems():
+            self.assert_(strSlice.indexMap[key] == value)
+        for key, value in dateMap.iteritems():
+            self.assert_(dateSlice.indexMap[key] == value)        
+        for key, value in intMap.iteritems():
+            self.assert_(intSlice.indexMap[key] == value)        
+    
+    def testGetItem(self):
+        sl = self.strIndex[[1,2,3]]
+        for i in sl:
+            self.assertEqual(i, sl[sl.indexMap[i]])
+        boolIdx = np.repeat(True, len(self.strIndex)).astype(bool)
+        boolIdx[5:30:2] = False
+        subIndex = self.strIndex[boolIdx]
+        strMap = map_indices(subIndex)
+        for key, value in strMap.iteritems():
+            self.assert_(subIndex.indexMap[key] == value)
+        
+    def testAdd(self):
+        firstCat = self.strIndex + self.dateIndex
+        secondCat = self.strIndex + self.strIndex
+        self.assert_(equalContents(np.append(self.strIndex, self.dateIndex), firstCat))
+        self.assert_(equalContents(secondCat, self.strIndex))
+        for key in self.strIndex:
+            self.assert_(key in firstCat.indexMap)
+            self.assert_(key in secondCat.indexMap)
+        for key in self.dateIndex:
+            self.assert_(key in firstCat.indexMap)
+            
+    def testContains(self):
+        self.assert_(self.strIndex[10] in self.strIndex)
+        self.assert_(self.dateIndex[10] in self.dateIndex)
+        self.assert_(self.intIndex[10] in self.intIndex)
+        strSlice = self.strIndex[10:20]
+        dateSlice = self.dateIndex[10:20]
+        intSlice = self.intIndex[10:20]
+        self.assert_(self.strIndex[9] not in strSlice)
+        self.assert_(self.dateIndex[9] not in dateSlice)
+        self.assert_(self.intIndex[9] not in intSlice)
+    
+    def testMutability(self):
+        self.assertRaises(Exception, self.strIndex.__setitem__, 5, 0)
+        self.assertRaises(Exception, self.strIndex.__setitem__, slice(1,5), 0)
+    
+    def testPickle(self):
+        f = open('tmp', 'wb')
+        pickle.dump(self.strIndex, f)
+        f.close()
+        f = open('tmp', 'rb')
+        unPickled = pickle.load(f)
+        f.close()
+        os.remove('tmp')
+        self.assert_(isinstance(unPickled, Index))
+        self.assert_(equalContents(unPickled, self.strIndex))
+        for k, v in self.strIndex.indexMap.iteritems():
+            self.assert_(k in unPickled.indexMap)
+            self.assertEqual(unPickled.indexMap[k], v)
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
new file mode 100644
index 000000000..891613157
--- /dev/null
+++ b/pandas/core/tests/test_series.py
@@ -0,0 +1,240 @@
+from pandas.core.daterange import DateRange
+from pandas.core.datetools import bday
+from pandas.core.index import Index
+from pandas.core.series import Series
+from pandas.lib.tseries import map_indices
+from copy import deepcopy
+from datetime import datetime
+from numpy import isnan, array, NaN, alltrue
+from numpy import random
+from random import choice
+import numpy as np
+import os
+import pickle
+import string
+import sys
+import unittest
+
+def rands(n):
+    return ''.join([choice(string.letters + string.digits) for i in range(n)])
+def equalContents(arr1, arr2):
+    """Checks if the set of unique elements of arr1 and arr2 are equivalent.
+    """
+    return frozenset(arr1) == frozenset(arr2)
+
+#-------------------------------------------------------------------------------
+# Series test cases
+
+class TestSeries(unittest.TestCase):
+    def setUp(self):
+        index = Index([rands(10) for i in range(50)])
+        dateIndex = DateRange(datetime(2008,4,22), periods=50, offset=bday)
+        self.ts = Series(random.random(50), index=dateIndex)
+        self.series = Series(random.random(50), index=index)
+        self.objSeries = Series(dateIndex, index=index)
+        #self.plainSeries = Series(random.random(50))
+    
+    def testSlice(self):
+        numSlice = self.series[10:20]
+        numSliceEnd = self.series[-10:]
+        objSlice = self.objSeries[10:20]
+        self.assert_(self.series.index[9] not in numSlice.index)
+        self.assert_(self.objSeries.index[9] not in objSlice.index)
+        self.assertEqual(len(numSlice), len(numSlice.index))
+        self.assertEqual(self.series[numSlice.index[0]], numSlice[numSlice.index[0]])
+        self.assertEqual(numSlice.index[1], self.series.index[11])
+        self.assert_(equalContents(numSliceEnd, array(self.series)[-10:]))
+    
+    def testGet(self):
+        self.assertEqual(self.series[5], self.series.get(self.series.index[5]))
+    
+    def testGetItem(self):
+        idx1 = self.series.index[5]
+        idx2 = self.objSeries.index[5]
+        self.assertEqual(self.series[idx1], self.series.get(idx1))
+        self.assertEqual(self.objSeries[idx2], self.objSeries.get(idx2))
+    
+    def testSetItem(self):
+        self.ts[self.ts.index[5]] = NaN
+        self.ts[[1,2,27]] = NaN
+        self.ts[6] = NaN
+        self.assert_(isnan(self.ts[6]))
+        self.assert_(isnan(self.ts[2]))
+        self.ts[isnan(self.ts)] = 5
+        self.assert_(not isnan(self.ts[2]))
+        
+    def testSetSlice(self):
+        slice = self.ts[5:20]
+        self.assertEqual(len(slice), len(slice.index))
+        self.assertEqual(len(slice.index.indexMap), len(slice.index))
+        
+    def testGetSequence(self):
+        slice1 = self.series[[1,2,3]]
+        slice2 = self.objSeries[[1,2,3]]
+        self.assertEqual(self.series.index[2], slice1.index[1])
+        self.assertEqual(self.objSeries.index[2], slice2.index[1])
+        self.assertEqual(self.series[2], slice1[1])
+        self.assertEqual(self.objSeries[2], slice2[1])
+
+        #slice3 = self.plainSeries[[1,2,3]]
+        #self.assertEqual(self.plainSeries[2], slice3[1])
+        
+    def testMeta(self):
+        wrapped = Series(self.series)
+        self.assert_(equalContents(wrapped.index, self.series.index))
+        # Ensure new index is not created
+        self.assertEquals(id(self.series.index), id(wrapped.index))
+    
+    def testStatistics(self):
+        self.series[5:15] = NaN
+        
+        s1 = array(self.series)
+        s1 = s1[-isnan(s1)]
+        self.assertEquals(np.mean(s1), self.series.mean())
+        self.assertEquals(np.std(s1, ddof=1), self.series.std())
+        self.assertEquals(np.var(s1, ddof=1), self.series.var())
+        self.assertEquals(np.sum(s1), self.series.sum())
+        self.assert_(not isnan(np.sum(self.series)))
+        self.assert_(not isnan(np.mean(self.series)))
+        self.assert_(not isnan(np.std(self.series)))
+        self.assert_(not isnan(np.var(self.series)))
+
+        #self.plainSeries[20:25] = NaN
+        #s2 = array(self.plainSeries)
+        #s2 = s2[-isnan(s2)]
+        #self.assertEquals(np.mean(s2), self.plainSeries.mean())
+        #self.assertEquals(np.std(s2, ddof=1), self.plainSeries.std())
+        #self.assertEquals(np.var(s2, ddof=1), self.plainSeries.var())
+        #self.assertEquals(np.sum(s2), self.plainSeries.sum())
+
+        #self.assert_(isnan(self.series.mean(removeNA=False)))
+        #self.assert_(isnan(self.series.std(removeNA=False)))
+        #self.assert_(isnan(self.series.var(removeNA=False)))
+        #self.assert_(isnan(self.series.sum(removeNA=False)))
+        
+    def testPickle(self):
+        f = open('tmp1', 'wb')
+        #g = open('tmp2', 'wb')
+        h = open('tmp3', 'wb')
+        pickle.dump(self.series, f)
+        #pickle.dump(self.plainSeries, g)
+        pickle.dump(self.ts, h)
+        f.close()
+        #g.close()
+        h.close()
+        f = open('tmp1', 'rb')
+        #g = open('tmp2', 'rb')
+        h = open('tmp3', 'rb')
+        unPickledf = pickle.load(f)
+        #unPickledg = pickle.load(g)
+        unPickledh = pickle.load(h)
+        f.close()
+        #g.close()
+        h.close()
+        os.remove('tmp1')
+        #os.remove('tmp2')
+        os.remove('tmp3')
+        self.assert_(isinstance(unPickledf, Series))
+        #self.assert_(isinstance(unPickledg, Series))
+        self.assert_(isinstance(unPickledh, Series))
+        self.assert_(equalContents(unPickledf, self.series))
+        #self.assert_(equalContents(unPickledg, self.plainSeries))
+        self.assert_(equalContents(unPickledh, self.ts))
+        for idx in self.series.index:
+            self.assert_(idx in unPickledf.index)
+            self.assertEqual(unPickledf[idx], self.series[idx])    
+        for idx in self.ts.index:
+            self.assert_(idx in unPickledh.index)
+            self.assertEqual(unPickledh[idx], self.ts[idx])    
+            
+    def testIter(self):
+        for i, val in enumerate(self.series):
+            self.assertEqual(val, self.series[i])
+        for i, val in enumerate(self.ts):
+            self.assertEqual(val, self.ts[i])
+        for idx, val in self.series.iteritems():
+            self.assertEqual(val, self.series[idx])
+        for idx, val in self.ts.iteritems():
+            self.assertEqual(val, self.ts[idx])            
+        #self.assertRaises(Exception, self.plainSeries.iteritems)
+        
+    def testFromIndex(self):
+        identity = self.series.reindex(self.series.index)
+        self.assertEqual(id(self.series.index), id(identity.index))
+        subIndex = self.series.index[10:20]
+        subSeries = self.series.reindex(subIndex)
+        for idx, val in subSeries.iteritems():
+            self.assertEqual(val, self.series[idx])
+        subIndex2 = self.ts.index[10:20]
+        subTS = self.ts.reindex(subIndex2)
+        for idx, val in subTS.iteritems():
+            self.assertEqual(val, self.ts[idx])
+        crapSeries = self.ts.reindex(subIndex)
+        self.assert_(alltrue(isnan(crapSeries)))
+        
+        # This is extremely important for the Cython code to not screw up
+        nonContigIndex = self.ts.index[::2]
+        subNonContig = self.ts.reindex(nonContigIndex)
+        for idx, val in subNonContig.iteritems():
+            self.assertEqual(val, self.ts[idx])            
+    
+    def testCombineFunc(self):
+        shiftedSum = self.ts + self.ts.shift(5)
+        idSum = self.ts + self.ts
+        self.assert_(isnan(shiftedSum[0]))
+        for idx, val in idSum.iteritems():
+            self.assertAlmostEqual(self.ts[idx] + self.ts[idx], val)
+        multiplied = self.ts * 5
+        for idx, val in multiplied.iteritems():
+            self.assertEqual(self.ts[idx] * 5, val)
+
+    def testOperators(self):
+        newSeries = deepcopy(self.series)
+        newSeries[5:10] = NaN
+        newSeries[10:20] = newSeries[10:20] + 1
+        newSeries[20:30] = newSeries[20:30] - 1
+        eqSeries = (newSeries == self.series)
+        ltSeries = (newSeries < self.series)
+        gtSeries = (newSeries > self.series)
+        self.assertTrue(ltSeries[20])
+        self.assertFalse(ltSeries[10])
+        self.assertTrue(gtSeries[10])
+        self.assertFalse(gtSeries[20])
+        
+        
+    def testShift(self):
+        shifted = self.ts.shift(1)
+        unshifted = shifted.shift(-1)
+        #self.assert_(equalContents(self.ts.index, unshifted.index))
+        idxMap = self.ts.index.indexMap
+        for k, v in unshifted.iteritems():
+            self.assertEqual(self.ts[idxMap[k]], v)
+
+    def testAsOf(self):
+        self.ts[5:10] = NaN
+        self.ts[15:20] = NaN
+        val1 = self.ts.asOf(self.ts.index[7])
+        val2 = self.ts.asOf(self.ts.index[19])
+        self.assertEqual(val1, self.ts[4])
+        self.assertEqual(val2, self.ts[14])
+        
+    def testPreserveReferences(self):
+        slice = self.ts[5:10]
+        seq = self.ts[[5,10,15]]
+        slice[4] = NaN
+        seq[1] = NaN
+        self.assertFalse(isnan(self.ts[9]))
+        self.assertFalse(isnan(self.ts[10]))
+        
+    def testAppend(self):
+        appendedSeries = self.series.append(self.ts)
+        for idx, value in appendedSeries.iteritems():
+            if idx in self.series.index:
+                self.assertEqual(value, self.series[idx])
+            elif idx in self.ts.index:
+                self.assertEqual(value, self.ts[idx])
+            else:
+                self.fail("orphaned index!")
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pandas/io/__init__.py b/pandas/io/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
new file mode 100644
index 000000000..eceb8d12f
--- /dev/null
+++ b/pandas/io/parsers.py
@@ -0,0 +1,141 @@
+"""
+Module contains tools for processing files into DataFrames or other objects
+"""
+
+from pandas.core.index import Index
+from pandas.core.frame import DataFrame
+from pandas.core.matrix import DataMatrix
+from pandas.core.series import Series
+
+from datetime import datetime, timedelta
+
+try:
+    from dateutil import parser
+except ImportError:
+    # just a little hack for now
+    class parser(object):
+        @classmethod
+        def parse(cls, val):
+            try:
+                return datetime.strptime(val, '%m/%d/%Y')
+            except:
+                return val
+
+from itertools import izip
+import numpy as np
+import string
+
+def simpleParser(nestedList, forceFloat=True, colNames=None,
+                 header=0, indexCol=0):
+    """
+    Workhorse function for processing nested list into DataFrame
+    """
+    naValues = set(['-1.#IND', '1.#QNAN', '1.#IND', 
+                    '-1.#QNAN','1.#INF','-1.#INF', '1.#INF000000',
+                    'NA', 'NULL', 'NaN', 'nan', ''])
+    lines = nestedList
+    data = {}
+    if header is not None:
+        columns = lines[header]
+        columns = [c if c != '' else 'Unnamed: ' + string.ascii_uppercase[i] 
+                   for i, c in enumerate(columns)]
+        content = lines[header+1:]
+
+        colCounts = dict(((col, 0) for col in columns))
+        for i, col in enumerate(columns):
+            if columns.count(col) > 1:
+                columns[i] = col + str(colCounts[col])
+                colCounts[col] += 1
+    else:
+        if not colNames:
+            columns = string.ascii_uppercase[:len(lines[0])]
+        else:
+            columns = colNames
+        content = lines
+
+    for i, (c, col) in enumerate(izip(columns, izip(*content))):            
+        if i == indexCol:
+            data[c] = col
+            continue
+        data[c] = []
+        for val in col:
+            if val in naValues:
+                val = np.nan
+            else:
+                try:    
+                    tmp = val        
+                    val = np.float64(val)
+                    if isinf(val):
+                        val = tmp
+                except:
+                    pass
+            data[c].append(val)
+
+    if header is not None:
+        if 'date' in columns[0].lower() or 'Unnamed' in columns[0]:
+            dates = []
+            for s in data[columns[0]]:
+                try:
+                    dates.append(parser.parse(s))
+                except:
+                    dates.append(s)
+            data[columns[0]] = dates
+    for c, values in data.iteritems():
+        try:
+            data[c] = np.array(values, dtype = np.float64)
+        except:
+            data[c] = np.array(values, dtype = np.object_)            
+    if indexCol is not None:
+        index = Index(data[columns[indexCol]])
+        frameData = dict([(col, data[col]) for col in columns \
+                        if col != columns[indexCol]])
+        return DataFrame(data=frameData, index=index)
+    else:
+        index = np.arange(len(data.values()[0]))
+        frameData = dict([(col, data[col]) for col in columns])
+        return DataFrame(data=frameData, index=index)
+    
+def parseCSV(filepath, header=0, indexCol=0):
+    """
+    Parse CSV file into a DataFrame object. Try to parse dates if possible.
+    """
+    import csv
+    f = open(filepath,'rb')
+    reader = csv.reader(f, dialect='excel')
+    lines = [l for l in reader]
+    f.close()
+    return simpleParser(lines, header=header, indexCol=indexCol)
+
+def parseText(filepath, sep='\t', header=0, indexCol=0, colNames = None):
+    """
+    Parse whitespace separated file into a DataFrame object. 
+    Try to parse dates if possible.
+    """
+    lines = [l.rstrip().split(sep) for l in open(filepath,'rb').readlines()]
+    return simpleParser(lines, header=header, indexCol=indexCol, 
+                        colNames = colNames)
+
+#===============================================================================
+# Excel tools
+#===============================================================================
+
+OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
+def ole2datetime(oledt):
+    """function for converting excel date to normal date format"""
+    return OLE_TIME_ZERO + timedelta(days=float(oledt))  
+
+def parseExcel(filepath, header = None, indexCol = 0, dateCol = 0, 
+               sheetname = None):
+    try:
+        import xlrd
+    except ImportError:
+        raise ImportError('Sorry, you do not have xlrd.')
+    book = xlrd.open_workbook(filepath)
+    sheet = book.sheet_by_name(sheetname)
+    data = [sheet.row_values(i) for i in range(sheet.nrows)]
+    for row in data:
+        try:
+            row[0] = ole2datetime(row[0])
+        except:
+            pass
+    return simpleParser(data, header = header, indexCol = indexCol)
diff --git a/pandas/lib/__init__.py b/pandas/lib/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/lib/include/Python.pxi b/pandas/lib/include/Python.pxi
new file mode 100644
index 000000000..03018e960
--- /dev/null
+++ b/pandas/lib/include/Python.pxi
@@ -0,0 +1,54 @@
+# :Author:    Robert Kern
+# :Copyright: 2004, Enthought, Inc.
+# :License:   BSD Style
+
+
+cdef extern from "Python.h":
+    # Not part of the Python API, but we might as well define it here.
+    # Note that the exact type doesn't actually matter for Pyrex.
+    ctypedef int size_t
+
+    # String API
+    char* PyString_AsString(object string)
+    char* PyString_AS_STRING(object string)
+    object PyString_FromString(char* c_string)
+    object PyString_FromStringAndSize(char* c_string, int length)
+
+    # Float API
+    double PyFloat_AsDouble(object ob)
+    long PyInt_AsLong(object ob)
+
+    # Memory API
+    void* PyMem_Malloc(size_t n)
+    void* PyMem_Realloc(void* buf, size_t n)
+    void PyMem_Free(void* buf)
+
+    void Py_DECREF(object obj)
+    void Py_XDECREF(object obj)
+    void Py_INCREF(object obj)
+    void Py_XINCREF(object obj)
+
+    # CObject API
+    ctypedef void (*destructor1)(void* cobj)
+    ctypedef void (*destructor2)(void* cobj, void* desc)
+    int PyCObject_Check(object p)
+    object PyCObject_FromVoidPtr(void* cobj, destructor1 destr)
+    object PyCObject_FromVoidPtrAndDesc(void* cobj, void* desc, 
+        destructor2 destr)
+    void* PyCObject_AsVoidPtr(object self)
+    void* PyCObject_GetDesc(object self)
+    int PyCObject_SetVoidPtr(object self, void* cobj)  
+
+    # TypeCheck API
+    int PyFloat_Check(object obj)
+    int PyInt_Check(object obj)
+
+    # Error API
+    int PyErr_Occurred()
+    void PyErr_Clear()
+ 
+cdef extern from "string.h":
+    void *memcpy(void *s1, void *s2, int n)
+
+cdef extern from "math.h":
+    double fabs(double x)
diff --git a/pandas/lib/include/datetime.pxi b/pandas/lib/include/datetime.pxi
new file mode 100644
index 000000000..e0df966d4
--- /dev/null
+++ b/pandas/lib/include/datetime.pxi
@@ -0,0 +1,14 @@
+cdef extern from "datetime.h":
+    
+    ctypedef extern class datetime.datetime [object PyDateTime_DateTime]:
+        cdef int *data
+        cdef long hashcode
+        cdef char hastzinfo
+        
+    int PyDateTime_GET_YEAR(datetime o)
+    int PyDateTime_GET_MONTH(datetime o)
+    int PyDateTime_GET_DAY(datetime o)
+    int PyDateTime_TIME_GET_HOUR(datetime o)
+    int PyDateTime_TIME_GET_MINUTE(datetime o)
+    int PyDateTime_TIME_GET_SECOND(datetime o)
+    int PyDateTime_TIME_GET_MICROSECOND(datetime o)
\ No newline at end of file
diff --git a/pandas/lib/include/numpy.pxi b/pandas/lib/include/numpy.pxi
new file mode 100644
index 000000000..0f2f1ec13
--- /dev/null
+++ b/pandas/lib/include/numpy.pxi
@@ -0,0 +1,150 @@
+# :Author:    Travis Oliphant
+
+cdef extern from "numpy/arrayobject.h":
+
+	cdef enum NPY_TYPES:
+		NPY_BOOL
+		NPY_BYTE	
+		NPY_UBYTE
+		NPY_SHORT
+		NPY_USHORT 
+		NPY_INT
+		NPY_UINT 
+		NPY_LONG
+		NPY_ULONG
+		NPY_LONGLONG
+		NPY_ULONGLONG
+		NPY_FLOAT
+		NPY_DOUBLE
+		NPY_LONGDOUBLE
+		NPY_CFLOAT
+		NPY_CDOUBLE
+		NPY_CLONGDOUBLE
+		NPY_OBJECT
+		NPY_STRING
+		NPY_UNICODE
+		NPY_VOID
+		NPY_NTYPES
+		NPY_NOTYPE
+
+	cdef enum requirements:
+		NPY_CONTIGUOUS
+		NPY_FORTRAN
+		NPY_OWNDATA
+		NPY_FORCECAST
+		NPY_ENSURECOPY
+		NPY_ENSUREARRAY
+		NPY_ELEMENTSTRIDES
+		NPY_ALIGNED
+		NPY_NOTSWAPPED
+		NPY_WRITEABLE
+		NPY_UPDATEIFCOPY
+		NPY_ARR_HAS_DESCR
+		
+		NPY_BEHAVED
+		NPY_BEHAVED_NS
+		NPY_CARRAY
+		NPY_CARRAY_RO
+		NPY_FARRAY
+		NPY_FARRAY_RO
+		NPY_DEFAULT
+		
+		NPY_IN_ARRAY
+		NPY_OUT_ARRAY
+		NPY_INOUT_ARRAY
+		NPY_IN_FARRAY
+		NPY_OUT_FARRAY
+		NPY_INOUT_FARRAY
+		
+		NPY_UPDATE_ALL 
+
+	cdef enum NPY_SORTKIND:
+		NPY_QUICKSORT
+		NPY_HEAPSORT
+		NPY_MERGESORT
+	
+	cdef enum defines:
+		NPY_MAXDIMS
+
+	ctypedef struct npy_cdouble:
+		double real
+		double imag
+
+	ctypedef struct npy_cfloat:
+		double real
+		double imag
+	
+	ctypedef int npy_intp
+	
+	ctypedef extern class numpy.dtype [object PyArray_Descr]:
+		cdef int type_num, elsize, alignment
+		cdef char type, kind, byteorder, hasobject
+		cdef object fields, typeobj
+		cdef object f
+
+	ctypedef extern class numpy.ndarray [object PyArrayObject]:
+		cdef char *data
+		cdef int nd
+		cdef npy_intp *dimensions
+		cdef npy_intp *strides
+		cdef object base
+		cdef dtype descr
+		cdef int flags
+		
+	ctypedef extern class numpy.flatiter [object PyArrayIterObject]:
+		cdef int  nd_m1
+		cdef npy_intp index, size
+		cdef ndarray ao
+		cdef char *dataptr
+        
+	ctypedef extern class numpy.broadcast [object PyArrayMultiIterObject]:
+		cdef int numiter
+		cdef npy_intp size, index
+		cdef int nd
+		cdef npy_intp *dimensions
+		cdef void **iters
+
+	object PyArray_ZEROS(int ndims, npy_intp* dims, int type_num, int fortran)
+	object PyArray_EMPTY(int ndims, npy_intp* dims, int type_num, int fortran)
+	dtype PyArray_DescrFromTypeNum(NPY_TYPES type_num)
+	object PyArray_SimpleNew(int ndims, npy_intp* dims, NPY_TYPES type_num)
+	int PyArray_Check(object obj)
+	object PyArray_ContiguousFromAny(object obj, int type, 
+		int mindim, int maxdim)
+	object PyArray_ContiguousFromObject(object obj, NPY_TYPES type, 
+		int mindim, int maxdim)
+	npy_intp PyArray_SIZE(ndarray arr)
+	npy_intp PyArray_NBYTES(ndarray arr)
+	npy_intp *PyArray_DIMS(object arr)
+	void *PyArray_DATA(ndarray arr)
+	int PyArray_ITEMSIZE(object arr)
+	
+	int PyArray_ISBEHAVED(ndarray arr)
+	
+	int PyArray_TYPE(object arr)
+		
+	object PyArray_GETITEM(object obj, void* itemptr)
+	int PyArray_SETITEM(object obj, void* itemptr, object item)
+	object PyArray_FromAny(object obj, dtype newtype, int mindim, int maxdim,
+						   int requirements, object context)
+	object PyArray_FROMANY(object obj, NPY_TYPES type_num, int min,
+						   int max, int requirements)
+	object PyArray_NewFromDescr(object subtype, dtype newtype, int nd,
+								npy_intp* dims, npy_intp* strides, void* data,
+								int flags, object parent)
+	
+	object PyArray_FROM_OTF(object obj, NPY_TYPES type, int flags)
+	object PyArray_EnsureArray(object)
+	
+	object PyArray_MultiIterNew(int n, ...)
+	
+	char *PyArray_MultiIter_DATA(broadcast multi, int i)
+	void PyArray_MultiIter_NEXTi(broadcast multi, int i) 
+	void PyArray_MultiIter_NEXT(broadcast multi)
+	
+	object PyArray_IterNew(object arr)
+	void PyArray_ITER_NEXT(flatiter it)
+	void PyArray_ITER_GOTO(flatiter it, npy_intp* i)
+	void PyArray_ITER_GOTO1D(flatiter it, npy_intp i)
+	
+	void import_array()
diff --git a/pandas/lib/include/python_datetime.pxd b/pandas/lib/include/python_datetime.pxd
new file mode 100644
index 000000000..fed6e55d0
--- /dev/null
+++ b/pandas/lib/include/python_datetime.pxd
@@ -0,0 +1,16 @@
+cdef extern from "datetime.h":
+    
+    ctypedef extern class datetime.datetime [object PyDateTime_DateTime]:
+        cdef int *data
+        cdef long hashcode
+        cdef char hastzinfo
+        
+    int PyDateTime_GET_YEAR(datetime o)
+    int PyDateTime_GET_MONTH(datetime o)
+    int PyDateTime_GET_DAY(datetime o)
+    int PyDateTime_TIME_GET_HOUR(datetime o)
+    int PyDateTime_TIME_GET_MINUTE(datetime o)
+    int PyDateTime_TIME_GET_SECOND(datetime o)
+    int PyDateTime_TIME_GET_MICROSECOND(datetime o)
+    void PyDateTime_IMPORT()
+    
\ No newline at end of file
diff --git a/pandas/lib/src/tdates.c b/pandas/lib/src/tdates.c
new file mode 100644
index 000000000..8c995175f
--- /dev/null
+++ b/pandas/lib/src/tdates.c
@@ -0,0 +1,57 @@
+#include <Python.h>
+#include <datetime.h>
+#include <numpy/arrayobject.h>
+#include <stdio.h>
+
+static PyObject* isAllDates(PyObject *self, PyObject *args) {
+    PyDateTime_IMPORT;
+
+    PyObject *input;
+    PyArrayIterObject *iter;
+    PyObject *obj;
+
+
+    if (PyArg_ParseTuple(args, "O", &input)) {
+        if (!PyArray_Check(input)) {
+            PyErr_SetString(PyExc_RuntimeError, "Input was not ndarray!");
+            return NULL;
+        }
+
+        long size = PyArray_SIZE(input);
+    
+        if (size == 0) {
+            Py_RETURN_FALSE;	
+        }
+    
+        iter = (PyArrayIterObject *) PyArray_IterNew(input);
+    
+        while (iter->index < iter->size) {
+            obj = PyArray_GETITEM(input, (void *) iter->dataptr);
+            if (!PyDateTime_Check(obj)) {
+                Py_DECREF(obj);
+                Py_DECREF(iter);
+    
+                Py_RETURN_FALSE;
+            }
+    
+            Py_DECREF(obj);
+            PyArray_ITER_NEXT(iter);
+        }
+    
+        Py_DECREF(iter);
+        Py_RETURN_TRUE;
+    }	
+    return NULL;
+}
+
+static PyMethodDef tdatesMethods[] =
+{
+    { "isAllDates", isAllDates, METH_VARARGS, NULL },
+    {  NULL, NULL, 0, NULL},
+};
+
+PyMODINIT_FUNC inittdates(void)
+{
+    (void) Py_InitModule("tdates", tdatesMethods);
+    import_array();
+}
diff --git a/pandas/lib/src/tseries.c b/pandas/lib/src/tseries.c
new file mode 100644
index 000000000..076f4f070
--- /dev/null
+++ b/pandas/lib/src/tseries.c
@@ -0,0 +1,12922 @@
+/* Generated by Cython 0.11.2 on Tue Aug  4 23:05:09 2009 */
+
+#define PY_SSIZE_T_CLEAN
+#include "Python.h"
+#include "structmember.h"
+#ifndef Py_PYTHON_H
+    #error Python headers needed to compile C extensions, please install development version of Python.
+#endif
+#ifndef PY_LONG_LONG
+  #define PY_LONG_LONG LONG_LONG
+#endif
+#ifndef DL_EXPORT
+  #define DL_EXPORT(t) t
+#endif
+#if PY_VERSION_HEX < 0x02040000
+  #define METH_COEXIST 0
+  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+  #define PY_SSIZE_T_MAX INT_MAX
+  #define PY_SSIZE_T_MIN INT_MIN
+  #define PY_FORMAT_SIZE_T ""
+  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
+  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
+  #define PyNumber_Index(o)    PyNumber_Int(o)
+  #define PyIndex_Check(o)     PyNumber_Check(o)
+#endif
+#if PY_VERSION_HEX < 0x02060000
+  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
+  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
+  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
+  #define PyVarObject_HEAD_INIT(type, size) \
+          PyObject_HEAD_INIT(type) size,
+  #define PyType_Modified(t)
+
+  typedef struct {
+       void *buf;
+       PyObject *obj;
+       Py_ssize_t len;
+       Py_ssize_t itemsize;
+       int readonly;
+       int ndim;
+       char *format;
+       Py_ssize_t *shape;
+       Py_ssize_t *strides;
+       Py_ssize_t *suboffsets;
+       void *internal;
+  } Py_buffer;
+
+  #define PyBUF_SIMPLE 0
+  #define PyBUF_WRITABLE 0x0001
+  #define PyBUF_FORMAT 0x0004
+  #define PyBUF_ND 0x0008
+  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
+  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
+  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
+  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
+  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)
+
+#endif
+#if PY_MAJOR_VERSION < 3
+  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
+#else
+  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define Py_TPFLAGS_CHECKTYPES 0
+  #define Py_TPFLAGS_HAVE_INDEX 0
+#endif
+#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
+  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyBaseString_Type            PyUnicode_Type
+  #define PyString_Type                PyBytes_Type
+  #define PyString_CheckExact          PyBytes_CheckExact
+  #define PyInt_Type                   PyLong_Type
+  #define PyInt_Check(op)              PyLong_Check(op)
+  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
+  #define PyInt_FromString             PyLong_FromString
+  #define PyInt_FromUnicode            PyLong_FromUnicode
+  #define PyInt_FromLong               PyLong_FromLong
+  #define PyInt_FromSize_t             PyLong_FromSize_t
+  #define PyInt_FromSsize_t            PyLong_FromSsize_t
+  #define PyInt_AsLong                 PyLong_AsLong
+  #define PyInt_AS_LONG                PyLong_AS_LONG
+  #define PyInt_AsSsize_t              PyLong_AsSsize_t
+  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
+  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
+#else
+  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
+  #define PyBytes_Type                 PyString_Type
+#endif
+#if PY_MAJOR_VERSION >= 3
+  #define PyMethod_New(func, self, klass) PyInstanceMethod_New(func)
+#endif
+#if !defined(WIN32) && !defined(MS_WINDOWS)
+  #ifndef __stdcall
+    #define __stdcall
+  #endif
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __fastcall
+    #define __fastcall
+  #endif
+#else
+  #define _USE_MATH_DEFINES
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
+#else
+  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
+  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
+  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
+#endif
+#if PY_VERSION_HEX < 0x02050000
+  #define __Pyx_NAMESTR(n) ((char *)(n))
+  #define __Pyx_DOCSTR(n)  ((char *)(n))
+#else
+  #define __Pyx_NAMESTR(n) (n)
+  #define __Pyx_DOCSTR(n)  (n)
+#endif
+#ifdef __cplusplus
+#define __PYX_EXTERN_C extern "C"
+#else
+#define __PYX_EXTERN_C extern
+#endif
+#include <math.h>
+#define __PYX_HAVE_API__tseries
+#include "numpy/arrayobject.h"
+#include "datetime.h"
+#include "string.h"
+#include "math.h"
+#include "stdlib.h"
+#define __PYX_USE_C99_COMPLEX defined(_Complex_I)
+
+
+#ifdef __GNUC__
+#define INLINE __inline__
+#elif _WIN32
+#define INLINE __inline
+#else
+#define INLINE 
+#endif
+
+typedef struct {PyObject **p; char *s; long n; char is_unicode; char intern; char is_identifier;} __Pyx_StringTabEntry; /*proto*/
+
+
+
+static int __pyx_skip_dispatch = 0;
+
+
+/* Type Conversion Predeclarations */
+
+#if PY_MAJOR_VERSION < 3
+#define __Pyx_PyBytes_FromString          PyString_FromString
+#define __Pyx_PyBytes_FromStringAndSize   PyString_FromStringAndSize
+#define __Pyx_PyBytes_AsString            PyString_AsString
+#else
+#define __Pyx_PyBytes_FromString          PyBytes_FromString
+#define __Pyx_PyBytes_FromStringAndSize   PyBytes_FromStringAndSize
+#define __Pyx_PyBytes_AsString            PyBytes_AsString
+#endif
+
+#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
+static INLINE int __Pyx_PyObject_IsTrue(PyObject*);
+static INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
+
+#if !defined(T_PYSSIZET)
+#if PY_VERSION_HEX < 0x02050000
+#define T_PYSSIZET T_INT
+#elif !defined(T_LONGLONG)
+#define T_PYSSIZET \
+        ((sizeof(Py_ssize_t) == sizeof(int))  ? T_INT  : \
+        ((sizeof(Py_ssize_t) == sizeof(long)) ? T_LONG : -1))
+#else
+#define T_PYSSIZET \
+        ((sizeof(Py_ssize_t) == sizeof(int))          ? T_INT      : \
+        ((sizeof(Py_ssize_t) == sizeof(long))         ? T_LONG     : \
+        ((sizeof(Py_ssize_t) == sizeof(PY_LONG_LONG)) ? T_LONGLONG : -1)))
+#endif
+#endif
+
+#if !defined(T_SIZET)
+#if !defined(T_ULONGLONG)
+#define T_SIZET \
+        ((sizeof(size_t) == sizeof(unsigned int))  ? T_UINT  : \
+        ((sizeof(size_t) == sizeof(unsigned long)) ? T_ULONG : -1))
+#else
+#define T_SIZET \
+        ((sizeof(size_t) == sizeof(unsigned int))          ? T_UINT      : \
+        ((sizeof(size_t) == sizeof(unsigned long))         ? T_ULONG     : \
+        ((sizeof(size_t) == sizeof(unsigned PY_LONG_LONG)) ? T_ULONGLONG : -1)))
+#endif
+#endif
+
+static INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
+static INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
+static INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);
+
+#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
+
+
+#ifdef __GNUC__
+/* Test for GCC > 2.95 */
+#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
+#define likely(x)   __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+#else /* __GNUC__ > 2 ... */
+#define likely(x)   (x)
+#define unlikely(x) (x)
+#endif /* __GNUC__ > 2 ... */
+#else /* __GNUC__ */
+#define likely(x)   (x)
+#define unlikely(x) (x)
+#endif /* __GNUC__ */
+    
+static PyObject *__pyx_m;
+static PyObject *__pyx_b;
+static PyObject *__pyx_empty_tuple;
+static int __pyx_lineno;
+static int __pyx_clineno = 0;
+static const char * __pyx_cfilenm= __FILE__;
+static const char *__pyx_filename;
+static const char **__pyx_f;
+
+
+#ifdef CYTHON_REFNANNY
+typedef struct {
+  void (*INCREF)(void*, PyObject*, int);
+  void (*DECREF)(void*, PyObject*, int);
+  void (*GOTREF)(void*, PyObject*, int);
+  void (*GIVEREF)(void*, PyObject*, int);
+  void* (*NewContext)(const char*, int, const char*);
+  void (*FinishContext)(void**);
+} __Pyx_RefnannyAPIStruct;
+static __Pyx_RefnannyAPIStruct *__Pyx_Refnanny = NULL;
+#define __Pyx_ImportRefcountAPI(name)   (__Pyx_RefnannyAPIStruct *) PyCObject_Import((char *)name, (char *)"RefnannyAPI")
+#define __Pyx_INCREF(r) __Pyx_Refnanny->INCREF(__pyx_refchk, (PyObject *)(r), __LINE__)
+#define __Pyx_DECREF(r) __Pyx_Refnanny->DECREF(__pyx_refchk, (PyObject *)(r), __LINE__)
+#define __Pyx_GOTREF(r) __Pyx_Refnanny->GOTREF(__pyx_refchk, (PyObject *)(r), __LINE__)
+#define __Pyx_GIVEREF(r) __Pyx_Refnanny->GIVEREF(__pyx_refchk, (PyObject *)(r), __LINE__)
+#define __Pyx_XDECREF(r) if((r) == NULL) ; else __Pyx_DECREF(r)
+#define __Pyx_SetupRefcountContext(name)   void* __pyx_refchk = __Pyx_Refnanny->NewContext((name), __LINE__, __FILE__)
+#define __Pyx_FinishRefcountContext()   __Pyx_Refnanny->FinishContext(&__pyx_refchk)
+#else
+#define __Pyx_INCREF(r) Py_INCREF(r)
+#define __Pyx_DECREF(r) Py_DECREF(r)
+#define __Pyx_GOTREF(r)
+#define __Pyx_GIVEREF(r)
+#define __Pyx_XDECREF(r) Py_XDECREF(r)
+#define __Pyx_SetupRefcountContext(name)
+#define __Pyx_FinishRefcountContext()
+#endif /* CYTHON_REFNANNY */
+#define __Pyx_XGIVEREF(r) if((r) == NULL) ; else __Pyx_GIVEREF(r)
+#define __Pyx_XGOTREF(r) if((r) == NULL) ; else __Pyx_GOTREF(r)
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name, PyObject* kw_name); /*proto*/
+
+static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
+    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/
+
+static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/
+
+/* Run-time type information about structs used with buffers */
+struct __Pyx_StructField_;
+
+typedef struct {
+  const char* name; /* for error messages only */
+  struct __Pyx_StructField_* fields;
+  size_t size;     /* sizeof(type) */
+  char typegroup; /* _R_eal, _C_omplex, Signed _I_nt, _U_nsigned int, _S_truct, _P_ointer, _O_bject */
+} __Pyx_TypeInfo;
+
+typedef struct __Pyx_StructField_ {
+  __Pyx_TypeInfo* type;
+  const char* name;
+  size_t offset;
+} __Pyx_StructField;
+
+typedef struct {
+  __Pyx_StructField* field;
+  size_t parent_offset;
+} __Pyx_BufFmt_StackElem;
+
+
+static INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info);
+static int __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack);
+#define __Pyx_BufPtrStrided1d(type, buf, i0, s0) (type)((char*)buf + i0 * s0)
+
+static INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+static INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+
+static INLINE void __Pyx_RaiseNoneNotIterableError(void);
+
+static INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);
+
+static INLINE void __Pyx_RaiseTooManyValuesError(void);
+
+static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index); /*proto*/
+
+static void __Pyx_RaiseBufferFallbackError(void); /*proto*/
+static void __Pyx_RaiseBufferIndexError(int axis); /*proto*/
+
+
+static INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
+    PyObject *r;
+    if (!j) return NULL;
+    r = PyObject_GetItem(o, j);
+    Py_DECREF(j);
+    return r;
+}
+
+
+#define __Pyx_GetItemInt_List(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_List_Fast(o, i, size <= sizeof(long)) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+            PyObject *r = PyList_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyList_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyList_GET_ITEM(o, PyList_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
+}
+
+#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Tuple_Fast(o, i, size <= sizeof(long)) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
+    if (likely(o != Py_None)) {
+        if (likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+            PyObject *r = PyTuple_GET_ITEM(o, i);
+            Py_INCREF(r);
+            return r;
+        }
+        else if ((-PyTuple_GET_SIZE(o) <= i) & (i < 0)) {
+            PyObject *r = PyTuple_GET_ITEM(o, PyTuple_GET_SIZE(o) + i);
+            Py_INCREF(r);
+            return r;
+        }
+    }
+    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
+}
+
+
+#define __Pyx_GetItemInt(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
+                                                    __Pyx_GetItemInt_Fast(o, i, size <= sizeof(long)) : \
+                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))
+
+static INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
+    PyObject *r;
+    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
+        r = PyList_GET_ITEM(o, i);
+        Py_INCREF(r);
+    }
+    else if (PyTuple_CheckExact(o) && ((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
+        r = PyTuple_GET_ITEM(o, i);
+        Py_INCREF(r);
+    }
+    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_item && (likely(i >= 0))) {
+        r = PySequence_GetItem(o, i);
+    }
+    else {
+        r = __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
+    }
+    return r;
+}
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact); /*proto*/
+
+static INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+#if PY_MAJOR_VERSION < 3
+static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags);
+static void __Pyx_ReleaseBuffer(Py_buffer *view);
+#else
+#define __Pyx_GetBuffer PyObject_GetBuffer
+#define __Pyx_ReleaseBuffer PyBuffer_Release
+#endif
+
+Py_ssize_t __Pyx_zeros[] = {0};
+Py_ssize_t __Pyx_minusones[] = {-1};
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/
+
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
+
+static PyObject *__Pyx_UnpackItem(PyObject *, Py_ssize_t index); /*proto*/
+static int __Pyx_EndUnpack(PyObject *); /*proto*/
+
+#if __PYX_USE_C99_COMPLEX
+    #define __Pyx_REAL_PART(z) __real__(z)
+    #define __Pyx_IMAG_PART(z) __imag__(z)
+#else
+    #define __Pyx_REAL_PART(z) ((z).real)
+    #define __Pyx_IMAG_PART(z) ((z).imag)
+#endif
+
+#define __pyx_PyObject_from_complex(z) PyComplex_FromDoubles((double)__Pyx_REAL_PART(z), (double)__Pyx_IMAG_PART(z))
+
+#if __PYX_USE_C99_COMPLEX
+
+    typedef float _Complex __pyx_t_float_complex;
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
+      return x + y*(__pyx_t_float_complex)_Complex_I;
+    }
+    
+    #define __pyx_t_float_complex_is_zero(a) ((a) == 0)
+    #define __pyx_t_float_complex_eq(a, b) ((a) == (b))
+    #define __pyx_t_float_complex_add(a, b) ((a)+(b))
+    #define __pyx_t_float_complex_sub(a, b) ((a)-(b))
+    #define __pyx_t_float_complex_mul(a, b) ((a)*(b))
+    #define __pyx_t_float_complex_div(a, b) ((a)/(b))
+    #define __pyx_t_float_complex_neg(a) (-(a))
+
+#else
+
+    typedef struct { float real, imag; } __pyx_t_float_complex;
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_from_parts(float x, float y) {
+      __pyx_t_float_complex c; c.real = x; c.imag = y; return c;
+    }
+    
+    static INLINE int __pyx_t_float_complex_is_zero(__pyx_t_float_complex a) {
+       return (a.real == 0) & (a.imag == 0);
+    }
+
+    static INLINE int __pyx_t_float_complex_eq(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+       return (a.real == b.real) & (a.imag == b.imag);
+    }
+
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_add(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real + b.real;
+        z.imag = a.imag + b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_sub(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real - b.real;
+        z.imag = a.imag - b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_mul(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        z.real = a.real * b.real - a.imag * b.imag;
+        z.imag = a.real * b.imag + a.imag * b.real;
+        return z;
+    }
+
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_div(__pyx_t_float_complex a, __pyx_t_float_complex b) {
+        __pyx_t_float_complex z;
+        float denom = b.real*b.real + b.imag*b.imag;
+        z.real = (a.real * b.real + a.imag * b.imag) / denom;
+        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
+        return z;
+    }
+
+    static INLINE __pyx_t_float_complex __pyx_t_float_complex_neg(__pyx_t_float_complex a) {
+        __pyx_t_float_complex z;
+        z.real = -a.real;
+        z.imag = -a.imag;
+        return z;
+    }
+
+#endif
+
+#if __PYX_USE_C99_COMPLEX
+
+    typedef double _Complex __pyx_t_double_complex;
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
+      return x + y*(__pyx_t_double_complex)_Complex_I;
+    }
+    
+    #define __pyx_t_double_complex_is_zero(a) ((a) == 0)
+    #define __pyx_t_double_complex_eq(a, b) ((a) == (b))
+    #define __pyx_t_double_complex_add(a, b) ((a)+(b))
+    #define __pyx_t_double_complex_sub(a, b) ((a)-(b))
+    #define __pyx_t_double_complex_mul(a, b) ((a)*(b))
+    #define __pyx_t_double_complex_div(a, b) ((a)/(b))
+    #define __pyx_t_double_complex_neg(a) (-(a))
+
+#else
+
+    typedef struct { double real, imag; } __pyx_t_double_complex;
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_from_parts(double x, double y) {
+      __pyx_t_double_complex c; c.real = x; c.imag = y; return c;
+    }
+    
+    static INLINE int __pyx_t_double_complex_is_zero(__pyx_t_double_complex a) {
+       return (a.real == 0) & (a.imag == 0);
+    }
+
+    static INLINE int __pyx_t_double_complex_eq(__pyx_t_double_complex a, __pyx_t_double_complex b) {
+       return (a.real == b.real) & (a.imag == b.imag);
+    }
+
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_add(__pyx_t_double_complex a, __pyx_t_double_complex b) {
+        __pyx_t_double_complex z;
+        z.real = a.real + b.real;
+        z.imag = a.imag + b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_sub(__pyx_t_double_complex a, __pyx_t_double_complex b) {
+        __pyx_t_double_complex z;
+        z.real = a.real - b.real;
+        z.imag = a.imag - b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_mul(__pyx_t_double_complex a, __pyx_t_double_complex b) {
+        __pyx_t_double_complex z;
+        z.real = a.real * b.real - a.imag * b.imag;
+        z.imag = a.real * b.imag + a.imag * b.real;
+        return z;
+    }
+
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_div(__pyx_t_double_complex a, __pyx_t_double_complex b) {
+        __pyx_t_double_complex z;
+        double denom = b.real*b.real + b.imag*b.imag;
+        z.real = (a.real * b.real + a.imag * b.imag) / denom;
+        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
+        return z;
+    }
+
+    static INLINE __pyx_t_double_complex __pyx_t_double_complex_neg(__pyx_t_double_complex a) {
+        __pyx_t_double_complex z;
+        z.real = -a.real;
+        z.imag = -a.imag;
+        return z;
+    }
+
+#endif
+
+#if __PYX_USE_C99_COMPLEX
+
+    typedef long double _Complex __pyx_t_long__double_complex;
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_from_parts(long double x, long double y) {
+      return x + y*(__pyx_t_long__double_complex)_Complex_I;
+    }
+    
+    #define __pyx_t_long__double_complex_is_zero(a) ((a) == 0)
+    #define __pyx_t_long__double_complex_eq(a, b) ((a) == (b))
+    #define __pyx_t_long__double_complex_add(a, b) ((a)+(b))
+    #define __pyx_t_long__double_complex_sub(a, b) ((a)-(b))
+    #define __pyx_t_long__double_complex_mul(a, b) ((a)*(b))
+    #define __pyx_t_long__double_complex_div(a, b) ((a)/(b))
+    #define __pyx_t_long__double_complex_neg(a) (-(a))
+
+#else
+
+    typedef struct { long double real, imag; } __pyx_t_long__double_complex;
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_from_parts(long double x, long double y) {
+      __pyx_t_long__double_complex c; c.real = x; c.imag = y; return c;
+    }
+    
+    static INLINE int __pyx_t_long__double_complex_is_zero(__pyx_t_long__double_complex a) {
+       return (a.real == 0) & (a.imag == 0);
+    }
+
+    static INLINE int __pyx_t_long__double_complex_eq(__pyx_t_long__double_complex a, __pyx_t_long__double_complex b) {
+       return (a.real == b.real) & (a.imag == b.imag);
+    }
+
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_add(__pyx_t_long__double_complex a, __pyx_t_long__double_complex b) {
+        __pyx_t_long__double_complex z;
+        z.real = a.real + b.real;
+        z.imag = a.imag + b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_sub(__pyx_t_long__double_complex a, __pyx_t_long__double_complex b) {
+        __pyx_t_long__double_complex z;
+        z.real = a.real - b.real;
+        z.imag = a.imag - b.imag;
+        return z;
+    }
+
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_mul(__pyx_t_long__double_complex a, __pyx_t_long__double_complex b) {
+        __pyx_t_long__double_complex z;
+        z.real = a.real * b.real - a.imag * b.imag;
+        z.imag = a.real * b.imag + a.imag * b.real;
+        return z;
+    }
+
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_div(__pyx_t_long__double_complex a, __pyx_t_long__double_complex b) {
+        __pyx_t_long__double_complex z;
+        long double denom = b.real*b.real + b.imag*b.imag;
+        z.real = (a.real * b.real + a.imag * b.imag) / denom;
+        z.imag = (a.imag * b.real - a.real * b.imag) / denom;
+        return z;
+    }
+
+    static INLINE __pyx_t_long__double_complex __pyx_t_long__double_complex_neg(__pyx_t_long__double_complex a) {
+        __pyx_t_long__double_complex z;
+        z.real = -a.real;
+        z.imag = -a.imag;
+        return z;
+    }
+
+#endif
+
+static INLINE int __Pyx_StrEq(const char *, const char *); /*proto*/
+
+static INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);
+
+static INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);
+
+static INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);
+
+static INLINE char __Pyx_PyInt_AsChar(PyObject *);
+
+static INLINE short __Pyx_PyInt_AsShort(PyObject *);
+
+static INLINE int __Pyx_PyInt_AsInt(PyObject *);
+
+static INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);
+
+static INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);
+
+static INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);
+
+static INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);
+
+static INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);
+
+static INLINE long __Pyx_PyInt_AsLong(PyObject *);
+
+static INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);
+
+static INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);
+
+static INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);
+
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, long size);  /*proto*/
+
+static PyObject *__Pyx_ImportModule(const char *name); /*proto*/
+
+static void __Pyx_AddTraceback(const char *funcname); /*proto*/
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
+
+/* Type declarations */
+
+typedef npy_int8 __pyx_t_5numpy_int8_t;
+
+typedef npy_int16 __pyx_t_5numpy_int16_t;
+
+typedef npy_int32 __pyx_t_5numpy_int32_t;
+
+typedef npy_int64 __pyx_t_5numpy_int64_t;
+
+typedef npy_uint8 __pyx_t_5numpy_uint8_t;
+
+typedef npy_uint16 __pyx_t_5numpy_uint16_t;
+
+typedef npy_uint32 __pyx_t_5numpy_uint32_t;
+
+typedef npy_uint64 __pyx_t_5numpy_uint64_t;
+
+typedef npy_float32 __pyx_t_5numpy_float32_t;
+
+typedef npy_float64 __pyx_t_5numpy_float64_t;
+
+typedef npy_complex64 __pyx_t_5numpy_complex64_t;
+
+typedef npy_complex128 __pyx_t_5numpy_complex128_t;
+
+typedef npy_long __pyx_t_5numpy_int_t;
+
+typedef npy_longlong __pyx_t_5numpy_long_t;
+
+typedef npy_ulong __pyx_t_5numpy_uint_t;
+
+typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
+
+typedef npy_double __pyx_t_5numpy_float_t;
+
+typedef npy_double __pyx_t_5numpy_double_t;
+
+typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
+
+typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
+
+typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
+
+typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
+
+typedef npy_cdouble __pyx_t_5numpy_complex_t;
+
+typedef double (*__pyx_t_7tseries_double_func)(double, double);
+/* Module declarations from numpy */
+
+/* Module declarations from datetime */
+
+/* Module declarations from python_buffer */
+
+/* Module declarations from stdlib */
+
+/* Module declarations from numpy */
+
+/* Module declarations from numpy */
+
+static PyTypeObject *__pyx_ptype_5numpy_dtype = 0;
+static PyTypeObject *__pyx_ptype_5numpy_ndarray = 0;
+static INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *, char *, char *, int *); /*proto*/
+/* Module declarations from python_dict */
+
+/* Module declarations from cython */
+
+/* Module declarations from tseries */
+
+static PyTypeObject *__pyx_ptype_7tseries_dtype = 0;
+static PyTypeObject *__pyx_ptype_7tseries_ndarray = 0;
+static PyTypeObject *__pyx_ptype_7tseries_flatiter = 0;
+static PyTypeObject *__pyx_ptype_7tseries_broadcast = 0;
+static PyTypeObject *__pyx_ptype_7tseries_datetime = 0;
+static double __pyx_v_7tseries_NaN;
+static double __pyx_v_7tseries_INF;
+static double __pyx_v_7tseries_NEGINF;
+static INLINE PyObject *__pyx_f_7tseries_trycall(PyObject *, PyObject *); /*proto*/
+static INLINE int __pyx_f_7tseries_int_max(int, int); /*proto*/
+static INLINE int __pyx_f_7tseries_int_min(int, int); /*proto*/
+static PyObject *__pyx_f_7tseries__nofill(PyArrayObject *, PyArrayObject *, PyObject *, PyObject *); /*proto*/
+static PyObject *__pyx_f_7tseries__backfill(PyArrayObject *, PyArrayObject *, PyObject *, PyObject *); /*proto*/
+static PyObject *__pyx_f_7tseries__pad(PyArrayObject *, PyArrayObject *, PyObject *, PyObject *); /*proto*/
+static INLINE PyObject *__pyx_f_7tseries__checknull(PyObject *); /*proto*/
+static PyArrayObject *__pyx_f_7tseries__isnullobj(PyObject *); /*proto*/
+static double __pyx_f_7tseries___add(double, double); /*proto*/
+static double __pyx_f_7tseries___sub(double, double); /*proto*/
+static double __pyx_f_7tseries___div(double, double); /*proto*/
+static double __pyx_f_7tseries___mul(double, double); /*proto*/
+static double __pyx_f_7tseries___eq(double, double); /*proto*/
+static double __pyx_f_7tseries___ne(double, double); /*proto*/
+static double __pyx_f_7tseries___lt(double, double); /*proto*/
+static double __pyx_f_7tseries___gt(double, double); /*proto*/
+static double __pyx_f_7tseries___pow(double, double); /*proto*/
+static PyArrayObject *__pyx_f_7tseries__applyFunc(__pyx_t_7tseries_double_func, PyArrayObject *, PyObject *, PyObject *, PyObject *, PyObject *); /*proto*/
+static __Pyx_TypeInfo __Pyx_TypeInfo_object = { "Python object", NULL, sizeof(PyObject *), 'O' };
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn_npy_int8 = { "numpy.npy_int8", NULL, sizeof(npy_int8), 'I' };
+static __Pyx_TypeInfo __Pyx_TypeInfo_nn_npy_float64 = { "numpy.npy_float64", NULL, sizeof(npy_float64), 'R' };
+#define __Pyx_MODULE_NAME "tseries"
+int __pyx_module_is_main_tseries = 0;
+
+/* Implementation of tseries */
+static PyObject *__pyx_int_1;
+static char __pyx_k___main__[] = "__main__";
+static PyObject *__pyx_kp___main__;
+static char __pyx_k_index[] = "index";
+static PyObject *__pyx_kp_index;
+static char __pyx_k_A[] = "A";
+static PyObject *__pyx_kp_A;
+static char __pyx_k_B[] = "B";
+static PyObject *__pyx_kp_B;
+static char __pyx_k_arr[] = "arr";
+static PyObject *__pyx_kp_arr;
+static char __pyx_k_idxMap[] = "idxMap";
+static PyObject *__pyx_kp_idxMap;
+static char __pyx_k_oldIndex[] = "oldIndex";
+static PyObject *__pyx_kp_oldIndex;
+static char __pyx_k_newIndex[] = "newIndex";
+static PyObject *__pyx_kp_newIndex;
+static char __pyx_k_oldMap[] = "oldMap";
+static PyObject *__pyx_kp_oldMap;
+static char __pyx_k_newMap[] = "newMap";
+static PyObject *__pyx_kp_newMap;
+static char __pyx_k_kind[] = "kind";
+static PyObject *__pyx_kp_kind;
+static char __pyx_k_values[] = "values";
+static PyObject *__pyx_kp_values;
+static char __pyx_k_indexMap[] = "indexMap";
+static PyObject *__pyx_kp_indexMap;
+static char __pyx_k_input[] = "input";
+static PyObject *__pyx_kp_input;
+static char __pyx_k_name[] = "name";
+static PyObject *__pyx_kp_name;
+static char __pyx_k_ao[] = "ao";
+static PyObject *__pyx_kp_ao;
+static char __pyx_k_bo[] = "bo";
+static PyObject *__pyx_kp_bo;
+static char __pyx_k_aMap[] = "aMap";
+static PyObject *__pyx_kp_aMap;
+static char __pyx_k_bMap[] = "bMap";
+static PyObject *__pyx_kp_bMap;
+static char __pyx_k_func[] = "func";
+static PyObject *__pyx_kp_func;
+static char __pyx_k_keyfunc[] = "keyfunc";
+static PyObject *__pyx_kp_keyfunc;
+static char __pyx_k_applyfunc[] = "applyfunc";
+static PyObject *__pyx_kp_applyfunc;
+static char __pyx_k_numpy[] = "numpy";
+static PyObject *__pyx_kp_numpy;
+static char __pyx_k_np[] = "np";
+static PyObject *__pyx_kp_np;
+static char __pyx_k_isnan[] = "isnan";
+static PyObject *__pyx_kp_isnan;
+static char __pyx_k_NaN[] = "NaN";
+static PyObject *__pyx_kp_NaN;
+static char __pyx_k_datetime[] = "datetime";
+static PyObject *__pyx_kp_datetime;
+static char __pyx_k_pydatetime[] = "pydatetime";
+static PyObject *__pyx_kp_pydatetime;
+static char __pyx_k_inf[] = "inf";
+static PyObject *__pyx_kp_inf;
+static char __pyx_k_Exception[] = "Exception";
+static PyObject *__pyx_kp_Exception;
+static char __pyx_k_map_indices[] = "map_indices";
+static PyObject *__pyx_kp_map_indices;
+static char __pyx_k_empty[] = "empty";
+static PyObject *__pyx_kp_empty;
+static char __pyx_k_32[] = "float64";
+static PyObject *__pyx_kp_32;
+static char __pyx_k_astype[] = "astype";
+static PyObject *__pyx_kp_astype;
+static char __pyx_k_dtype[] = "dtype";
+static PyObject *__pyx_kp_dtype;
+static char __pyx_k_object_[] = "object_";
+static PyObject *__pyx_kp_object_;
+static char __pyx_k_object[] = "object";
+static PyObject *__pyx_kp_object;
+static char __pyx_k_33[] = "int32";
+static PyObject *__pyx_kp_33;
+static char __pyx_k_zeros[] = "zeros";
+static PyObject *__pyx_kp_zeros;
+static char __pyx_k_34[] = "int8";
+static PyObject *__pyx_kp_34;
+static char __pyx_k_36[] = "PAD";
+static PyObject *__pyx_kp_36;
+static char __pyx_k_37[] = "BACKFILL";
+static PyObject *__pyx_kp_37;
+static char __pyx_k_bool[] = "bool";
+static PyObject *__pyx_kp_bool;
+static char __pyx_k_38[] = "O";
+static PyObject *__pyx_kp_38;
+static char __pyx_k_39[] = "S";
+static PyObject *__pyx_kp_39;
+static char __pyx_k_isfinite[] = "isfinite";
+static PyObject *__pyx_kp_isfinite;
+static char __pyx_k_isnull[] = "isnull";
+static PyObject *__pyx_kp_isnull;
+static char __pyx_k_40[] = "__add__";
+static PyObject *__pyx_kp_40;
+static char __pyx_k_41[] = "__sub__";
+static PyObject *__pyx_kp_41;
+static char __pyx_k_42[] = "__div__";
+static PyObject *__pyx_kp_42;
+static char __pyx_k_43[] = "__mul__";
+static PyObject *__pyx_kp_43;
+static char __pyx_k_44[] = "__eq__";
+static PyObject *__pyx_kp_44;
+static char __pyx_k_45[] = "__ne__";
+static PyObject *__pyx_kp_45;
+static char __pyx_k_46[] = "__lt__";
+static PyObject *__pyx_kp_46;
+static char __pyx_k_47[] = "__gt__";
+static PyObject *__pyx_kp_47;
+static char __pyx_k_48[] = "__pow__";
+static PyObject *__pyx_kp_48;
+static char __pyx_k_arrmap[] = "arrmap";
+static PyObject *__pyx_kp_arrmap;
+static char __pyx_k_asarray[] = "asarray";
+static PyObject *__pyx_kp_asarray;
+static char __pyx_k_any[] = "any";
+static PyObject *__pyx_kp_any;
+static PyObject *__pyx_builtin_Exception;
+static PyObject *__pyx_builtin_object;
+static PyObject *__pyx_kp_31;
+static char __pyx_k_31[] = "Error calling func on index %s";
+static PyObject *__pyx_kp_35;
+static char __pyx_k_35[] = "";
+static PyObject *__pyx_kp_49;
+static char __pyx_k_49[] = "bad funcname requested of Cython code";
+static PyObject *__pyx_kp_50;
+static char __pyx_k_50[] = "Dates and values were not the same length!";
+static PyObject *__pyx_kp_51;
+static char __pyx_k_51[] = "Dates and values were not the same length!";
+static PyObject *__pyx_kp_52;
+static char __pyx_k_52[] = "Dates and values were not the same length!";
+static PyObject *__pyx_kp_53;
+static char __pyx_k_53[] = "Dates and values were not the same length!";
+static PyObject *__pyx_int_15;
+static char __pyx_k___getbuffer__[] = "__getbuffer__";
+static PyObject *__pyx_kp___getbuffer__;
+static char __pyx_k___releasebuffer__[] = "__releasebuffer__";
+static PyObject *__pyx_kp___releasebuffer__;
+static char __pyx_k_info[] = "info";
+static PyObject *__pyx_kp_info;
+static char __pyx_k_flags[] = "flags";
+static PyObject *__pyx_kp_flags;
+static char __pyx_k_ValueError[] = "ValueError";
+static PyObject *__pyx_kp_ValueError;
+static char __pyx_k_range[] = "range";
+static PyObject *__pyx_kp_range;
+static char __pyx_k_itervalues[] = "itervalues";
+static PyObject *__pyx_kp_itervalues;
+static char __pyx_k_RuntimeError[] = "RuntimeError";
+static PyObject *__pyx_kp_RuntimeError;
+static PyObject *__pyx_kp_1;
+static PyObject *__pyx_kp_2;
+static PyObject *__pyx_kp_5;
+static PyObject *__pyx_kp_23;
+static PyObject *__pyx_builtin_ValueError;
+static PyObject *__pyx_builtin_range;
+static PyObject *__pyx_builtin_RuntimeError;
+static char __pyx_k_1[] = "ndarray is not C contiguous";
+static char __pyx_k_2[] = "ndarray is not Fortran contiguous";
+static char __pyx_k_3[] = ">";
+static char __pyx_k_4[] = "<";
+static char __pyx_k_5[] = "Non-native byte order not supported";
+static char __pyx_k_6[] = "b";
+static char __pyx_k_7[] = "B";
+static char __pyx_k_8[] = "h";
+static char __pyx_k_9[] = "H";
+static char __pyx_k_10[] = "i";
+static char __pyx_k_11[] = "I";
+static char __pyx_k_12[] = "l";
+static char __pyx_k_13[] = "L";
+static char __pyx_k_14[] = "q";
+static char __pyx_k_15[] = "Q";
+static char __pyx_k_16[] = "f";
+static char __pyx_k_17[] = "d";
+static char __pyx_k_18[] = "g";
+static char __pyx_k_19[] = "Zf";
+static char __pyx_k_20[] = "Zd";
+static char __pyx_k_21[] = "Zg";
+static char __pyx_k_22[] = "O";
+static char __pyx_k_23[] = "unknown dtype code in numpy.pxd (%d)";
+static char __pyx_k_24[] = "^";
+static PyObject *__pyx_kp_25;
+static PyObject *__pyx_kp_28;
+static PyObject *__pyx_kp_29;
+static PyObject *__pyx_kp_30;
+static char __pyx_k_25[] = "Format string allocated too short, see comment in numpy.pxd";
+static char __pyx_k_26[] = ">";
+static char __pyx_k_27[] = "<";
+static char __pyx_k_28[] = "Non-native byte order not supported";
+static char __pyx_k_29[] = "Format string allocated too short.";
+static char __pyx_k_30[] = "unknown dtype code in numpy.pxd (%d)";
+
+/* "pandas/lib/src/tseries.pyx":21
+ * cimport cython
+ * 
+ * cdef inline object trycall(object func, object arg):             # <<<<<<<<<<<<<<
+ *     cdef object result
+ *     try:
+ */
+
+static INLINE PyObject *__pyx_f_7tseries_trycall(PyObject *__pyx_v_func, PyObject *__pyx_v_arg) {
+  PyObject *__pyx_v_result;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  __Pyx_SetupRefcountContext("trycall");
+  __pyx_v_result = Py_None; __Pyx_INCREF(Py_None);
+
+  /* "pandas/lib/src/tseries.pyx":23
+ * cdef inline object trycall(object func, object arg):
+ *     cdef object result
+ *     try:             # <<<<<<<<<<<<<<
+ *         result = func(arg)
+ *     except:
+ */
+  {
+    PyObject *__pyx_save_exc_type, *__pyx_save_exc_value, *__pyx_save_exc_tb;
+    __Pyx_ExceptionSave(&__pyx_save_exc_type, &__pyx_save_exc_value, &__pyx_save_exc_tb);
+    __Pyx_XGOTREF(__pyx_save_exc_type);
+    __Pyx_XGOTREF(__pyx_save_exc_value);
+    __Pyx_XGOTREF(__pyx_save_exc_tb);
+    /*try:*/ {
+
+      /* "pandas/lib/src/tseries.pyx":24
+ *     cdef object result
+ *     try:
+ *         result = func(arg)             # <<<<<<<<<<<<<<
+ *     except:
+ *         raise Exception('Error calling func on index %s' % arg)
+ */
+      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+      __Pyx_INCREF(__pyx_v_arg);
+      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_arg);
+      __Pyx_GIVEREF(__pyx_v_arg);
+      __pyx_t_2 = PyObject_Call(__pyx_v_func, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_v_result);
+      __pyx_v_result = __pyx_t_2;
+      __pyx_t_2 = 0;
+    }
+    __Pyx_XDECREF(__pyx_save_exc_type); __pyx_save_exc_type = 0;
+    __Pyx_XDECREF(__pyx_save_exc_value); __pyx_save_exc_value = 0;
+    __Pyx_XDECREF(__pyx_save_exc_tb); __pyx_save_exc_tb = 0;
+    goto __pyx_L10_try_end;
+    __pyx_L3_error:;
+    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":25
+ *     try:
+ *         result = func(arg)
+ *     except:             # <<<<<<<<<<<<<<
+ *         raise Exception('Error calling func on index %s' % arg)
+ *     return result
+ */
+    /*except:*/ {
+      __Pyx_AddTraceback("tseries.trycall");
+      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 25; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_GOTREF(__pyx_t_3);
+
+      /* "pandas/lib/src/tseries.pyx":26
+ *         result = func(arg)
+ *     except:
+ *         raise Exception('Error calling func on index %s' % arg)             # <<<<<<<<<<<<<<
+ *     return result
+ * 
+ */
+      __pyx_t_4 = PyNumber_Remainder(__pyx_kp_31, __pyx_v_arg); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
+      __Pyx_GIVEREF(__pyx_t_4);
+      __pyx_t_4 = 0;
+      __pyx_t_4 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L5_except_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      goto __pyx_L4_exception_handled;
+    }
+    __pyx_L5_except_error:;
+    __Pyx_XDECREF(__pyx_save_exc_type);
+    __Pyx_XDECREF(__pyx_save_exc_value);
+    __Pyx_XDECREF(__pyx_save_exc_tb);
+    goto __pyx_L1_error;
+    __pyx_L4_exception_handled:;
+    __Pyx_XGIVEREF(__pyx_save_exc_type);
+    __Pyx_XGIVEREF(__pyx_save_exc_value);
+    __Pyx_XGIVEREF(__pyx_save_exc_tb);
+    __Pyx_ExceptionReset(__pyx_save_exc_type, __pyx_save_exc_value, __pyx_save_exc_tb);
+    __pyx_L10_try_end:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":27
+ *     except:
+ *         raise Exception('Error calling func on index %s' % arg)
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline int int_max(int a, int b): return a if a >= b else b
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(__pyx_v_result);
+  __pyx_r = __pyx_v_result;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("tseries.trycall");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_DECREF(__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":29
+ *     return result
+ * 
+ * cdef inline int int_max(int a, int b): return a if a >= b else b             # <<<<<<<<<<<<<<
+ * cdef inline int int_min(int a, int b): return a if a >= b else b
+ * 
+ */
+
+static INLINE int __pyx_f_7tseries_int_max(int __pyx_v_a, int __pyx_v_b) {
+  int __pyx_r;
+  int __pyx_1;
+  __Pyx_SetupRefcountContext("int_max");
+  if ((__pyx_v_a >= __pyx_v_b)) {
+    __pyx_1 = __pyx_v_a;
+  } else {
+    __pyx_1 = __pyx_v_b;
+  }
+  __pyx_r = __pyx_1;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":30
+ * 
+ * cdef inline int int_max(int a, int b): return a if a >= b else b
+ * cdef inline int int_min(int a, int b): return a if a >= b else b             # <<<<<<<<<<<<<<
+ * 
+ * def map_indices(ndarray index):
+ */
+
+static INLINE int __pyx_f_7tseries_int_min(int __pyx_v_a, int __pyx_v_b) {
+  int __pyx_r;
+  int __pyx_1;
+  __Pyx_SetupRefcountContext("int_min");
+  if ((__pyx_v_a >= __pyx_v_b)) {
+    __pyx_1 = __pyx_v_a;
+  } else {
+    __pyx_1 = __pyx_v_b;
+  }
+  __pyx_r = __pyx_1;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":32
+ * cdef inline int int_min(int a, int b): return a if a >= b else b
+ * 
+ * def map_indices(ndarray index):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Produce a dict mapping the values of the input array to their respective
+ */
+
+static PyObject *__pyx_pf_7tseries_map_indices(PyObject *__pyx_self, PyObject *__pyx_v_index); /*proto*/
+static char __pyx_doc_7tseries_map_indices[] = "\n    Produce a dict mapping the values of the input array to their respective\n    locations.\n    \n    Example:\n        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}\n        \n    Better to do this with Cython because of the enormous speed boost.\n    ";
+static PyObject *__pyx_pf_7tseries_map_indices(PyObject *__pyx_self, PyObject *__pyx_v_index) {
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_iter;
+  PyObject *__pyx_v_result;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  __Pyx_SetupRefcountContext("map_indices");
+  __pyx_self = __pyx_self;
+  __pyx_v_iter = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_result = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":47
+ *     cdef object idx
+ * 
+ *     result = {}             # <<<<<<<<<<<<<<
+ * 
+ *     iter = PyArray_IterNew(index)
+ */
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 47; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":49
+ *     result = {}
+ * 
+ *     iter = PyArray_IterNew(index)             # <<<<<<<<<<<<<<
+ * 
+ *     length = PyArray_SIZE(index)
+ */
+  __pyx_t_1 = PyArray_IterNew(__pyx_v_index); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iter));
+  __pyx_v_iter = ((PyArrayIterObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":51
+ *     iter = PyArray_IterNew(index)
+ * 
+ *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  if (!(__Pyx_TypeTest(__pyx_v_index, __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
+
+  /* "pandas/lib/src/tseries.pyx":53
+ *     length = PyArray_SIZE(index)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(index, <void *> iter.dataptr)
+ *         result[idx] = i
+ */
+  __pyx_t_2 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_2; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":54
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iter.dataptr)             # <<<<<<<<<<<<<<
+ *         result[idx] = i
+ *         PyArray_ITER_NEXT(iter)
+ */
+    __pyx_t_1 = PyArray_GETITEM(__pyx_v_index, ((void *)__pyx_v_iter->dataptr)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_1;
+    __pyx_t_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":55
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iter.dataptr)
+ *         result[idx] = i             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iter)
+ * 
+ */
+    __pyx_t_1 = PyInt_FromLong(__pyx_v_i); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (PyDict_SetItem(((PyObject *)__pyx_v_result), __pyx_v_idx, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 55; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":56
+ *         idx = PyArray_GETITEM(index, <void *> iter.dataptr)
+ *         result[idx] = i
+ *         PyArray_ITER_NEXT(iter)             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    PyArray_ITER_NEXT(__pyx_v_iter);
+  }
+
+  /* "pandas/lib/src/tseries.pyx":58
+ *         PyArray_ITER_NEXT(iter)
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * def match(ndarray A, ndarray B):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("tseries.map_indices");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_iter);
+  __Pyx_DECREF(__pyx_v_result);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":60
+ *     return result
+ * 
+ * def match(ndarray A, ndarray B):             # <<<<<<<<<<<<<<
+ *     '''
+ *     --> match(a, b)
+ */
+
+static PyObject *__pyx_pf_7tseries_match(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_match[] = "\n    --> match(a, b)\n    \n    Close equivalent of R's match function.\n    \n    For given input index A, find matching locations for values of A in B.\n    \n    Example:\n    >>> b\n    array([[ 0.        ,  0.26929312],\n           [ 1.        ,  0.49540359],\n           [ 2.        ,  0.66389941],\n           [ 3.        ,  0.66235806],\n           [ 4.        ,  0.97993956],\n           [ 5.        ,  0.83804732],\n           [ 6.        ,  0.75033074],\n           [ 7.        ,  0.10250388],\n           [ 8.        ,  0.66591799],\n           [ 9.        ,  0.18337242]])\n    >>> a\n        array([1, 3, 6, 8, 4, 5, 7, 0, 2, 9])\n    \n    # Now with match we can realign b based on a\n    \n    >>> b[match(a, b[:,0]),:]\n    array([[ 1.        ,  0.49540359],\n           [ 3.        ,  0.66235806],\n           [ 6.        ,  0.75033074],\n           [ 8.        ,  0.66591799],\n           [ 4.        ,  0.97993956],\n           [ 5.        ,  0.83804732],\n           [ 7.        ,  0.10250388],\n           [ 0.        ,  0.26929312],\n           [ 2.        ,  0.66389941],\n           [ 9.        ,  0.18337242]])\n   \n    ";
+static PyObject *__pyx_pf_7tseries_match(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_A = 0;
+  PyArrayObject *__pyx_v_B = 0;
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itera;
+  PyObject *__pyx_v_bmap;
+  double *__pyx_v_result_data;
+  double __pyx_v_nan;
+  PyObject *__pyx_v_idx;
+  PyArrayObject *__pyx_v_result;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_A,&__pyx_kp_B,0};
+  __Pyx_SetupRefcountContext("match");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_A);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_B);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("match", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "match") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_A = ((PyArrayObject *)values[0]);
+    __pyx_v_B = ((PyArrayObject *)values[1]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_A = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_B = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("match", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.match");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_itera = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_bmap = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_A), __pyx_ptype_5numpy_ndarray, 1, "A", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_B), __pyx_ptype_5numpy_ndarray, 1, "B", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":107
+ *     cdef ndarray result
+ * 
+ *     nan = <double> np.NaN             # <<<<<<<<<<<<<<
+ * 
+ *     bmap = map_indices(B)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_nan = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":109
+ *     nan = <double> np.NaN
+ * 
+ *     bmap = map_indices(B)             # <<<<<<<<<<<<<<
+ * 
+ *     itera = PyArray_IterNew(A)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_map_indices); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __Pyx_INCREF(((PyObject *)__pyx_v_B));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_B));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_B));
+  __pyx_t_3 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  if (!(likely(PyDict_CheckExact(__pyx_t_3)) || (__pyx_t_3) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected dict, got %s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 109; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_bmap));
+  __pyx_v_bmap = ((PyObject *)__pyx_t_3);
+  __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":111
+ *     bmap = map_indices(B)
+ * 
+ *     itera = PyArray_IterNew(A)             # <<<<<<<<<<<<<<
+ *     length = PyArray_SIZE(A)
+ * 
+ */
+  __pyx_t_3 = PyArray_IterNew(((PyObject *)__pyx_v_A)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  if (!(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 111; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_itera));
+  __pyx_v_itera = ((PyArrayIterObject *)__pyx_t_3);
+  __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":112
+ * 
+ *     itera = PyArray_IterNew(A)
+ *     length = PyArray_SIZE(A)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_A), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_A));
+
+  /* "pandas/lib/src/tseries.pyx":114
+ *     length = PyArray_SIZE(A)
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)             # <<<<<<<<<<<<<<
+ * 
+ *     result_data = <double *> result.data
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_1 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_1, __pyx_kp_32); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
+  __Pyx_GIVEREF(__pyx_t_1);
+  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_1 = 0;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 114; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":116
+ *     result = <ndarray> np.empty(length, np.float64)
+ * 
+ *     result_data = <double *> result.data             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_v_result_data = ((double *)__pyx_v_result->data);
+
+  /* "pandas/lib/src/tseries.pyx":118
+ *     result_data = <double *> result.data
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(A, <void *> itera.dataptr)
+ *         if idx in bmap:
+ */
+  __pyx_t_6 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":119
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(A, <void *> itera.dataptr)             # <<<<<<<<<<<<<<
+ *         if idx in bmap:
+ *             result_data[i] = <double> bmap[idx]
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_A), ((void *)__pyx_v_itera->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 119; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":120
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(A, <void *> itera.dataptr)
+ *         if idx in bmap:             # <<<<<<<<<<<<<<
+ *             result_data[i] = <double> bmap[idx]
+ *         else:
+ */
+    __pyx_t_7 = (PySequence_Contains(((PyObject *)__pyx_v_bmap), __pyx_v_idx)); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_7) {
+
+      /* "pandas/lib/src/tseries.pyx":121
+ *         idx = PyArray_GETITEM(A, <void *> itera.dataptr)
+ *         if idx in bmap:
+ *             result_data[i] = <double> bmap[idx]             # <<<<<<<<<<<<<<
+ *         else:
+ *             result_data[i] = nan
+ */
+      __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_bmap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_1);
+      __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+      (__pyx_v_result_data[__pyx_v_i]) = ((double)__pyx_t_2);
+      goto __pyx_L8;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":123
+ *             result_data[i] = <double> bmap[idx]
+ *         else:
+ *             result_data[i] = nan             # <<<<<<<<<<<<<<
+ * 
+ *         PyArray_ITER_NEXT(itera)
+ */
+      (__pyx_v_result_data[__pyx_v_i]) = __pyx_v_nan;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":125
+ *             result_data[i] = nan
+ * 
+ *         PyArray_ITER_NEXT(itera)             # <<<<<<<<<<<<<<
+ * 
+ *     return result.astype(int)
+ */
+    PyArray_ITER_NEXT(__pyx_v_itera);
+  }
+
+  /* "pandas/lib/src/tseries.pyx":127
+ *         PyArray_ITER_NEXT(itera)
+ * 
+ *     return result.astype(int)             # <<<<<<<<<<<<<<
+ * 
+ * def reindex(ndarray index, ndarray arr, dict idxMap):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_4 = PyObject_GetAttr(((PyObject *)__pyx_v_result), __pyx_kp_astype); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  __Pyx_INCREF(((PyObject *)((PyObject*)&PyInt_Type)));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)((PyObject*)&PyInt_Type)));
+  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyInt_Type)));
+  __pyx_t_3 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("tseries.match");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_itera);
+  __Pyx_DECREF(__pyx_v_bmap);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":129
+ *     return result.astype(int)
+ * 
+ * def reindex(ndarray index, ndarray arr, dict idxMap):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Using the provided new index, a given array, and a mapping of index-value
+ */
+
+static PyObject *__pyx_pf_7tseries_reindex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_reindex[] = "\n    Using the provided new index, a given array, and a mapping of index-value\n    correpondences in the value array, return a new ndarray conforming to \n    the new index.\n    \n    This is significantly faster than doing it in pure Python.\n    ";
+static PyObject *__pyx_pf_7tseries_reindex(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyArrayObject *__pyx_v_arr = 0;
+  PyObject *__pyx_v_idxMap = 0;
+  PyArrayObject *__pyx_v_result;
+  double *__pyx_v_result_data;
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itera;
+  PyArrayIterObject *__pyx_v_iteridx;
+  double __pyx_v_nan;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  npy_intp __pyx_t_8;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_arr,&__pyx_kp_idxMap,0};
+  __Pyx_SetupRefcountContext("reindex");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[3] = {0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_arr);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindex", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_idxMap);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindex", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "reindex") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_arr = ((PyArrayObject *)values[1]);
+    __pyx_v_idxMap = ((PyObject *)values[2]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_arr = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_idxMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 2));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("reindex", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.reindex");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_itera = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iteridx = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_idxMap), &PyDict_Type, 1, "idxMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":144
+ *     cdef object idx
+ * 
+ *     nan = <double> np.NaN             # <<<<<<<<<<<<<<
+ * 
+ *     length = PyArray_SIZE(index)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_nan = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":146
+ *     nan = <double> np.NaN
+ * 
+ *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
+
+  /* "pandas/lib/src/tseries.pyx":148
+ *     length = PyArray_SIZE(index)
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)             # <<<<<<<<<<<<<<
+ * 
+ *     result_data = <double *> result.data
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_1, __pyx_kp_32); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_3 = 0;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":150
+ *     result = <ndarray> np.empty(length, np.float64)
+ * 
+ *     result_data = <double *> result.data             # <<<<<<<<<<<<<<
+ * 
+ *     itera = PyArray_IterNew(arr)
+ */
+  __pyx_v_result_data = ((double *)__pyx_v_result->data);
+
+  /* "pandas/lib/src/tseries.pyx":152
+ *     result_data = <double *> result.data
+ * 
+ *     itera = PyArray_IterNew(arr)             # <<<<<<<<<<<<<<
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_arr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 152; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_itera));
+  __pyx_v_itera = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":153
+ * 
+ *     itera = PyArray_IterNew(arr)
+ *     iteridx = PyArray_IterNew(index)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_index)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iteridx));
+  __pyx_v_iteridx = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":155
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ */
+  __pyx_t_6 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":156
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_index), ((void *)__pyx_v_iteridx->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":157
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)             # <<<<<<<<<<<<<<
+ *         if idx not in idxMap:
+ *             result_data[i] = nan
+ */
+    PyArray_ITER_NEXT(__pyx_v_iteridx);
+
+    /* "pandas/lib/src/tseries.pyx":158
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:             # <<<<<<<<<<<<<<
+ *             result_data[i] = nan
+ *             continue
+ */
+    __pyx_t_7 = (!PySequence_Contains(((PyObject *)__pyx_v_idxMap), __pyx_v_idx)); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 158; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_7) {
+
+      /* "pandas/lib/src/tseries.pyx":159
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:
+ *             result_data[i] = nan             # <<<<<<<<<<<<<<
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ */
+      (__pyx_v_result_data[__pyx_v_i]) = __pyx_v_nan;
+
+      /* "pandas/lib/src/tseries.pyx":160
+ *         if idx not in idxMap:
+ *             result_data[i] = nan
+ *             continue             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ */
+      goto __pyx_L6_continue;
+      goto __pyx_L8;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":161
+ *             result_data[i] = nan
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])             # <<<<<<<<<<<<<<
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ * 
+ */
+    __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_idxMap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_1); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 161; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    PyArray_ITER_GOTO1D(__pyx_v_itera, __pyx_t_8);
+
+    /* "pandas/lib/src/tseries.pyx":162
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ *         result_data[i] = (<double *>(itera.dataptr))[0]             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    (__pyx_v_result_data[__pyx_v_i]) = (((double *)__pyx_v_itera->dataptr)[0]);
+    __pyx_L6_continue:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":164
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * def reindexObj(ndarray index, ndarray arr, dict idxMap):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("tseries.reindex");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_DECREF((PyObject *)__pyx_v_itera);
+  __Pyx_DECREF((PyObject *)__pyx_v_iteridx);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":166
+ *     return result
+ * 
+ * def reindexObj(ndarray index, ndarray arr, dict idxMap):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Using the provided new index, a given array, and a mapping of index-value
+ */
+
+static PyObject *__pyx_pf_7tseries_reindexObj(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_reindexObj[] = "\n    Using the provided new index, a given array, and a mapping of index-value\n    correpondences in the value array, return a new ndarray conforming to \n    the new index.\n    \n    This is significantly faster than doing it in pure Python.\n    ";
+static PyObject *__pyx_pf_7tseries_reindexObj(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyArrayObject *__pyx_v_arr = 0;
+  PyObject *__pyx_v_idxMap = 0;
+  PyArrayObject *__pyx_v_result;
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itera;
+  PyArrayIterObject *__pyx_v_iteridx;
+  PyArrayIterObject *__pyx_v_iterresult;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_nan;
+  PyObject *__pyx_v_obj;
+  int __pyx_v_res;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  npy_intp __pyx_t_6;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_arr,&__pyx_kp_idxMap,0};
+  __Pyx_SetupRefcountContext("reindexObj");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[3] = {0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_arr);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexObj", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_idxMap);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexObj", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "reindexObj") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_arr = ((PyArrayObject *)values[1]);
+    __pyx_v_idxMap = ((PyObject *)values[2]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_arr = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_idxMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 2));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("reindexObj", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.reindexObj");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_itera = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iteridx = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iterresult = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_nan = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_obj = Py_None; __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_idxMap), &PyDict_Type, 1, "idxMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":179
+ *     cdef object idx, nan, obj
+ * 
+ *     nan = np.NaN             # <<<<<<<<<<<<<<
+ *     length = PyArray_SIZE(index)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 179; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __Pyx_DECREF(__pyx_v_nan);
+  __pyx_v_nan = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":180
+ * 
+ *     nan = np.NaN
+ *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.empty(length, dtype=np.object_)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
+
+  /* "pandas/lib/src/tseries.pyx":182
+ *     length = PyArray_SIZE(index)
+ * 
+ *     result = <ndarray> np.empty(length, dtype=np.object_)             # <<<<<<<<<<<<<<
+ * 
+ *     itera = PyArray_IterNew(arr)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_2, __pyx_kp_object_); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_2)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":184
+ *     result = <ndarray> np.empty(length, dtype=np.object_)
+ * 
+ *     itera = PyArray_IterNew(arr)             # <<<<<<<<<<<<<<
+ *     iteridx = PyArray_IterNew(index)
+ *     iterresult = PyArray_IterNew(result)
+ */
+  __pyx_t_2 = PyArray_IterNew(((PyObject *)__pyx_v_arr)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_itera));
+  __pyx_v_itera = ((PyArrayIterObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":185
+ * 
+ *     itera = PyArray_IterNew(arr)
+ *     iteridx = PyArray_IterNew(index)             # <<<<<<<<<<<<<<
+ *     iterresult = PyArray_IterNew(result)
+ * 
+ */
+  __pyx_t_2 = PyArray_IterNew(((PyObject *)__pyx_v_index)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iteridx));
+  __pyx_v_iteridx = ((PyArrayIterObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":186
+ *     itera = PyArray_IterNew(arr)
+ *     iteridx = PyArray_IterNew(index)
+ *     iterresult = PyArray_IterNew(result)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int res
+ */
+  __pyx_t_2 = PyArray_IterNew(((PyObject *)__pyx_v_result)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iterresult));
+  __pyx_v_iterresult = ((PyArrayIterObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":190
+ *     cdef int res
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ */
+  __pyx_t_4 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":191
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iteridx)
+ * 
+ */
+    __pyx_t_2 = PyArray_GETITEM(((PyObject *)__pyx_v_index), ((void *)__pyx_v_iteridx->dataptr)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 191; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_2;
+    __pyx_t_2 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":192
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)             # <<<<<<<<<<<<<<
+ * 
+ *         if idx not in idxMap:
+ */
+    PyArray_ITER_NEXT(__pyx_v_iteridx);
+
+    /* "pandas/lib/src/tseries.pyx":194
+ *         PyArray_ITER_NEXT(iteridx)
+ * 
+ *         if idx not in idxMap:             # <<<<<<<<<<<<<<
+ *             PyArray_SETITEM(result, <void *> iterresult.dataptr, nan)
+ *             PyArray_ITER_NEXT(iterresult)
+ */
+    __pyx_t_5 = (!PySequence_Contains(((PyObject *)__pyx_v_idxMap), __pyx_v_idx)); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_5) {
+
+      /* "pandas/lib/src/tseries.pyx":195
+ * 
+ *         if idx not in idxMap:
+ *             PyArray_SETITEM(result, <void *> iterresult.dataptr, nan)             # <<<<<<<<<<<<<<
+ *             PyArray_ITER_NEXT(iterresult)
+ *             continue
+ */
+      PyArray_SETITEM(((PyObject *)__pyx_v_result), ((void *)__pyx_v_iterresult->dataptr), __pyx_v_nan);
+
+      /* "pandas/lib/src/tseries.pyx":196
+ *         if idx not in idxMap:
+ *             PyArray_SETITEM(result, <void *> iterresult.dataptr, nan)
+ *             PyArray_ITER_NEXT(iterresult)             # <<<<<<<<<<<<<<
+ *             continue
+ * 
+ */
+      PyArray_ITER_NEXT(__pyx_v_iterresult);
+
+      /* "pandas/lib/src/tseries.pyx":197
+ *             PyArray_SETITEM(result, <void *> iterresult.dataptr, nan)
+ *             PyArray_ITER_NEXT(iterresult)
+ *             continue             # <<<<<<<<<<<<<<
+ * 
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ */
+      goto __pyx_L6_continue;
+      goto __pyx_L8;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":199
+ *             continue
+ * 
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])             # <<<<<<<<<<<<<<
+ *         obj = PyArray_GETITEM(arr, <void *> itera.dataptr)
+ * 
+ */
+    __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_idxMap), __pyx_v_idx); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_2);
+    __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 199; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+    PyArray_ITER_GOTO1D(__pyx_v_itera, __pyx_t_6);
+
+    /* "pandas/lib/src/tseries.pyx":200
+ * 
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ *         obj = PyArray_GETITEM(arr, <void *> itera.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *         res = PyArray_SETITEM(result, <void *> iterresult.dataptr, obj)
+ */
+    __pyx_t_2 = PyArray_GETITEM(((PyObject *)__pyx_v_arr), ((void *)__pyx_v_itera->dataptr)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_v_obj);
+    __pyx_v_obj = __pyx_t_2;
+    __pyx_t_2 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":202
+ *         obj = PyArray_GETITEM(arr, <void *> itera.dataptr)
+ * 
+ *         res = PyArray_SETITEM(result, <void *> iterresult.dataptr, obj)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iterresult)
+ * 
+ */
+    __pyx_v_res = PyArray_SETITEM(((PyObject *)__pyx_v_result), ((void *)__pyx_v_iterresult->dataptr), __pyx_v_obj);
+
+    /* "pandas/lib/src/tseries.pyx":203
+ * 
+ *         res = PyArray_SETITEM(result, <void *> iterresult.dataptr, obj)
+ *         PyArray_ITER_NEXT(iterresult)             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    PyArray_ITER_NEXT(__pyx_v_iterresult);
+    __pyx_L6_continue:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":205
+ *         PyArray_ITER_NEXT(iterresult)
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("tseries.reindexObj");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_DECREF((PyObject *)__pyx_v_itera);
+  __Pyx_DECREF((PyObject *)__pyx_v_iteridx);
+  __Pyx_DECREF((PyObject *)__pyx_v_iterresult);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_nan);
+  __Pyx_DECREF(__pyx_v_obj);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":208
+ * 
+ * @cython.boundscheck(False)
+ * def reindexObject(ndarray[object, ndim=1] index,             # <<<<<<<<<<<<<<
+ *                   ndarray[object, ndim=1] arr,
+ *                   dict idxMap):
+ */
+
+static PyObject *__pyx_pf_7tseries_reindexObject(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_reindexObject[] = "\n    Using the provided new index, a given array, and a mapping of index-value\n    correpondences in the value array, return a new ndarray conforming to \n    the new index.\n    ";
+static PyObject *__pyx_pf_7tseries_reindexObject(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyArrayObject *__pyx_v_arr = 0;
+  PyObject *__pyx_v_idxMap = 0;
+  int __pyx_v_loc;
+  int __pyx_v_length;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_value;
+  PyObject *__pyx_v_nan = 0;
+  PyArrayObject *__pyx_v_result = 0;
+  int __pyx_v_i;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  Py_buffer __pyx_bstruct_arr;
+  Py_ssize_t __pyx_bstride_0_arr = 0;
+  Py_ssize_t __pyx_bshape_0_arr = 0;
+  Py_buffer __pyx_bstruct_result;
+  Py_ssize_t __pyx_bstride_0_result = 0;
+  Py_ssize_t __pyx_bshape_0_result = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  PyObject **__pyx_t_9;
+  int __pyx_t_10;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_arr,&__pyx_kp_idxMap,0};
+  __Pyx_SetupRefcountContext("reindexObject");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[3] = {0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_arr);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexObject", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_idxMap);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexObject", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "reindexObject") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_arr = ((PyArrayObject *)values[1]);
+    __pyx_v_idxMap = ((PyObject *)values[2]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_arr = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_idxMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 2));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("reindexObject", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.reindexObject");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_value = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_bstruct_result.buf = NULL;
+  __pyx_bstruct_index.buf = NULL;
+  __pyx_bstruct_arr.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 209; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_idxMap), &PyDict_Type, 1, "idxMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_arr, (PyObject*)__pyx_v_arr, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 208; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_arr = __pyx_bstruct_arr.strides[0];
+  __pyx_bshape_0_arr = __pyx_bstruct_arr.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":218
+ *     cdef int j, loc, length
+ *     cdef object idx, value
+ *     cdef object nan = np.NaN             # <<<<<<<<<<<<<<
+ * 
+ *     length = index.shape[0]
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 218; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_v_nan = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":220
+ *     cdef object nan = np.NaN
+ * 
+ *     length = index.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef ndarray[object, ndim = 1] result = np.empty(length, dtype=object)
+ * 
+ */
+  __pyx_v_length = (__pyx_v_index->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":221
+ * 
+ *     length = index.shape[0]
+ *     cdef ndarray[object, ndim = 1] result = np.empty(length, dtype=object)             # <<<<<<<<<<<<<<
+ * 
+ *     loc = 0
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_builtin_object) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_2 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_2);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_result.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_result = __pyx_bstruct_result.strides[0];
+      __pyx_bshape_0_result = __pyx_bstruct_result.shape[0];
+    }
+  }
+  __pyx_t_4 = 0;
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":223
+ *     cdef ndarray[object, ndim = 1] result = np.empty(length, dtype=object)
+ * 
+ *     loc = 0             # <<<<<<<<<<<<<<
+ *     cdef int i = 0
+ *     for i from 0 <= i < length:
+ */
+  __pyx_v_loc = 0;
+
+  /* "pandas/lib/src/tseries.pyx":224
+ * 
+ *     loc = 0
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ *     for i from 0 <= i < length:
+ *         idx = index[i]
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":225
+ *     loc = 0
+ *     cdef int i = 0
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = index[i]
+ *         if not PyDict_Contains(idxMap, idx):
+ */
+  __pyx_t_5 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":226
+ *     cdef int i = 0
+ *     for i from 0 <= i < length:
+ *         idx = index[i]             # <<<<<<<<<<<<<<
+ *         if not PyDict_Contains(idxMap, idx):
+ *             result[i] = nan
+ */
+    __pyx_t_6 = __pyx_v_i;
+    if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+    __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+    __Pyx_INCREF((PyObject*)__pyx_1);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_1;
+    __pyx_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":227
+ *     for i from 0 <= i < length:
+ *         idx = index[i]
+ *         if not PyDict_Contains(idxMap, idx):             # <<<<<<<<<<<<<<
+ *             result[i] = nan
+ *             continue
+ */
+    __pyx_t_7 = (!PyDict_Contains(((PyObject *)__pyx_v_idxMap), __pyx_v_idx));
+    if (__pyx_t_7) {
+
+      /* "pandas/lib/src/tseries.pyx":228
+ *         idx = index[i]
+ *         if not PyDict_Contains(idxMap, idx):
+ *             result[i] = nan             # <<<<<<<<<<<<<<
+ *             continue
+ *         value = arr[idxMap[idx]]
+ */
+      __pyx_t_8 = __pyx_v_i;
+      if (__pyx_t_8 < 0) __pyx_t_8 += __pyx_bshape_0_result;
+      __pyx_t_9 = __Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_result.buf, __pyx_t_8, __pyx_bstride_0_result);
+      __Pyx_GOTREF(*__pyx_t_9);
+      __Pyx_DECREF(*__pyx_t_9); __Pyx_INCREF(__pyx_v_nan);
+      *__pyx_t_9 = __pyx_v_nan;
+      __Pyx_GIVEREF(*__pyx_t_9);
+
+      /* "pandas/lib/src/tseries.pyx":229
+ *         if not PyDict_Contains(idxMap, idx):
+ *             result[i] = nan
+ *             continue             # <<<<<<<<<<<<<<
+ *         value = arr[idxMap[idx]]
+ *         result[i] = value
+ */
+      goto __pyx_L6_continue;
+      goto __pyx_L8;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":230
+ *             result[i] = nan
+ *             continue
+ *         value = arr[idxMap[idx]]             # <<<<<<<<<<<<<<
+ *         result[i] = value
+ *     return result
+ */
+    __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_idxMap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_arr), __pyx_1); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 230; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_2);
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    __Pyx_DECREF(__pyx_v_value);
+    __pyx_v_value = __pyx_2;
+    __pyx_2 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":231
+ *             continue
+ *         value = arr[idxMap[idx]]
+ *         result[i] = value             # <<<<<<<<<<<<<<
+ *     return result
+ * 
+ */
+    __pyx_t_10 = __pyx_v_i;
+    if (__pyx_t_10 < 0) __pyx_t_10 += __pyx_bshape_0_result;
+    __pyx_t_9 = __Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_result.buf, __pyx_t_10, __pyx_bstride_0_result);
+    __Pyx_GOTREF(*__pyx_t_9);
+    __Pyx_DECREF(*__pyx_t_9); __Pyx_INCREF(__pyx_v_value);
+    *__pyx_t_9 = __pyx_v_value;
+    __Pyx_GIVEREF(*__pyx_t_9);
+    __pyx_L6_continue:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":232
+ *         value = arr[idxMap[idx]]
+ *         result[i] = value
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * cdef tuple _nofill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_arr);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.reindexObject");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_arr);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_value);
+  __Pyx_XDECREF(__pyx_v_nan);
+  __Pyx_XDECREF((PyObject *)__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":234
+ *     return result
+ * 
+ * cdef tuple _nofill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):             # <<<<<<<<<<<<<<
+ *     cdef int *fillLocs
+ *     cdef char *mask
+ */
+
+static  PyObject *__pyx_f_7tseries__nofill(PyArrayObject *__pyx_v_oldIndex, PyArrayObject *__pyx_v_newIndex, PyObject *__pyx_v_oldMap, PyObject *__pyx_v_newMap) {
+  int *__pyx_v_fillLocs;
+  char *__pyx_v_mask;
+  int __pyx_v_i;
+  int __pyx_v_j;
+  int __pyx_v_length;
+  int __pyx_v_newLength;
+  PyArrayIterObject *__pyx_v_iterold;
+  PyObject *__pyx_v_idx;
+  PyArrayObject *__pyx_v_fillVec;
+  PyArrayObject *__pyx_v_maskVec;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  __Pyx_SetupRefcountContext("_nofill");
+  __pyx_v_iterold = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_fillVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_maskVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+
+  /* "pandas/lib/src/tseries.pyx":244
+ *     cdef ndarray maskVec
+ * 
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)             # <<<<<<<<<<<<<<
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_33); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_4), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_3)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_fillVec));
+  __pyx_v_fillVec = ((PyArrayObject *)__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":245
+ * 
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)             # <<<<<<<<<<<<<<
+ * 
+ *     fillLocs = <int *> fillVec.data
+ */
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_zeros); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_4 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_2, __pyx_kp_34); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_v_maskVec = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":247
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+ * 
+ *     fillLocs = <int *> fillVec.data             # <<<<<<<<<<<<<<
+ *     mask = <char *> maskVec.data
+ * 
+ */
+  __pyx_v_fillLocs = ((int *)__pyx_v_fillVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":248
+ * 
+ *     fillLocs = <int *> fillVec.data
+ *     mask = <char *> maskVec.data             # <<<<<<<<<<<<<<
+ * 
+ *     newLength = PyArray_SIZE(fillVec)
+ */
+  __pyx_v_mask = ((char *)__pyx_v_maskVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":250
+ *     mask = <char *> maskVec.data
+ * 
+ *     newLength = PyArray_SIZE(fillVec)             # <<<<<<<<<<<<<<
+ * 
+ *     length = PyArray_SIZE(oldIndex)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_fillVec), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_newLength = PyArray_SIZE(((PyArrayObject *)__pyx_v_fillVec));
+
+  /* "pandas/lib/src/tseries.pyx":252
+ *     newLength = PyArray_SIZE(fillVec)
+ * 
+ *     length = PyArray_SIZE(oldIndex)             # <<<<<<<<<<<<<<
+ *     iterold = PyArray_IterNew(oldIndex)
+ * 
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_oldIndex), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_oldIndex));
+
+  /* "pandas/lib/src/tseries.pyx":253
+ * 
+ *     length = PyArray_SIZE(oldIndex)
+ *     iterold = PyArray_IterNew(oldIndex)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_oldIndex)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 253; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iterold));
+  __pyx_v_iterold = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":255
+ *     iterold = PyArray_IterNew(oldIndex)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ *         if i < length - 1:
+ */
+  __pyx_t_5 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":256
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)             # <<<<<<<<<<<<<<
+ *         if i < length - 1:
+ *            PyArray_ITER_NEXT(iterold)
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_oldIndex), ((void *)__pyx_v_iterold->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":257
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ *         if i < length - 1:             # <<<<<<<<<<<<<<
+ *            PyArray_ITER_NEXT(iterold)
+ *         if idx in newMap:
+ */
+    __pyx_t_6 = (__pyx_v_i < (__pyx_v_length - 1));
+    if (__pyx_t_6) {
+
+      /* "pandas/lib/src/tseries.pyx":258
+ *         idx = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ *         if i < length - 1:
+ *            PyArray_ITER_NEXT(iterold)             # <<<<<<<<<<<<<<
+ *         if idx in newMap:
+ *             j = newMap[idx]
+ */
+      PyArray_ITER_NEXT(__pyx_v_iterold);
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "pandas/lib/src/tseries.pyx":259
+ *         if i < length - 1:
+ *            PyArray_ITER_NEXT(iterold)
+ *         if idx in newMap:             # <<<<<<<<<<<<<<
+ *             j = newMap[idx]
+ *             fillLocs[j] = i
+ */
+    __pyx_t_6 = (PySequence_Contains(((PyObject *)__pyx_v_newMap), __pyx_v_idx)); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_6) {
+
+      /* "pandas/lib/src/tseries.pyx":260
+ *            PyArray_ITER_NEXT(iterold)
+ *         if idx in newMap:
+ *             j = newMap[idx]             # <<<<<<<<<<<<<<
+ *             fillLocs[j] = i
+ *             mask[j] = 1
+ */
+      __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_newMap), __pyx_v_idx); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_2);
+      __pyx_t_7 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 260; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+      __pyx_v_j = __pyx_t_7;
+
+      /* "pandas/lib/src/tseries.pyx":261
+ *         if idx in newMap:
+ *             j = newMap[idx]
+ *             fillLocs[j] = i             # <<<<<<<<<<<<<<
+ *             mask[j] = 1
+ * 
+ */
+      (__pyx_v_fillLocs[__pyx_v_j]) = __pyx_v_i;
+
+      /* "pandas/lib/src/tseries.pyx":262
+ *             j = newMap[idx]
+ *             fillLocs[j] = i
+ *             mask[j] = 1             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < newLength:
+ */
+      (__pyx_v_mask[__pyx_v_j]) = 1;
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":264
+ *             mask[j] = 1
+ * 
+ *     for i from 0 <= i < newLength:             # <<<<<<<<<<<<<<
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1
+ */
+  __pyx_t_5 = __pyx_v_newLength;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":265
+ * 
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:             # <<<<<<<<<<<<<<
+ *             fillLocs[i] = -1
+ * 
+ */
+    __pyx_t_6 = ((__pyx_v_mask[__pyx_v_i]) == 0);
+    if (__pyx_t_6) {
+
+      /* "pandas/lib/src/tseries.pyx":266
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1             # <<<<<<<<<<<<<<
+ * 
+ *     return fillVec, maskVec
+ */
+      (__pyx_v_fillLocs[__pyx_v_i]) = -1;
+      goto __pyx_L9;
+    }
+    __pyx_L9:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":268
+ *             fillLocs[i] = -1
+ * 
+ *     return fillVec, maskVec             # <<<<<<<<<<<<<<
+ * 
+ * cdef tuple _backfill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  __Pyx_INCREF(((PyObject *)__pyx_v_fillVec));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_v_fillVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_fillVec));
+  __Pyx_INCREF(((PyObject *)__pyx_v_maskVec));
+  PyTuple_SET_ITEM(__pyx_t_4, 1, ((PyObject *)__pyx_v_maskVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_r = __pyx_t_4;
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("tseries._nofill");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_iterold);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF((PyObject *)__pyx_v_fillVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_maskVec);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":270
+ *     return fillVec, maskVec
+ * 
+ * cdef tuple _backfill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Backfilling logic for generating fill vector
+ */
+
+static  PyObject *__pyx_f_7tseries__backfill(PyArrayObject *__pyx_v_oldIndex, PyArrayObject *__pyx_v_newIndex, PyObject *__pyx_v_oldMap, PyObject *__pyx_v_newMap) {
+  int __pyx_v_i;
+  int __pyx_v_oldLength;
+  int __pyx_v_newLength;
+  int __pyx_v_curLoc;
+  PyArrayObject *__pyx_v_fillVec;
+  PyArrayObject *__pyx_v_maskVec;
+  int *__pyx_v_fillLocs;
+  char *__pyx_v_mask;
+  PyArrayIterObject *__pyx_v_iterold;
+  PyArrayIterObject *__pyx_v_iternew;
+  int __pyx_v_newPos;
+  int __pyx_v_oldPos;
+  PyObject *__pyx_v_prevOld;
+  PyObject *__pyx_v_curOld;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  __Pyx_SetupRefcountContext("_backfill");
+  __pyx_v_fillVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_maskVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iterold = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iternew = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_prevOld = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curOld = Py_None; __Pyx_INCREF(Py_None);
+
+  /* "pandas/lib/src/tseries.pyx":299
+ *     cdef ndarray fillVec
+ *     cdef ndarray maskVec
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)             # <<<<<<<<<<<<<<
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_33); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_4), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 299; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_3)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_fillVec));
+  __pyx_v_fillVec = ((PyArrayObject *)__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":300
+ *     cdef ndarray maskVec
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)             # <<<<<<<<<<<<<<
+ * 
+ *     # Get references
+ */
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_zeros); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_4 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_2, __pyx_kp_34); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_v_maskVec = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":305
+ *     cdef int *fillLocs
+ *     cdef char *mask
+ *     fillLocs = <int *> fillVec.data             # <<<<<<<<<<<<<<
+ *     mask = <char *> maskVec.data
+ * 
+ */
+  __pyx_v_fillLocs = ((int *)__pyx_v_fillVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":306
+ *     cdef char *mask
+ *     fillLocs = <int *> fillVec.data
+ *     mask = <char *> maskVec.data             # <<<<<<<<<<<<<<
+ * 
+ *     # Create the iterators
+ */
+  __pyx_v_mask = ((char *)__pyx_v_maskVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":310
+ *     # Create the iterators
+ *     cdef flatiter iterold, iternew
+ *     iterold = PyArray_IterNew(oldIndex)             # <<<<<<<<<<<<<<
+ *     iternew = PyArray_IterNew(newIndex)
+ * 
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_oldIndex)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 310; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iterold));
+  __pyx_v_iterold = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":311
+ *     cdef flatiter iterold, iternew
+ *     iterold = PyArray_IterNew(oldIndex)
+ *     iternew = PyArray_IterNew(newIndex)             # <<<<<<<<<<<<<<
+ * 
+ *     # Get the size
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_newIndex)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iternew));
+  __pyx_v_iternew = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":314
+ * 
+ *     # Get the size
+ *     oldLength = PyArray_SIZE(oldIndex)             # <<<<<<<<<<<<<<
+ *     newLength = PyArray_SIZE(newIndex)
+ * 
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_oldIndex), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_oldLength = PyArray_SIZE(((PyArrayObject *)__pyx_v_oldIndex));
+
+  /* "pandas/lib/src/tseries.pyx":315
+ *     # Get the size
+ *     oldLength = PyArray_SIZE(oldIndex)
+ *     newLength = PyArray_SIZE(newIndex)             # <<<<<<<<<<<<<<
+ * 
+ *     # Current positions
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_newIndex), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 315; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_newLength = PyArray_SIZE(((PyArrayObject *)__pyx_v_newIndex));
+
+  /* "pandas/lib/src/tseries.pyx":319
+ *     # Current positions
+ *     cdef int newPos, oldPos
+ *     oldPos = oldLength - 1             # <<<<<<<<<<<<<<
+ *     newPos = newLength - 1
+ * 
+ */
+  __pyx_v_oldPos = (__pyx_v_oldLength - 1);
+
+  /* "pandas/lib/src/tseries.pyx":320
+ *     cdef int newPos, oldPos
+ *     oldPos = oldLength - 1
+ *     newPos = newLength - 1             # <<<<<<<<<<<<<<
+ * 
+ *     # References holding indices
+ */
+  __pyx_v_newPos = (__pyx_v_newLength - 1);
+
+  /* "pandas/lib/src/tseries.pyx":325
+ *     cdef object prevOld, curOld
+ * 
+ *     while newPos >= 0:             # <<<<<<<<<<<<<<
+ *         # Move to the current position
+ *         PyArray_ITER_GOTO1D(iternew, newPos)
+ */
+  while (1) {
+    __pyx_t_5 = (__pyx_v_newPos >= 0);
+    if (!__pyx_t_5) break;
+
+    /* "pandas/lib/src/tseries.pyx":327
+ *     while newPos >= 0:
+ *         # Move to the current position
+ *         PyArray_ITER_GOTO1D(iternew, newPos)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_GOTO1D(iterold, oldPos)
+ * 
+ */
+    PyArray_ITER_GOTO1D(__pyx_v_iternew, __pyx_v_newPos);
+
+    /* "pandas/lib/src/tseries.pyx":328
+ *         # Move to the current position
+ *         PyArray_ITER_GOTO1D(iternew, newPos)
+ *         PyArray_ITER_GOTO1D(iterold, oldPos)             # <<<<<<<<<<<<<<
+ * 
+ *         # Get the current index
+ */
+    PyArray_ITER_GOTO1D(__pyx_v_iterold, __pyx_v_oldPos);
+
+    /* "pandas/lib/src/tseries.pyx":331
+ * 
+ *         # Get the current index
+ *         curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *         # Until we reach a point where we are before the curOld point
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_oldIndex), ((void *)__pyx_v_iterold->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_curOld);
+    __pyx_v_curOld = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":334
+ * 
+ *         # Until we reach a point where we are before the curOld point
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > curOld:             # <<<<<<<<<<<<<<
+ *             newPos -= 1
+ *             if newPos < 0:
+ */
+    while (1) {
+      __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_v_curOld, Py_GT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      if (!__pyx_t_5) break;
+
+      /* "pandas/lib/src/tseries.pyx":335
+ *         # Until we reach a point where we are before the curOld point
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > curOld:
+ *             newPos -= 1             # <<<<<<<<<<<<<<
+ *             if newPos < 0:
+ *                 break
+ */
+      __pyx_v_newPos -= 1;
+
+      /* "pandas/lib/src/tseries.pyx":336
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > curOld:
+ *             newPos -= 1
+ *             if newPos < 0:             # <<<<<<<<<<<<<<
+ *                 break
+ *             PyArray_ITER_GOTO1D(iternew, newPos)
+ */
+      __pyx_t_5 = (__pyx_v_newPos < 0);
+      if (__pyx_t_5) {
+
+        /* "pandas/lib/src/tseries.pyx":337
+ *             newPos -= 1
+ *             if newPos < 0:
+ *                 break             # <<<<<<<<<<<<<<
+ *             PyArray_ITER_GOTO1D(iternew, newPos)
+ * 
+ */
+        goto __pyx_L6_break;
+        goto __pyx_L7;
+      }
+      __pyx_L7:;
+
+      /* "pandas/lib/src/tseries.pyx":338
+ *             if newPos < 0:
+ *                 break
+ *             PyArray_ITER_GOTO1D(iternew, newPos)             # <<<<<<<<<<<<<<
+ * 
+ *         # Get the location in the old index
+ */
+      PyArray_ITER_GOTO1D(__pyx_v_iternew, __pyx_v_newPos);
+    }
+    __pyx_L6_break:;
+
+    /* "pandas/lib/src/tseries.pyx":341
+ * 
+ *         # Get the location in the old index
+ *         curLoc = oldMap[curOld]             # <<<<<<<<<<<<<<
+ * 
+ *         # At the beginning of the old index
+ */
+    __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_oldMap), __pyx_v_curOld); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_2);
+    __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 341; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+    __pyx_v_curLoc = __pyx_t_6;
+
+    /* "pandas/lib/src/tseries.pyx":344
+ * 
+ *         # At the beginning of the old index
+ *         if oldPos == 0:             # <<<<<<<<<<<<<<
+ * 
+ *             # Make sure we are before the curOld index
+ */
+    __pyx_t_5 = (__pyx_v_oldPos == 0);
+    if (__pyx_t_5) {
+
+      /* "pandas/lib/src/tseries.pyx":347
+ * 
+ *             # Make sure we are before the curOld index
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) <= curOld:             # <<<<<<<<<<<<<<
+ *                 fillVec[:newPos + 1] = curLoc
+ *                 maskVec[:newPos + 1] = 1
+ */
+      __pyx_t_1 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_v_curOld, Py_LE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_5) {
+
+        /* "pandas/lib/src/tseries.pyx":348
+ *             # Make sure we are before the curOld index
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) <= curOld:
+ *                 fillVec[:newPos + 1] = curLoc             # <<<<<<<<<<<<<<
+ *                 maskVec[:newPos + 1] = 1
+ * 
+ */
+        __pyx_t_4 = PyInt_FromLong(__pyx_v_curLoc); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        if (PySequence_SetSlice(((PyObject *)__pyx_v_fillVec), 0, (__pyx_v_newPos + 1), __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":349
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) <= curOld:
+ *                 fillVec[:newPos + 1] = curLoc
+ *                 maskVec[:newPos + 1] = 1             # <<<<<<<<<<<<<<
+ * 
+ *             # Exit the main loop
+ */
+        if (PySequence_SetSlice(((PyObject *)__pyx_v_maskVec), 0, (__pyx_v_newPos + 1), __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L9;
+      }
+      __pyx_L9:;
+
+      /* "pandas/lib/src/tseries.pyx":352
+ * 
+ *             # Exit the main loop
+ *             break             # <<<<<<<<<<<<<<
+ * 
+ *         else:
+ */
+      goto __pyx_L4_break;
+      goto __pyx_L8;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":356
+ *         else:
+ *             # Move one position back
+ *             PyArray_ITER_GOTO1D(iterold, oldPos - 1)             # <<<<<<<<<<<<<<
+ * 
+ *             # Get the index there
+ */
+      PyArray_ITER_GOTO1D(__pyx_v_iterold, (__pyx_v_oldPos - 1));
+
+      /* "pandas/lib/src/tseries.pyx":359
+ * 
+ *             # Get the index there
+ *             prevOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *             # Until we reach the previous index
+ */
+      __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_oldIndex), ((void *)__pyx_v_iterold->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_v_prevOld);
+      __pyx_v_prevOld = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":362
+ * 
+ *             # Until we reach the previous index
+ *             while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > prevOld:             # <<<<<<<<<<<<<<
+ * 
+ *                 # Set the current fill location
+ */
+      while (1) {
+        __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_v_prevOld, Py_GT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 362; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (!__pyx_t_5) break;
+
+        /* "pandas/lib/src/tseries.pyx":365
+ * 
+ *                 # Set the current fill location
+ *                 fillLocs[newPos] = curLoc             # <<<<<<<<<<<<<<
+ *                 mask[newPos] = 1
+ * 
+ */
+        (__pyx_v_fillLocs[__pyx_v_newPos]) = __pyx_v_curLoc;
+
+        /* "pandas/lib/src/tseries.pyx":366
+ *                 # Set the current fill location
+ *                 fillLocs[newPos] = curLoc
+ *                 mask[newPos] = 1             # <<<<<<<<<<<<<<
+ * 
+ *                 newPos -= 1
+ */
+        (__pyx_v_mask[__pyx_v_newPos]) = 1;
+
+        /* "pandas/lib/src/tseries.pyx":368
+ *                 mask[newPos] = 1
+ * 
+ *                 newPos -= 1             # <<<<<<<<<<<<<<
+ *                 if newPos < 0:
+ *                     break
+ */
+        __pyx_v_newPos -= 1;
+
+        /* "pandas/lib/src/tseries.pyx":369
+ * 
+ *                 newPos -= 1
+ *                 if newPos < 0:             # <<<<<<<<<<<<<<
+ *                     break
+ * 
+ */
+        __pyx_t_5 = (__pyx_v_newPos < 0);
+        if (__pyx_t_5) {
+
+          /* "pandas/lib/src/tseries.pyx":370
+ *                 newPos -= 1
+ *                 if newPos < 0:
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *                 # Move the iterator back
+ */
+          goto __pyx_L11_break;
+          goto __pyx_L12;
+        }
+        __pyx_L12:;
+
+        /* "pandas/lib/src/tseries.pyx":373
+ * 
+ *                 # Move the iterator back
+ *                 PyArray_ITER_GOTO1D(iternew, newPos)             # <<<<<<<<<<<<<<
+ * 
+ *         # Move one period back
+ */
+        PyArray_ITER_GOTO1D(__pyx_v_iternew, __pyx_v_newPos);
+      }
+      __pyx_L11_break:;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":376
+ * 
+ *         # Move one period back
+ *         oldPos -= 1             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < newLength:
+ */
+    __pyx_v_oldPos -= 1;
+  }
+  __pyx_L4_break:;
+
+  /* "pandas/lib/src/tseries.pyx":378
+ *         oldPos -= 1
+ * 
+ *     for i from 0 <= i < newLength:             # <<<<<<<<<<<<<<
+ *         if mask[i] == 0:
+ *             # Fill from some generic location
+ */
+  __pyx_t_6 = __pyx_v_newLength;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":379
+ * 
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:             # <<<<<<<<<<<<<<
+ *             # Fill from some generic location
+ *             fillLocs[i] = -1
+ */
+    __pyx_t_5 = ((__pyx_v_mask[__pyx_v_i]) == 0);
+    if (__pyx_t_5) {
+
+      /* "pandas/lib/src/tseries.pyx":381
+ *         if mask[i] == 0:
+ *             # Fill from some generic location
+ *             fillLocs[i] = -1             # <<<<<<<<<<<<<<
+ * 
+ *     return (fillVec, maskVec)
+ */
+      (__pyx_v_fillLocs[__pyx_v_i]) = -1;
+      goto __pyx_L15;
+    }
+    __pyx_L15:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":383
+ *             fillLocs[i] = -1
+ * 
+ *     return (fillVec, maskVec)             # <<<<<<<<<<<<<<
+ * 
+ * cdef tuple _pad(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __Pyx_INCREF(((PyObject *)__pyx_v_fillVec));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_fillVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_fillVec));
+  __Pyx_INCREF(((PyObject *)__pyx_v_maskVec));
+  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_maskVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("tseries._backfill");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_fillVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_maskVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_iterold);
+  __Pyx_DECREF((PyObject *)__pyx_v_iternew);
+  __Pyx_DECREF(__pyx_v_prevOld);
+  __Pyx_DECREF(__pyx_v_curOld);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":385
+ *     return (fillVec, maskVec)
+ * 
+ * cdef tuple _pad(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Padding logic for generating fill vector
+ */
+
+static  PyObject *__pyx_f_7tseries__pad(PyArrayObject *__pyx_v_oldIndex, PyArrayObject *__pyx_v_newIndex, PyObject *__pyx_v_oldMap, PyObject *__pyx_v_newMap) {
+  PyArrayObject *__pyx_v_fillVec;
+  PyArrayObject *__pyx_v_maskVec;
+  int *__pyx_v_fillLocs;
+  char *__pyx_v_mask;
+  int __pyx_v_i;
+  int __pyx_v_oldLength;
+  int __pyx_v_newLength;
+  int __pyx_v_curLoc;
+  int __pyx_v_newPos;
+  int __pyx_v_oldPos;
+  PyArrayIterObject *__pyx_v_iterold;
+  PyArrayIterObject *__pyx_v_iternew;
+  PyObject *__pyx_v_nextOld;
+  PyObject *__pyx_v_curOld;
+  char __pyx_v_done;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  Py_ssize_t __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  char __pyx_t_7;
+  __Pyx_SetupRefcountContext("_pad");
+  __pyx_v_fillVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_maskVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iterold = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iternew = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_nextOld = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curOld = Py_None; __Pyx_INCREF(Py_None);
+
+  /* "pandas/lib/src/tseries.pyx":419
+ * 
+ *     # Make empty fill vector and mask vector, cast to ndarray
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)             # <<<<<<<<<<<<<<
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_33); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_4), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_3)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_fillVec));
+  __pyx_v_fillVec = ((PyArrayObject *)__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":420
+ *     # Make empty fill vector and mask vector, cast to ndarray
+ *     fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+ *     maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)             # <<<<<<<<<<<<<<
+ * 
+ *     # Get reference to the arrays inside
+ */
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_zeros); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  __pyx_t_2 = PyObject_Length(((PyObject *)__pyx_v_newIndex)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_4 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_2, __pyx_kp_34); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_1), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_v_maskVec = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":423
+ * 
+ *     # Get reference to the arrays inside
+ *     fillLocs = <int *> fillVec.data             # <<<<<<<<<<<<<<
+ *     mask = <char *> maskVec.data
+ * 
+ */
+  __pyx_v_fillLocs = ((int *)__pyx_v_fillVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":424
+ *     # Get reference to the arrays inside
+ *     fillLocs = <int *> fillVec.data
+ *     mask = <char *> maskVec.data             # <<<<<<<<<<<<<<
+ * 
+ *     # Create simple ndarray iterators using C API
+ */
+  __pyx_v_mask = ((char *)__pyx_v_maskVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":427
+ * 
+ *     # Create simple ndarray iterators using C API
+ *     iterold = PyArray_IterNew(oldIndex)             # <<<<<<<<<<<<<<
+ *     iternew = PyArray_IterNew(newIndex)
+ * 
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_oldIndex)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 427; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iterold));
+  __pyx_v_iterold = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":428
+ *     # Create simple ndarray iterators using C API
+ *     iterold = PyArray_IterNew(oldIndex)
+ *     iternew = PyArray_IterNew(newIndex)             # <<<<<<<<<<<<<<
+ * 
+ *     # Length of each index
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_newIndex)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iternew));
+  __pyx_v_iternew = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":431
+ * 
+ *     # Length of each index
+ *     oldLength = PyArray_SIZE(oldIndex)             # <<<<<<<<<<<<<<
+ *     newLength = PyArray_SIZE(newIndex)
+ * 
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_oldIndex), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 431; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_oldLength = PyArray_SIZE(((PyArrayObject *)__pyx_v_oldIndex));
+
+  /* "pandas/lib/src/tseries.pyx":432
+ *     # Length of each index
+ *     oldLength = PyArray_SIZE(oldIndex)
+ *     newLength = PyArray_SIZE(newIndex)             # <<<<<<<<<<<<<<
+ * 
+ *     oldPos = 0
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_newIndex), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 432; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_newLength = PyArray_SIZE(((PyArrayObject *)__pyx_v_newIndex));
+
+  /* "pandas/lib/src/tseries.pyx":434
+ *     newLength = PyArray_SIZE(newIndex)
+ * 
+ *     oldPos = 0             # <<<<<<<<<<<<<<
+ *     newPos = 0
+ *     while newPos < newLength:
+ */
+  __pyx_v_oldPos = 0;
+
+  /* "pandas/lib/src/tseries.pyx":435
+ * 
+ *     oldPos = 0
+ *     newPos = 0             # <<<<<<<<<<<<<<
+ *     while newPos < newLength:
+ *         curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ */
+  __pyx_v_newPos = 0;
+
+  /* "pandas/lib/src/tseries.pyx":436
+ *     oldPos = 0
+ *     newPos = 0
+ *     while newPos < newLength:             # <<<<<<<<<<<<<<
+ *         curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ * 
+ */
+  while (1) {
+    __pyx_t_5 = (__pyx_v_newPos < __pyx_v_newLength);
+    if (!__pyx_t_5) break;
+
+    /* "pandas/lib/src/tseries.pyx":437
+ *     newPos = 0
+ *     while newPos < newLength:
+ *         curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *         # At beginning, keep going until we go exceed the
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_oldIndex), ((void *)__pyx_v_iterold->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_curOld);
+    __pyx_v_curOld = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":441
+ *         # At beginning, keep going until we go exceed the
+ *         # first OLD index in the NEW index
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < curOld:             # <<<<<<<<<<<<<<
+ *             newPos += 1
+ *             if newPos > newLength - 1:
+ */
+    while (1) {
+      __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_v_curOld, Py_LT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      if (!__pyx_t_5) break;
+
+      /* "pandas/lib/src/tseries.pyx":442
+ *         # first OLD index in the NEW index
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < curOld:
+ *             newPos += 1             # <<<<<<<<<<<<<<
+ *             if newPos > newLength - 1:
+ *                 break
+ */
+      __pyx_v_newPos += 1;
+
+      /* "pandas/lib/src/tseries.pyx":443
+ *         while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < curOld:
+ *             newPos += 1
+ *             if newPos > newLength - 1:             # <<<<<<<<<<<<<<
+ *                 break
+ *             PyArray_ITER_NEXT(iternew)
+ */
+      __pyx_t_5 = (__pyx_v_newPos > (__pyx_v_newLength - 1));
+      if (__pyx_t_5) {
+
+        /* "pandas/lib/src/tseries.pyx":444
+ *             newPos += 1
+ *             if newPos > newLength - 1:
+ *                 break             # <<<<<<<<<<<<<<
+ *             PyArray_ITER_NEXT(iternew)
+ * 
+ */
+        goto __pyx_L6_break;
+        goto __pyx_L7;
+      }
+      __pyx_L7:;
+
+      /* "pandas/lib/src/tseries.pyx":445
+ *             if newPos > newLength - 1:
+ *                 break
+ *             PyArray_ITER_NEXT(iternew)             # <<<<<<<<<<<<<<
+ * 
+ *         # We got there, get the current location in the old index
+ */
+      PyArray_ITER_NEXT(__pyx_v_iternew);
+    }
+    __pyx_L6_break:;
+
+    /* "pandas/lib/src/tseries.pyx":448
+ * 
+ *         # We got there, get the current location in the old index
+ *         curLoc = oldMap[curOld]             # <<<<<<<<<<<<<<
+ * 
+ *         # We're at the end of the road, need to propagate this value to the end
+ */
+    __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_oldMap), __pyx_v_curOld); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_2);
+    __pyx_t_6 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 448; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+    __pyx_v_curLoc = __pyx_t_6;
+
+    /* "pandas/lib/src/tseries.pyx":451
+ * 
+ *         # We're at the end of the road, need to propagate this value to the end
+ *         if oldPos == oldLength - 1:             # <<<<<<<<<<<<<<
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) >= curOld:
+ *                 fillVec[newPos:] = curLoc
+ */
+    __pyx_t_5 = (__pyx_v_oldPos == (__pyx_v_oldLength - 1));
+    if (__pyx_t_5) {
+
+      /* "pandas/lib/src/tseries.pyx":452
+ *         # We're at the end of the road, need to propagate this value to the end
+ *         if oldPos == oldLength - 1:
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) >= curOld:             # <<<<<<<<<<<<<<
+ *                 fillVec[newPos:] = curLoc
+ *                 maskVec[newPos:] = 1
+ */
+      __pyx_t_1 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_1, __pyx_v_curOld, Py_GE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_5) {
+
+        /* "pandas/lib/src/tseries.pyx":453
+ *         if oldPos == oldLength - 1:
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) >= curOld:
+ *                 fillVec[newPos:] = curLoc             # <<<<<<<<<<<<<<
+ *                 maskVec[newPos:] = 1
+ *             break
+ */
+        __pyx_t_4 = PyInt_FromLong(__pyx_v_curLoc); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        if (PySequence_SetSlice(((PyObject *)__pyx_v_fillVec), __pyx_v_newPos, PY_SSIZE_T_MAX, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 453; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":454
+ *             if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) >= curOld:
+ *                 fillVec[newPos:] = curLoc
+ *                 maskVec[newPos:] = 1             # <<<<<<<<<<<<<<
+ *             break
+ *         else:
+ */
+        if (PySequence_SetSlice(((PyObject *)__pyx_v_maskVec), __pyx_v_newPos, PY_SSIZE_T_MAX, __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L9;
+      }
+      __pyx_L9:;
+
+      /* "pandas/lib/src/tseries.pyx":455
+ *                 fillVec[newPos:] = curLoc
+ *                 maskVec[newPos:] = 1
+ *             break             # <<<<<<<<<<<<<<
+ *         else:
+ *             # Not at the end, need to go about filling
+ */
+      goto __pyx_L4_break;
+      goto __pyx_L8;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":460
+ * 
+ *             # Get the next index so we know when to stop propagating this value
+ *             PyArray_ITER_NEXT(iterold)             # <<<<<<<<<<<<<<
+ *             nextOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ * 
+ */
+      PyArray_ITER_NEXT(__pyx_v_iterold);
+
+      /* "pandas/lib/src/tseries.pyx":461
+ *             # Get the next index so we know when to stop propagating this value
+ *             PyArray_ITER_NEXT(iterold)
+ *             nextOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *             done = 0
+ */
+      __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_oldIndex), ((void *)__pyx_v_iterold->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 461; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_v_nextOld);
+      __pyx_v_nextOld = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":463
+ *             nextOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+ * 
+ *             done = 0             # <<<<<<<<<<<<<<
+ * 
+ *             # Until we reach the next OLD value in the NEW index
+ */
+      __pyx_v_done = 0;
+
+      /* "pandas/lib/src/tseries.pyx":466
+ * 
+ *             # Until we reach the next OLD value in the NEW index
+ *             while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < nextOld:             # <<<<<<<<<<<<<<
+ * 
+ *                 # Use this location to fill
+ */
+      while (1) {
+        __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_newIndex), ((void *)__pyx_v_iternew->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        __pyx_t_1 = PyObject_RichCompare(__pyx_t_4, __pyx_v_nextOld, Py_LT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 466; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (!__pyx_t_5) break;
+
+        /* "pandas/lib/src/tseries.pyx":469
+ * 
+ *                 # Use this location to fill
+ *                 fillLocs[newPos] = curLoc             # <<<<<<<<<<<<<<
+ * 
+ *                 # Set mask to be 1 so will not be NaN'd
+ */
+        (__pyx_v_fillLocs[__pyx_v_newPos]) = __pyx_v_curLoc;
+
+        /* "pandas/lib/src/tseries.pyx":472
+ * 
+ *                 # Set mask to be 1 so will not be NaN'd
+ *                 mask[newPos] = 1             # <<<<<<<<<<<<<<
+ *                 newPos += 1
+ * 
+ */
+        (__pyx_v_mask[__pyx_v_newPos]) = 1;
+
+        /* "pandas/lib/src/tseries.pyx":473
+ *                 # Set mask to be 1 so will not be NaN'd
+ *                 mask[newPos] = 1
+ *                 newPos += 1             # <<<<<<<<<<<<<<
+ * 
+ *                 # We got to the end of the new index
+ */
+        __pyx_v_newPos += 1;
+
+        /* "pandas/lib/src/tseries.pyx":476
+ * 
+ *                 # We got to the end of the new index
+ *                 if newPos > newLength - 1:             # <<<<<<<<<<<<<<
+ *                     done = 1
+ *                     break
+ */
+        __pyx_t_5 = (__pyx_v_newPos > (__pyx_v_newLength - 1));
+        if (__pyx_t_5) {
+
+          /* "pandas/lib/src/tseries.pyx":477
+ *                 # We got to the end of the new index
+ *                 if newPos > newLength - 1:
+ *                     done = 1             # <<<<<<<<<<<<<<
+ *                     break
+ * 
+ */
+          __pyx_v_done = 1;
+
+          /* "pandas/lib/src/tseries.pyx":478
+ *                 if newPos > newLength - 1:
+ *                     done = 1
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *                 # Advance the pointer
+ */
+          goto __pyx_L11_break;
+          goto __pyx_L12;
+        }
+        __pyx_L12:;
+
+        /* "pandas/lib/src/tseries.pyx":481
+ * 
+ *                 # Advance the pointer
+ *                 PyArray_ITER_NEXT(iternew)             # <<<<<<<<<<<<<<
+ * 
+ *             # We got to the end of the new index
+ */
+        PyArray_ITER_NEXT(__pyx_v_iternew);
+      }
+      __pyx_L11_break:;
+
+      /* "pandas/lib/src/tseries.pyx":484
+ * 
+ *             # We got to the end of the new index
+ *             if done:             # <<<<<<<<<<<<<<
+ *                 break
+ * 
+ */
+      __pyx_t_7 = __pyx_v_done;
+      if (__pyx_t_7) {
+
+        /* "pandas/lib/src/tseries.pyx":485
+ *             # We got to the end of the new index
+ *             if done:
+ *                 break             # <<<<<<<<<<<<<<
+ * 
+ *         # We already advanced the iterold pointer to the next value,
+ */
+        goto __pyx_L4_break;
+        goto __pyx_L13;
+      }
+      __pyx_L13:;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":489
+ *         # We already advanced the iterold pointer to the next value,
+ *         # inc the count
+ *         oldPos += 1             # <<<<<<<<<<<<<<
+ * 
+ *     # Places where the mask is 0, fill with an arbitrary value
+ */
+    __pyx_v_oldPos += 1;
+  }
+  __pyx_L4_break:;
+
+  /* "pandas/lib/src/tseries.pyx":493
+ *     # Places where the mask is 0, fill with an arbitrary value
+ *     # (will be NA'd out)
+ *     for i from 0 <= i < newLength:             # <<<<<<<<<<<<<<
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1
+ */
+  __pyx_t_6 = __pyx_v_newLength;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":494
+ *     # (will be NA'd out)
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:             # <<<<<<<<<<<<<<
+ *             fillLocs[i] = -1
+ * 
+ */
+    __pyx_t_5 = ((__pyx_v_mask[__pyx_v_i]) == 0);
+    if (__pyx_t_5) {
+
+      /* "pandas/lib/src/tseries.pyx":495
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1             # <<<<<<<<<<<<<<
+ * 
+ *     return fillVec, maskVec
+ */
+      (__pyx_v_fillLocs[__pyx_v_i]) = -1;
+      goto __pyx_L16;
+    }
+    __pyx_L16:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":497
+ *             fillLocs[i] = -1
+ * 
+ *     return fillVec, maskVec             # <<<<<<<<<<<<<<
+ * 
+ * def getFillVec(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap,
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __Pyx_INCREF(((PyObject *)__pyx_v_fillVec));
+  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_fillVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_fillVec));
+  __Pyx_INCREF(((PyObject *)__pyx_v_maskVec));
+  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_maskVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_r = __pyx_t_1;
+  __pyx_t_1 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("tseries._pad");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_fillVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_maskVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_iterold);
+  __Pyx_DECREF((PyObject *)__pyx_v_iternew);
+  __Pyx_DECREF(__pyx_v_nextOld);
+  __Pyx_DECREF(__pyx_v_curOld);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":499
+ *     return fillVec, maskVec
+ * 
+ * def getFillVec(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap,             # <<<<<<<<<<<<<<
+ *                object kind):
+ * 
+ */
+
+static PyObject *__pyx_pf_7tseries_getFillVec(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_getFillVec(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_oldIndex = 0;
+  PyArrayObject *__pyx_v_newIndex = 0;
+  PyObject *__pyx_v_oldMap = 0;
+  PyObject *__pyx_v_newMap = 0;
+  PyObject *__pyx_v_kind = 0;
+  PyObject *__pyx_v_fillVec;
+  PyObject *__pyx_v_maskVec;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_3 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_oldIndex,&__pyx_kp_newIndex,&__pyx_kp_oldMap,&__pyx_kp_newMap,&__pyx_kp_kind,0};
+  __Pyx_SetupRefcountContext("getFillVec");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[5] = {0,0,0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_oldIndex);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_newIndex);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("getFillVec", 1, 5, 5, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_oldMap);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("getFillVec", 1, 5, 5, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  3:
+      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_kp_newMap);
+      if (likely(values[3])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("getFillVec", 1, 5, 5, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  4:
+      values[4] = PyDict_GetItem(__pyx_kwds, __pyx_kp_kind);
+      if (likely(values[4])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("getFillVec", 1, 5, 5, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "getFillVec") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_oldIndex = ((PyArrayObject *)values[0]);
+    __pyx_v_newIndex = ((PyArrayObject *)values[1]);
+    __pyx_v_oldMap = ((PyObject *)values[2]);
+    __pyx_v_newMap = ((PyObject *)values[3]);
+    __pyx_v_kind = values[4];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 5) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_oldIndex = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_newIndex = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_oldMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 2));
+    __pyx_v_newMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 3));
+    __pyx_v_kind = PyTuple_GET_ITEM(__pyx_args, 4);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("getFillVec", 1, 5, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.getFillVec");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_fillVec = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_maskVec = Py_None; __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_oldIndex), __pyx_ptype_5numpy_ndarray, 1, "oldIndex", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_newIndex), __pyx_ptype_5numpy_ndarray, 1, "newIndex", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_oldMap), &PyDict_Type, 1, "oldMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_newMap), &PyDict_Type, 1, "newMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":502
+ *                object kind):
+ * 
+ *     if kind == '':             # <<<<<<<<<<<<<<
+ *         fillVec, maskVec = _nofill(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'PAD':
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_kind, __pyx_kp_35, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":503
+ * 
+ *     if kind == '':
+ *         fillVec, maskVec = _nofill(oldIndex, newIndex, oldMap, newMap)             # <<<<<<<<<<<<<<
+ *     elif kind == 'PAD':
+ *         fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)
+ */
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__nofill(__pyx_v_oldIndex, __pyx_v_newIndex, __pyx_v_oldMap, __pyx_v_newMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (likely(__pyx_t_1 != Py_None) && likely(PyTuple_GET_SIZE(__pyx_t_1) == 2)) {
+      PyObject* tuple = __pyx_t_1;
+      __pyx_2 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_2);
+      __pyx_3 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_3);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_v_fillVec);
+      __pyx_v_fillVec = __pyx_2;
+      __pyx_2 = 0;
+      __Pyx_DECREF(__pyx_v_maskVec);
+      __pyx_v_maskVec = __pyx_3;
+      __pyx_3 = 0;
+    } else {
+      __Pyx_UnpackTupleError(__pyx_t_1, 2);
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 503; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":504
+ *     if kind == '':
+ *         fillVec, maskVec = _nofill(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'PAD':             # <<<<<<<<<<<<<<
+ *         fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'BACKFILL':
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_kind, __pyx_kp_36, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":505
+ *         fillVec, maskVec = _nofill(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'PAD':
+ *         fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)             # <<<<<<<<<<<<<<
+ *     elif kind == 'BACKFILL':
+ *         fillVec, maskVec = _backfill(oldIndex, newIndex, oldMap, newMap)
+ */
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__pad(__pyx_v_oldIndex, __pyx_v_newIndex, __pyx_v_oldMap, __pyx_v_newMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (likely(__pyx_t_1 != Py_None) && likely(PyTuple_GET_SIZE(__pyx_t_1) == 2)) {
+      PyObject* tuple = __pyx_t_1;
+      __pyx_2 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_2);
+      __pyx_3 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_3);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_v_fillVec);
+      __pyx_v_fillVec = __pyx_2;
+      __pyx_2 = 0;
+      __Pyx_DECREF(__pyx_v_maskVec);
+      __pyx_v_maskVec = __pyx_3;
+      __pyx_3 = 0;
+    } else {
+      __Pyx_UnpackTupleError(__pyx_t_1, 2);
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 505; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":506
+ *     elif kind == 'PAD':
+ *         fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'BACKFILL':             # <<<<<<<<<<<<<<
+ *         fillVec, maskVec = _backfill(oldIndex, newIndex, oldMap, newMap)
+ * 
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_kind, __pyx_kp_37, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":507
+ *         fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)
+ *     elif kind == 'BACKFILL':
+ *         fillVec, maskVec = _backfill(oldIndex, newIndex, oldMap, newMap)             # <<<<<<<<<<<<<<
+ * 
+ *     return fillVec, maskVec.astype(np.bool)
+ */
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__backfill(__pyx_v_oldIndex, __pyx_v_newIndex, __pyx_v_oldMap, __pyx_v_newMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    if (likely(__pyx_t_1 != Py_None) && likely(PyTuple_GET_SIZE(__pyx_t_1) == 2)) {
+      PyObject* tuple = __pyx_t_1;
+      __pyx_2 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_2);
+      __pyx_3 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_3);
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+      __Pyx_DECREF(__pyx_v_fillVec);
+      __pyx_v_fillVec = __pyx_2;
+      __pyx_2 = 0;
+      __Pyx_DECREF(__pyx_v_maskVec);
+      __pyx_v_maskVec = __pyx_3;
+      __pyx_3 = 0;
+    } else {
+      __Pyx_UnpackTupleError(__pyx_t_1, 2);
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    }
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "pandas/lib/src/tseries.pyx":509
+ *         fillVec, maskVec = _backfill(oldIndex, newIndex, oldMap, newMap)
+ * 
+ *     return fillVec, maskVec.astype(np.bool)             # <<<<<<<<<<<<<<
+ * 
+ * def getMergeVec(ndarray values, dict indexMap):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_v_maskVec, __pyx_kp_astype); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_1, __pyx_kp_bool); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 509; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  __Pyx_INCREF(__pyx_v_fillVec);
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_fillVec);
+  __Pyx_GIVEREF(__pyx_v_fillVec);
+  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_r = ((PyObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_3);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("tseries.getFillVec");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF(__pyx_v_fillVec);
+  __Pyx_DECREF(__pyx_v_maskVec);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":511
+ *     return fillVec, maskVec.astype(np.bool)
+ * 
+ * def getMergeVec(ndarray values, dict indexMap):             # <<<<<<<<<<<<<<
+ *     cdef int *fillLocs
+ *     cdef char *mask
+ */
+
+static PyObject *__pyx_pf_7tseries_getMergeVec(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_getMergeVec(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_values = 0;
+  PyObject *__pyx_v_indexMap = 0;
+  int *__pyx_v_fillLocs;
+  char *__pyx_v_mask;
+  int __pyx_v_i;
+  int __pyx_v_j;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itervals;
+  PyObject *__pyx_v_val;
+  PyArrayObject *__pyx_v_fillVec;
+  PyArrayObject *__pyx_v_maskVec;
+  int __pyx_v_newLength;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  Py_ssize_t __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_values,&__pyx_kp_indexMap,0};
+  __Pyx_SetupRefcountContext("getMergeVec");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_values);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_indexMap);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("getMergeVec", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "getMergeVec") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_values = ((PyArrayObject *)values[0]);
+    __pyx_v_indexMap = ((PyObject *)values[1]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_values = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_indexMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("getMergeVec", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.getMergeVec");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_itervals = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_val = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_fillVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_maskVec = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_values), __pyx_ptype_5numpy_ndarray, 1, "values", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_indexMap), &PyDict_Type, 1, "indexMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 511; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":521
+ *     cdef ndarray maskVec
+ * 
+ *     cdef int newLength = len(values)             # <<<<<<<<<<<<<<
+ * 
+ *     fillVec = <ndarray> np.empty(newLength, dtype = np.int32)
+ */
+  __pyx_t_1 = PyObject_Length(((PyObject *)__pyx_v_values)); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_newLength = __pyx_t_1;
+
+  /* "pandas/lib/src/tseries.pyx":523
+ *     cdef int newLength = len(values)
+ * 
+ *     fillVec = <ndarray> np.empty(newLength, dtype = np.int32)             # <<<<<<<<<<<<<<
+ *     maskVec = <ndarray> np.zeros(newLength, dtype = np.int8)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_newLength); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  __pyx_t_3 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_33); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __pyx_t_3 = PyEval_CallObjectWithKeywords(__pyx_t_2, ((PyObject *)__pyx_t_4), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_3)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_fillVec));
+  __pyx_v_fillVec = ((PyArrayObject *)__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":524
+ * 
+ *     fillVec = <ndarray> np.empty(newLength, dtype = np.int32)
+ *     maskVec = <ndarray> np.zeros(newLength, dtype = np.int8)             # <<<<<<<<<<<<<<
+ * 
+ *     fillLocs = <int *> fillVec.data
+ */
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_3 = PyObject_GetAttr(__pyx_2, __pyx_kp_zeros); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  __pyx_t_4 = PyInt_FromLong(__pyx_v_newLength); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_4 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_2, __pyx_kp_34); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __pyx_t_4 = PyEval_CallObjectWithKeywords(__pyx_t_3, ((PyObject *)__pyx_t_2), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 524; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_maskVec));
+  __pyx_v_maskVec = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":526
+ *     maskVec = <ndarray> np.zeros(newLength, dtype = np.int8)
+ * 
+ *     fillLocs = <int *> fillVec.data             # <<<<<<<<<<<<<<
+ *     mask = <char *> maskVec.data
+ * 
+ */
+  __pyx_v_fillLocs = ((int *)__pyx_v_fillVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":527
+ * 
+ *     fillLocs = <int *> fillVec.data
+ *     mask = <char *> maskVec.data             # <<<<<<<<<<<<<<
+ * 
+ *     length = PyArray_SIZE(values)
+ */
+  __pyx_v_mask = ((char *)__pyx_v_maskVec->data);
+
+  /* "pandas/lib/src/tseries.pyx":529
+ *     mask = <char *> maskVec.data
+ * 
+ *     length = PyArray_SIZE(values)             # <<<<<<<<<<<<<<
+ *     itervals = PyArray_IterNew(values)
+ * 
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_values), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_values));
+
+  /* "pandas/lib/src/tseries.pyx":530
+ * 
+ *     length = PyArray_SIZE(values)
+ *     itervals = PyArray_IterNew(values)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_values)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_itervals));
+  __pyx_v_itervals = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":532
+ *     itervals = PyArray_IterNew(values)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         val = PyArray_GETITEM(values, <void *> itervals.dataptr)
+ *         if val in indexMap:
+ */
+  __pyx_t_5 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":533
+ * 
+ *     for i from 0 <= i < length:
+ *         val = PyArray_GETITEM(values, <void *> itervals.dataptr)             # <<<<<<<<<<<<<<
+ *         if val in indexMap:
+ *             j = indexMap[val]
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_values), ((void *)__pyx_v_itervals->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_val);
+    __pyx_v_val = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":534
+ *     for i from 0 <= i < length:
+ *         val = PyArray_GETITEM(values, <void *> itervals.dataptr)
+ *         if val in indexMap:             # <<<<<<<<<<<<<<
+ *             j = indexMap[val]
+ *             fillLocs[i] = j
+ */
+    __pyx_t_6 = (PySequence_Contains(((PyObject *)__pyx_v_indexMap), __pyx_v_val)); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 534; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_6) {
+
+      /* "pandas/lib/src/tseries.pyx":535
+ *         val = PyArray_GETITEM(values, <void *> itervals.dataptr)
+ *         if val in indexMap:
+ *             j = indexMap[val]             # <<<<<<<<<<<<<<
+ *             fillLocs[i] = j
+ *             mask[i] = 1
+ */
+      __pyx_2 = PyObject_GetItem(((PyObject *)__pyx_v_indexMap), __pyx_v_val); if (!__pyx_2) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_2);
+      __pyx_t_7 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+      __pyx_v_j = __pyx_t_7;
+
+      /* "pandas/lib/src/tseries.pyx":536
+ *         if val in indexMap:
+ *             j = indexMap[val]
+ *             fillLocs[i] = j             # <<<<<<<<<<<<<<
+ *             mask[i] = 1
+ * 
+ */
+      (__pyx_v_fillLocs[__pyx_v_i]) = __pyx_v_j;
+
+      /* "pandas/lib/src/tseries.pyx":537
+ *             j = indexMap[val]
+ *             fillLocs[i] = j
+ *             mask[i] = 1             # <<<<<<<<<<<<<<
+ * 
+ *         PyArray_ITER_NEXT(itervals)
+ */
+      (__pyx_v_mask[__pyx_v_i]) = 1;
+      goto __pyx_L8;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":539
+ *             mask[i] = 1
+ * 
+ *         PyArray_ITER_NEXT(itervals)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < newLength:
+ */
+    PyArray_ITER_NEXT(__pyx_v_itervals);
+  }
+
+  /* "pandas/lib/src/tseries.pyx":541
+ *         PyArray_ITER_NEXT(itervals)
+ * 
+ *     for i from 0 <= i < newLength:             # <<<<<<<<<<<<<<
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1
+ */
+  __pyx_t_5 = __pyx_v_newLength;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":542
+ * 
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:             # <<<<<<<<<<<<<<
+ *             fillLocs[i] = -1
+ * 
+ */
+    __pyx_t_6 = ((__pyx_v_mask[__pyx_v_i]) == 0);
+    if (__pyx_t_6) {
+
+      /* "pandas/lib/src/tseries.pyx":543
+ *     for i from 0 <= i < newLength:
+ *         if mask[i] == 0:
+ *             fillLocs[i] = -1             # <<<<<<<<<<<<<<
+ * 
+ *     return fillVec, maskVec.astype(np.bool)
+ */
+      (__pyx_v_fillLocs[__pyx_v_i]) = -1;
+      goto __pyx_L11;
+    }
+    __pyx_L11:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":545
+ *             fillLocs[i] = -1
+ * 
+ *     return fillVec, maskVec.astype(np.bool)             # <<<<<<<<<<<<<<
+ * 
+ * cdef double INF = <double> np.inf
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_4 = PyObject_GetAttr(((PyObject *)__pyx_v_maskVec), __pyx_kp_astype); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_bool); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_t_2 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 545; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_fillVec));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_fillVec));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_fillVec));
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_r = ((PyObject *)__pyx_t_3);
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_AddTraceback("tseries.getMergeVec");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_itervals);
+  __Pyx_DECREF(__pyx_v_val);
+  __Pyx_DECREF((PyObject *)__pyx_v_fillVec);
+  __Pyx_DECREF((PyObject *)__pyx_v_maskVec);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":550
+ * cdef double NEGINF = -INF
+ * 
+ * cdef inline _checknull(object val):             # <<<<<<<<<<<<<<
+ *     return val is None or val != val or val == INF or val == NEGINF
+ * 
+ */
+
+static INLINE PyObject *__pyx_f_7tseries__checknull(PyObject *__pyx_v_val) {
+  PyObject *__pyx_r = NULL;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  PyObject *__pyx_t_6 = NULL;
+  __Pyx_SetupRefcountContext("_checknull");
+
+  /* "pandas/lib/src/tseries.pyx":551
+ * 
+ * cdef inline _checknull(object val):
+ *     return val is None or val != val or val == INF or val == NEGINF             # <<<<<<<<<<<<<<
+ * 
+ * cdef ndarray _isnullobj(input):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __pyx_t_1 = (__pyx_v_val == Py_None);
+  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (!__pyx_t_1) {
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_3 = PyObject_RichCompare(__pyx_v_val, __pyx_v_val, Py_NE); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!__pyx_t_1) {
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_4 = PyFloat_FromDouble(__pyx_v_7tseries_INF); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_val, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      if (!__pyx_t_1) {
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        __pyx_t_4 = PyFloat_FromDouble(__pyx_v_7tseries_NEGINF); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        __pyx_t_6 = PyObject_RichCompare(__pyx_v_val, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_6);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        __pyx_t_4 = __pyx_t_6;
+        __pyx_t_6 = 0;
+      } else {
+        __pyx_t_4 = __pyx_t_5;
+        __pyx_t_5 = 0;
+      }
+      __pyx_t_5 = __pyx_t_4;
+      __pyx_t_4 = 0;
+    } else {
+      __pyx_t_5 = __pyx_t_3;
+      __pyx_t_3 = 0;
+    }
+    __pyx_t_3 = __pyx_t_5;
+    __pyx_t_5 = 0;
+  } else {
+    __pyx_t_3 = __pyx_t_2;
+    __pyx_t_2 = 0;
+  }
+  __pyx_r = __pyx_t_3;
+  __pyx_t_3 = 0;
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_XDECREF(__pyx_t_6);
+  __Pyx_AddTraceback("tseries._checknull");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":553
+ *     return val is None or val != val or val == INF or val == NEGINF
+ * 
+ * cdef ndarray _isnullobj(input):             # <<<<<<<<<<<<<<
+ *     cdef int i, length
+ *     cdef object val
+ */
+
+static  PyArrayObject *__pyx_f_7tseries__isnullobj(PyObject *__pyx_v_input) {
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyObject *__pyx_v_val;
+  PyArrayObject *__pyx_v_result;
+  PyArrayIterObject *__pyx_v_iter;
+  Py_buffer __pyx_bstruct_result;
+  Py_ssize_t __pyx_bstride_0_result = 0;
+  Py_ssize_t __pyx_bshape_0_result = 0;
+  PyArrayObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  PyObject *__pyx_t_6 = NULL;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  int __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  __Pyx_SetupRefcountContext("_isnullobj");
+  __pyx_v_val = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iter = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_bstruct_result.buf = NULL;
+
+  /* "pandas/lib/src/tseries.pyx":559
+ *     cdef flatiter iter
+ * 
+ *     length = PyArray_SIZE(input)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.zeros(length, dtype=np.int8)
+ */
+  if (!(__Pyx_TypeTest(__pyx_v_input, __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 559; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_input));
+
+  /* "pandas/lib/src/tseries.pyx":561
+ *     length = PyArray_SIZE(input)
+ * 
+ *     result = <ndarray> np.zeros(length, dtype=np.int8)             # <<<<<<<<<<<<<<
+ * 
+ *     iter= PyArray_IterNew(input)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_zeros); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_2, __pyx_kp_34); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_2);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+    __pyx_t_5 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack);
+    if (unlikely(__pyx_t_5 < 0)) {
+      PyErr_Fetch(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
+      if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)__pyx_v_result, &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+        Py_XDECREF(__pyx_t_6); Py_XDECREF(__pyx_t_7); Py_XDECREF(__pyx_t_8);
+        __Pyx_RaiseBufferFallbackError();
+      } else {
+        PyErr_Restore(__pyx_t_6, __pyx_t_7, __pyx_t_8);
+      }
+    }
+    __pyx_bstride_0_result = __pyx_bstruct_result.strides[0];
+    __pyx_bshape_0_result = __pyx_bstruct_result.shape[0];
+    if (unlikely(__pyx_t_5 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 561; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_t_4 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_2)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":563
+ *     result = <ndarray> np.zeros(length, dtype=np.int8)
+ * 
+ *     iter= PyArray_IterNew(input)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_2 = PyArray_IterNew(__pyx_v_input); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 563; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iter));
+  __pyx_v_iter = ((PyArrayIterObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":565
+ *     iter= PyArray_IterNew(input)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         val = PyArray_GETITEM(input, <void *> iter.dataptr)
+ * 
+ */
+  __pyx_t_5 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":566
+ * 
+ *     for i from 0 <= i < length:
+ *         val = PyArray_GETITEM(input, <void *> iter.dataptr)             # <<<<<<<<<<<<<<
+ * 
+ *         if _checknull(val):
+ */
+    __pyx_t_2 = PyArray_GETITEM(__pyx_v_input, ((void *)__pyx_v_iter->dataptr)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 566; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(__pyx_v_val);
+    __pyx_v_val = __pyx_t_2;
+    __pyx_t_2 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":568
+ *         val = PyArray_GETITEM(input, <void *> iter.dataptr)
+ * 
+ *         if _checknull(val):             # <<<<<<<<<<<<<<
+ *             result[i] = 1
+ * 
+ */
+    __pyx_t_2 = __pyx_f_7tseries__checknull(__pyx_v_val); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_9 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (__pyx_t_9) {
+
+      /* "pandas/lib/src/tseries.pyx":569
+ * 
+ *         if _checknull(val):
+ *             result[i] = 1             # <<<<<<<<<<<<<<
+ * 
+ *         PyArray_ITER_NEXT(iter)
+ */
+      __pyx_t_10 = __pyx_v_i;
+      __pyx_t_11 = -1;
+      if (__pyx_t_10 < 0) {
+        __pyx_t_10 += __pyx_bshape_0_result;
+        if (unlikely(__pyx_t_10 < 0)) __pyx_t_11 = 0;
+      } else if (unlikely(__pyx_t_10 >= __pyx_bshape_0_result)) __pyx_t_11 = 0;
+      if (unlikely(__pyx_t_11 != -1)) {
+        __Pyx_RaiseBufferIndexError(__pyx_t_11);
+        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      *__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_result.buf, __pyx_t_10, __pyx_bstride_0_result) = 1;
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "pandas/lib/src/tseries.pyx":571
+ *             result[i] = 1
+ * 
+ *         PyArray_ITER_NEXT(iter)             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    PyArray_ITER_NEXT(__pyx_v_iter);
+  }
+
+  /* "pandas/lib/src/tseries.pyx":573
+ *         PyArray_ITER_NEXT(iter)
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * def isnull(input):
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyArrayObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries._isnullobj");
+  __pyx_r = 0;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_val);
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_DECREF((PyObject *)__pyx_v_iter);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":575
+ *     return result
+ * 
+ * def isnull(input):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Replacement for numpy.isnan / -numpy.isfinite which is suitable
+ */
+
+static PyObject *__pyx_pf_7tseries_isnull(PyObject *__pyx_self, PyObject *__pyx_v_input); /*proto*/
+static char __pyx_doc_7tseries_isnull[] = "\n    Replacement for numpy.isnan / -numpy.isfinite which is suitable\n    for use on object arrays.\n\n    Parameters\n    ----------\n    arr: ndarray or object value\n    \n    Returns\n    -------\n    boolean ndarray or boolean\n    ";
+static PyObject *__pyx_pf_7tseries_isnull(PyObject *__pyx_self, PyObject *__pyx_v_input) {
+  PyArrayObject *__pyx_v_result;
+  Py_buffer __pyx_bstruct_result;
+  Py_ssize_t __pyx_bstride_0_result = 0;
+  Py_ssize_t __pyx_bshape_0_result = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7 = NULL;
+  PyObject *__pyx_t_8 = NULL;
+  PyObject *__pyx_t_9 = NULL;
+  PyObject *__pyx_t_10 = NULL;
+  __Pyx_SetupRefcountContext("isnull");
+  __pyx_self = __pyx_self;
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_bstruct_result.buf = NULL;
+
+  /* "pandas/lib/src/tseries.pyx":590
+ *     cdef ndarray[npy_int8, ndim=1] result
+ * 
+ *     if isinstance(input, np.ndarray):             # <<<<<<<<<<<<<<
+ *         if input.dtype.kind in ('O', 'S'):
+ *             result = _isnullobj(input)
+ */
+  __pyx_t_1 = PyObject_TypeCheck(__pyx_v_input, ((PyTypeObject *)((PyObject*)__pyx_ptype_5numpy_ndarray))); 
+  if (__pyx_t_1) {
+
+    /* "pandas/lib/src/tseries.pyx":591
+ * 
+ *     if isinstance(input, np.ndarray):
+ *         if input.dtype.kind in ('O', 'S'):             # <<<<<<<<<<<<<<
+ *             result = _isnullobj(input)
+ * 
+ */
+    __pyx_t_2 = PyObject_GetAttr(__pyx_v_input, __pyx_kp_dtype); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_t_2, __pyx_kp_kind); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_kp_38, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_1 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    if (!((int)__pyx_t_1)) {
+      __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_kp_39, Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_4 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __pyx_t_5 = ((int)__pyx_t_4);
+    } else {
+      __pyx_t_5 = ((int)__pyx_t_1);
+    }
+    __pyx_t_1 = __pyx_t_5;
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    if (__pyx_t_1) {
+
+      /* "pandas/lib/src/tseries.pyx":592
+ *     if isinstance(input, np.ndarray):
+ *         if input.dtype.kind in ('O', 'S'):
+ *             result = _isnullobj(input)             # <<<<<<<<<<<<<<
+ * 
+ *             return result.astype(np.bool)
+ */
+      __pyx_t_3 = ((PyObject *)__pyx_f_7tseries__isnullobj(__pyx_v_input)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      {
+        __Pyx_BufFmt_StackElem __pyx_stack[1];
+        __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+        __pyx_t_6 = __Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)((PyArrayObject *)__pyx_t_3), &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack);
+        if (unlikely(__pyx_t_6 < 0)) {
+          PyErr_Fetch(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
+          if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)__pyx_v_result, &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+            Py_XDECREF(__pyx_t_7); Py_XDECREF(__pyx_t_8); Py_XDECREF(__pyx_t_9);
+            __Pyx_RaiseBufferFallbackError();
+          } else {
+            PyErr_Restore(__pyx_t_7, __pyx_t_8, __pyx_t_9);
+          }
+        }
+        __pyx_bstride_0_result = __pyx_bstruct_result.strides[0];
+        __pyx_bshape_0_result = __pyx_bstruct_result.shape[0];
+        if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      __Pyx_DECREF(((PyObject *)__pyx_v_result));
+      __pyx_v_result = ((PyArrayObject *)__pyx_t_3);
+      __pyx_t_3 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":594
+ *             result = _isnullobj(input)
+ * 
+ *             return result.astype(np.bool)             # <<<<<<<<<<<<<<
+ *         else:
+ *             return -np.isfinite(input)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_t_3 = PyObject_GetAttr(((PyObject *)__pyx_v_result), __pyx_kp_astype); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_1);
+      __pyx_t_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_bool); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+      __pyx_t_10 = PyTuple_New(1); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_10));
+      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_10), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 594; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_10)); __pyx_t_10 = 0;
+      __pyx_r = __pyx_t_2;
+      __pyx_t_2 = 0;
+      goto __pyx_L0;
+      goto __pyx_L6;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":596
+ *             return result.astype(np.bool)
+ *         else:
+ *             return -np.isfinite(input)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return _checknull(input)
+ */
+      __Pyx_XDECREF(__pyx_r);
+      __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_1);
+      __pyx_t_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_isfinite); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+      __pyx_t_10 = PyTuple_New(1); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_10));
+      __Pyx_INCREF(__pyx_v_input);
+      PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_v_input);
+      __Pyx_GIVEREF(__pyx_v_input);
+      __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_10), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_t_10)); __pyx_t_10 = 0;
+      __pyx_1 = PyNumber_Negative(__pyx_t_3); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_1);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_r = __pyx_1;
+      __pyx_1 = 0;
+      goto __pyx_L0;
+    }
+    __pyx_L6:;
+    goto __pyx_L5;
+  }
+  /*else*/ {
+
+    /* "pandas/lib/src/tseries.pyx":598
+ *             return -np.isfinite(input)
+ *     else:
+ *         return _checknull(input)             # <<<<<<<<<<<<<<
+ * 
+ * def notnull(input):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_3 = __pyx_f_7tseries__checknull(__pyx_v_input); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L5:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_10);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.isnull");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __pyx_L2:;
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":600
+ *         return _checknull(input)
+ * 
+ * def notnull(input):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Replacement for numpy.isfinite / -numpy.isnan which is suitable
+ */
+
+static PyObject *__pyx_pf_7tseries_notnull(PyObject *__pyx_self, PyObject *__pyx_v_input); /*proto*/
+static char __pyx_doc_7tseries_notnull[] = "\n    Replacement for numpy.isfinite / -numpy.isnan which is suitable\n    for use on object arrays.\n    \n    Parameters\n    ----------\n    arr: ndarray or object value\n    \n    Returns\n    -------\n    boolean ndarray or boolean\n    ";
+static PyObject *__pyx_pf_7tseries_notnull(PyObject *__pyx_self, PyObject *__pyx_v_input) {
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  __Pyx_SetupRefcountContext("notnull");
+  __pyx_self = __pyx_self;
+
+  /* "pandas/lib/src/tseries.pyx":613
+ *     boolean ndarray or boolean
+ *     '''
+ *     if isinstance(input, np.ndarray):             # <<<<<<<<<<<<<<
+ *         return -isnull(input)
+ *     else:
+ */
+  __pyx_t_1 = PyObject_TypeCheck(__pyx_v_input, ((PyTypeObject *)((PyObject*)__pyx_ptype_5numpy_ndarray))); 
+  if (__pyx_t_1) {
+
+    /* "pandas/lib/src/tseries.pyx":614
+ *     '''
+ *     if isinstance(input, np.ndarray):
+ *         return -isnull(input)             # <<<<<<<<<<<<<<
+ *     else:
+ *         return not bool(_checknull(input))
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_isnull); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __Pyx_INCREF(__pyx_v_input);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_input);
+    __Pyx_GIVEREF(__pyx_v_input);
+    __pyx_t_3 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __pyx_1 = PyNumber_Negative(__pyx_t_3); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 614; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_r = __pyx_1;
+    __pyx_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L5;
+  }
+  /*else*/ {
+
+    /* "pandas/lib/src/tseries.pyx":616
+ *         return -isnull(input)
+ *     else:
+ *         return not bool(_checknull(input))             # <<<<<<<<<<<<<<
+ * 
+ * def reindexNew(ndarray index, ndarray arr, dict idxMap):
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_3 = __pyx_f_7tseries__checknull(__pyx_v_input); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
+    __Pyx_GIVEREF(__pyx_t_3);
+    __pyx_t_3 = 0;
+    __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)&PyBool_Type)), ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __pyx_t_3 = __Pyx_PyBool_FromLong((!__pyx_t_1)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_r = __pyx_t_3;
+    __pyx_t_3 = 0;
+    goto __pyx_L0;
+  }
+  __pyx_L5:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("tseries.notnull");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":618
+ *         return not bool(_checknull(input))
+ * 
+ * def reindexNew(ndarray index, ndarray arr, dict idxMap):             # <<<<<<<<<<<<<<
+ *     '''
+ *     Using the provided new index, a given array, and a mapping of index-value
+ */
+
+static PyObject *__pyx_pf_7tseries_reindexNew(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_reindexNew[] = "\n    Using the provided new index, a given array, and a mapping of index-value\n    correpondences in the value array, return a new ndarray conforming to \n    the new index.\n    \n    This is significantly faster than doing it in pure Python.\n    ";
+static PyObject *__pyx_pf_7tseries_reindexNew(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyArrayObject *__pyx_v_arr = 0;
+  PyObject *__pyx_v_idxMap = 0;
+  PyArrayObject *__pyx_v_result;
+  double *__pyx_v_result_data;
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itera;
+  PyArrayIterObject *__pyx_v_iteridx;
+  double __pyx_v_nan;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  npy_intp __pyx_t_8;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_arr,&__pyx_kp_idxMap,0};
+  __Pyx_SetupRefcountContext("reindexNew");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[3] = {0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_arr);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexNew", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_idxMap);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("reindexNew", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "reindexNew") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_arr = ((PyArrayObject *)values[1]);
+    __pyx_v_idxMap = ((PyObject *)values[2]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_arr = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_idxMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 2));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("reindexNew", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.reindexNew");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_itera = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iteridx = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_idxMap), &PyDict_Type, 1, "idxMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 618; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":633
+ *     cdef object idx
+ * 
+ *     nan = <double> np.NaN             # <<<<<<<<<<<<<<
+ * 
+ *     length = PyArray_SIZE(index)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 633; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_nan = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":635
+ *     nan = <double> np.NaN
+ * 
+ *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 635; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
+
+  /* "pandas/lib/src/tseries.pyx":637
+ *     length = PyArray_SIZE(index)
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)             # <<<<<<<<<<<<<<
+ * 
+ *     result_data = <double *> result.data
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_1, __pyx_kp_32); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_3 = 0;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":639
+ *     result = <ndarray> np.empty(length, np.float64)
+ * 
+ *     result_data = <double *> result.data             # <<<<<<<<<<<<<<
+ * 
+ *     itera = PyArray_IterNew(arr)
+ */
+  __pyx_v_result_data = ((double *)__pyx_v_result->data);
+
+  /* "pandas/lib/src/tseries.pyx":641
+ *     result_data = <double *> result.data
+ * 
+ *     itera = PyArray_IterNew(arr)             # <<<<<<<<<<<<<<
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_arr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 641; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 641; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_itera));
+  __pyx_v_itera = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":642
+ * 
+ *     itera = PyArray_IterNew(arr)
+ *     iteridx = PyArray_IterNew(index)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_index)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iteridx));
+  __pyx_v_iteridx = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":644
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ */
+  __pyx_t_6 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":645
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_index), ((void *)__pyx_v_iteridx->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":646
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)             # <<<<<<<<<<<<<<
+ *         if idx not in idxMap:
+ *             result_data[i] = nan
+ */
+    PyArray_ITER_NEXT(__pyx_v_iteridx);
+
+    /* "pandas/lib/src/tseries.pyx":647
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:             # <<<<<<<<<<<<<<
+ *             result_data[i] = nan
+ *             continue
+ */
+    __pyx_t_7 = (!PySequence_Contains(((PyObject *)__pyx_v_idxMap), __pyx_v_idx)); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 647; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_7) {
+
+      /* "pandas/lib/src/tseries.pyx":648
+ *         PyArray_ITER_NEXT(iteridx)
+ *         if idx not in idxMap:
+ *             result_data[i] = nan             # <<<<<<<<<<<<<<
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ */
+      (__pyx_v_result_data[__pyx_v_i]) = __pyx_v_nan;
+
+      /* "pandas/lib/src/tseries.pyx":649
+ *         if idx not in idxMap:
+ *             result_data[i] = nan
+ *             continue             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ */
+      goto __pyx_L6_continue;
+      goto __pyx_L8;
+    }
+    __pyx_L8:;
+
+    /* "pandas/lib/src/tseries.pyx":650
+ *             result_data[i] = nan
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])             # <<<<<<<<<<<<<<
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ * 
+ */
+    __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_idxMap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_8 = __Pyx_PyInt_AsInt(__pyx_1); if (unlikely((__pyx_t_8 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 650; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    PyArray_ITER_GOTO1D(__pyx_v_itera, __pyx_t_8);
+
+    /* "pandas/lib/src/tseries.pyx":651
+ *             continue
+ *         PyArray_ITER_GOTO1D(itera, idxMap[idx])
+ *         result_data[i] = (<double *>(itera.dataptr))[0]             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    (__pyx_v_result_data[__pyx_v_i]) = (((double *)__pyx_v_itera->dataptr)[0]);
+    __pyx_L6_continue:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":653
+ *         result_data[i] = (<double *>(itera.dataptr))[0]
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * cdef double __add(double a, double b):
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("tseries.reindexNew");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_DECREF((PyObject *)__pyx_v_itera);
+  __Pyx_DECREF((PyObject *)__pyx_v_iteridx);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":655
+ *     return result
+ * 
+ * cdef double __add(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a + b
+ * cdef double __sub(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___add(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__add");
+
+  /* "pandas/lib/src/tseries.pyx":656
+ * 
+ * cdef double __add(double a, double b):
+ *     return a + b             # <<<<<<<<<<<<<<
+ * cdef double __sub(double a, double b):
+ *     return a - b
+ */
+  __pyx_r = (__pyx_v_a + __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":657
+ * cdef double __add(double a, double b):
+ *     return a + b
+ * cdef double __sub(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a - b
+ * cdef double __div(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___sub(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__sub");
+
+  /* "pandas/lib/src/tseries.pyx":658
+ *     return a + b
+ * cdef double __sub(double a, double b):
+ *     return a - b             # <<<<<<<<<<<<<<
+ * cdef double __div(double a, double b):
+ *     return a / b
+ */
+  __pyx_r = (__pyx_v_a - __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":659
+ * cdef double __sub(double a, double b):
+ *     return a - b
+ * cdef double __div(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a / b
+ * cdef double __mul(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___div(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__div");
+
+  /* "pandas/lib/src/tseries.pyx":660
+ *     return a - b
+ * cdef double __div(double a, double b):
+ *     return a / b             # <<<<<<<<<<<<<<
+ * cdef double __mul(double a, double b):
+ *     return a * b
+ */
+  __pyx_r = (__pyx_v_a / __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":661
+ * cdef double __div(double a, double b):
+ *     return a / b
+ * cdef double __mul(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a * b
+ * cdef double __eq(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___mul(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__mul");
+
+  /* "pandas/lib/src/tseries.pyx":662
+ *     return a / b
+ * cdef double __mul(double a, double b):
+ *     return a * b             # <<<<<<<<<<<<<<
+ * cdef double __eq(double a, double b):
+ *     return a == b
+ */
+  __pyx_r = (__pyx_v_a * __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":663
+ * cdef double __mul(double a, double b):
+ *     return a * b
+ * cdef double __eq(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a == b
+ * cdef double __ne(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___eq(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__eq");
+
+  /* "pandas/lib/src/tseries.pyx":664
+ *     return a * b
+ * cdef double __eq(double a, double b):
+ *     return a == b             # <<<<<<<<<<<<<<
+ * cdef double __ne(double a, double b):
+ *     return a != b
+ */
+  __pyx_r = (__pyx_v_a == __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":665
+ * cdef double __eq(double a, double b):
+ *     return a == b
+ * cdef double __ne(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a != b
+ * cdef double __lt(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___ne(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__ne");
+
+  /* "pandas/lib/src/tseries.pyx":666
+ *     return a == b
+ * cdef double __ne(double a, double b):
+ *     return a != b             # <<<<<<<<<<<<<<
+ * cdef double __lt(double a, double b):
+ *     return a < b
+ */
+  __pyx_r = (__pyx_v_a != __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":667
+ * cdef double __ne(double a, double b):
+ *     return a != b
+ * cdef double __lt(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a < b
+ * cdef double __gt(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___lt(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__lt");
+
+  /* "pandas/lib/src/tseries.pyx":668
+ *     return a != b
+ * cdef double __lt(double a, double b):
+ *     return a < b             # <<<<<<<<<<<<<<
+ * cdef double __gt(double a, double b):
+ *     return a > b
+ */
+  __pyx_r = (__pyx_v_a < __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":669
+ * cdef double __lt(double a, double b):
+ *     return a < b
+ * cdef double __gt(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a > b
+ * cdef double __pow(double a, double b):
+ */
+
+static  double __pyx_f_7tseries___gt(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__gt");
+
+  /* "pandas/lib/src/tseries.pyx":670
+ *     return a < b
+ * cdef double __gt(double a, double b):
+ *     return a > b             # <<<<<<<<<<<<<<
+ * cdef double __pow(double a, double b):
+ *     return a ** b
+ */
+  __pyx_r = (__pyx_v_a > __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":671
+ * cdef double __gt(double a, double b):
+ *     return a > b
+ * cdef double __pow(double a, double b):             # <<<<<<<<<<<<<<
+ *     return a ** b
+ * 
+ */
+
+static  double __pyx_f_7tseries___pow(double __pyx_v_a, double __pyx_v_b) {
+  double __pyx_r;
+  __Pyx_SetupRefcountContext("__pow");
+
+  /* "pandas/lib/src/tseries.pyx":672
+ *     return a > b
+ * cdef double __pow(double a, double b):
+ *     return a ** b             # <<<<<<<<<<<<<<
+ * 
+ * ctypedef double (* double_func)(double a, double b)
+ */
+  __pyx_r = pow(__pyx_v_a, __pyx_v_b);
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":676
+ * ctypedef double (* double_func)(double a, double b)
+ * 
+ * cdef ndarray _applyFunc(double_func func, ndarray index, object ao,             # <<<<<<<<<<<<<<
+ *                         object bo, dict aMap, dict bMap):
+ *     '''
+ */
+
+static  PyArrayObject *__pyx_f_7tseries__applyFunc(__pyx_t_7tseries_double_func __pyx_v_func, PyArrayObject *__pyx_v_index, PyObject *__pyx_v_ao, PyObject *__pyx_v_bo, PyObject *__pyx_v_aMap, PyObject *__pyx_v_bMap) {
+  PyArrayObject *__pyx_v_A;
+  PyArrayObject *__pyx_v_B;
+  PyArrayObject *__pyx_v_result;
+  double *__pyx_v_result_data;
+  int __pyx_v_i;
+  int __pyx_v_length;
+  PyArrayIterObject *__pyx_v_itera;
+  PyArrayIterObject *__pyx_v_iterb;
+  PyArrayIterObject *__pyx_v_iteridx;
+  double __pyx_v_nan;
+  PyObject *__pyx_v_idx;
+  PyArrayObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  int __pyx_t_9;
+  Py_ssize_t __pyx_t_10;
+  Py_ssize_t __pyx_t_11;
+  __Pyx_SetupRefcountContext("_applyFunc");
+  __pyx_v_A = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_B = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_itera = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iterb = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_iteridx = ((PyArrayIterObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+
+  /* "pandas/lib/src/tseries.pyx":690
+ *     # This is EXTREMELY important, otherwise you will get very
+ *     # undesired results
+ *     A = PyArray_ContiguousFromAny(ao, NPY_DOUBLE, 1, 1)             # <<<<<<<<<<<<<<
+ *     B = PyArray_ContiguousFromAny(bo, NPY_DOUBLE, 1, 1)
+ * 
+ */
+  __pyx_t_1 = PyArray_ContiguousFromAny(__pyx_v_ao, NPY_DOUBLE, 1, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 690; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 690; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_A));
+  __pyx_v_A = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":691
+ *     # undesired results
+ *     A = PyArray_ContiguousFromAny(ao, NPY_DOUBLE, 1, 1)
+ *     B = PyArray_ContiguousFromAny(bo, NPY_DOUBLE, 1, 1)             # <<<<<<<<<<<<<<
+ * 
+ *     nan = <double> np.NaN
+ */
+  __pyx_t_1 = PyArray_ContiguousFromAny(__pyx_v_bo, NPY_DOUBLE, 1, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 691; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_B));
+  __pyx_v_B = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":693
+ *     B = PyArray_ContiguousFromAny(bo, NPY_DOUBLE, 1, 1)
+ * 
+ *     nan = <double> np.NaN             # <<<<<<<<<<<<<<
+ *     length = PyArray_SIZE(index)
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 693; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 693; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 693; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_nan = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":694
+ * 
+ *     nan = <double> np.NaN
+ *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)
+ */
+  if (!(__Pyx_TypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_7tseries_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 694; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
+
+  /* "pandas/lib/src/tseries.pyx":696
+ *     length = PyArray_SIZE(index)
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)             # <<<<<<<<<<<<<<
+ *     result_data = <double *>result.data
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_4 = PyObject_GetAttr(__pyx_1, __pyx_kp_32); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
+  __Pyx_GIVEREF(__pyx_t_3);
+  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
+  __Pyx_GIVEREF(__pyx_t_4);
+  __pyx_t_3 = 0;
+  __pyx_t_4 = 0;
+  __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 696; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_result));
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":697
+ * 
+ *     result = <ndarray> np.empty(length, np.float64)
+ *     result_data = <double *>result.data             # <<<<<<<<<<<<<<
+ * 
+ *     itera = <flatiter> PyArray_IterNew(A)
+ */
+  __pyx_v_result_data = ((double *)__pyx_v_result->data);
+
+  /* "pandas/lib/src/tseries.pyx":699
+ *     result_data = <double *>result.data
+ * 
+ *     itera = <flatiter> PyArray_IterNew(A)             # <<<<<<<<<<<<<<
+ *     iterb = <flatiter> PyArray_IterNew(B)
+ *     iteridx = PyArray_IterNew(index)
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_A)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 699; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(((PyObject *)((PyArrayIterObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_itera));
+  __pyx_v_itera = ((PyArrayIterObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":700
+ * 
+ *     itera = <flatiter> PyArray_IterNew(A)
+ *     iterb = <flatiter> PyArray_IterNew(B)             # <<<<<<<<<<<<<<
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_B)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 700; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  __Pyx_INCREF(((PyObject *)((PyArrayIterObject *)__pyx_t_4)));
+  __Pyx_DECREF(((PyObject *)__pyx_v_iterb));
+  __pyx_v_iterb = ((PyArrayIterObject *)__pyx_t_4);
+  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":701
+ *     itera = <flatiter> PyArray_IterNew(A)
+ *     iterb = <flatiter> PyArray_IterNew(B)
+ *     iteridx = PyArray_IterNew(index)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_t_4 = PyArray_IterNew(((PyObject *)__pyx_v_index)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_4);
+  if (!(__Pyx_TypeTest(__pyx_t_4, __pyx_ptype_7tseries_flatiter))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 701; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_iteridx));
+  __pyx_v_iteridx = ((PyArrayIterObject *)__pyx_t_4);
+  __pyx_t_4 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":703
+ *     iteridx = PyArray_IterNew(index)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)
+ */
+  __pyx_t_6 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_6; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":704
+ * 
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)             # <<<<<<<<<<<<<<
+ *         PyArray_ITER_NEXT(iteridx)
+ * 
+ */
+    __pyx_t_4 = PyArray_GETITEM(((PyObject *)__pyx_v_index), ((void *)__pyx_v_iteridx->dataptr)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 704; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_v_idx);
+    __pyx_v_idx = __pyx_t_4;
+    __pyx_t_4 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":705
+ *     for i from 0 <= i < length:
+ *         idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+ *         PyArray_ITER_NEXT(iteridx)             # <<<<<<<<<<<<<<
+ * 
+ *         if idx not in aMap or idx not in bMap:
+ */
+    PyArray_ITER_NEXT(__pyx_v_iteridx);
+
+    /* "pandas/lib/src/tseries.pyx":707
+ *         PyArray_ITER_NEXT(iteridx)
+ * 
+ *         if idx not in aMap or idx not in bMap:             # <<<<<<<<<<<<<<
+ *             result_data[i] = nan
+ *             continue
+ */
+    __pyx_t_7 = (!PySequence_Contains(((PyObject *)__pyx_v_aMap), __pyx_v_idx)); if (unlikely(__pyx_t_7 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (!__pyx_t_7) {
+      __pyx_t_8 = (!PySequence_Contains(((PyObject *)__pyx_v_bMap), __pyx_v_idx)); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_9 = __pyx_t_8;
+    } else {
+      __pyx_t_9 = __pyx_t_7;
+    }
+    if (__pyx_t_9) {
+
+      /* "pandas/lib/src/tseries.pyx":708
+ * 
+ *         if idx not in aMap or idx not in bMap:
+ *             result_data[i] = nan             # <<<<<<<<<<<<<<
+ *             continue
+ * 
+ */
+      (__pyx_v_result_data[__pyx_v_i]) = __pyx_v_nan;
+
+      /* "pandas/lib/src/tseries.pyx":709
+ *         if idx not in aMap or idx not in bMap:
+ *             result_data[i] = nan
+ *             continue             # <<<<<<<<<<<<<<
+ * 
+ *         result_data[i] = func((<double *>A.data)[aMap[idx]],
+ */
+      goto __pyx_L3_continue;
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "pandas/lib/src/tseries.pyx":711
+ *             continue
+ * 
+ *         result_data[i] = func((<double *>A.data)[aMap[idx]],             # <<<<<<<<<<<<<<
+ *                             (<double *>B.data)[bMap[idx]])
+ * 
+ */
+    __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_aMap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_10 = __Pyx_PyIndex_AsSsize_t(__pyx_1); if (unlikely((__pyx_t_10 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 711; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":712
+ * 
+ *         result_data[i] = func((<double *>A.data)[aMap[idx]],
+ *                             (<double *>B.data)[bMap[idx]])             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_bMap), __pyx_v_idx); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_11 = __Pyx_PyIndex_AsSsize_t(__pyx_1); if (unlikely((__pyx_t_11 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":711
+ *             continue
+ * 
+ *         result_data[i] = func((<double *>A.data)[aMap[idx]],             # <<<<<<<<<<<<<<
+ *                             (<double *>B.data)[bMap[idx]])
+ * 
+ */
+    (__pyx_v_result_data[__pyx_v_i]) = __pyx_v_func((((double *)__pyx_v_A->data)[__pyx_t_10]), (((double *)__pyx_v_B->data)[__pyx_t_11]));
+    __pyx_L3_continue:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":714
+ *                             (<double *>B.data)[bMap[idx]])
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * def combineFunc(object name, ndarray index, object ao,
+ */
+  __Pyx_XDECREF(((PyObject *)__pyx_r));
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = __pyx_v_result;
+  goto __pyx_L0;
+
+  __pyx_r = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("tseries._applyFunc");
+  __pyx_r = 0;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_A);
+  __Pyx_DECREF((PyObject *)__pyx_v_B);
+  __Pyx_DECREF((PyObject *)__pyx_v_result);
+  __Pyx_DECREF((PyObject *)__pyx_v_itera);
+  __Pyx_DECREF((PyObject *)__pyx_v_iterb);
+  __Pyx_DECREF((PyObject *)__pyx_v_iteridx);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_XGIVEREF((PyObject *)__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":716
+ *     return result
+ * 
+ * def combineFunc(object name, ndarray index, object ao,             # <<<<<<<<<<<<<<
+ *                 object bo, dict aMap, dict bMap):
+ *     '''
+ */
+
+static PyObject *__pyx_pf_7tseries_combineFunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_combineFunc[] = "\n    Combine two series (values and index maps for each passed in) using the \n    indicated function.\n    ";
+static PyObject *__pyx_pf_7tseries_combineFunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyObject *__pyx_v_name = 0;
+  PyArrayObject *__pyx_v_index = 0;
+  PyObject *__pyx_v_ao = 0;
+  PyObject *__pyx_v_bo = 0;
+  PyObject *__pyx_v_aMap = 0;
+  PyObject *__pyx_v_bMap = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_name,&__pyx_kp_index,&__pyx_kp_ao,&__pyx_kp_bo,&__pyx_kp_aMap,&__pyx_kp_bMap,0};
+  __Pyx_SetupRefcountContext("combineFunc");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[6] = {0,0,0,0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
+      case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
+      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_name);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_ao);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  3:
+      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_kp_bo);
+      if (likely(values[3])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  4:
+      values[4] = PyDict_GetItem(__pyx_kwds, __pyx_kp_aMap);
+      if (likely(values[4])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, 4); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  5:
+      values[5] = PyDict_GetItem(__pyx_kwds, __pyx_kp_bMap);
+      if (likely(values[5])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, 5); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "combineFunc") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_name = values[0];
+    __pyx_v_index = ((PyArrayObject *)values[1]);
+    __pyx_v_ao = values[2];
+    __pyx_v_bo = values[3];
+    __pyx_v_aMap = ((PyObject *)values[4]);
+    __pyx_v_bMap = ((PyObject *)values[5]);
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 6) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_name = PyTuple_GET_ITEM(__pyx_args, 0);
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_ao = PyTuple_GET_ITEM(__pyx_args, 2);
+    __pyx_v_bo = PyTuple_GET_ITEM(__pyx_args, 3);
+    __pyx_v_aMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 4));
+    __pyx_v_bMap = ((PyObject *)PyTuple_GET_ITEM(__pyx_args, 5));
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("combineFunc", 1, 6, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.combineFunc");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_aMap), &PyDict_Type, 1, "aMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 717; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_bMap), &PyDict_Type, 1, "bMap", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 717; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+  /* "pandas/lib/src/tseries.pyx":722
+ *     indicated function.
+ *     '''
+ *     if name == "__add__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__add, index, ao, bo, aMap, bMap)
+ *     elif name == "__sub__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_40, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 722; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":723
+ *     '''
+ *     if name == "__add__":
+ *         return _applyFunc(__add, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__sub__":
+ *         return _applyFunc(__sub, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___add, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 723; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":724
+ *     if name == "__add__":
+ *         return _applyFunc(__add, index, ao, bo, aMap, bMap)
+ *     elif name == "__sub__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__sub, index, ao, bo, aMap, bMap)
+ *     elif name == "__div__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_41, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":725
+ *         return _applyFunc(__add, index, ao, bo, aMap, bMap)
+ *     elif name == "__sub__":
+ *         return _applyFunc(__sub, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__div__":
+ *         return _applyFunc(__div, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___sub, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 725; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":726
+ *     elif name == "__sub__":
+ *         return _applyFunc(__sub, index, ao, bo, aMap, bMap)
+ *     elif name == "__div__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__div, index, ao, bo, aMap, bMap)
+ *     elif name == "__mul__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_42, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 726; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":727
+ *         return _applyFunc(__sub, index, ao, bo, aMap, bMap)
+ *     elif name == "__div__":
+ *         return _applyFunc(__div, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__mul__":
+ *         return _applyFunc(__mul, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___div, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 727; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":728
+ *     elif name == "__div__":
+ *         return _applyFunc(__div, index, ao, bo, aMap, bMap)
+ *     elif name == "__mul__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__mul, index, ao, bo, aMap, bMap)
+ *     elif name == "__eq__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_43, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 728; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 728; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":729
+ *         return _applyFunc(__div, index, ao, bo, aMap, bMap)
+ *     elif name == "__mul__":
+ *         return _applyFunc(__mul, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__eq__":
+ *         return _applyFunc(__eq, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___mul, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 729; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":730
+ *     elif name == "__mul__":
+ *         return _applyFunc(__mul, index, ao, bo, aMap, bMap)
+ *     elif name == "__eq__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__eq, index, ao, bo, aMap, bMap)
+ *     elif name == "__ne__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_44, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 730; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":731
+ *         return _applyFunc(__mul, index, ao, bo, aMap, bMap)
+ *     elif name == "__eq__":
+ *         return _applyFunc(__eq, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__ne__":
+ *         return _applyFunc(__ne, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___eq, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":732
+ *     elif name == "__eq__":
+ *         return _applyFunc(__eq, index, ao, bo, aMap, bMap)
+ *     elif name == "__ne__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__ne, index, ao, bo, aMap, bMap)
+ *     elif name == "__lt__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_45, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 732; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 732; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":733
+ *         return _applyFunc(__eq, index, ao, bo, aMap, bMap)
+ *     elif name == "__ne__":
+ *         return _applyFunc(__ne, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__lt__":
+ *         return _applyFunc(__lt, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___ne, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 733; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":734
+ *     elif name == "__ne__":
+ *         return _applyFunc(__ne, index, ao, bo, aMap, bMap)
+ *     elif name == "__lt__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__lt, index, ao, bo, aMap, bMap)
+ *     elif name == "__gt__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_46, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 734; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":735
+ *         return _applyFunc(__ne, index, ao, bo, aMap, bMap)
+ *     elif name == "__lt__":
+ *         return _applyFunc(__lt, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__gt__":
+ *         return _applyFunc(__gt, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___lt, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 735; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":736
+ *     elif name == "__lt__":
+ *         return _applyFunc(__lt, index, ao, bo, aMap, bMap)
+ *     elif name == "__gt__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__gt, index, ao, bo, aMap, bMap)
+ *     elif name == "__pow__":
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_47, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 736; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":737
+ *         return _applyFunc(__lt, index, ao, bo, aMap, bMap)
+ *     elif name == "__gt__":
+ *         return _applyFunc(__gt, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     elif name == "__pow__":
+ *         return _applyFunc(__pow, index, ao, bo, aMap, bMap)
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___gt, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 737; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":738
+ *     elif name == "__gt__":
+ *         return _applyFunc(__gt, index, ao, bo, aMap, bMap)
+ *     elif name == "__pow__":             # <<<<<<<<<<<<<<
+ *         return _applyFunc(__pow, index, ao, bo, aMap, bMap)
+ *     else:
+ */
+  __pyx_t_1 = PyObject_RichCompare(__pyx_v_name, __pyx_kp_48, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":739
+ *         return _applyFunc(__gt, index, ao, bo, aMap, bMap)
+ *     elif name == "__pow__":
+ *         return _applyFunc(__pow, index, ao, bo, aMap, bMap)             # <<<<<<<<<<<<<<
+ *     else:
+ *         raise Exception('bad funcname requested of Cython code')
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__applyFunc(__pyx_f_7tseries___pow, __pyx_v_index, __pyx_v_ao, __pyx_v_bo, __pyx_v_aMap, __pyx_v_bMap)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L6;
+  }
+  /*else*/ {
+
+    /* "pandas/lib/src/tseries.pyx":741
+ *         return _applyFunc(__pow, index, ao, bo, aMap, bMap)
+ *     else:
+ *         raise Exception('bad funcname requested of Cython code')             # <<<<<<<<<<<<<<
+ * 
+ * #-------------------------------------------------------------------------------
+ */
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_kp_49);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_49);
+    __Pyx_GIVEREF(__pyx_kp_49);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_L6:;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("tseries.combineFunc");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":747
+ * 
+ * @cython.boundscheck(False)
+ * def arrmap(ndarray[object, ndim=1] index, object func):             # <<<<<<<<<<<<<<
+ *     cdef int length = index.shape[0]
+ *     cdef int i = 0
+ */
+
+static PyObject *__pyx_pf_7tseries_arrmap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_arrmap(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyObject *__pyx_v_func = 0;
+  int __pyx_v_length;
+  int __pyx_v_i;
+  PyArrayObject *__pyx_v_result = 0;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  Py_buffer __pyx_bstruct_result;
+  Py_ssize_t __pyx_bstride_0_result = 0;
+  Py_ssize_t __pyx_bshape_0_result = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  PyObject **__pyx_t_8;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_func,0};
+  __Pyx_SetupRefcountContext("arrmap");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_func);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("arrmap", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 747; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "arrmap") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 747; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_func = values[1];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_func = PyTuple_GET_ITEM(__pyx_args, 1);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("arrmap", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 747; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.arrmap");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_bstruct_result.buf = NULL;
+  __pyx_bstruct_index.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 747; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 747; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":748
+ * @cython.boundscheck(False)
+ * def arrmap(ndarray[object, ndim=1] index, object func):
+ *     cdef int length = index.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef int i = 0
+ * 
+ */
+  __pyx_v_length = (__pyx_v_index->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":749
+ * def arrmap(ndarray[object, ndim=1] index, object func):
+ *     cdef int length = index.shape[0]
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ * 
+ *     cdef ndarray[object, ndim=1] result = np.empty(length, dtype=np.object_)
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":751
+ *     cdef int i = 0
+ * 
+ *     cdef ndarray[object, ndim=1] result = np.empty(length, dtype=np.object_)             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_empty); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = PyInt_FromLong(__pyx_v_length); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+  __Pyx_GIVEREF(__pyx_t_2);
+  __pyx_t_2 = 0;
+  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_1));
+  __pyx_2 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  __pyx_t_2 = PyObject_GetAttr(__pyx_2, __pyx_kp_object_); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  if (PyDict_SetItem(__pyx_1, __pyx_kp_dtype, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  __pyx_t_2 = PyEval_CallObjectWithKeywords(__pyx_t_1, ((PyObject *)__pyx_t_3), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
+  if (!(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_2);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_result, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES| PyBUF_WRITABLE, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_result = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_result.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_result = __pyx_bstruct_result.strides[0];
+      __pyx_bshape_0_result = __pyx_bstruct_result.shape[0];
+    }
+  }
+  __pyx_t_4 = 0;
+  __pyx_v_result = ((PyArrayObject *)__pyx_t_2);
+  __pyx_t_2 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":753
+ *     cdef ndarray[object, ndim=1] result = np.empty(length, dtype=np.object_)
+ * 
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         result[i] = func(index[i])
+ * 
+ */
+  __pyx_t_5 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":754
+ * 
+ *     for i from 0 <= i < length:
+ *         result[i] = func(index[i])             # <<<<<<<<<<<<<<
+ * 
+ *     return result
+ */
+    __pyx_t_6 = __pyx_v_i;
+    if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+    __pyx_2 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+    __Pyx_INCREF((PyObject*)__pyx_2);
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_2);
+    __Pyx_GIVEREF(__pyx_2);
+    __pyx_2 = 0;
+    __pyx_t_3 = PyObject_Call(__pyx_v_func, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 754; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __pyx_t_7 = __pyx_v_i;
+    if (__pyx_t_7 < 0) __pyx_t_7 += __pyx_bshape_0_result;
+    __pyx_t_8 = __Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_result.buf, __pyx_t_7, __pyx_bstride_0_result);
+    __Pyx_GOTREF(*__pyx_t_8);
+    __Pyx_DECREF(*__pyx_t_8); __Pyx_INCREF(__pyx_t_3);
+    *__pyx_t_8 = __pyx_t_3;
+    __Pyx_GIVEREF(*__pyx_t_8);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":756
+ *         result[i] = func(index[i])
+ * 
+ *     return result             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_result));
+  __pyx_r = ((PyObject *)__pyx_v_result);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.arrmap");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_result);
+  __pyx_L2:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_result);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":759
+ * 
+ * @cython.boundscheck(False)
+ * def groupby_withnull_old(ndarray[object, ndim = 1] index, object keyfunc):             # <<<<<<<<<<<<<<
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]
+ */
+
+static PyObject *__pyx_pf_7tseries_groupby_withnull_old(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_groupby_withnull_old(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyObject *__pyx_v_keyfunc = 0;
+  PyObject *__pyx_v_groups;
+  int __pyx_v_length;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_curKey;
+  PyObject *__pyx_v_key;
+  PyObject *__pyx_v_members;
+  PyArrayObject *__pyx_v_mapped_index = 0;
+  PyArrayObject *__pyx_v_null_mask = 0;
+  PyObject *__pyx_v_bool_mask;
+  PyObject *__pyx_v_null_values;
+  int __pyx_v_i;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  Py_buffer __pyx_bstruct_null_mask;
+  Py_ssize_t __pyx_bstride_0_null_mask = 0;
+  Py_ssize_t __pyx_bshape_0_null_mask = 0;
+  Py_buffer __pyx_bstruct_mapped_index;
+  Py_ssize_t __pyx_bstride_0_mapped_index = 0;
+  Py_ssize_t __pyx_bshape_0_mapped_index = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  long __pyx_t_6;
+  long __pyx_t_7;
+  int __pyx_t_8;
+  npy_int8 __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_t_12;
+  PyObject *__pyx_t_13;
+  int __pyx_t_14;
+  int __pyx_t_15;
+  int __pyx_t_16;
+  int __pyx_t_17;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_keyfunc,0};
+  __Pyx_SetupRefcountContext("groupby_withnull_old");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_keyfunc);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupby_withnull_old", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "groupby_withnull_old") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_keyfunc = values[1];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_keyfunc = PyTuple_GET_ITEM(__pyx_args, 1);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("groupby_withnull_old", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.groupby_withnull_old");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_groups = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curKey = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_key = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_members = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_bool_mask = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_null_values = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_bstruct_mapped_index.buf = NULL;
+  __pyx_bstruct_null_mask.buf = NULL;
+  __pyx_bstruct_index.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":761
+ * def groupby_withnull_old(ndarray[object, ndim = 1] index, object keyfunc):
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef object idx
+ *     cdef object curKey, key
+ */
+  __pyx_v_length = (__pyx_v_index->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":766
+ *     cdef list members
+ * 
+ *     groups = PyDict_New()             # <<<<<<<<<<<<<<
+ * 
+ *     if length != index.shape[0]:
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(PyDict_CheckExact(__pyx_t_1)) || (__pyx_t_1) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected dict, got %s", Py_TYPE(__pyx_t_1)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_groups));
+  __pyx_v_groups = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":768
+ *     groups = PyDict_New()
+ * 
+ *     if length != index.shape[0]:             # <<<<<<<<<<<<<<
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_length != (__pyx_v_index->dimensions[0]));
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":769
+ * 
+ *     if length != index.shape[0]:
+ *         raise Exception('Dates and values were not the same length!')             # <<<<<<<<<<<<<<
+ * 
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+ */
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_kp_50);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_50);
+    __Pyx_GIVEREF(__pyx_kp_50);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 769; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "pandas/lib/src/tseries.pyx":771
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_arrmap); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_index));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_index));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_index));
+  __Pyx_INCREF(__pyx_v_keyfunc);
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_keyfunc);
+  __Pyx_GIVEREF(__pyx_v_keyfunc);
+  __pyx_t_1 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  if (!(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mapped_index, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_mapped_index = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_mapped_index.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 771; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_mapped_index = __pyx_bstruct_mapped_index.strides[0];
+      __pyx_bshape_0_mapped_index = __pyx_bstruct_mapped_index.shape[0];
+    }
+  }
+  __pyx_t_4 = 0;
+  __pyx_v_mapped_index = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":773
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+ * 
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)             # <<<<<<<<<<<<<<
+ * 
+ *     bool_mask = null_mask.astype(bool)
+ */
+  __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__isnullobj(((PyObject *)__pyx_v_mapped_index))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_null_mask, (PyObject*)((PyArrayObject *)__pyx_t_1), &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_null_mask = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_null_mask.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_null_mask = __pyx_bstruct_null_mask.strides[0];
+      __pyx_bshape_0_null_mask = __pyx_bstruct_null_mask.shape[0];
+    }
+  }
+  __pyx_v_null_mask = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":775
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+ * 
+ *     bool_mask = null_mask.astype(bool)             # <<<<<<<<<<<<<<
+ * 
+ *     null_values = np.asarray(index)[bool_mask]
+ */
+  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_null_mask), __pyx_kp_astype); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)((PyObject*)&PyBool_Type)));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)((PyObject*)&PyBool_Type)));
+  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyBool_Type)));
+  __pyx_t_5 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 775; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_v_bool_mask);
+  __pyx_v_bool_mask = __pyx_t_5;
+  __pyx_t_5 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":777
+ *     bool_mask = null_mask.astype(bool)
+ * 
+ *     null_values = np.asarray(index)[bool_mask]             # <<<<<<<<<<<<<<
+ * 
+ *     if null_values.any():
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_5 = PyObject_GetAttr(__pyx_1, __pyx_kp_asarray); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_index));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_index));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_index));
+  __pyx_t_1 = PyObject_Call(__pyx_t_5, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_1 = PyObject_GetItem(__pyx_t_1, __pyx_v_bool_mask); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 777; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_v_null_values);
+  __pyx_v_null_values = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":779
+ *     null_values = np.asarray(index)[bool_mask]
+ * 
+ *     if null_values.any():             # <<<<<<<<<<<<<<
+ *         PyDict_SetItem(groups, np.NaN, null_values)
+ * 
+ */
+  __pyx_t_1 = PyObject_GetAttr(__pyx_v_null_values, __pyx_kp_any); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 779; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":780
+ * 
+ *     if null_values.any():
+ *         PyDict_SetItem(groups, np.NaN, null_values)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int i = 0
+ */
+    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 780; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_t_3, __pyx_v_null_values);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L7;
+  }
+  __pyx_L7:;
+
+  /* "pandas/lib/src/tseries.pyx":782
+ *         PyDict_SetItem(groups, np.NaN, null_values)
+ * 
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ *     idx = index[0]
+ *     key = mapped_index[0]
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":783
+ * 
+ *     cdef int i = 0
+ *     idx = index[0]             # <<<<<<<<<<<<<<
+ *     key = mapped_index[0]
+ * 
+ */
+  __pyx_t_6 = 0;
+  if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_idx);
+  __pyx_v_idx = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":784
+ *     cdef int i = 0
+ *     idx = index[0]
+ *     key = mapped_index[0]             # <<<<<<<<<<<<<<
+ * 
+ *     # Algorithm notes
+ */
+  __pyx_t_7 = 0;
+  if (__pyx_t_7 < 0) __pyx_t_7 += __pyx_bshape_0_mapped_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_7, __pyx_bstride_0_mapped_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_key);
+  __pyx_v_key = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":790
+ *     #   'lazily' evaluates
+ * 
+ *     while i < length:             # <<<<<<<<<<<<<<
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]
+ */
+  while (1) {
+    __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+    if (!__pyx_t_2) break;
+
+    /* "pandas/lib/src/tseries.pyx":791
+ * 
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):             # <<<<<<<<<<<<<<
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)
+ */
+    __pyx_t_2 = (!PyDict_Contains(((PyObject *)__pyx_v_groups), __pyx_v_key));
+    if (__pyx_t_2) {
+
+      /* "pandas/lib/src/tseries.pyx":792
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]             # <<<<<<<<<<<<<<
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 792; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+      __Pyx_INCREF(__pyx_v_idx);
+      PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_idx);
+      __Pyx_GIVEREF(__pyx_v_idx);
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = __pyx_t_3;
+      __pyx_t_3 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":793
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_v_key, ((PyObject *)__pyx_v_members));
+
+      /* "pandas/lib/src/tseries.pyx":794
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":795
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 if null_mask[i]:
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":796
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 if null_mask[i]:
+ *                     i += 1
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":797
+ *             curKey = key
+ *             while i < length:
+ *                 if null_mask[i]:             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                     continue
+ */
+        __pyx_t_8 = __pyx_v_i;
+        if (__pyx_t_8 < 0) __pyx_t_8 += __pyx_bshape_0_null_mask;
+        __pyx_t_9 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_8, __pyx_bstride_0_null_mask));
+        if (__pyx_t_9) {
+
+          /* "pandas/lib/src/tseries.pyx":798
+ *             while i < length:
+ *                 if null_mask[i]:
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                     continue
+ * 
+ */
+          __pyx_v_i += 1;
+
+          /* "pandas/lib/src/tseries.pyx":799
+ *                 if null_mask[i]:
+ *                     i += 1
+ *                     continue             # <<<<<<<<<<<<<<
+ * 
+ *                 idx = index[i]
+ */
+          goto __pyx_L11_continue;
+          goto __pyx_L13;
+        }
+        __pyx_L13:;
+
+        /* "pandas/lib/src/tseries.pyx":801
+ *                     continue
+ * 
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ */
+        __pyx_t_10 = __pyx_v_i;
+        if (__pyx_t_10 < 0) __pyx_t_10 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_10, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":802
+ * 
+ *                 idx = index[i]
+ *                 key = mapped_index[i]             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_11 = __pyx_v_i;
+        if (__pyx_t_11 < 0) __pyx_t_11 += __pyx_bshape_0_mapped_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_11, __pyx_bstride_0_mapped_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":803
+ *                 idx = index[i]
+ *                 key = mapped_index[i]
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_3 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 803; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":804
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_12 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_12 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 804; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":805
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L14;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":807
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ */
+          goto __pyx_L12_break;
+        }
+        __pyx_L14:;
+        __pyx_L11_continue:;
+      }
+      __pyx_L12_break:;
+      goto __pyx_L10;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":809
+ *                     break
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)             # <<<<<<<<<<<<<<
+ *             members.append(idx)
+ *             i += 1
+ */
+      __pyx_t_13 = PyDict_GetItem(((PyObject *)__pyx_v_groups), __pyx_v_key);
+      __Pyx_INCREF(((PyObject *)((PyObject *)__pyx_t_13)));
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = ((PyObject *)__pyx_t_13);
+
+      /* "pandas/lib/src/tseries.pyx":810
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(idx)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      __pyx_t_12 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_12 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 810; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+      /* "pandas/lib/src/tseries.pyx":811
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(idx)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while null_mask[i] and i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":812
+ *             members.append(idx)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while null_mask[i] and i < length:
+ *                 i += 1
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":813
+ *             i += 1
+ *             curKey = key
+ *             while null_mask[i] and i < length:             # <<<<<<<<<<<<<<
+ *                 i += 1
+ * 
+ */
+      while (1) {
+        __pyx_t_12 = __pyx_v_i;
+        if (__pyx_t_12 < 0) __pyx_t_12 += __pyx_bshape_0_null_mask;
+        if ((*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_12, __pyx_bstride_0_null_mask))) {
+          __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        } else {
+          __pyx_t_2 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_12, __pyx_bstride_0_null_mask));
+        }
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":814
+ *             curKey = key
+ *             while null_mask[i] and i < length:
+ *                 i += 1             # <<<<<<<<<<<<<<
+ * 
+ *             while i < length:
+ */
+        __pyx_v_i += 1;
+      }
+
+      /* "pandas/lib/src/tseries.pyx":816
+ *                 i += 1
+ * 
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 if null_mask[i]:
+ *                     i += 1
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":817
+ * 
+ *             while i < length:
+ *                 if null_mask[i]:             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                     continue
+ */
+        __pyx_t_14 = __pyx_v_i;
+        if (__pyx_t_14 < 0) __pyx_t_14 += __pyx_bshape_0_null_mask;
+        __pyx_t_9 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_14, __pyx_bstride_0_null_mask));
+        if (__pyx_t_9) {
+
+          /* "pandas/lib/src/tseries.pyx":818
+ *             while i < length:
+ *                 if null_mask[i]:
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                     continue
+ * 
+ */
+          __pyx_v_i += 1;
+
+          /* "pandas/lib/src/tseries.pyx":819
+ *                 if null_mask[i]:
+ *                     i += 1
+ *                     continue             # <<<<<<<<<<<<<<
+ * 
+ *                 idx = index[i]
+ */
+          goto __pyx_L17_continue;
+          goto __pyx_L19;
+        }
+        __pyx_L19:;
+
+        /* "pandas/lib/src/tseries.pyx":821
+ *                     continue
+ * 
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ */
+        __pyx_t_15 = __pyx_v_i;
+        if (__pyx_t_15 < 0) __pyx_t_15 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_15, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":822
+ * 
+ *                 idx = index[i]
+ *                 key = mapped_index[i]             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_16 = __pyx_v_i;
+        if (__pyx_t_16 < 0) __pyx_t_16 += __pyx_bshape_0_mapped_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_16, __pyx_bstride_0_mapped_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":823
+ *                 idx = index[i]
+ *                 key = mapped_index[i]
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_3 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 823; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":824
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_17 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_17 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 824; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":825
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L20;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":827
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *     return groups
+ */
+          goto __pyx_L18_break;
+        }
+        __pyx_L20:;
+        __pyx_L17_continue:;
+      }
+      __pyx_L18_break:;
+    }
+    __pyx_L10:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":829
+ *                     break
+ * 
+ *     return groups             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_groups));
+  __pyx_r = ((PyObject *)__pyx_v_groups);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_5);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_null_mask);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mapped_index);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.groupby_withnull_old");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_null_mask);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mapped_index);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_groups);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_curKey);
+  __Pyx_DECREF(__pyx_v_key);
+  __Pyx_DECREF(__pyx_v_members);
+  __Pyx_XDECREF((PyObject *)__pyx_v_mapped_index);
+  __Pyx_XDECREF((PyObject *)__pyx_v_null_mask);
+  __Pyx_DECREF(__pyx_v_bool_mask);
+  __Pyx_DECREF(__pyx_v_null_values);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":832
+ * 
+ * @cython.boundscheck(False)
+ * def groupby_withnull(ndarray[object, ndim = 1] index, object keyfunc):             # <<<<<<<<<<<<<<
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]
+ */
+
+static PyObject *__pyx_pf_7tseries_groupby_withnull(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_groupby_withnull(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyObject *__pyx_v_keyfunc = 0;
+  PyObject *__pyx_v_groups;
+  int __pyx_v_length;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_curKey;
+  PyObject *__pyx_v_key;
+  PyObject *__pyx_v_members;
+  PyArrayObject *__pyx_v_mapped_index = 0;
+  PyArrayObject *__pyx_v_null_mask = 0;
+  PyObject *__pyx_v_bool_mask;
+  PyObject *__pyx_v_null_values;
+  int __pyx_v_i;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  Py_buffer __pyx_bstruct_null_mask;
+  Py_ssize_t __pyx_bstride_0_null_mask = 0;
+  Py_ssize_t __pyx_bshape_0_null_mask = 0;
+  Py_buffer __pyx_bstruct_mapped_index;
+  Py_ssize_t __pyx_bstride_0_mapped_index = 0;
+  Py_ssize_t __pyx_bshape_0_mapped_index = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  PyArrayObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  long __pyx_t_6;
+  long __pyx_t_7;
+  int __pyx_t_8;
+  npy_int8 __pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_t_12;
+  int __pyx_t_13;
+  int __pyx_t_14;
+  int __pyx_t_15;
+  int __pyx_t_16;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_keyfunc,0};
+  __Pyx_SetupRefcountContext("groupby_withnull");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_keyfunc);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupby_withnull", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "groupby_withnull") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_keyfunc = values[1];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_keyfunc = PyTuple_GET_ITEM(__pyx_args, 1);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("groupby_withnull", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.groupby_withnull");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_groups = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curKey = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_key = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_members = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_bool_mask = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_null_values = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_bstruct_mapped_index.buf = NULL;
+  __pyx_bstruct_null_mask.buf = NULL;
+  __pyx_bstruct_index.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 832; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":834
+ * def groupby_withnull(ndarray[object, ndim = 1] index, object keyfunc):
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef object idx
+ *     cdef object curKey, key
+ */
+  __pyx_v_length = (__pyx_v_index->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":839
+ *     cdef list members
+ * 
+ *     groups = PyDict_New()             # <<<<<<<<<<<<<<
+ * 
+ *     if length != index.shape[0]:
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(PyDict_CheckExact(__pyx_t_1)) || (__pyx_t_1) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected dict, got %s", Py_TYPE(__pyx_t_1)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 839; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_groups));
+  __pyx_v_groups = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":841
+ *     groups = PyDict_New()
+ * 
+ *     if length != index.shape[0]:             # <<<<<<<<<<<<<<
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_length != (__pyx_v_index->dimensions[0]));
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":842
+ * 
+ *     if length != index.shape[0]:
+ *         raise Exception('Dates and values were not the same length!')             # <<<<<<<<<<<<<<
+ * 
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+ */
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_kp_51);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_51);
+    __Pyx_GIVEREF(__pyx_kp_51);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 842; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "pandas/lib/src/tseries.pyx":844
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_arrmap); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_index));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_index));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_index));
+  __Pyx_INCREF(__pyx_v_keyfunc);
+  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_keyfunc);
+  __Pyx_GIVEREF(__pyx_v_keyfunc);
+  __pyx_t_1 = PyObject_Call(__pyx_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  if (!(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5numpy_ndarray))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_4 = ((PyArrayObject *)__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_mapped_index, (PyObject*)__pyx_t_4, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_mapped_index = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_mapped_index.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 844; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_mapped_index = __pyx_bstruct_mapped_index.strides[0];
+      __pyx_bshape_0_mapped_index = __pyx_bstruct_mapped_index.shape[0];
+    }
+  }
+  __pyx_t_4 = 0;
+  __pyx_v_mapped_index = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":846
+ *     cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+ * 
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)             # <<<<<<<<<<<<<<
+ * 
+ *     bool_mask = null_mask.astype(bool)
+ */
+  __pyx_t_1 = ((PyObject *)__pyx_f_7tseries__isnullobj(((PyObject *)__pyx_v_mapped_index))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_null_mask, (PyObject*)((PyArrayObject *)__pyx_t_1), &__Pyx_TypeInfo_nn_npy_int8, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {
+      __pyx_v_null_mask = ((PyArrayObject *)Py_None); __Pyx_INCREF(Py_None); __pyx_bstruct_null_mask.buf = NULL;
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 846; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    } else {__pyx_bstride_0_null_mask = __pyx_bstruct_null_mask.strides[0];
+      __pyx_bshape_0_null_mask = __pyx_bstruct_null_mask.shape[0];
+    }
+  }
+  __pyx_v_null_mask = ((PyArrayObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":848
+ *     cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+ * 
+ *     bool_mask = null_mask.astype(bool)             # <<<<<<<<<<<<<<
+ * 
+ *     null_values = np.asarray(index)[bool_mask]
+ */
+  __pyx_t_1 = PyObject_GetAttr(((PyObject *)__pyx_v_null_mask), __pyx_kp_astype); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)((PyObject*)&PyBool_Type)));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)((PyObject*)&PyBool_Type)));
+  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyBool_Type)));
+  __pyx_t_5 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 848; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_v_bool_mask);
+  __pyx_v_bool_mask = __pyx_t_5;
+  __pyx_t_5 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":850
+ *     bool_mask = null_mask.astype(bool)
+ * 
+ *     null_values = np.asarray(index)[bool_mask]             # <<<<<<<<<<<<<<
+ * 
+ *     if null_values.any():
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_5 = PyObject_GetAttr(__pyx_1, __pyx_kp_asarray); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_5);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(((PyObject *)__pyx_v_index));
+  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_index));
+  __Pyx_GIVEREF(((PyObject *)__pyx_v_index));
+  __pyx_t_1 = PyObject_Call(__pyx_t_5, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __pyx_1 = PyObject_GetItem(__pyx_t_1, __pyx_v_bool_mask); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 850; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __Pyx_DECREF(__pyx_v_null_values);
+  __pyx_v_null_values = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":852
+ *     null_values = np.asarray(index)[bool_mask]
+ * 
+ *     if null_values.any():             # <<<<<<<<<<<<<<
+ *         PyDict_SetItem(groups, np.NaN, null_values)
+ * 
+ */
+  __pyx_t_1 = PyObject_GetAttr(__pyx_v_null_values, __pyx_kp_any); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 852; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":853
+ * 
+ *     if null_values.any():
+ *         PyDict_SetItem(groups, np.NaN, null_values)             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int i = 0
+ */
+    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_3 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 853; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_t_3, __pyx_v_null_values);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    goto __pyx_L7;
+  }
+  __pyx_L7:;
+
+  /* "pandas/lib/src/tseries.pyx":855
+ *         PyDict_SetItem(groups, np.NaN, null_values)
+ * 
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ *     idx = index[0]
+ *     key = mapped_index[0]
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":856
+ * 
+ *     cdef int i = 0
+ *     idx = index[0]             # <<<<<<<<<<<<<<
+ *     key = mapped_index[0]
+ * 
+ */
+  __pyx_t_6 = 0;
+  if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_idx);
+  __pyx_v_idx = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":857
+ *     cdef int i = 0
+ *     idx = index[0]
+ *     key = mapped_index[0]             # <<<<<<<<<<<<<<
+ * 
+ *     # Algorithm notes
+ */
+  __pyx_t_7 = 0;
+  if (__pyx_t_7 < 0) __pyx_t_7 += __pyx_bshape_0_mapped_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_7, __pyx_bstride_0_mapped_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_key);
+  __pyx_v_key = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":863
+ *     #   'lazily' evaluates
+ * 
+ *     while i < length:             # <<<<<<<<<<<<<<
+ *         if key not in groups:
+ *             members = [idx]
+ */
+  while (1) {
+    __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+    if (!__pyx_t_2) break;
+
+    /* "pandas/lib/src/tseries.pyx":864
+ * 
+ *     while i < length:
+ *         if key not in groups:             # <<<<<<<<<<<<<<
+ *             members = [idx]
+ *             groups[key] = members
+ */
+    __pyx_t_2 = (!PySequence_Contains(((PyObject *)__pyx_v_groups), __pyx_v_key)); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 864; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (__pyx_t_2) {
+
+      /* "pandas/lib/src/tseries.pyx":865
+ *     while i < length:
+ *         if key not in groups:
+ *             members = [idx]             # <<<<<<<<<<<<<<
+ *             groups[key] = members
+ *             i += 1
+ */
+      __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 865; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+      __Pyx_INCREF(__pyx_v_idx);
+      PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_idx);
+      __Pyx_GIVEREF(__pyx_v_idx);
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = __pyx_t_3;
+      __pyx_t_3 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":866
+ *         if key not in groups:
+ *             members = [idx]
+ *             groups[key] = members             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      if (PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_v_key, ((PyObject *)__pyx_v_members)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 866; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+      /* "pandas/lib/src/tseries.pyx":867
+ *             members = [idx]
+ *             groups[key] = members
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":868
+ *             groups[key] = members
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 if null_mask[i]:
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":869
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 if null_mask[i]:
+ *                     i += 1
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":870
+ *             curKey = key
+ *             while i < length:
+ *                 if null_mask[i]:             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                     continue
+ */
+        __pyx_t_8 = __pyx_v_i;
+        if (__pyx_t_8 < 0) __pyx_t_8 += __pyx_bshape_0_null_mask;
+        __pyx_t_9 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_8, __pyx_bstride_0_null_mask));
+        if (__pyx_t_9) {
+
+          /* "pandas/lib/src/tseries.pyx":871
+ *             while i < length:
+ *                 if null_mask[i]:
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                     continue
+ * 
+ */
+          __pyx_v_i += 1;
+
+          /* "pandas/lib/src/tseries.pyx":872
+ *                 if null_mask[i]:
+ *                     i += 1
+ *                     continue             # <<<<<<<<<<<<<<
+ * 
+ *                 idx = index[i]
+ */
+          goto __pyx_L11_continue;
+          goto __pyx_L13;
+        }
+        __pyx_L13:;
+
+        /* "pandas/lib/src/tseries.pyx":874
+ *                     continue
+ * 
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ */
+        __pyx_t_10 = __pyx_v_i;
+        if (__pyx_t_10 < 0) __pyx_t_10 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_10, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":875
+ * 
+ *                 idx = index[i]
+ *                 key = mapped_index[i]             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_11 = __pyx_v_i;
+        if (__pyx_t_11 < 0) __pyx_t_11 += __pyx_bshape_0_mapped_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_11, __pyx_bstride_0_mapped_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":876
+ *                 idx = index[i]
+ *                 key = mapped_index[i]
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_3 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 876; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":877
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_12 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_12 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 877; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":878
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L14;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":880
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ *         else:
+ *             members = <list> groups[key]
+ */
+          goto __pyx_L12_break;
+        }
+        __pyx_L14:;
+        __pyx_L11_continue:;
+      }
+      __pyx_L12_break:;
+      goto __pyx_L10;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":882
+ *                     break
+ *         else:
+ *             members = <list> groups[key]             # <<<<<<<<<<<<<<
+ *             members.append(idx)
+ *             i += 1
+ */
+      __pyx_1 = PyObject_GetItem(((PyObject *)__pyx_v_groups), __pyx_v_key); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 882; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_1);
+      __Pyx_INCREF(((PyObject *)((PyObject *)__pyx_1)));
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = ((PyObject *)__pyx_1);
+      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":883
+ *         else:
+ *             members = <list> groups[key]
+ *             members.append(idx)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      __pyx_t_12 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_12 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 883; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+      /* "pandas/lib/src/tseries.pyx":884
+ *             members = <list> groups[key]
+ *             members.append(idx)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while null_mask[i] and i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":885
+ *             members.append(idx)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while null_mask[i] and i < length:
+ *                 i += 1
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":886
+ *             i += 1
+ *             curKey = key
+ *             while null_mask[i] and i < length:             # <<<<<<<<<<<<<<
+ *                 i += 1
+ * 
+ */
+      while (1) {
+        __pyx_t_12 = __pyx_v_i;
+        if (__pyx_t_12 < 0) __pyx_t_12 += __pyx_bshape_0_null_mask;
+        if ((*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_12, __pyx_bstride_0_null_mask))) {
+          __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        } else {
+          __pyx_t_2 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_12, __pyx_bstride_0_null_mask));
+        }
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":887
+ *             curKey = key
+ *             while null_mask[i] and i < length:
+ *                 i += 1             # <<<<<<<<<<<<<<
+ * 
+ *             while i < length:
+ */
+        __pyx_v_i += 1;
+      }
+
+      /* "pandas/lib/src/tseries.pyx":889
+ *                 i += 1
+ * 
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 if null_mask[i]:
+ *                     i += 1
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":890
+ * 
+ *             while i < length:
+ *                 if null_mask[i]:             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                     continue
+ */
+        __pyx_t_13 = __pyx_v_i;
+        if (__pyx_t_13 < 0) __pyx_t_13 += __pyx_bshape_0_null_mask;
+        __pyx_t_9 = (*__Pyx_BufPtrStrided1d(npy_int8 *, __pyx_bstruct_null_mask.buf, __pyx_t_13, __pyx_bstride_0_null_mask));
+        if (__pyx_t_9) {
+
+          /* "pandas/lib/src/tseries.pyx":891
+ *             while i < length:
+ *                 if null_mask[i]:
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                     continue
+ * 
+ */
+          __pyx_v_i += 1;
+
+          /* "pandas/lib/src/tseries.pyx":892
+ *                 if null_mask[i]:
+ *                     i += 1
+ *                     continue             # <<<<<<<<<<<<<<
+ * 
+ *                 idx = index[i]
+ */
+          goto __pyx_L17_continue;
+          goto __pyx_L19;
+        }
+        __pyx_L19:;
+
+        /* "pandas/lib/src/tseries.pyx":894
+ *                     continue
+ * 
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ */
+        __pyx_t_14 = __pyx_v_i;
+        if (__pyx_t_14 < 0) __pyx_t_14 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_14, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":895
+ * 
+ *                 idx = index[i]
+ *                 key = mapped_index[i]             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_15 = __pyx_v_i;
+        if (__pyx_t_15 < 0) __pyx_t_15 += __pyx_bshape_0_mapped_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_mapped_index.buf, __pyx_t_15, __pyx_bstride_0_mapped_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":896
+ *                 idx = index[i]
+ *                 key = mapped_index[i]
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_3 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_3);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 896; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":897
+ *                 key = mapped_index[i]
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_16 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_16 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 897; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":898
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L20;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":900
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *     return groups
+ */
+          goto __pyx_L18_break;
+        }
+        __pyx_L20:;
+        __pyx_L17_continue:;
+      }
+      __pyx_L18_break:;
+    }
+    __pyx_L10:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":902
+ *                     break
+ * 
+ *     return groups             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_groups));
+  __pyx_r = ((PyObject *)__pyx_v_groups);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_5);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_null_mask);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mapped_index);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.groupby_withnull");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_null_mask);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_mapped_index);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_groups);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_curKey);
+  __Pyx_DECREF(__pyx_v_key);
+  __Pyx_DECREF(__pyx_v_members);
+  __Pyx_XDECREF((PyObject *)__pyx_v_mapped_index);
+  __Pyx_XDECREF((PyObject *)__pyx_v_null_mask);
+  __Pyx_DECREF(__pyx_v_bool_mask);
+  __Pyx_DECREF(__pyx_v_null_values);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":905
+ * 
+ * @cython.boundscheck(False)
+ * def groupby(ndarray[object, ndim = 1] index, object keyfunc):             # <<<<<<<<<<<<<<
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]
+ */
+
+static PyObject *__pyx_pf_7tseries_groupby(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static PyObject *__pyx_pf_7tseries_groupby(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyObject *__pyx_v_keyfunc = 0;
+  PyObject *__pyx_v_groups;
+  int __pyx_v_length;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_curKey;
+  PyObject *__pyx_v_key;
+  PyObject *__pyx_v_members;
+  int __pyx_v_i;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  PyObject *__pyx_t_7;
+  int __pyx_t_8;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_keyfunc,0};
+  __Pyx_SetupRefcountContext("groupby");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[2] = {0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_keyfunc);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupby", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "groupby") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_keyfunc = values[1];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_keyfunc = PyTuple_GET_ITEM(__pyx_args, 1);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("groupby", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.groupby");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_groups = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curKey = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_key = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_members = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_bstruct_index.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 905; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":907
+ * def groupby(ndarray[object, ndim = 1] index, object keyfunc):
+ *     cdef dict groups
+ *     cdef int length = index.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef object idx
+ *     cdef object curKey, key
+ */
+  __pyx_v_length = (__pyx_v_index->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":912
+ *     cdef list members
+ * 
+ *     groups = PyDict_New()             # <<<<<<<<<<<<<<
+ * 
+ *     if length != index.shape[0]:
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(PyDict_CheckExact(__pyx_t_1)) || (__pyx_t_1) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected dict, got %s", Py_TYPE(__pyx_t_1)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 912; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_groups));
+  __pyx_v_groups = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":914
+ *     groups = PyDict_New()
+ * 
+ *     if length != index.shape[0]:             # <<<<<<<<<<<<<<
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_length != (__pyx_v_index->dimensions[0]));
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":915
+ * 
+ *     if length != index.shape[0]:
+ *         raise Exception('Dates and values were not the same length!')             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int i = 0
+ */
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_kp_52);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_52);
+    __Pyx_GIVEREF(__pyx_kp_52);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 915; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "pandas/lib/src/tseries.pyx":917
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ *     idx = index[i]
+ *     key = keyfunc(idx)
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":918
+ * 
+ *     cdef int i = 0
+ *     idx = index[i]             # <<<<<<<<<<<<<<
+ *     key = keyfunc(idx)
+ * 
+ */
+  __pyx_t_4 = __pyx_v_i;
+  if (__pyx_t_4 < 0) __pyx_t_4 += __pyx_bshape_0_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_4, __pyx_bstride_0_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_idx);
+  __pyx_v_idx = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":919
+ *     cdef int i = 0
+ *     idx = index[i]
+ *     key = keyfunc(idx)             # <<<<<<<<<<<<<<
+ * 
+ *     # Algorithm notes
+ */
+  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+  __Pyx_INCREF(__pyx_v_idx);
+  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_idx);
+  __Pyx_GIVEREF(__pyx_v_idx);
+  __pyx_t_1 = PyObject_Call(__pyx_v_keyfunc, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 919; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+  __Pyx_DECREF(__pyx_v_key);
+  __pyx_v_key = __pyx_t_1;
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":924
+ *     #   - Tries to reduce the number of calls to PyDict_GetItem, 'lazily' evaluates
+ * 
+ *     while i < length:             # <<<<<<<<<<<<<<
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]
+ */
+  while (1) {
+    __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+    if (!__pyx_t_2) break;
+
+    /* "pandas/lib/src/tseries.pyx":925
+ * 
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):             # <<<<<<<<<<<<<<
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)
+ */
+    __pyx_t_2 = (!PyDict_Contains(((PyObject *)__pyx_v_groups), __pyx_v_key));
+    if (__pyx_t_2) {
+
+      /* "pandas/lib/src/tseries.pyx":926
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]             # <<<<<<<<<<<<<<
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ */
+      __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 926; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+      __Pyx_INCREF(__pyx_v_idx);
+      PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_idx);
+      __Pyx_GIVEREF(__pyx_v_idx);
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = __pyx_t_1;
+      __pyx_t_1 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":927
+ *         if not PyDict_Contains(groups, key):
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_v_key, ((PyObject *)__pyx_v_members));
+
+      /* "pandas/lib/src/tseries.pyx":928
+ *             members = [idx]
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":929
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 idx = index[i]
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":930
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":931
+ *             curKey = key
+ *             while i < length:
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ */
+        __pyx_t_5 = __pyx_v_i;
+        if (__pyx_t_5 < 0) __pyx_t_5 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_5, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":932
+ *             while i < length:
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_1 = __pyx_f_7tseries_trycall(__pyx_v_keyfunc, __pyx_v_idx); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 932; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_t_1;
+        __pyx_t_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":933
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 933; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":934
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_6 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 934; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":935
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L12;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":937
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ */
+          goto __pyx_L11_break;
+        }
+        __pyx_L12:;
+      }
+      __pyx_L11_break:;
+      goto __pyx_L9;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":939
+ *                     break
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)             # <<<<<<<<<<<<<<
+ *             members.append(idx)
+ *             i += 1
+ */
+      __pyx_t_7 = PyDict_GetItem(((PyObject *)__pyx_v_groups), __pyx_v_key);
+      __Pyx_INCREF(((PyObject *)((PyObject *)__pyx_t_7)));
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = ((PyObject *)__pyx_t_7);
+
+      /* "pandas/lib/src/tseries.pyx":940
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(idx)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      __pyx_t_6 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 940; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+      /* "pandas/lib/src/tseries.pyx":941
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(idx)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":942
+ *             members.append(idx)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 idx = index[i]
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":943
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":944
+ *             curKey = key
+ *             while i < length:
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ */
+        __pyx_t_6 = __pyx_v_i;
+        if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":945
+ *             while i < length:
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(idx)
+ */
+        __pyx_t_1 = __pyx_f_7tseries_trycall(__pyx_v_keyfunc, __pyx_v_idx); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 945; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_t_1;
+        __pyx_t_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":946
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(idx)
+ *                     i += 1
+ */
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 946; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 946; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":947
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ *                     members.append(idx)             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_8 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_v_idx); if (unlikely(__pyx_t_8 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 947; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+
+          /* "pandas/lib/src/tseries.pyx":948
+ *                 if key == curKey:
+ *                     members.append(idx)
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L15;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":950
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *     return groups
+ */
+          goto __pyx_L14_break;
+        }
+        __pyx_L15:;
+      }
+      __pyx_L14_break:;
+    }
+    __pyx_L9:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":952
+ *                     break
+ * 
+ *     return groups             # <<<<<<<<<<<<<<
+ * 
+ * @cython.boundscheck(False)
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_groups));
+  __pyx_r = ((PyObject *)__pyx_v_groups);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.groupby");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_groups);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_curKey);
+  __Pyx_DECREF(__pyx_v_key);
+  __Pyx_DECREF(__pyx_v_members);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "pandas/lib/src/tseries.pyx":955
+ * 
+ * @cython.boundscheck(False)
+ * def groupbyfunc(ndarray[object, ndim = 1] index,             # <<<<<<<<<<<<<<
+ *                 ndarray[npy_float64, ndim = 1] values,
+ *                 object keyfunc, object applyfunc):
+ */
+
+static PyObject *__pyx_pf_7tseries_groupbyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
+static char __pyx_doc_7tseries_groupbyfunc[] = "\n    Doing this proper in Cython\n    Not sure how much it will really speed things up\n    ";
+static PyObject *__pyx_pf_7tseries_groupbyfunc(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
+  PyArrayObject *__pyx_v_index = 0;
+  PyArrayObject *__pyx_v_values = 0;
+  PyObject *__pyx_v_keyfunc = 0;
+  PyObject *__pyx_v_applyfunc = 0;
+  PyObject *__pyx_v_groups;
+  int __pyx_v_length;
+  PyObject *__pyx_v_idx;
+  PyObject *__pyx_v_curKey;
+  PyObject *__pyx_v_key;
+  PyObject *__pyx_v_members;
+  PyObject *__pyx_v_grouplist;
+  int __pyx_v_i;
+  Py_buffer __pyx_bstruct_index;
+  Py_ssize_t __pyx_bstride_0_index = 0;
+  Py_ssize_t __pyx_bshape_0_index = 0;
+  Py_buffer __pyx_bstruct_values;
+  Py_ssize_t __pyx_bstride_0_values = 0;
+  Py_ssize_t __pyx_bshape_0_values = 0;
+  PyObject *__pyx_r = NULL;
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  int __pyx_t_2;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  PyObject *__pyx_t_9;
+  int __pyx_t_10;
+  int __pyx_t_11;
+  int __pyx_t_12;
+  Py_ssize_t __pyx_t_13;
+  PyObject *__pyx_t_14 = NULL;
+  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_index,&__pyx_kp_values,&__pyx_kp_keyfunc,&__pyx_kp_applyfunc,0};
+  __Pyx_SetupRefcountContext("groupbyfunc");
+  __pyx_self = __pyx_self;
+  if (unlikely(__pyx_kwds)) {
+    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
+    PyObject* values[4] = {0,0,0,0};
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
+      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
+      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
+      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
+      case  0: break;
+      default: goto __pyx_L5_argtuple_error;
+    }
+    switch (PyTuple_GET_SIZE(__pyx_args)) {
+      case  0:
+      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_index);
+      if (likely(values[0])) kw_args--;
+      else goto __pyx_L5_argtuple_error;
+      case  1:
+      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_values);
+      if (likely(values[1])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupbyfunc", 1, 4, 4, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  2:
+      values[2] = PyDict_GetItem(__pyx_kwds, __pyx_kp_keyfunc);
+      if (likely(values[2])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupbyfunc", 1, 4, 4, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+      case  3:
+      values[3] = PyDict_GetItem(__pyx_kwds, __pyx_kp_applyfunc);
+      if (likely(values[3])) kw_args--;
+      else {
+        __Pyx_RaiseArgtupleInvalid("groupbyfunc", 1, 4, 4, 3); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+      }
+    }
+    if (unlikely(kw_args > 0)) {
+      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "groupbyfunc") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+    }
+    __pyx_v_index = ((PyArrayObject *)values[0]);
+    __pyx_v_values = ((PyArrayObject *)values[1]);
+    __pyx_v_keyfunc = values[2];
+    __pyx_v_applyfunc = values[3];
+  } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
+    goto __pyx_L5_argtuple_error;
+  } else {
+    __pyx_v_index = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 0));
+    __pyx_v_values = ((PyArrayObject *)PyTuple_GET_ITEM(__pyx_args, 1));
+    __pyx_v_keyfunc = PyTuple_GET_ITEM(__pyx_args, 2);
+    __pyx_v_applyfunc = PyTuple_GET_ITEM(__pyx_args, 3);
+  }
+  goto __pyx_L4_argument_unpacking_done;
+  __pyx_L5_argtuple_error:;
+  __Pyx_RaiseArgtupleInvalid("groupbyfunc", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
+  __pyx_L3_error:;
+  __Pyx_AddTraceback("tseries.groupbyfunc");
+  return NULL;
+  __pyx_L4_argument_unpacking_done:;
+  __pyx_v_groups = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_idx = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_curKey = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_key = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_members = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_grouplist = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_bstruct_index.buf = NULL;
+  __pyx_bstruct_values.buf = NULL;
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index), __pyx_ptype_5numpy_ndarray, 1, "index", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_values), __pyx_ptype_5numpy_ndarray, 1, "values", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 956; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_index, (PyObject*)__pyx_v_index, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_index = __pyx_bstruct_index.strides[0];
+  __pyx_bshape_0_index = __pyx_bstruct_index.shape[0];
+  {
+    __Pyx_BufFmt_StackElem __pyx_stack[1];
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_values, (PyObject*)__pyx_v_values, &__Pyx_TypeInfo_nn_npy_float64, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 955; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  }
+  __pyx_bstride_0_values = __pyx_bstruct_values.strides[0];
+  __pyx_bshape_0_values = __pyx_bstruct_values.shape[0];
+
+  /* "pandas/lib/src/tseries.pyx":963
+ *     '''
+ *     cdef dict groups
+ *     cdef int length = values.shape[0]             # <<<<<<<<<<<<<<
+ *     cdef object idx
+ *     cdef object curKey, key
+ */
+  __pyx_v_length = (__pyx_v_values->dimensions[0]);
+
+  /* "pandas/lib/src/tseries.pyx":968
+ *     cdef list members, grouplist
+ * 
+ *     groups = PyDict_New()             # <<<<<<<<<<<<<<
+ * 
+ *     if length != index.shape[0]:
+ */
+  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(PyDict_CheckExact(__pyx_t_1)) || (__pyx_t_1) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected dict, got %s", Py_TYPE(__pyx_t_1)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 968; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_groups));
+  __pyx_v_groups = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":970
+ *     groups = PyDict_New()
+ * 
+ *     if length != index.shape[0]:             # <<<<<<<<<<<<<<
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_length != (__pyx_v_index->dimensions[0]));
+  if (__pyx_t_2) {
+
+    /* "pandas/lib/src/tseries.pyx":971
+ * 
+ *     if length != index.shape[0]:
+ *         raise Exception('Dates and values were not the same length!')             # <<<<<<<<<<<<<<
+ * 
+ *     cdef int i = 0
+ */
+    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+    __Pyx_INCREF(__pyx_kp_53);
+    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_53);
+    __Pyx_GIVEREF(__pyx_kp_53);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 971; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "pandas/lib/src/tseries.pyx":973
+ *         raise Exception('Dates and values were not the same length!')
+ * 
+ *     cdef int i = 0             # <<<<<<<<<<<<<<
+ *     idx = index[i]
+ *     key = trycall(keyfunc, idx)
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":974
+ * 
+ *     cdef int i = 0
+ *     idx = index[i]             # <<<<<<<<<<<<<<
+ *     key = trycall(keyfunc, idx)
+ * 
+ */
+  __pyx_t_4 = __pyx_v_i;
+  if (__pyx_t_4 < 0) __pyx_t_4 += __pyx_bshape_0_index;
+  __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_4, __pyx_bstride_0_index);
+  __Pyx_INCREF((PyObject*)__pyx_1);
+  __Pyx_DECREF(__pyx_v_idx);
+  __pyx_v_idx = __pyx_1;
+  __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":975
+ *     cdef int i = 0
+ *     idx = index[i]
+ *     key = trycall(keyfunc, idx)             # <<<<<<<<<<<<<<
+ * 
+ *     # Algorithm notes
+ */
+  __pyx_t_3 = __pyx_f_7tseries_trycall(__pyx_v_keyfunc, __pyx_v_idx); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 975; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_v_key);
+  __pyx_v_key = __pyx_t_3;
+  __pyx_t_3 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":981
+ *     #   'lazily' evaluates
+ * 
+ *     while i < length:             # <<<<<<<<<<<<<<
+ *         if not PyDict_Contains(groups, key):
+ *             members = [values[i]]
+ */
+  while (1) {
+    __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+    if (!__pyx_t_2) break;
+
+    /* "pandas/lib/src/tseries.pyx":982
+ * 
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):             # <<<<<<<<<<<<<<
+ *             members = [values[i]]
+ *             PyDict_SetItem(groups, key, members)
+ */
+    __pyx_t_2 = (!PyDict_Contains(((PyObject *)__pyx_v_groups), __pyx_v_key));
+    if (__pyx_t_2) {
+
+      /* "pandas/lib/src/tseries.pyx":983
+ *     while i < length:
+ *         if not PyDict_Contains(groups, key):
+ *             members = [values[i]]             # <<<<<<<<<<<<<<
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ */
+      __pyx_t_5 = __pyx_v_i;
+      if (__pyx_t_5 < 0) __pyx_t_5 += __pyx_bshape_0_values;
+      __pyx_t_3 = PyFloat_FromDouble((*__Pyx_BufPtrStrided1d(npy_float64 *, __pyx_bstruct_values.buf, __pyx_t_5, __pyx_bstride_0_values))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 983; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+      PyList_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
+      __Pyx_GIVEREF(__pyx_t_3);
+      __pyx_t_3 = 0;
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = __pyx_t_1;
+      __pyx_t_1 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":984
+ *         if not PyDict_Contains(groups, key):
+ *             members = [values[i]]
+ *             PyDict_SetItem(groups, key, members)             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_v_key, ((PyObject *)__pyx_v_members));
+
+      /* "pandas/lib/src/tseries.pyx":985
+ *             members = [values[i]]
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":986
+ *             PyDict_SetItem(groups, key, members)
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 idx = index[i]
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":987
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":988
+ *             curKey = key
+ *             while i < length:
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ */
+        __pyx_t_6 = __pyx_v_i;
+        if (__pyx_t_6 < 0) __pyx_t_6 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_6, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":989
+ *             while i < length:
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(values[i])
+ */
+        __pyx_t_1 = __pyx_f_7tseries_trycall(__pyx_v_keyfunc, __pyx_v_idx); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 989; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_t_1;
+        __pyx_t_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":990
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(values[i])
+ *                     i += 1
+ */
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 990; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":991
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ *                     members.append(values[i])             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_7 = __pyx_v_i;
+          if (__pyx_t_7 < 0) __pyx_t_7 += __pyx_bshape_0_values;
+          __pyx_t_1 = PyFloat_FromDouble((*__Pyx_BufPtrStrided1d(npy_float64 *, __pyx_bstruct_values.buf, __pyx_t_7, __pyx_bstride_0_values))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 991; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __Pyx_GOTREF(__pyx_t_1);
+          __pyx_t_8 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_t_1); if (unlikely(__pyx_t_8 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 991; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+          /* "pandas/lib/src/tseries.pyx":992
+ *                 if key == curKey:
+ *                     members.append(values[i])
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L12;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":994
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ */
+          goto __pyx_L11_break;
+        }
+        __pyx_L12:;
+      }
+      __pyx_L11_break:;
+      goto __pyx_L9;
+    }
+    /*else*/ {
+
+      /* "pandas/lib/src/tseries.pyx":996
+ *                     break
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)             # <<<<<<<<<<<<<<
+ *             members.append(values[i])
+ *             i += 1
+ */
+      __pyx_t_9 = PyDict_GetItem(((PyObject *)__pyx_v_groups), __pyx_v_key);
+      __Pyx_INCREF(((PyObject *)((PyObject *)__pyx_t_9)));
+      __Pyx_DECREF(((PyObject *)__pyx_v_members));
+      __pyx_v_members = ((PyObject *)__pyx_t_9);
+
+      /* "pandas/lib/src/tseries.pyx":997
+ *         else:
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(values[i])             # <<<<<<<<<<<<<<
+ *             i += 1
+ *             curKey = key
+ */
+      __pyx_t_8 = __pyx_v_i;
+      if (__pyx_t_8 < 0) __pyx_t_8 += __pyx_bshape_0_values;
+      __pyx_t_1 = PyFloat_FromDouble((*__Pyx_BufPtrStrided1d(npy_float64 *, __pyx_bstruct_values.buf, __pyx_t_8, __pyx_bstride_0_values))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 997; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_1);
+      __pyx_t_10 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_t_1); if (unlikely(__pyx_t_10 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 997; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+      /* "pandas/lib/src/tseries.pyx":998
+ *             members = <list> PyDict_GetItem(groups, key)
+ *             members.append(values[i])
+ *             i += 1             # <<<<<<<<<<<<<<
+ *             curKey = key
+ *             while i < length:
+ */
+      __pyx_v_i += 1;
+
+      /* "pandas/lib/src/tseries.pyx":999
+ *             members.append(values[i])
+ *             i += 1
+ *             curKey = key             # <<<<<<<<<<<<<<
+ *             while i < length:
+ *                 idx = index[i]
+ */
+      __Pyx_INCREF(__pyx_v_key);
+      __Pyx_DECREF(__pyx_v_curKey);
+      __pyx_v_curKey = __pyx_v_key;
+
+      /* "pandas/lib/src/tseries.pyx":1000
+ *             i += 1
+ *             curKey = key
+ *             while i < length:             # <<<<<<<<<<<<<<
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ */
+      while (1) {
+        __pyx_t_2 = (__pyx_v_i < __pyx_v_length);
+        if (!__pyx_t_2) break;
+
+        /* "pandas/lib/src/tseries.pyx":1001
+ *             curKey = key
+ *             while i < length:
+ *                 idx = index[i]             # <<<<<<<<<<<<<<
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ */
+        __pyx_t_10 = __pyx_v_i;
+        if (__pyx_t_10 < 0) __pyx_t_10 += __pyx_bshape_0_index;
+        __pyx_1 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_index.buf, __pyx_t_10, __pyx_bstride_0_index);
+        __Pyx_INCREF((PyObject*)__pyx_1);
+        __Pyx_DECREF(__pyx_v_idx);
+        __pyx_v_idx = __pyx_1;
+        __pyx_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":1002
+ *             while i < length:
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)             # <<<<<<<<<<<<<<
+ *                 if key == curKey:
+ *                     members.append(values[i])
+ */
+        __pyx_t_1 = __pyx_f_7tseries_trycall(__pyx_v_keyfunc, __pyx_v_idx); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __Pyx_DECREF(__pyx_v_key);
+        __pyx_v_key = __pyx_t_1;
+        __pyx_t_1 = 0;
+
+        /* "pandas/lib/src/tseries.pyx":1003
+ *                 idx = index[i]
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:             # <<<<<<<<<<<<<<
+ *                     members.append(values[i])
+ *                     i += 1
+ */
+        __pyx_t_1 = PyObject_RichCompare(__pyx_v_key, __pyx_v_curKey, Py_EQ); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_1);
+        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1003; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+        if (__pyx_t_2) {
+
+          /* "pandas/lib/src/tseries.pyx":1004
+ *                 key = trycall(keyfunc, idx)
+ *                 if key == curKey:
+ *                     members.append(values[i])             # <<<<<<<<<<<<<<
+ *                     i += 1
+ *                 else:
+ */
+          __pyx_t_11 = __pyx_v_i;
+          if (__pyx_t_11 < 0) __pyx_t_11 += __pyx_bshape_0_values;
+          __pyx_t_1 = PyFloat_FromDouble((*__Pyx_BufPtrStrided1d(npy_float64 *, __pyx_bstruct_values.buf, __pyx_t_11, __pyx_bstride_0_values))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __Pyx_GOTREF(__pyx_t_1);
+          __pyx_t_12 = PyList_Append(((PyObject *)__pyx_v_members), __pyx_t_1); if (unlikely(__pyx_t_12 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1004; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+          /* "pandas/lib/src/tseries.pyx":1005
+ *                 if key == curKey:
+ *                     members.append(values[i])
+ *                     i += 1             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     break
+ */
+          __pyx_v_i += 1;
+          goto __pyx_L15;
+        }
+        /*else*/ {
+
+          /* "pandas/lib/src/tseries.pyx":1007
+ *                     i += 1
+ *                 else:
+ *                     break             # <<<<<<<<<<<<<<
+ * 
+ *     grouplist = PyDict_Keys(groups)
+ */
+          goto __pyx_L14_break;
+        }
+        __pyx_L15:;
+      }
+      __pyx_L14_break:;
+    }
+    __pyx_L9:;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":1009
+ *                     break
+ * 
+ *     grouplist = PyDict_Keys(groups)             # <<<<<<<<<<<<<<
+ * 
+ *     i = 0
+ */
+  __pyx_t_1 = PyDict_Keys(((PyObject *)__pyx_v_groups)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1009; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  if (!(likely(PyList_CheckExact(__pyx_t_1)) || (__pyx_t_1) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected list, got %s", Py_TYPE(__pyx_t_1)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1009; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(((PyObject *)__pyx_v_grouplist));
+  __pyx_v_grouplist = ((PyObject *)__pyx_t_1);
+  __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":1011
+ *     grouplist = PyDict_Keys(groups)
+ * 
+ *     i = 0             # <<<<<<<<<<<<<<
+ *     length = len(grouplist)
+ *     for i from 0 <= i < length:
+ */
+  __pyx_v_i = 0;
+
+  /* "pandas/lib/src/tseries.pyx":1012
+ * 
+ *     i = 0
+ *     length = len(grouplist)             # <<<<<<<<<<<<<<
+ *     for i from 0 <= i < length:
+ *         key = grouplist[i]
+ */
+  __pyx_t_13 = PyObject_Length(((PyObject *)__pyx_v_grouplist)); if (unlikely(__pyx_t_13 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1012; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_v_length = __pyx_t_13;
+
+  /* "pandas/lib/src/tseries.pyx":1013
+ *     i = 0
+ *     length = len(grouplist)
+ *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
+ *         key = grouplist[i]
+ *         members = <list> PyDict_GetItem(groups, key)
+ */
+  __pyx_t_12 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_12; __pyx_v_i++) {
+
+    /* "pandas/lib/src/tseries.pyx":1014
+ *     length = len(grouplist)
+ *     for i from 0 <= i < length:
+ *         key = grouplist[i]             # <<<<<<<<<<<<<<
+ *         members = <list> PyDict_GetItem(groups, key)
+ *         PyDict_SetItem(groups, key, applyfunc(np.asarray(members)))
+ */
+    __pyx_1 = __Pyx_GetItemInt_List(((PyObject *)__pyx_v_grouplist), __pyx_v_i, sizeof(int), PyInt_FromLong); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1014; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __Pyx_DECREF(__pyx_v_key);
+    __pyx_v_key = __pyx_1;
+    __pyx_1 = 0;
+
+    /* "pandas/lib/src/tseries.pyx":1015
+ *     for i from 0 <= i < length:
+ *         key = grouplist[i]
+ *         members = <list> PyDict_GetItem(groups, key)             # <<<<<<<<<<<<<<
+ *         PyDict_SetItem(groups, key, applyfunc(np.asarray(members)))
+ * 
+ */
+    __pyx_t_9 = PyDict_GetItem(((PyObject *)__pyx_v_groups), __pyx_v_key);
+    __Pyx_INCREF(((PyObject *)((PyObject *)__pyx_t_9)));
+    __Pyx_DECREF(((PyObject *)__pyx_v_members));
+    __pyx_v_members = ((PyObject *)__pyx_t_9);
+
+    /* "pandas/lib/src/tseries.pyx":1016
+ *         key = grouplist[i]
+ *         members = <list> PyDict_GetItem(groups, key)
+ *         PyDict_SetItem(groups, key, applyfunc(np.asarray(members)))             # <<<<<<<<<<<<<<
+ * 
+ *     return groups
+ */
+    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_asarray); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __Pyx_INCREF(((PyObject *)__pyx_v_members));
+    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_members));
+    __Pyx_GIVEREF(((PyObject *)__pyx_v_members));
+    __pyx_t_14 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_14);
+    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_14);
+    __Pyx_GIVEREF(__pyx_t_14);
+    __pyx_t_14 = 0;
+    __pyx_t_14 = PyObject_Call(__pyx_v_applyfunc, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_14)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1016; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_14);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    PyDict_SetItem(((PyObject *)__pyx_v_groups), __pyx_v_key, __pyx_t_14);
+    __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
+  }
+
+  /* "pandas/lib/src/tseries.pyx":1018
+ *         PyDict_SetItem(groups, key, applyfunc(np.asarray(members)))
+ * 
+ *     return groups             # <<<<<<<<<<<<<<
+ * 
+ */
+  __Pyx_XDECREF(__pyx_r);
+  __Pyx_INCREF(((PyObject *)__pyx_v_groups));
+  __pyx_r = ((PyObject *)__pyx_v_groups);
+  goto __pyx_L0;
+
+  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_14);
+  { PyObject *__pyx_type, *__pyx_value, *__pyx_tb;
+    __Pyx_ErrFetch(&__pyx_type, &__pyx_value, &__pyx_tb);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+    __Pyx_SafeReleaseBuffer(&__pyx_bstruct_values);
+  __Pyx_ErrRestore(__pyx_type, __pyx_value, __pyx_tb);}
+  __Pyx_AddTraceback("tseries.groupbyfunc");
+  __pyx_r = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_index);
+  __Pyx_SafeReleaseBuffer(&__pyx_bstruct_values);
+  __pyx_L2:;
+  __Pyx_DECREF(__pyx_v_groups);
+  __Pyx_DECREF(__pyx_v_idx);
+  __Pyx_DECREF(__pyx_v_curKey);
+  __Pyx_DECREF(__pyx_v_key);
+  __Pyx_DECREF(__pyx_v_members);
+  __Pyx_DECREF(__pyx_v_grouplist);
+  __Pyx_XGIVEREF(__pyx_r);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":65
+ *         # experimental exception made for __getbuffer__ and __releasebuffer__
+ *         # -- the details of this may change.
+ *         def __getbuffer__(ndarray self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
+ *             # This implementation of getbuffer is geared towards Cython
+ *             # requirements, and does not yet fullfill the PEP.
+ */
+
+static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
+static int __pyx_pf_5numpy_7ndarray___getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
+  int __pyx_v_copy_shape;
+  int __pyx_v_i;
+  int __pyx_v_ndim;
+  int __pyx_v_endian_detector;
+  int __pyx_v_little_endian;
+  int __pyx_v_t;
+  char *__pyx_v_f;
+  PyArray_Descr *__pyx_v_descr = 0;
+  int __pyx_v_offset;
+  int __pyx_v_hasfields;
+  int __pyx_r;
+  int __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  int __pyx_t_4;
+  int __pyx_t_5;
+  int __pyx_t_6;
+  char *__pyx_t_7;
+  __Pyx_SetupRefcountContext("__getbuffer__");
+  if (__pyx_v_info == NULL) return 0;
+  __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
+  __Pyx_GIVEREF(__pyx_v_info->obj);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":71
+ *             # of flags
+ *             cdef int copy_shape, i, ndim
+ *             cdef int endian_detector = 1             # <<<<<<<<<<<<<<
+ *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
+ * 
+ */
+  __pyx_v_endian_detector = 1;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":72
+ *             cdef int copy_shape, i, ndim
+ *             cdef int endian_detector = 1
+ *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
+ * 
+ *             ndim = PyArray_NDIM(self)
+ */
+  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":74
+ *             cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
+ * 
+ *             ndim = PyArray_NDIM(self)             # <<<<<<<<<<<<<<
+ * 
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ */
+  __pyx_v_ndim = PyArray_NDIM(((PyArrayObject *)__pyx_v_self));
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":76
+ *             ndim = PyArray_NDIM(self)
+ * 
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
+ *                 copy_shape = 1
+ *             else:
+ */
+  __pyx_t_1 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":77
+ * 
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ *                 copy_shape = 1             # <<<<<<<<<<<<<<
+ *             else:
+ *                 copy_shape = 0
+ */
+    __pyx_v_copy_shape = 1;
+    goto __pyx_L5;
+  }
+  /*else*/ {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":79
+ *                 copy_shape = 1
+ *             else:
+ *                 copy_shape = 0             # <<<<<<<<<<<<<<
+ * 
+ *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
+ */
+    __pyx_v_copy_shape = 0;
+  }
+  __pyx_L5:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":81
+ *                 copy_shape = 0
+ * 
+ *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)             # <<<<<<<<<<<<<<
+ *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 raise ValueError("ndarray is not C contiguous")
+ */
+  if (((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS)) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":82
+ * 
+ *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
+ *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("ndarray is not C contiguous")
+ * 
+ */
+    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_C_CONTIGUOUS));
+  } else {
+    __pyx_t_1 = ((__pyx_v_flags & PyBUF_C_CONTIGUOUS) == PyBUF_C_CONTIGUOUS);
+  }
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":83
+ *             if ((flags & pybuf.PyBUF_C_CONTIGUOUS == pybuf.PyBUF_C_CONTIGUOUS)
+ *                 and not PyArray_CHKFLAGS(self, NPY_C_CONTIGUOUS)):
+ *                 raise ValueError("ndarray is not C contiguous")             # <<<<<<<<<<<<<<
+ * 
+ *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
+ */
+    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+    __Pyx_INCREF(__pyx_kp_1);
+    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_1);
+    __Pyx_GIVEREF(__pyx_kp_1);
+    __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+    __Pyx_Raise(__pyx_t_3, 0, 0);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":85
+ *                 raise ValueError("ndarray is not C contiguous")
+ * 
+ *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)             # <<<<<<<<<<<<<<
+ *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 raise ValueError("ndarray is not Fortran contiguous")
+ */
+  if (((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS)) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":86
+ * 
+ *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
+ *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):             # <<<<<<<<<<<<<<
+ *                 raise ValueError("ndarray is not Fortran contiguous")
+ * 
+ */
+    __pyx_t_1 = (!PyArray_CHKFLAGS(((PyArrayObject *)__pyx_v_self), NPY_F_CONTIGUOUS));
+  } else {
+    __pyx_t_1 = ((__pyx_v_flags & PyBUF_F_CONTIGUOUS) == PyBUF_F_CONTIGUOUS);
+  }
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":87
+ *             if ((flags & pybuf.PyBUF_F_CONTIGUOUS == pybuf.PyBUF_F_CONTIGUOUS)
+ *                 and not PyArray_CHKFLAGS(self, NPY_F_CONTIGUOUS)):
+ *                 raise ValueError("ndarray is not Fortran contiguous")             # <<<<<<<<<<<<<<
+ * 
+ *             info.buf = PyArray_DATA(self)
+ */
+    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+    __Pyx_INCREF(__pyx_kp_2);
+    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_2);
+    __Pyx_GIVEREF(__pyx_kp_2);
+    __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+    __Pyx_Raise(__pyx_t_2, 0, 0);
+    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+    {__pyx_filename = __pyx_f[1]; __pyx_lineno = 87; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    goto __pyx_L7;
+  }
+  __pyx_L7:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":89
+ *                 raise ValueError("ndarray is not Fortran contiguous")
+ * 
+ *             info.buf = PyArray_DATA(self)             # <<<<<<<<<<<<<<
+ *             info.ndim = ndim
+ *             if copy_shape:
+ */
+  __pyx_v_info->buf = PyArray_DATA(((PyArrayObject *)__pyx_v_self));
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":90
+ * 
+ *             info.buf = PyArray_DATA(self)
+ *             info.ndim = ndim             # <<<<<<<<<<<<<<
+ *             if copy_shape:
+ *                 # Allocate new buffer for strides and shape info. This is allocated
+ */
+  __pyx_v_info->ndim = __pyx_v_ndim;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":91
+ *             info.buf = PyArray_DATA(self)
+ *             info.ndim = ndim
+ *             if copy_shape:             # <<<<<<<<<<<<<<
+ *                 # Allocate new buffer for strides and shape info. This is allocated
+ *                 # as one block, strides first.
+ */
+  __pyx_t_4 = __pyx_v_copy_shape;
+  if (__pyx_t_4) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":94
+ *                 # Allocate new buffer for strides and shape info. This is allocated
+ *                 # as one block, strides first.
+ *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)             # <<<<<<<<<<<<<<
+ *                 info.shape = info.strides + ndim
+ *                 for i in range(ndim):
+ */
+    __pyx_v_info->strides = ((Py_ssize_t *)malloc((((sizeof(Py_ssize_t)) * __pyx_v_ndim) * 2)));
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":95
+ *                 # as one block, strides first.
+ *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)
+ *                 info.shape = info.strides + ndim             # <<<<<<<<<<<<<<
+ *                 for i in range(ndim):
+ *                     info.strides[i] = PyArray_STRIDES(self)[i]
+ */
+    __pyx_v_info->shape = (__pyx_v_info->strides + __pyx_v_ndim);
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":96
+ *                 info.strides = <Py_ssize_t*>stdlib.malloc(sizeof(Py_ssize_t) * ndim * 2)
+ *                 info.shape = info.strides + ndim
+ *                 for i in range(ndim):             # <<<<<<<<<<<<<<
+ *                     info.strides[i] = PyArray_STRIDES(self)[i]
+ *                     info.shape[i] = PyArray_DIMS(self)[i]
+ */
+    for (__pyx_t_4 = 0; __pyx_t_4 < __pyx_v_ndim; __pyx_t_4+=1) {
+      __pyx_v_i = __pyx_t_4;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":97
+ *                 info.shape = info.strides + ndim
+ *                 for i in range(ndim):
+ *                     info.strides[i] = PyArray_STRIDES(self)[i]             # <<<<<<<<<<<<<<
+ *                     info.shape[i] = PyArray_DIMS(self)[i]
+ *             else:
+ */
+      (__pyx_v_info->strides[__pyx_v_i]) = (PyArray_STRIDES(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":98
+ *                 for i in range(ndim):
+ *                     info.strides[i] = PyArray_STRIDES(self)[i]
+ *                     info.shape[i] = PyArray_DIMS(self)[i]             # <<<<<<<<<<<<<<
+ *             else:
+ *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
+ */
+      (__pyx_v_info->shape[__pyx_v_i]) = (PyArray_DIMS(((PyArrayObject *)__pyx_v_self))[__pyx_v_i]);
+    }
+    goto __pyx_L8;
+  }
+  /*else*/ {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":100
+ *                     info.shape[i] = PyArray_DIMS(self)[i]
+ *             else:
+ *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)             # <<<<<<<<<<<<<<
+ *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
+ *             info.suboffsets = NULL
+ */
+    __pyx_v_info->strides = ((Py_ssize_t *)PyArray_STRIDES(((PyArrayObject *)__pyx_v_self)));
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":101
+ *             else:
+ *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
+ *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)             # <<<<<<<<<<<<<<
+ *             info.suboffsets = NULL
+ *             info.itemsize = PyArray_ITEMSIZE(self)
+ */
+    __pyx_v_info->shape = ((Py_ssize_t *)PyArray_DIMS(((PyArrayObject *)__pyx_v_self)));
+  }
+  __pyx_L8:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":102
+ *                 info.strides = <Py_ssize_t*>PyArray_STRIDES(self)
+ *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
+ *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
+ *             info.itemsize = PyArray_ITEMSIZE(self)
+ *             info.readonly = not PyArray_ISWRITEABLE(self)
+ */
+  __pyx_v_info->suboffsets = NULL;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":103
+ *                 info.shape = <Py_ssize_t*>PyArray_DIMS(self)
+ *             info.suboffsets = NULL
+ *             info.itemsize = PyArray_ITEMSIZE(self)             # <<<<<<<<<<<<<<
+ *             info.readonly = not PyArray_ISWRITEABLE(self)
+ * 
+ */
+  __pyx_v_info->itemsize = PyArray_ITEMSIZE(((PyArrayObject *)__pyx_v_self));
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":104
+ *             info.suboffsets = NULL
+ *             info.itemsize = PyArray_ITEMSIZE(self)
+ *             info.readonly = not PyArray_ISWRITEABLE(self)             # <<<<<<<<<<<<<<
+ * 
+ *             cdef int t
+ */
+  __pyx_v_info->readonly = (!PyArray_ISWRITEABLE(((PyArrayObject *)__pyx_v_self)));
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":107
+ * 
+ *             cdef int t
+ *             cdef char* f = NULL             # <<<<<<<<<<<<<<
+ *             cdef dtype descr = self.descr
+ *             cdef list stack
+ */
+  __pyx_v_f = NULL;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":108
+ *             cdef int t
+ *             cdef char* f = NULL
+ *             cdef dtype descr = self.descr             # <<<<<<<<<<<<<<
+ *             cdef list stack
+ *             cdef int offset
+ */
+  __Pyx_INCREF(((PyObject *)((PyArrayObject *)__pyx_v_self)->descr));
+  __pyx_v_descr = ((PyArrayObject *)__pyx_v_self)->descr;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":112
+ *             cdef int offset
+ * 
+ *             cdef bint hasfields = PyDataType_HASFIELDS(descr)             # <<<<<<<<<<<<<<
+ * 
+ *             if not hasfields and not copy_shape:
+ */
+  __pyx_v_hasfields = PyDataType_HASFIELDS(__pyx_v_descr);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":114
+ *             cdef bint hasfields = PyDataType_HASFIELDS(descr)
+ * 
+ *             if not hasfields and not copy_shape:             # <<<<<<<<<<<<<<
+ *                 # do not call releasebuffer
+ *                 info.obj = None
+ */
+  if ((!__pyx_v_hasfields)) {
+    __pyx_t_1 = (!__pyx_v_copy_shape);
+  } else {
+    __pyx_t_1 = (!__pyx_v_hasfields);
+  }
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":116
+ *             if not hasfields and not copy_shape:
+ *                 # do not call releasebuffer
+ *                 info.obj = None             # <<<<<<<<<<<<<<
+ *             else:
+ *                 # need to call releasebuffer
+ */
+    __Pyx_INCREF(Py_None);
+    __Pyx_GIVEREF(Py_None);
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj);
+    __pyx_v_info->obj = Py_None;
+    goto __pyx_L11;
+  }
+  /*else*/ {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":119
+ *             else:
+ *                 # need to call releasebuffer
+ *                 info.obj = self             # <<<<<<<<<<<<<<
+ * 
+ *             if not hasfields:
+ */
+    __Pyx_INCREF(__pyx_v_self);
+    __Pyx_GIVEREF(__pyx_v_self);
+    __Pyx_GOTREF(__pyx_v_info->obj);
+    __Pyx_DECREF(__pyx_v_info->obj);
+    __pyx_v_info->obj = __pyx_v_self;
+  }
+  __pyx_L11:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":121
+ *                 info.obj = self
+ * 
+ *             if not hasfields:             # <<<<<<<<<<<<<<
+ *                 t = descr.type_num
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ */
+  __pyx_t_1 = (!__pyx_v_hasfields);
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":122
+ * 
+ *             if not hasfields:
+ *                 t = descr.type_num             # <<<<<<<<<<<<<<
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
+ */
+    __pyx_v_t = __pyx_v_descr->type_num;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":123
+ *             if not hasfields:
+ *                 t = descr.type_num
+ *                 if ((descr.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *                     (descr.byteorder == '<' and not little_endian)):
+ *                     raise ValueError("Non-native byte order not supported")
+ */
+    if ((__pyx_v_descr->byteorder == '>')) {
+      __pyx_t_1 = __pyx_v_little_endian;
+    } else {
+      __pyx_t_1 = (__pyx_v_descr->byteorder == '>');
+    }
+    if (!__pyx_t_1) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":124
+ *                 t = descr.type_num
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *                     raise ValueError("Non-native byte order not supported")
+ *                 if   t == NPY_BYTE:        f = "b"
+ */
+      if ((__pyx_v_descr->byteorder == '<')) {
+        __pyx_t_5 = (!__pyx_v_little_endian);
+      } else {
+        __pyx_t_5 = (__pyx_v_descr->byteorder == '<');
+      }
+      __pyx_t_6 = __pyx_t_5;
+    } else {
+      __pyx_t_6 = __pyx_t_1;
+    }
+    if (__pyx_t_6) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":125
+ *                 if ((descr.byteorder == '>' and little_endian) or
+ *                     (descr.byteorder == '<' and not little_endian)):
+ *                     raise ValueError("Non-native byte order not supported")             # <<<<<<<<<<<<<<
+ *                 if   t == NPY_BYTE:        f = "b"
+ *                 elif t == NPY_UBYTE:       f = "B"
+ */
+      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
+      __Pyx_INCREF(__pyx_kp_5);
+      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_5);
+      __Pyx_GIVEREF(__pyx_kp_5);
+      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
+      __Pyx_Raise(__pyx_t_3, 0, 0);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 125; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L13;
+    }
+    __pyx_L13:;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":126
+ *                     (descr.byteorder == '<' and not little_endian)):
+ *                     raise ValueError("Non-native byte order not supported")
+ *                 if   t == NPY_BYTE:        f = "b"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_UBYTE:       f = "B"
+ *                 elif t == NPY_SHORT:       f = "h"
+ */
+    switch (__pyx_v_t) {
+      case NPY_BYTE:
+      __pyx_v_f = __pyx_k_6;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":127
+ *                     raise ValueError("Non-native byte order not supported")
+ *                 if   t == NPY_BYTE:        f = "b"
+ *                 elif t == NPY_UBYTE:       f = "B"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_SHORT:       f = "h"
+ *                 elif t == NPY_USHORT:      f = "H"
+ */
+      case NPY_UBYTE:
+      __pyx_v_f = __pyx_k_7;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":128
+ *                 if   t == NPY_BYTE:        f = "b"
+ *                 elif t == NPY_UBYTE:       f = "B"
+ *                 elif t == NPY_SHORT:       f = "h"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_USHORT:      f = "H"
+ *                 elif t == NPY_INT:         f = "i"
+ */
+      case NPY_SHORT:
+      __pyx_v_f = __pyx_k_8;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":129
+ *                 elif t == NPY_UBYTE:       f = "B"
+ *                 elif t == NPY_SHORT:       f = "h"
+ *                 elif t == NPY_USHORT:      f = "H"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_INT:         f = "i"
+ *                 elif t == NPY_UINT:        f = "I"
+ */
+      case NPY_USHORT:
+      __pyx_v_f = __pyx_k_9;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":130
+ *                 elif t == NPY_SHORT:       f = "h"
+ *                 elif t == NPY_USHORT:      f = "H"
+ *                 elif t == NPY_INT:         f = "i"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_UINT:        f = "I"
+ *                 elif t == NPY_LONG:        f = "l"
+ */
+      case NPY_INT:
+      __pyx_v_f = __pyx_k_10;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":131
+ *                 elif t == NPY_USHORT:      f = "H"
+ *                 elif t == NPY_INT:         f = "i"
+ *                 elif t == NPY_UINT:        f = "I"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_LONG:        f = "l"
+ *                 elif t == NPY_ULONG:       f = "L"
+ */
+      case NPY_UINT:
+      __pyx_v_f = __pyx_k_11;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":132
+ *                 elif t == NPY_INT:         f = "i"
+ *                 elif t == NPY_UINT:        f = "I"
+ *                 elif t == NPY_LONG:        f = "l"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_ULONG:       f = "L"
+ *                 elif t == NPY_LONGLONG:    f = "q"
+ */
+      case NPY_LONG:
+      __pyx_v_f = __pyx_k_12;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":133
+ *                 elif t == NPY_UINT:        f = "I"
+ *                 elif t == NPY_LONG:        f = "l"
+ *                 elif t == NPY_ULONG:       f = "L"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_LONGLONG:    f = "q"
+ *                 elif t == NPY_ULONGLONG:   f = "Q"
+ */
+      case NPY_ULONG:
+      __pyx_v_f = __pyx_k_13;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":134
+ *                 elif t == NPY_LONG:        f = "l"
+ *                 elif t == NPY_ULONG:       f = "L"
+ *                 elif t == NPY_LONGLONG:    f = "q"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_ULONGLONG:   f = "Q"
+ *                 elif t == NPY_FLOAT:       f = "f"
+ */
+      case NPY_LONGLONG:
+      __pyx_v_f = __pyx_k_14;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":135
+ *                 elif t == NPY_ULONG:       f = "L"
+ *                 elif t == NPY_LONGLONG:    f = "q"
+ *                 elif t == NPY_ULONGLONG:   f = "Q"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_FLOAT:       f = "f"
+ *                 elif t == NPY_DOUBLE:      f = "d"
+ */
+      case NPY_ULONGLONG:
+      __pyx_v_f = __pyx_k_15;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":136
+ *                 elif t == NPY_LONGLONG:    f = "q"
+ *                 elif t == NPY_ULONGLONG:   f = "Q"
+ *                 elif t == NPY_FLOAT:       f = "f"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_DOUBLE:      f = "d"
+ *                 elif t == NPY_LONGDOUBLE:  f = "g"
+ */
+      case NPY_FLOAT:
+      __pyx_v_f = __pyx_k_16;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":137
+ *                 elif t == NPY_ULONGLONG:   f = "Q"
+ *                 elif t == NPY_FLOAT:       f = "f"
+ *                 elif t == NPY_DOUBLE:      f = "d"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_LONGDOUBLE:  f = "g"
+ *                 elif t == NPY_CFLOAT:      f = "Zf"
+ */
+      case NPY_DOUBLE:
+      __pyx_v_f = __pyx_k_17;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":138
+ *                 elif t == NPY_FLOAT:       f = "f"
+ *                 elif t == NPY_DOUBLE:      f = "d"
+ *                 elif t == NPY_LONGDOUBLE:  f = "g"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_CFLOAT:      f = "Zf"
+ *                 elif t == NPY_CDOUBLE:     f = "Zd"
+ */
+      case NPY_LONGDOUBLE:
+      __pyx_v_f = __pyx_k_18;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":139
+ *                 elif t == NPY_DOUBLE:      f = "d"
+ *                 elif t == NPY_LONGDOUBLE:  f = "g"
+ *                 elif t == NPY_CFLOAT:      f = "Zf"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_CDOUBLE:     f = "Zd"
+ *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
+ */
+      case NPY_CFLOAT:
+      __pyx_v_f = __pyx_k_19;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":140
+ *                 elif t == NPY_LONGDOUBLE:  f = "g"
+ *                 elif t == NPY_CFLOAT:      f = "Zf"
+ *                 elif t == NPY_CDOUBLE:     f = "Zd"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
+ *                 elif t == NPY_OBJECT:      f = "O"
+ */
+      case NPY_CDOUBLE:
+      __pyx_v_f = __pyx_k_20;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":141
+ *                 elif t == NPY_CFLOAT:      f = "Zf"
+ *                 elif t == NPY_CDOUBLE:     f = "Zd"
+ *                 elif t == NPY_CLONGDOUBLE: f = "Zg"             # <<<<<<<<<<<<<<
+ *                 elif t == NPY_OBJECT:      f = "O"
+ *                 else:
+ */
+      case NPY_CLONGDOUBLE:
+      __pyx_v_f = __pyx_k_21;
+      break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":142
+ *                 elif t == NPY_CDOUBLE:     f = "Zd"
+ *                 elif t == NPY_CLONGDOUBLE: f = "Zg"
+ *                 elif t == NPY_OBJECT:      f = "O"             # <<<<<<<<<<<<<<
+ *                 else:
+ *                     raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)
+ */
+      case NPY_OBJECT:
+      __pyx_v_f = __pyx_k_22;
+      break;
+      default:
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":144
+ *                 elif t == NPY_OBJECT:      f = "O"
+ *                 else:
+ *                     raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
+ *                 info.format = f
+ *                 return
+ */
+      __pyx_t_3 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_3);
+      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_23, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
+      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
+      __Pyx_GIVEREF(__pyx_t_2);
+      __pyx_t_2 = 0;
+      __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_2);
+      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
+      __Pyx_Raise(__pyx_t_2, 0, 0);
+      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      break;
+    }
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":145
+ *                 else:
+ *                     raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)
+ *                 info.format = f             # <<<<<<<<<<<<<<
+ *                 return
+ *             else:
+ */
+    __pyx_v_info->format = __pyx_v_f;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":146
+ *                     raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)
+ *                 info.format = f
+ *                 return             # <<<<<<<<<<<<<<
+ *             else:
+ *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
+ */
+    __pyx_r = 0;
+    goto __pyx_L0;
+    goto __pyx_L12;
+  }
+  /*else*/ {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":148
+ *                 return
+ *             else:
+ *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)             # <<<<<<<<<<<<<<
+ *                 info.format[0] = '^' # Native data types, manual alignment
+ *                 offset = 0
+ */
+    __pyx_v_info->format = ((char *)malloc(255));
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":149
+ *             else:
+ *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
+ *                 info.format[0] = '^' # Native data types, manual alignment             # <<<<<<<<<<<<<<
+ *                 offset = 0
+ *                 f = _util_dtypestring(descr, info.format + 1,
+ */
+    (__pyx_v_info->format[0]) = '^';
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":150
+ *                 info.format = <char*>stdlib.malloc(_buffer_format_string_len)
+ *                 info.format[0] = '^' # Native data types, manual alignment
+ *                 offset = 0             # <<<<<<<<<<<<<<
+ *                 f = _util_dtypestring(descr, info.format + 1,
+ *                                       info.format + _buffer_format_string_len,
+ */
+    __pyx_v_offset = 0;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":153
+ *                 f = _util_dtypestring(descr, info.format + 1,
+ *                                       info.format + _buffer_format_string_len,
+ *                                       &offset)             # <<<<<<<<<<<<<<
+ *                 f[0] = 0 # Terminate format string
+ * 
+ */
+    __pyx_t_7 = __pyx_f_5numpy__util_dtypestring(__pyx_v_descr, (__pyx_v_info->format + 1), (__pyx_v_info->format + 255), (&__pyx_v_offset)); if (unlikely(__pyx_t_7 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_v_f = __pyx_t_7;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":154
+ *                                       info.format + _buffer_format_string_len,
+ *                                       &offset)
+ *                 f[0] = 0 # Terminate format string             # <<<<<<<<<<<<<<
+ * 
+ *         def __releasebuffer__(ndarray self, Py_buffer* info):
+ */
+    (__pyx_v_f[0]) = 0;
+  }
+  __pyx_L12:;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_AddTraceback("numpy.ndarray.__getbuffer__");
+  __pyx_r = -1;
+  __Pyx_GOTREF(__pyx_v_info->obj);
+  __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
+  goto __pyx_L2;
+  __pyx_L0:;
+  if (__pyx_v_info->obj == Py_None) {
+    __Pyx_GOTREF(Py_None);
+    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
+  }
+  __pyx_L2:;
+  __Pyx_XDECREF((PyObject *)__pyx_v_descr);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+/* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":156
+ *                 f[0] = 0 # Terminate format string
+ * 
+ *         def __releasebuffer__(ndarray self, Py_buffer* info):             # <<<<<<<<<<<<<<
+ *             if PyArray_HASFIELDS(self):
+ *                 stdlib.free(info.format)
+ */
+
+static void __pyx_pf_5numpy_7ndarray___releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
+static void __pyx_pf_5numpy_7ndarray___releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
+  int __pyx_t_1;
+  int __pyx_t_2;
+  __Pyx_SetupRefcountContext("__releasebuffer__");
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":157
+ * 
+ *         def __releasebuffer__(ndarray self, Py_buffer* info):
+ *             if PyArray_HASFIELDS(self):             # <<<<<<<<<<<<<<
+ *                 stdlib.free(info.format)
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ */
+  __pyx_t_1 = PyArray_HASFIELDS(((PyArrayObject *)__pyx_v_self));
+  if (__pyx_t_1) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":158
+ *         def __releasebuffer__(ndarray self, Py_buffer* info):
+ *             if PyArray_HASFIELDS(self):
+ *                 stdlib.free(info.format)             # <<<<<<<<<<<<<<
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ *                 stdlib.free(info.strides)
+ */
+    free(__pyx_v_info->format);
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":159
+ *             if PyArray_HASFIELDS(self):
+ *                 stdlib.free(info.format)
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):             # <<<<<<<<<<<<<<
+ *                 stdlib.free(info.strides)
+ *                 # info.shape was stored after info.strides in the same block
+ */
+  __pyx_t_2 = ((sizeof(npy_intp)) != (sizeof(Py_ssize_t)));
+  if (__pyx_t_2) {
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":160
+ *                 stdlib.free(info.format)
+ *             if sizeof(npy_intp) != sizeof(Py_ssize_t):
+ *                 stdlib.free(info.strides)             # <<<<<<<<<<<<<<
+ *                 # info.shape was stored after info.strides in the same block
+ * 
+ */
+    free(__pyx_v_info->strides);
+    goto __pyx_L6;
+  }
+  __pyx_L6:;
+
+  __Pyx_FinishRefcountContext();
+}
+
+/* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":277
+ * ctypedef npy_cdouble     complex_t
+ * 
+ * cdef inline char* _util_dtypestring(dtype descr, char* f, char* end, int* offset) except NULL:             # <<<<<<<<<<<<<<
+ *     # Recursive utility function used in __getbuffer__ to get format
+ *     # string. The new location in the format string is returned.
+ */
+
+static INLINE char *__pyx_f_5numpy__util_dtypestring(PyArray_Descr *__pyx_v_descr, char *__pyx_v_f, char *__pyx_v_end, int *__pyx_v_offset) {
+  PyArray_Descr *__pyx_v_child;
+  PyObject *__pyx_v_i;
+  int __pyx_v_endian_detector;
+  int __pyx_v_little_endian;
+  PyObject *__pyx_v_new_offset;
+  PyObject *__pyx_v_t;
+  char *__pyx_r;
+  PyObject *__pyx_1 = 0;
+  Py_ssize_t __pyx_t_1;
+  PyObject *__pyx_t_2 = NULL;
+  PyObject *__pyx_t_3 = NULL;
+  PyObject *__pyx_t_4 = NULL;
+  PyObject *__pyx_t_5 = NULL;
+  int __pyx_t_6;
+  int __pyx_t_7;
+  int __pyx_t_8;
+  char *__pyx_t_9;
+  __Pyx_SetupRefcountContext("_util_dtypestring");
+  __pyx_v_child = ((PyArray_Descr *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_i = ((PyObject *)Py_None); __Pyx_INCREF(Py_None);
+  __pyx_v_new_offset = Py_None; __Pyx_INCREF(Py_None);
+  __pyx_v_t = Py_None; __Pyx_INCREF(Py_None);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":284
+ *     cdef int delta_offset
+ *     cdef tuple i
+ *     cdef int endian_detector = 1             # <<<<<<<<<<<<<<
+ *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
+ * 
+ */
+  __pyx_v_endian_detector = 1;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":285
+ *     cdef tuple i
+ *     cdef int endian_detector = 1
+ *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)             # <<<<<<<<<<<<<<
+ * 
+ *     for i in descr.fields.itervalues():
+ */
+  __pyx_v_little_endian = ((((char *)(&__pyx_v_endian_detector))[0]) != 0);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":287
+ *     cdef bint little_endian = ((<char*>&endian_detector)[0] != 0)
+ * 
+ *     for i in descr.fields.itervalues():             # <<<<<<<<<<<<<<
+ *         child = i[0]
+ *         new_offset = i[1]
+ */
+  __pyx_t_2 = PyObject_GetAttr(__pyx_v_descr->fields, __pyx_kp_itervalues); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_2);
+  __pyx_t_3 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_3);
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+  if (PyList_CheckExact(__pyx_t_3) || PyTuple_CheckExact(__pyx_t_3)) {
+    __pyx_t_1 = 0; __pyx_t_2 = __pyx_t_3; __Pyx_INCREF(__pyx_t_2);
+  } else {
+    __pyx_t_1 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_2);
+  }
+  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+  for (;;) {
+    if (likely(PyList_CheckExact(__pyx_t_2))) {
+      if (__pyx_t_1 >= PyList_GET_SIZE(__pyx_t_2)) break;
+      __pyx_t_3 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_1); __Pyx_INCREF(__pyx_t_3); __pyx_t_1++;
+    } else if (likely(PyTuple_CheckExact(__pyx_t_2))) {
+      if (__pyx_t_1 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
+      __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_1); __Pyx_INCREF(__pyx_t_3); __pyx_t_1++;
+    } else {
+      __pyx_t_3 = PyIter_Next(__pyx_t_2);
+      if (!__pyx_t_3) {
+        if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        break;
+      }
+      __Pyx_GOTREF(__pyx_t_3);
+    }
+    if (!(likely(PyTuple_CheckExact(__pyx_t_3)) || (__pyx_t_3) == Py_None || (PyErr_Format(PyExc_TypeError, "Expected tuple, got %s", Py_TYPE(__pyx_t_3)->tp_name), 0))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_v_i));
+    __pyx_v_i = ((PyObject *)__pyx_t_3);
+    __pyx_t_3 = 0;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":288
+ * 
+ *     for i in descr.fields.itervalues():
+ *         child = i[0]             # <<<<<<<<<<<<<<
+ *         new_offset = i[1]
+ * 
+ */
+    __pyx_1 = __Pyx_GetItemInt_Tuple(((PyObject *)__pyx_v_i), 0, sizeof(long), PyInt_FromLong); if (!__pyx_1) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    if (!(__Pyx_TypeTest(__pyx_1, __pyx_ptype_5numpy_dtype))) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(((PyObject *)__pyx_v_child));
+    __pyx_v_child = ((PyArray_Descr *)__pyx_1);
+    __pyx_1 = 0;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":289
+ *     for i in descr.fields.itervalues():
+ *         child = i[0]
+ *         new_offset = i[1]             # <<<<<<<<<<<<<<
+ * 
+ *         if (end - f) - (new_offset - offset[0]) < 15:
+ */
+    __pyx_1 = __Pyx_GetItemInt_Tuple(((PyObject *)__pyx_v_i), 1, sizeof(long), PyInt_FromLong); if (!__pyx_1) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 289; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_1);
+    __Pyx_DECREF(__pyx_v_new_offset);
+    __pyx_v_new_offset = __pyx_1;
+    __pyx_1 = 0;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":291
+ *         new_offset = i[1]
+ * 
+ *         if (end - f) - (new_offset - offset[0]) < 15:             # <<<<<<<<<<<<<<
+ *             raise RuntimeError("Format string allocated too short, see comment in numpy.pxd")
+ * 
+ */
+    __pyx_t_3 = PyInt_FromLong((__pyx_v_end - __pyx_v_f)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_3);
+    __pyx_t_4 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __pyx_t_5 = PyNumber_Subtract(__pyx_v_new_offset, __pyx_t_4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_4 = PyNumber_Subtract(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_4);
+    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_int_15, Py_LT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_5);
+    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 291; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+    if (__pyx_t_6) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":292
+ * 
+ *         if (end - f) - (new_offset - offset[0]) < 15:
+ *             raise RuntimeError("Format string allocated too short, see comment in numpy.pxd")             # <<<<<<<<<<<<<<
+ * 
+ *         if ((child.byteorder == '>' and little_endian) or
+ */
+      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+      __Pyx_INCREF(__pyx_kp_25);
+      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_25);
+      __Pyx_GIVEREF(__pyx_kp_25);
+      __pyx_t_4 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+      __Pyx_Raise(__pyx_t_4, 0, 0);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L5;
+    }
+    __pyx_L5:;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":294
+ *             raise RuntimeError("Format string allocated too short, see comment in numpy.pxd")
+ * 
+ *         if ((child.byteorder == '>' and little_endian) or             # <<<<<<<<<<<<<<
+ *             (child.byteorder == '<' and not little_endian)):
+ *             raise ValueError("Non-native byte order not supported")
+ */
+    if ((__pyx_v_child->byteorder == '>')) {
+      __pyx_t_6 = __pyx_v_little_endian;
+    } else {
+      __pyx_t_6 = (__pyx_v_child->byteorder == '>');
+    }
+    if (!__pyx_t_6) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":295
+ * 
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):             # <<<<<<<<<<<<<<
+ *             raise ValueError("Non-native byte order not supported")
+ *             # One could encode it in the format string and have Cython
+ */
+      if ((__pyx_v_child->byteorder == '<')) {
+        __pyx_t_7 = (!__pyx_v_little_endian);
+      } else {
+        __pyx_t_7 = (__pyx_v_child->byteorder == '<');
+      }
+      __pyx_t_8 = __pyx_t_7;
+    } else {
+      __pyx_t_8 = __pyx_t_6;
+    }
+    if (__pyx_t_8) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":296
+ *         if ((child.byteorder == '>' and little_endian) or
+ *             (child.byteorder == '<' and not little_endian)):
+ *             raise ValueError("Non-native byte order not supported")             # <<<<<<<<<<<<<<
+ *             # One could encode it in the format string and have Cython
+ *             # complain instead, BUT: < and > in format strings also imply
+ */
+      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+      __Pyx_INCREF(__pyx_kp_28);
+      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_28);
+      __Pyx_GIVEREF(__pyx_kp_28);
+      __pyx_t_5 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+      __Pyx_Raise(__pyx_t_5, 0, 0);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      {__pyx_filename = __pyx_f[1]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      goto __pyx_L6;
+    }
+    __pyx_L6:;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":306
+ * 
+ *         # Output padding bytes
+ *         while offset[0] < new_offset:             # <<<<<<<<<<<<<<
+ *             f[0] = 120 # "x"; pad byte
+ *             f += 1
+ */
+    while (1) {
+      __pyx_t_5 = PyInt_FromLong((__pyx_v_offset[0])); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_t_5, __pyx_v_new_offset, Py_LT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (!__pyx_t_8) break;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":307
+ *         # Output padding bytes
+ *         while offset[0] < new_offset:
+ *             f[0] = 120 # "x"; pad byte             # <<<<<<<<<<<<<<
+ *             f += 1
+ *             offset[0] += 1
+ */
+      (__pyx_v_f[0]) = 120;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":308
+ *         while offset[0] < new_offset:
+ *             f[0] = 120 # "x"; pad byte
+ *             f += 1             # <<<<<<<<<<<<<<
+ *             offset[0] += 1
+ * 
+ */
+      __pyx_v_f += 1;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":309
+ *             f[0] = 120 # "x"; pad byte
+ *             f += 1
+ *             offset[0] += 1             # <<<<<<<<<<<<<<
+ * 
+ *         offset[0] += child.itemsize
+ */
+      (__pyx_v_offset[0]) += 1;
+    }
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":311
+ *             offset[0] += 1
+ * 
+ *         offset[0] += child.itemsize             # <<<<<<<<<<<<<<
+ * 
+ *         if not PyDataType_HASFIELDS(child):
+ */
+    (__pyx_v_offset[0]) += __pyx_v_child->elsize;
+
+    /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":313
+ *         offset[0] += child.itemsize
+ * 
+ *         if not PyDataType_HASFIELDS(child):             # <<<<<<<<<<<<<<
+ *             t = child.type_num
+ *             if end - f < 5:
+ */
+    __pyx_t_8 = (!PyDataType_HASFIELDS(__pyx_v_child));
+    if (__pyx_t_8) {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":314
+ * 
+ *         if not PyDataType_HASFIELDS(child):
+ *             t = child.type_num             # <<<<<<<<<<<<<<
+ *             if end - f < 5:
+ *                 raise RuntimeError("Format string allocated too short.")
+ */
+      __pyx_t_4 = PyInt_FromLong(__pyx_v_child->type_num); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_v_t);
+      __pyx_v_t = __pyx_t_4;
+      __pyx_t_4 = 0;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":315
+ *         if not PyDataType_HASFIELDS(child):
+ *             t = child.type_num
+ *             if end - f < 5:             # <<<<<<<<<<<<<<
+ *                 raise RuntimeError("Format string allocated too short.")
+ * 
+ */
+      __pyx_t_8 = ((__pyx_v_end - __pyx_v_f) < 5);
+      if (__pyx_t_8) {
+
+        /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":316
+ *             t = child.type_num
+ *             if end - f < 5:
+ *                 raise RuntimeError("Format string allocated too short.")             # <<<<<<<<<<<<<<
+ * 
+ *             # Until ticket #99 is fixed, use integers to avoid warnings
+ */
+        __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_4));
+        __Pyx_INCREF(__pyx_kp_29);
+        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_29);
+        __Pyx_GIVEREF(__pyx_kp_29);
+        __pyx_t_5 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_5);
+        __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
+        __Pyx_Raise(__pyx_t_5, 0, 0);
+        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        goto __pyx_L10;
+      }
+      __pyx_L10:;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":319
+ * 
+ *             # Until ticket #99 is fixed, use integers to avoid warnings
+ *             if   t == NPY_BYTE:        f[0] =  98 #"b"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
+ *             elif t == NPY_SHORT:       f[0] = 104 #"h"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_BYTE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 98;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":320
+ *             # Until ticket #99 is fixed, use integers to avoid warnings
+ *             if   t == NPY_BYTE:        f[0] =  98 #"b"
+ *             elif t == NPY_UBYTE:       f[0] =  66 #"B"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_SHORT:       f[0] = 104 #"h"
+ *             elif t == NPY_USHORT:      f[0] =  72 #"H"
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_UBYTE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 320; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 66;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":321
+ *             if   t == NPY_BYTE:        f[0] =  98 #"b"
+ *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
+ *             elif t == NPY_SHORT:       f[0] = 104 #"h"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_USHORT:      f[0] =  72 #"H"
+ *             elif t == NPY_INT:         f[0] = 105 #"i"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_SHORT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 104;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":322
+ *             elif t == NPY_UBYTE:       f[0] =  66 #"B"
+ *             elif t == NPY_SHORT:       f[0] = 104 #"h"
+ *             elif t == NPY_USHORT:      f[0] =  72 #"H"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_INT:         f[0] = 105 #"i"
+ *             elif t == NPY_UINT:        f[0] =  73 #"I"
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_USHORT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 322; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 72;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":323
+ *             elif t == NPY_SHORT:       f[0] = 104 #"h"
+ *             elif t == NPY_USHORT:      f[0] =  72 #"H"
+ *             elif t == NPY_INT:         f[0] = 105 #"i"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_UINT:        f[0] =  73 #"I"
+ *             elif t == NPY_LONG:        f[0] = 108 #"l"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_INT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 105;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":324
+ *             elif t == NPY_USHORT:      f[0] =  72 #"H"
+ *             elif t == NPY_INT:         f[0] = 105 #"i"
+ *             elif t == NPY_UINT:        f[0] =  73 #"I"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_LONG:        f[0] = 108 #"l"
+ *             elif t == NPY_ULONG:       f[0] = 76  #"L"
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_UINT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 324; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 73;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":325
+ *             elif t == NPY_INT:         f[0] = 105 #"i"
+ *             elif t == NPY_UINT:        f[0] =  73 #"I"
+ *             elif t == NPY_LONG:        f[0] = 108 #"l"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_ULONG:       f[0] = 76  #"L"
+ *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_LONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 108;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":326
+ *             elif t == NPY_UINT:        f[0] =  73 #"I"
+ *             elif t == NPY_LONG:        f[0] = 108 #"l"
+ *             elif t == NPY_ULONG:       f[0] = 76  #"L"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
+ *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_ULONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 326; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 76;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":327
+ *             elif t == NPY_LONG:        f[0] = 108 #"l"
+ *             elif t == NPY_ULONG:       f[0] = 76  #"L"
+ *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
+ *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_LONGLONG); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 327; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 113;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":328
+ *             elif t == NPY_ULONG:       f[0] = 76  #"L"
+ *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
+ *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
+ *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_ULONGLONG); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 328; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 81;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":329
+ *             elif t == NPY_LONGLONG:    f[0] = 113 #"q"
+ *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
+ *             elif t == NPY_FLOAT:       f[0] = 102 #"f"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
+ *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_FLOAT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 329; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 102;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":330
+ *             elif t == NPY_ULONGLONG:   f[0] = 81  #"Q"
+ *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
+ *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
+ *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_DOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 100;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":331
+ *             elif t == NPY_FLOAT:       f[0] = 102 #"f"
+ *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
+ *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"             # <<<<<<<<<<<<<<
+ *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
+ *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_LONGDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 103;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":332
+ *             elif t == NPY_DOUBLE:      f[0] = 100 #"d"
+ *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
+ *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf             # <<<<<<<<<<<<<<
+ *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
+ *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_CFLOAT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 90;
+        (__pyx_v_f[1]) = 102;
+        __pyx_v_f += 1;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":333
+ *             elif t == NPY_LONGDOUBLE:  f[0] = 103 #"g"
+ *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
+ *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd             # <<<<<<<<<<<<<<
+ *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
+ *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_CDOUBLE); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 90;
+        (__pyx_v_f[1]) = 100;
+        __pyx_v_f += 1;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":334
+ *             elif t == NPY_CFLOAT:      f[0] = 90; f[1] = 102; f += 1 # Zf
+ *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
+ *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg             # <<<<<<<<<<<<<<
+ *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
+ *             else:
+ */
+      __pyx_t_4 = PyInt_FromLong(NPY_CLONGDOUBLE); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __pyx_t_5 = PyObject_RichCompare(__pyx_v_t, __pyx_t_4, Py_EQ); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 90;
+        (__pyx_v_f[1]) = 103;
+        __pyx_v_f += 1;
+        goto __pyx_L11;
+      }
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":335
+ *             elif t == NPY_CDOUBLE:     f[0] = 90; f[1] = 100; f += 1 # Zd
+ *             elif t == NPY_CLONGDOUBLE: f[0] = 90; f[1] = 103; f += 1 # Zg
+ *             elif t == NPY_OBJECT:      f[0] = 79 #"O"             # <<<<<<<<<<<<<<
+ *             else:
+ *                 raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)
+ */
+      __pyx_t_5 = PyInt_FromLong(NPY_OBJECT); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_5);
+      __pyx_t_4 = PyObject_RichCompare(__pyx_v_t, __pyx_t_5, Py_EQ); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_GOTREF(__pyx_t_4);
+      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
+      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_8 < 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+      if (__pyx_t_8) {
+        (__pyx_v_f[0]) = 79;
+        goto __pyx_L11;
+      }
+      /*else*/ {
+
+        /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":337
+ *             elif t == NPY_OBJECT:      f[0] = 79 #"O"
+ *             else:
+ *                 raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)             # <<<<<<<<<<<<<<
+ *             f += 1
+ *         else:
+ */
+        __pyx_t_4 = PyNumber_Remainder(__pyx_kp_30, __pyx_v_t); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(((PyObject *)__pyx_t_5));
+        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
+        __Pyx_GIVEREF(__pyx_t_4);
+        __pyx_t_4 = 0;
+        __pyx_t_4 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+        __Pyx_GOTREF(__pyx_t_4);
+        __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
+        __Pyx_Raise(__pyx_t_4, 0, 0);
+        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
+        {__pyx_filename = __pyx_f[1]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      }
+      __pyx_L11:;
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":338
+ *             else:
+ *                 raise ValueError("unknown dtype code in numpy.pxd (%d)" % t)
+ *             f += 1             # <<<<<<<<<<<<<<
+ *         else:
+ *             # Cython ignores struct boundary information ("T{...}"),
+ */
+      __pyx_v_f += 1;
+      goto __pyx_L9;
+    }
+    /*else*/ {
+
+      /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":342
+ *             # Cython ignores struct boundary information ("T{...}"),
+ *             # so don't output it
+ *             f = _util_dtypestring(child, f, end, offset)             # <<<<<<<<<<<<<<
+ *     return f
+ * 
+ */
+      __pyx_t_9 = __pyx_f_5numpy__util_dtypestring(__pyx_v_child, __pyx_v_f, __pyx_v_end, __pyx_v_offset); if (unlikely(__pyx_t_9 == NULL)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_v_f = __pyx_t_9;
+    }
+    __pyx_L9:;
+  }
+  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/numpy.pxd":343
+ *             # so don't output it
+ *             f = _util_dtypestring(child, f, end, offset)
+ *     return f             # <<<<<<<<<<<<<<
+ * 
+ */
+  __pyx_r = __pyx_v_f;
+  goto __pyx_L0;
+
+  __pyx_r = 0;
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_t_2);
+  __Pyx_XDECREF(__pyx_t_3);
+  __Pyx_XDECREF(__pyx_t_4);
+  __Pyx_XDECREF(__pyx_t_5);
+  __Pyx_AddTraceback("numpy._util_dtypestring");
+  __pyx_r = NULL;
+  __pyx_L0:;
+  __Pyx_DECREF((PyObject *)__pyx_v_child);
+  __Pyx_DECREF(__pyx_v_i);
+  __Pyx_DECREF(__pyx_v_new_offset);
+  __Pyx_DECREF(__pyx_v_t);
+  __Pyx_FinishRefcountContext();
+  return __pyx_r;
+}
+
+static struct PyMethodDef __pyx_methods[] = {
+  {__Pyx_NAMESTR("map_indices"), (PyCFunction)__pyx_pf_7tseries_map_indices, METH_O, __Pyx_DOCSTR(__pyx_doc_7tseries_map_indices)},
+  {__Pyx_NAMESTR("match"), (PyCFunction)__pyx_pf_7tseries_match, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_match)},
+  {__Pyx_NAMESTR("reindex"), (PyCFunction)__pyx_pf_7tseries_reindex, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_reindex)},
+  {__Pyx_NAMESTR("reindexObj"), (PyCFunction)__pyx_pf_7tseries_reindexObj, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_reindexObj)},
+  {__Pyx_NAMESTR("reindexObject"), (PyCFunction)__pyx_pf_7tseries_reindexObject, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_reindexObject)},
+  {__Pyx_NAMESTR("getFillVec"), (PyCFunction)__pyx_pf_7tseries_getFillVec, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("getMergeVec"), (PyCFunction)__pyx_pf_7tseries_getMergeVec, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("isnull"), (PyCFunction)__pyx_pf_7tseries_isnull, METH_O, __Pyx_DOCSTR(__pyx_doc_7tseries_isnull)},
+  {__Pyx_NAMESTR("notnull"), (PyCFunction)__pyx_pf_7tseries_notnull, METH_O, __Pyx_DOCSTR(__pyx_doc_7tseries_notnull)},
+  {__Pyx_NAMESTR("reindexNew"), (PyCFunction)__pyx_pf_7tseries_reindexNew, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_reindexNew)},
+  {__Pyx_NAMESTR("combineFunc"), (PyCFunction)__pyx_pf_7tseries_combineFunc, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_combineFunc)},
+  {__Pyx_NAMESTR("arrmap"), (PyCFunction)__pyx_pf_7tseries_arrmap, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("groupby_withnull_old"), (PyCFunction)__pyx_pf_7tseries_groupby_withnull_old, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("groupby_withnull"), (PyCFunction)__pyx_pf_7tseries_groupby_withnull, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("groupby"), (PyCFunction)__pyx_pf_7tseries_groupby, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(0)},
+  {__Pyx_NAMESTR("groupbyfunc"), (PyCFunction)__pyx_pf_7tseries_groupbyfunc, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_7tseries_groupbyfunc)},
+  {0, 0, 0, 0}
+};
+
+static void __pyx_init_filenames(void); /*proto*/
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef __pyx_moduledef = {
+    PyModuleDef_HEAD_INIT,
+    __Pyx_NAMESTR("tseries"),
+    0, /* m_doc */
+    -1, /* m_size */
+    __pyx_methods /* m_methods */,
+    NULL, /* m_reload */
+    NULL, /* m_traverse */
+    NULL, /* m_clear */
+    NULL /* m_free */
+};
+#endif
+
+static __Pyx_StringTabEntry __pyx_string_tab[] = {
+  {&__pyx_kp___main__, __pyx_k___main__, sizeof(__pyx_k___main__), 1, 1, 1},
+  {&__pyx_kp_index, __pyx_k_index, sizeof(__pyx_k_index), 1, 1, 1},
+  {&__pyx_kp_A, __pyx_k_A, sizeof(__pyx_k_A), 1, 1, 1},
+  {&__pyx_kp_B, __pyx_k_B, sizeof(__pyx_k_B), 1, 1, 1},
+  {&__pyx_kp_arr, __pyx_k_arr, sizeof(__pyx_k_arr), 1, 1, 1},
+  {&__pyx_kp_idxMap, __pyx_k_idxMap, sizeof(__pyx_k_idxMap), 1, 1, 1},
+  {&__pyx_kp_oldIndex, __pyx_k_oldIndex, sizeof(__pyx_k_oldIndex), 1, 1, 1},
+  {&__pyx_kp_newIndex, __pyx_k_newIndex, sizeof(__pyx_k_newIndex), 1, 1, 1},
+  {&__pyx_kp_oldMap, __pyx_k_oldMap, sizeof(__pyx_k_oldMap), 1, 1, 1},
+  {&__pyx_kp_newMap, __pyx_k_newMap, sizeof(__pyx_k_newMap), 1, 1, 1},
+  {&__pyx_kp_kind, __pyx_k_kind, sizeof(__pyx_k_kind), 1, 1, 1},
+  {&__pyx_kp_values, __pyx_k_values, sizeof(__pyx_k_values), 1, 1, 1},
+  {&__pyx_kp_indexMap, __pyx_k_indexMap, sizeof(__pyx_k_indexMap), 1, 1, 1},
+  {&__pyx_kp_input, __pyx_k_input, sizeof(__pyx_k_input), 1, 1, 1},
+  {&__pyx_kp_name, __pyx_k_name, sizeof(__pyx_k_name), 1, 1, 1},
+  {&__pyx_kp_ao, __pyx_k_ao, sizeof(__pyx_k_ao), 1, 1, 1},
+  {&__pyx_kp_bo, __pyx_k_bo, sizeof(__pyx_k_bo), 1, 1, 1},
+  {&__pyx_kp_aMap, __pyx_k_aMap, sizeof(__pyx_k_aMap), 1, 1, 1},
+  {&__pyx_kp_bMap, __pyx_k_bMap, sizeof(__pyx_k_bMap), 1, 1, 1},
+  {&__pyx_kp_func, __pyx_k_func, sizeof(__pyx_k_func), 1, 1, 1},
+  {&__pyx_kp_keyfunc, __pyx_k_keyfunc, sizeof(__pyx_k_keyfunc), 1, 1, 1},
+  {&__pyx_kp_applyfunc, __pyx_k_applyfunc, sizeof(__pyx_k_applyfunc), 1, 1, 1},
+  {&__pyx_kp_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 1, 1, 1},
+  {&__pyx_kp_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 1, 1},
+  {&__pyx_kp_isnan, __pyx_k_isnan, sizeof(__pyx_k_isnan), 1, 1, 1},
+  {&__pyx_kp_NaN, __pyx_k_NaN, sizeof(__pyx_k_NaN), 1, 1, 1},
+  {&__pyx_kp_datetime, __pyx_k_datetime, sizeof(__pyx_k_datetime), 1, 1, 1},
+  {&__pyx_kp_pydatetime, __pyx_k_pydatetime, sizeof(__pyx_k_pydatetime), 0, 1, 1},
+  {&__pyx_kp_inf, __pyx_k_inf, sizeof(__pyx_k_inf), 1, 1, 1},
+  {&__pyx_kp_Exception, __pyx_k_Exception, sizeof(__pyx_k_Exception), 1, 1, 1},
+  {&__pyx_kp_map_indices, __pyx_k_map_indices, sizeof(__pyx_k_map_indices), 1, 1, 1},
+  {&__pyx_kp_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 1, 1, 1},
+  {&__pyx_kp_32, __pyx_k_32, sizeof(__pyx_k_32), 1, 1, 1},
+  {&__pyx_kp_astype, __pyx_k_astype, sizeof(__pyx_k_astype), 1, 1, 1},
+  {&__pyx_kp_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 1, 1, 1},
+  {&__pyx_kp_object_, __pyx_k_object_, sizeof(__pyx_k_object_), 1, 1, 1},
+  {&__pyx_kp_object, __pyx_k_object, sizeof(__pyx_k_object), 1, 1, 1},
+  {&__pyx_kp_33, __pyx_k_33, sizeof(__pyx_k_33), 1, 1, 1},
+  {&__pyx_kp_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 1, 1, 1},
+  {&__pyx_kp_34, __pyx_k_34, sizeof(__pyx_k_34), 1, 1, 1},
+  {&__pyx_kp_36, __pyx_k_36, sizeof(__pyx_k_36), 0, 1, 0},
+  {&__pyx_kp_37, __pyx_k_37, sizeof(__pyx_k_37), 0, 1, 0},
+  {&__pyx_kp_bool, __pyx_k_bool, sizeof(__pyx_k_bool), 1, 1, 1},
+  {&__pyx_kp_38, __pyx_k_38, sizeof(__pyx_k_38), 0, 1, 0},
+  {&__pyx_kp_39, __pyx_k_39, sizeof(__pyx_k_39), 0, 1, 0},
+  {&__pyx_kp_isfinite, __pyx_k_isfinite, sizeof(__pyx_k_isfinite), 1, 1, 1},
+  {&__pyx_kp_isnull, __pyx_k_isnull, sizeof(__pyx_k_isnull), 1, 1, 1},
+  {&__pyx_kp_40, __pyx_k_40, sizeof(__pyx_k_40), 0, 1, 0},
+  {&__pyx_kp_41, __pyx_k_41, sizeof(__pyx_k_41), 0, 1, 0},
+  {&__pyx_kp_42, __pyx_k_42, sizeof(__pyx_k_42), 0, 1, 0},
+  {&__pyx_kp_43, __pyx_k_43, sizeof(__pyx_k_43), 0, 1, 0},
+  {&__pyx_kp_44, __pyx_k_44, sizeof(__pyx_k_44), 0, 1, 0},
+  {&__pyx_kp_45, __pyx_k_45, sizeof(__pyx_k_45), 0, 1, 0},
+  {&__pyx_kp_46, __pyx_k_46, sizeof(__pyx_k_46), 0, 1, 0},
+  {&__pyx_kp_47, __pyx_k_47, sizeof(__pyx_k_47), 0, 1, 0},
+  {&__pyx_kp_48, __pyx_k_48, sizeof(__pyx_k_48), 0, 1, 0},
+  {&__pyx_kp_arrmap, __pyx_k_arrmap, sizeof(__pyx_k_arrmap), 1, 1, 1},
+  {&__pyx_kp_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 1, 1, 1},
+  {&__pyx_kp_any, __pyx_k_any, sizeof(__pyx_k_any), 1, 1, 1},
+  {&__pyx_kp_31, __pyx_k_31, sizeof(__pyx_k_31), 0, 0, 0},
+  {&__pyx_kp_35, __pyx_k_35, sizeof(__pyx_k_35), 0, 0, 0},
+  {&__pyx_kp_49, __pyx_k_49, sizeof(__pyx_k_49), 0, 0, 0},
+  {&__pyx_kp_50, __pyx_k_50, sizeof(__pyx_k_50), 0, 0, 0},
+  {&__pyx_kp_51, __pyx_k_51, sizeof(__pyx_k_51), 0, 0, 0},
+  {&__pyx_kp_52, __pyx_k_52, sizeof(__pyx_k_52), 0, 0, 0},
+  {&__pyx_kp_53, __pyx_k_53, sizeof(__pyx_k_53), 0, 0, 0},
+  {&__pyx_kp___getbuffer__, __pyx_k___getbuffer__, sizeof(__pyx_k___getbuffer__), 1, 1, 1},
+  {&__pyx_kp___releasebuffer__, __pyx_k___releasebuffer__, sizeof(__pyx_k___releasebuffer__), 1, 1, 1},
+  {&__pyx_kp_info, __pyx_k_info, sizeof(__pyx_k_info), 1, 1, 1},
+  {&__pyx_kp_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 1, 1, 1},
+  {&__pyx_kp_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 1, 1, 1},
+  {&__pyx_kp_range, __pyx_k_range, sizeof(__pyx_k_range), 1, 1, 1},
+  {&__pyx_kp_itervalues, __pyx_k_itervalues, sizeof(__pyx_k_itervalues), 1, 1, 1},
+  {&__pyx_kp_RuntimeError, __pyx_k_RuntimeError, sizeof(__pyx_k_RuntimeError), 1, 1, 1},
+  {&__pyx_kp_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 0},
+  {&__pyx_kp_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 0},
+  {&__pyx_kp_5, __pyx_k_5, sizeof(__pyx_k_5), 0, 0, 0},
+  {&__pyx_kp_23, __pyx_k_23, sizeof(__pyx_k_23), 0, 0, 0},
+  {&__pyx_kp_25, __pyx_k_25, sizeof(__pyx_k_25), 0, 0, 0},
+  {&__pyx_kp_28, __pyx_k_28, sizeof(__pyx_k_28), 0, 0, 0},
+  {&__pyx_kp_29, __pyx_k_29, sizeof(__pyx_k_29), 0, 0, 0},
+  {&__pyx_kp_30, __pyx_k_30, sizeof(__pyx_k_30), 0, 0, 0},
+  {0, 0, 0, 0, 0, 0}
+};
+static int __Pyx_InitCachedBuiltins(void) {
+  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_kp_Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_object = __Pyx_GetName(__pyx_b, __pyx_kp_object); if (!__pyx_builtin_object) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_kp_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_range = __Pyx_GetName(__pyx_b, __pyx_kp_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_kp_RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+static int __Pyx_InitGlobals(void) {
+  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  return 0;
+  __pyx_L1_error:;
+  return -1;
+}
+
+#if PY_MAJOR_VERSION < 3
+PyMODINIT_FUNC inittseries(void); /*proto*/
+PyMODINIT_FUNC inittseries(void)
+#else
+PyMODINIT_FUNC PyInit_tseries(void); /*proto*/
+PyMODINIT_FUNC PyInit_tseries(void)
+#endif
+{
+  PyObject *__pyx_1 = 0;
+  PyObject *__pyx_2 = 0;
+  PyObject *__pyx_t_1 = NULL;
+  double __pyx_t_2;
+  #ifdef CYTHON_REFNANNY
+  void* __pyx_refchk = NULL;
+  __Pyx_Refnanny = __Pyx_ImportRefcountAPI("refnanny");
+  if (!__Pyx_Refnanny) {
+      PyErr_Clear();
+      __Pyx_Refnanny = __Pyx_ImportRefcountAPI("Cython.Runtime.refnanny");
+      if (!__Pyx_Refnanny)
+          Py_FatalError("failed to import refnanny module");
+  }
+  __pyx_refchk = __Pyx_Refnanny->NewContext("PyMODINIT_FUNC PyInit_tseries(void)", __LINE__, __FILE__);
+  #endif
+  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Library function declarations ---*/
+  __pyx_init_filenames();
+  /*--- Threads initialization code ---*/
+  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
+  #ifdef WITH_THREAD /* Python build with threading support? */
+  PyEval_InitThreads();
+  #endif
+  #endif
+  /*--- Initialize various global constants etc. ---*/
+  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Module creation code ---*/
+  #if PY_MAJOR_VERSION < 3
+  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("tseries"), __pyx_methods, 0, 0, PYTHON_API_VERSION);
+  #else
+  __pyx_m = PyModule_Create(&__pyx_moduledef);
+  #endif
+  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  #if PY_MAJOR_VERSION < 3
+  Py_INCREF(__pyx_m);
+  #endif
+  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
+  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  if (__pyx_module_is_main_tseries) {
+    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_kp___main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
+  }
+  /*--- Builtin init code ---*/
+  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_skip_dispatch = 0;
+  /*--- Global init code ---*/
+  /*--- Function export code ---*/
+  /*--- Type init code ---*/
+  __pyx_ptype_7tseries_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr)); if (unlikely(!__pyx_ptype_7tseries_dtype)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7tseries_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject)); if (unlikely(!__pyx_ptype_7tseries_ndarray)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7tseries_flatiter = __Pyx_ImportType("numpy", "flatiter", sizeof(PyArrayIterObject)); if (unlikely(!__pyx_ptype_7tseries_flatiter)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7tseries_broadcast = __Pyx_ImportType("numpy", "broadcast", sizeof(PyArrayMultiIterObject)); if (unlikely(!__pyx_ptype_7tseries_broadcast)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 100; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_7tseries_datetime = __Pyx_ImportType("datetime", "datetime", sizeof(PyDateTime_DateTime)); if (unlikely(!__pyx_ptype_7tseries_datetime)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 3; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Type import code ---*/
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType("numpy", "dtype", sizeof(PyArray_Descr)); if (unlikely(!__pyx_ptype_5numpy_dtype)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType("numpy", "ndarray", sizeof(PyArrayObject)); if (unlikely(!__pyx_ptype_5numpy_ndarray)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 51; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  /*--- Function import code ---*/
+  /*--- Execution code ---*/
+
+  /* "pandas/lib/src/tseries.pyx":6
+ * 
+ * # initialize numpy
+ * import_array()             # <<<<<<<<<<<<<<
+ * 
+ * import numpy as np
+ */
+  import_array();
+
+  /* "pandas/lib/src/tseries.pyx":8
+ * import_array()
+ * 
+ * import numpy as np             # <<<<<<<<<<<<<<
+ * cimport numpy as np
+ * 
+ */
+  __pyx_1 = __Pyx_Import(__pyx_kp_numpy, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  if (PyObject_SetAttr(__pyx_m, __pyx_kp_np, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":11
+ * cimport numpy as np
+ * 
+ * isnan = np.isnan             # <<<<<<<<<<<<<<
+ * cdef double NaN = <double> np.NaN
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_isnan); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  if (PyObject_SetAttr(__pyx_m, __pyx_kp_isnan, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 11; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":12
+ * 
+ * isnan = np.isnan
+ * cdef double NaN = <double> np.NaN             # <<<<<<<<<<<<<<
+ * 
+ * from datetime import datetime as pydatetime
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_NaN); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_7tseries_NaN = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":14
+ * cdef double NaN = <double> np.NaN
+ * 
+ * from datetime import datetime as pydatetime             # <<<<<<<<<<<<<<
+ * 
+ * from python_dict cimport *
+ */
+  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
+  __Pyx_INCREF(__pyx_kp_datetime);
+  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_kp_datetime);
+  __Pyx_GIVEREF(__pyx_kp_datetime);
+  __pyx_1 = __Pyx_Import(__pyx_kp_datetime, ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
+  __pyx_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_datetime); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_2);
+  if (PyObject_SetAttr(__pyx_m, __pyx_kp_pydatetime, __pyx_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 14; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+
+  /* "pandas/lib/src/tseries.pyx":547
+ *     return fillVec, maskVec.astype(np.bool)
+ * 
+ * cdef double INF = <double> np.inf             # <<<<<<<<<<<<<<
+ * cdef double NEGINF = -INF
+ * 
+ */
+  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_np); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_1);
+  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_inf); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_GOTREF(__pyx_t_1);
+  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
+  __pyx_t_2 = __pyx_PyFloat_AsDouble(__pyx_t_1); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 547; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  __pyx_v_7tseries_INF = ((double)__pyx_t_2);
+
+  /* "pandas/lib/src/tseries.pyx":548
+ * 
+ * cdef double INF = <double> np.inf
+ * cdef double NEGINF = -INF             # <<<<<<<<<<<<<<
+ * 
+ * cdef inline _checknull(object val):
+ */
+  __pyx_v_7tseries_NEGINF = (-__pyx_v_7tseries_INF);
+
+  /* "/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/site-packages/Cython-0.11.2-py2.5-macosx-10.3-i386.egg/Cython/Includes/stdlib.pxd":2
+ * 
+ * cdef extern from "stdlib.h" nogil:             # <<<<<<<<<<<<<<
+ *     void free(void *ptr)
+ *     void *malloc(size_t size)
+ */
+  goto __pyx_L0;
+  __pyx_L1_error:;
+  __Pyx_XDECREF(__pyx_1);
+  __Pyx_XDECREF(__pyx_2);
+  __Pyx_XDECREF(__pyx_t_1);
+  __Pyx_AddTraceback("tseries");
+  Py_DECREF(__pyx_m); __pyx_m = 0;
+  __pyx_L0:;
+  __Pyx_FinishRefcountContext();
+  #if PY_MAJOR_VERSION < 3
+  return;
+  #else
+  return __pyx_m;
+  #endif
+}
+
+static const char *__pyx_filenames[] = {
+  "tseries.pyx",
+  "numpy.pxd",
+  "numpy.pxi",
+  "datetime.pxi",
+};
+
+/* Runtime support code */
+
+static void __pyx_init_filenames(void) {
+  __pyx_f = __pyx_filenames;
+}
+
+static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+    PyErr_NormalizeException(type, value, tb);
+    if (PyErr_Occurred())
+        goto bad;
+    Py_INCREF(*type);
+    Py_INCREF(*value);
+    Py_INCREF(*tb);
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = *type;
+    tstate->exc_value = *value;
+    tstate->exc_traceback = *tb;
+    /* Make sure tstate is in a consistent state when we XDECREF
+    these objects (XDECREF may run arbitrary code). */
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+    return 0;
+bad:
+    Py_XDECREF(*type);
+    Py_XDECREF(*value);
+    Py_XDECREF(*tb);
+    return -1;
+}
+
+
+static int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
+    if (!type) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (obj == Py_None || PyObject_TypeCheck(obj, type))
+        return 1;
+    PyErr_Format(PyExc_TypeError, "Cannot convert %s to %s",
+        Py_TYPE(obj)->tp_name, type->tp_name);
+    return 0;
+}
+
+static void __Pyx_RaiseDoubleKeywordsError(
+    const char* func_name,
+    PyObject* kw_name)
+{
+    PyErr_Format(PyExc_TypeError,
+        #if PY_MAJOR_VERSION >= 3
+        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
+        #else
+        "%s() got multiple values for keyword argument '%s'", func_name,
+        PyString_AS_STRING(kw_name));
+        #endif
+}
+
+static void __Pyx_RaiseArgtupleInvalid(
+    const char* func_name,
+    int exact,
+    Py_ssize_t num_min,
+    Py_ssize_t num_max,
+    Py_ssize_t num_found)
+{
+    Py_ssize_t num_expected;
+    const char *number, *more_or_less;
+
+    if (num_found < num_min) {
+        num_expected = num_min;
+        more_or_less = "at least";
+    } else {
+        num_expected = num_max;
+        more_or_less = "at most";
+    }
+    if (exact) {
+        more_or_less = "exactly";
+    }
+    number = (num_expected == 1) ? "" : "s";
+    PyErr_Format(PyExc_TypeError,
+        #if PY_VERSION_HEX < 0x02050000
+            "%s() takes %s %d positional argument%s (%d given)",
+        #else
+            "%s() takes %s %zd positional argument%s (%zd given)",
+        #endif
+        func_name, more_or_less, num_expected, number, num_found);
+}
+
+static int __Pyx_ParseOptionalKeywords(
+    PyObject *kwds,
+    PyObject **argnames[],
+    PyObject *kwds2,
+    PyObject *values[],
+    Py_ssize_t num_pos_args,
+    const char* function_name)
+{
+    PyObject *key = 0, *value = 0;
+    Py_ssize_t pos = 0;
+    PyObject*** name;
+    PyObject*** first_kw_arg = argnames + num_pos_args;
+
+    while (PyDict_Next(kwds, &pos, &key, &value)) {
+        name = first_kw_arg;
+        while (*name && (**name != key)) name++;
+        if (*name) {
+            values[name-argnames] = value;
+        } else {
+            #if PY_MAJOR_VERSION < 3
+            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
+            #else
+            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
+            #endif
+                goto invalid_keyword_type;
+            } else {
+                for (name = first_kw_arg; *name; name++) {
+                    #if PY_MAJOR_VERSION >= 3
+                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                        PyUnicode_Compare(**name, key) == 0) break;
+                    #else
+                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                        _PyString_Eq(**name, key)) break;
+                    #endif
+                }
+                if (*name) {
+                    values[name-argnames] = value;
+                } else {
+                    /* unexpected keyword found */
+                    for (name=argnames; name != first_kw_arg; name++) {
+                        if (**name == key) goto arg_passed_twice;
+                        #if PY_MAJOR_VERSION >= 3
+                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
+                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
+                        #else
+                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
+                            _PyString_Eq(**name, key)) goto arg_passed_twice;
+                        #endif
+                    }
+                    if (kwds2) {
+                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
+                    } else {
+                        goto invalid_keyword;
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+arg_passed_twice:
+    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
+    goto bad;
+invalid_keyword_type:
+    PyErr_Format(PyExc_TypeError,
+        "%s() keywords must be strings", function_name);
+    goto bad;
+invalid_keyword:
+    PyErr_Format(PyExc_TypeError,
+    #if PY_MAJOR_VERSION < 3
+        "%s() got an unexpected keyword argument '%s'",
+        function_name, PyString_AsString(key));
+    #else
+        "%s() got an unexpected keyword argument '%U'",
+        function_name, key);
+    #endif
+bad:
+    return -1;
+}
+
+static INLINE int __Pyx_IsLittleEndian(void) {
+  unsigned int n = 1;
+  return *(unsigned char*)(&n) != 0;
+}
+
+typedef struct {
+  __Pyx_StructField root;
+  __Pyx_BufFmt_StackElem* head;
+  size_t fmt_offset;
+  int new_count, enc_count;
+  int is_complex;
+  char enc_type;
+  char packmode;
+} __Pyx_BufFmt_Context;
+
+static void __Pyx_BufFmt_Init(__Pyx_BufFmt_Context* ctx,
+                              __Pyx_BufFmt_StackElem* stack,
+                              __Pyx_TypeInfo* type) {
+  stack[0].field = &ctx->root;
+  stack[0].parent_offset = 0;
+  ctx->root.type = type;
+  ctx->root.name = "buffer dtype";
+  ctx->root.offset = 0;
+  ctx->head = stack;
+  ctx->head->field = &ctx->root;
+  ctx->fmt_offset = 0;
+  ctx->head->parent_offset = 0;
+  ctx->packmode = '@';
+  ctx->new_count = 1;
+  ctx->enc_count = 0;
+  ctx->enc_type = 0;
+  ctx->is_complex = 0;
+  while (type->typegroup == 'S') {
+    ++ctx->head;
+    ctx->head->field = type->fields;
+    ctx->head->parent_offset = 0;
+    type = type->fields->type;
+  }
+}
+
+static int __Pyx_BufFmt_ParseNumber(const char** ts) {
+    int count;
+    const char* t = *ts;
+    if (*t < '0' || *t > '9') {
+      return -1;
+    } else {
+        count = *t++ - '0';
+        while (*t >= '0' && *t < '9') {
+            count *= 10;
+            count += *t++ - '0';
+        }
+    }
+    *ts = t;
+    return count;
+}
+
+static void __Pyx_BufFmt_RaiseUnexpectedChar(char ch) {
+  char msg[] = {ch, 0};
+  PyErr_Format(PyExc_ValueError, "Unexpected format string character: '%s'", msg);
+}
+
+static const char* __Pyx_BufFmt_DescribeTypeChar(char ch, int is_complex) {
+  switch (ch) {
+    case 'b': return "'char'";
+    case 'B': return "'unsigned char'";
+    case 'h': return "'short'";
+    case 'H': return "'unsigned short'";
+    case 'i': return "'int'";
+    case 'I': return "'unsigned int'";
+    case 'l': return "'long'";
+    case 'L': return "'unsigned long'";
+    case 'q': return "'long long'";
+    case 'Q': return "'unsigned long long'";
+    case 'f': return (is_complex ? "'complex float'" : "'float'");
+    case 'd': return (is_complex ? "'complex double'" : "'double'");
+    case 'g': return (is_complex ? "'complex long double'" : "'long double'");
+    case 'T': return "a struct";
+    case 'O': return "Python object";
+    case 'P': return "a pointer";
+    case 0: return "end";
+    default: return "unparseable format string";
+  }
+}
+
+static size_t __Pyx_BufFmt_TypeCharToStandardSize(char ch, int is_complex) {
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': return 1;
+    case 'h': case 'H': return 2;
+    case 'i': case 'I': case 'l': case 'L': return 4;
+    case 'q': case 'Q': return 8;
+    case 'f': return (is_complex ? 8 : 4);
+    case 'd': return (is_complex ? 16 : 8);
+    case 'g': {
+      PyErr_SetString(PyExc_ValueError, "Python does not define a standard format string size for long double ('g')..");
+      return 0;
+    }
+    case 'O': case 'P': return sizeof(void*);
+    default:
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+}
+
+static size_t __Pyx_BufFmt_TypeCharToNativeSize(char ch, int is_complex) {
+  switch (ch) {
+    case 'c': case 'b': case 'B': return 1;
+    case 'h': case 'H': return sizeof(short);
+    case 'i': case 'I': return sizeof(int);
+    case 'l': case 'L': return sizeof(long);
+    #ifdef HAVE_LONG_LONG
+    case 'q': case 'Q': return sizeof(PY_LONG_LONG);
+    #endif
+    case 'f': return sizeof(float) * (is_complex ? 2 : 1);
+    case 'd': return sizeof(double) * (is_complex ? 2 : 1);
+    case 'g': return sizeof(long double) * (is_complex ? 2 : 1);
+    case 'O': case 'P': return sizeof(void*);
+    default: {
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }    
+  }
+}
+
+typedef struct { char c; short x; } __Pyx_st_short;
+typedef struct { char c; int x; } __Pyx_st_int;
+typedef struct { char c; long x; } __Pyx_st_long;
+typedef struct { char c; float x; } __Pyx_st_float;
+typedef struct { char c; double x; } __Pyx_st_double;
+typedef struct { char c; long double x; } __Pyx_st_longdouble;
+typedef struct { char c; void *x; } __Pyx_st_void_p;
+#ifdef HAVE_LONG_LONG
+typedef struct { char c; PY_LONG_LONG x; } __Pyx_s_long_long;
+#endif
+
+static size_t __Pyx_BufFmt_TypeCharToAlignment(char ch, int is_complex) {
+  switch (ch) {
+    case '?': case 'c': case 'b': case 'B': return 1;
+    case 'h': case 'H': return sizeof(__Pyx_st_short) - sizeof(short);
+    case 'i': case 'I': return sizeof(__Pyx_st_int) - sizeof(int);
+    case 'l': case 'L': return sizeof(__Pyx_st_long) - sizeof(long);
+#ifdef HAVE_LONG_LONG
+    case 'q': case 'Q': return sizeof(__Pyx_s_long_long) - sizeof(PY_LONG_LONG);
+#endif
+    case 'f': return sizeof(__Pyx_st_float) - sizeof(float);
+    case 'd': return sizeof(__Pyx_st_double) - sizeof(double);
+    case 'g': return sizeof(__Pyx_st_longdouble) - sizeof(long double);
+    case 'P': case 'O': return sizeof(__Pyx_st_void_p) - sizeof(void*);
+    default:
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }
+}
+
+static size_t __Pyx_BufFmt_TypeCharToGroup(char ch, int is_complex) {
+  switch (ch) {
+    case 'c': case 'b': case 'h': case 'i': case 'l': case 'q': return 'I';
+    case 'B': case 'H': case 'I': case 'L': case 'Q': return 'U';
+    case 'f': case 'd': case 'g': return (is_complex ? 'C' : 'R');
+    case 'O': return 'O';
+    case 'P': return 'P';
+    default: {
+      __Pyx_BufFmt_RaiseUnexpectedChar(ch);
+      return 0;
+    }    
+  }
+}
+
+static void __Pyx_BufFmt_RaiseExpected(__Pyx_BufFmt_Context* ctx) {
+  if (ctx->head == NULL || ctx->head->field == &ctx->root) {
+    const char* expected;
+    const char* quote;
+    if (ctx->head == NULL) {
+      expected = "end";
+      quote = "";
+    } else {
+      expected = ctx->head->field->type->name;
+      quote = "'";
+    }
+    PyErr_Format(PyExc_ValueError,
+                 "Buffer dtype mismatch, expected %s%s%s but got %s",
+                 quote, expected, quote,
+                 __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex));
+  } else {
+    __Pyx_StructField* field = ctx->head->field;
+    __Pyx_StructField* parent = (ctx->head - 1)->field;
+    PyErr_Format(PyExc_ValueError,
+                 "Buffer dtype mismatch, expected '%s' but got %s in '%s.%s'",
+                 field->type->name, __Pyx_BufFmt_DescribeTypeChar(ctx->enc_type, ctx->is_complex),
+                 parent->type->name, field->name);
+  }
+}
+
+static int __Pyx_BufFmt_ProcessTypeChunk(__Pyx_BufFmt_Context* ctx) {
+  char group;
+  size_t size, offset;
+  if (ctx->enc_type == 0) return 0;
+  group = __Pyx_BufFmt_TypeCharToGroup(ctx->enc_type, ctx->is_complex);
+  do {
+    __Pyx_StructField* field = ctx->head->field;
+    __Pyx_TypeInfo* type = field->type;
+  
+    if (ctx->packmode == '@' || ctx->packmode == '^') {
+      size = __Pyx_BufFmt_TypeCharToNativeSize(ctx->enc_type, ctx->is_complex);
+    } else {
+      size = __Pyx_BufFmt_TypeCharToStandardSize(ctx->enc_type, ctx->is_complex);
+    }
+    if (ctx->packmode == '@') {
+      int align_at = __Pyx_BufFmt_TypeCharToAlignment(ctx->enc_type, ctx->is_complex);
+      int align_mod_offset;
+      if (align_at == 0) return -1;
+      align_mod_offset = ctx->fmt_offset % align_at;
+      if (align_mod_offset > 0) ctx->fmt_offset += align_at - align_mod_offset;
+    }
+
+    if (type->size != size || type->typegroup != group) {
+      if (type->typegroup == 'C' && type->fields != NULL) {
+        /* special case -- treat as struct rather than complex number */
+        size_t parent_offset = ctx->head->parent_offset + field->offset;
+        ++ctx->head;
+        ctx->head->field = type->fields;
+        ctx->head->parent_offset = parent_offset;
+        continue;
+      }
+    
+      __Pyx_BufFmt_RaiseExpected(ctx);
+      return -1;
+    }
+
+    offset = ctx->head->parent_offset + field->offset;
+    if (ctx->fmt_offset != offset) {
+      PyErr_Format(PyExc_ValueError,
+                   "Buffer dtype mismatch; next field is at offset %"PY_FORMAT_SIZE_T"d "
+                   "but %"PY_FORMAT_SIZE_T"d expected", ctx->fmt_offset, offset);
+      return -1;
+    }
+
+    ctx->fmt_offset += size;
+  
+    --ctx->enc_count; /* Consume from buffer string */
+
+    /* Done checking, move to next field, pushing or popping struct stack if needed */
+    while (1) {
+      if (field == &ctx->root) {
+        ctx->head = NULL;
+        if (ctx->enc_count != 0) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return -1;
+        }
+        break; /* breaks both loops as ctx->enc_count == 0 */
+      }
+      ctx->head->field = ++field;
+      if (field->type == NULL) {
+        --ctx->head;
+        field = ctx->head->field;
+        continue;
+      } else if (field->type->typegroup == 'S') {
+        size_t parent_offset = ctx->head->parent_offset + field->offset;
+        if (field->type->fields->type == NULL) continue; /* empty struct */
+        field = field->type->fields;
+        ++ctx->head;
+        ctx->head->field = field;
+        ctx->head->parent_offset = parent_offset;
+        break;
+      } else {
+        break;
+      }
+    }
+  } while (ctx->enc_count);
+  ctx->enc_type = 0;
+  ctx->is_complex = 0;
+  return 0;    
+}
+
+static int __Pyx_BufFmt_FirstPack(__Pyx_BufFmt_Context* ctx) {
+  if (ctx->enc_type != 0 || ctx->packmode != '@') {
+    PyErr_SetString(PyExc_ValueError, "Buffer packing mode currently only allowed at beginning of format string (this is a defect)");
+    return -1;
+  }
+  return 0;
+}
+
+static const char* __Pyx_BufFmt_CheckString(__Pyx_BufFmt_Context* ctx, const char* ts) {
+  int got_Z = 0;
+  while (1) {
+    switch(*ts) {
+      case 0:
+        if (ctx->enc_type != 0 && ctx->head == NULL) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return NULL;
+        }
+        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+        if (ctx->head != NULL) {
+          __Pyx_BufFmt_RaiseExpected(ctx);
+          return NULL;
+        }
+        return ts;
+      case ' ':
+      case 10:
+      case 13:
+        ++ts;
+        break;
+      case '<':
+        if (!__Pyx_IsLittleEndian()) {
+          PyErr_SetString(PyExc_ValueError, "Little-endian buffer not supported on big-endian compiler");
+          return NULL;
+        }
+        if (__Pyx_BufFmt_FirstPack(ctx) == -1) return NULL;
+        ctx->packmode = '=';
+        ++ts;
+        break;
+      case '>':
+      case '!':
+        if (__Pyx_IsLittleEndian()) {
+          PyErr_SetString(PyExc_ValueError, "Big-endian buffer not supported on little-endian compiler");
+          return NULL;
+        }
+        if (__Pyx_BufFmt_FirstPack(ctx) == -1) return NULL;
+        ctx->packmode = '=';
+        ++ts;
+        break;
+      case '=':
+      case '@':
+      case '^':
+        if (__Pyx_BufFmt_FirstPack(ctx) == -1) return NULL;
+        ctx->packmode = *ts++;
+        break;
+      case 'T': /* substruct */
+        {
+          int i;
+          const char* ts_after_sub;
+          int struct_count = ctx->new_count;
+          ctx->new_count = 1;
+          ++ts;
+          if (*ts != '{') {
+            PyErr_SetString(PyExc_ValueError, "Buffer acquisition: Expected '{' after 'T'");
+            return NULL;
+          }
+          ++ts;
+          ts_after_sub = ts;
+          for (i = 0; i != struct_count; ++i) {
+            ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);
+            if (!ts_after_sub) return NULL;
+          }
+          ts = ts_after_sub;
+        }
+        break;
+      case '}': /* end of substruct; either repeat or move on */
+        ++ts;
+        return ts;
+      case 'x':
+        if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+        ctx->fmt_offset += ctx->new_count;
+        ctx->new_count = 1;
+        ctx->enc_count = 0;
+        ctx->enc_type = 0;
+        ++ts;
+        break;
+      case 'Z':
+        got_Z = 1;
+        ++ts;
+        if (*ts != 'f' && *ts != 'd' && *ts != 'g') {
+          __Pyx_BufFmt_RaiseUnexpectedChar('Z');
+          return NULL;
+        }        /* fall through */
+      case 'c': case 'b': case 'B': case 'h': case 'H': case 'i': case 'I':
+      case 'l': case 'L': case 'q': case 'Q':
+      case 'f': case 'd': case 'g':
+      case 'O':
+        if (ctx->enc_type == *ts && got_Z == ctx->is_complex) {
+          /* Continue pooling same type */
+          ctx->enc_count += ctx->new_count;
+        } else {
+          /* New type */
+          if (__Pyx_BufFmt_ProcessTypeChunk(ctx) == -1) return NULL;
+          ctx->enc_count = ctx->new_count;
+          ctx->enc_type = *ts;
+          ctx->is_complex = got_Z;
+        }
+        ++ts;
+        ctx->new_count = 1;
+        got_Z = 0;
+        break;
+      default:
+        {
+          ctx->new_count = __Pyx_BufFmt_ParseNumber(&ts);
+          if (ctx->new_count == -1) { /* First char was not a digit */
+            char msg[2] = { *ts, 0 };
+            PyErr_Format(PyExc_ValueError,
+                         "Does not understand character buffer dtype format string ('%s')", msg);
+            return NULL;
+          }
+        }
+      
+    }
+  }
+}
+
+static INLINE void __Pyx_ZeroBuffer(Py_buffer* buf) {
+  buf->buf = NULL;
+  buf->obj = NULL;
+  buf->strides = __Pyx_zeros;
+  buf->shape = __Pyx_zeros;
+  buf->suboffsets = __Pyx_minusones;
+}
+
+static int __Pyx_GetBufferAndValidate(Py_buffer* buf, PyObject* obj, __Pyx_TypeInfo* dtype, int flags, int nd, int cast, __Pyx_BufFmt_StackElem* stack) {
+  if (obj == Py_None) {
+    __Pyx_ZeroBuffer(buf);
+    return 0;
+  }
+  buf->buf = NULL;
+  if (__Pyx_GetBuffer(obj, buf, flags) == -1) goto fail;
+  if (buf->ndim != nd) {
+    PyErr_Format(PyExc_ValueError,
+                 "Buffer has wrong number of dimensions (expected %d, got %d)",
+                 nd, buf->ndim);
+    goto fail;
+  }
+  if (!cast) {
+    __Pyx_BufFmt_Context ctx;
+    __Pyx_BufFmt_Init(&ctx, stack, dtype);
+    if (!__Pyx_BufFmt_CheckString(&ctx, buf->format)) goto fail;
+  }
+  if ((unsigned)buf->itemsize != dtype->size) {
+    PyErr_Format(PyExc_ValueError,
+      "Item size of buffer (%"PY_FORMAT_SIZE_T"d byte%s) does not match size of '%s' (%"PY_FORMAT_SIZE_T"d byte%s)",
+      buf->itemsize, (buf->itemsize > 1) ? "s" : "",
+      dtype->name,
+      dtype->size, (dtype->size > 1) ? "s" : "");
+    goto fail;
+  }
+  if (buf->suboffsets == NULL) buf->suboffsets = __Pyx_minusones;
+  return 0;
+fail:;
+  __Pyx_ZeroBuffer(buf);
+  return -1;
+}
+
+static INLINE void __Pyx_SafeReleaseBuffer(Py_buffer* info) {
+  if (info->buf == NULL) return;
+  if (info->suboffsets == __Pyx_minusones) info->suboffsets = NULL;
+  __Pyx_ReleaseBuffer(info);
+}
+
+static INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+
+#if PY_MAJOR_VERSION >= 3
+    /* Note: this is a temporary work-around to prevent crashes in Python 3.0 */
+    if ((tstate->exc_type != NULL) & (tstate->exc_type != Py_None)) {
+        tmp_type = tstate->exc_type;
+        tmp_value = tstate->exc_value;
+        tmp_tb = tstate->exc_traceback;
+        PyErr_NormalizeException(&type, &value, &tb);
+        PyErr_NormalizeException(&tmp_type, &tmp_value, &tmp_tb);
+        tstate->exc_type = 0;
+        tstate->exc_value = 0;
+        tstate->exc_traceback = 0;
+        PyException_SetContext(value, tmp_value);
+        Py_DECREF(tmp_type);
+        Py_XDECREF(tmp_tb);
+    }
+#endif
+
+    tmp_type = tstate->curexc_type;
+    tmp_value = tstate->curexc_value;
+    tmp_tb = tstate->curexc_traceback;
+    tstate->curexc_type = type;
+    tstate->curexc_value = value;
+    tstate->curexc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+
+static INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->curexc_type;
+    *value = tstate->curexc_value;
+    *tb = tstate->curexc_traceback;
+
+    tstate->curexc_type = 0;
+    tstate->curexc_value = 0;
+    tstate->curexc_traceback = 0;
+}
+
+
+static INLINE void __Pyx_RaiseNoneNotIterableError(void) {
+    PyErr_SetString(PyExc_TypeError, "'NoneType' object is iterable");
+}
+
+static INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
+    PyErr_Format(PyExc_ValueError,
+        #if PY_VERSION_HEX < 0x02050000
+                 "need more than %d value%s to unpack", (int)index,
+        #else
+                 "need more than %zd value%s to unpack", index,
+        #endif
+                 (index == 1) ? "" : "s");
+}
+
+static INLINE void __Pyx_RaiseTooManyValuesError(void) {
+    PyErr_SetString(PyExc_ValueError, "too many values to unpack");
+}
+
+static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
+    if (t == Py_None) {
+      __Pyx_RaiseNoneNotIterableError();
+    } else if (PyTuple_GET_SIZE(t) < index) {
+      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
+    } else {
+      __Pyx_RaiseTooManyValuesError();
+    }
+}
+
+static void __Pyx_RaiseBufferFallbackError(void) {
+  PyErr_Format(PyExc_ValueError,
+     "Buffer acquisition failed on assignment; and then reacquiring the old buffer failed too!");
+}
+
+static void __Pyx_RaiseBufferIndexError(int axis) {
+  PyErr_Format(PyExc_IndexError,
+     "Out of bounds on buffer access (axis %d)", axis);
+}
+
+
+
+static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
+    const char *name, int exact)
+{
+    if (!type) {
+        PyErr_Format(PyExc_SystemError, "Missing type object");
+        return 0;
+    }
+    if (none_allowed && obj == Py_None) return 1;
+    else if (exact) {
+        if (Py_TYPE(obj) == type) return 1;
+    }
+    else {
+        if (PyObject_TypeCheck(obj, type)) return 1;
+    }
+    PyErr_Format(PyExc_TypeError,
+        "Argument '%s' has incorrect type (expected %s, got %s)",
+        name, type->tp_name, Py_TYPE(obj)->tp_name);
+    return 0;
+}
+
+static INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
+    PyThreadState *tstate = PyThreadState_GET();
+    *type = tstate->exc_type;
+    *value = tstate->exc_value;
+    *tb = tstate->exc_traceback;
+    Py_XINCREF(*type);
+    Py_XINCREF(*value);
+    Py_XINCREF(*tb);
+}
+
+static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
+    PyObject *tmp_type, *tmp_value, *tmp_tb;
+    PyThreadState *tstate = PyThreadState_GET();
+    tmp_type = tstate->exc_type;
+    tmp_value = tstate->exc_value;
+    tmp_tb = tstate->exc_traceback;
+    tstate->exc_type = type;
+    tstate->exc_value = value;
+    tstate->exc_traceback = tb;
+    Py_XDECREF(tmp_type);
+    Py_XDECREF(tmp_value);
+    Py_XDECREF(tmp_tb);
+}
+
+#if PY_MAJOR_VERSION < 3
+static int __Pyx_GetBuffer(PyObject *obj, Py_buffer *view, int flags) {
+  #if PY_VERSION_HEX >= 0x02060000
+  if (Py_TYPE(obj)->tp_flags & Py_TPFLAGS_HAVE_NEWBUFFER)
+      return PyObject_GetBuffer(obj, view, flags);
+  #endif
+  if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) return __pyx_pf_5numpy_7ndarray___getbuffer__(obj, view, flags);
+  else {
+  PyErr_Format(PyExc_TypeError, "'%100s' does not have the buffer interface", Py_TYPE(obj)->tp_name);
+  return -1;
+    }
+}
+
+static void __Pyx_ReleaseBuffer(Py_buffer *view) {
+  PyObject* obj = view->obj;
+  if (obj) {
+if (PyObject_TypeCheck(obj, __pyx_ptype_5numpy_ndarray)) __pyx_pf_5numpy_7ndarray___releasebuffer__(obj, view);
+    Py_DECREF(obj);
+    view->obj = NULL;
+  }
+}
+
+#endif
+
+static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
+    PyObject *__import__ = 0;
+    PyObject *empty_list = 0;
+    PyObject *module = 0;
+    PyObject *global_dict = 0;
+    PyObject *empty_dict = 0;
+    PyObject *list;
+    __import__ = __Pyx_GetAttrString(__pyx_b, "__import__");
+    if (!__import__)
+        goto bad;
+    if (from_list)
+        list = from_list;
+    else {
+        empty_list = PyList_New(0);
+        if (!empty_list)
+            goto bad;
+        list = empty_list;
+    }
+    global_dict = PyModule_GetDict(__pyx_m);
+    if (!global_dict)
+        goto bad;
+    empty_dict = PyDict_New();
+    if (!empty_dict)
+        goto bad;
+    module = PyObject_CallFunctionObjArgs(__import__,
+        name, global_dict, empty_dict, list, NULL);
+bad:
+    Py_XDECREF(empty_list);
+    Py_XDECREF(__import__);
+    Py_XDECREF(empty_dict);
+    return module;
+}
+
+static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
+    PyObject *result;
+    result = PyObject_GetAttr(dict, name);
+    if (!result)
+        PyErr_SetObject(PyExc_NameError, name);
+    return result;
+}
+
+static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
+    Py_XINCREF(type);
+    Py_XINCREF(value);
+    Py_XINCREF(tb);
+    /* First, check the traceback argument, replacing None with NULL. */
+    if (tb == Py_None) {
+        Py_DECREF(tb);
+        tb = 0;
+    }
+    else if (tb != NULL && !PyTraceBack_Check(tb)) {
+        PyErr_SetString(PyExc_TypeError,
+            "raise: arg 3 must be a traceback or None");
+        goto raise_error;
+    }
+    /* Next, replace a missing value with None */
+    if (value == NULL) {
+        value = Py_None;
+        Py_INCREF(value);
+    }
+    #if PY_VERSION_HEX < 0x02050000
+    if (!PyClass_Check(type))
+    #else
+    if (!PyType_Check(type))
+    #endif
+    {
+        /* Raising an instance.  The value should be a dummy. */
+        if (value != Py_None) {
+            PyErr_SetString(PyExc_TypeError,
+                "instance exception may not have a separate value");
+            goto raise_error;
+        }
+        /* Normalize to raise <class>, <instance> */
+        Py_DECREF(value);
+        value = type;
+        #if PY_VERSION_HEX < 0x02050000
+            if (PyInstance_Check(type)) {
+                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
+                Py_INCREF(type);
+            }
+            else {
+                type = 0;
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception must be an old-style class or instance");
+                goto raise_error;
+            }
+        #else
+            type = (PyObject*) Py_TYPE(type);
+            Py_INCREF(type);
+            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
+                PyErr_SetString(PyExc_TypeError,
+                    "raise: exception class must be a subclass of BaseException");
+                goto raise_error;
+            }
+        #endif
+    }
+    __Pyx_ErrRestore(type, value, tb);
+    return;
+raise_error:
+    Py_XDECREF(value);
+    Py_XDECREF(type);
+    Py_XDECREF(tb);
+    return;
+}
+
+static PyObject *__Pyx_UnpackItem(PyObject *iter, Py_ssize_t index) {
+    PyObject *item;
+    if (!(item = PyIter_Next(iter))) {
+        if (!PyErr_Occurred()) {
+            __Pyx_RaiseNeedMoreValuesError(index);
+        }
+    }
+    return item;
+}
+
+static int __Pyx_EndUnpack(PyObject *iter) {
+    PyObject *item;
+    if ((item = PyIter_Next(iter))) {
+        Py_DECREF(item);
+        __Pyx_RaiseTooManyValuesError();
+        return -1;
+    }
+    else if (!PyErr_Occurred())
+        return 0;
+    else
+        return -1;
+}
+
+static INLINE int __Pyx_StrEq(const char *s1, const char *s2) {
+     while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
+     return *s1 == *s2;
+}
+
+static INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
+    if (sizeof(unsigned char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned char)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (unsigned char)-1;
+            if (unlikely(val < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned char");
+                return (unsigned char)-1;
+            }
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to unsigned char");
+            return (unsigned char)-1;
+        }
+        return (unsigned char)val;
+    }
+    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
+    if (sizeof(unsigned short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned short)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (unsigned short)-1;
+            if (unlikely(val < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned short");
+                return (unsigned short)-1;
+            }
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to unsigned short");
+            return (unsigned short)-1;
+        }
+        return (unsigned short)val;
+    }
+    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
+    if (sizeof(unsigned int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(unsigned int)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (unsigned int)-1;
+            if (unlikely(val < 0)) {
+                PyErr_SetString(PyExc_OverflowError,
+                                "can't convert negative value to unsigned int");
+                return (unsigned int)-1;
+            }
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to unsigned int");
+            return (unsigned int)-1;
+        }
+        return (unsigned int)val;
+    }
+    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
+}
+
+static INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
+    if (sizeof(char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(char)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (char)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to char");
+            return (char)-1;
+        }
+        return (char)val;
+    }
+    return (char)__Pyx_PyInt_AsLong(x);
+}
+
+static INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
+    if (sizeof(short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(short)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (short)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to short");
+            return (short)-1;
+        }
+        return (short)val;
+    }
+    return (short)__Pyx_PyInt_AsLong(x);
+}
+
+static INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
+    if (sizeof(int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(int)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (int)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to int");
+            return (int)-1;
+        }
+        return (int)val;
+    }
+    return (int)__Pyx_PyInt_AsLong(x);
+}
+
+static INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
+    if (sizeof(signed char) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed char)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (signed char)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to signed char");
+            return (signed char)-1;
+        }
+        return (signed char)val;
+    }
+    return (signed char)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
+    if (sizeof(signed short) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed short)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (signed short)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to signed short");
+            return (signed short)-1;
+        }
+        return (signed short)val;
+    }
+    return (signed short)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
+    if (sizeof(signed int) < sizeof(long)) {
+        long val = __Pyx_PyInt_AsLong(x);
+        if (unlikely(val != (long)(signed int)val)) {
+            if (unlikely(val == -1 && PyErr_Occurred()))
+                return (signed int)-1;
+            PyErr_SetString(PyExc_OverflowError,
+                           "value too large to convert to signed int");
+            return (signed int)-1;
+        }
+        return (signed int)val;
+    }
+    return (signed int)__Pyx_PyInt_AsSignedLong(x);
+}
+
+static INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return (unsigned long)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        if (unlikely(Py_SIZE(x) < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned long");
+            return (unsigned long)-1;
+        }
+        return PyLong_AsUnsignedLong(x);
+    } else {
+        unsigned long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned long)-1;
+        val = __Pyx_PyInt_AsUnsignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        if (unlikely(val < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return (unsigned PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        if (unlikely(Py_SIZE(x) < 0)) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "can't convert negative value to unsigned PY_LONG_LONG");
+            return (unsigned PY_LONG_LONG)-1;
+        }
+        return PyLong_AsUnsignedLongLong(x);
+    } else {
+        unsigned PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (unsigned PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        return (long)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        return PyLong_AsLong(x);
+    } else {
+        long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (long)-1;
+        val = __Pyx_PyInt_AsLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        return (PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        return PyLong_AsLongLong(x);
+    } else {
+        PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        return (signed long)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        return PyLong_AsLong(x);
+    } else {
+        signed long val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed long)-1;
+        val = __Pyx_PyInt_AsSignedLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+static INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
+#if PY_VERSION_HEX < 0x03000000
+    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
+        long val = PyInt_AS_LONG(x);
+        return (signed PY_LONG_LONG)val;
+    } else
+#endif
+    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
+        return PyLong_AsLongLong(x);
+    } else {
+        signed PY_LONG_LONG val;
+        PyObject *tmp = __Pyx_PyNumber_Int(x);
+        if (!tmp) return (signed PY_LONG_LONG)-1;
+        val = __Pyx_PyInt_AsSignedLongLong(tmp);
+        Py_DECREF(tmp);
+        return val;
+    }
+}
+
+#ifndef __PYX_HAVE_RT_ImportType
+#define __PYX_HAVE_RT_ImportType
+static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
+    long size)
+{
+    PyObject *py_module = 0;
+    PyObject *result = 0;
+    PyObject *py_name = 0;
+
+    py_module = __Pyx_ImportModule(module_name);
+    if (!py_module)
+        goto bad;
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(class_name);
+    #else
+    py_name = PyUnicode_FromString(class_name);
+    #endif
+    if (!py_name)
+        goto bad;
+    result = PyObject_GetAttr(py_module, py_name);
+    Py_DECREF(py_name);
+    py_name = 0;
+    Py_DECREF(py_module);
+    py_module = 0;
+    if (!result)
+        goto bad;
+    if (!PyType_Check(result)) {
+        PyErr_Format(PyExc_TypeError, 
+            "%s.%s is not a type object",
+            module_name, class_name);
+        goto bad;
+    }
+    if (((PyTypeObject *)result)->tp_basicsize != size) {
+        PyErr_Format(PyExc_ValueError, 
+            "%s.%s does not appear to be the correct type object",
+            module_name, class_name);
+        goto bad;
+    }
+    return (PyTypeObject *)result;
+bad:
+    Py_XDECREF(py_module);
+    Py_XDECREF(result);
+    return 0;
+}
+#endif
+
+#ifndef __PYX_HAVE_RT_ImportModule
+#define __PYX_HAVE_RT_ImportModule
+static PyObject *__Pyx_ImportModule(const char *name) {
+    PyObject *py_name = 0;
+    PyObject *py_module = 0;
+
+    #if PY_MAJOR_VERSION < 3
+    py_name = PyString_FromString(name);
+    #else
+    py_name = PyUnicode_FromString(name);
+    #endif
+    if (!py_name)
+        goto bad;
+    py_module = PyImport_Import(py_name);
+    Py_DECREF(py_name);
+    return py_module;
+bad:
+    Py_XDECREF(py_name);
+    return 0;
+}
+#endif
+
+#include "compile.h"
+#include "frameobject.h"
+#include "traceback.h"
+
+static void __Pyx_AddTraceback(const char *funcname) {
+    PyObject *py_srcfile = 0;
+    PyObject *py_funcname = 0;
+    PyObject *py_globals = 0;
+    PyObject *empty_string = 0;
+    PyCodeObject *py_code = 0;
+    PyFrameObject *py_frame = 0;
+
+    #if PY_MAJOR_VERSION < 3
+    py_srcfile = PyString_FromString(__pyx_filename);
+    #else
+    py_srcfile = PyUnicode_FromString(__pyx_filename);
+    #endif
+    if (!py_srcfile) goto bad;
+    if (__pyx_clineno) {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
+        #else
+        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
+        #endif
+    }
+    else {
+        #if PY_MAJOR_VERSION < 3
+        py_funcname = PyString_FromString(funcname);
+        #else
+        py_funcname = PyUnicode_FromString(funcname);
+        #endif
+    }
+    if (!py_funcname) goto bad;
+    py_globals = PyModule_GetDict(__pyx_m);
+    if (!py_globals) goto bad;
+    #if PY_MAJOR_VERSION < 3
+    empty_string = PyString_FromStringAndSize("", 0);
+    #else
+    empty_string = PyBytes_FromStringAndSize("", 0);
+    #endif
+    if (!empty_string) goto bad;
+    py_code = PyCode_New(
+        0,            /*int argcount,*/
+        #if PY_MAJOR_VERSION >= 3
+        0,            /*int kwonlyargcount,*/
+        #endif
+        0,            /*int nlocals,*/
+        0,            /*int stacksize,*/
+        0,            /*int flags,*/
+        empty_string, /*PyObject *code,*/
+        __pyx_empty_tuple,  /*PyObject *consts,*/
+        __pyx_empty_tuple,  /*PyObject *names,*/
+        __pyx_empty_tuple,  /*PyObject *varnames,*/
+        __pyx_empty_tuple,  /*PyObject *freevars,*/
+        __pyx_empty_tuple,  /*PyObject *cellvars,*/
+        py_srcfile,   /*PyObject *filename,*/
+        py_funcname,  /*PyObject *name,*/
+        __pyx_lineno,   /*int firstlineno,*/
+        empty_string  /*PyObject *lnotab*/
+    );
+    if (!py_code) goto bad;
+    py_frame = PyFrame_New(
+        PyThreadState_GET(), /*PyThreadState *tstate,*/
+        py_code,             /*PyCodeObject *code,*/
+        py_globals,          /*PyObject *globals,*/
+        0                    /*PyObject *locals*/
+    );
+    if (!py_frame) goto bad;
+    py_frame->f_lineno = __pyx_lineno;
+    PyTraceBack_Here(py_frame);
+bad:
+    Py_XDECREF(py_srcfile);
+    Py_XDECREF(py_funcname);
+    Py_XDECREF(empty_string);
+    Py_XDECREF(py_code);
+    Py_XDECREF(py_frame);
+}
+
+static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
+    while (t->p) {
+        #if PY_MAJOR_VERSION < 3
+        if (t->is_unicode && (!t->is_identifier)) {
+            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
+        } else if (t->intern) {
+            *t->p = PyString_InternFromString(t->s);
+        } else {
+            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
+        }
+        #else  /* Python 3+ has unicode identifiers */
+        if (t->is_identifier || (t->is_unicode && t->intern)) {
+            *t->p = PyUnicode_InternFromString(t->s);
+        } else if (t->is_unicode) {
+            *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
+        } else {
+            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
+        }
+        #endif
+        if (!*t->p)
+            return -1;
+        ++t;
+    }
+    return 0;
+}
+
+/* Type Conversion Functions */
+
+static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
+   if (x == Py_True) return 1;
+   else if ((x == Py_False) | (x == Py_None)) return 0;
+   else return PyObject_IsTrue(x);
+}
+
+static INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
+  PyNumberMethods *m;
+  const char *name = NULL;
+  PyObject *res = NULL;
+#if PY_VERSION_HEX < 0x03000000
+  if (PyInt_Check(x) || PyLong_Check(x))
+#else
+  if (PyLong_Check(x))
+#endif
+    return Py_INCREF(x), x;
+  m = Py_TYPE(x)->tp_as_number;
+#if PY_VERSION_HEX < 0x03000000
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Int(x);
+  }
+  else if (m && m->nb_long) {
+    name = "long";
+    res = PyNumber_Long(x);
+  }
+#else
+  if (m && m->nb_int) {
+    name = "int";
+    res = PyNumber_Long(x);
+  }
+#endif
+  if (res) {
+#if PY_VERSION_HEX < 0x03000000
+    if (!PyInt_Check(res) && !PyLong_Check(res)) {
+#else
+    if (!PyLong_Check(res)) {
+#endif
+      PyErr_Format(PyExc_TypeError,
+                   "__%s__ returned non-%s (type %.200s)",
+                   name, name, Py_TYPE(res)->tp_name);
+      Py_DECREF(res);
+      return NULL;
+    }
+  }
+  else if (!PyErr_Occurred()) {
+    PyErr_SetString(PyExc_TypeError,
+                    "an integer is required");
+  }
+  return res;
+}
+
+static INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
+  Py_ssize_t ival;
+  PyObject* x = PyNumber_Index(b);
+  if (!x) return -1;
+  ival = PyInt_AsSsize_t(x);
+  Py_DECREF(x);
+  return ival;
+}
+
+static INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
+#if PY_VERSION_HEX < 0x02050000
+   if (ival <= LONG_MAX)
+       return PyInt_FromLong((long)ival);
+   else {
+       unsigned char *bytes = (unsigned char *) &ival;
+       int one = 1; int little = (int)*(unsigned char*)&one;
+       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
+   }
+#else
+   return PyInt_FromSize_t(ival);
+#endif
+}
+
+static INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
+   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
+   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
+       return (size_t)-1;
+   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
+       PyErr_SetString(PyExc_OverflowError,
+                       "value too large to convert to size_t");
+       return (size_t)-1;
+   }
+   return (size_t)val;
+}
+
+
diff --git a/pandas/lib/src/tseries.pyx b/pandas/lib/src/tseries.pyx
new file mode 100644
index 000000000..171f2ee03
--- /dev/null
+++ b/pandas/lib/src/tseries.pyx
@@ -0,0 +1,1019 @@
+include "numpy.pxi"
+include "datetime.pxi"
+include "Python.pxi"
+
+# initialize numpy
+import_array()
+
+import numpy as np
+cimport numpy as np
+
+isnan = np.isnan
+cdef double NaN = <double> np.NaN
+
+from datetime import datetime as pydatetime
+
+from python_dict cimport *
+from numpy cimport ndarray, npy_float64, npy_int32, npy_int8, npy_float128
+
+cimport cython
+
+cdef inline object trycall(object func, object arg):
+    cdef object result
+    try:
+        result = func(arg)
+    except:
+        raise Exception('Error calling func on index %s' % arg)
+    return result
+
+cdef inline int int_max(int a, int b): return a if a >= b else b
+cdef inline int int_min(int a, int b): return a if a >= b else b
+
+def map_indices(ndarray index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+    
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+        
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef int i, length
+    cdef flatiter iter
+    cdef dict result
+    cdef object idx
+        
+    result = {}
+    
+    iter = PyArray_IterNew(index)
+
+    length = PyArray_SIZE(index)
+        
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(index, <void *> iter.dataptr)
+        result[idx] = i
+        PyArray_ITER_NEXT(iter)
+        
+    return result
+
+def match(ndarray A, ndarray B):
+    '''
+    --> match(a, b)
+    
+    Close equivalent of R's match function.
+    
+    For given input index A, find matching locations for values of A in B.
+    
+    Example:
+    >>> b
+    array([[ 0.        ,  0.26929312],
+           [ 1.        ,  0.49540359],
+           [ 2.        ,  0.66389941],
+           [ 3.        ,  0.66235806],
+           [ 4.        ,  0.97993956],
+           [ 5.        ,  0.83804732],
+           [ 6.        ,  0.75033074],
+           [ 7.        ,  0.10250388],
+           [ 8.        ,  0.66591799],
+           [ 9.        ,  0.18337242]])
+    >>> a
+        array([1, 3, 6, 8, 4, 5, 7, 0, 2, 9])
+    
+    # Now with match we can realign b based on a
+    
+    >>> b[match(a, b[:,0]),:]
+    array([[ 1.        ,  0.49540359],
+           [ 3.        ,  0.66235806],
+           [ 6.        ,  0.75033074],
+           [ 8.        ,  0.66591799],
+           [ 4.        ,  0.97993956],
+           [ 5.        ,  0.83804732],
+           [ 7.        ,  0.10250388],
+           [ 0.        ,  0.26929312],
+           [ 2.        ,  0.66389941],
+           [ 9.        ,  0.18337242]])
+   
+    '''
+    
+    cdef int i, length
+    cdef flatiter itera
+    cdef dict bmap
+    cdef double *result_data
+    cdef double nan
+    cdef object idx
+    cdef ndarray result
+
+    nan = <double> np.NaN
+    
+    bmap = map_indices(B)
+        
+    itera = PyArray_IterNew(A)
+    length = PyArray_SIZE(A)
+    
+    result = <ndarray> np.empty(length, np.float64)
+
+    result_data = <double *> result.data    
+    
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(A, <void *> itera.dataptr)
+        if idx in bmap:
+            result_data[i] = <double> bmap[idx]
+        else:
+            result_data[i] = nan
+            
+        PyArray_ITER_NEXT(itera)
+    
+    return result.astype(int)
+    
+def reindex(ndarray index, ndarray arr, dict idxMap):
+    '''
+    Using the provided new index, a given array, and a mapping of index-value
+    correpondences in the value array, return a new ndarray conforming to 
+    the new index.
+    
+    This is significantly faster than doing it in pure Python.
+    '''
+    cdef ndarray result
+    cdef double *result_data
+    cdef int i, length
+    cdef flatiter itera, iteridx
+    cdef double nan
+    cdef object idx
+    
+    nan = <double> np.NaN
+
+    length = PyArray_SIZE(index)
+    
+    result = <ndarray> np.empty(length, np.float64)
+
+    result_data = <double *> result.data
+
+    itera = PyArray_IterNew(arr)
+    iteridx = PyArray_IterNew(index)
+
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+        PyArray_ITER_NEXT(iteridx)
+        if idx not in idxMap:
+            result_data[i] = nan
+            continue
+        PyArray_ITER_GOTO1D(itera, idxMap[idx])
+        result_data[i] = (<double *>(itera.dataptr))[0]
+
+    return result
+
+def reindexObj(ndarray index, ndarray arr, dict idxMap):
+    '''
+    Using the provided new index, a given array, and a mapping of index-value
+    correpondences in the value array, return a new ndarray conforming to 
+    the new index.
+    
+    This is significantly faster than doing it in pure Python.
+    '''
+    cdef ndarray result
+    cdef int i, length
+    cdef flatiter itera, iteridx, iterresult
+    cdef object idx, nan, obj
+
+    nan = np.NaN
+    length = PyArray_SIZE(index)
+
+    result = <ndarray> np.empty(length, dtype=np.object_)    
+
+    itera = PyArray_IterNew(arr)
+    iteridx = PyArray_IterNew(index)
+    iterresult = PyArray_IterNew(result)
+
+    cdef int res
+
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+        PyArray_ITER_NEXT(iteridx)
+        
+        if idx not in idxMap:
+            PyArray_SETITEM(result, <void *> iterresult.dataptr, nan)
+            PyArray_ITER_NEXT(iterresult)
+            continue
+            
+        PyArray_ITER_GOTO1D(itera, idxMap[idx])
+        obj = PyArray_GETITEM(arr, <void *> itera.dataptr)        
+        
+        res = PyArray_SETITEM(result, <void *> iterresult.dataptr, obj)
+        PyArray_ITER_NEXT(iterresult)
+        
+    return result
+
+@cython.boundscheck(False)
+def reindexObject(ndarray[object, ndim=1] index, 
+                  ndarray[object, ndim=1] arr,
+                  dict idxMap):
+    '''
+    Using the provided new index, a given array, and a mapping of index-value
+    correpondences in the value array, return a new ndarray conforming to 
+    the new index.
+    '''
+    cdef int j, loc, length
+    cdef object idx, value
+    cdef object nan = np.NaN
+
+    length = index.shape[0]
+    cdef ndarray[object, ndim = 1] result = np.empty(length, dtype=object)
+    
+    loc = 0
+    cdef int i = 0
+    for i from 0 <= i < length:
+        idx = index[i]
+        if not PyDict_Contains(idxMap, idx):
+            result[i] = nan
+            continue
+        value = arr[idxMap[idx]]
+        result[i] = value
+    return result
+
+cdef tuple _nofill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+    cdef int *fillLocs
+    cdef char *mask
+    cdef int i, j, length, newLength
+
+    cdef flatiter iterold
+    cdef object idx
+    cdef ndarray fillVec
+    cdef ndarray maskVec
+    
+    fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+    maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+
+    fillLocs = <int *> fillVec.data
+    mask = <char *> maskVec.data
+    
+    newLength = PyArray_SIZE(fillVec)    
+    
+    length = PyArray_SIZE(oldIndex)
+    iterold = PyArray_IterNew(oldIndex)
+
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+        if i < length - 1:
+           PyArray_ITER_NEXT(iterold)
+        if idx in newMap:
+            j = newMap[idx]
+            fillLocs[j] = i
+            mask[j] = 1
+
+    for i from 0 <= i < newLength:
+        if mask[i] == 0:
+            fillLocs[i] = -1
+
+    return fillVec, maskVec
+
+cdef tuple _backfill(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+    
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc 
+    # Make empty vectors
+    cdef ndarray fillVec
+    cdef ndarray maskVec
+    fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+    maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+    
+    # Get references
+    cdef int *fillLocs
+    cdef char *mask
+    fillLocs = <int *> fillVec.data
+    mask = <char *> maskVec.data
+    
+    # Create the iterators
+    cdef flatiter iterold, iternew
+    iterold = PyArray_IterNew(oldIndex)
+    iternew = PyArray_IterNew(newIndex)
+    
+    # Get the size
+    oldLength = PyArray_SIZE(oldIndex)
+    newLength = PyArray_SIZE(newIndex)
+    
+    # Current positions
+    cdef int newPos, oldPos
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+    
+    # References holding indices
+    cdef object prevOld, curOld
+    
+    while newPos >= 0:
+        # Move to the current position
+        PyArray_ITER_GOTO1D(iternew, newPos)
+        PyArray_ITER_GOTO1D(iterold, oldPos)
+        
+        # Get the current index
+        curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+        
+        # Until we reach a point where we are before the curOld point
+        while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+            PyArray_ITER_GOTO1D(iternew, newPos)
+        
+        # Get the location in the old index
+        curLoc = oldMap[curOld]
+        
+        # At the beginning of the old index
+        if oldPos == 0:
+
+            # Make sure we are before the curOld index
+            if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) <= curOld:
+                fillVec[:newPos + 1] = curLoc
+                maskVec[:newPos + 1] = 1
+            
+            # Exit the main loop
+            break
+
+        else:
+            # Move one position back
+            PyArray_ITER_GOTO1D(iterold, oldPos - 1)
+            
+            # Get the index there
+            prevOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+            
+            # Until we reach the previous index
+            while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) > prevOld:
+
+                # Set the current fill location
+                fillLocs[newPos] = curLoc
+                mask[newPos] = 1
+                
+                newPos -= 1
+                if newPos < 0:
+                    break
+                
+                # Move the iterator back
+                PyArray_ITER_GOTO1D(iternew, newPos)
+        
+        # Move one period back
+        oldPos -= 1
+
+    for i from 0 <= i < newLength:
+        if mask[i] == 0:
+            # Fill from some generic location
+            fillLocs[i] = -1
+
+    return (fillVec, maskVec)
+
+cdef tuple _pad(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+    
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+
+    # Declare variables
+    cdef ndarray fillVec
+    cdef ndarray maskVec
+    cdef int *fillLocs
+    cdef char *mask
+    cdef int i, j, oldLength, newLength, curLoc, newPos, oldPos
+    cdef flatiter iterold, iternew
+    cdef object nextOld, curOld
+    cdef char done
+    
+    # Make empty fill vector and mask vector, cast to ndarray
+    fillVec = <ndarray> np.empty(len(newIndex), dtype = np.int32)
+    maskVec = <ndarray> np.zeros(len(newIndex), dtype = np.int8)
+    
+    # Get reference to the arrays inside
+    fillLocs = <int *> fillVec.data
+    mask = <char *> maskVec.data
+    
+    # Create simple ndarray iterators using C API
+    iterold = PyArray_IterNew(oldIndex)
+    iternew = PyArray_IterNew(newIndex)
+    
+    # Length of each index
+    oldLength = PyArray_SIZE(oldIndex)
+    newLength = PyArray_SIZE(newIndex)
+
+    oldPos = 0
+    newPos = 0
+    while newPos < newLength:
+        curOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+
+        # At beginning, keep going until we go exceed the 
+        # first OLD index in the NEW index
+        while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+            PyArray_ITER_NEXT(iternew)
+
+        # We got there, get the current location in the old index
+        curLoc = oldMap[curOld]
+
+        # We're at the end of the road, need to propagate this value to the end
+        if oldPos == oldLength - 1:
+            if PyArray_GETITEM(newIndex, <void *> iternew.dataptr) >= curOld:
+                fillVec[newPos:] = curLoc
+                maskVec[newPos:] = 1
+            break
+        else:
+            # Not at the end, need to go about filling
+
+            # Get the next index so we know when to stop propagating this value
+            PyArray_ITER_NEXT(iterold)
+            nextOld = PyArray_GETITEM(oldIndex, <void *> iterold.dataptr)
+
+            done = 0
+            
+            # Until we reach the next OLD value in the NEW index
+            while PyArray_GETITEM(newIndex, <void *> iternew.dataptr) < nextOld:
+                
+                # Use this location to fill
+                fillLocs[newPos] = curLoc
+
+                # Set mask to be 1 so will not be NaN'd
+                mask[newPos] = 1
+                newPos += 1
+                
+                # We got to the end of the new index
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+                
+                # Advance the pointer
+                PyArray_ITER_NEXT(iternew)
+
+            # We got to the end of the new index
+            if done:
+                break
+            
+        # We already advanced the iterold pointer to the next value, 
+        # inc the count
+        oldPos += 1
+
+    # Places where the mask is 0, fill with an arbitrary value 
+    # (will be NA'd out)
+    for i from 0 <= i < newLength:
+        if mask[i] == 0:
+            fillLocs[i] = -1
+
+    return fillVec, maskVec
+
+def getFillVec(ndarray oldIndex, ndarray newIndex, dict oldMap, dict newMap, 
+               object kind):
+
+    if kind == '':
+        fillVec, maskVec = _nofill(oldIndex, newIndex, oldMap, newMap)
+    elif kind == 'PAD':
+        fillVec, maskVec = _pad(oldIndex, newIndex, oldMap, newMap)
+    elif kind == 'BACKFILL':
+        fillVec, maskVec = _backfill(oldIndex, newIndex, oldMap, newMap)
+    
+    return fillVec, maskVec.astype(np.bool)
+
+def getMergeVec(ndarray values, dict indexMap):
+    cdef int *fillLocs    
+    cdef char *mask
+    cdef int i, j, length
+    
+    cdef flatiter itervals
+    cdef object val
+    cdef ndarray fillVec
+    cdef ndarray maskVec
+    
+    cdef int newLength = len(values)
+    
+    fillVec = <ndarray> np.empty(newLength, dtype = np.int32)
+    maskVec = <ndarray> np.zeros(newLength, dtype = np.int8)
+
+    fillLocs = <int *> fillVec.data
+    mask = <char *> maskVec.data
+        
+    length = PyArray_SIZE(values)
+    itervals = PyArray_IterNew(values)
+
+    for i from 0 <= i < length:
+        val = PyArray_GETITEM(values, <void *> itervals.dataptr)
+        if val in indexMap:
+            j = indexMap[val]
+            fillLocs[i] = j
+            mask[i] = 1
+
+        PyArray_ITER_NEXT(itervals)
+            
+    for i from 0 <= i < newLength:
+        if mask[i] == 0:
+            fillLocs[i] = -1
+
+    return fillVec, maskVec.astype(np.bool)
+
+cdef double INF = <double> np.inf
+cdef double NEGINF = -INF
+
+cdef inline _checknull(object val):
+    return val is None or val != val or val == INF or val == NEGINF    
+
+cdef ndarray _isnullobj(input):
+    cdef int i, length
+    cdef object val
+    cdef ndarray[npy_int8, ndim=1] result    
+    cdef flatiter iter 
+
+    length = PyArray_SIZE(input)
+    
+    result = <ndarray> np.zeros(length, dtype=np.int8)
+    
+    iter= PyArray_IterNew(input)
+            
+    for i from 0 <= i < length:
+        val = PyArray_GETITEM(input, <void *> iter.dataptr)
+        
+        if _checknull(val):
+            result[i] = 1
+
+        PyArray_ITER_NEXT(iter)
+            
+    return result
+    
+def isnull(input):    
+    '''
+    Replacement for numpy.isnan / -numpy.isfinite which is suitable
+    for use on object arrays.
+
+    Parameters
+    ----------
+    arr: ndarray or object value
+    
+    Returns
+    -------
+    boolean ndarray or boolean
+    '''
+    cdef ndarray[npy_int8, ndim=1] result
+    
+    if isinstance(input, np.ndarray):
+        if input.dtype.kind in ('O', 'S'):
+            result = _isnullobj(input)
+            
+            return result.astype(np.bool)
+        else:
+            return -np.isfinite(input)
+    else:
+        return _checknull(input)
+    
+def notnull(input):    
+    '''
+    Replacement for numpy.isfinite / -numpy.isnan which is suitable
+    for use on object arrays.
+    
+    Parameters
+    ----------
+    arr: ndarray or object value
+    
+    Returns
+    -------
+    boolean ndarray or boolean
+    '''
+    if isinstance(input, np.ndarray):
+        return -isnull(input)
+    else:
+        return not bool(_checknull(input))
+    
+def reindexNew(ndarray index, ndarray arr, dict idxMap):
+    '''
+    Using the provided new index, a given array, and a mapping of index-value
+    correpondences in the value array, return a new ndarray conforming to 
+    the new index.
+    
+    This is significantly faster than doing it in pure Python.
+    '''
+    cdef ndarray result
+    cdef double *result_data
+    cdef int i, length
+    cdef flatiter itera, iteridx
+    cdef double nan
+    cdef object idx
+    
+    nan = <double> np.NaN
+
+    length = PyArray_SIZE(index)
+    
+    result = <ndarray> np.empty(length, np.float64)
+
+    result_data = <double *> result.data
+
+    itera = PyArray_IterNew(arr)
+    iteridx = PyArray_IterNew(index)
+
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+        PyArray_ITER_NEXT(iteridx)
+        if idx not in idxMap:
+            result_data[i] = nan
+            continue
+        PyArray_ITER_GOTO1D(itera, idxMap[idx])
+        result_data[i] = (<double *>(itera.dataptr))[0]
+
+    return result
+    
+cdef double __add(double a, double b):
+    return a + b
+cdef double __sub(double a, double b):
+    return a - b
+cdef double __div(double a, double b):
+    return a / b
+cdef double __mul(double a, double b):
+    return a * b
+cdef double __eq(double a, double b):
+    return a == b
+cdef double __ne(double a, double b):
+    return a != b
+cdef double __lt(double a, double b):
+    return a < b
+cdef double __gt(double a, double b):
+    return a > b
+cdef double __pow(double a, double b):
+    return a ** b
+
+ctypedef double (* double_func)(double a, double b)
+
+cdef ndarray _applyFunc(double_func func, ndarray index, object ao, 
+                        object bo, dict aMap, dict bMap):
+    '''
+    C function taking a function pointer for quickly adding two Series objects.
+    '''
+    cdef ndarray A, B, result
+    cdef double *result_data
+    cdef int i, length
+    cdef flatiter itera, iterb, iteridx
+    cdef double nan
+    cdef object idx
+    
+    # This is EXTREMELY important, otherwise you will get very 
+    # undesired results
+    A = PyArray_ContiguousFromAny(ao, NPY_DOUBLE, 1, 1)
+    B = PyArray_ContiguousFromAny(bo, NPY_DOUBLE, 1, 1)
+
+    nan = <double> np.NaN
+    length = PyArray_SIZE(index)
+    
+    result = <ndarray> np.empty(length, np.float64)
+    result_data = <double *>result.data
+    
+    itera = <flatiter> PyArray_IterNew(A)
+    iterb = <flatiter> PyArray_IterNew(B)
+    iteridx = PyArray_IterNew(index)
+    
+    for i from 0 <= i < length:
+        idx = PyArray_GETITEM(index, <void *> iteridx.dataptr)
+        PyArray_ITER_NEXT(iteridx)
+        
+        if idx not in aMap or idx not in bMap:
+            result_data[i] = nan
+            continue
+
+        result_data[i] = func((<double *>A.data)[aMap[idx]], 
+                            (<double *>B.data)[bMap[idx]])
+                                         
+    return result
+    
+def combineFunc(object name, ndarray index, object ao, 
+                object bo, dict aMap, dict bMap):
+    '''
+    Combine two series (values and index maps for each passed in) using the 
+    indicated function.
+    '''
+    if name == "__add__":
+        return _applyFunc(__add, index, ao, bo, aMap, bMap)
+    elif name == "__sub__":
+        return _applyFunc(__sub, index, ao, bo, aMap, bMap)
+    elif name == "__div__":
+        return _applyFunc(__div, index, ao, bo, aMap, bMap)
+    elif name == "__mul__":
+        return _applyFunc(__mul, index, ao, bo, aMap, bMap)
+    elif name == "__eq__":
+        return _applyFunc(__eq, index, ao, bo, aMap, bMap)
+    elif name == "__ne__":
+        return _applyFunc(__ne, index, ao, bo, aMap, bMap)
+    elif name == "__lt__":
+        return _applyFunc(__lt, index, ao, bo, aMap, bMap)
+    elif name == "__gt__":
+        return _applyFunc(__gt, index, ao, bo, aMap, bMap)
+    elif name == "__pow__":
+        return _applyFunc(__pow, index, ao, bo, aMap, bMap)
+    else:
+        raise Exception('bad funcname requested of Cython code')
+        
+#-------------------------------------------------------------------------------
+# Groupby-related functions
+
+@cython.boundscheck(False)
+def arrmap(ndarray[object, ndim=1] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object, ndim=1] result = np.empty(length, dtype=np.object_)
+    
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+    
+    return result
+
+@cython.boundscheck(False)
+def groupby_withnull_old(ndarray[object, ndim = 1] index, object keyfunc):
+    cdef dict groups
+    cdef int length = index.shape[0]
+    cdef object idx
+    cdef object curKey, key
+    cdef list members
+    
+    groups = PyDict_New()
+    
+    if length != index.shape[0]:
+        raise Exception('Dates and values were not the same length!')
+
+    cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+
+    cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+    
+    bool_mask = null_mask.astype(bool)    
+    
+    null_values = np.asarray(index)[bool_mask]
+    
+    if null_values.any():
+        PyDict_SetItem(groups, np.NaN, null_values)
+    
+    cdef int i = 0
+    idx = index[0]    
+    key = mapped_index[0]
+    
+    # Algorithm notes
+    #   - Tries to reduce the number of calls to PyDict_GetItem, 
+    #   'lazily' evaluates
+    
+    while i < length:    
+        if not PyDict_Contains(groups, key):
+            members = [idx]
+            PyDict_SetItem(groups, key, members)
+            i += 1
+            curKey = key            
+            while i < length:
+                if null_mask[i]:
+                    i += 1
+                    continue
+                    
+                idx = index[i]
+                key = mapped_index[i]
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+        else:
+            members = <list> PyDict_GetItem(groups, key)
+            members.append(idx)
+            i += 1
+            curKey = key
+            while null_mask[i] and i < length:
+                i += 1
+
+            while i < length:
+                if null_mask[i]:
+                    i += 1
+                    continue
+
+                idx = index[i]
+                key = mapped_index[i]
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+    
+    return groups 
+
+@cython.boundscheck(False)
+def groupby_withnull(ndarray[object, ndim = 1] index, object keyfunc):
+    cdef dict groups
+    cdef int length = index.shape[0]
+    cdef object idx
+    cdef object curKey, key
+    cdef list members
+    
+    groups = PyDict_New()
+    
+    if length != index.shape[0]:
+        raise Exception('Dates and values were not the same length!')
+
+    cdef ndarray[object, ndim=1] mapped_index = arrmap(index, keyfunc)
+
+    cdef ndarray[npy_int8, ndim=1] null_mask = _isnullobj(mapped_index)
+    
+    bool_mask = null_mask.astype(bool)    
+    
+    null_values = np.asarray(index)[bool_mask]
+    
+    if null_values.any():
+        PyDict_SetItem(groups, np.NaN, null_values)
+    
+    cdef int i = 0
+    idx = index[0]    
+    key = mapped_index[0]
+
+    # Algorithm notes
+    #   - Tries to reduce the number of calls to PyDict_GetItem, 
+    #   'lazily' evaluates
+    
+    while i < length:    
+        if key not in groups:
+            members = [idx]
+            groups[key] = members
+            i += 1
+            curKey = key            
+            while i < length:
+                if null_mask[i]:
+                    i += 1
+                    continue
+                    
+                idx = index[i]
+                key = mapped_index[i]
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+        else:
+            members = <list> groups[key]
+            members.append(idx)
+            i += 1
+            curKey = key
+            while null_mask[i] and i < length:
+                i += 1
+
+            while i < length:
+                if null_mask[i]:
+                    i += 1
+                    continue
+
+                idx = index[i]
+                key = mapped_index[i]
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+    
+    return groups 
+    
+@cython.boundscheck(False)
+def groupby(ndarray[object, ndim = 1] index, object keyfunc):
+    cdef dict groups
+    cdef int length = index.shape[0]
+    cdef object idx
+    cdef object curKey, key
+    cdef list members
+    
+    groups = PyDict_New()
+    
+    if length != index.shape[0]:
+        raise Exception('Dates and values were not the same length!')
+
+    cdef int i = 0
+    idx = index[i]
+    key = keyfunc(idx)
+
+    # Algorithm notes
+    #   - Tries to reduce the number of calls to PyDict_GetItem, 'lazily' evaluates
+    
+    while i < length:
+        if not PyDict_Contains(groups, key):
+            members = [idx]
+            PyDict_SetItem(groups, key, members)
+            i += 1
+            curKey = key
+            while i < length:
+                idx = index[i]
+                key = trycall(keyfunc, idx)
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+        else:
+            members = <list> PyDict_GetItem(groups, key)
+            members.append(idx)
+            i += 1
+            curKey = key
+            while i < length:
+                idx = index[i]
+                key = trycall(keyfunc, idx)
+                if key == curKey:
+                    members.append(idx)
+                    i += 1
+                else:
+                    break
+    
+    return groups
+    
+@cython.boundscheck(False)
+def groupbyfunc(ndarray[object, ndim = 1] index, 
+                ndarray[npy_float64, ndim = 1] values, 
+                object keyfunc, object applyfunc):
+    '''
+    Doing this proper in Cython
+    Not sure how much it will really speed things up
+    '''
+    cdef dict groups
+    cdef int length = values.shape[0]
+    cdef object idx
+    cdef object curKey, key
+    cdef list members, grouplist
+    
+    groups = PyDict_New()
+    
+    if length != index.shape[0]:
+        raise Exception('Dates and values were not the same length!')
+
+    cdef int i = 0
+    idx = index[i]
+    key = trycall(keyfunc, idx)
+
+    # Algorithm notes
+    #   - Tries to reduce the number of calls to PyDict_GetItem, 
+    #   'lazily' evaluates
+    
+    while i < length:        
+        if not PyDict_Contains(groups, key):
+            members = [values[i]]
+            PyDict_SetItem(groups, key, members)
+            i += 1
+            curKey = key
+            while i < length:
+                idx = index[i]
+                key = trycall(keyfunc, idx)
+                if key == curKey:
+                    members.append(values[i])
+                    i += 1
+                else:
+                    break
+        else:
+            members = <list> PyDict_GetItem(groups, key)
+            members.append(values[i])
+            i += 1
+            curKey = key
+            while i < length:
+                idx = index[i]
+                key = trycall(keyfunc, idx)
+                if key == curKey:
+                    members.append(values[i])
+                    i += 1
+                else:
+                    break
+
+    grouplist = PyDict_Keys(groups)
+    
+    i = 0
+    length = len(grouplist)
+    for i from 0 <= i < length:
+        key = grouplist[i]
+        members = <list> PyDict_GetItem(groups, key)
+        PyDict_SetItem(groups, key, applyfunc(np.asarray(members)))
+    
+    return groups
+
diff --git a/setup.py b/setup.py
new file mode 100644
index 000000000..fd9e30914
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,51 @@
+#/usr/bin/env python
+
+# Do not add setuptools here; use setupegg.py instead. Nose still has problems running
+# tests inside of egg packages, so it is useful to be able to install without eggs as needed.
+
+from distutils.core import Extension
+from numpy.distutils.misc_util import Configuration
+from numpy.distutils.system_info import get_info
+import numpy
+import os
+import sys
+
+config = Configuration('pandas', parent_package=None, top_path=None)
+
+cython_ext = Extension('pandas.lib.tseries', ['pandas/lib/src/tseries.c'], 
+                       include_dirs=[numpy.get_include(),
+                                     'pandas/lib/include/']) 
+
+dates_ext = Extension('pandas.lib.tdates', ['pandas/lib/src/tdates.c'])
+
+config_dict = config.todict()
+try:
+    config_dict.pop('packages')
+except:
+    pass
+
+if __name__ == '__main__':
+    from numpy.distutils.core import setup
+    setup(version="0.1",
+          description="Panel and time series data analysis toolkit",
+          author="AQR Capital Management, LLC",
+          author_email='wesmckinn@gmail.com',
+          url="pandas.googlecode.com",
+          license="BSD License",
+          classifiers=[
+            'Development Status :: 2 - Pre-Alpha',
+            'Environment :: Console',
+            'Operating System :: OS Independent',
+            'Intended Audience :: Science/Research',
+            'Programming Language :: Python',
+            'Programming Language :: Cython',
+            'Topic :: Scientific/Engineering',
+            ],
+          requires=['NumPy (>=1.2)',],
+          platforms='any',
+          long_description="""
+          """,
+          packages=["pandas", "pandas.core", "pandas.core.tests", "pandas.io",
+                    "pandas.lib"],
+          ext_modules=[cython_ext, dates_ext],
+          **(config_dict))
diff --git a/setupegg.py b/setupegg.py
new file mode 100644
index 000000000..53c1b3dab
--- /dev/null
+++ b/setupegg.py
@@ -0,0 +1,7 @@
+#!/usr/bin/env python
+"""
+A setup.py script to use setuptools.
+"""
+
+from setuptools import setup
+execfile('setup.py')

commit 8ad5c12de3c1497ffb593d46df8ff9a46dfe3ced
Author: ganevgv <ganevgv@users.noreply.github.com>
Date:   Thu Nov 14 16:47:48 2019 +0200

    TST: add test for .unique() dtype preserving (#29515)

diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index ef844dd97..0bc09ddc4 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -10,6 +10,13 @@ from pandas._libs import algos as libalgos, groupby as libgroupby, hashtable as
 from pandas.compat.numpy import np_array_datetime64_compat
 import pandas.util._test_decorators as td
 
+from pandas.core.dtypes.common import (
+    is_bool_dtype,
+    is_complex_dtype,
+    is_float_dtype,
+    is_integer_dtype,
+    is_object_dtype,
+)
 from pandas.core.dtypes.dtypes import CategoricalDtype as CDT
 
 import pandas as pd
@@ -23,6 +30,7 @@ from pandas import (
     Timestamp,
     compat,
 )
+from pandas.conftest import BYTES_DTYPES, STRING_DTYPES
 import pandas.core.algorithms as algos
 from pandas.core.arrays import DatetimeArray
 import pandas.core.common as com
@@ -352,6 +360,35 @@ class TestUnique:
 
         tm.assert_almost_equal(result, expected)
 
+    def test_dtype_preservation(self, any_numpy_dtype):
+        # GH 15442
+        if any_numpy_dtype in (BYTES_DTYPES + STRING_DTYPES):
+            pytest.skip("skip string dtype")
+        elif is_integer_dtype(any_numpy_dtype):
+            data = [1, 2, 2]
+            uniques = [1, 2]
+        elif is_float_dtype(any_numpy_dtype):
+            data = [1, 2, 2]
+            uniques = [1.0, 2.0]
+        elif is_complex_dtype(any_numpy_dtype):
+            data = [complex(1, 0), complex(2, 0), complex(2, 0)]
+            uniques = [complex(1, 0), complex(2, 0)]
+        elif is_bool_dtype(any_numpy_dtype):
+            data = [True, True, False]
+            uniques = [True, False]
+        elif is_object_dtype(any_numpy_dtype):
+            data = ["A", "B", "B"]
+            uniques = ["A", "B"]
+        else:
+            # datetime64[ns]/M8[ns]/timedelta64[ns]/m8[ns] tested elsewhere
+            data = [1, 2, 2]
+            uniques = [1, 2]
+
+        result = Series(data, dtype=any_numpy_dtype).unique()
+        expected = np.array(uniques, dtype=any_numpy_dtype)
+
+        tm.assert_numpy_array_equal(result, expected)
+
     def test_datetime64_dtype_array_returned(self):
         # GH 9431
         expected = np_array_datetime64_compat(

commit 2502befe4cf7c3f75115a33c15abb0cab3ca8b0e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 7 14:59:36 2011 +0200

    added to release notes, removed some deprecated methods, continued work on DataMatrix refactor

diff --git a/RELEASE.rst b/RELEASE.rst
index c7a1adac1..4895f3e0a 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -28,19 +28,38 @@ Release notes
 
 **New features / modules**
 
-* `DataFrame.describe`
+* `Series.describe`, `DataFrame.describe`: produces an R-like table of summary
+  statistics about each data column
 * `DataFrame.quantile`, `Series.quantile`
-* `DataFrame.describe`
 * Fancy indexing
+* Boolean indexing with DataFrame objects: df[df > 1] = 1
 * `pytz` / tzinfo support in `DateRange`
   * `tz_localize`, `tz_normalize`, and `tz_validate` methods added
 
 **Improvements to existing features**
 
+* The 2-dimensional `DataFrame` and `DataMatrix` classes have been extensively
+  refactored internally into a single class `DataFrame`, preserving where
+  possible their optimal performance characteristics. This should reduce
+  confusion from users about which class to use
+* Column ordering for mixed type data is now completely consistent in
+  `DataFrame`. In prior releases, there was inconsistent column ordering in
+  `DataMatrix`
+
 **API Changes**
 
+* Handling of boolean dtype in `DataFrame` has been improved to support storage
+  of boolean data with NA / NaN values. As a sacrifice, the boolean data needs
+  to be stored in an object array. Before it was being converted to float64 so
+  this should not (in theory) cause API breakage
 * Backwards compatibility support for begin/end/nPeriods keyword arguments in
   DateRange class has been removed
+* `DataFrame.rows()` removed (use `DataFrame.index`)
+* Added deprecation warning to `DataFrame.cols()`, to be removed in next release
+* `fillMethod` arguments (deprecated in prior release) removed, should be
+  replaced with `method`
+* `Series.fill`, `DataFrame.fill`, and `WidePanel.fill` removed, use `fillna`
+  instead
 
 **Bug fixes**
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 024d8f0f0..3d88daeb9 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -852,6 +852,8 @@ class DataFrame(PandasGeneric):
 
     def cols(self):
         """Return sorted list of frame's columns"""
+        warnings.warn("Replace usage of .cols() with .columns, will be removed "
+                      "in next release", FutureWarning)
         return list(self.columns)
 
     def iteritems(self):
@@ -885,7 +887,7 @@ class DataFrame(PandasGeneric):
         return DataFrame(data=new_data, index=new_index,
                          columns=new_columns)
 
-    def asfreq(self, freq, method=None, fillMethod=None):
+    def asfreq(self, freq, method=None):
         """
         Convert all TimeSeries inside to specified frequency using
         DateOffset objects. Optionally provide fill method to pad or
@@ -910,7 +912,7 @@ class DataFrame(PandasGeneric):
         else:
             dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
 
-        return self.reindex(dateRange, method=method, fillMethod=fillMethod)
+        return self.reindex(dateRange, method=method)
 
     def as_matrix(self, columns=None):
         """
@@ -1129,13 +1131,6 @@ class DataFrame(PandasGeneric):
 
         return self.reindex(self.index[theCount >= minObs])
 
-    def fill(self, value=None, method='pad'): # pragma: no cover
-        warnings.warn("fill is being replaced by fillna, and the fill function "
-                      "behavior will disappear in the next release: please "
-                      "modify your code accordingly",
-                      FutureWarning)
-        return self.fillna(value=value, method=method)
-
     def fillna(self, value=None, method='pad'):
         """
         Fill NaN values using the specified method.
@@ -1234,7 +1229,7 @@ class DataFrame(PandasGeneric):
         from pandas.core.panel import pivot
         return pivot(self[index], self[columns], self[values])
 
-    def reindex(self, index=None, columns=None, method=None, fillMethod=None):
+    def reindex(self, index=None, columns=None, method=None):
         """
         Reindex data inside, optionally filling according to some rule.
 
@@ -1253,13 +1248,6 @@ class DataFrame(PandasGeneric):
         -------
         y : same type as calling instance
         """
-        # TODO: remove this on next release
-        if fillMethod is not None: # pragma: no cover
-            warnings.warn("'fillMethod' is deprecated. Use 'method' instead",
-                          FutureWarning)
-
-            method = fillMethod
-
         frame = self
 
         if index is not None:
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 4cf35a9ec..bc5000b16 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -44,9 +44,7 @@ class DataMatrix(DataFrame):
     underlying ndarray to have to be reallocated!).
     """
     objects = None
-    def __init__(self, data=None, index=None, columns=None, dtype=None,
-                 objects=None):
-
+    def __init__(self, data=None, index=None, columns=None, dtype=None):
         if isinstance(data, dict) and len(data) > 0:
             (index, columns,
              values, objects) = self._init_dict(data, index, columns, objects,
@@ -83,23 +81,13 @@ class DataMatrix(DataFrame):
 
                 index = objects.index
 
-            if index is None:
-                N = 0
-                index = NULL_INDEX
-            else:
-                N = len(index)
-
-            if columns is None:
-                K = 0
-                columns = NULL_INDEX
-            else:
-                K = len(columns)
-
-            values = np.empty((N, K), dtype=dtype)
-            values[:] = NaN
+            values = _nan_array(index, columns)
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
+        self._float_values = None
+        self._object_values = None
+
         self._values_dict = {}
         self._columns_dict = {}
 
@@ -1053,6 +1041,176 @@ class DataMatrix(DataFrame):
         return DataMatrix(data=new_values, index=new_index,
                           columns=self.columns, objects=shifted_objects)
 
+_data_types = [np.float_, np.int_]
+
+def _filter_out(data, columns):
+    if columns is not None:
+        colset = set(columns)
+        data = dict((k, v) for k, v in data.iteritems() if k in colset)
+
+    return data
+
+def _homogenize_series(data, index):
+    homogenized = {}
+
+    for k, v in data.iteritems():
+        if isinstance(v, Series):
+            if v.index is not index:
+                # Forces alignment. No need to copy data since we
+                # are putting it into an ndarray later
+                v = v.reindex(index)
+        else:
+            if isinstance(v, dict):
+                v = [v.get(i, NaN) for i in index]
+            else:
+                assert(len(v) == len(index))
+            v = Series(v, index=index)
+
+        if issubclass(v.dtype.type, (float, int)):
+            v = v.astype(np.float64)
+        else:
+            v = v.astype(object)
+
+        homogenized[k] = v
+
+    return homogenized
+
+def _group_dtypes(data, columns):
+    import itertools
+
+    chunk_cols = []
+    chunks = []
+    for dtype, gp_cols in itertools.groupby(columns, lambda x: data[x].dtype):
+        chunk = np.vstack([data[k] for k in gp_cols]).T
+
+        chunks.append(chunk)
+        chunk_cols.append(gp_cols)
+
+    return chunks, chunk_cols
+
+def _init_dict(self, data, index, columns, objects, dtype):
+    """
+    Segregate Series based on type and coerce into matrices.
+    Needs to handle a lot of exceptional cases.
+    Somehow this got outrageously complicated
+    """
+    # pre-filter out columns if we passed it
+    data = _filter_out(data, columns)
+    index = extract_index(data, index)
+
+    if columns is None:
+        columns = try_sort(data.keys())
+
+
+
+    objectDict = {}
+    if objects is not None and isinstance(objects, dict):
+        objectDict.update(objects)
+
+    valueDict = {}
+    for k, v in data.iteritems():
+        if isinstance(v, Series):
+            if v.index is not index:
+                # Forces alignment. No need to copy data since we
+                # are putting it into an ndarray later
+                v = v.reindex(index)
+        else:
+            if isinstance(v, dict):
+                v = [v.get(i, NaN) for i in index]
+            else:
+                assert(len(v) == len(index))
+
+            try:
+                v = Series(v, dtype=dtype, index=index)
+            except Exception:
+                v = Series(v, index=index)
+
+        if issubclass(v.dtype.type, (np.bool_, float, int)):
+            valueDict[k] = v
+        else:
+            objectDict[k] = v
+
+    if columns is None:
+        columns = Index(try_sort(valueDict))
+        objectColumns = Index(try_sort(objectDict))
+    else:
+        objectColumns = Index([c for c in columns if c in objectDict])
+        columns = Index([c for c in columns if c not in objectDict])
+
+    if len(valueDict) == 0:
+        dtype = np.object_
+        valueDict = objectDict
+        columns = objectColumns
+    else:
+        dtypes = set(v.dtype for v in valueDict.values())
+
+        if len(dtypes) > 1:
+            dtype = np.float_
+        else:
+            dtype = list(dtypes)[0]
+
+        if len(objectDict) > 0:
+            new_objects = DataMatrix(objectDict,
+                                     dtype=np.object_,
+                                     index=index,
+                                     columns=objectColumns)
+            if isinstance(objects, DataMatrix):
+                objects = objects.join(new_objects, how='left')
+            else:
+                objects = new_objects
+
+    values = np.empty((len(index), len(columns)), dtype=dtype)
+
+    for i, col in enumerate(columns):
+        if col in valueDict:
+            values[:, i] = valueDict[col].values
+        else:
+            values[:, i] = np.NaN
+
+    return index, columns, values, objects
+
+def _init_matrix(self, values, index, columns, dtype):
+    if not isinstance(values, np.ndarray):
+        arr = np.array(values)
+        if issubclass(arr.dtype.type, basestring):
+            arr = np.array(values, dtype=object, copy=True)
+
+        values = arr
+
+    if values.ndim == 1:
+        N = values.shape[0]
+        if N == 0:
+            values = values.reshape((values.shape[0], 0))
+        else:
+            values = values.reshape((values.shape[0], 1))
+
+    if dtype is not None:
+        try:
+            values = values.astype(dtype)
+        except Exception:
+            pass
+
+    N, K = values.shape
+
+    if index is None:
+        index = _default_index(N)
+
+    if columns is None:
+        columns = _default_index(K)
+
+    return index, columns, values
+
 def _reorder_columns(mat, current, desired):
     indexer, mask = common.get_indexer(current, desired, None)
     return mat.take(indexer[mask], axis=1)
+
+
+def _nan_array(index, columns):
+    if index is None:
+        index = NULL_INDEX
+    if columns is None:
+        columns = NULL_INDEX
+
+    values = np.empty((len(index), len(columns)), dtype=dtype)
+    values.fill(NaN)
+    return values
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index d1a16403f..edbaaad3f 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -483,13 +483,6 @@ class WidePanel(Panel, PandasGeneric):
 
         return WidePanel(result_values, items, major, minor)
 
-    def fill(self, value=None, method='pad'): # pragma: no cover
-        warnings.warn("fill is being replaced by fillna, and the fill function "
-                      "behavior will disappear in the next release: please "
-                      "modify your code accordingly",
-                      FutureWarning)
-        return self.fillna(value=value, method=method)
-
     def fillna(self, value=None, method='pad'):
         """
         Fill NaN values using the specified method.
diff --git a/pandas/core/proto.py b/pandas/core/proto.py
new file mode 100644
index 000000000..a04425c2f
--- /dev/null
+++ b/pandas/core/proto.py
@@ -0,0 +1,156 @@
+import itertools
+
+from numpy import nan
+import numpy as np
+
+from pandas.core.index import Index
+from pandas.core.common import _ensure_index
+import pandas.lib.tseries as tseries
+
+class _Block(object):
+
+    def __init__(self, values, columns):
+        if values.ndim == 1:
+            values = np.atleast_2d(values).T
+        self.values = values
+        self.columns = _ensure_index(columns)
+
+    def __len__(self):
+        return len(self.values)
+
+    @property
+    def dtype(self):
+        return self.values.dtype
+
+    def reindex(self, new_columns):
+        pass
+
+def _interleave(blocks, columns):
+    dtype = _interleaved_dtype(blocks)
+    columns = _ensure_index(columns)
+
+    result = np.empty((len(blocks[0]), len(columns)), dtype=dtype)
+    result.fill(nan)
+
+    for block in blocks:
+        indexer, mask = columns.get_indexer(block.columns)
+
+        if mask.all():
+            result[:, indexer] = block.values
+        else:
+            result[:, indexer[mask]] = block.values[mask]
+
+    return result
+
+def _consolidate(blocks):
+    """
+    Merge blocks having same dtype
+    """
+    get_dtype = lambda x: x.dtype
+    grouper = itertools.groupby(sorted(blocks, key=get_dtype),
+                                lambda x: x.dtype)
+
+    new_blocks = []
+    for dtype, group_blocks in grouper:
+        group_blocks = list(group_blocks)
+        new_values = np.hstack([b.values for b in group_blocks])
+        new_columns = np.concatenate([b.columns for b in group_blocks])
+        new_blocks.append(_Block(new_values, new_columns))
+
+    return new_blocks
+
+# def _merge_blocks(blocks):
+#     return np.hstack([b.values for b in blocks])
+
+def _xs(blocks, i, copy=True):
+    if copy:
+        return np.concatenate([b[i] for b in blocks])
+    else:
+        if len(blocks) == 1:
+            return blocks[0].values[i]
+        else:
+            raise Exception('cannot get view with mixed-type data')
+
+def _interleaved_dtype(blocks):
+    for block in blocks:
+        if not issubclass(block.dtype.type, np.floating):
+            return object
+    return np.float64
+
+class _MixedTypeData(object):
+
+    def __init__(self, floats, objects, float_cols, object_cols):
+        pass
+
+    def as_matrix(self, columns=None):
+        if columns is None:
+            if self.nblocks == 0:
+                return self.blocks[0]
+
+            return self.hstack(self.blocks)
+        else:
+            pass
+
+class _BlockedData(object):
+
+    def __init__(self, columns, blocks, block_cols):
+
+        self.columns = columns
+        self.blocks = blocks
+        self.block_cols = block_cols
+        self.block_widths = np.asarray([len(cols) for cols in block_cols])
+
+    @property
+    def nblocks(self):
+        return len(self.blocks)
+
+    def as_matrix(self, columns=None):
+        if columns is None:
+            if self.nblocks == 0:
+                return self.blocks.values[0]
+            return _interleave(self.blocks, self.columns)
+        else:
+            pass
+
+    def xs(self, i, copy=True):
+        return np.concatenate([b[i] for b in blocks])
+
+    def get(self, col):
+        for block in self.blocks:
+            pass
+
+    def set(self, key, value):
+        pass
+
+    def _chunk_index(self, col):
+        pass
+
+import unittest
+class TestBlockOperations(unittest.TestCase):
+
+    def test_interleave(self):
+        pass
+
+    def test_consolidate(self):
+        pass
+
+    def test_xs(self):
+        pass
+
+if __name__ == '__main__':
+    floats = np.repeat(np.atleast_2d(np.arange(3.)), 10, axis=0)
+    objects = np.empty((10, 2), dtype=object)
+    objects[:, 0] = 'foo'
+    objects[:, 1] = 'bar'
+
+    float_cols = Index(['a', 'c', 'e'])
+    object_cols = Index(['b', 'd'])
+    columns = Index(sorted(float_cols + object_cols))
+    new_columns = Index(['a', 'c', 'e', 'b', 'd'])
+
+    fblock = _Block(floats, float_cols)
+    oblock = _Block(objects, object_cols)
+
+    blocks = [fblock, oblock]
+
+    interleaved = _interleave(blocks, columns)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 21ec376f8..276e3fccc 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -903,7 +903,7 @@ class Series(np.ndarray, PandasGeneric):
 
     applymap = apply
 
-    def reindex(self, index=None, method=None, fillMethod=None):
+    def reindex(self, index=None, method=None):
         """Conform Series to new Index
 
         Parameters
@@ -920,12 +920,6 @@ class Series(np.ndarray, PandasGeneric):
         -------
         reindexed : Series
         """
-        if fillMethod is not None: # pragma: no cover
-            warnings.warn("'fillMethod' is deprecated. Use 'method' instead",
-                          FutureWarning)
-
-            method = fillMethod
-
         if self.index.equals(index):
             return self.copy()
 
@@ -967,13 +961,6 @@ class Series(np.ndarray, PandasGeneric):
         """
         return self.reindex(other.index, method=method)
 
-    def fill(self, value=None, method='pad'): # pragma: no cover
-        warnings.warn("fill is being replaced by fillna, and the fill function "
-                      "behavior will disappear in the next release: please "
-                      "modify your code accordingly",
-                      FutureWarning)
-        return self.fillna(value=value, method=method)
-
     def fillna(self, value=None, method='pad'):
         """
         Fill NaN values using the specified method.
@@ -1236,7 +1223,7 @@ class Series(np.ndarray, PandasGeneric):
         else:
             return v
 
-    def asfreq(self, freq, method=None, fillMethod=None):
+    def asfreq(self, freq, method=None):
         """
         Convert this TimeSeries to the provided frequency using DateOffset
         objects. Optionally provide fill method to pad/backfill/interpolate
@@ -1258,7 +1245,7 @@ class Series(np.ndarray, PandasGeneric):
         else:
             dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
 
-        return self.reindex(dateRange, method=method, fillMethod=fillMethod)
+        return self.reindex(dateRange, method=method)
 
     def interpolate(self, method='linear'):
         """

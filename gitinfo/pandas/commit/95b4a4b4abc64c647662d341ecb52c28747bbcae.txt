commit 95b4a4b4abc64c647662d341ecb52c28747bbcae
Author: Chang She <chang@lambdafoundry.com>
Date:   Thu Mar 28 21:48:40 2013 -0700

    BUG: DatetimeIndex bug adding offsets to tz-aware indices #3210

diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index d230f3d5c..70e4a7010 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -557,9 +557,15 @@ class DatetimeIndex(Int64Index):
         if isinstance(delta, (Tick, timedelta)):
             inc = offsets._delta_to_nanoseconds(delta)
             new_values = (self.asi8 + inc).view(_NS_DTYPE)
+            tz = 'UTC' if self.tz is not None else None
+            result = DatetimeIndex(new_values, tz=tz, freq='infer')
+            utc = _utc()
+            if self.tz is not None and self.tz is not utc:
+                result = result.tz_convert(self.tz)
         else:
             new_values = self.astype('O') + delta
-        return DatetimeIndex(new_values, tz=self.tz, freq='infer')
+            result = DatetimeIndex(new_values, tz=self.tz, freq='infer')
+        return result
 
     def __contains__(self, key):
         try:
@@ -579,11 +585,11 @@ class DatetimeIndex(Int64Index):
         for d in data:
             if d.time() != zero_time or d.tzinfo is not None:
                 return [u'%s' % x for x in data ]
-            
+
         values = np.array(data,dtype=object)
         mask = isnull(self.values)
         values[mask] = na_rep
-        
+
         imask = -mask
         values[imask] = np.array([ u'%d-%.2d-%.2d' % (dt.year, dt.month, dt.day) for dt in values[imask] ])
         return values.tolist()
@@ -1093,7 +1099,7 @@ class DatetimeIndex(Int64Index):
                                      tz=self.tz).value - 1)
         else:
             raise KeyError
-        
+
 
         stamps = self.asi8
 
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 5dac20fb4..21b11bb45 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -104,7 +104,10 @@ class TestTimeZoneSupport(unittest.TestCase):
         self.assertEquals(result, expected)
 
     def test_timestamp_constructed_by_date_and_tz(self):
-        """ Fix Issue 2993, Timestamp cannot be constructed by datetime.date and tz correctly """
+        """
+        Fix Issue 2993, Timestamp cannot be constructed by datetime.date
+        and tz correctly
+        """
 
         result = Timestamp(date(2012, 3, 11), tz='US/Eastern')
 
@@ -510,7 +513,9 @@ class TestTimeZoneSupport(unittest.TestCase):
         # GH 2810 (with timezones)
         datetimes_naive   = [ ts.to_pydatetime() for ts in dr ]
         datetimes_with_tz = [ ts.to_pydatetime() for ts in dr_tz ]
-        df = DataFrame({'dr' : dr, 'dr_tz' : dr_tz, 'datetimes_naive': datetimes_naive, 'datetimes_with_tz' : datetimes_with_tz })
+        df = DataFrame({'dr' : dr, 'dr_tz' : dr_tz,
+                        'datetimes_naive': datetimes_naive,
+                        'datetimes_with_tz' : datetimes_with_tz })
         result = df.get_dtype_counts()
         expected = Series({ 'datetime64[ns]' : 3, 'object' : 1 })
         assert_series_equal(result, expected)
@@ -904,6 +909,11 @@ class TestTimeZones(unittest.TestCase):
         self.assert_(result.is_normalized)
         self.assert_(not rng.is_normalized)
 
+    def test_tzaware_offset(self):
+        dates = date_range('2012-11-01', periods=3, tz='US/Pacific')
+        offset = dates + offsets.Hour(5)
+        self.assertEqual(dates[0] + offsets.Hour(5), offset[0])
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 329c565fc..080146c3e 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -984,9 +984,10 @@ def repr_timedelta64(object value):
        sign_pretty = ""
 
    if days:
-       return "%s%d days, %02d:%02d:%s" % (sign_pretty,days,hours,minutes,seconds_pretty)
+       return "%s%d days, %02d:%02d:%s" % (sign_pretty, days, hours, minutes,
+                                           seconds_pretty)
 
-   return "%s%02d:%02d:%s" % (sign_pretty,hours,minutes,seconds_pretty)
+   return "%s%02d:%02d:%s" % (sign_pretty, hours, minutes, seconds_pretty)
 
 def array_strptime(ndarray[object] values, object fmt):
     cdef:
@@ -1148,12 +1149,12 @@ def array_strptime(ndarray[object] values, object fmt):
                     # W starts week on Monday.
                     week_of_year_start = 0
             elif parse_code == 17:
-                # Since -1 is default value only need to worry about setting tz if
-                # it can be something other than -1.
+                # Since -1 is default value only need to worry about setting tz
+                # if it can be something other than -1.
                 found_zone = found_dict['Z'].lower()
                 for value, tz_values in enumerate(locale_time.timezone):
                     if found_zone in tz_values:
-                        # Deal with bad locale setup where timezone names are the
+                        # Deal w/ bad locale setup where timezone names are the
                         # same and yet time.daylight is true; too ambiguous to
                         # be able to tell what timezone has daylight savings
                         if (time.tzname[0] == time.tzname[1] and
@@ -1162,14 +1163,14 @@ def array_strptime(ndarray[object] values, object fmt):
                         else:
                             tz = value
                             break
-        # If we know the week of the year and what day of that week, we can figure
+        # If we know the wk of the year and what day of that wk, we can figure
         # out the Julian day of the year.
         if julian == -1 and week_of_year != -1 and weekday != -1:
             week_starts_Mon = True if week_of_year_start == 0 else False
             julian = _calc_julian_from_U_or_W(year, week_of_year, weekday,
                                                 week_starts_Mon)
         # Cannot pre-calculate datetime_date() since can change in Julian
-        # calculation and thus could have different value for the day of the week
+        # calculation and thus could have different value for the day of the wk
         # calculation.
         if julian == -1:
             # Need to add 1 to result since first day of the year is 1, not 0.
@@ -1177,7 +1178,8 @@ def array_strptime(ndarray[object] values, object fmt):
                       datetime_date(year, 1, 1).toordinal() + 1
         else:  # Assume that if they bothered to include Julian day it will
                # be accurate.
-            datetime_result = datetime_date.fromordinal((julian - 1) + datetime_date(year, 1, 1).toordinal())
+            datetime_result = datetime_date.fromordinal(
+                (julian - 1) + datetime_date(year, 1, 1).toordinal())
             year = datetime_result.year
             month = datetime_result.month
             day = datetime_result.day
@@ -1297,7 +1299,8 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
                 pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
                 dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                               dts.min, dts.sec, dts.us, tz1)
-                delta = int(total_seconds(_get_utcoffset(tz1, dt))) * 1000000000
+                delta = (int(total_seconds(_get_utcoffset(tz1, dt)))
+                         * 1000000000)
                 utc_dates[i] = v - delta
         else:
             deltas = _get_deltas(tz1)

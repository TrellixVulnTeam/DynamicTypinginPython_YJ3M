commit 80241e6d4b469aa55f6105d15d0a4176718bcbaa
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Feb 21 15:55:21 2018 -0800

    Fix name setting in DTI/TDI __add__ and __sub__ (#19744)

diff --git a/doc/source/whatsnew/v0.23.0.txt b/doc/source/whatsnew/v0.23.0.txt
index a4b943f99..c9951e0ec 100644
--- a/doc/source/whatsnew/v0.23.0.txt
+++ b/doc/source/whatsnew/v0.23.0.txt
@@ -731,6 +731,8 @@ Datetimelike
 - Bug in :class:`Timestamp` and :func:`to_datetime` where a string representing a barely out-of-bounds timestamp would be incorrectly rounded down instead of raising ``OutOfBoundsDatetime`` (:issue:`19382`)
 - Bug in :func:`Timestamp.floor` :func:`DatetimeIndex.floor` where time stamps far in the future and past were not rounded correctly (:issue:`19206`)
 - Bug in :func:`to_datetime` where passing an out-of-bounds datetime with ``errors='coerce'`` and ``utc=True`` would raise ``OutOfBoundsDatetime`` instead of parsing to ``NaT`` (:issue:`19612`)
+- Bug in :class:`DatetimeIndex` and :class:`TimedeltaIndex` addition and subtraction where name of the returned object was not always set consistently. (:issue:`19744`)
+-
 
 Timedelta
 ^^^^^^^^^
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 6748db825..77dc15220 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -121,21 +121,6 @@ def _consensus_name_attr(objs):
     return name
 
 
-def _maybe_match_name(a, b):
-    a_has = hasattr(a, 'name')
-    b_has = hasattr(b, 'name')
-    if a_has and b_has:
-        if a.name == b.name:
-            return a.name
-        else:
-            return None
-    elif a_has:
-        return a.name
-    elif b_has:
-        return b.name
-    return None
-
-
 def _get_info_slice(obj, indexer):
     """Slice the info axis of `obj` with `indexer`."""
     if not hasattr(obj, '_info_axis_number'):
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index c98f8ceea..187f9fcf5 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -29,7 +29,7 @@ from pandas.core.dtypes.common import (
 from pandas.core.dtypes.generic import (
     ABCIndex, ABCSeries, ABCPeriodIndex, ABCIndexClass)
 from pandas.core.dtypes.missing import isna
-from pandas.core import common as com, algorithms
+from pandas.core import common as com, algorithms, ops
 from pandas.core.algorithms import checked_add_with_arr
 from pandas.errors import NullFrequencyError
 import pandas.io.formats.printing as printing
@@ -661,29 +661,37 @@ class DatetimeIndexOpsMixin(object):
             if isinstance(other, ABCSeries):
                 return NotImplemented
             elif is_timedelta64_dtype(other):
-                return self._add_delta(other)
+                result = self._add_delta(other)
             elif isinstance(other, (DateOffset, timedelta)):
-                return self._add_delta(other)
+                result = self._add_delta(other)
             elif is_offsetlike(other):
                 # Array/Index of DateOffset objects
-                return self._add_offset_array(other)
+                result = self._add_offset_array(other)
             elif isinstance(self, TimedeltaIndex) and isinstance(other, Index):
                 if hasattr(other, '_add_delta'):
-                    return other._add_delta(self)
-                raise TypeError("cannot add TimedeltaIndex and {typ}"
-                                .format(typ=type(other)))
+                    result = other._add_delta(self)
+                else:
+                    raise TypeError("cannot add TimedeltaIndex and {typ}"
+                                    .format(typ=type(other)))
             elif is_integer(other):
-                return self.shift(other)
+                # This check must come after the check for timedelta64_dtype
+                # or else it will incorrectly catch np.timedelta64 objects
+                result = self.shift(other)
             elif isinstance(other, (datetime, np.datetime64)):
-                return self._add_datelike(other)
+                result = self._add_datelike(other)
             elif isinstance(other, Index):
-                return self._add_datelike(other)
+                result = self._add_datelike(other)
             elif is_integer_dtype(other) and self.freq is None:
                 # GH#19123
                 raise NullFrequencyError("Cannot shift with no freq")
             else:  # pragma: no cover
                 return NotImplemented
 
+            if result is not NotImplemented:
+                res_name = ops.get_op_result_name(self, other)
+                result.name = res_name
+            return result
+
         cls.__add__ = __add__
         cls.__radd__ = __add__
 
@@ -697,25 +705,27 @@ class DatetimeIndexOpsMixin(object):
             if isinstance(other, ABCSeries):
                 return NotImplemented
             elif is_timedelta64_dtype(other):
-                return self._add_delta(-other)
+                result = self._add_delta(-other)
             elif isinstance(other, (DateOffset, timedelta)):
-                return self._add_delta(-other)
+                result = self._add_delta(-other)
             elif is_offsetlike(other):
                 # Array/Index of DateOffset objects
-                return self._sub_offset_array(other)
+                result = self._sub_offset_array(other)
             elif isinstance(self, TimedeltaIndex) and isinstance(other, Index):
                 if not isinstance(other, TimedeltaIndex):
                     raise TypeError("cannot subtract TimedeltaIndex and {typ}"
                                     .format(typ=type(other).__name__))
-                return self._add_delta(-other)
+                result = self._add_delta(-other)
             elif isinstance(other, DatetimeIndex):
-                return self._sub_datelike(other)
+                result = self._sub_datelike(other)
             elif is_integer(other):
-                return self.shift(-other)
+                # This check must come after the check for timedelta64_dtype
+                # or else it will incorrectly catch np.timedelta64 objects
+                result = self.shift(-other)
             elif isinstance(other, (datetime, np.datetime64)):
-                return self._sub_datelike(other)
+                result = self._sub_datelike(other)
             elif isinstance(other, Period):
-                return self._sub_period(other)
+                result = self._sub_period(other)
             elif isinstance(other, Index):
                 raise TypeError("cannot subtract {typ1} and {typ2}"
                                 .format(typ1=type(self).__name__,
@@ -726,6 +736,11 @@ class DatetimeIndexOpsMixin(object):
             else:  # pragma: no cover
                 return NotImplemented
 
+            if result is not NotImplemented:
+                res_name = ops.get_op_result_name(self, other)
+                result.name = res_name
+            return result
+
         cls.__sub__ = __sub__
 
         def __rsub__(self, other):
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index cc9ce1f3f..debeabf9b 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -886,7 +886,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
         else:
             raise TypeError("cannot subtract DatetimeIndex and {typ}"
                             .format(typ=type(other).__name__))
-        return TimedeltaIndex(result, name=self.name, copy=False)
+        return TimedeltaIndex(result)
 
     def _sub_datelike_dti(self, other):
         """subtraction of two DatetimeIndexes"""
@@ -910,20 +910,31 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
         return attrs
 
     def _add_delta(self, delta):
-        if isinstance(delta, ABCSeries):
-            return NotImplemented
+        """
+        Add a timedelta-like, DateOffset, or TimedeltaIndex-like object
+        to self.
+
+        Parameters
+        ----------
+        delta : {timedelta, np.timedelta64, DateOffset,
+                 TimedelaIndex, ndarray[timedelta64]}
 
+        Returns
+        -------
+        result : DatetimeIndex
+
+        Notes
+        -----
+        The result's name is set outside of _add_delta by the calling
+        method (__add__ or __sub__)
+        """
         from pandas import TimedeltaIndex
-        name = self.name
 
         if isinstance(delta, (Tick, timedelta, np.timedelta64)):
             new_values = self._add_delta_td(delta)
         elif is_timedelta64_dtype(delta):
             if not isinstance(delta, TimedeltaIndex):
                 delta = TimedeltaIndex(delta)
-            else:
-                # update name when delta is Index
-                name = com._maybe_match_name(self, delta)
             new_values = self._add_delta_tdi(delta)
         elif isinstance(delta, DateOffset):
             new_values = self._add_offset(delta).asi8
@@ -931,7 +942,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
             new_values = self.astype('O') + delta
 
         tz = 'UTC' if self.tz is not None else None
-        result = DatetimeIndex(new_values, tz=tz, name=name, freq='infer')
+        result = DatetimeIndex(new_values, tz=tz, freq='infer')
         if self.tz is not None and self.tz is not utc:
             result = result.tz_convert(self.tz)
         return result
@@ -954,22 +965,19 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
 
     def _add_offset_array(self, other):
         # Array/Index of DateOffset objects
-        if isinstance(other, ABCSeries):
-            return NotImplemented
-        elif len(other) == 1:
+        if len(other) == 1:
             return self + other[0]
         else:
             warnings.warn("Adding/subtracting array of DateOffsets to "
                           "{} not vectorized".format(type(self)),
                           PerformanceWarning)
             return self.astype('O') + np.array(other)
+            # TODO: pass freq='infer' like we do in _sub_offset_array?
             # TODO: This works for __add__ but loses dtype in __sub__
 
     def _sub_offset_array(self, other):
         # Array/Index of DateOffset objects
-        if isinstance(other, ABCSeries):
-            return NotImplemented
-        elif len(other) == 1:
+        if len(other) == 1:
             return self - other[0]
         else:
             warnings.warn("Adding/subtracting array of DateOffsets to "
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 8f2d7d382..60798e6d7 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -729,7 +729,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
         if other is tslib.NaT:
             new_data = np.empty(len(self), dtype=np.int64)
             new_data.fill(tslib.iNaT)
-            return TimedeltaIndex(new_data, name=self.name)
+            return TimedeltaIndex(new_data)
         return NotImplemented
 
     def _sub_period(self, other):
@@ -744,7 +744,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
             new_data = new_data.astype(np.float64)
             new_data[self._isnan] = np.nan
         # result must be Int64Index or Float64Index
-        return Index(new_data, name=self.name)
+        return Index(new_data)
 
     def shift(self, n):
         """
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 41e499da8..6b61db53d 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -356,19 +356,32 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
         return attrs
 
     def _add_delta(self, delta):
+        """
+        Add a timedelta-like, Tick, or TimedeltaIndex-like object
+        to self.
+
+        Parameters
+        ----------
+        delta : {timedelta, np.timedelta64, Tick, TimedeltaIndex}
+
+        Returns
+        -------
+        result : TimedeltaIndex
+
+        Notes
+        -----
+        The result's name is set outside of _add_delta by the calling
+        method (__add__ or __sub__)
+        """
         if isinstance(delta, (Tick, timedelta, np.timedelta64)):
             new_values = self._add_delta_td(delta)
-            name = self.name
         elif isinstance(delta, TimedeltaIndex):
             new_values = self._add_delta_tdi(delta)
-            # update name when delta is index
-            name = com._maybe_match_name(self, delta)
         else:
             raise TypeError("cannot add the type {0} to a TimedeltaIndex"
                             .format(type(delta)))
 
-        result = TimedeltaIndex(new_values, freq='infer', name=name)
-        return result
+        return TimedeltaIndex(new_values, freq='infer')
 
     def _evaluate_with_timedelta_like(self, other, op, opstr, reversed=False):
         if isinstance(other, ABCSeries):
@@ -409,7 +422,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
             result = checked_add_with_arr(i8, other.value,
                                           arr_mask=self._isnan)
             result = self._maybe_mask_results(result, fill_value=iNaT)
-        return DatetimeIndex(result, name=self.name, copy=False)
+            return DatetimeIndex(result)
 
     def _sub_datelike(self, other):
         # GH#19124 Timedelta - datetime is not in general well-defined.
@@ -426,9 +439,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
             # TimedeltaIndex can only operate with a subset of DateOffset
             # subclasses.  Incompatible classes will raise AttributeError,
             # which we re-raise as TypeError
-            if isinstance(other, ABCSeries):
-                return NotImplemented
-            elif len(other) == 1:
+            if len(other) == 1:
                 return self + other[0]
             else:
                 from pandas.errors import PerformanceWarning
@@ -436,6 +447,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
                               "{} not vectorized".format(type(self)),
                               PerformanceWarning)
                 return self.astype('O') + np.array(other)
+                # TODO: pass freq='infer' like we do in _sub_offset_array?
                 # TODO: This works for __add__ but loses dtype in __sub__
         except AttributeError:
             raise TypeError("Cannot add non-tick DateOffset to TimedeltaIndex")
@@ -446,9 +458,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
             # TimedeltaIndex can only operate with a subset of DateOffset
             # subclasses.  Incompatible classes will raise AttributeError,
             # which we re-raise as TypeError
-            if isinstance(other, ABCSeries):
-                return NotImplemented
-            elif len(other) == 1:
+            if len(other) == 1:
                 return self - other[0]
             else:
                 from pandas.errors import PerformanceWarning
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index ad6102eb6..9e80ab3b3 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -42,6 +42,67 @@ from pandas.core.dtypes.generic import (
     ABCSparseSeries, ABCSparseArray)
 
 
+# -----------------------------------------------------------------------------
+# Ops Wrapping Utilities
+
+def get_op_result_name(left, right):
+    """
+    Find the appropriate name to pin to an operation result.  This result
+    should always be either an Index or a Series.
+
+    Parameters
+    ----------
+    left : {Series, Index}
+    right : object
+
+    Returns
+    -------
+    name : object
+        Usually a string
+    """
+    # `left` is always a pd.Series when called from within ops
+    if isinstance(right, (ABCSeries, pd.Index)):
+        name = _maybe_match_name(left, right)
+    else:
+        name = left.name
+    return name
+
+
+def _maybe_match_name(a, b):
+    """
+    Try to find a name to attach to the result of an operation between
+    a and b.  If only one of these has a `name` attribute, return that
+    name.  Otherwise return a consensus name if they match of None if
+    they have different names.
+
+    Parameters
+    ----------
+    a : object
+    b : object
+
+    Returns
+    -------
+    name : str or None
+
+    See also
+    --------
+    pandas.core.common._consensus_name_attr
+    """
+    a_has = hasattr(a, 'name')
+    b_has = hasattr(b, 'name')
+    if a_has and b_has:
+        if a.name == b.name:
+            return a.name
+        else:
+            # TODO: what if they both have np.nan for their names?
+            return None
+    elif a_has:
+        return a.name
+    elif b_has:
+        return b.name
+    return None
+
+
 # -----------------------------------------------------------------------------
 # Reversed Operations not available in the stdlib operator module.
 # Defining these instead of using lambdas allows us to reference them by name.
@@ -822,7 +883,7 @@ def _arith_method_SERIES(cls, op, special):
             return NotImplemented
 
         left, right = _align_method_SERIES(left, right)
-        res_name = _get_series_op_result_name(left, right)
+        res_name = get_op_result_name(left, right)
 
         if is_datetime64_dtype(left) or is_datetime64tz_dtype(left):
             result = dispatch_to_index_op(op, left, right, pd.DatetimeIndex)
@@ -886,15 +947,6 @@ def dispatch_to_index_op(op, left, right, index_class):
     return result
 
 
-def _get_series_op_result_name(left, right):
-    # `left` is always a pd.Series
-    if isinstance(right, (ABCSeries, pd.Index)):
-        name = com._maybe_match_name(left, right)
-    else:
-        name = left.name
-    return name
-
-
 def _comp_method_OBJECT_ARRAY(op, x, y):
     if isinstance(y, list):
         y = construct_1d_object_array_from_listlike(y)
@@ -972,7 +1024,7 @@ def _comp_method_SERIES(cls, op, special):
         if axis is not None:
             self._get_axis_number(axis)
 
-        res_name = _get_series_op_result_name(self, other)
+        res_name = get_op_result_name(self, other)
 
         if isinstance(other, ABCDataFrame):  # pragma: no cover
             # Defer to DataFrame implementation; fail early
@@ -1098,7 +1150,7 @@ def _bool_method_SERIES(cls, op, special):
             return NotImplemented
 
         elif isinstance(other, ABCSeries):
-            name = com._maybe_match_name(self, other)
+            name = get_op_result_name(self, other)
             is_other_int_dtype = is_integer_dtype(other.dtype)
             other = fill_int(other) if is_other_int_dtype else fill_bool(other)
 
@@ -1536,7 +1588,7 @@ def _arith_method_SPARSE_SERIES(cls, op, special):
 def _sparse_series_op(left, right, op, name):
     left, right = left.align(right, join='outer', copy=False)
     new_index = left.index
-    new_name = com._maybe_match_name(left, right)
+    new_name = get_op_result_name(left, right)
 
     from pandas.core.sparse.array import _sparse_array_op
     result = _sparse_array_op(left.values, right.values, op, name,
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 90dc14836..79ffb8be6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1728,7 +1728,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
         with np.errstate(all='ignore'):
             result = func(this_vals, other_vals)
-        name = com._maybe_match_name(self, other)
+        name = ops.get_op_result_name(self, other)
         result = self._constructor(result, index=new_index, name=name)
         result = result.__finalize__(self)
         if name is None:
@@ -1769,7 +1769,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         if isinstance(other, Series):
             new_index = self.index.union(other.index)
-            new_name = com._maybe_match_name(self, other)
+            new_name = ops.get_op_result_name(self, other)
             new_values = np.empty(len(new_index), dtype=self.dtype)
             for i, idx in enumerate(new_index):
                 lv = self.get(idx, fill_value)
@@ -1814,7 +1814,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         this = self.reindex(new_index, copy=False)
         other = other.reindex(new_index, copy=False)
         # TODO: do we need name?
-        name = com._maybe_match_name(self, other)  # noqa
+        name = ops.get_op_result_name(self, other)  # noqa
         rs_vals = com._where_compat(isna(this), other._values, this._values)
         return self._constructor(rs_vals, index=new_index).__finalize__(self)
 
diff --git a/pandas/tests/indexes/datetimes/test_arithmetic.py b/pandas/tests/indexes/datetimes/test_arithmetic.py
index ddc97636a..f252d6ec3 100644
--- a/pandas/tests/indexes/datetimes/test_arithmetic.py
+++ b/pandas/tests/indexes/datetimes/test_arithmetic.py
@@ -721,11 +721,10 @@ class TestDatetimeIndexArithmetic(object):
         result4 = index + ser.values
         tm.assert_index_equal(result4, expected)
 
-    @pytest.mark.parametrize('box', [np.array, pd.Index])
-    def test_dti_add_offset_array(self, tz, box):
+    def test_dti_add_offset_array(self, tz):
         # GH#18849
         dti = pd.date_range('2017-01-01', periods=2, tz=tz)
-        other = box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
+        other = np.array([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
 
         with tm.assert_produces_warning(PerformanceWarning):
             res = dti + other
@@ -737,11 +736,29 @@ class TestDatetimeIndexArithmetic(object):
             res2 = other + dti
         tm.assert_index_equal(res2, expected)
 
-    @pytest.mark.parametrize('box', [np.array, pd.Index])
-    def test_dti_sub_offset_array(self, tz, box):
+    @pytest.mark.parametrize('names', [(None, None, None),
+                                       ('foo', 'bar', None),
+                                       ('foo', 'foo', 'foo')])
+    def test_dti_add_offset_index(self, tz, names):
+        # GH#18849, GH#19744
+        dti = pd.date_range('2017-01-01', periods=2, tz=tz, name=names[0])
+        other = pd.Index([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)],
+                         name=names[1])
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res = dti + other
+        expected = DatetimeIndex([dti[n] + other[n] for n in range(len(dti))],
+                                 name=names[2], freq='infer')
+        tm.assert_index_equal(res, expected)
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res2 = other + dti
+        tm.assert_index_equal(res2, expected)
+
+    def test_dti_sub_offset_array(self, tz):
         # GH#18824
         dti = pd.date_range('2017-01-01', periods=2, tz=tz)
-        other = box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
+        other = np.array([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
 
         with tm.assert_produces_warning(PerformanceWarning):
             res = dti - other
@@ -749,6 +766,21 @@ class TestDatetimeIndexArithmetic(object):
                                  name=dti.name, freq='infer')
         tm.assert_index_equal(res, expected)
 
+    @pytest.mark.parametrize('names', [(None, None, None),
+                                       ('foo', 'bar', None),
+                                       ('foo', 'foo', 'foo')])
+    def test_dti_sub_offset_index(self, tz, names):
+        # GH#18824, GH#19744
+        dti = pd.date_range('2017-01-01', periods=2, tz=tz, name=names[0])
+        other = pd.Index([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)],
+                         name=names[1])
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res = dti - other
+        expected = DatetimeIndex([dti[n] - other[n] for n in range(len(dti))],
+                                 name=names[2], freq='infer')
+        tm.assert_index_equal(res, expected)
+
     @pytest.mark.parametrize('names', [(None, None, None),
                                        ('foo', 'bar', None),
                                        ('foo', 'foo', 'foo')])
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
index 3dc60ed33..029fdfcef 100644
--- a/pandas/tests/indexes/timedeltas/test_arithmetic.py
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -194,11 +194,31 @@ class TestTimedeltaIndexArithmetic(object):
 
     # -------------------------------------------------------------
 
-    @pytest.mark.parametrize('box', [np.array, pd.Index])
-    def test_tdi_add_offset_array(self, box):
+    @pytest.mark.parametrize('names', [(None, None, None),
+                                       ('foo', 'bar', None),
+                                       ('foo', 'foo', 'foo')])
+    def test_tdi_add_offset_index(self, names):
+        # GH#18849, GH#19744
+        tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'],
+                             name=names[0])
+        other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)],
+                         name=names[1])
+
+        expected = TimedeltaIndex([tdi[n] + other[n] for n in range(len(tdi))],
+                                  freq='infer', name=names[2])
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res = tdi + other
+        tm.assert_index_equal(res, expected)
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res2 = other + tdi
+        tm.assert_index_equal(res2, expected)
+
+    def test_tdi_add_offset_array(self):
         # GH#18849
         tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'])
-        other = box([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])
+        other = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])
 
         expected = TimedeltaIndex([tdi[n] + other[n] for n in range(len(tdi))],
                                   freq='infer')
@@ -211,23 +231,27 @@ class TestTimedeltaIndexArithmetic(object):
             res2 = other + tdi
         tm.assert_index_equal(res2, expected)
 
-        anchored = box([pd.offsets.QuarterEnd(),
-                        pd.offsets.Week(weekday=2)])
+    @pytest.mark.parametrize('names', [(None, None, None),
+                                       ('foo', 'bar', None),
+                                       ('foo', 'foo', 'foo')])
+    def test_tdi_sub_offset_index(self, names):
+        # GH#18824, GH#19744
+        tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'],
+                             name=names[0])
+        other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)],
+                         name=names[1])
 
-        # addition/subtraction ops with anchored offsets should issue
-        # a PerformanceWarning and _then_ raise a TypeError.
-        with pytest.raises(TypeError):
-            with tm.assert_produces_warning(PerformanceWarning):
-                tdi + anchored
-        with pytest.raises(TypeError):
-            with tm.assert_produces_warning(PerformanceWarning):
-                anchored + tdi
+        expected = TimedeltaIndex([tdi[n] - other[n] for n in range(len(tdi))],
+                                  freq='infer', name=names[2])
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            res = tdi - other
+        tm.assert_index_equal(res, expected)
 
-    @pytest.mark.parametrize('box', [np.array, pd.Index])
-    def test_tdi_sub_offset_array(self, box):
+    def test_tdi_sub_offset_array(self):
         # GH#18824
         tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'])
-        other = box([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])
+        other = np.array([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)])
 
         expected = TimedeltaIndex([tdi[n] - other[n] for n in range(len(tdi))],
                                   freq='infer')
@@ -236,17 +260,6 @@ class TestTimedeltaIndexArithmetic(object):
             res = tdi - other
         tm.assert_index_equal(res, expected)
 
-        anchored = box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
-
-        # addition/subtraction ops with anchored offsets should issue
-        # a PerformanceWarning and _then_ raise a TypeError.
-        with pytest.raises(TypeError):
-            with tm.assert_produces_warning(PerformanceWarning):
-                tdi - anchored
-        with pytest.raises(TypeError):
-            with tm.assert_produces_warning(PerformanceWarning):
-                anchored - tdi
-
     @pytest.mark.parametrize('names', [(None, None, None),
                                        ('foo', 'bar', None),
                                        ('foo', 'foo', 'foo')])
@@ -275,8 +288,12 @@ class TestTimedeltaIndexArithmetic(object):
             res3 = tdi - other
         tm.assert_series_equal(res3, expected_sub)
 
-        anchored = Series([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)],
-                          name=names[1])
+    @pytest.mark.parametrize('box', [np.array, pd.Index, pd.Series])
+    def test_tdi_add_sub_anchored_offset_arraylike(self, box):
+        # GH#18824
+        tdi = TimedeltaIndex(['1 days 00:00:00', '3 days 04:00:00'])
+
+        anchored = box([pd.offsets.MonthEnd(), pd.offsets.Day(n=2)])
 
         # addition/subtraction ops with anchored offsets should issue
         # a PerformanceWarning and _then_ raise a TypeError.
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 57479be4d..0b329f64d 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -9,6 +9,7 @@ import numpy as np
 from pandas import Series, Timestamp
 from pandas.compat import range, lmap
 import pandas.core.common as com
+from pandas.core import ops
 import pandas.util.testing as tm
 
 
@@ -167,26 +168,26 @@ def test_random_state():
 
 def test_maybe_match_name():
 
-    matched = com._maybe_match_name(
+    matched = ops._maybe_match_name(
         Series([1], name='x'), Series(
             [2], name='x'))
     assert (matched == 'x')
 
-    matched = com._maybe_match_name(
+    matched = ops._maybe_match_name(
         Series([1], name='x'), Series(
             [2], name='y'))
     assert (matched is None)
 
-    matched = com._maybe_match_name(Series([1]), Series([2], name='x'))
+    matched = ops._maybe_match_name(Series([1]), Series([2], name='x'))
     assert (matched is None)
 
-    matched = com._maybe_match_name(Series([1], name='x'), Series([2]))
+    matched = ops._maybe_match_name(Series([1], name='x'), Series([2]))
     assert (matched is None)
 
-    matched = com._maybe_match_name(Series([1], name='x'), [2])
+    matched = ops._maybe_match_name(Series([1], name='x'), [2])
     assert (matched == 'x')
 
-    matched = com._maybe_match_name([1], Series([2], name='y'))
+    matched = ops._maybe_match_name([1], Series([2], name='y'))
     assert (matched == 'y')
 
 

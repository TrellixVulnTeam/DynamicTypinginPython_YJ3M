commit c89e9bbad5f0781e7615ed7c564ff1fa90f91b16
Author: Chang She <chang@lambdafoundry.com>
Date:   Mon Nov 19 15:33:35 2012 -0500

    BUG: remove asserts from core #2288

diff --git a/pandas/core/format.py b/pandas/core/format.py
index d87d20067..13e504a8e 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -293,8 +293,9 @@ class DataFrameFormatter(object):
 
         if column_format is None:
             column_format = '|l|%s|' % '|'.join('c' for _ in strcols)
-        else:
-            assert isinstance(column_format, basestring)
+        elif not isinstance(column_format, basestring):
+            raise AssertionError(('column_format must be str or unicode, not %s'
+                                  % type(column_format)))
 
         self.buf.write('\\begin{tabular}{%s}\n' % column_format)
         self.buf.write('\\hline\n')
@@ -474,7 +475,9 @@ class HTMLFormatter(object):
         if self.classes is not None:
             if isinstance(self.classes, str):
                 self.classes = self.classes.split()
-            assert isinstance(self.classes, (list, tuple))
+            if not isinstance(self.classes, (list, tuple)):
+                raise AssertionError(('classes must be list or tuple, '
+                                      'not %s') % type(self.classes))
             _classes.extend(self.classes)
 
         self.write('<table border="1" class="%s">' % ' '.join(_classes),
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 218c04b6f..8e12d1f8e 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1138,8 +1138,9 @@ class DataFrame(NDFrame):
         from pandas.core.reshape import block2d_to_block3d
 
         # only support this kind for now
-        assert(isinstance(self.index, MultiIndex) and
-               len(self.index.levels) == 2)
+        if (not isinstance(self.index, MultiIndex) or
+            len(self.index.levels) != 2):
+            raise AssertionError('Must have 2-level MultiIndex')
 
         self._consolidate_inplace()
 
@@ -1503,7 +1504,8 @@ class DataFrame(NDFrame):
             lines.append('Data columns:')
             space = max([len(com.pprint_thing(k)) for k in self.columns]) + 4
             counts = self.count()
-            assert(len(cols) == len(counts))
+            if len(cols) != len(counts):
+                raise AssertionError('Columns must equal counts')
             for col, count in counts.iteritems():
                 if not isinstance(col, basestring):
                     col = str(col)
@@ -1962,7 +1964,8 @@ class DataFrame(NDFrame):
 
     def _set_item_multiple(self, keys, value):
         if isinstance(value, DataFrame):
-            assert(len(value.columns) == len(keys))
+            if len(value.columns) != len(keys):
+                raise AssertionError('Columns must be same length as keys')
             for k1, k2 in zip(keys, value.columns):
                 self[k1] = value[k2]
         else:
@@ -2195,7 +2198,8 @@ class DataFrame(NDFrame):
         from itertools import izip
 
         n = len(row_labels)
-        assert(n == len(col_labels))
+        if n != len(col_labels):
+            raise AssertionError('Row labels must have same size as col labels')
 
         thresh = 1000
         if not self._is_mixed_type or n > thresh:
@@ -2973,7 +2977,8 @@ class DataFrame(NDFrame):
         labels = self._get_axis(axis)
 
         if by is not None:
-            assert(axis == 0)
+            if axis != 0:
+                raise AssertionError('Axis must be 0')
             if isinstance(by, (tuple, list)):
                 keys = [self[x].values for x in by]
                 indexer = _lexsort_indexer(keys, orders=ascending)
@@ -3934,7 +3939,8 @@ class DataFrame(NDFrame):
     def _apply_standard(self, func, axis, ignore_failures=False):
         try:
 
-            assert(not self._is_mixed_type)  # maybe a hack for now
+            if self._is_mixed_type:  # maybe a hack for now
+                raise AssertionError('Must be mixed type DataFrame')
             values = self.values
             dummy = Series(NA, index=self._get_axis(axis),
                            dtype=values.dtype)
@@ -4151,7 +4157,8 @@ class DataFrame(NDFrame):
         from pandas.tools.merge import merge, concat
 
         if isinstance(other, Series):
-            assert(other.name is not None)
+            if other.name is None:
+                raise AssertionError('Other Series must have a name')
             other = DataFrame({other.name: other})
 
         if isinstance(other, DataFrame):
@@ -5030,7 +5037,12 @@ def group_agg(values, bounds, f):
         result = np.empty((len(bounds), K), dtype=float)
 
     testagg = f(values[:min(1, len(values))])
-    assert(not (isinstance(testagg, np.ndarray) and testagg.ndim == 2))
+    if isinstance(testagg, np.ndarray):
+        raise AssertionError('Results must be an ndarray, not %s'
+                             % type(testagg))
+    if testagg.ndim == 2:
+        raise AssertionError('Results must be 2-D, not %d-D'
+                             % testagg.ndim)
 
     for i, left_bound in enumerate(bounds):
         if i == len(bounds) - 1:
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 4f73d6884..ef238b40d 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -340,7 +340,8 @@ class PandasObject(object):
 
         if axis.is_unique:
             if level is not None:
-                assert(isinstance(axis, MultiIndex))
+                if not isinstance(axis, MultiIndex):
+                    raise AssertionError('axis must be a MultiIndex')
                 new_axis = axis.drop(labels, level=level)
             else:
                 new_axis = axis.drop(labels)
@@ -348,7 +349,8 @@ class PandasObject(object):
             return self.reindex(**{axis_name: new_axis})
         else:
             if level is not None:
-                assert(isinstance(axis, MultiIndex))
+                if not isinstance(axis, MultiIndex):
+                    raise AssertionError('axis must be a MultiIndex')
                 indexer = -lib.ismember(axis.get_level_values(level),
                                         set(labels))
             else:
@@ -1012,7 +1014,9 @@ def truncate(self, before=None, after=None, copy=True):
     after = to_datetime(after)
 
     if before is not None and after is not None:
-        assert(before <= after)
+        if before > after:
+            raise AssertionError('Truncate: %s must be after %s' %
+                                 (before, after))
 
     result = self.ix[before:after]
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index f09e2d543..6705df681 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -830,12 +830,9 @@ class Grouper(object):
                                              axis=self.axis):
             res = func(group)
             if result is None:
-                try:
-                    assert(not isinstance(res, np.ndarray))
-                    assert(not isinstance(res, list))
-                    result = np.empty(ngroups, dtype='O')
-                except Exception:
-                    raise ValueError('function does not reduce')
+                if isinstance(res, np.ndarray) or isinstance(res, list):
+                    raise ValueError('Function does not reduce')
+                result = np.empty(ngroups, dtype='O')
 
             counts[label] = group.shape[0]
             result[label] = res
@@ -1040,7 +1037,8 @@ class Grouping(object):
 
         if level is not None:
             if not isinstance(level, int):
-                assert(level in index.names)
+                if level not in index.names:
+                    raise AssertionError('Level %s not in index' % str(level))
                 level = index.names.index(level)
 
             inds = index.labels[level]
@@ -1231,7 +1229,8 @@ def _convert_grouper(axis, grouper):
         else:
             return grouper.reindex(axis).values
     elif isinstance(grouper, (list, np.ndarray)):
-        assert(len(grouper) == len(axis))
+        if len(grouper) != len(axis):
+            raise AssertionError('Grouper and axis must be same length')
         return grouper
     else:
         return grouper
@@ -1629,7 +1628,8 @@ class NDFrameGroupBy(GroupBy):
         return result
 
     def _aggregate_generic(self, func, *args, **kwargs):
-        assert(self.grouper.nkeys == 1)
+        if self.grouper.nkeys != 1:
+            raise AssertionError('Number of keys must be 1')
 
         axis = self.axis
         obj = self._obj_with_exclusions
@@ -2061,7 +2061,9 @@ def generate_groups(data, group_index, ngroups, axis=0, factory=lambda x: x):
         # Since I'm now compressing the group ids, it's now not "possible" to
         # produce empty slices because such groups would not be observed in the
         # data
-        assert(start < end)
+        if start >= end:
+            raise AssertionError('Start %s must be less than end %s'
+                                 % (str(start), str(end)))
         yield i, _get_slice(slice(start, end))
 
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 6098d0a37..b7792309f 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -180,7 +180,9 @@ class Index(np.ndarray):
         return [self.name]
 
     def _set_names(self, values):
-        assert(len(values) == 1)
+        if len(values) != 1:
+            raise AssertionError('Length of new names must be 1, got %d'
+                                 % len(values))
         self.name = values[0]
 
     names = property(fset=_set_names, fget=_get_names)
@@ -255,7 +257,9 @@ class Index(np.ndarray):
 
     def _get_level_number(self, level):
         if not isinstance(level, int):
-            assert(level == self.name)
+            if level != self.name:
+                raise AssertionError('Level %s must be same as name (%s)'
+                                     % (level, self.name))
             level = 0
         return level
 
@@ -749,10 +753,12 @@ class Index(np.ndarray):
                             'objects')
 
         if method == 'pad':
-            assert(self.is_monotonic)
+            if not self.is_monotonic:
+                raise AssertionError('Must be monotonic for forward fill')
             indexer = self._engine.get_pad_indexer(target.values, limit)
         elif method == 'backfill':
-            assert(self.is_monotonic)
+            if not self.is_monotonic:
+                raise AssertionError('Must be monotonic for backward fill')
             indexer = self._engine.get_backfill_indexer(target.values, limit)
         elif method is None:
             indexer = self._engine.get_indexer(target.values)
@@ -1249,7 +1255,8 @@ class MultiIndex(Index):
     names = None
 
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
-        assert(len(levels) == len(labels))
+        if len(levels) != len(labels):
+            raise AssertionError('Length of levels and labels must be the same')
         if len(levels) == 0:
             raise Exception('Must pass non-zero number of levels/labels')
 
@@ -1272,7 +1279,10 @@ class MultiIndex(Index):
         if names is None:
             subarr.names = [None] * subarr.nlevels
         else:
-            assert(len(names) == subarr.nlevels)
+            if len(names) != subarr.nlevels:
+                raise AssertionError(('Length of names must be same as level '
+                                      '(%d), got %d') % (subarr.nlevels))
+
             subarr.names = list(names)
 
         # set the name
@@ -1815,7 +1825,10 @@ class MultiIndex(Index):
         ----------
         """
         order = [self._get_level_number(i) for i in order]
-        assert(len(order) == self.nlevels)
+        if len(order) != self.nlevels:
+            raise AssertionError(('Length of order must be same as '
+                                  'number of levels (%d), got %d')
+                                 % (self.nlevels, len(order)))
         new_levels = [self.levels[i] for i in order]
         new_labels = [self.labels[i] for i in order]
         new_names = [self.names[i] for i in order]
@@ -1912,11 +1925,15 @@ class MultiIndex(Index):
         self_index = self._tuple_index
 
         if method == 'pad':
-            assert(self.is_unique and self.is_monotonic)
+            if not self.is_unique or not self.is_monotonic:
+                raise AssertionError(('Must be unique and monotonic to '
+                                      'use forward fill getting the indexer'))
             indexer = self_index._engine.get_pad_indexer(target_index,
                                                          limit=limit)
         elif method == 'backfill':
-            assert(self.is_unique and self.is_monotonic)
+            if not self.is_unique or not self.is_monotonic:
+                raise AssertionError(('Must be unique and monotonic to '
+                                      'use backward fill getting the indexer'))
             indexer = self_index._engine.get_backfill_indexer(target_index,
                                                               limit=limit)
         else:
@@ -2083,7 +2100,9 @@ class MultiIndex(Index):
             return new_index
 
         if isinstance(level, (tuple, list)):
-            assert(len(key) == len(level))
+            if len(key) != len(level):
+                raise AssertionError('Key for location must have same '
+                                     'length as number of levels')
             result = None
             for lev, k in zip(level, key):
                 loc, new_index = self.get_loc_level(k, level=lev)
@@ -2329,7 +2348,8 @@ class MultiIndex(Index):
             raise TypeError('can only call with other hierarchical '
                             'index objects')
 
-        assert(self.nlevels == other.nlevels)
+        if self.nlevels != other.nlevels:
+            raise AssertionError('Must have same number of levels')
 
     def insert(self, loc, item):
         """
@@ -2477,7 +2497,8 @@ def _get_distinct_indexes(indexes):
 
 
 def _union_indexes(indexes):
-    assert(len(indexes) > 0)
+    if len(indexes) == 0:
+        raise AssertionError('Must have at least 1 Index to union')
     if len(indexes) == 1:
         result = indexes[0]
         if isinstance(result, list):
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 0cfb40047..d0410aa06 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -358,7 +358,8 @@ class _NDFrameIndexer(object):
                 return self.obj.reindex_axis(keys, axis=axis, level=level)
             except AttributeError:
                 # Series
-                assert(axis == 0)
+                if axis != 0:
+                    raise AssertionError('axis must be 0')
                 return self.obj.reindex(keys, level=level)
 
         if com._is_bool_indexer(key):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index c86821659..5f4434d4d 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -43,7 +43,9 @@ class Block(object):
         if self._ref_locs is None:
             indexer = self.ref_items.get_indexer(self.items)
             indexer = com._ensure_platform_int(indexer)
-            assert((indexer != -1).all())
+            if (indexer == -1).any():
+                raise AssertionError('Some block items were not in block '
+                                     'ref_items')
             self._ref_locs = indexer
         return self._ref_locs
 
@@ -51,7 +53,8 @@ class Block(object):
         """
         If maybe_rename=True, need to set the items for this guy
         """
-        assert(isinstance(ref_items, Index))
+        if not isinstance(ref_items, Index):
+            raise AssertionError('block ref_items must be an Index')
         if maybe_rename:
             self.items = ref_items.take(self.ref_locs)
         self.ref_items = ref_items
@@ -98,7 +101,8 @@ class Block(object):
         return make_block(values, self.items, self.ref_items)
 
     def merge(self, other):
-        assert(self.ref_items.equals(other.ref_items))
+        if not self.ref_items.equals(other.ref_items):
+            raise AssertionError('Merge operands must have same ref_items')
 
         # Not sure whether to allow this or not
         # if not union_ref.equals(other.ref_items):
@@ -287,7 +291,8 @@ class Block(object):
         return make_block(values, self.items, self.ref_items)
 
     def take(self, indexer, axis=1, fill_value=np.nan):
-        assert(axis >= 1)
+        if axis < 1:
+            raise AssertionError('axis must be at least 1, got %d' % axis)
         new_values = com.take_fast(self.values, indexer, None,
                                    None, axis=axis,
                                    fill_value=fill_value)
@@ -496,7 +501,11 @@ class BlockManager(object):
 
         ndim = len(axes)
         for block in blocks:
-            assert(ndim == block.values.ndim)
+            if ndim != block.values.ndim:
+                raise AssertionError(('Number of Block dimensions (%d) must '
+                                      'equal number of axes (%d)')
+                                     % (block.values.ndim, ndim))
+
 
         if do_integrity_check:
             self._verify_integrity()
@@ -580,10 +589,15 @@ class BlockManager(object):
     def _verify_integrity(self):
         mgr_shape = self.shape
         for block in self.blocks:
-            assert(block.ref_items is self.items)
-            assert(block.values.shape[1:] == mgr_shape[1:])
+            if block.ref_items is not self.items:
+                raise AssertionError("Block ref_items must be BlockManager "
+                                     "items")
+            if block.values.shape[1:] != mgr_shape[1:]:
+                raise AssertionError('Block shape incompatible with manager')
         tot_items = sum(len(x.items) for x in self.blocks)
-        assert(len(self.items) == tot_items)
+        if len(self.items) != tot_items:
+            raise AssertionError('Number of manager items must equal union of '
+                                 'block items')
 
     def astype(self, dtype):
         new_blocks = []
@@ -751,23 +765,28 @@ class BlockManager(object):
         if items.is_unique:
             for block in self.blocks:
                 indexer = items.get_indexer(block.items)
-                assert((indexer != -1).all())
+                if (indexer == -1).any():
+                    raise AssertionError('Items must contain all block items')
                 result[indexer] = block.get_values(dtype)
                 itemmask[indexer] = 1
         else:
             for block in self.blocks:
                 mask = items.isin(block.items)
                 indexer = mask.nonzero()[0]
-                assert(len(indexer) == len(block.items))
+                if (len(indexer) != len(block.items)):
+                    raise AssertionError('All items must be in block items')
                 result[indexer] = block.get_values(dtype)
                 itemmask[indexer] = 1
 
-        assert(itemmask.all())
+        if not itemmask.all():
+            raise AssertionError('Some items were not contained in blocks')
 
         return result
 
     def xs(self, key, axis=1, copy=True):
-        assert(axis >= 1)
+        if axis < 1:
+            raise AssertionError('Can only take xs across axis >= 1, got %d'
+                                 % axis)
 
         loc = self.axes[axis].get_loc(key)
         slicer = [slice(None, None) for _ in range(self.ndim)]
@@ -899,7 +918,9 @@ class BlockManager(object):
         """
         if value.ndim == self.ndim - 1:
             value = value.reshape((1,) + value.shape)
-        assert(value.shape[1:] == self.shape[1:])
+        if value.shape[1:] != self.shape[1:]:
+            raise AssertionError('Shape of new values must be compatible '
+                                 'with manager shape')
         if item in self.items:
             i, block = self._find_block(item)
             if not block.should_store(value):
@@ -984,7 +1005,9 @@ class BlockManager(object):
                 return self
 
         if axis == 0:
-            assert(method is None)
+            if method is not None:
+                raise AssertionError('method argument not supported for '
+                                     'axis == 0')
             return self.reindex_items(new_axis)
 
         new_axis, indexer = cur_axis.reindex(new_axis, method)
@@ -1118,7 +1141,8 @@ class BlockManager(object):
         return BlockManager(new_blocks, new_axes)
 
     def merge(self, other, lsuffix=None, rsuffix=None):
-        assert(self._is_indexed_like(other))
+        if not self._is_indexed_like(other):
+            raise AssertionError('Must have same axes to merge managers')
 
         this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
 
@@ -1157,7 +1181,9 @@ class BlockManager(object):
         """
         Check all axes except items
         """
-        assert(self.ndim == other.ndim)
+        if self.ndim != other.ndim:
+            raise AssertionError(('Number of dimensions must agree '
+                                  'got %d and %d') % (self.ndim, other.ndim))
         for ax, oax in zip(self.axes[1:], other.axes[1:]):
             if not ax.equals(oax):
                 return False
@@ -1165,7 +1191,8 @@ class BlockManager(object):
 
     def rename_axis(self, mapper, axis=1):
         new_axis = Index([mapper(x) for x in self.axes[axis]])
-        assert(new_axis.is_unique)
+        if not new_axis.is_unique:
+            raise AssertionError('New axis must be unique to rename')
 
         new_axes = list(self.axes)
         new_axes[axis] = new_axis
@@ -1231,10 +1258,12 @@ class BlockManager(object):
 
         for i, blk in enumerate(self.blocks):
             indexer = self.items.get_indexer(blk.items)
-            assert((indexer != -1).all())
+            if (indexer == -1).any():
+                raise AssertionError('Block items must be in manager items')
             result.put(indexer, i)
 
-        assert((result >= 0).all())
+        if (result < 0).any():
+            raise AssertionError('Some items were not in any block')
         return result
 
     @property
@@ -1245,7 +1274,8 @@ class BlockManager(object):
             indexer = self.items.get_indexer(blk.items)
             result.put(indexer, blk.values.dtype.name)
             mask.put(indexer, 1)
-        assert(mask.all())
+        if not (mask.all()):
+            raise AssertionError('Some items were not in any block')
         return result
 
 def form_blocks(arrays, names, axes):
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 8c6119fc8..f7d732507 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -388,7 +388,8 @@ def nancorr(a, b, method='pearson'):
     """
     a, b: ndarrays
     """
-    assert(len(a) == len(b))
+    if len(a) != len(b):
+        raise AssertionError('Operands to nancorr must have same size')
 
     valid = notnull(a) & notnull(b)
     if not valid.all():
@@ -427,7 +428,8 @@ def get_corr_func(method):
 
 
 def nancov(a, b):
-    assert(len(a) == len(b))
+    if len(a) != len(b):
+        raise AssertionError('Operands to nancov must have same size')
 
     valid = notnull(a) & notnull(b)
     if not valid.all():
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 42adf0420..2dca8a2ae 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -590,7 +590,9 @@ class Panel(NDFrame):
                                   columns=self.minor_axis)
             mat = value.values
         elif isinstance(value, np.ndarray):
-            assert(value.shape == (N, K))
+            if value.shape != (N, K):
+                raise AssertionError(('Shape of values must be (%d, %d), '
+                                      'not (%d, %d)') % ((N, K) + values.shape))
             mat = np.asarray(value)
         elif np.isscalar(value):
             dtype = _infer_dtype(value)
@@ -1394,7 +1396,8 @@ def _prep_ndarray(values, copy=True):
     else:
         if copy:
             values = values.copy()
-    assert(values.ndim == 3)
+    if values.ndim != 3:
+        raise AssertionError('Number of dimensions must be 3')
     return values
 
 
@@ -1461,7 +1464,8 @@ def _extract_axis(data, axis=0, intersect=False):
                 raise ValueError('ndarrays must match shape on axis %d' % axis)
 
             if have_frames:
-                assert(lengths[0] == len(index))
+                if lengths[0] != len(index):
+                    raise AssertionError('Length of data and index must match')
             else:
                 index = Index(np.arange(lengths[0]))
 
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index 5d611bdea..09946c9e0 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -317,7 +317,9 @@ def pivot_simple(index, columns, values):
     -------
     DataFrame
     """
-    assert(len(index) == len(columns) == len(values))
+    if (len(index) != len(columns)) or (len(columns) != len(values)):
+        raise AssertionError('Length of index, columns, and values must be the'
+                             ' same')
 
     if len(index) == 0:
         return DataFrame(index=[])
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 4a84d8f46..3241044a6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1636,7 +1636,8 @@ copy : boolean, default False
         -------
         combined : Series
         """
-        assert(isinstance(other, Series))
+        if not isinstance(other, Series):
+            raise AssertionError('Other operand must be Series')
 
         new_index = self.index
         this = self

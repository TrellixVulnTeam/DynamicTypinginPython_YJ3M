commit 7947086a4a085e52cca7152a2f8d166d8988ab52
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Fri Jan 31 05:12:02 2020 +0200

    Some code cleanups (#31462)

diff --git a/pandas/core/base.py b/pandas/core/base.py
index 05e3302ab..9fe1af776 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -1,6 +1,7 @@
 """
 Base and utility classes for pandas objects.
 """
+
 import builtins
 import textwrap
 from typing import Dict, FrozenSet, List, Optional, Union
@@ -45,11 +46,15 @@ _indexops_doc_kwargs = dict(
 
 
 class PandasObject(DirNamesMixin):
-    """baseclass for various pandas objects"""
+    """
+    Baseclass for various pandas objects.
+    """
 
     @property
     def _constructor(self):
-        """class constructor (for this class it's just `__class__`"""
+        """
+        Class constructor (for this class it's just `__class__`.
+        """
         return type(self)
 
     def __repr__(self) -> str:
@@ -77,16 +82,14 @@ class PandasObject(DirNamesMixin):
         """
         if hasattr(self, "memory_usage"):
             mem = self.memory_usage(deep=True)
-            if not is_scalar(mem):
-                mem = mem.sum()
-            return int(mem)
+            return int(mem if is_scalar(mem) else mem.sum())
 
-        # no memory_usage attribute, so fall back to
-        # object's 'sizeof'
+        # no memory_usage attribute, so fall back to object's 'sizeof'
         return super().__sizeof__()
 
     def _ensure_type(self: T, obj) -> T:
-        """Ensure that an object has same type as self.
+        """
+        Ensure that an object has same type as self.
 
         Used by type checkers.
         """
@@ -95,7 +98,8 @@ class PandasObject(DirNamesMixin):
 
 
 class NoNewAttributesMixin:
-    """Mixin which prevents adding new attributes.
+    """
+    Mixin which prevents adding new attributes.
 
     Prevents additional attributes via xxx.attribute = "something" after a
     call to `self.__freeze()`. Mainly used to prevent the user from using
@@ -106,7 +110,9 @@ class NoNewAttributesMixin:
     """
 
     def _freeze(self):
-        """Prevents setting additional attributes"""
+        """
+        Prevents setting additional attributes.
+        """
         object.__setattr__(self, "__frozen", True)
 
     # prevent adding any attribute via s.xxx.new_attribute = ...
@@ -180,14 +186,12 @@ class SelectionMixin:
     @property
     def _selection_name(self):
         """
-        return a name for myself; this would ideally be called
-        the 'name' property, but we cannot conflict with the
-        Series.name property which can be set
+        Return a name for myself;
+
+        This would ideally be called the 'name' property,
+        but we cannot conflict with the Series.name property which can be set.
         """
-        if self._selection is None:
-            return None  # 'result'
-        else:
-            return self._selection
+        return self._selection
 
     @property
     def _selection_list(self):
@@ -199,7 +203,6 @@ class SelectionMixin:
 
     @cache_readonly
     def _selected_obj(self):
-
         if self._selection is None or isinstance(self.obj, ABCSeries):
             return self.obj
         else:
@@ -246,12 +249,11 @@ class SelectionMixin:
 
         Parameters
         ----------
-        key : string / list of selections
+        key : str / list of selections
         ndim : 1,2
             requested ndim of result
         subset : object, default None
             subset to act on
-
         """
         raise AbstractMethodError(self)
 
@@ -266,7 +268,6 @@ class SelectionMixin:
         - try to find a function (or attribute) on ourselves
         - try to find a numpy function
         - raise
-
         """
         assert isinstance(arg, str)
 
@@ -585,7 +586,6 @@ class ShallowMixin:
         """
         return a new object with the replacement attributes
         """
-
         if isinstance(obj, self._constructor):
             obj = obj.obj
         for attr in self._attributes:
@@ -669,8 +669,7 @@ class IndexOpsMixin:
 
         if len(self) == 1:
             return next(iter(self))
-        else:
-            raise ValueError("can only convert an array of size 1 to a Python scalar")
+        raise ValueError("can only convert an array of size 1 to a Python scalar")
 
     @property
     def nbytes(self) -> int:
@@ -735,7 +734,6 @@ class IndexOpsMixin:
 
         Examples
         --------
-
         For regular NumPy types like int, and float, a PandasArray
         is returned.
 
@@ -851,12 +849,11 @@ class IndexOpsMixin:
         """
         if is_extension_array_dtype(self.dtype):
             return self.array.to_numpy(dtype, copy=copy, na_value=na_value, **kwargs)
-        else:
-            if kwargs:
-                msg = "to_numpy() got an unexpected keyword argument '{}'".format(
-                    list(kwargs.keys())[0]
-                )
-                raise TypeError(msg)
+        elif kwargs:
+            bad_keys = list(kwargs.keys())[0]
+            raise TypeError(
+                f"to_numpy() got an unexpected keyword argument '{bad_keys}'"
+            )
 
         result = np.asarray(self._values, dtype=dtype)
         # TODO(GH-24345): Avoid potential double copy
@@ -1076,7 +1073,9 @@ class IndexOpsMixin:
         filter_type=None,
         **kwds,
     ):
-        """ perform the reduction type operation if we can """
+        """
+        Perform the reduction type operation if we can.
+        """
         func = getattr(self, name, None)
         if func is None:
             raise TypeError(
@@ -1103,9 +1102,7 @@ class IndexOpsMixin:
             The output of the mapping function applied to the index.
             If the function returns a tuple with more than one element
             a MultiIndex will be returned.
-
         """
-
         # we can fastpath dict/Series to an efficient map
         # as we know that we are not going to have to yield
         # python types
@@ -1341,7 +1338,9 @@ class IndexOpsMixin:
 
     @property
     def is_monotonic_increasing(self) -> bool:
-        """alias for is_monotonic"""
+        """
+        Alias for is_monotonic.
+        """
         # mypy complains if we alias directly
         return self.is_monotonic
 
@@ -1455,7 +1454,6 @@ class IndexOpsMixin:
 
         Examples
         --------
-
         >>> x = pd.Series([1, 2, 3])
         >>> x
         0    1
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f3a0cf384..5016dff4d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -874,8 +874,8 @@ class DataFrame(NDFrame):
         polar   bear      22000
         koala   marsupial 80000
         >>> for label, content in df.items():
-        ...     print('label:', label)
-        ...     print('content:', content, sep='\n')
+        ...     print(f'label: {label}')
+        ...     print(f'content: {content}', sep='\n')
         ...
         label: species
         content:
diff --git a/pandas/io/excel/_pyxlsb.py b/pandas/io/excel/_pyxlsb.py
index df6a38000..0d96c8c4a 100644
--- a/pandas/io/excel/_pyxlsb.py
+++ b/pandas/io/excel/_pyxlsb.py
@@ -8,11 +8,12 @@ from pandas.io.excel._base import _BaseExcelReader
 
 class _PyxlsbReader(_BaseExcelReader):
     def __init__(self, filepath_or_buffer: FilePathOrBuffer):
-        """Reader using pyxlsb engine.
+        """
+        Reader using pyxlsb engine.
 
         Parameters
-        __________
-        filepath_or_buffer: string, path object, or Workbook
+        ----------
+        filepath_or_buffer: str, path object, or Workbook
             Object to be parsed.
         """
         import_optional_dependency("pyxlsb")
@@ -29,7 +30,7 @@ class _PyxlsbReader(_BaseExcelReader):
     def load_workbook(self, filepath_or_buffer: FilePathOrBuffer):
         from pyxlsb import open_workbook
 
-        # Todo: hack in buffer capability
+        # TODO: hack in buffer capability
         # This might need some modifications to the Pyxlsb library
         # Actual work for opening it is in xlsbpackage.py, line 20-ish
 
@@ -48,7 +49,7 @@ class _PyxlsbReader(_BaseExcelReader):
         return self.book.get_sheet(index + 1)
 
     def _convert_cell(self, cell, convert_float: bool) -> Scalar:
-        # Todo: there is no way to distinguish between floats and datetimes in pyxlsb
+        # TODO: there is no way to distinguish between floats and datetimes in pyxlsb
         # This means that there is no way to read datetime types from an xlsb file yet
         if cell.v is None:
             return ""  # Prevents non-named columns from not showing up as Unnamed: i
diff --git a/pandas/util/_test_decorators.py b/pandas/util/_test_decorators.py
index d8804994a..cd7fdd55a 100644
--- a/pandas/util/_test_decorators.py
+++ b/pandas/util/_test_decorators.py
@@ -77,8 +77,8 @@ def safe_import(mod_name: str, min_version: Optional[str] = None):
 
 
 # TODO:
-# remove when gh-24839 is fixed; this affects numpy 1.16
-# and pytables 3.4.4
+# remove when gh-24839 is fixed.
+# this affects numpy 1.16 and pytables 3.4.4
 tables = safe_import("tables")
 xfail_non_writeable = pytest.mark.xfail(
     tables
@@ -86,7 +86,7 @@ xfail_non_writeable = pytest.mark.xfail(
     and LooseVersion(tables.__version__) < LooseVersion("3.5.1"),
     reason=(
         "gh-25511, gh-24839. pytables needs a "
-        "release beyong 3.4.4 to support numpy 1.16x"
+        "release beyond 3.4.4 to support numpy 1.16.x"
     ),
 )
 

commit 29be383d1ff9355cd7b3031f595201af863406e5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Nov 16 13:06:45 2019 -0800

    REF: simplify _iterate_slices (#29629)

diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index f6c483663..6376dbefc 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -10,19 +10,7 @@ import copy
 from functools import partial
 from textwrap import dedent
 import typing
-from typing import (
-    Any,
-    Callable,
-    FrozenSet,
-    Hashable,
-    Iterable,
-    Optional,
-    Sequence,
-    Tuple,
-    Type,
-    Union,
-    cast,
-)
+from typing import Any, Callable, FrozenSet, Iterable, Sequence, Type, Union, cast
 import warnings
 
 import numpy as np
@@ -142,8 +130,8 @@ def pin_whitelisted_properties(klass: Type[FrameOrSeries], whitelist: FrozenSet[
 class SeriesGroupBy(GroupBy):
     _apply_whitelist = base.series_apply_whitelist
 
-    def _iterate_slices(self) -> Iterable[Tuple[Optional[Hashable], Series]]:
-        yield self._selection_name, self._selected_obj
+    def _iterate_slices(self) -> Iterable[Series]:
+        yield self._selected_obj
 
     @property
     def _selection_name(self):
@@ -923,20 +911,20 @@ class DataFrameGroupBy(GroupBy):
 
     agg = aggregate
 
-    def _iterate_slices(self) -> Iterable[Tuple[Optional[Hashable], Series]]:
+    def _iterate_slices(self) -> Iterable[Series]:
         obj = self._selected_obj
         if self.axis == 1:
             obj = obj.T
 
         if isinstance(obj, Series) and obj.name not in self.exclusions:
             # Occurs when doing DataFrameGroupBy(...)["X"]
-            yield obj.name, obj
+            yield obj
         else:
             for label, values in obj.items():
                 if label in self.exclusions:
                     continue
 
-                yield label, values
+                yield values
 
     def _cython_agg_general(
         self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index 746fb21c5..294cb723e 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -14,7 +14,7 @@ from functools import partial, wraps
 import inspect
 import re
 import types
-from typing import FrozenSet, Hashable, Iterable, List, Optional, Tuple, Type, Union
+from typing import FrozenSet, Iterable, List, Optional, Tuple, Type, Union
 
 import numpy as np
 
@@ -439,7 +439,7 @@ class _GroupBy(PandasObject, SelectionMixin):
         def get_converter(s):
             # possibly convert to the actual key types
             # in the indices, could be a Timestamp or a np.datetime64
-            if isinstance(s, (Timestamp, datetime.datetime)):
+            if isinstance(s, datetime.datetime):
                 return lambda key: Timestamp(key)
             elif isinstance(s, np.datetime64):
                 return lambda key: Timestamp(key).asm8
@@ -488,6 +488,7 @@ class _GroupBy(PandasObject, SelectionMixin):
 
     @cache_readonly
     def _selected_obj(self):
+        # Note: _selected_obj is always just `self.obj` for SeriesGroupBy
 
         if self._selection is None or isinstance(self.obj, Series):
             if self._group_selection is not None:
@@ -736,7 +737,7 @@ b  2""",
             keys, values, not_indexed_same=mutated or self.mutated
         )
 
-    def _iterate_slices(self) -> Iterable[Tuple[Optional[Hashable], Series]]:
+    def _iterate_slices(self) -> Iterable[Series]:
         raise AbstractMethodError(self)
 
     def transform(self, func, *args, **kwargs):
@@ -832,7 +833,8 @@ b  2""",
 
     def _cython_transform(self, how: str, numeric_only: bool = True, **kwargs):
         output = collections.OrderedDict()  # type: dict
-        for name, obj in self._iterate_slices():
+        for obj in self._iterate_slices():
+            name = obj.name
             is_numeric = is_numeric_dtype(obj.dtype)
             if numeric_only and not is_numeric:
                 continue
@@ -864,7 +866,8 @@ b  2""",
         self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1
     ):
         output = {}
-        for name, obj in self._iterate_slices():
+        for obj in self._iterate_slices():
+            name = obj.name
             is_numeric = is_numeric_dtype(obj.dtype)
             if numeric_only and not is_numeric:
                 continue
@@ -883,7 +886,8 @@ b  2""",
 
         # iterate through "columns" ex exclusions to populate output dict
         output = {}
-        for name, obj in self._iterate_slices():
+        for obj in self._iterate_slices():
+            name = obj.name
             if self.grouper.ngroups == 0:
                 # agg_series below assumes ngroups > 0
                 continue
@@ -2234,7 +2238,8 @@ class GroupBy(_GroupBy):
         output = collections.OrderedDict()  # type: dict
         base_func = getattr(libgroupby, how)
 
-        for name, obj in self._iterate_slices():
+        for obj in self._iterate_slices():
+            name = obj.name
             values = obj._data._values
 
             if aggregate:

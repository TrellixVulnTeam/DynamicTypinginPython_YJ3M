commit 002da29c7727cd3b1f9ac2664ee71261d2fe5570
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Dec 5 07:36:04 2019 -0800

    CLN: simplify pytables create_axes (#30068)

diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index c56445d6c..5a3f488dd 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -3832,6 +3832,7 @@ class Table(Fixed):
         else:
             existing_table = None
 
+        assert self.ndim == 2  # with next check, we must have len(axes) == 1
         # currently support on ndim-1 axes
         if len(axes) != self.ndim - 1:
             raise ValueError(
@@ -3846,63 +3847,58 @@ class Table(Fixed):
         if nan_rep is None:
             nan_rep = "nan"
 
-        # create axes to index and non_index
-        index_axes_map = dict()
-        for i, a in enumerate(obj.axes):
+        # We construct the non-index-axis first, since that alters self.info
+        idx = [x for x in [0, 1] if x not in axes][0]
 
-            if i in axes:
-                name = obj._AXIS_NAMES[i]
-                new_index = _convert_index(name, a, self.encoding, self.errors)
-                new_index.axis = i
-                index_axes_map[i] = new_index
-
-            else:
+        a = obj.axes[idx]
+        # we might be able to change the axes on the appending data if necessary
+        append_axis = list(a)
+        if existing_table is not None:
+            indexer = len(new_non_index_axes)  # i.e. 0
+            exist_axis = existing_table.non_index_axes[indexer][1]
+            if not array_equivalent(np.array(append_axis), np.array(exist_axis)):
 
-                # we might be able to change the axes on the appending data if
-                # necessary
-                append_axis = list(a)
-                if existing_table is not None:
-                    indexer = len(new_non_index_axes)
-                    exist_axis = existing_table.non_index_axes[indexer][1]
-                    if not array_equivalent(
-                        np.array(append_axis), np.array(exist_axis)
-                    ):
-
-                        # ahah! -> reindex
-                        if array_equivalent(
-                            np.array(sorted(append_axis)), np.array(sorted(exist_axis))
-                        ):
-                            append_axis = exist_axis
+                # ahah! -> reindex
+                if array_equivalent(
+                    np.array(sorted(append_axis)), np.array(sorted(exist_axis))
+                ):
+                    append_axis = exist_axis
 
-                # the non_index_axes info
-                info = _get_info(self.info, i)
-                info["names"] = list(a.names)
-                info["type"] = type(a).__name__
+        # the non_index_axes info
+        info = self.info.setdefault(idx, {})
+        info["names"] = list(a.names)
+        info["type"] = type(a).__name__
 
-                new_non_index_axes.append((i, append_axis))
+        new_non_index_axes.append((idx, append_axis))
 
-        self.non_index_axes = new_non_index_axes
+        # Now we can construct our new index axis
+        idx = axes[0]
+        a = obj.axes[idx]
+        name = obj._AXIS_NAMES[idx]
+        new_index = _convert_index(name, a, self.encoding, self.errors)
+        new_index.axis = idx
 
-        # set axis positions (based on the axes)
-        new_index_axes = [index_axes_map[a] for a in axes]
-        for j, iax in enumerate(new_index_axes):
-            iax.set_pos(j)
-            iax.update_info(self.info)
+        # Because we are always 2D, there is only one new_index, so
+        #  we know it will have pos=0
+        new_index.set_pos(0)
+        new_index.update_info(self.info)
+        new_index.maybe_set_size(min_itemsize)  # check for column conflicts
 
-        j = len(new_index_axes)
+        self.non_index_axes = new_non_index_axes
 
-        # check for column conflicts
-        for a in new_index_axes:
-            a.maybe_set_size(min_itemsize=min_itemsize)
+        new_index_axes = [new_index]
+        j = len(new_index_axes)  # i.e. 1
+        assert j == 1
 
         # reindex by our non_index_axes & compute data_columns
+        assert len(new_non_index_axes) == 1
         for a in new_non_index_axes:
             obj = _reindex_axis(obj, a[0], a[1])
 
         def get_blk_items(mgr, blocks):
             return [mgr.items.take(blk.mgr_locs) for blk in blocks]
 
-        transposed = new_index_axes[0].axis == 1
+        transposed = new_index.axis == 1
 
         # figure out data_columns and get out blocks
         block_obj = self.get_object(obj, transposed)._consolidate()

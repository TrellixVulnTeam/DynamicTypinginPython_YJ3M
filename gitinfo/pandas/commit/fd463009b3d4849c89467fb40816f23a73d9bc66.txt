commit fd463009b3d4849c89467fb40816f23a73d9bc66
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 26 23:57:34 2011 -0400

    ENH: got new merging function working. many more test cases required however. bumped dev version to 0.4.2

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 826015706..5e5ecb887 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -171,28 +171,32 @@ def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
             needs_masking = mask.any()
 
         if needs_masking:
-            out = arr.take(indexer, axis=axis)
-            out = _maybe_upcast(out)
-            null_out_axis(out, mask, axis)
+            # upcasting may be required
+            result = arr.take(indexer, axis=axis, out=out)
+            result = _maybe_mask(result, mask, needs_masking, axis=axis,
+                                 out_passed=out is not None)
+            return result
         else:
-            out = np.empty(out_shape, dtype=arr.dtype)
+            if out is None:
+                out = np.empty(out_shape, dtype=arr.dtype)
             take_f = _get_take2d_function(dtype_str, axis=axis)
             take_f(arr, indexer, out=out)
+            return out
     elif dtype_str in ('float64', 'object'):
-        out = np.empty(out_shape, dtype=arr.dtype)
+        if out is None:
+            out = np.empty(out_shape, dtype=arr.dtype)
         take_f = _get_take2d_function(dtype_str, axis=axis)
         take_f(arr, indexer, out=out)
+        return out
     else:
         if mask is None:
             mask = indexer == -1
             needs_masking = mask.any()
 
-        out = arr.take(indexer, axis=axis)
-        if needs_masking:
-            out = _maybe_upcast(out)
-            null_out_axis(out, mask, axis)
-
-    return out
+        result = arr.take(indexer, axis=axis, out=out)
+        result = _maybe_mask(result, mask, needs_masking, axis=axis,
+                             out_passed=out is not None)
+        return result
 
 def null_out_axis(arr, mask, axis):
     indexer = [slice(None)] * arr.ndim
@@ -206,16 +210,20 @@ def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None):
                        needs_masking=needs_masking,
                        axis=axis)
 
-    if out is None:
-        out = arr.take(indexer, axis=axis)
-        if needs_masking:
-            out = _maybe_upcast(out)
-            null_out_axis(out, mask, axis)
-    else:
-        out = arr.take(indexer, axis=axis)
-        if needs_masking and _need_upcast(out):
+    result = arr.take(indexer, axis=axis, out=out)
+    result = _maybe_mask(result, mask, needs_masking, axis=axis,
+                         out_passed=out is not None)
+    return result
+
+def _maybe_mask(result, mask, needs_masking, axis=0, out_passed=False):
+    if needs_masking:
+        if out_passed and _need_upcast(result):
             raise Exception('incompatible type for NAs')
-    return out
+        else:
+            # a bit spaghettified
+            result = _maybe_upcast(result)
+            null_out_axis(result, mask, axis)
+    return result
 
 def _maybe_upcast(values):
     if issubclass(values.dtype.type, np.int_):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3a0a47c47..237031c93 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2148,13 +2148,15 @@ class DataFrame(NDFrame):
         return self._constructor(new_data)
 
     def _join_index(self, other, how, lsuffix, rsuffix):
+        from pandas.core.internals import merge_managers
+
         join_index = self._get_join_index(other, how)
 
-        this = self.reindex(join_index)
-        other = other.reindex(join_index)
+        thisdata, otherdata = self._data._maybe_rename_join(
+            other._data, lsuffix, rsuffix, copydata=False)
 
-        # merge blocks
-        merged_data = this._data.merge(other._data, lsuffix, rsuffix)
+        # this will always ensure copied data
+        merged_data = merge_managers(thisdata, otherdata, join_index, axis=1)
         return self._constructor(merged_data)
 
     def _get_join_index(self, other, how):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 8dd5629c4..7713bc642 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -123,6 +123,9 @@ class Index(np.ndarray):
 
             return Index(arr_idx[key])
 
+    def append(self, other):
+        return Index(np.concatenate((self.values, other.values)))
+
     def take(self, *args, **kwargs):
         """
         Analogous to ndarray.take
@@ -718,6 +721,10 @@ class MultiIndex(Index):
         new_labels = [lab.take(*args, **kwargs) for lab in self.labels]
         return MultiIndex(levels=self.levels, labels=new_labels)
 
+    def append(self, other):
+        new_tuples = np.concatenate((self.values, other.values))
+        return MultiIndex.from_tuples(new_tuples, names=self.names)
+
     def argsort(self, *args, **kwargs):
         return self.get_tuple_index().argsort()
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index a7ddda876..3d4af1b4f 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -611,43 +611,7 @@ class BlockManager(object):
 
         return BlockManager(consolidated, new_axes)
 
-    def merge_with_indexers(self, other, lindexer, lmask, rindexer, rmask,
-                            axis=1):
-        """
-        Parameters
-        ----------
-        other
-        lindexer
-        lmask
-        rindexer
-        rmask
-
-        Returns
-        -------
-        merged : BlockManager
-        """
-        assert(self.is_consolidated())
-        assert(other.is_consolidated())
-
-        this_blockmap = dict((type(blk), blk) for blk in self.blocks)
-        other_blockmap = dict((type(blk), blk) for blk in other.blocks)
-        result_blocks = []
-
-        kinds = [FloatBlock, ObjectBlock, BoolBlock, IntBlock]
-        for klass in kinds:
-            if klass in this_blockmap and other_blockmap:
-                # true merge
-                pass
-            elif klass in this_blockmap:
-                # only take necessary
-                pass
-            elif klass in other_blockmap:
-                # only take necessary
-                pass
-
-        return BlockManager(consolidated, new_axes)
-
-    def _maybe_rename_join(self, other, lsuffix, rsuffix):
+    def _maybe_rename_join(self, other, lsuffix, rsuffix, copydata=True):
         intersection = self.items.intersection(other.items)
 
         if len(intersection) > 0:
@@ -665,8 +629,8 @@ class BlockManager(object):
                 return x
 
             # XXX: COPIES DATA!
-            this = self.rename_items(lrenamer)
-            other = other.rename_items(rrenamer)
+            this = self.rename_items(lrenamer, copydata=copydata)
+            other = other.rename_items(rrenamer, copydata=copydata)
         else:
             this = self
 
@@ -932,9 +896,11 @@ def merge_managers(left, right, index, axis=1):
     assert(left.is_consolidated())
     assert(right.is_consolidated())
 
+    N = len(index)
+
     if left.axes[axis].equals(index):
-        lindexer = np.arange(index, dtype=np.int32)
-        lmask = np.zeros(len(index), dtype=np.bool)
+        lindexer = np.arange(N, dtype=np.int32)
+        lmask = np.zeros(N, dtype=np.bool)
         lneed_masking = False
     else:
         lindexer = left.axes[axis].get_indexer(index)
@@ -942,8 +908,8 @@ def merge_managers(left, right, index, axis=1):
         lneed_masking = lmask.any()
 
     if right.axes[axis].equals(index):
-        rindexer = np.arange(index, dtype=np.int32)
-        rmask = np.zeros(len(index), dtype=np.bool)
+        rindexer = np.arange(N, dtype=np.int32)
+        rmask = np.zeros(N, dtype=np.bool)
         rneed_masking = False
     else:
         rindexer = right.axes[axis].get_indexer(index)
@@ -965,17 +931,19 @@ def merge_managers(left, right, index, axis=1):
 
     result_blocks = []
 
+    # copies all data by definition
+
     kinds = [FloatBlock, ObjectBlock, BoolBlock, IntBlock]
     for klass in kinds:
-        if klass in left_blockmap and right_blockmap:
-            # true merge
-            left = left_blockmap[klass]
-            right = right_blockmap[klass]
-            new_values = _merge_blocks_fast(left, right,
+        if klass in left_blockmap and klass in right_blockmap:
+            # true merge, do not produce intermediate copy
+            lblk = left_blockmap[klass]
+            rblk = right_blockmap[klass]
+            new_values = _merge_blocks_fast(lblk, rblk,
                                             lindexer, lmask, lneed_masking,
                                             rindexer, rmask, rneed_masking,
                                             axis=axis)
-            new_items = left.items.append(right.items)
+            new_items = lblk.items.append(rblk.items)
             res_blk = make_block(new_values, new_items, result_items)
         elif klass in left_blockmap:
             # only take necessary
@@ -989,6 +957,9 @@ def merge_managers(left, right, index, axis=1):
             res_blk = blk.reindex_axis(lindexer, lmask, lneed_masking,
                                        axis=axis)
             res_blk.ref_items = result_items
+        else:
+            # not found in either
+            continue
 
         result_blocks.append(res_blk)
 
@@ -1013,7 +984,7 @@ def _maybe_upcast_blocks(blocks, needs_masking):
         new_blocks.append(newb)
 
     # use any ref_items
-    return _consolidate(blocks, newb.ref_items)
+    return _consolidate(new_blocks, newb.ref_items)
 
 def _merge_blocks_fast(left, right, lindexer, lmask, lneed_masking,
                        rindexer, rmask, rneed_masking, axis=1):
@@ -1027,8 +998,8 @@ def _merge_blocks_fast(left, right, lindexer, lmask, lneed_masking,
 
     out = np.empty(out_shape, dtype=left.values.dtype)
     common.take_fast(left.values, lindexer, lmask, lneed_masking,
-                     axis=axis, out=out[:lk].T)
+                     axis=axis, out=out[:lk])
     common.take_fast(right.values, rindexer, rmask, rneed_masking,
-                     axis=axis, out=out[lk:].T)
+                     axis=axis, out=out[lk:])
 
     return out
diff --git a/pandas/stats/tests/test_ols.py b/pandas/stats/tests/test_ols.py
index 0af72752e..be6b436e8 100644
--- a/pandas/stats/tests/test_ols.py
+++ b/pandas/stats/tests/test_ols.py
@@ -415,14 +415,12 @@ class TestPanelOLS(BaseTest):
         result = ols(y=self.panel_y2, x=self.panel_x2, entity_effects=True)
 
         assert_almost_equal(result._y.values.flat, [1, 4, 5])
-        exp_x = [[0, 6, 14, 1], [0, 9, 17, 1], [1, 30, 48, 1]]
-        # exp_x = [[6, 14, 0, 1], [9, 17, 0, 1], [30, 48, 1, 1]]
-        assert_almost_equal(result._x.values, exp_x)
-
-        exp_index = Index(['FE_B', 'x1', 'x2', 'intercept'])
-        # exp_index = Index(['x1', 'x2', 'FE_B', 'intercept'])
-        self.assertTrue(exp_index.equals(result._x.items))
 
+        exp_x = DataFrame([[0, 6, 14, 1], [0, 9, 17, 1], [1, 30, 48, 1]],
+                          index=result._x.index, columns=['FE_B', 'x1', 'x2',
+                                                          'intercept'],
+                          dtype=float)
+        tm.assert_frame_equal(result._x, exp_x.ix[:, result._x.columns])
         # _check_non_raw_results(result)
 
     def testWithEntityEffectsAndDroppedDummies(self):
@@ -430,13 +428,11 @@ class TestPanelOLS(BaseTest):
                      dropped_dummies={'entity' : 'B'})
 
         assert_almost_equal(result._y.values.flat, [1, 4, 5])
-        exp_x = [[1, 6, 14, 1], [1, 9, 17, 1], [0, 30, 48, 1]]
-        # exp_x = [[6, 14, 1, 1], [9, 17, 1, 1], [30, 48, 0, 1]]
-        assert_almost_equal(result._x.values, exp_x)
-
-        exp_index = Index(['FE_A', 'x1', 'x2', 'intercept'])
-        self.assertTrue(exp_index.equals(result._x.items))
-
+        exp_x = DataFrame([[1, 6, 14, 1], [1, 9, 17, 1], [0, 30, 48, 1]],
+                          index=result._x.index, columns=['FE_A', 'x1', 'x2',
+                                                          'intercept'],
+                          dtype=float)
+        tm.assert_frame_equal(result._x, exp_x.ix[:, result._x.columns])
         # _check_non_raw_results(result)
 
     def testWithXEffects(self):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 16df6056c..259ef2f6c 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -690,7 +690,9 @@ class SafeForSparse(object):
         df2_suf = df2.ix[:, ['B', 'C']].add_suffix('_df2')
         no_overlap = self.frame.ix[:, ['A', 'D']]
         expected = df1_suf.join(df2_suf).join(no_overlap)
-        assert_frame_equal(joined, expected)
+
+        # column order not necessarily sorted
+        assert_frame_equal(joined, expected.ix[:, joined.columns])
 
     def test_add_prefix_suffix(self):
         with_prefix = self.frame.add_prefix('foo#')
diff --git a/setup.py b/setup.py
index bf897f256..671afcbc9 100755
--- a/setup.py
+++ b/setup.py
@@ -117,7 +117,7 @@ CLASSIFIERS = [
 
 MAJOR = 0
 MINOR = 4
-MICRO = 1
+MICRO = 2
 ISRELEASED = False
 VERSION = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
 

commit ed98ff0ea7a920356dbb1c3af9e29eab1c041823
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Fri Nov 29 18:43:43 2019 +0200

    STY: x.__class__ to type(x) #batch-3 (#29894)

diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index b52015b73..67412ed5e 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -105,7 +105,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
     def __call__(self, axis=None):
         # we need to return a copy of ourselves
-        new_self = self.__class__(self.name, self.obj)
+        new_self = type(self)(self.name, self.obj)
 
         if axis is not None:
             axis = self.obj._get_axis_number(axis)
@@ -228,7 +228,9 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
         raise AbstractMethodError(self)
 
     def _has_valid_tuple(self, key: Tuple):
-        """ check the key for valid keys across my indexer """
+        """
+        Check the key for valid keys across my indexer.
+        """
         for i, k in enumerate(key):
             if i >= self.ndim:
                 raise IndexingError("Too many indexers")
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 2d6ffb727..e4de1c94d 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -257,11 +257,11 @@ class Block(PandasObject):
             placement = self.mgr_locs
         if ndim is None:
             ndim = self.ndim
-        return make_block(values, placement=placement, ndim=ndim, klass=self.__class__)
+        return make_block(values, placement=placement, ndim=ndim, klass=type(self))
 
     def __repr__(self) -> str:
         # don't want to print out all of the items here
-        name = pprint_thing(self.__class__.__name__)
+        name = type(self).__name__
         if self._is_single_block:
 
             result = "{name}: {len} dtype: {dtype}".format(
diff --git a/pandas/core/internals/concat.py b/pandas/core/internals/concat.py
index f981c00fd..6c4ab2882 100644
--- a/pandas/core/internals/concat.py
+++ b/pandas/core/internals/concat.py
@@ -122,7 +122,7 @@ class JoinUnit:
 
     def __repr__(self) -> str:
         return "{name}({block!r}, {indexers})".format(
-            name=self.__class__.__name__, block=self.block, indexers=self.indexers
+            name=type(self).__name__, block=self.block, indexers=self.indexers
         )
 
     @cache_readonly
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index 19901dc51..0fe95a4b7 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -153,7 +153,7 @@ class BlockManager(PandasObject):
             blocks = np.array([], dtype=self.array_dtype)
         else:
             blocks = []
-        return self.__class__(blocks, axes)
+        return type(self)(blocks, axes)
 
     def __nonzero__(self):
         return True
@@ -316,7 +316,7 @@ class BlockManager(PandasObject):
         return len(self.items)
 
     def __repr__(self) -> str:
-        output = pprint_thing(self.__class__.__name__)
+        output = type(self).__name__
         for i, ax in enumerate(self.axes):
             if i == 0:
                 output += "\nItems: {ax}".format(ax=ax)
@@ -430,7 +430,7 @@ class BlockManager(PandasObject):
 
         if len(result_blocks) == 0:
             return self.make_empty(axes or self.axes)
-        bm = self.__class__(
+        bm = type(self)(
             result_blocks, axes or self.axes, do_integrity_check=do_integrity_check
         )
         bm._consolidate_inplace()
@@ -519,7 +519,7 @@ class BlockManager(PandasObject):
                     for b in blocks
                 ]
 
-            return self.__class__(blocks, new_axes)
+            return type(self)(blocks, new_axes)
 
         # single block, i.e. ndim == {1}
         values = concat_compat([b.values for b in blocks])
@@ -629,7 +629,7 @@ class BlockManager(PandasObject):
                 rb = new_rb
             result_blocks.extend(rb)
 
-        bm = self.__class__(result_blocks, self.axes)
+        bm = type(self)(result_blocks, self.axes)
         bm._consolidate_inplace()
         return bm
 
@@ -724,7 +724,7 @@ class BlockManager(PandasObject):
         axes = list(self.axes)
         axes[0] = self.items.take(indexer)
 
-        return self.__class__(new_blocks, axes, do_integrity_check=False)
+        return type(self)(new_blocks, axes, do_integrity_check=False)
 
     def get_slice(self, slobj, axis=0):
         if axis >= self.ndim:
@@ -741,7 +741,7 @@ class BlockManager(PandasObject):
         new_axes = list(self.axes)
         new_axes[axis] = new_axes[axis][slobj]
 
-        bm = self.__class__(new_blocks, new_axes, do_integrity_check=False)
+        bm = type(self)(new_blocks, new_axes, do_integrity_check=False)
         bm._consolidate_inplace()
         return bm
 
@@ -917,7 +917,7 @@ class BlockManager(PandasObject):
         if self.is_consolidated():
             return self
 
-        bm = self.__class__(self.blocks, self.axes)
+        bm = type(self)(self.blocks, self.axes)
         bm._is_consolidated = False
         bm._consolidate_inplace()
         return bm
@@ -1251,7 +1251,7 @@ class BlockManager(PandasObject):
 
         new_axes = list(self.axes)
         new_axes[axis] = new_axis
-        return self.__class__(new_blocks, new_axes)
+        return type(self)(new_blocks, new_axes)
 
     def _slice_take_blocks_ax0(self, slice_or_indexer, fill_tuple=None):
         """
@@ -1521,9 +1521,7 @@ class SingleBlockManager(BlockManager):
         if axis >= self.ndim:
             raise IndexError("Requested axis not found in manager")
 
-        return self.__class__(
-            self._block._slice(slobj), self.index[slobj], fastpath=True
-        )
+        return type(self)(self._block._slice(slobj), self.index[slobj], fastpath=True)
 
     @property
     def index(self):
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index 2433e3f52..58c4a97d6 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -96,7 +96,7 @@ class Resampler(_GroupBy, ShallowMixin):
             if getattr(self.groupby, k, None) is not None
         )
         return "{klass} [{attrs}]".format(
-            klass=self.__class__.__name__, attrs=", ".join(attrs)
+            klass=type(self).__name__, attrs=", ".join(attrs)
         )
 
     def __getattr__(self, attr):
@@ -885,7 +885,7 @@ class Resampler(_GroupBy, ShallowMixin):
         result = self._downsample("count")
         if not len(self.ax):
             if self._selected_obj.ndim == 1:
-                result = self._selected_obj.__class__(
+                result = type(self._selected_obj)(
                     [], index=result.index, dtype="int64", name=self._selected_obj.name
                 )
             else:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7f63b2575..560396056 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -256,9 +256,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             elif is_extension_array_dtype(data):
                 pass
             elif isinstance(data, (set, frozenset)):
-                raise TypeError(
-                    "{0!r} type is unordered".format(data.__class__.__name__)
-                )
+                raise TypeError(f"{repr(type(data).__name__)} type is unordered")
             elif isinstance(data, ABCSparseArray):
                 # handle sparse passed here (and force conversion)
                 data = data.to_dense()
@@ -1535,9 +1533,8 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         # catch contract violations
         if not isinstance(result, str):
             raise AssertionError(
-                "result must be of type unicode, type"
-                " of result is {0!r}"
-                "".format(result.__class__.__name__)
+                "result must be of type str, type"
+                f" of result is {repr(type(result).__name__)}"
             )
 
         if buf is None:
diff --git a/pandas/core/window/rolling.py b/pandas/core/window/rolling.py
index 7f3404100..d8aa36208 100644
--- a/pandas/core/window/rolling.py
+++ b/pandas/core/window/rolling.py
@@ -204,7 +204,7 @@ class _Window(PandasObject, ShallowMixin, SelectionMixin):
 
     @property
     def _window_type(self) -> str:
-        return self.__class__.__name__
+        return type(self).__name__
 
     def __repr__(self) -> str:
         """
diff --git a/pandas/errors/__init__.py b/pandas/errors/__init__.py
index 73cc40ae0..34838af5f 100644
--- a/pandas/errors/__init__.py
+++ b/pandas/errors/__init__.py
@@ -178,6 +178,6 @@ class AbstractMethodError(NotImplementedError):
         if self.methodtype == "classmethod":
             name = self.class_instance.__name__
         else:
-            name = self.class_instance.__class__.__name__
+            name = type(self.class_instance).__name__
         msg = "This {methodtype} must be defined in the concrete class {name}"
         return msg.format(methodtype=self.methodtype, name=name)
diff --git a/pandas/io/clipboard/__init__.py b/pandas/io/clipboard/__init__.py
index 7d3dbaf6e..f808b7e70 100644
--- a/pandas/io/clipboard/__init__.py
+++ b/pandas/io/clipboard/__init__.py
@@ -95,8 +95,8 @@ def _stringifyText(text) -> str:
     acceptedTypes = (str, int, float, bool)
     if not isinstance(text, acceptedTypes):
         raise PyperclipException(
-            f"only str, int, float, and bool values"
-            f"can be copied to the clipboard, not {text.__class__.__name__}"
+            f"only str, int, float, and bool values "
+            f"can be copied to the clipboard, not {type(text).__name__}"
         )
     return str(text)
 

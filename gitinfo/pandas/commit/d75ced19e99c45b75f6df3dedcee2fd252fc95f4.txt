commit d75ced19e99c45b75f6df3dedcee2fd252fc95f4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Oct 1 02:26:36 2010 -0400

    API changes, cleanup, unit testing

diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 793ba3e73..05e37e022 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -9,87 +9,12 @@ import numpy as np
 
 from pandas.core.api import (DataFrame, DataMatrix, Series, notnull)
 import pandas.lib.tseries as tseries
-import pandas.util.misc as misc_util
 
 __all__ = ['rolling_count', 'rolling_max', 'rolling_min',
            'rolling_sum', 'rolling_mean', 'rolling_std', 'rolling_cov',
            'rolling_corr', 'rolling_var', 'rolling_skew', 'rolling_kurt',
            'rolling_median', 'ewma', 'ewmvol', 'ewmcorr', 'ewmcov']
 
-
-#-------------------------------------------------------------------------------
-# Python interface to Cython functions
-
-def _check_arg(arg):
-    if not issubclass(arg.dtype.type, float):
-        arg = arg.astype(float)
-
-    return arg
-
-def _two_periods(minp, window):
-    if minp is None:
-        return window
-    else:
-        return max(2, minp)
-
-def _use_window(minp, window):
-    if minp is None:
-        return window
-    else:
-        return minp
-
-def _wrap_cython(f, check_minp=_use_window):
-    def wrapper(arg, window, minp=None):
-        minp = check_minp(minp, window)
-        arg = _check_arg(arg)
-        return f(arg, window, minp)
-
-    return wrapper
-
-_rolling_sum = _wrap_cython(tseries.roll_sum)
-_rolling_max = _wrap_cython(tseries.roll_max)
-_rolling_min = _wrap_cython(tseries.roll_min)
-_rolling_mean = _wrap_cython(tseries.roll_mean)
-_rolling_median = _wrap_cython(tseries.roll_median)
-_rolling_var = _wrap_cython(tseries.roll_var, check_minp=_two_periods)
-_rolling_skew = _wrap_cython(tseries.roll_skew, check_minp=_two_periods)
-_rolling_kurt = _wrap_cython(tseries.roll_kurt, check_minp=_two_periods)
-_rolling_std = lambda *a, **kw: np.sqrt(_rolling_var(*a, **kw))
-
-def _ewma(arg, com):
-    arg = _check_arg(arg)
-    return tseries.ewma(arg, com)
-
-#-------------------------------------------------------------------------------
-# Rolling statistics
-
-_doc_template = """
-%s
-
-Parameters
-----------
-arg : 1D ndarray, Series, or DataFrame/DataMatrix
-window : Number of observations used for calculating statistic
-min_periods : int
-    Minimum number of observations in window required to have a value
-time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default=None
-    Name of time rule to conform to before computing statistic
-
-Returns
--------
-y : type of input argument
-"""
-
-def _rolling_func(func, desc):
-    @wraps(func)
-    def f(arg, window, min_periods=None, time_rule=None):
-        return _rollingMoment(arg, window, func, min_periods,
-                              time_rule=time_rule)
-
-    f.__doc__ = _doc_template % desc
-
-    return f
-
 def rolling_count(arg, window, time_rule=None):
     """
     Rolling count of number of observations inside provided window.
@@ -99,27 +24,22 @@ def rolling_count(arg, window, time_rule=None):
     arg :  DataFrame or numpy ndarray-like
     window : Number of observations used for calculating statistic
     """
-    types = (DataFrame, DataMatrix, Series)
-    if time_rule is not None and isinstance(arg, types):
+    if time_rule is not None and isinstance(arg, (DataFrame, Series)):
         # Conform to whatever frequency needed.
         arg = arg.asfreq(time_rule)
 
     window = min(window, len(arg))
-    if isinstance(arg, DataMatrix):
-        arg = arg.copy()
-        arg.values = np.isfinite(arg.values).astype(float)
-        result = rolling_sum(arg, window, min_periods=1, time_rule=time_rule)
-        result.values[np.isnan(result.values)] = 0
-    elif isinstance(arg, DataFrame):
-        converter = lambda x: np.isfinite(x).astype(float)
-        arg = arg.apply(converter)
-        result = rolling_sum(arg, window, min_periods=1, time_rule=time_rule)
-        result = result.fill(value=0)
-    else:
-        arg = np.isfinite(arg).astype(float)
-        result = rolling_sum(arg, window, min_periods=1, time_rule=time_rule)
-        result[np.isnan(result)] = 0
-    return result
+
+    return_hook, values = _process_data_structure(arg, kill_inf=False)
+
+    converted = np.isfinite(values).astype(float)
+    result = rolling_sum(converted, window, min_periods=1,
+                         time_rule=time_rule)
+
+    # putmask here?
+    result[np.isnan(result)] = 0
+
+    return return_hook(result)
 
 def rolling_cov(arg1, arg2, window, min_periods=None, time_rule=None):
     """
@@ -133,10 +53,22 @@ def rolling_cov(arg1, arg2, window, min_periods=None, time_rule=None):
         Minimum number of observations in window required to have a value
     time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default=None
         Name of time rule to conform to before computing statistic
+
+    Returns
+    -------
+    y : type of input
+
+    Note
+    ----
+    cov(X,Y) = (E(X * Y) - E(X)E(Y)) * window / (window - 1)
     """
-    num1 = rolling_mean(arg1*arg2, window, min_periods, time_rule) #E(XY)
+    # TODO: filter down to common region
+    # E(XY)
+    num1 = rolling_mean(arg1 * arg2, window, min_periods, time_rule)
+
+    # E(X)E (Y)
     num2 = (rolling_mean(arg1, window, min_periods, time_rule) *
-            rolling_mean(arg2, window, min_periods, time_rule)) #E(X)E(Y)
+            rolling_mean(arg2, window, min_periods, time_rule))
     return (num1 - num2) * window / (window - 1)
 
 def rolling_corr(arg1, arg2, window, min_periods=None, time_rule=None):
@@ -151,24 +83,17 @@ def rolling_corr(arg1, arg2, window, min_periods=None, time_rule=None):
         Minimum number of observations in window required to have a value
     time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default=None
         Name of time rule to conform to before computing statistic
+
+    Returns
+    -------
+    y : type of input
     """
     num = rolling_cov(arg1, arg2, window, min_periods, time_rule)
     den  = (rolling_std(arg1, window, min_periods, time_rule) *
             rolling_std(arg2, window, min_periods, time_rule))
     return num / den
 
-rolling_max = _rolling_func(_rolling_max, 'Moving maximum')
-rolling_min = _rolling_func(_rolling_min, 'Moving minimum')
-rolling_sum = _rolling_func(_rolling_sum, 'Moving sum')
-rolling_mean = _rolling_func(_rolling_mean, 'Moving mean')
-rolling_median = _rolling_func(_rolling_median, 'Moving median')
-rolling_std = _rolling_func(_rolling_std,
-                            'Unbiased moving standard deviation')
-rolling_var = _rolling_func(_rolling_var, 'Unbiased moving variance')
-rolling_skew = _rolling_func(_rolling_skew, 'Unbiased moving skewness')
-rolling_kurt = _rolling_func(_rolling_kurt, 'Unbiased moving kurtosis')
-
-def _rollingMoment(arg, window, func, minp, time_rule=None):
+def _rolling_moment(arg, window, func, minp, axis=0, time_rule=None):
     """
     Rolling statistical measure using supplied function. Designed to be
     used with passed-in Cython array-based functions.
@@ -180,52 +105,55 @@ def _rollingMoment(arg, window, func, minp, time_rule=None):
     func : Cython function to compute rolling statistic on raw series
     minp : int
         Minimum number of observations required to have a value
+    axis : int, default 0
+    time_rule : string or DateOffset
+        Time rule to conform to before computing result
+
+    Returns
+    -------
+    y : type of input
     """
-    types = (DataFrame, DataMatrix, Series)
+    types = (DataFrame, Series)
     if time_rule is not None and isinstance(arg, types):
         # Conform to whatever frequency needed.
         arg = arg.asfreq(time_rule)
 
-    if isinstance(arg, DataMatrix):
-        T, N = arg.values.shape
-        resultMatrix = np.empty((T, N), dtype=arg.values.dtype)
-        arg.values[np.isinf(arg.values)] = NaN
-        for i in range(N):
-            resultMatrix[:, i] = func(arg.values[:, i], window, minp=minp)
-        output = DataMatrix(resultMatrix, index=arg.index,
-                            columns=arg.columns)
-
-    elif isinstance(arg, DataFrame):
-        output = DataFrame(index = arg.index)
-        for col, series in arg.iteritems():
-            series[np.isinf(series)] = NaN
-            output[col] = Series(func(series, window, minp=minp),
-                                 index=series.index)
+    calc = lambda x: func(x, window, minp=minp)
+
+    return_hook, values = _process_data_structure(arg)
+
+    # actually calculate the moment. Faster way to do this?
+    result = np.apply_along_axis(calc, axis, values)
+
+    return return_hook(result)
+
+def _process_data_structure(arg, kill_inf=True):
+    if isinstance(arg, DataFrame):
+        if isinstance(arg, DataMatrix):
+            return_hook = lambda v: DataMatrix(v, index=arg.index,
+                                               columns=arg.columns,
+                                               objects=arg.objects)
+        else:
+            return_hook = lambda v: DataFrame(v, index=arg.index,
+                                              columns=arg.columns)
+        values = arg.values
     elif isinstance(arg, Series):
-        arg[np.isinf(arg)] = NaN
-        output = Series(func(arg, window, minp=minp), index=arg.index)
+        values = arg.values
+        return_hook = lambda v: Series(v, arg.index)
     else:
-        try:
-            assert(hasattr(arg, '__iter__'))
-        except AssertionError:
-            raise AssertionError('Expected DataFrame or array-like argument')
-        arg[np.isinf(arg)] = NaN
-        output = func(arg, window, minp=minp)
-    return output
-
-#-------------------------------------------------------------------------------
-# Exponential moving moments
+        return_hook = lambda v: v
+        values = arg
 
-def _getMinPeriods(minPct, rho):
-    if not (0 <= minPct <= 1):
-        raise Exception('minPct must be between 0 and 1!')
+    if kill_inf:
+        values = values.copy()
+        values[np.isinf(values)] = np.NaN
 
-    if minPct == 0:
-        return 0
+    return return_hook, values
 
-    return int(np.ceil(np.log(minPct) / np.log(rho)))
+#-------------------------------------------------------------------------------
+# Exponential moving moments
 
-def _ewmoment(values, func, min_periods=None, biasCorrection=None):
+def _ewmoment(values, func, min_periods=None, bias_adj=None):
     """
     Generic rolling exponential moment function using blended accumulator
     method.
@@ -236,7 +164,7 @@ def _ewmoment(values, func, min_periods=None, biasCorrection=None):
     func : function
         taking previous value and next value
 
-    biasCorrection : float
+    bias_adj : float
         Optional bias correction
 
     min_periods : int, optional
@@ -263,135 +191,106 @@ def _ewmoment(values, func, min_periods=None, biasCorrection=None):
     output = values.copy()
     output[okLocs] = result
 
-    if biasCorrection is not None:
-        if biasCorrection <= 0:
+    if bias_adj is not None:
+        if bias_adj <= 0:
             raise Exception('Bias correction cannot be negative!')
 
-        output *= biasCorrection
+        output *= bias_adj
 
     return output
 
-def ewma(arg, com=None, span=None, minCom=0):
-    """
-    Calculates the rolling exponentially weighted moving average of a series.
+def _get_center_of_mass(com, span):
+    if span is not None:
+        if com is not None:
+            raise Exception("com and span are mutually exclusive")
 
-    Parameters
-    ----------
-    arg : Series, DataFrame, or DataMatrix
-    com : float. optional
-        Center of mass: \alpha = com / (1 + com),
-    span : float, optional
-        Specify decay in terms of span, \alpha = 2 / (span + 1)
-    minCom : int, default 0
-        Optionally require that at least a certain number of periods as
-        a multiple of the Center of Mass be included in the sample.
-
-    Returns
-    -------
-    y : type of input argument
-
-    Note
-    ----
-    Either center of mass or span must be specified
-
-    EWMA is sometimes specified using a "span" parameter s, we have
-    have that the decay parameter \alpha is related to the span in the
-    following way:
-
-    \alpha = 1 - 2 / (span + 1) = c / (1 + c)
-
-    where c is the center of mass. Given a span, the
-    associated center of mass is:
+        # convert span to center of mass
+        com = (span - 1) / 2.
 
-    c = (s - 1) / 2
-
-    So a "20-day EWMA" would have center 9.5
-    """
-    if com is None and span is None:
+    elif com is None:
         raise Exception("Must pass either com or span")
-    elif com is not None and span is not None:
-        raise Exception("com and span are mutually exclusive")
 
-    def ewmaFunc(series):
-        series[np.isinf(series)] = NaN
-        result = _ewma(series, com)
+    return float(com)
 
-        firstIndex = _first_valid_index(series)
 
-        result[firstIndex : firstIndex + minCom*com] = NaN
-        result = Series(result, index=arg.index)
-        return result
+_ewm_doc = r"""%s
 
-    if isinstance(arg, Series):
-        output = ewmaFunc(arg)
-    elif isinstance(arg, DataFrame):
-        output = arg.apply(ewmaFunc)
-    else:
-        output = _ewma(arg, com)
-        firstIndex = _first_valid_index(arg)
-        output[firstIndex : firstIndex + minCom * com] = NaN
+Parameters
+----------
+arg : Series, DataFrame, or DataMatrix
+com : float. optional
+    Center of mass: \alpha = com / (1 + com),
+span : float, optional
+    Specify decay in terms of span, \alpha = 2 / (span + 1)
+min_periods : int, default 0
+    Number of observations in sample to require (only affects
+    beginning)
+%s
+Returns
+-------
+y : type of input argument
 
-    return output
+Note
+----
+Either center of mass or span must be specified
 
-def _first_valid_index(arr):
-    # argmax scans from left
-    return notnull(arr).argmax()
+EWMA is sometimes specified using a "span" parameter s, we have
+have that the decay parameter \alpha is related to the span in the
+following way:
 
-def ewmvar(arg, com, minCom = 0, correctBias = True):
-    """
-    Calculates the rolling exponentially weighted moving variance of a series.
+\alpha = 1 - 2 / (span + 1) = c / (1 + c)
 
-    Parameters
-    ----------
-    series : Series
-    com : integer
-        Center of Mass for exponentially weighted moving average
-        decay = com / (1 + com) maps center of mass to decay parameter
+where c is the center of mass. Given a span, the
+associated center of mass is:
 
-    minCom : int, default None
-        Optionally require that at least a certain number of periods as
-        a multiple of the Center of Mass be included in the sample.
+c = (s - 1) / 2
 
-    correctBias : boolean
-        Use a standard bias correction
-    """
+So a "20-day EWMA" would have center 9.5
+"""
 
-    if correctBias:
-        biasCorrection = (1.0 + 2.0 * com) / (2.0 * com)
-    else:
-        biasCorrection = 1.0
+_bias_doc = r"""bias : boolean, default False
+    Use a standard estimation bias correction
+"""
 
-    moment2nd = ewma(arg * arg, com=com, minCom=minCom)
-    moment1st = ewma(arg, com=com, minCom=minCom)
+def ewma(arg, com=None, span=None, min_periods=0):
+    com = _get_center_of_mass(com, span)
+    if min_periods is None:
+        min_periods = 0
 
-    return biasCorrection * (moment2nd - moment1st**2)
+    def ewmaFunc(v):
+        result = _ewma(v, com)
+        first_index = _first_valid_index(v)
+        result[first_index : first_index + min_periods] = NaN
+        return result
 
-def ewmvol(arg, com, minCom=0, correctBias = True):
-    """
-    Calculates the rolling exponentially weighted moving variance of a series.
+    return_hook, values = _process_data_structure(arg)
+    output = np.apply_along_axis(ewmaFunc, 0, values)
+    return return_hook(output)
+ewma.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving average", "")
 
-    Parameters
-    ----------
-    series : Series
-    com : integer
-        Center of Mass for exponentially weighted moving average
-        decay = com / (1 + com) maps center of mass to decay parameter
+def _first_valid_index(arr):
+    # argmax scans from left
+    return notnull(arr).argmax()
 
-    minCom : int, default None
-        Optionally require that at least a certain number of periods as
-        a multiple of the Center of Mass be included in the sample.
+def ewmvar(arg, com=None, span=None, min_periods=0, bias=False):
+    com = _get_center_of_mass(com, span)
 
-    correctBias : boolean
-        Use a standard bias correction
-    """
-    result = ewmvar(arg, com=com, minCom=minCom, correctBias=correctBias)
+    moment2nd = ewma(arg * arg, com=com, min_periods=min_periods)
+    moment1st = ewma(arg, com=com, min_periods=min_periods)
 
-    if isinstance(result, DataFrame):
-        result = result.apply(np.sqrt)
-    else:
-        result = np.sqrt(result)
+    result = moment2nd - moment1st ** 2
+    if not bias:
+        result *= (1.0 + 2.0 * com) / (2.0 * com)
 
     return result
+ewmvar.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving variance",
+                             _bias_doc)
+
+def ewmvol(arg, com=None, span=None, min_periods=0, bias=False):
+    result = ewmvar(arg, com=com, min_periods=min_periods, bias=bias)
+    return np.sqrt(result)
+ewmvol.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving std",
+                             _bias_doc)
 
 def ewmcov(seriesA, seriesB, com, minCom=0, correctBias=True):
     """
@@ -414,9 +313,9 @@ def ewmcov(seriesA, seriesB, com, minCom=0, correctBias=True):
     """
 
     if correctBias:
-        biasCorrection = ( 1.0 + 2.0 * com ) / (2.0 * com)
+        bias_adj = ( 1.0 + 2.0 * com ) / (2.0 * com)
     else:
-        biasCorrection = 1.0
+        bias_adj = 1.0
 
     if not isinstance(seriesB, type(seriesA)):
         raise Exception('Input arrays must be of the same type!')
@@ -436,7 +335,7 @@ def ewmcov(seriesA, seriesB, com, minCom=0, correctBias=True):
     X  = ewma(cleanSeriesA, com=com, minCom=minCom)
     Y  = ewma(cleanSeriesB, com=com, minCom=minCom)
 
-    return biasCorrection * (XY - X * Y)
+    return bias_adj * (XY - X * Y)
 
 
 def ewmcorr(seriesA, seriesB, com, minCom=0):
@@ -478,3 +377,89 @@ def ewmcorr(seriesA, seriesB, com, minCom=0):
 
     return (XY - X * Y) / np.sqrt(varX * varY)
 
+
+#-------------------------------------------------------------------------------
+# Python interface to Cython functions
+
+def _check_arg(arg):
+    if not issubclass(arg.dtype.type, float):
+        arg = arg.astype(float)
+
+    return arg
+
+def _two_periods(minp, window):
+    if minp is None:
+        return window
+    else:
+        return max(2, minp)
+
+def _use_window(minp, window):
+    if minp is None:
+        return window
+    else:
+        return minp
+
+def _wrap_cython(f, check_minp=_use_window):
+    def wrapper(arg, window, minp=None):
+        minp = check_minp(minp, window)
+        arg = _check_arg(arg)
+        return f(arg, window, minp)
+
+    return wrapper
+
+_rolling_sum = _wrap_cython(tseries.roll_sum)
+_rolling_max = _wrap_cython(tseries.roll_max)
+_rolling_min = _wrap_cython(tseries.roll_min)
+_rolling_mean = _wrap_cython(tseries.roll_mean)
+_rolling_median = _wrap_cython(tseries.roll_median)
+_rolling_var = _wrap_cython(tseries.roll_var, check_minp=_two_periods)
+_rolling_skew = _wrap_cython(tseries.roll_skew, check_minp=_two_periods)
+_rolling_kurt = _wrap_cython(tseries.roll_kurt, check_minp=_two_periods)
+_rolling_std = lambda *a, **kw: np.sqrt(_rolling_var(*a, **kw))
+
+def _ewma(arg, com):
+    arg = _check_arg(arg)
+    return tseries.ewma(arg, com)
+
+#-------------------------------------------------------------------------------
+# Rolling statistics
+
+_doc_template = """
+%s
+
+Parameters
+----------
+arg : 1D ndarray, Series, or DataFrame/DataMatrix
+window : Number of observations used for calculating statistic
+min_periods : int
+    Minimum number of observations in window required to have a value
+time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default=None
+    Name of time rule to conform to before computing statistic
+
+Returns
+-------
+y : type of input argument
+"""
+
+def _rolling_func(func, desc):
+    @wraps(func)
+    def f(arg, window, min_periods=None, time_rule=None):
+        return _rolling_moment(arg, window, func, min_periods,
+                              time_rule=time_rule)
+
+    f.__doc__ = _doc_template % desc
+
+    return f
+
+rolling_max = _rolling_func(_rolling_max, 'Moving maximum')
+rolling_min = _rolling_func(_rolling_min, 'Moving minimum')
+rolling_sum = _rolling_func(_rolling_sum, 'Moving sum')
+rolling_mean = _rolling_func(_rolling_mean, 'Moving mean')
+rolling_median = _rolling_func(_rolling_median, 'Moving median')
+
+rolling_std = _rolling_func(_rolling_std,
+                            'Unbiased moving standard deviation')
+
+rolling_var = _rolling_func(_rolling_var, 'Unbiased moving variance')
+rolling_skew = _rolling_func(_rolling_skew, 'Unbiased moving skewness')
+rolling_kurt = _rolling_func(_rolling_kurt, 'Unbiased moving kurtosis')
diff --git a/pandas/stats/tests/test_moments.py b/pandas/stats/tests/test_moments.py
index ec83fca6b..8175d66cb 100644
--- a/pandas/stats/tests/test_moments.py
+++ b/pandas/stats/tests/test_moments.py
@@ -1,18 +1,217 @@
+import unittest
+
+from datetime import datetime
+from numpy.random import randn
 import numpy as np
+
+from pandas.core.api import Series, DataFrame, DataMatrix, DateRange
+from pandas.util.testing import assert_almost_equal
+import pandas.core.datetools as datetools
 import pandas.stats.moments as moments
 
-def test_rolling_median():
-    arr = np.random.randn(100)
-    arr[20:40] = np.NaN
+N, K = 100, 10
+
+class TestMoments(unittest.TestCase):
+
+    _nan_locs = np.arange(20, 40)
+    _inf_locs = np.array([])
+
+    def setUp(self):
+        arr = randn(N)
+        arr[self._nan_locs] = np.NaN
+
+        self.arr = arr
+        self.rng = DateRange(datetime(2009, 1, 1), periods=N)
+
+        self.series = Series(arr.copy(), index=self.rng)
+
+        self.frame = DataFrame(randn(N, K), index=self.rng,
+                               columns=np.arange(K))
+
+        self.matrix = DataMatrix(randn(N, K), index=self.rng,
+                                 columns=np.arange(K))
+
+    def test_rolling_sum(self):
+        self._check_moment_func(moments.rolling_sum, np.sum)
+
+    def test_rolling_count(self):
+        counter = lambda x: np.isfinite(x).astype(float).sum()
+        self._check_moment_func(moments.rolling_count, counter,
+                                has_min_periods=False,
+                                preserve_nan=False)
+
+    def test_rolling_mean(self):
+        self._check_moment_func(moments.rolling_mean, np.mean)
+
+    def test_rolling_median(self):
+        self._check_moment_func(moments.rolling_median, np.median)
+
+    def test_rolling_min(self):
+        self._check_moment_func(moments.rolling_min, np.min)
+
+    def test_rolling_max(self):
+        self._check_moment_func(moments.rolling_max, np.max)
+
+    def test_rolling_std(self):
+        self._check_moment_func(moments.rolling_std,
+                                lambda x: np.std(x, ddof=1))
+
+    def test_rolling_var(self):
+        self._check_moment_func(moments.rolling_var,
+                                lambda x: np.var(x, ddof=1))
+
+    def test_rolling_skew(self):
+        from scipy.stats import skew
+        self._check_moment_func(moments.rolling_skew,
+                                lambda x: skew(x, bias=False))
+
+    def test_rolling_kurt(self):
+        from scipy.stats import kurtosis
+        self._check_moment_func(moments.rolling_kurt,
+                                lambda x: kurtosis(x, bias=False))
+
+    def _check_moment_func(self, func, static_comp, window=50,
+                           has_min_periods=True,
+                           has_time_rule=True,
+                           preserve_nan=True):
+
+        self._check_ndarray(func, static_comp, window=window,
+                            has_min_periods=has_min_periods,
+                            preserve_nan=preserve_nan)
+
+        self._check_structures(func, static_comp,
+                               has_min_periods=has_min_periods,
+                               has_time_rule=has_time_rule)
+
+    def _check_ndarray(self, func, static_comp, window=50,
+                       has_min_periods=True,
+                       preserve_nan=True):
+
+        result = func(self.arr, window)
+        assert_almost_equal(result[-1],
+                            static_comp(self.arr[-50:]))
+
+        if preserve_nan:
+            assert(np.isnan(result[self._nan_locs]).all())
+
+        # excluding NaNs correctly
+        arr = randn(50)
+        arr[:10] = np.NaN
+        arr[-10:] = np.NaN
+
+        if has_min_periods:
+            result = func(arr, 50, min_periods=30)
+            assert_almost_equal(result[-1], static_comp(arr[10:-10]))
+
+            # min_periods is working correctly
+            result = func(arr, 20, min_periods=15)
+            self.assert_(np.isnan(result[23]))
+            self.assert_(not np.isnan(result[24]))
+
+            self.assert_(not np.isnan(result[-6]))
+            self.assert_(np.isnan(result[-5]))
+        else:
+            result = func(arr, 50)
+            assert_almost_equal(result[-1], static_comp(arr[10:-10]))
+
+    def _check_structures(self, func, static_comp,
+                          has_min_periods=True, has_time_rule=True):
+
+        series_result = func(self.series, 50)
+        self.assert_(isinstance(series_result, Series))
+
+        frame_result = func(self.frame, 50)
+        self.assertEquals(type(frame_result), DataFrame)
+
+        matrix_result = func(self.matrix, 50)
+        self.assertEquals(type(matrix_result), DataMatrix)
+
+        # check time_rule works
+        if has_time_rule:
+            win = 25
+            minp = 10
+
+            if has_min_periods:
+                series_result = func(self.series[::2], win, min_periods=minp,
+                                     time_rule='WEEKDAY')
+                frame_result = func(self.frame[::2], win, min_periods=minp,
+                                    time_rule='WEEKDAY')
+                matrix_result = func(self.matrix[::2], win, min_periods=minp,
+                                     time_rule='WEEKDAY')
+            else:
+                series_result = func(self.series[::2], win, time_rule='WEEKDAY')
+                frame_result = func(self.frame[::2], win, time_rule='WEEKDAY')
+                matrix_result = func(self.matrix[::2], win, time_rule='WEEKDAY')
+
+            last_date = series_result.index[-1]
+            prev_date = last_date - 24 * datetools.bday
+
+            trunc_series = self.series[::2].truncate(prev_date, last_date)
+            trunc_frame = self.frame[::2].truncate(prev_date, last_date)
+            trunc_matrix = self.matrix[::2].truncate(prev_date, last_date)
+
+            assert_almost_equal(series_result[-1], static_comp(trunc_series))
+
+            assert_almost_equal(frame_result.xs(last_date),
+                                trunc_frame.apply(static_comp))
+
+            assert_almost_equal(matrix_result.xs(last_date),
+                                trunc_matrix.apply(static_comp))
+
+    # binary moments
+    def test_rolling_cov(self):
+        A = self.series
+        B = A + randn(len(A))
+
+        result = moments.rolling_cov(A, B, 50, min_periods=25)
+        assert_almost_equal(result[-1], np.cov(A[-50:], B[-50:])[0, 1])
+
+    def test_rolling_corr(self):
+        A = self.series
+        B = A + randn(len(A))
+
+        result = moments.rolling_corr(A, B, 50, min_periods=25)
+        assert_almost_equal(result[-1], np.corrcoef(A[-50:], B[-50:])[0, 1])
+
+    def test_ewma(self):
+        self._check_ew(moments.ewma)
+
+    def test_ewmcorr(self):
+        pass
+
+    def test_ewmvar(self):
+        self._check_ew(moments.ewmvar)
+
+    def test_ewmvar(self):
+        self._check_ew(moments.ewmvol)
+
+    def test_ewma_span_com(self):
+        A = moments.ewma(self.arr, com=9.5)
+        B = moments.ewma(self.arr, span=20)
+        assert_almost_equal(A, B)
 
-    result = moments.rolling_median(arr, 50)
+    def _check_ew(self, func):
+        self._check_ew_ndarray(func)
+        self._check_ew_structures(func)
 
-    assert(np.isnan(result[20]))
+    def _check_ew_ndarray(self, func, preserve_nan=False):
+        result = func(self.arr, com=10)
+        if preserve_nan:
+            assert(np.isnan(result[self._nan_locs]).all())
 
-    assert(result[-1] == np.median(arr[-50:]))
+        # excluding NaNs correctly
+        arr = randn(50)
+        arr[:10] = np.NaN
+        arr[-10:] = np.NaN
 
-    result = moments.rolling_median(arr, 49)
+    def _check_ew_structures(self, func):
+        series_result = func(self.series, com=10)
+        self.assert_(isinstance(series_result, Series))
+        frame_result = func(self.frame, com=10)
+        self.assertEquals(type(frame_result), DataFrame)
+        matrix_result = func(self.matrix, com=10)
+        self.assertEquals(type(matrix_result), DataMatrix)
 
-    assert(np.isnan(result[20]))
+if __name__ == '__main__':
+    unittest.main()
 
-    assert(result[-1] == np.median(arr[-49:]))

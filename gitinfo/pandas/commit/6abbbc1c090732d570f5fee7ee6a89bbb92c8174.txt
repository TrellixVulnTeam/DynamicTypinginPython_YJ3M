commit 6abbbc1c090732d570f5fee7ee6a89bbb92c8174
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Dec 1 21:13:01 2012 -0500

    BUG: assigning multiple columns in a hierarchically indexed DataFrame. close #1803

diff --git a/LICENSES/NUMPY_LICENSE b/LICENSES/NUMPY_LICENSE
new file mode 100644
index 000000000..e69de29bb
diff --git a/LICENSES/PSF_LICENSE b/LICENSES/PSF_LICENSE
new file mode 100644
index 000000000..e69de29bb
diff --git a/LICENSES/SCIPY_LICENSE b/LICENSES/SCIPY_LICENSE
new file mode 100644
index 000000000..e69de29bb
diff --git a/RELEASE.rst b/RELEASE.rst
index d51d1c341..a0dacb690 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -108,6 +108,9 @@ pandas 0.10.0
   - Use `col_space` argument as minimum column width in DataFrame.to_html (#2328)
   - Fix tz-aware DatetimeIndex.to_period (#2232)
   - Fix DataFrame row indexing case with MultiIndex (#2314)
+  - Fix to_excel exporting issues with Timestamp objects in index (#2294)
+  - Fixes assigning scalars and array to hierarchical column chunk (#1803)
+
 
 pandas 0.9.1
 ============
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index e0e859302..4d8a4b0bf 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2092,14 +2092,30 @@ class DataFrame(NDFrame):
                     value = value.copy().T
                 else:
                     value = value.copy()
+
+            # Broadcasting funtimes
+            if key in self.columns and value.ndim == 1:
+                existing_piece = self[key]
+                if isinstance(existing_piece, DataFrame):
+                    value = np.tile(value, (len(existing_piece.columns), 1))
         else:
-            value = np.repeat(value, len(self.index))
             if key in self.columns:
-                existing_column = self[key]
-                # special case for now
-                if (com.is_float_dtype(existing_column) and
-                    com.is_integer_dtype(value)):
-                    value = value.astype(np.float64)
+                existing_piece = self[key]
+
+                # transpose hack
+                if isinstance(existing_piece, DataFrame):
+                    shape = (len(existing_piece.columns), len(self.index))
+                    value = np.repeat(value, np.prod(shape)).reshape(shape)
+                else:
+                    value = np.repeat(value, len(self.index))
+
+                    # special case for now
+                    if (com.is_float_dtype(existing_piece) and
+                        com.is_integer_dtype(value)):
+                        value = value.astype(np.float64)
+
+            else:
+                value = np.repeat(value, len(self.index))
 
         return np.atleast_2d(np.asarray(value))
 
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 4a2717c2e..10ff3cf2d 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -291,6 +291,21 @@ class TestMultiLevel(unittest.TestCase):
         cp['a'] = cp['b'].values
         assert_frame_equal(cp['a'], cp['b'])
 
+        #----------------------------------------
+        # #1803
+        columns = MultiIndex.from_tuples([('A', '1'), ('A', '2'), ('B', '1')])
+        df = DataFrame(index=[1, 3, 5], columns=columns)
+
+        # Works, but adds a column instead of updating the two existing ones
+        df['A'] = 0.0 # Doesn't work
+        self.assertTrue((df['A'].values == 0).all())
+
+        # it broadcasts
+        df['B', '1'] = [1, 2, 3]
+        df['A'] = df['B', '1']
+        assert_almost_equal(df['A', '1'], df['B', '1'])
+        assert_almost_equal(df['A', '2'], df['B', '1'])
+
     def test_getitem_tuple_plus_slice(self):
         # GH #671
         df = DataFrame({'a' : range(10),

commit daf2f4cdcd5389787f92e49d84be39561cfbab6c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 22:36:24 2011 -0400

    REF: moved stack/unstack/pivot code into new reshape module

diff --git a/pandas/core/api.py b/pandas/core/api.py
index ffe6298b6..e0fa3ba10 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -10,7 +10,8 @@ from pandas.core.index import Index, Factor, MultiIndex
 from pandas.core.daterange import DateRange
 from pandas.core.series import Series, TimeSeries
 from pandas.core.frame import DataFrame
-from pandas.core.panel import WidePanel, LongPanel, pivot
+from pandas.core.panel import WidePanel, LongPanel
 from pandas.core.groupby import groupby
+from pandas.core.reshape import pivot_simple as pivot
 
 DataMatrix = DataFrame
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0ce9c21f6..20770deda 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1648,26 +1648,8 @@ class DataFrame(NDFrame):
         pivoted : DataFrame (value column specified) or WidePanel (no value
         column specified)
         """
-        index_vals = self[index]
-        column_vals = self[columns]
-        mindex = MultiIndex.from_arrays([index_vals, column_vals])
-
-        if values is None:
-            items = self.columns - [index, columns]
-            mat = self.reindex(columns=items).values
-        else:
-            items = [values]
-            mat = np.atleast_2d(self[values].values).T
-
-        stacked = DataFrame(mat, index=mindex, columns=items)
-
-        if not mindex.is_lexsorted():
-            stacked = stacked.sortlevel(level=0)
-
-        unstacked = stacked.unstack()
-        if values is not None:
-            unstacked.columns = unstacked.columns.droplevel(0)
-        return unstacked
+        from pandas.core.reshape import pivot
+        return pivot(self, index=index, columns=columns, values=values)
 
     def stack(self, level=-1, dropna=True):
         """
@@ -1678,110 +1660,8 @@ class DataFrame(NDFrame):
         -------
         stacked : Series
         """
-        N, K = self.shape
-        if isinstance(self.columns, MultiIndex):
-            return self._stack_multi_columns(level=level, dropna=True)
-        elif isinstance(self.index, MultiIndex):
-
-            new_levels = list(self.index.levels)
-            new_levels.append(self.columns)
-
-            new_labels = [lab.repeat(K) for lab in self.index.labels]
-            new_labels.append(np.tile(np.arange(K), N).ravel())
-
-            new_names = list(self.index.names)
-            new_names.append('columns')
-            new_index = MultiIndex(levels=new_levels, labels=new_labels,
-                                   names=new_names)
-        else:
-            ilabels = np.arange(N).repeat(K)
-            clabels = np.tile(np.arange(K), N).ravel()
-            new_index = MultiIndex(levels=[self.index, self.columns],
-                                   labels=[ilabels, clabels])
-
-        new_values = self.values.ravel()
-        if dropna:
-            mask = notnull(new_values)
-            new_values = new_values[mask]
-            new_index = new_index[mask]
-        return Series(new_values, index=new_index)
-
-    def _stack_multi_columns(self, level=-1, dropna=True):
-        import itertools
-        this = self.copy()
-        if level < 0:
-            level += self.columns.nlevels
-
-        # this makes life much simpler
-        if level != self.columns.nlevels - 1:
-            last = self.columns.nlevels - 1
-
-            # roll levels to put selected level at end
-            roll_columns = this.columns
-            for i in range(level, self.columns.nlevels - 1):
-                roll_columns = roll_columns.swaplevel(i, i + 1)
-            this.columns = roll_columns
-
-        if not this.columns.is_lexsorted():
-            this = this.sortlevel(0, axis=1)
-
-        # tuple list excluding level for grouping columns
-        if len(self.columns.levels) > 2:
-            tuples = zip(*[lev.values.take(lab)
-                           for lev, lab in zip(this.columns.levels[:-1],
-                                               this.columns.labels[:-1])])
-            unique_groups = [key for key, _ in itertools.groupby(tuples)]
-            new_names = this.columns.names[:-1]
-            new_columns = MultiIndex.from_tuples(unique_groups, names=new_names)
-        else:
-            new_columns = unique_groups = this.columns.levels[0]
-
-        # time to ravel the values
-        new_data = {}
-        level_vals = this.columns.levels[-1]
-        levsize = len(level_vals)
-        for key in unique_groups:
-            loc = this.columns.get_loc(key)
-
-            # can make more efficient?
-            if loc.stop - loc.start != levsize:
-                chunk = this.ix[:, this.columns[loc]]
-                chunk.columns = level_vals.take(chunk.columns.labels[-1])
-                value_slice = chunk.reindex(columns=level_vals).values
-            else:
-                if self._is_mixed_type:
-                    value_slice = this.ix[:, this.columns[loc]].values
-                else:
-                    value_slice = this.values[:, loc]
-
-            new_data[key] = value_slice.ravel()
-
-        N = len(this)
-
-        if isinstance(this.index, MultiIndex):
-            new_levels = list(this.index.levels)
-            new_names = list(this.index.names)
-            new_labels = [lab.repeat(levsize) for lab in this.index.labels]
-        else:
-            new_levels = [this.index]
-            new_labels = [np.arange(N).repeat(levsize)]
-            new_names = ['index'] # something better?
-
-        new_levels.append(self.columns.levels[level])
-        new_labels.append(np.tile(np.arange(levsize), N))
-        new_names.append(self.columns.names[level])
-
-        new_index = MultiIndex(levels=new_levels, labels=new_labels,
-                               names=new_names)
-
-        result = DataFrame(new_data, index=new_index, columns=new_columns)
-
-        # more efficient way to go about this? can do the whole masking biz but
-        # will only save a small amount of time...
-        if dropna:
-            result = result.dropna(axis=0, how='all')
-
-        return result
+        from pandas.core.reshape import stack
+        return stack(self, level=level, dropna=dropna)
 
     def unstack(self, level=-1):
         """
@@ -1814,7 +1694,7 @@ class DataFrame(NDFrame):
         -------
         unstacked : DataFrame
         """
-        from pandas.core.series import _Unstacker
+        from pandas.core.reshape import _Unstacker
         unstacker = _Unstacker(self.values, self.index, level=level,
                                value_columns=self.columns)
         return unstacker.get_result()
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 0d7de5ad1..df12ce8a7 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1459,38 +1459,6 @@ def _get_distinct_indexes(indexes):
     indexes = sorted(indexes, key=id)
     return [gp.next() for _, gp in groupby(indexes, id)]
 
-def pivot(index, columns, values):
-    """
-    Produce 'pivot' table based on 3 columns of this DataFrame.
-    Uses unique values from index / columns and fills with values.
-
-    Parameters
-    ----------
-    index : ndarray
-        Labels to use to make new frame's index
-    columns : ndarray
-        Labels to use to make new frame's columns
-    values : ndarray
-        Values to use for populating new frame's values
-
-    Note
-    ----
-    Obviously, all 3 of the input arguments must have the same length
-
-    Returns
-    -------
-    DataFrame
-    """
-    assert(len(index) == len(columns) == len(values))
-
-    if len(index) == 0:
-        return DataFrame(index=[])
-
-    hindex = MultiIndex.from_arrays([index, columns])
-    series = Series(values.ravel(), index=hindex)
-    series = series.sortlevel(0)
-    return series.unstack()
-
 def make_mask(index):
     """
     Create observation selection vector using major and minor
@@ -1502,31 +1470,5 @@ def make_mask(index):
     mask.put(selector, True)
     return mask
 
-def _slow_pivot(index, columns, values):
-    """
-    Produce 'pivot' table based on 3 columns of this DataFrame.
-    Uses unique values from index / columns and fills with values.
-
-    Parameters
-    ----------
-    index : string or object
-        Column name to use to make new frame's index
-    columns : string or object
-        Column name to use to make new frame's columns
-    values : string or object
-        Column name to use for populating new frame's values
-
-    Could benefit from some Cython here.
-    """
-    from itertools import izip
-    tree = {}
-    for i, (idx, col) in enumerate(izip(index, columns)):
-        if col not in tree:
-            tree[col] = {}
-        branch = tree[col]
-        branch[idx] = values[i]
-
-    return DataFrame(tree)
-
 def _monotonic(arr):
     return not (arr[1:] < arr[:-1]).any()
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
new file mode 100644
index 000000000..3c1d79738
--- /dev/null
+++ b/pandas/core/reshape.py
@@ -0,0 +1,372 @@
+# pylint: disable=E1101,E1103
+# pylint: disable=W0703,W0622,W0613,W0201
+
+import itertools
+
+import numpy as np
+
+from pandas.core.frame import DataFrame
+from pandas.core.series import Series
+
+from pandas.core.common import notnull
+from pandas.core.index import MultiIndex
+
+class _Unstacker(object):
+    """
+    Helper class to unstack data / pivot with multi-level index
+
+    Parameters
+    ----------
+    level : int, default last level
+        Level to "unstack"
+
+    Examples
+    --------
+    >>> s
+    one  a   1.
+    one  b   2.
+    two  a   3.
+    two  b   4.
+
+    >>> s.unstack(level=-1)
+         a   b
+    one  1.  2.
+    two  3.  4.
+
+    >>> s.unstack(level=0)
+       one  two
+    a  1.   2.
+    b  3.   4.
+
+    Returns
+    -------
+    unstacked : DataFrame
+    """
+    def __init__(self, values, index, level=-1, value_columns=None):
+        if values.ndim == 1:
+            values = values[:, np.newaxis]
+        self.values = values
+        self.value_columns = value_columns
+
+        if value_columns is None and values.shape[1] != 1:  # pragma: no cover
+            raise ValueError('must pass column labels for multi-column data')
+
+        self.index = index
+
+        if level < 0:
+            level += index.nlevels
+        self.level = level
+
+        self.new_index_levels = list(index.levels)
+        self.removed_level = self.new_index_levels.pop(level)
+
+        v = self.level
+        lshape = self.index.levshape
+        self.full_shape = np.prod(lshape[:v] + lshape[v+1:]), lshape[v]
+
+        self._make_sorted_values_labels()
+        self._make_selectors()
+
+    def _make_sorted_values_labels(self):
+        v = self.level
+
+        labs = self.index.labels
+        to_sort = labs[:v] + labs[v+1:] + [labs[v]]
+        indexer = np.lexsort(to_sort[::-1])
+
+        self.sorted_values = self.values.take(indexer, axis=0)
+        self.sorted_labels = [l.take(indexer) for l in to_sort]
+
+    def _make_selectors(self):
+        new_levels = self.new_index_levels
+
+        # make the mask
+        group_index = self.sorted_labels[0]
+        prev_stride = np.prod([len(x) for x in new_levels[1:]])
+
+        for lev, lab in zip(new_levels[1:], self.sorted_labels[1:-1]):
+            group_index = group_index * prev_stride + lab
+            prev_stride /= len(lev)
+
+        group_mask = np.zeros(self.full_shape[0], dtype=bool)
+        group_mask.put(group_index, True)
+
+        stride = self.index.levshape[self.level]
+        selector = self.sorted_labels[-1] + stride * group_index
+        mask = np.zeros(np.prod(self.full_shape), dtype=bool)
+        mask.put(selector, True)
+
+        # compress labels
+        unique_groups = np.arange(self.full_shape[0])[group_mask]
+        compressor = group_index.searchsorted(unique_groups)
+
+        self.group_mask = group_mask
+        self.group_index = group_index
+        self.mask = mask
+        self.unique_groups = unique_groups
+        self.compressor = compressor
+
+    def get_result(self):
+        # TODO: find a better way than this masking business
+
+        values, mask = self.get_new_values()
+        columns = self.get_new_columns()
+        index = self.get_new_index()
+
+        # filter out missing levels
+        values = values[:, mask]
+        columns = columns[mask]
+
+        return DataFrame(values, index=index, columns=columns)
+
+    def get_new_values(self):
+        # place the values
+        length, width = self.full_shape
+        stride = self.values.shape[1]
+        result_width = width * stride
+
+        new_values = np.empty((length, result_width), dtype=self.values.dtype)
+        new_mask = np.zeros((length, result_width), dtype=bool)
+
+        if not issubclass(self.values.dtype.type, np.integer):
+            new_values.fill(np.nan)
+
+        # is there a simpler / faster way of doing this?
+        for i in xrange(self.values.shape[1]):
+            chunk = new_values[:, i * width : (i + 1) * width]
+            mask_chunk = new_mask[:, i * width : (i + 1) * width]
+
+            chunk.flat[self.mask] = self.sorted_values[:, i]
+            mask_chunk.flat[self.mask] = True
+
+        new_values = new_values.take(self.unique_groups, axis=0)
+        return new_values, new_mask.sum(0) > 0
+
+    def get_new_columns(self):
+        if self.value_columns is None:
+            return self.removed_level
+
+        stride = len(self.removed_level)
+        width = len(self.value_columns)
+        propagator = np.repeat(np.arange(width), stride)
+        if isinstance(self.value_columns, MultiIndex):
+            new_levels = self.value_columns.levels + [self.removed_level]
+            new_labels = [lab.take(propagator)
+                          for lab in self.value_columns.labels]
+            new_labels.append(np.tile(np.arange(stride), width))
+        else:
+            new_levels = [self.value_columns, self.removed_level]
+            new_labels = []
+
+            new_labels.append(propagator)
+            new_labels.append(np.tile(np.arange(stride), width))
+
+        return MultiIndex(levels=new_levels, labels=new_labels)
+
+    def get_new_index(self):
+        result_labels = []
+        for cur in self.sorted_labels[:-1]:
+            result_labels.append(cur.take(self.compressor))
+
+        # construct the new index
+        if len(self.new_index_levels) == 1:
+            new_index = self.new_index_levels[0].take(self.unique_groups)
+        else:
+            new_index = MultiIndex(levels=self.new_index_levels,
+                                   labels=result_labels)
+
+        return new_index
+
+def pivot(self, index=None, columns=None, values=None):
+    """
+    See DataFrame.pivot
+    """
+    index_vals = self[index]
+    column_vals = self[columns]
+    mindex = MultiIndex.from_arrays([index_vals, column_vals])
+
+    if values is None:
+        items = self.columns - [index, columns]
+        mat = self.reindex(columns=items).values
+    else:
+        items = [values]
+        mat = np.atleast_2d(self[values].values).T
+
+    stacked = DataFrame(mat, index=mindex, columns=items)
+
+    if not mindex.is_lexsorted():
+        stacked = stacked.sortlevel(level=0)
+
+    unstacked = stacked.unstack()
+    if values is not None:
+        unstacked.columns = unstacked.columns.droplevel(0)
+    return unstacked
+
+def pivot_simple(index, columns, values):
+    """
+    Produce 'pivot' table based on 3 columns of this DataFrame.
+    Uses unique values from index / columns and fills with values.
+
+    Parameters
+    ----------
+    index : ndarray
+        Labels to use to make new frame's index
+    columns : ndarray
+        Labels to use to make new frame's columns
+    values : ndarray
+        Values to use for populating new frame's values
+
+    Note
+    ----
+    Obviously, all 3 of the input arguments must have the same length
+
+    Returns
+    -------
+    DataFrame
+    """
+    assert(len(index) == len(columns) == len(values))
+
+    if len(index) == 0:
+        return DataFrame(index=[])
+
+    hindex = MultiIndex.from_arrays([index, columns])
+    series = Series(values.ravel(), index=hindex)
+    series = series.sortlevel(0)
+    return series.unstack()
+
+def _slow_pivot(index, columns, values):
+    """
+    Produce 'pivot' table based on 3 columns of this DataFrame.
+    Uses unique values from index / columns and fills with values.
+
+    Parameters
+    ----------
+    index : string or object
+        Column name to use to make new frame's index
+    columns : string or object
+        Column name to use to make new frame's columns
+    values : string or object
+        Column name to use for populating new frame's values
+
+    Could benefit from some Cython here.
+    """
+    tree = {}
+    for i, (idx, col) in enumerate(itertools.izip(index, columns)):
+        if col not in tree:
+            tree[col] = {}
+        branch = tree[col]
+        branch[idx] = values[i]
+
+    return DataFrame(tree)
+
+def stack(frame, level=-1, dropna=True):
+    """
+    Convert DataFrame to Series with multi-level Index. Columns become the
+    second level of the resulting hierarchical index
+
+    Returns
+    -------
+    stacked : Series
+    """
+    N, K = frame.shape
+    if isinstance(frame.columns, MultiIndex):
+        return _stack_multi_columns(frame, level=level, dropna=True)
+    elif isinstance(frame.index, MultiIndex):
+
+        new_levels = list(frame.index.levels)
+        new_levels.append(frame.columns)
+
+        new_labels = [lab.repeat(K) for lab in frame.index.labels]
+        new_labels.append(np.tile(np.arange(K), N).ravel())
+
+        new_names = list(frame.index.names)
+        new_names.append('columns')
+        new_index = MultiIndex(levels=new_levels, labels=new_labels,
+                               names=new_names)
+    else:
+        ilabels = np.arange(N).repeat(K)
+        clabels = np.tile(np.arange(K), N).ravel()
+        new_index = MultiIndex(levels=[frame.index, frame.columns],
+                               labels=[ilabels, clabels])
+
+    new_values = frame.values.ravel()
+    if dropna:
+        mask = notnull(new_values)
+        new_values = new_values[mask]
+        new_index = new_index[mask]
+    return Series(new_values, index=new_index)
+
+def _stack_multi_columns(frame, level=-1, dropna=True):
+    this = frame.copy()
+    if level < 0:
+        level += frame.columns.nlevels
+
+    # this makes life much simpler
+    if level != frame.columns.nlevels - 1:
+        # roll levels to put selected level at end
+        roll_columns = this.columns
+        for i in range(level, frame.columns.nlevels - 1):
+            roll_columns = roll_columns.swaplevel(i, i + 1)
+        this.columns = roll_columns
+
+    if not this.columns.is_lexsorted():
+        this = this.sortlevel(0, axis=1)
+
+    # tuple list excluding level for grouping columns
+    if len(frame.columns.levels) > 2:
+        tuples = zip(*[lev.values.take(lab)
+                       for lev, lab in zip(this.columns.levels[:-1],
+                                           this.columns.labels[:-1])])
+        unique_groups = [key for key, _ in itertools.groupby(tuples)]
+        new_names = this.columns.names[:-1]
+        new_columns = MultiIndex.from_tuples(unique_groups, names=new_names)
+    else:
+        new_columns = unique_groups = this.columns.levels[0]
+
+    # time to ravel the values
+    new_data = {}
+    level_vals = this.columns.levels[-1]
+    levsize = len(level_vals)
+    for key in unique_groups:
+        loc = this.columns.get_loc(key)
+
+        # can make more efficient?
+        if loc.stop - loc.start != levsize:
+            chunk = this.ix[:, this.columns[loc]]
+            chunk.columns = level_vals.take(chunk.columns.labels[-1])
+            value_slice = chunk.reindex(columns=level_vals).values
+        else:
+            if frame._is_mixed_type:
+                value_slice = this.ix[:, this.columns[loc]].values
+            else:
+                value_slice = this.values[:, loc]
+
+        new_data[key] = value_slice.ravel()
+
+    N = len(this)
+
+    if isinstance(this.index, MultiIndex):
+        new_levels = list(this.index.levels)
+        new_names = list(this.index.names)
+        new_labels = [lab.repeat(levsize) for lab in this.index.labels]
+    else:
+        new_levels = [this.index]
+        new_labels = [np.arange(N).repeat(levsize)]
+        new_names = ['index'] # something better?
+
+    new_levels.append(frame.columns.levels[level])
+    new_labels.append(np.tile(np.arange(levsize), N))
+    new_names.append(frame.columns.names[level])
+
+    new_index = MultiIndex(levels=new_levels, labels=new_labels,
+                           names=new_names)
+
+    result = DataFrame(new_data, index=new_index, columns=new_columns)
+
+    # more efficient way to go about this? can do the whole masking biz but
+    # will only save a small amount of time...
+    if dropna:
+        result = result.dropna(axis=0, how='all')
+
+    return result
+
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 24a420bb3..c4b95a066 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1088,6 +1088,7 @@ copy : boolean, default False
         -------
         unstacked : DataFrame
         """
+        from pandas.core.reshape import _Unstacker
         unstacker = _Unstacker(self.values, self.index, level=level)
         return unstacker.get_result()
 
@@ -1660,175 +1661,6 @@ class TimeSeries(Series):
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
-class _Unstacker(object):
-    """
-    Helper class to unstack data / pivot with multi-level index
-
-    Parameters
-    ----------
-    level : int, default last level
-        Level to "unstack"
-
-    Examples
-    --------
-    >>> s
-    one  a   1.
-    one  b   2.
-    two  a   3.
-    two  b   4.
-
-    >>> s.unstack(level=-1)
-         a   b
-    one  1.  2.
-    two  3.  4.
-
-    >>> s.unstack(level=0)
-       one  two
-    a  1.   2.
-    b  3.   4.
-
-    Returns
-    -------
-    unstacked : DataFrame
-    """
-    def __init__(self, values, index, level=-1, value_columns=None):
-        if values.ndim == 1:
-            values = values[:, np.newaxis]
-        self.values = values
-        self.value_columns = value_columns
-
-        if value_columns is None and values.shape[1] != 1:  # pragma: no cover
-            raise ValueError('must pass column labels for multi-column data')
-
-        self.index = index
-
-        if level < 0:
-            level += index.nlevels
-        self.level = level
-
-        self.new_index_levels = list(index.levels)
-        self.removed_level = self.new_index_levels.pop(level)
-
-        v = self.level
-        lshape = self.index.levshape
-        self.full_shape = np.prod(lshape[:v] + lshape[v+1:]), lshape[v]
-
-        self._make_sorted_values_labels()
-        self._make_selectors()
-
-    def _make_sorted_values_labels(self):
-        v = self.level
-
-        labs = self.index.labels
-        to_sort = labs[:v] + labs[v+1:] + [labs[v]]
-        indexer = np.lexsort(to_sort[::-1])
-
-        self.sorted_values = self.values.take(indexer, axis=0)
-        self.sorted_labels = [l.take(indexer) for l in to_sort]
-
-    def _make_selectors(self):
-        new_levels = self.new_index_levels
-
-        # make the mask
-        group_index = self.sorted_labels[0]
-        prev_stride = np.prod([len(x) for x in new_levels[1:]])
-
-        for lev, lab in zip(new_levels[1:], self.sorted_labels[1:-1]):
-            group_index = group_index * prev_stride + lab
-            prev_stride /= len(lev)
-
-        group_mask = np.zeros(self.full_shape[0], dtype=bool)
-        group_mask.put(group_index, True)
-
-        stride = self.index.levshape[self.level]
-        selector = self.sorted_labels[-1] + stride * group_index
-        mask = np.zeros(np.prod(self.full_shape), dtype=bool)
-        mask.put(selector, True)
-
-        # compress labels
-        unique_groups = np.arange(self.full_shape[0])[group_mask]
-        compressor = group_index.searchsorted(unique_groups)
-
-        self.group_mask = group_mask
-        self.group_index = group_index
-        self.mask = mask
-        self.unique_groups = unique_groups
-        self.compressor = compressor
-
-    def get_result(self):
-        from pandas.core.frame import DataFrame
-
-        # TODO: find a better way than this masking business
-
-        values, mask = self.get_new_values()
-        columns = self.get_new_columns()
-        index = self.get_new_index()
-
-        # filter out missing levels
-        values = values[:, mask]
-        columns = columns[mask]
-
-        return DataFrame(values, index=index, columns=columns)
-
-    def get_new_values(self):
-        # place the values
-        length, width = self.full_shape
-        stride = self.values.shape[1]
-        result_width = width * stride
-
-        new_values = np.empty((length, result_width), dtype=self.values.dtype)
-        new_mask = np.zeros((length, result_width), dtype=bool)
-
-        if not issubclass(self.values.dtype.type, np.integer):
-            new_values.fill(np.nan)
-
-        # is there a simpler / faster way of doing this?
-        for i in xrange(self.values.shape[1]):
-            chunk = new_values[:, i * width : (i + 1) * width]
-            mask_chunk = new_mask[:, i * width : (i + 1) * width]
-
-            chunk.flat[self.mask] = self.sorted_values[:, i]
-            mask_chunk.flat[self.mask] = True
-
-        new_values = new_values.take(self.unique_groups, axis=0)
-        return new_values, new_mask.sum(0) > 0
-
-    def get_new_columns(self):
-        if self.value_columns is None:
-            return self.removed_level
-
-        stride = len(self.removed_level)
-        width = len(self.value_columns)
-        propagator = np.repeat(np.arange(width), stride)
-        if isinstance(self.value_columns, MultiIndex):
-            new_levels = self.value_columns.levels + [self.removed_level]
-            new_labels = [lab.take(propagator)
-                          for lab in self.value_columns.labels]
-            new_labels.append(np.tile(np.arange(stride), width))
-        else:
-            new_levels = [self.value_columns, self.removed_level]
-            new_labels = []
-
-            new_labels.append(propagator)
-            new_labels.append(np.tile(np.arange(stride), width))
-
-        return MultiIndex(levels=new_levels, labels=new_labels)
-
-    def get_new_index(self):
-        result_labels = []
-        for cur in self.sorted_labels[:-1]:
-            result_labels.append(cur.take(self.compressor))
-
-        # construct the new index
-        if len(self.new_index_levels) == 1:
-            new_index = self.new_index_levels[0].take(self.unique_groups)
-        else:
-            new_index = MultiIndex(levels=self.new_index_levels,
-                                   labels=result_labels)
-
-        return new_index
-
-
 def remove_na(arr):
     """
     Return array containing only true/non-NaN values, possibly empty.
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 6f6bb9ce4..0b238df0c 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -9,8 +9,7 @@ import traceback
 from numpy import NaN
 
 from pandas.core.datetools import format, to_datetime
-from pandas.core.panel import pivot
-from pandas.core.api import DataFrame, Series, Index, isnull
+from pandas.core.api import DataFrame, Series, Index, isnull, pivot
 
 #-------------------------------------------------------------------------------
 # Query formatting
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index c4d53eff0..b75a2f26c 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1885,6 +1885,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         renamed = self.frame.rename(columns={'C' : 'foo', 'D' : 'bar'})
         self.assert_(np.array_equal(renamed.columns, ['A', 'B', 'foo', 'bar']))
 
+        # other axis
+        renamed = self.frame.T.rename(index={'C' : 'foo', 'D' : 'bar'})
+        self.assert_(np.array_equal(renamed.index, ['A', 'B', 'foo', 'bar']))
+
     #----------------------------------------------------------------------
     # Time series related
 
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 4ec8b6c40..22ad4b0c9 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -298,6 +298,15 @@ class TestMultiLevel(unittest.TestCase):
         ymd_stacked = self.ymd.stack()
         assert_series_equal(stacked, ymd_stacked.reindex(stacked.index))
 
+    def test_stack_mixed_dtype(self):
+        df = self.frame.T
+        df['foo', 'four'] = 'foo'
+        df = df.sortlevel(1, axis=1)
+
+        stacked = df.stack()
+        assert_series_equal(stacked['foo'], df['foo'].stack())
+        self.assert_(stacked['bar'].dtype == np.float_)
+
     def test_insert_index(self):
         df = self.ymd[:5].T
         df[2000, 1, 10] = df[2000, 1, 7]
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index de49b4d71..6245d1527 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -8,10 +8,10 @@ import unittest
 
 import numpy as np
 
-from pandas.core.api import DataFrame, Index, notnull
+from pandas.core.api import DataFrame, Index, notnull, pivot
 from pandas.core.datetools import bday
 from pandas.core.frame import group_agg
-from pandas.core.panel import WidePanel, LongPanel, pivot
+from pandas.core.panel import WidePanel, LongPanel
 import pandas.core.panel as panelmod
 
 from pandas.util.testing import (assert_panel_equal,
@@ -969,6 +969,8 @@ class TestLongPanel(unittest.TestCase):
         assert_panel_equal(lp.to_wide(), self.panel.to_wide())
 
     def test_pivot(self):
+        from pandas.core.reshape import _slow_pivot
+
         df = pivot(np.array([1, 2, 3, 4, 5]),
                    np.array(['a', 'b', 'c', 'd', 'e']),
                    np.array([1, 2, 3, 5, 4.]))
@@ -983,7 +985,7 @@ class TestLongPanel(unittest.TestCase):
                    np.array(['a', 'a', 'a', 'a', 'a']),
                    np.array([1, 2, 3, 5, 4]))
         df = pivot(a, b, c)
-        expected = panelmod._slow_pivot(a, b, c)
+        expected = _slow_pivot(a, b, c)
         assert_frame_equal(df, expected)
 
         # corner case, empty

commit 1f82f18933e42f0c9695b551cfce98cd1632f841
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Jan 14 12:18:44 2017 -0500

    CLN: reorg NaT definitions in tslib.pyx

diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index ad11bd703..cde7c0dc1 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -854,68 +854,6 @@ class NaTType(_NaT):
         return NotImplemented
 
 
-fields = ['year', 'quarter', 'month', 'day', 'hour',
-          'minute', 'second', 'millisecond', 'microsecond', 'nanosecond',
-          'week', 'dayofyear', 'days_in_month', 'daysinmonth', 'dayofweek',
-          'weekday_name']
-for field in fields:
-    prop = property(fget=lambda self: np.nan)
-    setattr(NaTType, field, prop)
-
-
-# GH9513 NaT methods (except to_datetime64) to raise, return np.nan, or
-# return NaT create functions that raise, for binding to NaTType
-def _make_error_func(func_name):
-    def f(*args, **kwargs):
-        raise ValueError("NaTType does not support " + func_name)
-    f.__name__ = func_name
-    return f
-
-
-def _make_nat_func(func_name):
-    def f(*args, **kwargs):
-        return NaT
-    f.__name__ = func_name
-    return f
-
-
-def _make_nan_func(func_name):
-    def f(*args, **kwargs):
-        return np.nan
-    f.__name__ = func_name
-    return f
-
-
-# GH14940
-_round_methods = ['round', 'floor', 'ceil']
-
-_nat_methods = ['date', 'now', 'replace', 'to_pydatetime', 'today']
-_nat_methods.extend(_round_methods)
-
-_nan_methods = ['weekday', 'isoweekday', 'total_seconds']
-
-_implemented_methods = ['to_datetime', 'to_datetime64', 'isoformat']
-_implemented_methods.extend(_nat_methods)
-_implemented_methods.extend(_nan_methods)
-
-for _method_name in _nat_methods:
-    # not all methods exist in all versions of Python
-    if hasattr(NaTType, _method_name) or _method_name in _round_methods:
-        setattr(NaTType, _method_name, _make_nat_func(_method_name))
-
-for _method_name in _nan_methods:
-    if hasattr(NaTType, _method_name):
-        setattr(NaTType, _method_name, _make_nan_func(_method_name))
-
-for _maybe_method_name in dir(NaTType):
-    _maybe_method = getattr(NaTType, _maybe_method_name)
-    if (callable(_maybe_method)
-        and not _maybe_method_name.startswith("_")
-        and _maybe_method_name not in _implemented_methods):
-        setattr(NaTType, _maybe_method_name,
-                _make_error_func(_maybe_method_name))
-
-
 def __nat_unpickle(*args):
     # return constant defined in the module
     return NaT
@@ -1417,22 +1355,6 @@ cdef class _NaT(_Timestamp):
         return NotImplemented
 
 
-def _delta_to_nanoseconds(delta):
-    if isinstance(delta, np.ndarray):
-        return delta.astype('m8[ns]').astype('int64')
-    if hasattr(delta, 'nanos'):
-        return delta.nanos
-    if hasattr(delta, 'delta'):
-        delta = delta.delta
-    if is_timedelta64_object(delta):
-        return delta.astype("timedelta64[ns]").item()
-    if is_integer_object(delta):
-        return delta
-    return (delta.days * 24 * 60 * 60 * 1000000
-            + delta.seconds * 1000000
-            + delta.microseconds) * 1000
-
-
 # lightweight C object to hold datetime & int64 pair
 cdef class _TSObject:
     cdef:
@@ -3803,6 +3725,112 @@ def array_strptime(ndarray[object] values, object fmt,
     return result
 
 
+#----------------------------------------------------------------------
+# NaT methods/property setups
+
+
+# inject the Timestamp field properties
+# these by definition return np.nan
+fields = ['year', 'quarter', 'month', 'day', 'hour',
+          'minute', 'second', 'millisecond', 'microsecond', 'nanosecond',
+          'week', 'dayofyear', 'days_in_month', 'daysinmonth', 'dayofweek',
+          'weekday_name']
+for field in fields:
+    prop = property(fget=lambda self: np.nan)
+    setattr(NaTType, field, prop)
+
+
+# define how we are handling NaT methods & inject
+# to the NaTType class; these can return NaT, np.nan
+# or raise respectively
+_nat_methods = ['date', 'now', 'replace', 'to_pydatetime',
+                'today', 'round', 'floor', 'ceil']
+_nan_methods = ['weekday', 'isoweekday', 'total_seconds']
+_implemented_methods = ['to_datetime', 'to_datetime64', 'isoformat']
+_implemented_methods.extend(_nat_methods)
+_implemented_methods.extend(_nan_methods)
+
+
+def _get_docstring(_method_name):
+    # NaT serves double duty as Timestamp & Timedelta
+    # missing value, so need to acquire doc-strings for both
+
+    try:
+        return getattr(Timestamp, _method_name).__doc__
+    except AttributeError:
+        pass
+
+    try:
+        return getattr(Timedelta, _method_name).__doc__
+    except AttributeError:
+        pass
+
+    return None
+
+
+for _method_name in _nat_methods:
+
+    def _make_nat_func(func_name):
+        def f(*args, **kwargs):
+            return NaT
+        f.__name__ = func_name
+        f.__doc__ = _get_docstring(_method_name)
+        return f
+
+    setattr(NaTType, _method_name, _make_nat_func(_method_name))
+
+
+for _method_name in _nan_methods:
+
+    def _make_nan_func(func_name):
+        def f(*args, **kwargs):
+            return np.nan
+        f.__name__ = func_name
+        f.__doc__ = _get_docstring(_method_name)
+        return f
+
+    setattr(NaTType, _method_name, _make_nan_func(_method_name))
+
+
+# GH9513 NaT methods (except to_datetime64) to raise, return np.nan, or
+# return NaT create functions that raise, for binding to NaTType
+for _maybe_method_name in dir(NaTType):
+    _maybe_method = getattr(NaTType, _maybe_method_name)
+    if (callable(_maybe_method)
+        and not _maybe_method_name.startswith("_")
+        and _maybe_method_name not in _implemented_methods):
+
+        def _make_error_func(func_name):
+            def f(*args, **kwargs):
+                raise ValueError("NaTType does not support " + func_name)
+            f.__name__ = func_name
+            f.__doc__ = _get_docstring(_method_name)
+            return f
+
+        setattr(NaTType, _maybe_method_name,
+                _make_error_func(_maybe_method_name))
+
+
+#----------------------------------------------------------------------
+# Conversion routines
+
+
+def _delta_to_nanoseconds(delta):
+    if isinstance(delta, np.ndarray):
+        return delta.astype('m8[ns]').astype('int64')
+    if hasattr(delta, 'nanos'):
+        return delta.nanos
+    if hasattr(delta, 'delta'):
+        delta = delta.delta
+    if is_timedelta64_object(delta):
+        return delta.astype("timedelta64[ns]").item()
+    if is_integer_object(delta):
+        return delta
+    return (delta.days * 24 * 60 * 60 * 1000000
+            + delta.seconds * 1000000
+            + delta.microseconds) * 1000
+
+
 cdef inline _get_datetime64_nanos(object val):
     cdef:
         pandas_datetimestruct dts
@@ -3891,9 +3919,6 @@ def cast_to_nanoseconds(ndarray arr):
 
     return result
 
-#----------------------------------------------------------------------
-# Conversion routines
-
 
 def pydt_to_i8(object pydt):
     """

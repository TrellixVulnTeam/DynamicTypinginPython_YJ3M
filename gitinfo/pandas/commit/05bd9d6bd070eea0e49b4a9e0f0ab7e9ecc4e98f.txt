commit 05bd9d6bd070eea0e49b4a9e0f0ab7e9ecc4e98f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 7 12:06:54 2012 -0400

    BUG: label slicing bugs with floats in Series, DataFrame, close #1167

diff --git a/RELEASE.rst b/RELEASE.rst
index 2991910b2..9b496a72d 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -56,6 +56,8 @@ pandas 0.8.0
   - Series([False, nan]) was getting casted to float64 (GH #1074)
   - Fix binary operations between boolean Series and object Series with
     booleans and NAs (GH #1074)
+  - Couldn't assign whole array to column in mixed-type DataFrame via .ix
+    (#1142)
 
 pandas 0.7.3
 ============
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3869c9f17..5691bf65a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1440,11 +1440,13 @@ class DataFrame(NDFrame):
         # slice rows
         if isinstance(key, slice):
             from pandas.core.indexing import _is_index_slice
-            if self.index.inferred_type == 'integer' or _is_index_slice(key):
+            idx_type = self.index.inferred_type
+            if idx_type == 'floating':
+                indexer = self.ix._convert_to_indexer(key, axis=0)
+            elif idx_type == 'integer' or _is_index_slice(key):
                 indexer = key
             else:
                 indexer = self.ix._convert_to_indexer(key, axis=0)
-
             new_data = self._data.get_slice(indexer, axis=1)
             return self._constructor(new_data)
         # either boolean or fancy integer index
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 1c636106c..da24a07d3 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -251,26 +251,32 @@ class _NDFrameIndexer(object):
             pass
 
         if isinstance(obj, slice):
+            ltype = labels.inferred_type
+
+            if ltype == 'floating':
+                int_slice = _is_int_slice(obj)
+            else:
+                # floats that are within tolerance of int used
+                int_slice = _is_index_slice(obj)
 
-            int_slice = _is_index_slice(obj)
             null_slice = obj.start is None and obj.stop is None
             # could have integers in the first level of the MultiIndex
             position_slice = (int_slice
-                              and not labels.inferred_type == 'integer'
+                              and not ltype == 'integer'
                               and not isinstance(labels, MultiIndex))
 
             start, stop = obj.start, obj.stop
 
             # last ditch effort: if we are mixed and have integers
             try:
-                if 'mixed' in labels.inferred_type and int_slice:
+                if 'mixed' in ltype and int_slice:
                     if start is not None:
                         i = labels.get_loc(start)
                     if stop is not None:
                         j = labels.get_loc(stop)
                     position_slice = False
             except KeyError:
-                if labels.inferred_type == 'mixed-integer':
+                if ltype == 'mixed-integer':
                     raise
 
             if null_slice or position_slice:
@@ -337,8 +343,7 @@ class _NDFrameIndexer(object):
 
         # in case of providing all floats, use label-based indexing
         float_slice = (labels.inferred_type == 'floating'
-                       and (type(start) == float or start is None)
-                       and (type(stop) == float or stop is None))
+                       and _is_float_slice(slice_obj))
 
         null_slice = slice_obj.start is None and slice_obj.stop is None
 
@@ -395,6 +400,28 @@ def _is_index_slice(obj):
 
     return not both_none and (_crit(obj.start) and _crit(obj.stop))
 
+def _is_int_slice(obj):
+    def _is_valid_index(x):
+        return com.is_integer(x)
+
+    def _crit(v):
+        return v is None or _is_valid_index(v)
+
+    both_none = obj.start is None and obj.stop is None
+
+    return not both_none and (_crit(obj.start) and _crit(obj.stop))
+
+def _is_float_slice(obj):
+    def _is_valid_index(x):
+        return com.is_float(x)
+
+    def _crit(v):
+        return v is None or _is_valid_index(v)
+
+    both_none = obj.start is None and obj.stop is None
+
+    return not both_none and (_crit(obj.start) and _crit(obj.stop))
+
 
 class _SeriesIndexer(_NDFrameIndexer):
     """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1f1712a8b..c2094750f 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -430,7 +430,11 @@ copy : boolean, default False
         if isinstance(key, slice):
             from pandas.core.indexing import _is_index_slice
 
-            if self.index.inferred_type == 'integer' or _is_index_slice(key):
+            idx_type = self.index.inferred_type
+
+            if idx_type == 'floating':
+                indexer = self.ix._convert_to_indexer(key, axis=0)
+            elif idx_type == 'integer' or _is_index_slice(key):
                 indexer = key
             else:
                 indexer = self.ix._convert_to_indexer(key, axis=0)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 8be5d86ab..baa09a36a 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -566,6 +566,30 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assert_(len(s.ix[12.0:]) == 8)
         self.assert_(len(s.ix[12.5:]) == 7)
 
+    def test_slice_float64(self):
+        values = np.arange(10., 50., 2)
+        index = Index(values)
+
+        start, end = values[[5, 15]]
+
+        s = Series(np.random.randn(20), index=index)
+
+        result = s[start:end]
+        expected = s.ix[5:16]
+        assert_series_equal(result, expected)
+
+        result = s.ix[start:end]
+        assert_series_equal(result, expected)
+
+        df = DataFrame(np.random.randn(20, 3), index=index)
+
+        result = df[start:end]
+        expected = df.ix[5:16]
+        tm.assert_frame_equal(result, expected)
+
+        result = df.ix[start:end]
+        tm.assert_frame_equal(result, expected)
+
     def test_setitem(self):
         self.ts[self.ts.index[5]] = np.NaN
         self.ts[[1,2,17]] = np.NaN

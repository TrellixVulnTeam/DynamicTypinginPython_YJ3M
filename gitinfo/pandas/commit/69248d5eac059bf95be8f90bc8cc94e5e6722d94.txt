commit 69248d5eac059bf95be8f90bc8cc94e5e6722d94
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jul 8 18:12:19 2011 -0400

    SparseDataFrame + DataFrame -> SparseDataFrame, simplified arith methods

diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1b3b1fc75..f2051852a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -30,24 +30,12 @@ def _arith_method(op, name):
     Wrapper function for Series arithmetic operations, to avoid
     code duplication.
     """
-    MIRROR_OPS = {
-        '__add__' : '__radd__',
-        '__sub__' : '__rsub__',
-        '__div__' : '__rdiv__',
-        '__mul__' : '__rmul__',
-        '__radd__' : '__add__',
-        '__rsub__' : '__sub__',
-        '__rdiv__' : '__div__',
-        '__rmul__' : '__mul__',
-    }
     def wrapper(self, other):
         from pandas.core.frame import DataFrame
 
-        values = self.values
-
         if isinstance(other, Series):
             if self.index.equals(other.index):
-                return Series(op(values, other.values), index=self.index)
+                return Series(op(self.values, other.values), index=self.index)
 
             newIndex = self.index + other.index
 
@@ -70,16 +58,10 @@ def _arith_method(op, name):
                 arr = Series.combine(self, other, getattr(type(self[0]), name))
             result = Series(arr, index=newIndex)
             return result
-
         elif isinstance(other, DataFrame):
-            reverse_op = MIRROR_OPS.get(name)
-
-            if reverse_op is None:
-                raise Exception('Cannot do %s op, sorry!')
-
-            return getattr(other, reverse_op)(self)
+            return NotImplemented
         else:
-            return Series(op(values, other), index=self.index)
+            return Series(op(self.values, other), index=self.index)
     return wrapper
 
 def _flex_method(op, name):
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 28257c9e6..de755dedd 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -61,13 +61,32 @@ def make_sparse(arr, kind='block', fill_value=nan):
 
 #-------------------------------------------------------------------------------
 # Wrapper function for Series arithmetic methods
-_MIRROR_OPS = {
-    'add' : '__radd__',
-    'sub' : '__rsub__',
-    'div' : '__rdiv__',
-    'truediv' : '__rdiv__',
-    'mul' : '__rmul__',
-}
+
+def _sparse_op_wrap(op, name):
+    """
+    Wrapper function for Series arithmetic operations, to avoid
+    code duplication.
+    """
+    def wrapper(self, other):
+        if isinstance(other, Series):
+            if not isinstance(other, SparseSeries):
+                other = other.to_sparse(fill_value=self.fill_value)
+            return _sparse_series_op(self, other, op, name)
+        elif isinstance(other, DataFrame):
+            return NotImplemented
+        elif np.isscalar(other):
+            new_fill_value = op(np.float64(self.fill_value),
+                                np.float64(other))
+
+            return SparseSeries(op(self.sp_values, other),
+                                index=self.index,
+                                sparse_index=self.sp_index,
+                                fill_value=new_fill_value)
+        else:
+            raise Exception('operation with %s not supported' % type(other))
+
+    wrapper.__name__ = name
+    return wrapper
 
 def _sparse_series_op(left, right, op, name):
     if np.isnan(left.fill_value):
@@ -97,33 +116,6 @@ def _sparse_series_op(left, right, op, name):
                         sparse_index=result_index,
                         fill_value=fill_value)
 
-def _sparse_op_wrap(op, name):
-    """
-    Wrapper function for Series arithmetic operations, to avoid
-    code duplication.
-    """
-    def wrapper(self, other):
-        if isinstance(other, SparseSeries):
-            return _sparse_series_op(self, other, op, name)
-        elif isinstance(other, SparseDataFrame):
-            reverse_op = _MIRROR_OPS.get(name)
-            if reverse_op is None: # pragma: no cover
-                raise Exception('Cannot do %s op, sorry!' % name)
-            return getattr(other, reverse_op)(self)
-        elif np.isscalar(other):
-            new_fill_value = op(np.float64(self.fill_value),
-                                np.float64(other))
-
-            return SparseSeries(op(self.sp_values, other),
-                                index=self.index,
-                                sparse_index=self.sp_index,
-                                fill_value=new_fill_value)
-        else:
-            raise Exception('operation with %s not supported' % type(other))
-
-    wrapper.__name__ = name
-    return wrapper
-
 def _sparse_nanop(this, other, name):
     sparse_op = getattr(splib, 'sparse_nan%s' % name)
     result, result_index = sparse_op(this.sp_values,
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 6cc7e0bca..5e4bf6eea 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -473,7 +473,7 @@ class TestSeries(unittest.TestCase):
         df = DataFrame({'A' : self.ts})
 
         common.assert_almost_equal(self.ts + self.ts, (self.ts + df)['A'])
-        self.assertRaises(Exception, self.ts.__pow__, df)
+        common.assert_almost_equal(self.ts ** self.ts, (self.ts ** df)['A'])
 
     def test_operators_combine(self):
         def _check_fill(meth, op, a, b, fill_value=0):
diff --git a/pandas/tests/test_sparse.py b/pandas/tests/test_sparse.py
index e87955f60..fe3353c33 100644
--- a/pandas/tests/test_sparse.py
+++ b/pandas/tests/test_sparse.py
@@ -377,9 +377,9 @@ class TestSparseSeries(TestCase):
         check(self.zbseries, self.zbseries2)
         check(self.ziseries, self.ziseries2)
 
-    def test_operators_corner(self):
-        self.assertRaises(Exception, self.bseries.__add__,
-                          self.bseries.to_dense())
+        # with dense
+        result = self.bseries + self.bseries.to_dense()
+        assert_sp_series_equal(result, self.bseries + self.bseries)
 
     # @dec.knownfailureif(True, 'Known NumPy failer as of 1.5.1')
     def test_operators_corner2(self):
@@ -727,10 +727,17 @@ class TestSparseDataFrame(TestCase):
         def _compare_to_dense(a, b, da, db, op):
             sparse_result = op(a, b)
             dense_result = op(da, db)
+
             dense_result = dense_result.to_sparse(fill_value=fill)
             assert_sp_frame_equal(sparse_result, dense_result,
                                   exact_indices=False)
 
+            if isinstance(a, DataFrame) and isinstance(db, DataFrame):
+                mixed_result = op(a, db)
+                self.assert_(isinstance(mixed_result, SparseDataFrame))
+                assert_sp_frame_equal(mixed_result, sparse_result,
+                                      exact_indices=False)
+
         opnames = ['add', 'sub', 'mul', 'div']
         ops = [getattr(operator, name) for name in opnames]
 

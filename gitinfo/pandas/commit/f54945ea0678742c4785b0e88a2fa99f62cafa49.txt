commit f54945ea0678742c4785b0e88a2fa99f62cafa49
Author: Gregory Rome <gwrome@gmail.com>
Date:   Tue Apr 30 08:05:48 2019 -0500

    #26065 Fix Type Annotations in pandas.core.arrays (#26071)

diff --git a/mypy.ini b/mypy.ini
index 2069c736a..596d71c77 100644
--- a/mypy.ini
+++ b/mypy.ini
@@ -11,24 +11,6 @@ ignore_errors=True
 [mypy-pandas.core.api]
 ignore_errors=True
 
-[mypy-pandas.core.arrays.array_]
-ignore_errors=True
-
-[mypy-pandas.core.arrays.datetimelike]
-ignore_errors=True
-
-[mypy-pandas.core.arrays.integer]
-ignore_errors=True
-
-[mypy-pandas.core.arrays.interval]
-ignore_errors=True
-
-[mypy-pandas.core.arrays.period]
-ignore_errors=True
-
-[mypy-pandas.core.arrays.timedeltas]
-ignore_errors=True
-
 [mypy-pandas.core.base]
 ignore_errors=True
 
diff --git a/pandas/_typing.py b/pandas/_typing.py
index dc15a44b6..3959e38e6 100644
--- a/pandas/_typing.py
+++ b/pandas/_typing.py
@@ -1,11 +1,16 @@
 from pathlib import Path
-from typing import IO, AnyStr, Union
+from typing import IO, AnyStr, Type, Union
 
 import numpy as np
 
+from pandas._libs import Timestamp
+from pandas._libs.tslibs.period import Period
+from pandas._libs.tslibs.timedeltas import Timedelta
+
 from pandas.core.dtypes.dtypes import ExtensionDtype
 from pandas.core.dtypes.generic import ABCExtensionArray
 
 ArrayLike = Union[ABCExtensionArray, np.ndarray]
+DatetimeLikeScalar = Type[Union[Period, Timestamp, Timedelta]]
 Dtype = Union[str, np.dtype, ExtensionDtype]
 FilePathOrBuffer = Union[str, Path, IO[AnyStr]]
diff --git a/pandas/core/arrays/array_.py b/pandas/core/arrays/array_.py
index f54955744..1b002ad12 100644
--- a/pandas/core/arrays/array_.py
+++ b/pandas/core/arrays/array_.py
@@ -1,4 +1,4 @@
-from typing import Optional, Sequence, Union
+from typing import Optional, Sequence, Union, cast
 
 import numpy as np
 
@@ -229,7 +229,7 @@ def array(data: Sequence[object],
         dtype = registry.find(dtype) or dtype
 
     if is_extension_array_dtype(dtype):
-        cls = dtype.construct_array_type()
+        cls = cast(ExtensionDtype, dtype).construct_array_type()
         return cls._from_sequence(data, dtype=dtype, copy=copy)
 
     if dtype is None:
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index 38cad11b2..c32f8642d 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -1,6 +1,6 @@
 from datetime import datetime, timedelta
 import operator
-from typing import Any, Sequence, Tuple, Type, Union
+from typing import Any, Sequence, Union, cast
 import warnings
 
 import numpy as np
@@ -27,6 +27,7 @@ from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries
 from pandas.core.dtypes.inference import is_array_like
 from pandas.core.dtypes.missing import isna
 
+from pandas._typing import DatetimeLikeScalar
 from pandas.core import missing, nanops
 from pandas.core.algorithms import (
     checked_add_with_arr, take, unique1d, value_counts)
@@ -39,6 +40,7 @@ from .base import ExtensionArray, ExtensionOpsMixin
 
 
 class AttributesMixin:
+    _data = None  # type: np.ndarray
 
     @property
     def _attributes(self):
@@ -56,7 +58,7 @@ class AttributesMixin:
         return {k: getattr(self, k, None) for k in self._attributes}
 
     @property
-    def _scalar_type(self) -> Union[Type, Tuple[Type]]:
+    def _scalar_type(self) -> DatetimeLikeScalar:
         """The scalar associated with this datelike
 
         * PeriodArray : Period
@@ -477,14 +479,16 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin,
             if lib.is_scalar(key):
                 raise ValueError("setting an array element with a sequence.")
 
-            if (not is_slice
-                    and len(key) != len(value)
-                    and not com.is_bool_indexer(key)):
-                msg = ("shape mismatch: value array of length '{}' does not "
-                       "match indexing result of length '{}'.")
-                raise ValueError(msg.format(len(key), len(value)))
-            if not is_slice and len(key) == 0:
-                return
+            if not is_slice:
+                key = cast(Sequence, key)
+                if (len(key) != len(value)
+                        and not com.is_bool_indexer(key)):
+                    msg = ("shape mismatch: value array of length '{}' does "
+                           "not match indexing result of length '{}'.")
+                    raise ValueError(msg.format(
+                        len(key), len(value)))
+                elif not len(key):
+                    return
 
             value = type(self)._from_sequence(value, dtype=self.dtype)
             self._check_compatible_with(value)
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index 29c146cb5..3f0a3590e 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -1,5 +1,6 @@
 import copy
 import sys
+from typing import Type
 import warnings
 
 import numpy as np
@@ -31,9 +32,9 @@ class _IntegerDtype(ExtensionDtype):
 
     The attributes name & type are set when these subclasses are created.
     """
-    name = None
+    name = None  # type: str
     base = None
-    type = None
+    type = None  # type: Type
     na_value = np.nan
 
     def __repr__(self):
diff --git a/pandas/core/arrays/interval.py b/pandas/core/arrays/interval.py
index 5de265eb8..c73ac0ab5 100644
--- a/pandas/core/arrays/interval.py
+++ b/pandas/core/arrays/interval.py
@@ -939,8 +939,9 @@ class IntervalArray(IntervalMixin, ExtensionArray):
         points) and is either monotonic increasing or monotonic decreasing,
         else False
         """
-
-    @property
+    # https://github.com/python/mypy/issues/1362
+    # Mypy does not support decorated properties
+    @property  # type: ignore
     @Appender(_interval_shared_docs['is_non_overlapping_monotonic']
               % _shared_docs_kwargs)
     def is_non_overlapping_monotonic(self):
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 32f3d215b..8a6640e11 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -1,6 +1,6 @@
 from datetime import timedelta
 import operator
-from typing import Any, Callable, Optional, Sequence, Union
+from typing import Any, Callable, List, Optional, Sequence, Union
 
 import numpy as np
 
@@ -23,7 +23,7 @@ from pandas.core.dtypes.generic import (
 from pandas.core.dtypes.missing import isna, notna
 
 import pandas.core.algorithms as algos
-from pandas.core.arrays import ExtensionArray, datetimelike as dtl
+from pandas.core.arrays import datetimelike as dtl
 import pandas.core.common as com
 
 from pandas.tseries import frequencies
@@ -94,7 +94,7 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
 
     Parameters
     ----------
-    values : Union[PeriodArray, Series[period], ndarary[int], PeriodIndex]
+    values : Union[PeriodArray, Series[period], ndarray[int], PeriodIndex]
         The data to store. These should be arrays that can be directly
         converted to ordinals without inference or copy (PeriodArray,
         ndarray[int64]), or a box around such an array (Series[period],
@@ -135,7 +135,7 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
     _scalar_type = Period
 
     # Names others delegate to us
-    _other_ops = []
+    _other_ops = []  # type: List[str]
     _bool_ops = ['is_leap_year']
     _object_ops = ['start_time', 'end_time', 'freq']
     _field_ops = ['year', 'month', 'day', 'hour', 'minute', 'second',
@@ -276,7 +276,8 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
     def dtype(self):
         return self._dtype
 
-    @property
+    # read-only property overwriting read/write
+    @property  # type: ignore
     def freq(self):
         """
         Return the frequency object for this PeriodArray.
@@ -538,7 +539,8 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
     @Appender(dtl.DatetimeLikeArrayMixin._addsub_int_array.__doc__)
     def _addsub_int_array(
             self,
-            other: Union[ExtensionArray, np.ndarray, ABCIndexClass],
+            other: Union[ABCPeriodArray, ABCSeries,
+                         ABCPeriodIndex, np.ndarray],
             op: Callable[[Any], Any]
     ) -> ABCPeriodArray:
         assert op in [operator.add, operator.sub]
@@ -778,7 +780,8 @@ def period_array(
     data = np.asarray(data)
 
     if freq:
-        dtype = PeriodDtype(freq)
+        # typed Optional here because the else block below assigns None
+        dtype = PeriodDtype(freq)  # type: Optional[PeriodDtype]
     else:
         dtype = None
 
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index e09e546a4..58d9e4085 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -1,5 +1,6 @@
 from datetime import timedelta
 import textwrap
+from typing import List
 import warnings
 
 import numpy as np
@@ -130,8 +131,8 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
     _scalar_type = Timedelta
     __array_priority__ = 1000
     # define my properties & methods for delegation
-    _other_ops = []
-    _bool_ops = []
+    _other_ops = []  # type: List[str]
+    _bool_ops = []  # type: List[str]
     _object_ops = ['freq']
     _field_ops = ['days', 'seconds', 'microseconds', 'nanoseconds']
     _datetimelike_ops = _field_ops + _object_ops + _bool_ops

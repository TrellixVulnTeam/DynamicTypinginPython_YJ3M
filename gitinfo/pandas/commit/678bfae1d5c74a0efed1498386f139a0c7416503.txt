commit 678bfae1d5c74a0efed1498386f139a0c7416503
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 4 16:42:24 2020 -0800

    CLN: assorted cleanups in indexes/ (#31674)

diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 6a7551391..ccb4927d9 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -4107,6 +4107,11 @@ class Index(IndexOpsMixin, PandasObject):
         bool
             Whether the key search is in the index.
 
+        Raises
+        ------
+        TypeError
+            If the key is not hashable.
+
         See Also
         --------
         Index.isin : Returns an ndarray of boolean dtype indicating whether the
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index 2cdf47ad6..fc6da6f75 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -160,17 +160,6 @@ class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
 
     _typ = "categoricalindex"
 
-    _raw_inherit = {
-        "argsort",
-        "_internal_get_values",
-        "tolist",
-        "codes",
-        "categories",
-        "ordered",
-        "_reverse_indexer",
-        "searchsorted",
-    }
-
     codes: np.ndarray
     categories: Index
     _data: Categorical
@@ -847,18 +836,13 @@ class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
         result.name = name
         return result
 
-    def _delegate_property_get(self, name: str, *args, **kwargs):
-        """ method delegation to the ._values """
-        prop = getattr(self._values, name)
-        return prop  # no wrapping for now
-
     def _delegate_method(self, name: str, *args, **kwargs):
         """ method delegation to the ._values """
         method = getattr(self._values, name)
         if "inplace" in kwargs:
             raise ValueError("cannot use inplace with CategoricalIndex")
         res = method(*args, **kwargs)
-        if is_scalar(res) or name in self._raw_inherit:
+        if is_scalar(res):
             return res
         return CategoricalIndex(res, name=self.name)
 
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 718cd0957..04c05fa2a 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -200,7 +200,7 @@ class DatetimeIndexOpsMixin(ExtensionIndex):
             arr = type(self._data)._simple_new(
                 sorted_values, dtype=self.dtype, freq=freq
             )
-            return self._simple_new(arr, name=self.name)
+            return type(self)._simple_new(arr, name=self.name)
 
     @Appender(_index_shared_docs["take"] % _index_doc_kwargs)
     def take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):
@@ -526,7 +526,7 @@ class DatetimeIndexOpsMixin(ExtensionIndex):
             if is_diff_evenly_spaced:
                 new_data._freq = self.freq
 
-        return self._simple_new(new_data, name=name)
+        return type(self)._simple_new(new_data, name=name)
 
     def shift(self, periods=1, freq=None):
         """
@@ -629,7 +629,7 @@ class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
                     del attributes["freq"]
 
         attributes.update(kwargs)
-        return self._simple_new(values, **attributes)
+        return type(self)._simple_new(values, **attributes)
 
     # --------------------------------------------------------------------
     # Set Operation Methods
@@ -886,7 +886,7 @@ class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
             kwargs = {}
             if hasattr(self, "tz"):
                 kwargs["tz"] = getattr(other, "tz", None)
-            return self._simple_new(joined, name, **kwargs)
+            return type(self)._simple_new(joined, name, **kwargs)
 
     # --------------------------------------------------------------------
     # List-Like Methods
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 46c896a72..07290fc3c 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -590,6 +590,7 @@ class DatetimeIndex(DatetimeTimedeltaMixin):
                 raise KeyError
 
             # a monotonic (sorted) series can be sliced
+            # Use asi8.searchsorted to avoid re-validating
             left = stamps.searchsorted(t1.value, side="left") if use_lhs else None
             right = stamps.searchsorted(t2.value, side="right") if use_rhs else None
 
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 956da07f5..42f0a0129 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -5,7 +5,7 @@ import weakref
 import numpy as np
 
 from pandas._libs import index as libindex
-from pandas._libs.tslibs import NaT, frequencies as libfrequencies, resolution
+from pandas._libs.tslibs import frequencies as libfrequencies, resolution
 from pandas._libs.tslibs.parsing import parse_time_string
 from pandas._libs.tslibs.period import Period
 from pandas.util._decorators import Appender, cache_readonly
@@ -547,7 +547,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
             # we cannot construct the Period
             raise KeyError(key)
 
-        ordinal = key.ordinal if key is not NaT else key.value
+        ordinal = self._data._unbox_scalar(key)
         try:
             return self._engine.get_loc(ordinal)
         except KeyError:
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index d4954eb67..ec0414adc 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -278,12 +278,6 @@ class TimedeltaIndex(DatetimeTimedeltaMixin, dtl.TimelikeOps):
 
         return label
 
-    def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):
-        # TODO: Check for non-True use_lhs/use_rhs
-        assert isinstance(key, str), type(key)
-        # given a key, try to figure out a location for a partial slice
-        raise NotImplementedError
-
     def is_type_compatible(self, typ) -> bool:
         return typ == self.inferred_type or typ == "timedelta"
 

commit ea6408cf181bb7623e2baa647946101442b068c5
Author: jreback <jeff@reback.net>
Date:   Thu Aug 8 12:43:46 2013 -0400

    ENH:  GH2578, allow ix and friends to partially set when the key is not contained
          in the object

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 902a51ab0..9a3e3c9d6 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -440,6 +440,40 @@ the object it modified, which in the case of enlargement, will be a **new object
    df.at[dates[5], 'E'] = 7
    df.iat[3, 0] = 7
 
+.. _indexing.basics.partial_setting:
+
+Setting With Enlargement
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+The ``.loc/.iloc/[]`` operations can perform enlargement when setting a non-existant key for that axis.
+
+In the ``Series`` case this is effectively an appending operation
+
+.. ipython:: python
+
+   se = Series([1,2,3])
+   se
+   se[5] = 5.
+   se
+
+A ``DataFrame`` can be enlarged on either axis via ``.loc``
+
+.. ipython:: python
+
+   dfi = DataFrame(np.arange(6).reshape(3,2),
+                   columns=['A','B'])
+   dfi
+   dfi.loc[:,'C'] = dfi.loc[:,'A']
+   dfi
+
+This is like an ``append`` operation on the ``DataFrame``.
+
+.. ipython:: python
+
+   dfi.loc[3] = 5
+   dfi
+
+
 Boolean indexing
 ~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/release.rst b/doc/source/release.rst
index 69647939a..debe2aae9 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -123,6 +123,8 @@ pandas 0.13
 
     - added ``date_unit`` parameter to specify resolution of timestamps. Options
       are seconds, milliseconds, microseconds and nanoseconds. (:issue:`4362`, :issue:`4498`).
+    - allow ``ix/loc/iloc`` for Series/DataFrame/Panel to set on any axis even when the single-key is not currently contained in
+      the index for that axis (:issue:`2578`)
 
   - ``Index`` and ``MultiIndex`` changes (:issue:`4039`):
 
@@ -296,7 +298,7 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
   - ``tslib.get_period_field()`` and ``tslib.get_period_field_arr()`` now raise
     if code argument out of range (:issue:`4519`, :issue:`4520`)
   - Fix boolean indexing on an empty series loses index names (:issue:`4235`),
-  infer_dtype works with empty arrays.
+    infer_dtype works with empty arrays.
   - Fix reindexing with multiple axes; if an axes match was not replacing the current axes, leading
     to a possible lazay frequency inference issue (:issue:`3317`)
   - Fixed issue where ``DataFrame.apply`` was reraising exceptions incorrectly
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 74cdb1ce3..d1decc164 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -134,6 +134,54 @@ API changes
         df1 and df2
         s1 and s2
 
+Indexing API Changes
+~~~~~~~~~~~~~~~~~~~~
+
+    Prior to 0.13, it was impossible to use an indexer (``.loc/.iloc/.ix``) to set a value that
+    was not contained in the index of a particular axis. (:issue:`2578`). See more at :ref:`here<indexing.basics.partial_setting>`
+
+    In the ``Series`` case this is effectively an appending operation
+
+    .. ipython:: python
+
+       s = Series([1,2,3])
+       s
+       s[5] = 5.
+       s
+
+    .. ipython:: python
+
+       dfi = DataFrame(np.arange(6).reshape(3,2),
+                       columns=['A','B'])
+       dfi
+
+    This would previously ``KeyError``
+
+    .. ipython:: python
+
+       dfi.loc[:,'C'] = dfi.loc[:,'A']
+       dfi
+
+    This is like an ``append`` operation.
+
+    .. ipython:: python
+
+       dfi.loc[3] = 5
+       dfi
+
+    A Panel setting operation on an arbitrary axis aligns the input to the Panel
+
+    .. ipython:: python
+
+       p = pd.Panel(np.arange(16).reshape(2,4,2),
+                   items=['Item1','Item2'],
+                   major_axis=pd.date_range('2001/1/12',periods=4),
+                   minor_axis=['A','B'],dtype='float64')
+       p
+       p.loc[:,:,'C'] = Series([30,32],index=p.items)
+       p
+       p.loc[:,:,'C']
+
 Enhancements
 ~~~~~~~~~~~~
 
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 64760cdba..e0cd21906 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,7 +1,7 @@
 # pylint: disable=W0223
 
 from datetime import datetime
-from pandas.core.common import _asarray_tuplesafe
+from pandas.core.common import _asarray_tuplesafe, is_list_like
 from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas.compat import range, zip
 import pandas.compat as compat
@@ -86,27 +86,66 @@ class _NDFrameIndexer(object):
             if len(key) > self.ndim:
                 raise IndexingError('only tuples of length <= %d supported',
                                     self.ndim)
-            indexer = self._convert_tuple(key)
+            indexer = self._convert_tuple(key, is_setter=True)
         else:
-            indexer = self._convert_to_indexer(key)
+            indexer = self._convert_to_indexer(key, is_setter=True)
 
         self._setitem_with_indexer(indexer, value)
 
     def _has_valid_tuple(self, key):
         pass
 
-    def _convert_tuple(self, key):
+    def _convert_tuple(self, key, is_setter=False):
         keyidx = []
         for i, k in enumerate(key):
-            idx = self._convert_to_indexer(k, axis=i)
+            idx = self._convert_to_indexer(k, axis=i, is_setter=is_setter)
             keyidx.append(idx)
         return tuple(keyidx)
 
     def _setitem_with_indexer(self, indexer, value):
 
         # also has the side effect of consolidating in-place
-        # mmm, spaghetti
+        from pandas import Panel, DataFrame, Series
 
+        # maybe partial set
+        if isinstance(indexer,tuple):
+            nindexer = []
+            for i, idx in enumerate(indexer):
+                if isinstance(idx, dict):
+
+                    # reindex the axis to the new value
+                    # and set inplace
+                    key,_ = _convert_missing_indexer(idx)
+                    labels = self.obj._get_axis(i) + Index([key])
+                    self.obj._data = self.obj.reindex_axis(labels,i)._data
+
+                    nindexer.append(labels.get_loc(key))
+                else:
+                    nindexer.append(idx)
+
+            indexer = tuple(nindexer)
+        else:
+
+            indexer, missing = _convert_missing_indexer(indexer)
+
+            if missing:
+
+                # reindex the axis to the new value
+                # and set inplace
+                if self.ndim == 1:
+                    self.obj._data = self.obj.append(Series(value,index=[indexer]))._data
+                    return
+
+                elif self.ndim == 2:
+                    labels = self.obj._get_axis(0) + Index([indexer])
+                    self.obj._data = self.obj.reindex_axis(labels,0)._data
+                    return getattr(self.obj,self.name).__setitem__(indexer,value)
+
+                # set using setitem (Panel and > dims)
+                elif self.ndim >= 3:
+                    return self.obj.__setitem__(indexer,value)
+
+        # align and set the values
         if self.obj._is_mixed_type:
             if not isinstance(indexer, tuple):
                 indexer = self._tuplify(indexer)
@@ -192,14 +231,73 @@ class _NDFrameIndexer(object):
     def _align_series(self, indexer, ser):
         # indexer to assign Series can be tuple or scalar
         if isinstance(indexer, tuple):
+
+            aligners = [ not _is_null_slice(idx) for idx in indexer ]
+            single_aligner = sum(aligners) == 1
+            is_frame = self.obj.ndim == 2
+            is_panel = self.obj.ndim >= 3
+
+            # are we a single alignable value on a non-primary
+            # dim (e.g. panel: 1,2, or frame: 0) ?
+            # hence need to align to a single axis dimension
+            # rather that find all valid dims
+
+            # frame
+            if is_frame:
+                single_aligner = single_aligner and aligners[0]
+
+            # panel
+            elif is_panel:
+                single_aligner = single_aligner and (aligners[1] or aligners[2])
+
+            obj = self.obj
             for i, idx in enumerate(indexer):
-                ax = self.obj.axes[i]
+                ax = obj.axes[i]
+
+                # multiple aligners (or null slices)
                 if com._is_sequence(idx) or isinstance(idx, slice):
+                    if single_aligner and _is_null_slice(idx):
+                        continue
                     new_ix = ax[idx]
+                    if not is_list_like(new_ix):
+                        new_ix = Index([new_ix])
                     if ser.index.equals(new_ix):
                         return ser.values.copy()
                     return ser.reindex(new_ix).values
 
+                # 2 dims
+                elif single_aligner and is_frame:
+
+                    # reindex along index
+                    ax = self.obj.axes[1]
+                    if ser.index.equals(ax):
+                        return ser.values.copy()
+                    return ser.reindex(ax).values
+
+                # >2 dims
+                elif single_aligner:
+
+                    broadcast = []
+                    for n, labels in enumerate(self.obj._get_plane_axes(i)):
+
+                        # reindex along the matching dimensions
+                        if len(labels & ser.index):
+                            ser = ser.reindex(labels)
+                        else:
+                            broadcast.append((n,len(labels)))
+
+                    # broadcast along other dims
+                    ser = ser.values.copy()
+                    for (axis,l) in broadcast:
+                        shape = [ -1 ] * (len(broadcast)+1)
+                        shape[axis] = l
+                        ser = np.tile(ser,l).reshape(shape)
+
+                    if self.obj.ndim == 3:
+                        ser = ser.T
+
+                    return ser
+
         elif np.isscalar(indexer):
             ax = self.obj._get_axis(1)
 
@@ -521,7 +619,7 @@ class _NDFrameIndexer(object):
 
                 return result
 
-    def _convert_to_indexer(self, obj, axis=0):
+    def _convert_to_indexer(self, obj, axis=0, is_setter=False):
         """
         Convert indexing key into something we can use to do actual fancy
         indexing on an ndarray
@@ -639,7 +737,14 @@ class _NDFrameIndexer(object):
                 return indexer
 
         else:
-            return labels.get_loc(obj)
+            try:
+                return labels.get_loc(obj)
+            except (KeyError):
+
+                # allow a not found key only if we are a setter
+                if np.isscalar(obj) and is_setter:
+                    return { 'key' : obj }
+                raise
 
     def _tuplify(self, loc):
         tup = [slice(None, None) for _ in range(self.ndim)]
@@ -877,7 +982,7 @@ class _iLocIndexer(_LocationIndexer):
 
             return self._get_loc(key,axis=axis)
 
-    def _convert_to_indexer(self, obj, axis=0):
+    def _convert_to_indexer(self, obj, axis=0, is_setter=False):
         """ much simpler as we only have to deal with our valid types """
         if self._has_valid_type(obj,axis):
             return obj
@@ -1028,6 +1133,12 @@ class _SeriesIndexer(_NDFrameIndexer):
         return self.obj._get_values(indexer)
 
     def _setitem_with_indexer(self, indexer, value):
+
+        # need to delegate to the super setter
+        if isinstance(indexer, dict):
+            return super(_SeriesIndexer, self)._setitem_with_indexer(indexer, value)
+
+        # fast access
         self.obj._set_values(indexer, value)
 
 def _check_bool_indexer(ax, key):
@@ -1053,6 +1164,21 @@ def _check_bool_indexer(ax, key):
     return result
 
 
+def _convert_missing_indexer(indexer):
+    """ reverse convert a missing indexer, which is a dict
+        return the scalar indexer and a boolean indicating if we converted """
+
+    if isinstance(indexer, dict):
+
+        # a missing key (but not a tuple indexer)
+        indexer = indexer['key']
+
+        if isinstance(indexer, bool):
+            raise KeyError("cannot use a single bool to index into setitem")
+        return indexer, True
+
+    return indexer, False
+
 def _maybe_convert_indices(indices, n):
     """ if we have negative indicies, translate to postive here
         if have indicies that are out-of-bounds, raise an IndexError """
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index c6af7e270..114b651e9 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -2647,7 +2647,7 @@ class BlockManager(PandasObject):
             if method is not None or limit is not None:
                 return self.reindex_axis0_with_method(new_axis, indexer=indexer,
                                                       method=method, fill_value=fill_value, limit=limit, copy=copy)
-            return self.reindex_items(new_axis, copy=copy, fill_value=fill_value)
+            return self.reindex_items(new_axis, indexer=indexer, copy=copy, fill_value=fill_value)
 
         new_axis, indexer = cur_axis.reindex(
             new_axis, method, copy_if_needed=True)
@@ -2709,7 +2709,7 @@ class BlockManager(PandasObject):
 
         return self.__class__(new_blocks, new_axes)
 
-    def reindex_items(self, new_items, copy=True, fill_value=None):
+    def reindex_items(self, new_items, indexer=None, copy=True, fill_value=None):
         """
 
         """
@@ -2719,8 +2719,8 @@ class BlockManager(PandasObject):
             data = data.consolidate()
             return data.reindex_items(new_items, copy=copy, fill_value=fill_value)
 
-        # TODO: this part could be faster (!)
-        new_items, indexer = self.items.reindex(new_items, copy_if_needed=True)
+        if indexer is None:
+            new_items, indexer = self.items.reindex(new_items, copy_if_needed=True)
         new_axes = [new_items] + self.axes[1:]
 
         # could have so me pathological (MultiIndex) issues here
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index d72c37991..4157d05de 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -866,9 +866,11 @@ class CheckIndexing(object):
         self.assertRaises(KeyError,
                           self.frame.ix.__setitem__,
                           (slice(None, None), ['E']), 1)
-        self.assertRaises(KeyError,
-                          self.frame.ix.__setitem__,
-                          (slice(None, None), 'E'), 1)
+
+        # partial setting now allows this GH2578
+        #self.assertRaises(KeyError,
+        #                  self.frame.ix.__setitem__,
+        #                  (slice(None, None), 'E'), 1)
 
     def test_setitem_fancy_mixed_2d(self):
         self.mixed_frame.ix[:5, ['C', 'B', 'A']] = 5
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index da4e1e98e..42f98e830 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -1229,6 +1229,77 @@ class TestIndexing(unittest.TestCase):
         result = df.loc[1]
         assert_series_equal(result,expected)
 
+    def test_partial_setting(self):
+
+        # GH2578, allow ix and friends to partially set
+
+        ### frame ###
+
+        df_orig = DataFrame(np.arange(6).reshape(3,2),columns=['A','B'])
+
+        # row setting where it exists
+        expected = DataFrame(dict({ 'A' : [0,4,4], 'B' : [1,5,5] }))
+        df = df_orig.copy()
+        df.iloc[1] = df.iloc[2]
+        assert_frame_equal(df,expected)
+
+        expected = DataFrame(dict({ 'A' : [0,4,4], 'B' : [1,5,5] }))
+        df = df_orig.copy()
+        df.loc[1] = df.loc[2]
+        assert_frame_equal(df,expected)
+
+        expected = DataFrame(dict({ 'A' : [0,2,4,4], 'B' : [1,3,5,5] }),dtype='float64')
+        df = df_orig.copy()
+        df.loc[3] = df.loc[2]
+        assert_frame_equal(df,expected)
+
+        # single dtype frame, overwrite
+        expected = DataFrame(dict({ 'A' : [0,2,4], 'B' : [0,2,4] }))
+        df = df_orig.copy()
+        df.ix[:,'B'] = df.ix[:,'A']
+        assert_frame_equal(df,expected)
+
+        # mixed dtype frame, overwrite
+        expected = DataFrame(dict({ 'A' : [0,2,4], 'B' : Series([0.,2.,4.]) }))
+        df = df_orig.copy()
+        df['B'] = df['B'].astype(np.float64)
+        df.ix[:,'B'] = df.ix[:,'A']
+        assert_frame_equal(df,expected)
+
+        # single dtype frame, partial setting
+        expected = df_orig.copy()
+        expected['C'] = df['A'].astype(np.float64)
+        df = df_orig.copy()
+        df.ix[:,'C'] = df.ix[:,'A']
+        assert_frame_equal(df,expected)
+
+        # mixed frame, partial setting
+        expected = df_orig.copy()
+        expected['C'] = df['A'].astype(np.float64)
+        df = df_orig.copy()
+        df.ix[:,'C'] = df.ix[:,'A']
+        assert_frame_equal(df,expected)
+
+        ### panel ###
+        p_orig = Panel(np.arange(16).reshape(2,4,2),items=['Item1','Item2'],major_axis=pd.date_range('2001/1/12',periods=4),minor_axis=['A','B'],dtype='float64')
+
+        # panel setting via item
+        p_orig = Panel(np.arange(16).reshape(2,4,2),items=['Item1','Item2'],major_axis=pd.date_range('2001/1/12',periods=4),minor_axis=['A','B'],dtype='float64')
+        expected = p_orig.copy()
+        expected['Item3'] = expected['Item1']
+        p = p_orig.copy()
+        p.loc['Item3'] = p['Item1']
+        assert_panel_equal(p,expected)
+
+        # panel with aligned series
+        expected = p_orig.copy()
+        expected = expected.transpose(2,1,0)
+        expected['C'] = DataFrame({ 'Item1' : [30,30,30,30], 'Item2' : [32,32,32,32] },index=p_orig.major_axis)
+        expected = expected.transpose(2,1,0)
+        p = p_orig.copy()
+        p.loc[:,:,'C'] = Series([30,32],index=p_orig.items)
+        assert_panel_equal(p,expected)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index b2849aeb2..882638903 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -851,8 +851,17 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
 
     def test_setitem_ambiguous_keyerror(self):
         s = Series(lrange(10), index=lrange(0, 20, 2))
-        self.assertRaises(KeyError, s.__setitem__, 1, 5)
-        self.assertRaises(KeyError, s.ix.__setitem__, 1, 5)
+
+        # equivalent of an append
+        s2 = s.copy()
+        s2[1] = 5
+        expected = s.append(Series([5],index=[1]))
+        assert_series_equal(s2,expected)
+
+        s2 = s.copy()
+        s2.ix[1] = 5
+        expected = s.append(Series([5],index=[1]))
+        assert_series_equal(s2,expected)
 
     def test_setitem_float_labels(self):
         # note labels are floats
@@ -954,8 +963,10 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assert_((series[::2] == 0).all())
 
         # set item that's not contained
-        self.assertRaises(Exception, self.series.__setitem__,
-                          'foobar', 1)
+        s = self.series.copy()
+        s['foobar'] = 1
+        expected = self.series.append(Series([1],index=['foobar']))
+        assert_series_equal(s,expected)
 
     def test_setitem_dtypes(self):
 
@@ -4719,33 +4730,26 @@ class TestSeriesNonUnique(unittest.TestCase):
         self.assertRaises(IndexError, s.__setitem__, 5, 0)
 
         self.assertRaises(KeyError, s.__getitem__, 'c')
-        self.assertRaises(KeyError, s.__setitem__, 'c', 0)
 
         s = s.sort_index()
 
         self.assertRaises(IndexError, s.__getitem__, 5)
         self.assertRaises(IndexError, s.__setitem__, 5, 0)
 
-        self.assertRaises(KeyError, s.__getitem__, 'c')
-        self.assertRaises(KeyError, s.__setitem__, 'c', 0)
 
     def test_int_indexing(self):
         s = Series(np.random.randn(6), index=[0, 0, 1, 1, 2, 2])
 
         self.assertRaises(KeyError, s.__getitem__, 5)
-        self.assertRaises(KeyError, s.__setitem__, 5, 0)
 
         self.assertRaises(KeyError, s.__getitem__, 'c')
-        self.assertRaises(KeyError, s.__setitem__, 'c', 0)
 
         # not monotonic
         s = Series(np.random.randn(6), index=[2, 2, 0, 0, 1, 1])
 
         self.assertRaises(KeyError, s.__getitem__, 5)
-        self.assertRaises(KeyError, s.__setitem__, 5, 0)
 
         self.assertRaises(KeyError, s.__getitem__, 'c')
-        self.assertRaises(KeyError, s.__setitem__, 'c', 0)
 
     def test_datetime_indexing(self):
         from pandas import date_range

commit 9dc63de82d2f17be5d7c639a9df42eb00508c039
Author: Jeffrey Tratner <jeffrey.tratner@gmail.com>
Date:   Sun Jun 16 13:44:19 2013 -0400

    CLN: pandas/sparse: replace bare exceptions
    
    Replace with more descriptive exceptions
    
    CLN: SparsePanel: replace bare exceptions
    
    CLN: SparseFrame: change bare exceptions
    
    CLN: SparseSeries: change bare exceptions
    
    CLN: SparseArray: change bare exceptions
    
    Harmonize capitalization of SparseArray IndexErrors
    
    Added note about possible unreachable code fragment
    
    TST: Add test cases for SparseArray
    
    TST: Add SparseFrame test cases for the improved exceptions

diff --git a/pandas/sparse/array.py b/pandas/sparse/array.py
index 035db2790..de510aa15 100644
--- a/pandas/sparse/array.py
+++ b/pandas/sparse/array.py
@@ -261,7 +261,7 @@ to sparse
             loc += n
 
         if loc >= len(self) or loc < 0:
-            raise Exception('Out of bounds access')
+            raise IndexError('out of bounds access')
 
         sp_loc = self.sp_index.lookup(loc)
         if sp_loc == -1:
@@ -283,7 +283,7 @@ to sparse
 
         n = len(self)
         if (indices < 0).any() or (indices >= n).any():
-            raise Exception('out of bounds access')
+            raise IndexError('out of bounds access')
 
         if self.sp_index.npoints > 0:
             locs = np.array([self.sp_index.lookup(loc) for loc in indices])
@@ -296,10 +296,10 @@ to sparse
         return result
 
     def __setitem__(self, key, value):
-        raise Exception('SparseArray objects are immutable')
+        raise TypeError('%r object does not support item assignment' % self.__class__.__name__)
 
     def __setslice__(self, i, j, value):
-        raise Exception('SparseArray objects are immutable')
+        raise TypeError('%r object does not support item assignment' % self.__class__.__name__)
 
     def to_dense(self):
         """
@@ -313,7 +313,7 @@ to sparse
         """
         dtype = np.dtype(dtype)
         if dtype is not None and dtype not in (np.float_, float):
-            raise Exception('Can only support floating point data for now')
+            raise TypeError('Can only support floating point data for now')
         return self.copy()
 
     def copy(self, deep=True):
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index 9694cc005..0a08fba49 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -195,10 +195,10 @@ class SparseDataFrame(DataFrame):
             columns = _default_index(K)
 
         if len(columns) != K:
-            raise Exception('Column length mismatch: %d vs. %d' %
+            raise ValueError('Column length mismatch: %d vs. %d' %
                             (len(columns), K))
         if len(index) != N:
-            raise Exception('Index length mismatch: %d vs. %d' %
+            raise ValueError('Index length mismatch: %d vs. %d' %
                             (len(index), N))
 
         data = dict([(idx, data[:, i]) for i, idx in enumerate(columns)])
@@ -585,7 +585,7 @@ class SparseDataFrame(DataFrame):
     def _reindex_index(self, index, method, copy, level, fill_value=np.nan,
                        limit=None):
         if level is not None:
-            raise Exception('Reindex by level not supported for sparse')
+            raise TypeError('Reindex by level not supported for sparse')
 
         if self.index.equals(index):
             if copy:
@@ -616,7 +616,7 @@ class SparseDataFrame(DataFrame):
 
     def _reindex_columns(self, columns, copy, level, fill_value, limit=None):
         if level is not None:
-            raise Exception('Reindex by level not supported for sparse')
+            raise TypeError('Reindex by level not supported for sparse')
 
         if com.notnull(fill_value):
             raise NotImplementedError
@@ -889,9 +889,12 @@ def stack_sparse_frame(frame):
 
     inds_to_concat = []
     vals_to_concat = []
+    # TODO: Figure out whether this can be reached.
+    # I think this currently can't be reached because you can't build a SparseDataFrame
+    # with a non-np.NaN fill value (fails earlier).
     for _, series in frame.iteritems():
         if not np.isnan(series.fill_value):
-            raise Exception('This routine assumes NaN fill value')
+            raise TypeError('This routine assumes NaN fill value')
 
         int_index = series.sp_index.to_int_index()
         inds_to_concat.append(int_index.indices)
@@ -931,7 +934,7 @@ def homogenize(series_dict):
 
     for _, series in series_dict.iteritems():
         if not np.isnan(series.fill_value):
-            raise Exception('this method is only valid with NaN fill values')
+            raise TypeError('this method is only valid with NaN fill values')
 
         if index is None:
             index = series.sp_index
diff --git a/pandas/sparse/panel.py b/pandas/sparse/panel.py
index 0b2842155..246e6fa93 100644
--- a/pandas/sparse/panel.py
+++ b/pandas/sparse/panel.py
@@ -249,7 +249,7 @@ class SparsePanel(Panel):
         frame : DataFrame
         """
         if not filter_observations:
-            raise Exception('filter_observations=False not supported for '
+            raise TypeError('filter_observations=False not supported for '
                             'SparsePanel.to_long')
 
         I, N, K = self.shape
@@ -325,7 +325,7 @@ class SparsePanel(Panel):
                 if item in self._frames:
                     new_frames[item] = self._frames[item]
                 else:
-                    raise Exception('Reindexing with new items not yet '
+                    raise NotImplementedError('Reindexing with new items not yet '
                                     'supported')
         else:
             new_frames = self._frames
@@ -488,7 +488,7 @@ def _stack_sparse_info(frame):
         series = frame[col]
 
         if not np.isnan(series.fill_value):
-            raise Exception('This routine assumes NaN fill value')
+            raise TypeError('This routine assumes NaN fill value')
 
         int_index = series.sp_index.to_int_index()
         inds_to_concat.append(int_index.indices)
diff --git a/pandas/sparse/series.py b/pandas/sparse/series.py
index bd01845a2..1b8d3541d 100644
--- a/pandas/sparse/series.py
+++ b/pandas/sparse/series.py
@@ -133,7 +133,7 @@ class SparseSeries(SparseArray, Series):
                     raise AssertionError()
         else:
             if index is None:
-                raise Exception('must pass index!')
+                raise TypeError('must pass index!')
 
             length = len(index)
 
@@ -388,7 +388,7 @@ class SparseSeries(SparseArray, Series):
 
         """
         if dtype is not None and dtype not in (np.float_, float):
-            raise Exception('Can only support floating point data')
+            raise TypeError('Can only support floating point data')
 
         return self.copy()
 
diff --git a/pandas/sparse/tests/test_array.py b/pandas/sparse/tests/test_array.py
index cf2cd2f68..a92170621 100644
--- a/pandas/sparse/tests/test_array.py
+++ b/pandas/sparse/tests/test_array.py
@@ -1,3 +1,4 @@
+import re
 from numpy import nan, ndarray
 import numpy as np
 
@@ -8,7 +9,7 @@ import unittest
 from pandas.core.series import Series
 from pandas.core.common import notnull
 from pandas.sparse.api import SparseArray
-from pandas.util.testing import assert_almost_equal
+from pandas.util.testing import assert_almost_equal, assertRaisesRegexp
 
 
 def assert_sp_array_equal(left, right):
@@ -28,6 +29,24 @@ class TestSparseArray(unittest.TestCase):
         self.arr = SparseArray(self.arr_data)
         self.zarr = SparseArray([0, 0, 1, 2, 3, 0, 4, 5, 0, 6], fill_value=0)
 
+    def test_get_item(self):
+        errmsg = re.compile("bounds")
+        assertRaisesRegexp(IndexError, errmsg, lambda : self.arr[11])
+        assertRaisesRegexp(IndexError, errmsg, lambda : self.arr[-11])
+        self.assertEqual(self.arr[-1], self.arr[len(self.arr) - 1])
+
+    def test_bad_take(self):
+        assertRaisesRegexp(IndexError, "bounds", lambda : self.arr.take(11))
+        self.assertRaises(IndexError, lambda : self.arr.take(-11))
+
+    def test_set_item(self):
+        def setitem():
+            self.arr[5] = 3
+        def setslice():
+            self.arr[1:5] = 2
+        assertRaisesRegexp(TypeError, "item assignment", setitem)
+        assertRaisesRegexp(TypeError, "item assignment", setslice)
+
     def test_constructor_from_sparse(self):
         res = SparseArray(self.zarr)
         self.assertEquals(res.fill_value, 0)
@@ -47,7 +66,7 @@ class TestSparseArray(unittest.TestCase):
         res.sp_values[:3] = 27
         self.assert_(not (self.arr.sp_values[:3] == 27).any())
 
-        self.assertRaises(Exception, self.arr.astype, 'i8')
+        assertRaisesRegexp(TypeError, "floating point", self.arr.astype, 'i8')
 
     def test_copy_shallow(self):
         arr2 = self.arr.copy(deep=False)
diff --git a/pandas/sparse/tests/test_sparse.py b/pandas/sparse/tests/test_sparse.py
index c6515cd41..1382a6a64 100644
--- a/pandas/sparse/tests/test_sparse.py
+++ b/pandas/sparse/tests/test_sparse.py
@@ -13,7 +13,7 @@ import pandas as pd
 dec = np.testing.dec
 
 from pandas.util.testing import (assert_almost_equal, assert_series_equal,
-                                 assert_frame_equal, assert_panel_equal)
+                                 assert_frame_equal, assert_panel_equal, assertRaisesRegexp)
 from numpy.testing import assert_equal
 
 from pandas import Series, DataFrame, bdate_range, Panel
@@ -641,7 +641,7 @@ class TestSparseSeries(TestCase,
         # must have NaN fill value
         data = {'a': SparseSeries(np.arange(7), sparse_index=expected2,
                                   fill_value=0)}
-        nose.tools.assert_raises(Exception, spf.homogenize, data)
+        assertRaisesRegexp(TypeError, "NaN fill value", spf.homogenize, data)
 
     def test_fill_value_corner(self):
         cop = self.zbseries.copy()
@@ -791,7 +791,7 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         assert_sp_frame_equal(cons, reindexed)
 
         # assert level parameter breaks reindex
-        self.assertRaises(Exception, self.frame.reindex, idx, level=0)
+        self.assertRaises(TypeError, self.frame.reindex, idx, level=0)
 
         repr(self.frame)
 
@@ -805,14 +805,14 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         assert_sp_frame_equal(sp, self.frame.reindex(columns=['A']))
 
         # raise on level argument
-        self.assertRaises(Exception, self.frame.reindex, columns=['A'],
+        self.assertRaises(TypeError, self.frame.reindex, columns=['A'],
                           level=1)
 
         # wrong length index / columns
-        self.assertRaises(Exception, SparseDataFrame, self.frame.values,
-                          index=self.frame.index[:-1])
-        self.assertRaises(Exception, SparseDataFrame, self.frame.values,
-                          columns=self.frame.columns[:-1])
+        assertRaisesRegexp(ValueError, "^Index length", SparseDataFrame, self.frame.values,
+                           index=self.frame.index[:-1])
+        assertRaisesRegexp(ValueError, "^Column length", SparseDataFrame, self.frame.values,
+                           columns=self.frame.columns[:-1])
 
     def test_constructor_empty(self):
         sp = SparseDataFrame()
@@ -840,11 +840,17 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
 
         x = Series(np.random.randn(10000), name ='a')
         y = Series(np.random.randn(10000), name ='b')
-        x.ix[:9998] = 0
-        x = x.to_sparse(fill_value=0)
+        x2 = x.astype(float)
+        x2.ix[:9998] = np.NaN
+        x_sparse = x2.to_sparse(fill_value=np.NaN)
         
-        # currently fails
-        #df1 = SparseDataFrame([x, y])
+        # Currently fails too with weird ufunc error
+        # df1 = SparseDataFrame([x_sparse, y])
+
+        y.ix[:9998] = 0
+        y_sparse = y.to_sparse(fill_value=0)
+        # without sparse value raises error
+        # df2 = SparseDataFrame([x2_sparse, y])
 
     def test_dtypes(self):
         df = DataFrame(np.random.randn(10000, 4))

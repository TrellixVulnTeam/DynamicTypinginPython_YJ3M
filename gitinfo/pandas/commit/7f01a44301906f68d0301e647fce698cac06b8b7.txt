commit 7f01a44301906f68d0301e647fce698cac06b8b7
Author: Chang She <chang@lambdafoundry.com>
Date:   Thu Jul 12 11:09:37 2012 -0400

    removed bad exception handling in parse_time_string

diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index bdfb443a9..b60c219bc 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -143,81 +143,83 @@ def parse_time_string(arg, freq=None):
         return arg
 
     arg = arg.upper()
-    try:
-        default = datetime(1,1,1).replace(hour=0, minute=0,
-                                          second=0, microsecond=0)
-
-        # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
-        if len(arg) in [4, 6]:
-            add_century = False
-            if len(arg) == 4:
-                add_century = True
-                qpats = [(qpat1, 1), (qpat2, 0)]
-            else:
-                qpats = [(qpat1full, 1), (qpat2full, 0)]
-
-            for pat, yfirst in qpats:
-                qparse = pat.match(arg)
-                if qparse is not None:
-                    if yfirst:
-                        yi, qi = 1, 2
-                    else:
-                        yi, qi = 2, 1
-                    q = int(qparse.group(yi))
-                    y_str = qparse.group(qi)
-                    y = int(y_str)
-                    if add_century:
-                        y += 2000
-
-                    if freq is not None:
-                        # hack attack, #1228
-                        mnum = _month_numbers[_get_rule_month(freq)] + 1
-                        month = (mnum + (q - 1) * 3) % 12 + 1
-                        if month > mnum:
-                            y -= 1
-                    else:
-                        month = (q - 1) * 3 + 1
-
-                    ret = default.replace(year=y, month=month)
-                    return ret, ret, 'quarter'
-
-            is_mo_str = freq is not None and freq == 'M'
-            is_mo_off = getattr(freq, 'rule_code', None) == 'M'
-            is_monthly = is_mo_str or is_mo_off
-            if len(arg) == 6 and is_monthly:
-                try:
-                    ret = _try_parse_monthly(arg)
-                    if ret is not None:
-                        return ret, ret, 'month'
-                except Exception:
-                    pass
-
-        dayfirst = print_config.date_dayfirst
-        yearfirst = print_config.date_yearfirst
 
+    default = datetime(1,1,1).replace(hour=0, minute=0,
+                                      second=0, microsecond=0)
+
+    # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
+    if len(arg) in [4, 6]:
+        add_century = False
+        if len(arg) == 4:
+            add_century = True
+            qpats = [(qpat1, 1), (qpat2, 0)]
+        else:
+            qpats = [(qpat1full, 1), (qpat2full, 0)]
+
+        for pat, yfirst in qpats:
+            qparse = pat.match(arg)
+            if qparse is not None:
+                if yfirst:
+                    yi, qi = 1, 2
+                else:
+                    yi, qi = 2, 1
+                q = int(qparse.group(yi))
+                y_str = qparse.group(qi)
+                y = int(y_str)
+                if add_century:
+                    y += 2000
+
+                if freq is not None:
+                    # hack attack, #1228
+                    mnum = _month_numbers[_get_rule_month(freq)] + 1
+                    month = (mnum + (q - 1) * 3) % 12 + 1
+                    if month > mnum:
+                        y -= 1
+                else:
+                    month = (q - 1) * 3 + 1
+
+                ret = default.replace(year=y, month=month)
+                return ret, ret, 'quarter'
+
+        is_mo_str = freq is not None and freq == 'M'
+        is_mo_off = getattr(freq, 'rule_code', None) == 'M'
+        is_monthly = is_mo_str or is_mo_off
+        if len(arg) == 6 and is_monthly:
+            try:
+                ret = _try_parse_monthly(arg)
+                if ret is not None:
+                    return ret, ret, 'month'
+            except Exception:
+                pass
+
+    dayfirst = print_config.date_dayfirst
+    yearfirst = print_config.date_yearfirst
+
+    try:
         parsed = _dtparser._parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
-        if parsed is None:
-            raise DateParseError("Could not parse %s" % arg)
-
-        repl = {}
-        reso = 'year'
-        stopped = False
-        for attr in ["year", "month", "day", "hour",
-                     "minute", "second", "microsecond"]:
-            can_be_zero = ['hour', 'minute', 'second', 'microsecond']
-            value = getattr(parsed, attr)
-            if value is not None and value != 0: # or attr in can_be_zero):
-                repl[attr] = value
-                if not stopped:
-                    reso = attr
-            else:
-                stopped = True
-                break
-        ret = default.replace(**repl)
-        return ret, parsed, reso  # datetime, resolution
     except Exception, e:
         raise DateParseError(e)
 
+    if parsed is None:
+        raise DateParseError("Could not parse %s" % arg)
+
+    repl = {}
+    reso = 'year'
+    stopped = False
+    for attr in ["year", "month", "day", "hour",
+                 "minute", "second", "microsecond"]:
+        can_be_zero = ['hour', 'minute', 'second', 'microsecond']
+        value = getattr(parsed, attr)
+        if value is not None and value != 0: # or attr in can_be_zero):
+            repl[attr] = value
+            if not stopped:
+                reso = attr
+        else:
+            stopped = True
+            break
+    ret = default.replace(**repl)
+    return ret, parsed, reso  # datetime, resolution
+
 def _try_parse_monthly(arg):
     base = 2000
     add_base = False

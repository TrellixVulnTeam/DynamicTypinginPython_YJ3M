commit 9874d62fbc6fd05880a2258e7290c6b6ba815fd6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Sep 2 11:35:10 2012 -0400

    ENH: adding option to skip (and maybe warn about) bad lines

diff --git a/pandas/io/tests/test_cparser.py b/pandas/io/tests/test_cparser.py
index 8351f05dd..084ccb20f 100644
--- a/pandas/io/tests/test_cparser.py
+++ b/pandas/io/tests/test_cparser.py
@@ -27,6 +27,7 @@ from pandas.lib import Timestamp
 
 import pandas.util.testing as tm
 
+from pandas._parser import TextReader
 import pandas._parser as parser
 
 
@@ -43,13 +44,13 @@ class TestCParser(unittest.TestCase):
         self.xls1 = os.path.join(self.dirpath, 'test.xls')
 
     def test_string_filename(self):
-        reader = parser.TextReader(self.csv1)
+        reader = TextReader(self.csv1)
         result = reader.read()
 
     def test_file_handle(self):
         try:
             f = open(self.csv1, 'rb')
-            reader = parser.TextReader(f)
+            reader = TextReader(f)
             result = reader.read()
         finally:
             f.close()
@@ -57,20 +58,20 @@ class TestCParser(unittest.TestCase):
     def test_file_handle_mmap(self):
         try:
             f = open(self.csv1, 'rb')
-            reader = parser.TextReader(f, memory_map=True)
+            reader = TextReader(f, memory_map=True)
             result = reader.read()
         finally:
             f.close()
 
     def test_StringIO(self):
         text = open(self.csv1, 'rb').read()
-        reader = parser.TextReader(BytesIO(text))
+        reader = TextReader(BytesIO(text))
         result = reader.read()
 
     def test_string_factorize(self):
         # should this be optional?
         data = 'a\nb\na\nb\na'
-        reader = parser.TextReader(StringIO(data))
+        reader = TextReader(StringIO(data))
         result = reader.read()
         self.assert_(len(set(map(id, result[0]))) == 2)
 
@@ -80,7 +81,7 @@ class TestCParser(unittest.TestCase):
                 'a,   b\n'
                 'a,   b')
 
-        reader = parser.TextReader(StringIO(data), skipinitialspace=True)
+        reader = TextReader(StringIO(data), skipinitialspace=True)
         result = reader.read()
 
         self.assert_(np.array_equal(result[0], ['a', 'a', 'a', 'a']))
@@ -89,7 +90,7 @@ class TestCParser(unittest.TestCase):
     def test_parse_booleans(self):
         data = 'True\nFalse\nTrue\nTrue'
 
-        reader = parser.TextReader(StringIO(data))
+        reader = TextReader(StringIO(data))
         result = reader.read()
 
         self.assert_(result[0].dtype == np.bool_)
@@ -97,7 +98,7 @@ class TestCParser(unittest.TestCase):
     def test_delimit_whitespace(self):
         data = 'a  b\na\t\t "b"\n"a"\t \t b'
 
-        reader = parser.TextReader(StringIO(data), delim_whitespace=True)
+        reader = TextReader(StringIO(data), delim_whitespace=True)
         result = reader.read()
 
         self.assert_(np.array_equal(result[0], ['a', 'a', 'a']))
@@ -106,7 +107,7 @@ class TestCParser(unittest.TestCase):
     def test_embedded_newline(self):
         data = 'a\n"hello\nthere"\nthis'
 
-        reader = parser.TextReader(StringIO(data))
+        reader = TextReader(StringIO(data))
         result = reader.read()
 
         expected = ['a', 'hello\nthere', 'this']
@@ -115,7 +116,7 @@ class TestCParser(unittest.TestCase):
     def test_euro_decimal(self):
         data = '12345,67\n345,678'
 
-        reader = parser.TextReader(StringIO(data), delimiter=':',
+        reader = TextReader(StringIO(data), delimiter=':',
                                    decimal=',')
         result = reader.read()
 
@@ -125,16 +126,43 @@ class TestCParser(unittest.TestCase):
     def test_integer_thousands(self):
         data = '123,456\n12,500'
 
-        reader = parser.TextReader(StringIO(data), delimiter=':',
+        reader = TextReader(StringIO(data), delimiter=':',
                                    thousands=',')
         result = reader.read()
 
         expected = [123456, 12500]
         tm.assert_almost_equal(result[0], expected)
 
+    def test_skip_bad_lines(self):
+        data = ('a:b:c\n'
+                'd:e:f\n'
+                'g:h:i\n'
+                'j:k\n'
+                'l:m:n')
+
+        reader = TextReader(StringIO(data), delimiter=':')
+        self.assertRaises(parser.CParserError, reader.read)
+
+        reader = TextReader(StringIO(data), delimiter=':',
+                            error_bad_lines=False,
+                            warn_bad_lines=False)
+        result = reader.read()
+        expected = {0: ['a', 'd', 'g', 'l'],
+                    1: ['b', 'e', 'h', 'm'],
+                    2: ['c', 'f', 'i', 'n']}
+        assert_array_dicts_equal(result, expected)
+
+    def test_eof_has_eol(self):
+        # handling of new line at EOF
+        pass
+
     def test_na_substitution(self):
         pass
 
+def assert_array_dicts_equal(left, right):
+    for k, v in left.iteritems():
+        assert(np.array_equal(v, right[k]))
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index 690ad114c..e5f12d577 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -92,6 +92,7 @@ cdef extern from "parser/parser.h":
         int *line_start      # position in words for start of line
         int *line_fields     # Number of fields in each line
         int lines            # Number of lines observed
+        int file_lines       # Number of file lines observed (with bad/skipped)
         int lines_cap        # Vector capacity
 
         # Tokenizing stuff
@@ -134,8 +135,6 @@ cdef extern from "parser/parser.h":
         void **columns
         int ncols
 
-        # PyObject *converters
-
         #  error handling
         char *error_msg
 
@@ -200,6 +199,8 @@ cdef class TextReader:
                   as_recarray=False,
                   skipinitialspace=False,
                   decimal=b'.',
+                  error_bad_lines=True,
+                  warn_bad_lines=True,
                   na_filter=True):
         self.parser = parser_new()
         self.parser.chunksize = tokenize_chunksize
@@ -231,6 +232,10 @@ cdef class TextReader:
                 raise ValueError('Only length-1 decimal markers supported')
             self.parser.thousands = ord(thousands)
 
+        # error handling of bad lines
+        self.parser.error_bad_lines = int(error_bad_lines)
+        self.parser.warn_bad_lines = int(warn_bad_lines)
+
         self.should_close = False
 
         self.delimiter = delimiter
diff --git a/pandas/src/parser/parser.c b/pandas/src/parser/parser.c
index 409c35fbb..1b3253ef2 100644
--- a/pandas/src/parser/parser.c
+++ b/pandas/src/parser/parser.c
@@ -1,6 +1,7 @@
  /*
-   Low-level ascii-file processing for pandas. Combines elements from Python's
-   built-in csv module and Warren Weckesser's textreader project on GitHub
+   Low-level ascii-file processing for pandas. Combines some elements from
+   Python's built-in csv module and Warren Weckesser's textreader project on
+   GitHub
 
    See Python Software Foundation License and BSD licenses
 
@@ -497,692 +498,721 @@ coliter_t *coliter_new(parser_t *self, int i) {
  /* } */
 
 
- int merge_chunks(parser_t *parser) {
-     int i, j, ncols;
+int merge_chunks(parser_t *parser) {
+    int i, j, ncols;
 
-     // Get a consensus on number of columns and check types
-     for (i = 0; i < parser->nchunks; ++i)
-     {
-         if (i == 0) {
-             ncols = parser->chunks[i].ncols;
-         } else {
-             // XXX this should not happen
-             if (ncols != parser->chunks[i].ncols) {
-                 return -1;
-             }
-         }
-     }
+    // Get a consensus on number of columns and check types
+    for (i = 0; i < parser->nchunks; ++i)
+    {
+        if (i == 0) {
+            ncols = parser->chunks[i].ncols;
+        } else {
+            // XXX this should not happen
+            if (ncols != parser->chunks[i].ncols) {
+                return -1;
+            }
+        }
+    }
 
-     for (i = 0; i < parser->nchunks; ++i)
-     {
-         for (j = 0; j < ncols; ++j)
-         {
-             return -1;
-         }
-     }
+    for (i = 0; i < parser->nchunks; ++i)
+    {
+        for (j = 0; j < ncols; ++j)
+        {
+            return -1;
+        }
+    }
 
-     return 0;
- }
+    return 0;
+}
 
- int _try_int64(parser_t *parser, array_t *arr, char** strings, size_t length) {
-     int i, error;
-     int64_t *data;
+int _try_int64(parser_t *parser, array_t *arr, char** strings, size_t length) {
+    int i, error;
+    int64_t *data;
 
-     arr->data = malloc(length * sizeof(int64_t));
-     data = (int64_t*) arr->data;
+    arr->data = malloc(length * sizeof(int64_t));
+    data = (int64_t*) arr->data;
 
-     for (i = 0; i < length; ++i)
-     {
-         *data++ = (int64_t) str_to_int64(strings[i], INT64_MIN,
-                                          INT64_MAX, &error,
-                                          parser->thousands);
+    for (i = 0; i < length; ++i)
+    {
+        *data++ = (int64_t) str_to_int64(strings[i], INT64_MIN,
+                                         INT64_MAX, &error,
+                                         parser->thousands);
 
-         if (error != 0) {
-             return -1;
-         }
-     }
+        if (error != 0) {
+            return -1;
+        }
+    }
 
-     return 0;
- }
+    return 0;
+}
 
- int _try_float(parser_t *parser, array_t* arr, char** strings, size_t length) {
-     int i, error;
-     double *data;
+int _try_float(parser_t *parser, array_t* arr, char** strings, size_t length) {
+    int i, error;
+    double *data;
 
-     arr->data = malloc(length * sizeof(double));
-     data = (double*) arr->data;
+    arr->data = malloc(length * sizeof(double));
+    data = (double*) arr->data;
 
-     for (i = 0; i < length; ++i)
-     {
-         error = to_double(strings[i], data, parser->sci, parser->decimal);
+    for (i = 0; i < length; ++i)
+    {
+        error = to_double(strings[i], data, parser->sci, parser->decimal);
 
-         if (error != 1) {
-             return -1;
-         }
-     }
+        if (error != 1) {
+            return -1;
+        }
+    }
 
-     return 0;
- }
+    return 0;
+}
 
 
- int _try_boolean(parser_t *parser, array_t* arr, char** strings, size_t length) {
-     int i, error;
-     uint8_t *data;
+int _try_boolean(parser_t *parser, array_t* arr, char** strings, size_t length) {
+    int i, error;
+    uint8_t *data;
 
-     arr->data = malloc(length * sizeof(uint8_t));
-     data = (uint8_t*) arr->data;
+    arr->data = malloc(length * sizeof(uint8_t));
+    data = (uint8_t*) arr->data;
 
-     for (i = 0; i < length; ++i)
-     {
-         error = to_boolean(strings[i], data);
+    for (i = 0; i < length; ++i)
+    {
+        error = to_boolean(strings[i], data);
 
-         if (error != 1) {
-             return -1;
-         }
-     }
+        if (error != 1) {
+            return -1;
+        }
+    }
 
-     return 0;
- }
+    return 0;
+}
 
- typedef int (*cast_func)(parser_t *parser, array_t* arr,
-                          char** strings, size_t length);
+typedef int (*cast_func)(parser_t *parser, array_t* arr,
+                         char** strings, size_t length);
 
- static cast_func _inference_order[3] = {_try_int64, _try_float, _try_boolean};
+static cast_func _inference_order[3] = {_try_int64, _try_float, _try_boolean};
 
- int convert_infer(parser_t *parser, array_t* result,
-                   char** strings, size_t length) {
+int convert_infer(parser_t *parser, array_t* result,
+                  char** strings, size_t length) {
 
-     int i, status;
-     /* array_t* result = (array_t*) malloc(sizeof(array_t*)); */
+    int i, status;
+    /* array_t* result = (array_t*) malloc(sizeof(array_t*)); */
 
-     for (i = 0; i < sizeof(_inference_order); ++i)
-     {
-         status = _inference_order[i](parser, result, strings, length);
+    for (i = 0; i < sizeof(_inference_order); ++i)
+    {
+        status = _inference_order[i](parser, result, strings, length);
 
-         if (status == 0) {
-             // success
-             return 0;
-         }
-     }
+        if (status == 0) {
+            // success
+            return 0;
+        }
+    }
 
-     free(result);
+    free(result);
 
-     return 0;
- }
+    return 0;
+}
 
- // #define CHUNKSIZE 1024*1024
 
- void parser_set_default_options(parser_t *self) {
-     // parsing, type inference
-     self->infer_types = 1;
-     self->decimal = '.';
-     self->sci = 'E';
+void parser_set_default_options(parser_t *self) {
+    // parsing, type inference
+    self->infer_types = 1;
+    self->decimal = '.';
+    self->sci = 'E';
 
-     // For tokenization
-     self->state = START_RECORD;
+    // For tokenization
+    self->state = START_RECORD;
 
-     self->delimiter = ','; // XXX
-     self->delim_whitespace = 0;
+    self->delimiter = ','; // XXX
+    self->delim_whitespace = 0;
 
-     self->doublequote = 0;
-     self->quotechar = '"';
-     self->escapechar = '\\';
-     self->skipinitialspace = 0;
-     self->quoting = QUOTE_MINIMAL;
-     self->allow_embedded_newline = 1;
-     self->strict = 1;
+    self->doublequote = 0;
+    self->quotechar = '"';
+    self->escapechar = '\\';
+    self->skipinitialspace = 0;
+    self->quoting = QUOTE_MINIMAL;
+    self->allow_embedded_newline = 1;
+    self->strict = 1;
 
-     self->error_bad_lines = 0;
-     self->warn_bad_lines = 0;
+    self->error_bad_lines = 0;
+    self->warn_bad_lines = 0;
 
-     self->commentchar = '#';
-     self->thousands = '\0';
+    self->commentchar = '#';
+    self->thousands = '\0';
 
-     self->skiprows = 0;
-     self->skip_footer = 0;
- }
+    self->skiprows = 0;
+    self->skip_footer = 0;
+}
 
- int get_parser_memory_footprint(parser_t *self) {
-     return 0;
- }
+int get_parser_memory_footprint(parser_t *self) {
+    return 0;
+}
 
- parser_t* parser_new() {
-     return (parser_t*) calloc(1, sizeof(parser_t));
- }
+parser_t* parser_new() {
+    return (parser_t*) calloc(1, sizeof(parser_t));
+}
 
- int parser_file_source_init(parser_t *self, FILE* fp) {
-     self->sourcetype = 'F';
-     self->source = new_file_source(fp);
+int parser_file_source_init(parser_t *self, FILE* fp) {
+    self->sourcetype = 'F';
+    self->source = new_file_source(fp);
 
-     // Only allocate this heap memory if we are not memory-mapping the file
-     self->data = (char*) malloc((self->chunksize + 1) * sizeof(char));
+    // Only allocate this heap memory if we are not memory-mapping the file
+    self->data = (char*) malloc((self->chunksize + 1) * sizeof(char));
 
-     if (self->data == NULL) {
-         return PARSER_OUT_OF_MEMORY;
-     }
+    if (self->data == NULL) {
+        return PARSER_OUT_OF_MEMORY;
+    }
 
-     return 0;
- }
+    return 0;
+}
 
- // XXX handle on systems without the capability
+// XXX handle on systems without the capability
 
- #include <sys/stat.h>
- #include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
 
- typedef struct _memory_map {
+typedef struct _memory_map {
 
-     FILE *file;
+    FILE *file;
 
-     /* Size of the file, in bytes. */
-     off_t size;
+    /* Size of the file, in bytes. */
+    off_t size;
 
-     /* file position when the file_buffer was created. */
-     off_t initial_file_pos;
+    /* file position when the file_buffer was created. */
+    off_t initial_file_pos;
 
-     int line_number;
+    int line_number;
 
-     int fileno;
-     off_t position;
-     off_t last_pos;
-     char *memmap;
+    int fileno;
+    off_t position;
+    off_t last_pos;
+    char *memmap;
 
- } memory_map;
+} memory_map;
 
- #define MM(src) ((memory_map*) src)
+#define MM(src) ((memory_map*) src)
 
 
- /*
-  *  void *new_file_buffer(FILE *f, int buffer_size)
-  *
-  *  Allocate a new file_buffer.
-  *  Returns NULL if the memory allocation fails or if the call to mmap fails.
-  *
-  *  buffer_size is ignored.
-  */
+/*
+ *  void *new_file_buffer(FILE *f, int buffer_size)
+ *
+ *  Allocate a new file_buffer.
+ *  Returns NULL if the memory allocation fails or if the call to mmap fails.
+ *
+ *  buffer_size is ignored.
+ */
 
- void *new_mmap(FILE *f)
- {
-     struct stat buf;
-     int fd;
-     memory_map *mm;
-     off_t position;
-     off_t filesize;
-
-     fd = fileno(f);
-     if (fstat(fd, &buf) == -1) {
-         fprintf(stderr, "new_file_buffer: fstat() failed. errno =%d\n", errno);
-         return NULL;
-     }
-     filesize = buf.st_size;  /* XXX This might be 32 bits. */
+void *new_mmap(FILE *f)
+{
+    struct stat buf;
+    int fd;
+    memory_map *mm;
+    off_t position;
+    off_t filesize;
+
+    fd = fileno(f);
+    if (fstat(fd, &buf) == -1) {
+        fprintf(stderr, "new_file_buffer: fstat() failed. errno =%d\n", errno);
+        return NULL;
+    }
+    filesize = buf.st_size;  /* XXX This might be 32 bits. */
 
-     mm = (memory_map *) malloc(sizeof(memory_map));
-     if (mm == NULL) {
-         /* XXX Eventually remove this print statement. */
-         fprintf(stderr, "new_file_buffer: malloc() failed.\n");
-         return NULL;
-     }
-     mm->file = f;
-     mm->size = (off_t) filesize;
-     mm->line_number = 0;
-
-     mm->fileno = fd;
-     mm->position = ftell(f);
-     mm->last_pos = (off_t) filesize;
-
-     mm->memmap = mmap(NULL, filesize, PROT_READ, MAP_SHARED, fd, 0);
-     if (mm->memmap == NULL) {
-         /* XXX Eventually remove this print statement. */
-         fprintf(stderr, "new_file_buffer: mmap() failed.\n");
-         free(mm);
-         mm = NULL;
-     }
+    mm = (memory_map *) malloc(sizeof(memory_map));
+    if (mm == NULL) {
+        /* XXX Eventually remove this print statement. */
+        fprintf(stderr, "new_file_buffer: malloc() failed.\n");
+        return NULL;
+    }
+    mm->file = f;
+    mm->size = (off_t) filesize;
+    mm->line_number = 0;
+
+    mm->fileno = fd;
+    mm->position = ftell(f);
+    mm->last_pos = (off_t) filesize;
+
+    mm->memmap = mmap(NULL, filesize, PROT_READ, MAP_SHARED, fd, 0);
+    if (mm->memmap == NULL) {
+        /* XXX Eventually remove this print statement. */
+        fprintf(stderr, "new_file_buffer: mmap() failed.\n");
+        free(mm);
+        mm = NULL;
+    }
 
-     return (void*) mm;
- }
+    return (void*) mm;
+}
 
 
- void del_mmap(void *src)
- {
-     munmap(MM(src)->memmap, MM(src)->size);
+void del_mmap(void *src)
+{
+    munmap(MM(src)->memmap, MM(src)->size);
 
-     /*
-      *  With a memory mapped file, there is no need to do
-      *  anything if restore == RESTORE_INITIAL.
-      */
-     /* if (restore == RESTORE_FINAL) { */
-     /*     fseek(FB(fb)->file, FB(fb)->current_pos, SEEK_SET); */
-     /* } */
-     free(src);
- }
+    /*
+     *  With a memory mapped file, there is no need to do
+     *  anything if restore == RESTORE_INITIAL.
+     */
+    /* if (restore == RESTORE_FINAL) { */
+    /*     fseek(FB(fb)->file, FB(fb)->current_pos, SEEK_SET); */
+    /* } */
+    free(src);
+}
 
- int _buffer_mmap_bytes(parser_t *self, size_t nbytes) {
-     memory_map *src = MM(self->source);
+int _buffer_mmap_bytes(parser_t *self, size_t nbytes) {
+    memory_map *src = MM(self->source);
 
-     if (src->position == src->last_pos) {
-         self->datalen = 0;
-         return REACHED_EOF;
-     }
+    if (src->position == src->last_pos) {
+        self->datalen = 0;
+        return REACHED_EOF;
+    }
 
-     self->data = src->memmap + src->position;
+    self->data = src->memmap + src->position;
 
-     if (src->position + nbytes > src->last_pos) {
-         // fewer than nbytes remaining
-         self->datalen = src->last_pos - src->position;
-     } else {
-         self->datalen = nbytes;
-     }
+    if (src->position + nbytes > src->last_pos) {
+        // fewer than nbytes remaining
+        self->datalen = src->last_pos - src->position;
+    } else {
+        self->datalen = nbytes;
+    }
 
-     src->position += self->datalen;
-     return 0;
- }
+    src->position += self->datalen;
+    return 0;
+}
 
- int parser_mmap_init(parser_t *self, FILE* fp) {
-     self->sourcetype = 'M';
-     self->source = new_mmap(fp);
+int parser_mmap_init(parser_t *self, FILE* fp) {
+    self->sourcetype = 'M';
+    self->source = new_mmap(fp);
 
-     // TODO: better error message
-     if (NULL == self->source)
-         return -1;
+    // TODO: better error message
+    if (NULL == self->source)
+        return -1;
 
-     return 0;
- }
+    return 0;
+}
 
- int parser_gzip_source_init(parser_t *self, FILE* fp) {
-     return 0;
- }
+int parser_gzip_source_init(parser_t *self, FILE* fp) {
+    return 0;
+}
 
- int parser_array_source_init(parser_t *self, char *bytes, size_t length) {
-     self->sourcetype = 'A';
-     self->source = new_array_source(bytes, length);
-     return 0;
- }
+int parser_array_source_init(parser_t *self, char *bytes, size_t length) {
+    self->sourcetype = 'A';
+    self->source = new_array_source(bytes, length);
+    return 0;
+}
 
- int parser_init(parser_t *self) {
-     int sz;
+int parser_init(parser_t *self) {
+    int sz;
 
-     /*
-       Initialize data buffers
-     */
+    /*
+      Initialize data buffers
+    */
 
-     self->stream = NULL;
-     self->words = NULL;
-     self->word_starts = NULL;
-     self->line_start = NULL;
-     self->line_fields = NULL;
+    self->stream = NULL;
+    self->words = NULL;
+    self->word_starts = NULL;
+    self->line_start = NULL;
+    self->line_fields = NULL;
 
-     // token stream
-     self->stream = (char*) malloc(STREAM_INIT_SIZE * sizeof(char));
-     if (self->stream == NULL) {
-         return PARSER_OUT_OF_MEMORY;
-     }
-     self->stream_cap = STREAM_INIT_SIZE;
-     self->stream_len = 0;
+    // token stream
+    self->stream = (char*) malloc(STREAM_INIT_SIZE * sizeof(char));
+    if (self->stream == NULL) {
+        return PARSER_OUT_OF_MEMORY;
+    }
+    self->stream_cap = STREAM_INIT_SIZE;
+    self->stream_len = 0;
 
-     // word pointers and metadata
-     sz = STREAM_INIT_SIZE / 10;
-     sz = sz? sz : 1;
-     self->words = (char**) malloc(sz * sizeof(char*));
-     self->word_starts = (int*) malloc(sz * sizeof(int));
-     self->words_cap = sz;
-     self->words_len = 0;
+    // word pointers and metadata
+    sz = STREAM_INIT_SIZE / 10;
+    sz = sz? sz : 1;
+    self->words = (char**) malloc(sz * sizeof(char*));
+    self->word_starts = (int*) malloc(sz * sizeof(int));
+    self->words_cap = sz;
+    self->words_len = 0;
 
-     // line pointers and metadata
-     self->line_start = (int*) malloc(sz * sizeof(int));
+    // line pointers and metadata
+    self->line_start = (int*) malloc(sz * sizeof(int));
 
-     self->line_fields = (int*) malloc(sz * sizeof(int));
+    self->line_fields = (int*) malloc(sz * sizeof(int));
 
-     self->lines_cap = sz;
-     self->lines = 0;
+    self->lines_cap = sz;
+    self->lines = 0;
+    self->file_lines = 0;
 
-     if (self->stream == NULL || self->words == NULL ||
-         self->word_starts == NULL || self->line_start == NULL ||
-         self->line_fields == NULL) {
+    if (self->stream == NULL || self->words == NULL ||
+        self->word_starts == NULL || self->line_start == NULL ||
+        self->line_fields == NULL) {
 
-         parser_cleanup(self);
+        parser_cleanup(self);
 
-         return PARSER_OUT_OF_MEMORY;
-     }
+        return PARSER_OUT_OF_MEMORY;
+    }
 
-     self->line_fields[0] = 0;
+    self->line_start[0] = 0;
+    self->line_fields[0] = 0;
 
-     self->pword_start = self->stream;
-     self->word_start = 0;
+    self->pword_start = self->stream;
+    self->word_start = 0;
 
-     self->state = START_RECORD;
+    self->state = START_RECORD;
 
-     self->error_msg = NULL;
+    self->error_msg = NULL;
 
-     return 0;
- }
+    return 0;
+}
 
 
- int make_stream_space(parser_t *self, size_t nbytes) {
-     int i, status, cap;
-     void *orig_ptr;
+int make_stream_space(parser_t *self, size_t nbytes) {
+    int i, status, cap;
+    void *orig_ptr;
 
-     // Can we fit potentially nbytes tokens (+ null terminators) in the stream?
+    // Can we fit potentially nbytes tokens (+ null terminators) in the stream?
 
-     TRACE(("maybe growing buffers\n"));
+    TRACE(("maybe growing buffers\n"));
 
-     /*
-       TOKEN STREAM
-     */
+    /*
+      TOKEN STREAM
+    */
 
-     // TODO: move word pointers when copy occurs
-     orig_ptr = (void *) self->stream;
-     self->stream = (char*) grow_buffer((void *) self->stream,
-                                        self->stream_len,
-                                        &self->stream_cap, nbytes * 2,
-                                        sizeof(char), &status);
+    orig_ptr = (void *) self->stream;
+    self->stream = (char*) grow_buffer((void *) self->stream,
+                                       self->stream_len,
+                                       &self->stream_cap, nbytes * 2,
+                                       sizeof(char), &status);
 
-     if (status != 0) {
-         return PARSER_OUT_OF_MEMORY;
-     }
+    if (status != 0) {
+        return PARSER_OUT_OF_MEMORY;
+    }
 
-     // realloc sets errno when moving buffer?
-     if (self->stream != orig_ptr) {
-         // uff
-         TRACE(("Moving word pointers\n"))
+    // realloc sets errno when moving buffer?
+    if (self->stream != orig_ptr) {
+        // uff
+        TRACE(("Moving word pointers\n"))
 
-         self->pword_start = self->stream + self->word_start;
+        self->pword_start = self->stream + self->word_start;
 
-         for (i = 0; i < self->words_len; ++i)
-         {
-             self->words[i] = self->stream + self->word_starts[i];
-         }
-     }
+        for (i = 0; i < self->words_len; ++i)
+        {
+            self->words[i] = self->stream + self->word_starts[i];
+        }
+    }
 
 
-     /*
-       WORD VECTORS
-     */
+    /*
+      WORD VECTORS
+    */
 
-     cap = self->words_cap;
-     self->words = (char**) grow_buffer((void *) self->words,
-                                        self->words_len,
-                                        &self->words_cap, nbytes,
-                                        sizeof(char*), &status);
-     if (status != 0) {
-         return PARSER_OUT_OF_MEMORY;
-     }
+    cap = self->words_cap;
+    self->words = (char**) grow_buffer((void *) self->words,
+                                       self->words_len,
+                                       &self->words_cap, nbytes,
+                                       sizeof(char*), &status);
+    if (status != 0) {
+        return PARSER_OUT_OF_MEMORY;
+    }
 
 
-     // realloc took place
-     if (cap != self->words_cap) {
-         self->word_starts = (int*) safe_realloc((void *) self->word_starts,
-                                                 sizeof(int) * self->words_cap);
-         if (self->word_starts == NULL) {
-             return PARSER_OUT_OF_MEMORY;
-         }
-     }
+    // realloc took place
+    if (cap != self->words_cap) {
+        self->word_starts = (int*) safe_realloc((void *) self->word_starts,
+                                                sizeof(int) * self->words_cap);
+        if (self->word_starts == NULL) {
+            return PARSER_OUT_OF_MEMORY;
+        }
+    }
 
 
-     /*
-       LINE VECTORS
-     */
+    /*
+      LINE VECTORS
+    */
 
-     cap = self->lines_cap;
-     self->line_start = (int*) grow_buffer((void *) self->line_start,
-                                           self->lines,
-                                           &self->lines_cap, nbytes,
-                                           sizeof(int), &status);
-     if (status != 0) {
-         return PARSER_OUT_OF_MEMORY;
-     }
+    cap = self->lines_cap;
+    self->line_start = (int*) grow_buffer((void *) self->line_start,
+                                          self->lines,
+                                          &self->lines_cap, nbytes,
+                                          sizeof(int), &status);
+    if (status != 0) {
+        return PARSER_OUT_OF_MEMORY;
+    }
 
-     // realloc took place
-     if (cap != self->lines_cap) {
-         self->line_fields = (int*) safe_realloc((void *) self->line_fields,
-                                                 sizeof(int) * self->lines_cap);
+    // realloc took place
+    if (cap != self->lines_cap) {
+        self->line_fields = (int*) safe_realloc((void *) self->line_fields,
+                                                sizeof(int) * self->lines_cap);
 
-         if (self->line_fields == NULL) {
-             return PARSER_OUT_OF_MEMORY;
-         }
-     }
+        if (self->line_fields == NULL) {
+            return PARSER_OUT_OF_MEMORY;
+        }
+    }
 
 
-     TRACE(("finished growing buffers\n"));
+    TRACE(("finished growing buffers\n"));
 
-     return 0;
- }
+    return 0;
+}
 
 
- int inline push_char(parser_t *self, char c) {
-     /* TRACE(("pushing %c \n", c)) */
-     self->stream[self->stream_len++] = c;
-     return 0;
- }
+int inline push_char(parser_t *self, char c) {
+    /* TRACE(("pushing %c \n", c)) */
+    self->stream[self->stream_len++] = c;
+    return 0;
+}
 
- int inline end_field(parser_t *self) {
-     int pos;
+int inline end_field(parser_t *self) {
+    int pos;
 
-     // XXX cruft
-     self->numeric_field = 0;
+    // XXX cruft
+    self->numeric_field = 0;
 
-     // null terminate token
-     push_char(self, '\0');
+    // null terminate token
+    push_char(self, '\0');
 
-     // set pointer and metadata
-     self->words[self->words_len] = self->pword_start;
+    // set pointer and metadata
+    self->words[self->words_len] = self->pword_start;
 
-     TRACE(("Saw word at: %d\n", self->word_start))
+    TRACE(("Saw word at: %d\n", self->word_start))
 
-     self->word_starts[self->words_len] = self->word_start;
-     self->words_len++;
+    self->word_starts[self->words_len] = self->word_start;
+    self->words_len++;
 
-     // increment line field count
-     self->line_fields[self->lines]++;
+    // increment line field count
+    self->line_fields[self->lines]++;
 
-     // New field begin in stream
-     self->pword_start = self->stream + self->stream_len;
-     self->word_start = self->stream_len;
+    // New field begin in stream
+    self->pword_start = self->stream + self->stream_len;
+    self->word_start = self->stream_len;
 
-     return 0;
- }
+    return 0;
+}
 
- int inline end_line(parser_t *self) {
-     int fields, ex_fields;
-
-     if (self->lines == 0) {
-         self->line_start[0] = 0;
-     } else {
-         // move ahead so many fields
-         self->line_start[self->lines] = (self->line_start[self->lines - 1] +
-                                          self->line_fields[self->lines - 1]);
-
-         fields = self->line_fields[self->lines];
-         ex_fields = self->line_fields[self->lines - 1];
-         // TODO: better check here
-         if (fields != ex_fields) {
-             self->error_msg = (char*) malloc(100);
-             sprintf(self->error_msg, "Expected %d fields in line %d, saw %d\n",
-                     ex_fields, self->lines + 1, fields);
-             self->lines++;
-             return -1;
-         }
-     }
+int inline end_line(parser_t *self) {
+    int fields, ex_fields;
 
-     //printf("line %d had %d fields\n", self->lines, self->line_fields[self->lines]);
+    fields = self->line_fields[self->lines];
 
-     // field count already handled by end_field
+    // TODO: header line handling
 
-     self->lines++;
-     self->line_fields[self->lines] = 0;
+    if (self->lines == 0) {
+        // Nothing to check here
+        self->file_lines++;
+        self->lines++;
+        self->line_fields[self->lines] = 0;
+        self->line_start[self->lines] = fields;
+    } else {
+        ex_fields = self->line_fields[self->lines - 1];
 
-     return 0;
- }
+        // TODO: better check here
+        if (fields != ex_fields) {
+            // increment file line count
+            self->file_lines++;
 
- int parser_clear_data_buffers(parser_t *self) {
-     if (self->sourcetype == 'F') {
-         free_if_not_null(self->data);
-     }
+            // skip the tokens from this bad line
+            self->line_start[self->lines] += fields;
 
-     free_if_not_null(self->stream);
-     free_if_not_null(self->words);
-     free_if_not_null(self->word_starts);
-     free_if_not_null(self->line_start);
-     free_if_not_null(self->line_fields);
+            // reset field count
+            self->line_fields[self->lines] = 0;
 
-     return 0;
- }
+            // file_lines is now the _actual_ file line number (starting at 1)
 
- void parser_free(parser_t *self) {
-     // opposite of parser_init
-     parser_cleanup(self);
-     free(self);
- }
+            if (self->error_bad_lines) {
+                self->error_msg = (char*) malloc(100);
+                sprintf(self->error_msg, "Expected %d fields in line %d, saw %d\n",
+                        ex_fields, self->file_lines, fields);
 
+                return -1;
+            } else {
+                // simply skip bad lines
+                if (self->warn_bad_lines) {
+                    // print error message
+                    printf("Skipping line %d: expected %d fields, saw %d\n",
+                           self->file_lines, ex_fields, fields);
+                }
+            }
+        } else {
+            // increment both line counts
+            self->lines++;
+            self->file_lines++;
 
+            // good line, set new start point
+            self->line_start[self->lines] = (self->line_start[self->lines - 1]
+                                             + fields);
 
- int parser_cleanup(parser_t *self) {
-     if (parser_cleanup_filebuffers(self) < 0) {
-         return -1;
-     }
+            // new line start with 0 fields
+            self->line_fields[self->lines] = 0;
+        }
+    }
 
-     if (parser_clear_data_buffers(self) < 0) {
-         return -1;
-     }
 
-     // XXX where to put this
-     free_if_not_null(self->error_msg);
+    return 0;
+}
 
-     return 0;
- }
+int parser_clear_data_buffers(parser_t *self) {
+    if (self->sourcetype == 'F') {
+        free_if_not_null(self->data);
+    }
 
- int parser_buffer_bytes(parser_t *self, size_t nbytes) {
-     int status;
-     size_t bytes;
-     void *src = self->source;
+    free_if_not_null(self->stream);
+    free_if_not_null(self->words);
+    free_if_not_null(self->word_starts);
+    free_if_not_null(self->line_start);
+    free_if_not_null(self->line_fields);
 
-     // This should probably end up as a method table
+    return 0;
+}
 
-     status = 0;
+void parser_free(parser_t *self) {
+    // opposite of parser_init
+    parser_cleanup(self);
+    free(self);
+}
 
-     switch(self->sourcetype) {
-         case 'F': // basic FILE*
 
-             bytes = fread((void *) self->data, sizeof(char), nbytes,
-                           FS(src)->fp);
-             self->datalen = bytes;
 
-             TRACE(("Read %d bytes\n", (int) bytes));
+int parser_cleanup(parser_t *self) {
+    if (parser_cleanup_filebuffers(self) < 0) {
+        return -1;
+    }
 
-             // printf("%s\n", self->data);
+    if (parser_clear_data_buffers(self) < 0) {
+        return -1;
+    }
 
-             if (bytes == 0) {
-                 status = REACHED_EOF;
-             }
-             break;
+    // XXX where to put this
+    free_if_not_null(self->error_msg);
 
-         case 'A': // in-memory bytes (e.g. from StringIO)
-             // ew, side effects
-             status = _buffer_array_bytes(self, nbytes);
-             break;
+    return 0;
+}
 
- #ifdef HAVE_MEMMAP
-         case 'M': // memory map
-             status = _buffer_mmap_bytes(self, nbytes);
+int parser_buffer_bytes(parser_t *self, size_t nbytes) {
+    int status;
+    size_t bytes;
+    void *src = self->source;
 
-             break;
- #endif
+    // This should probably end up as a method table
 
- #ifdef HAVE_GZIP
-         case 'G': // gzip'd file
+    status = 0;
 
-             break;
- #endif
+    switch(self->sourcetype) {
+        case 'F': // basic FILE*
 
-     }
+            bytes = fread((void *) self->data, sizeof(char), nbytes,
+                          FS(src)->fp);
+            self->datalen = bytes;
 
-     return status;
- }
+            TRACE(("Read %d bytes\n", (int) bytes));
 
- int _buffer_array_bytes(parser_t *self, size_t nbytes) {
-     array_source *src = ARS(self->source);
+            // printf("%s\n", self->data);
 
-     if (src->position == src->length) {
-         self->datalen = 0;
-         return REACHED_EOF;
-     }
+            if (bytes == 0) {
+                status = REACHED_EOF;
+            }
+            break;
 
-     self->data = src->data + src->position;
+        case 'A': // in-memory bytes (e.g. from StringIO)
+            // ew, side effects
+            status = _buffer_array_bytes(self, nbytes);
+            break;
 
-     if (src->position + nbytes > src->length) {
-         // fewer than nbytes remaining
-         self->datalen = src->length - src->position;
-     } else {
-         self->datalen = nbytes;
-     }
+#ifdef HAVE_MEMMAP
+        case 'M': // memory map
+            status = _buffer_mmap_bytes(self, nbytes);
 
-     src->position += self->datalen;
+            break;
+#endif
 
-     TRACE(("datalen: %d\n", self->datalen));
+#ifdef HAVE_GZIP
+        case 'G': // gzip'd file
 
-     TRACE(("pos: %d, length: %d", src->position, src->length));
-     return 0;
- }
+            break;
+#endif
 
+    }
 
- int parser_cleanup_filebuffers(parser_t *self) {
-     switch(self->sourcetype) {
+    return status;
+}
 
-         case 'F':
-             del_file_source(self->source);
-             break;
+int _buffer_array_bytes(parser_t *self, size_t nbytes) {
+    array_source *src = ARS(self->source);
 
-         case 'A': // in-memory bytes (e.g. from StringIO)
-             del_array_source(self->source);
-             break;
+    if (src->position == src->length) {
+        self->datalen = 0;
+        return REACHED_EOF;
+    }
 
- #ifdef HAVE_MEMMAP
-         case 'M': // memory map
-             del_mmap(self->source);
-             break;
- #endif
+    self->data = src->data + src->position;
 
+    if (src->position + nbytes > src->length) {
+        // fewer than nbytes remaining
+        self->datalen = src->length - src->position;
+    } else {
+        self->datalen = nbytes;
+    }
 
- #ifdef HAVE_GZIP
-         case 'G': // gzip'd file
+    src->position += self->datalen;
 
-             break;
- #endif
+    TRACE(("datalen: %d\n", self->datalen));
 
-     }
+    TRACE(("pos: %d, length: %d", src->position, src->length));
+    return 0;
+}
 
-     return 0;
- }
 
- /*
+int parser_cleanup_filebuffers(parser_t *self) {
+    switch(self->sourcetype) {
+
+        case 'F':
+            del_file_source(self->source);
+            break;
 
-   Tokenization macros and state machine code
+        case 'A': // in-memory bytes (e.g. from StringIO)
+            del_array_source(self->source);
+            break;
 
- */
+#ifdef HAVE_MEMMAP
+        case 'M': // memory map
+            del_mmap(self->source);
+            break;
+#endif
+
+
+#ifdef HAVE_GZIP
+        case 'G': // gzip'd file
+
+            break;
+#endif
+
+    }
+
+    return 0;
+}
+
+/*
+
+  Tokenization macros and state machine code
+
+*/
 
 //    printf("pushing %c\n", c);                \
 
- #define PUSH_CHAR(c)                           \
-     *stream++ = c;                             \
-     slen++;
+#define PUSH_CHAR(c)                           \
+    *stream++ = c;                             \
+    slen++;
 
- // This is a little bit of a hack but works for now
+// This is a little bit of a hack but works for now
 
- #define END_FIELD()                                \
-     self->stream_len = slen;                   \
-     if (end_field(self) < 0) {                 \
-         goto parsingerror;                     \
-     }                                          \
-     stream = self->stream + self->stream_len;  \
-     slen = self->stream_len;
+#define END_FIELD()                                \
+    self->stream_len = slen;                   \
+    if (end_field(self) < 0) {                 \
+        goto parsingerror;                     \
+    }                                          \
+    stream = self->stream + self->stream_len;  \
+    slen = self->stream_len;
 
- #define END_LINE()                             \
-     self->stream_len = slen;                   \
-     if (end_line(self) < 0) {                  \
-         goto parsingerror;                     \
-     }                                          \
-     stream = self->stream + self->stream_len;  \
-     slen = self->stream_len;
+#define END_LINE()                             \
+    self->stream_len = slen;                   \
+    if (end_line(self) < 0) {                  \
+        goto parsingerror;                     \
+    }                                          \
+    stream = self->stream + self->stream_len;  \
+    slen = self->stream_len;
 
- #define IS_WHITESPACE(c) ((c == ' ' || c == '\t'))
+#define IS_WHITESPACE(c) ((c == ' ' || c == '\t'))
 
 typedef int (*parser_op)(parser_t *self);
 
@@ -1210,7 +1240,7 @@ int tokenize_delimited(parser_t *self)
         c = *buf++;
 
         TRACE(("Iter: %d Char: %c Line %d field_count %d\n",
-               i, c, self->lines + 1, self->line_fields[self->lines]));
+               i, c, self->file_lines + 1, self->line_fields[self->file_lines]));
 
         switch(self->state) {
         case START_RECORD:
@@ -1417,7 +1447,7 @@ int tokenize_whitespace(parser_t *self)
         c = *buf++;
 
         TRACE(("Iter: %d Char: %c Line %d field_count %d\n",
-               i, c, self->lines + 1, self->line_fields[self->lines]));
+               i, c, self->file_lines + 1, self->line_fields[self->file_lines]));
 
         switch(self->state) {
 
@@ -1635,7 +1665,7 @@ void debug_print_parser(parser_t *self) {
 
     for (line = 0; line < self->lines; ++line)
     {
-        printf("Line %d: ", line);
+        printf("(Parsed) Line %d: ", line);
 
         for (j = 0; j < self->line_fields[j]; ++j)
         {
@@ -1680,7 +1710,7 @@ int _tokenize_helper(parser_t *self, size_t nrows, int all) {
         TRACE(("sourcetype: %c, status: %d\n", self->sourcetype, status));
 
         if (status == REACHED_EOF) {
-            // close last line
+            // close out last line
             status = parser_handle_eof(self);
             break;
         }
diff --git a/pandas/src/parser/parser.h b/pandas/src/parser/parser.h
index a7686a924..fc699e79f 100644
--- a/pandas/src/parser/parser.h
+++ b/pandas/src/parser/parser.h
@@ -126,7 +126,8 @@ typedef struct parser_t {
 
     int *line_start;      // position in words for start of line
     int *line_fields;     // Number of fields in each line
-    int lines;            // Number of lines observed
+    int lines;            // Number of (good) lines observed
+    int file_lines;       // Number of file lines observed (including bad or skipped)
     int lines_cap;        // Vector capacity
 
     // Tokenizing stuff
@@ -139,7 +140,7 @@ typedef struct parser_t {
     int skipinitialspace;       /* ignore spaces following delimiter? */
     int quoting;                /* style of quoting to write */
 
-    // hmm =/
+    // krufty, hmm =/
     int numeric_field;
 
     char commentchar;

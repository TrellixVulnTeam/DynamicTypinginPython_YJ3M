commit bc0ef52f6ec69831c2b7e9f07263ea5dec26134f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Dec 2 15:42:28 2012 -0500

    ENH: start working toward refactor for fast apply

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 735616f72..941a2d135 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -11,7 +11,6 @@ from pandas.core.series import Series
 from pandas.core.panel import Panel
 from pandas.util.decorators import cache_readonly, Appender
 from pandas.util.compat import OrderedDict
-from pandas.util.decorators import Appender
 import pandas.core.algorithms as algos
 import pandas.core.common as com
 
@@ -1926,6 +1925,31 @@ class DataFrameGroupBy(NDFrameGroupBy):
 
         return result
 
+    def _python_apply_general(self, func, *args, **kwargs):
+        func = _intercept_function(func)
+
+        result_keys = []
+        result_values = []
+
+        not_indexed_same = False
+        for key, group in self:
+            object.__setattr__(group, 'name', key)
+
+            # group might be modified
+            group_axes = _get_axes(group)
+
+            res = func(group, *args, **kwargs)
+
+            if not _is_indexed_like(res, group_axes):
+                not_indexed_same = True
+
+            result_keys.append(key)
+            result_values.append(res)
+
+        return self._wrap_applied_output(result_keys, result_values,
+                                         not_indexed_same=not_indexed_same)
+
+
 from pandas.tools.plotting import boxplot_frame_groupby
 DataFrameGroupBy.boxplot = boxplot_frame_groupby
 
@@ -2008,6 +2032,59 @@ class NDArrayGroupBy(GroupBy):
     pass
 
 
+#----------------------------------------------------------------------
+# Splitting / application
+
+
+class DataSplitter(object):
+
+    def __init__(self, data, labels, ngroups, axis=0):
+        self.data = data
+        self.labels = com._ensure_int64(labels)
+        self.ngroups = ngroups
+
+        self.sort_idx = _algos.groupsort_indexer(self.labels,
+                                                 self.ngroups)[0]
+        self.slabels = com.ndtake(self.labels, self.sort_idx)
+        self.axis = axis
+
+    def __iter__(self):
+        sdata = self._get_sorted_data()
+
+        starts, ends = lib.generate_slices(self.sort_idx, self.ngroups)
+
+        for i, (start, end) in enumerate(zip(starts, ends)):
+            # Since I'm now compressing the group ids, it's now not "possible"
+            # to produce empty slices because such groups would not be observed
+            # in the data
+            # if start >= end:
+            #     raise AssertionError('Start %s must be less than end %s'
+            #                          % (str(start), str(end)))
+            yield i, self._chop(sdata, slice(start, end))
+
+    def _get_sorted_data(self):
+        return self.data.take(self.sort_idx, axis=self.axis)
+
+    def _chop(self, sdata, slice_obj):
+        raise NotImplementedError
+
+    def apply(self, f, keep_internal=False):
+        raise NotImplementedError
+
+
+class ArraySplitter(DataSplitter):
+    pass
+
+
+class SeriesSplitter(DataSplitter):
+
+    def _chop(self, sdata, slice_obj):
+        return sdata._get_values(slob)
+
+
+class FrameSplitter(DataSplitter):
+    pass
+
 #----------------------------------------------------------------------
 # Grouping generator for BlockManager
 
@@ -2022,7 +2099,6 @@ def generate_groups(data, group_index, ngroups, axis=0, factory=lambda x: x):
     generator
     """
     group_index = com._ensure_int64(group_index)
-
     indexer = _algos.groupsort_indexer(group_index, ngroups)[0]
     group_index = com.ndtake(group_index, indexer)
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 5015d833a..ef0a59075 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -1430,6 +1430,24 @@ class TestGroupBy(unittest.TestCase):
         result = self.df.groupby(cats).D.apply(get_stats)
         self.assertEquals(result.index.names[0], 'C')
 
+    def test_apply_corner_cases(self):
+        # #535, can't use sliding iterator
+
+        N = 1000
+        labels = np.random.randint(0, 100, size=N)
+        df = DataFrame({'key': labels,
+                        'value1': np.random.randn(N),
+                        'value2': ['foo', 'bar', 'baz', 'qux'] * (N / 4)})
+
+        grouped = df.groupby('key')
+
+        def f(g):
+            g['value3'] = g['value1'] * 2
+            return g
+
+        result = grouped.apply(f)
+        self.assertTrue('value3' in result)
+
     def test_transform_mixed_type(self):
         index = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1],
                                         [1, 2, 3, 1, 2, 3]])
diff --git a/vb_suite/groupby.py b/vb_suite/groupby.py
index 5f6e82b04..68a2bc8a6 100644
--- a/vb_suite/groupby.py
+++ b/vb_suite/groupby.py
@@ -220,3 +220,24 @@ groupby_simple_compress_timing = \
     Benchmark('df.groupby(labels).mean()', setup,
               start_date=datetime(2011, 8, 1))
 
+
+#----------------------------------------------------------------------
+# DataFrame Apply overhead
+
+setup = common_setup + """
+N = 10000
+labels = np.random.randint(0, 1000, size=N)
+labels2 = np.random.randint(0, 3, size=N)
+df = DataFrame({'key': labels,
+                'key2': labels2,
+                'value1': randn(N),
+                'value2': ['foo', 'bar', 'baz', 'qux'] * (N / 4)})
+def f(g):
+    return g
+"""
+
+groupby_frame_apply_overhead = Benchmark("df.groupby('key').apply(f)", setup,
+                                         start_date=datetime(2011, 10, 1))
+
+groupbym_frame_apply = Benchmark("df.groupby(['key', 'key2']).apply(f)", setup,
+                                 start_date=datetime(2011, 10, 1))

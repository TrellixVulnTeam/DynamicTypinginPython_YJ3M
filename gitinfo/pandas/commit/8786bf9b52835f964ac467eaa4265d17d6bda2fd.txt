commit 8786bf9b52835f964ac467eaa4265d17d6bda2fd
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Feb 27 16:47:59 2012 -0500

    ENH: add fill_value argument to Series.reindex, DataFrame next, #784

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 6f37aaea5..b253d24ee 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -103,10 +103,10 @@ def _unpickle_array(bytes):
     arr = read_array(BytesIO(bytes))
     return arr
 
-def _take_1d_bool(arr, indexer, out):
+def _take_1d_bool(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.uint8)
     outview = out.view(np.uint8)
-    lib.take_1d_bool(view, indexer, outview)
+    lib.take_1d_bool(view, indexer, outview, fill_value=fill_value)
 
 def _take_2d_axis0_bool(arr, indexer, out):
     view = arr.view(np.uint8)
@@ -148,7 +148,7 @@ def _get_take2d_function(dtype_str, axis=0):
     else:
         return _take2d_axis1_dict[dtype_str]
 
-def take_1d(arr, indexer, out=None):
+def take_1d(arr, indexer, out=None, fill_value=np.nan):
     """
     Specialized Cython take which sets NaN values in one pass
     """
@@ -167,7 +167,7 @@ def take_1d(arr, indexer, out=None):
             if out is None:
                 out = np.empty(n, dtype=arr.dtype)
             take_f = _take1d_dict[dtype_str]
-            take_f(arr, indexer, out=out)
+            take_f(arr, indexer, out=out, fill_value=fill_value)
         except ValueError:
             mask = indexer == -1
             if len(arr) == 0:
@@ -180,12 +180,12 @@ def take_1d(arr, indexer, out=None):
                     raise Exception('out with dtype %s does not support NA' %
                                     out.dtype)
                 out = _maybe_upcast(out)
-                np.putmask(out, mask, np.nan)
+                np.putmask(out, mask, fill_value)
     elif dtype_str in ('float64', 'object'):
         if out is None:
             out = np.empty(n, dtype=arr.dtype)
         take_f = _take1d_dict[dtype_str]
-        take_f(arr, indexer, out=out)
+        take_f(arr, indexer, out=out, fill_value=fill_value)
     else:
         out = arr.take(indexer, out=out)
         mask = indexer == -1
@@ -194,7 +194,7 @@ def take_1d(arr, indexer, out=None):
                 raise Exception('out with dtype %s does not support NA' %
                                 out.dtype)
             out = _maybe_upcast(out)
-            np.putmask(out, mask, np.nan)
+            np.putmask(out, mask, fill_value)
 
     return out
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 5474cb381..2a738fc09 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1841,7 +1841,8 @@ copy : boolean, default False
         # be subclass-friendly
         return self._constructor(new_values, new_index, name=self.name)
 
-    def reindex(self, index=None, method=None, level=None, copy=True):
+    def reindex(self, index=None, method=None, level=None, fill_value=np.nan,
+                copy=True):
         """Conform Series to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1861,6 +1862,9 @@ copy : boolean, default False
         level : int or name
             Broadcast across a level, matching Index values on the
             passed MultiIndex level
+        fill_value : scalar, default np.NaN
+            Value to use for missing values. Defaults to NaN, but can be any
+            "compatible" value
 
         Returns
         -------
@@ -1878,7 +1882,7 @@ copy : boolean, default False
 
         new_index, fill_vec = self.index.reindex(index, method=method,
                                                  level=level)
-        new_values = com.take_1d(self.values, fill_vec)
+        new_values = com.take_1d(self.values, fill_vec, fill_value=fill_value)
         return Series(new_values, index=new_index, name=self.name)
 
     def reindex_like(self, other, method=None):
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 09d2173c3..ba156a019 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -3,10 +3,11 @@ from cStringIO import StringIO
 take_1d_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_%(name)s(ndarray[%(c_type)s] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[%(c_type)s] outbuf
+        %(c_type)s fv
 
     n = len(indexer)
 
@@ -15,12 +16,21 @@ def take_1d_%(name)s(ndarray[%(c_type)s] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            %(na_action)s
-        else:
-            outbuf[i] = values[idx]
+    if %(raise_on_na)s and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 """
 
@@ -724,12 +734,14 @@ def generate_from_template(template, ndim=1, exclude=None):
         if exclude is not None and name in exclude:
             continue
 
+        raise_on_na = 'False' if can_hold_na else 'True'
         if ndim == 1:
             na_action = set_na if can_hold_na else raise_on_na
         elif ndim == 2:
             na_action = set_na_2d if can_hold_na else raise_on_na
-        func = template % {'name' : name, 'c_type' : c_type,
-                           'dtype' : dtype, 'na_action' : na_action}
+        func = template % {'name': name, 'c_type': c_type,
+                           'dtype': dtype, 'na_action': na_action,
+                           'raise_on_na': raise_on_na}
         output.write(func)
     return output.getvalue()
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 7f8ada117..9d1a3e1d9 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -927,10 +927,11 @@ def backfill_2d_inplace_bool(ndarray[uint8_t, ndim=2] values,
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[float64_t] outbuf
+        float64_t fv
 
     n = len(indexer)
 
@@ -939,20 +940,30 @@ def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            outbuf[i] = NaN
-        else:
-            outbuf[i] = values[idx]
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[object] outbuf
+        object fv
 
     n = len(indexer)
 
@@ -961,20 +972,30 @@ def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            outbuf[i] = NaN
-        else:
-            outbuf[i] = values[idx]
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[int32_t] outbuf
+        int32_t fv
 
     n = len(indexer)
 
@@ -983,20 +1004,30 @@ def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[int64_t] outbuf
+        int64_t fv
 
     n = len(indexer)
 
@@ -1005,20 +1036,30 @@ def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
-                     out=None):
+                     out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
         ndarray[uint8_t] outbuf
+        uint8_t fv
 
     n = len(indexer)
 
@@ -1027,12 +1068,21 @@ def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-        if idx == -1:
-            raise ValueError('No NA values allowed')
-        else:
-            outbuf[i] = values[idx]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                raise ValueError('No NA values allowed')
+            else:
+                outbuf[i] = values[idx]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                outbuf[i] = fv
+            else:
+                outbuf[i] = values[idx]
 
 
 @cython.boundscheck(False)
@@ -1404,7 +1454,7 @@ def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
 
         if idx == -1:
             for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
+                True
         else:
             for j from 0 <= j < k:
                 outbuf[i, j] = values[idx, j]
@@ -1431,7 +1481,7 @@ def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
 
         if idx == -1:
             for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
+                True
         else:
             for j from 0 <= j < k:
                 outbuf[i, j] = values[idx, j]
@@ -1458,7 +1508,7 @@ def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
 
         if idx == -1:
             for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
+                True
         else:
             for j from 0 <= j < k:
                 outbuf[i, j] = values[idx, j]
@@ -1540,7 +1590,7 @@ def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
 
         if idx == -1:
             for i in range(n):
-                raise ValueError('No NA values allowed')
+                True
         else:
             for i in range(n):
                 outbuf[i, j] = values[i, idx]
@@ -1567,7 +1617,7 @@ def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
 
         if idx == -1:
             for i in range(n):
-                raise ValueError('No NA values allowed')
+                True
         else:
             for i in range(n):
                 outbuf[i, j] = values[i, idx]
@@ -1594,7 +1644,7 @@ def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
 
         if idx == -1:
             for i in range(n):
-                raise ValueError('No NA values allowed')
+                True
         else:
             for i in range(n):
                 outbuf[i, j] = values[i, idx]
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index c71960bd1..1734d61f3 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1958,6 +1958,56 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(self.ts.reindex(other.index),
                             self.ts.reindex_like(other))
 
+    def test_reindex_fill_value(self):
+        #------------------------------------------------------------
+        # floats
+        floats = Series([1., 2., 3.])
+        result = floats.reindex([1, 2, 3])
+        expected = Series([2., 3., np.nan], index=[1, 2, 3])
+        assert_series_equal(result, expected)
+
+        result = floats.reindex([1, 2, 3], fill_value=0)
+        expected = Series([2., 3., 0], index=[1, 2, 3])
+        assert_series_equal(result, expected)
+
+        #------------------------------------------------------------
+        # ints
+        ints = Series([1, 2, 3])
+
+        result = ints.reindex([1, 2, 3])
+        expected = Series([2., 3., np.nan], index=[1, 2, 3])
+        assert_series_equal(result, expected)
+
+        # don't upcast
+        result = ints.reindex([1, 2, 3], fill_value=0)
+        expected = Series([2, 3, 0], index=[1, 2, 3])
+        self.assert_(issubclass(result.dtype.type, np.integer))
+        assert_series_equal(result, expected)
+
+        #------------------------------------------------------------
+        # objects
+        objects = Series([1, 2, 3], dtype=object)
+
+        result = objects.reindex([1, 2, 3])
+        expected = Series([2, 3, np.nan], index=[1, 2, 3], dtype=object)
+        assert_series_equal(result, expected)
+
+        result = objects.reindex([1, 2, 3], fill_value='foo')
+        expected = Series([2, 3, 'foo'], index=[1, 2, 3], dtype=object)
+        assert_series_equal(result, expected)
+
+        #------------------------------------------------------------
+        # bools
+        bools = Series([True, False, True])
+
+        result = bools.reindex([1, 2, 3])
+        expected = Series([False, True, np.nan], index=[1, 2, 3], dtype=object)
+        assert_series_equal(result, expected)
+
+        result = bools.reindex([1, 2, 3], fill_value=False)
+        expected = Series([False, True, False], index=[1, 2, 3])
+        assert_series_equal(result, expected)
+
     def test_rename(self):
         renamer = lambda x: x.strftime('%Y%m%d')
         renamed = self.ts.rename(renamer)

commit a5c992b579f0604e64fe821085718ca9723ae339
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Dec 12 04:15:51 2019 -0800

    DEPR: remove ix (#27620)

diff --git a/asv_bench/benchmarks/frame_methods.py b/asv_bench/benchmarks/frame_methods.py
index 9647693d4..ae6c07107 100644
--- a/asv_bench/benchmarks/frame_methods.py
+++ b/asv_bench/benchmarks/frame_methods.py
@@ -321,10 +321,9 @@ class Dropna:
 
     def setup(self, how, axis):
         self.df = DataFrame(np.random.randn(10000, 1000))
-        with warnings.catch_warnings(record=True):
-            self.df.ix[50:1000, 20:50] = np.nan
-            self.df.ix[2000:3000] = np.nan
-            self.df.ix[:, 60:70] = np.nan
+        self.df.iloc[50:1000, 20:50] = np.nan
+        self.df.iloc[2000:3000] = np.nan
+        self.df.iloc[:, 60:70] = np.nan
         self.df_mixed = self.df.copy()
         self.df_mixed["foo"] = "bar"
 
@@ -342,10 +341,9 @@ class Count:
 
     def setup(self, axis):
         self.df = DataFrame(np.random.randn(10000, 1000))
-        with warnings.catch_warnings(record=True):
-            self.df.ix[50:1000, 20:50] = np.nan
-            self.df.ix[2000:3000] = np.nan
-            self.df.ix[:, 60:70] = np.nan
+        self.df.iloc[50:1000, 20:50] = np.nan
+        self.df.iloc[2000:3000] = np.nan
+        self.df.iloc[:, 60:70] = np.nan
         self.df_mixed = self.df.copy()
         self.df_mixed["foo"] = "bar"
 
diff --git a/asv_bench/benchmarks/indexing.py b/asv_bench/benchmarks/indexing.py
index ac35139c1..c78c2fa92 100644
--- a/asv_bench/benchmarks/indexing.py
+++ b/asv_bench/benchmarks/indexing.py
@@ -67,22 +67,6 @@ class NumericSeriesIndexing:
     def time_iloc_slice(self, index, index_structure):
         self.data.iloc[:800000]
 
-    def time_ix_array(self, index, index_structure):
-        with warnings.catch_warnings(record=True):
-            self.data.ix[self.array]
-
-    def time_ix_list_like(self, index, index_structure):
-        with warnings.catch_warnings(record=True):
-            self.data.ix[[800000]]
-
-    def time_ix_scalar(self, index, index_structure):
-        with warnings.catch_warnings(record=True):
-            self.data.ix[800000]
-
-    def time_ix_slice(self, index, index_structure):
-        with warnings.catch_warnings(record=True):
-            self.data.ix[:800000]
-
     def time_loc_array(self, index, index_structure):
         self.data.loc[self.array]
 
@@ -148,10 +132,6 @@ class DataFrameStringIndexing:
         self.bool_indexer = self.df[self.col_scalar] > 0
         self.bool_obj_indexer = self.bool_indexer.astype(object)
 
-    def time_ix(self):
-        with warnings.catch_warnings(record=True):
-            self.df.ix[self.idx_scalar, self.col_scalar]
-
     def time_loc(self):
         self.df.loc[self.idx_scalar, self.col_scalar]
 
@@ -228,14 +208,6 @@ class MultiIndexing:
         self.idx = IndexSlice[20000:30000, 20:30, 35:45, 30000:40000]
         self.mdt = self.mdt.set_index(["A", "B", "C", "D"]).sort_index()
 
-    def time_series_ix(self):
-        with warnings.catch_warnings(record=True):
-            self.s.ix[999]
-
-    def time_frame_ix(self):
-        with warnings.catch_warnings(record=True):
-            self.df.ix[999]
-
     def time_index_slice(self):
         self.mdt.loc[self.idx, :]
 
@@ -310,10 +282,6 @@ class MethodLookup:
     def time_lookup_iloc(self, s):
         s.iloc
 
-    def time_lookup_ix(self, s):
-        with warnings.catch_warnings(record=True):
-            s.ix
-
     def time_lookup_loc(self, s):
         s.loc
 
diff --git a/doc/source/reference/index.rst b/doc/source/reference/index.rst
index 12ca318c8..9d5649c37 100644
--- a/doc/source/reference/index.rst
+++ b/doc/source/reference/index.rst
@@ -49,7 +49,6 @@ public functions related to data types in pandas.
 
         api/pandas.DataFrame.blocks
         api/pandas.DataFrame.as_matrix
-        api/pandas.DataFrame.ix
         api/pandas.Index.asi8
         api/pandas.Index.data
         api/pandas.Index.flags
@@ -60,7 +59,6 @@ public functions related to data types in pandas.
         api/pandas.Series.asobject
         api/pandas.Series.blocks
         api/pandas.Series.from_array
-        api/pandas.Series.ix
         api/pandas.Series.imag
         api/pandas.Series.real
 
diff --git a/doc/source/whatsnew/v1.0.0.rst b/doc/source/whatsnew/v1.0.0.rst
index 29060a939..87980c977 100644
--- a/doc/source/whatsnew/v1.0.0.rst
+++ b/doc/source/whatsnew/v1.0.0.rst
@@ -535,6 +535,7 @@ or ``matplotlib.Axes.plot``. See :ref:`plotting.formatters` for more.
 - :meth:`DataFrame.hist` and :meth:`Series.hist` no longer allows ``figsize="default"``, specify figure size by passinig a tuple instead (:issue:`30003`)
 - Floordiv of integer-dtyped array by :class:`Timedelta` now raises ``TypeError`` (:issue:`21036`)
 - :func:`pandas.api.types.infer_dtype` argument ``skipna`` defaults to ``True`` instead of ``False`` (:issue:`24050`)
+- Removed the previously deprecated :attr:`Series.ix` and :attr:`DataFrame.ix` (:issue:`26438`)
 - Removed the previously deprecated :meth:`Index.summary` (:issue:`18217`)
 - Removed the previously deprecated "fastpath" keyword from the :class:`Index` constructor (:issue:`23110`)
 - Removed the previously deprecated :meth:`Series.get_value`, :meth:`Series.set_value`, :meth:`DataFrame.get_value`, :meth:`DataFrame.set_value` (:issue:`17739`)
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index a9269a5e0..341262313 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,6 +1,4 @@
-import textwrap
 from typing import Tuple
-import warnings
 
 import numpy as np
 
@@ -10,10 +8,8 @@ from pandas.errors import AbstractMethodError
 from pandas.util._decorators import Appender
 
 from pandas.core.dtypes.common import (
-    ensure_platform_int,
     is_float,
     is_integer,
-    is_integer_dtype,
     is_iterator,
     is_list_like,
     is_numeric_dtype,
@@ -34,7 +30,6 @@ from pandas.core.indexers import is_list_like_indexer, length_of_indexer
 def get_indexers_list():
 
     return [
-        ("ix", _IXIndexer),
         ("iloc", _iLocIndexer),
         ("loc", _LocIndexer),
         ("at", _AtIndexer),
@@ -112,9 +107,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
         new_self.axis = axis
         return new_self
 
-    def __iter__(self):
-        raise NotImplementedError("ix is not iterable")
-
+    # TODO: remove once geopandas no longer needs this
     def __getitem__(self, key):
         # Used in ix and downstream in geopandas _CoordinateIndexer
         if type(key) is tuple:
@@ -921,9 +914,6 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
         if len(tup) > self.ndim:
             raise IndexingError("Too many indexers. handle elsewhere")
 
-        # to avoid wasted computation
-        # df.ix[d1:d2, 0] -> columns first (True)
-        # df.ix[0, ['C', 'B', A']] -> rows first (False)
         for i, key in enumerate(tup):
             if is_label_like(key) or isinstance(key, tuple):
                 section = self._getitem_axis(key, axis=i)
@@ -1004,6 +994,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
         return obj
 
+    # TODO: remove once geopandas no longer needs __getitem__
     def _getitem_axis(self, key, axis: int):
         if is_iterator(key):
             key = list(key)
@@ -1292,106 +1283,6 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
         return self._slice(indexer, axis=axis, kind="iloc")
 
 
-class _IXIndexer(_NDFrameIndexer):
-    """
-    A primarily label-location based indexer, with integer position fallback.
-
-    Warning: Starting in 0.20.0, the .ix indexer is deprecated, in
-    favor of the more strict .iloc and .loc indexers.
-
-    ``.ix[]`` supports mixed integer and label based access. It is
-    primarily label based, but will fall back to integer positional
-    access unless the corresponding axis is of integer type.
-
-    ``.ix`` is the most general indexer and will support any of the
-    inputs in ``.loc`` and ``.iloc``. ``.ix`` also supports floating
-    point label schemes. ``.ix`` is exceptionally useful when dealing
-    with mixed positional and label based hierarchical indexes.
-
-    However, when an axis is integer based, ONLY label based access
-    and not positional access is supported. Thus, in such cases, it's
-    usually better to be explicit and use ``.iloc`` or ``.loc``.
-
-    See more at :ref:`Advanced Indexing <advanced>`.
-    """
-
-    _ix_deprecation_warning = textwrap.dedent(
-        """
-        .ix is deprecated. Please use
-        .loc for label based indexing or
-        .iloc for positional indexing
-
-        See the documentation here:
-        http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#ix-indexer-is-deprecated"""  # noqa: E501
-    )
-
-    def __init__(self, name, obj):
-        warnings.warn(self._ix_deprecation_warning, FutureWarning, stacklevel=2)
-        super().__init__(name, obj)
-
-    @Appender(_NDFrameIndexer._validate_key.__doc__)
-    def _validate_key(self, key, axis: int) -> bool:
-        """
-        Returns
-        -------
-        bool
-        """
-        if isinstance(key, slice):
-            return True
-
-        elif com.is_bool_indexer(key):
-            return True
-
-        elif is_list_like_indexer(key):
-            return True
-
-        else:
-
-            self._convert_scalar_indexer(key, axis)
-
-        return True
-
-    def _convert_for_reindex(self, key, axis: int):
-        """
-        Transform a list of keys into a new array ready to be used as axis of
-        the object we return (e.g. including NaNs).
-
-        Parameters
-        ----------
-        key : list-like
-            Targeted labels.
-        axis: int
-            Where the indexing is being made.
-
-        Returns
-        -------
-        list-like of labels.
-        """
-        labels = self.obj._get_axis(axis)
-
-        if com.is_bool_indexer(key):
-            key = check_bool_indexer(labels, key)
-            return labels[key]
-
-        if isinstance(key, Index):
-            keyarr = labels._convert_index_indexer(key)
-        else:
-            # asarray can be unsafe, NumPy strings are weird
-            keyarr = com.asarray_tuplesafe(key)
-
-        if is_integer_dtype(keyarr):
-            # Cast the indexer to uint64 if possible so
-            # that the values returned from indexing are
-            # also uint64.
-            keyarr = labels._convert_arr_indexer(keyarr)
-
-            if not labels.is_integer():
-                keyarr = ensure_platform_int(keyarr)
-                return labels.take(keyarr)
-
-        return keyarr
-
-
 class _LocationIndexer(_NDFrameIndexer):
     def __getitem__(self, key):
         if type(key) is tuple:
diff --git a/pandas/tests/frame/indexing/test_indexing.py b/pandas/tests/frame/indexing/test_indexing.py
index 716be92eb..cd384d6fd 100644
--- a/pandas/tests/frame/indexing/test_indexing.py
+++ b/pandas/tests/frame/indexing/test_indexing.py
@@ -1,6 +1,5 @@
 from datetime import date, datetime, time, timedelta
 import re
-from warnings import catch_warnings, simplefilter
 
 import numpy as np
 import pytest
@@ -396,10 +395,8 @@ class TestDataFrameIndexing:
         expected = df.loc[df.index[:-1]]
         tm.assert_frame_equal(result, expected)
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[[1, 10]]
-            expected = df.ix[Index([1, 10], dtype=object)]
+        result = df.loc[[1, 10]]
+        expected = df.loc[Index([1, 10])]
         tm.assert_frame_equal(result, expected)
 
         # 11320
@@ -419,53 +416,6 @@ class TestDataFrameIndexing:
         expected = df.iloc[:, [1]]
         tm.assert_frame_equal(result, expected)
 
-    def test_getitem_setitem_ix_negative_integers(self, float_frame):
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = float_frame.ix[:, -1]
-        tm.assert_series_equal(result, float_frame["D"])
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = float_frame.ix[:, [-1]]
-        tm.assert_frame_equal(result, float_frame[["D"]])
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = float_frame.ix[:, [-1, -2]]
-        tm.assert_frame_equal(result, float_frame[["D", "C"]])
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            float_frame.ix[:, [-1]] = 0
-        assert (float_frame["D"] == 0).all()
-
-        df = DataFrame(np.random.randn(8, 4))
-        # ix does label-based indexing when having an integer index
-        msg = "\"None of [Int64Index([-1], dtype='int64')] are in the [index]\""
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            with pytest.raises(KeyError, match=re.escape(msg)):
-                df.ix[[-1]]
-
-        msg = "\"None of [Int64Index([-1], dtype='int64')] are in the [columns]\""
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            with pytest.raises(KeyError, match=re.escape(msg)):
-                df.ix[:, [-1]]
-
-        # #1942
-        a = DataFrame(np.random.randn(20, 2), index=[chr(x + 65) for x in range(20)])
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            a.ix[-1] = a.ix[-2]
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_series_equal(a.ix[-1], a.ix[-2], check_names=False)
-            assert a.ix[-1].name == "T"
-            assert a.ix[-2].name == "S"
-
     def test_getattr(self, float_frame):
         tm.assert_series_equal(float_frame.A, float_frame["A"])
         msg = "'DataFrame' object has no attribute 'NONEXISTENT_NAME'"
@@ -848,55 +798,6 @@ class TestDataFrameIndexing:
         del f["B"]
         assert len(f.columns) == 2
 
-    def test_getitem_fancy_2d(self, float_frame):
-        f = float_frame
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(f.ix[:, ["B", "A"]], f.reindex(columns=["B", "A"]))
-
-        subidx = float_frame.index[[5, 4, 1]]
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(
-                f.ix[subidx, ["B", "A"]], f.reindex(index=subidx, columns=["B", "A"])
-            )
-
-        # slicing rows, etc.
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(f.ix[5:10], f[5:10])
-            tm.assert_frame_equal(f.ix[5:10, :], f[5:10])
-            tm.assert_frame_equal(
-                f.ix[:5, ["A", "B"]], f.reindex(index=f.index[:5], columns=["A", "B"])
-            )
-
-        # slice rows with labels, inclusive!
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            expected = f.ix[5:11]
-            result = f.ix[f.index[5] : f.index[10]]
-        tm.assert_frame_equal(expected, result)
-
-        # slice columns
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(f.ix[:, :2], f.reindex(columns=["A", "B"]))
-
-        # get view
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            exp = f.copy()
-            f.ix[5:10].values[:] = 5
-            exp.values[5:10] = 5
-            tm.assert_frame_equal(f, exp)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            msg = "Cannot index with multidimensional key"
-            with pytest.raises(ValueError, match=msg):
-                f.ix[f > 0.5]
-
     def test_slice_floats(self):
         index = [52195.504153, 52196.303147, 52198.369883]
         df = DataFrame(np.random.rand(3, 2), index=index)
@@ -945,119 +846,6 @@ class TestDataFrameIndexing:
         with pytest.raises(KeyError, match=r"^3$"):
             df2.loc[3:11] = 0
 
-    def test_setitem_fancy_2d(self, float_frame):
-
-        # case 1
-        frame = float_frame.copy()
-        expected = frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[:, ["B", "A"]] = 1
-        expected["B"] = 1.0
-        expected["A"] = 1.0
-        tm.assert_frame_equal(frame, expected)
-
-        # case 2
-        frame = float_frame.copy()
-        frame2 = float_frame.copy()
-
-        expected = frame.copy()
-
-        subidx = float_frame.index[[5, 4, 1]]
-        values = np.random.randn(3, 2)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[subidx, ["B", "A"]] = values
-            frame2.ix[[5, 4, 1], ["B", "A"]] = values
-
-            expected["B"].ix[subidx] = values[:, 0]
-            expected["A"].ix[subidx] = values[:, 1]
-
-        tm.assert_frame_equal(frame, expected)
-        tm.assert_frame_equal(frame2, expected)
-
-        # case 3: slicing rows, etc.
-        frame = float_frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            expected1 = float_frame.copy()
-            frame.ix[5:10] = 1.0
-            expected1.values[5:10] = 1.0
-        tm.assert_frame_equal(frame, expected1)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            expected2 = float_frame.copy()
-            arr = np.random.randn(5, len(frame.columns))
-            frame.ix[5:10] = arr
-            expected2.values[5:10] = arr
-        tm.assert_frame_equal(frame, expected2)
-
-        # case 4
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame = float_frame.copy()
-            frame.ix[5:10, :] = 1.0
-            tm.assert_frame_equal(frame, expected1)
-            frame.ix[5:10, :] = arr
-        tm.assert_frame_equal(frame, expected2)
-
-        # case 5
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame = float_frame.copy()
-            frame2 = float_frame.copy()
-
-            expected = float_frame.copy()
-            values = np.random.randn(5, 2)
-
-            frame.ix[:5, ["A", "B"]] = values
-            expected["A"][:5] = values[:, 0]
-            expected["B"][:5] = values[:, 1]
-        tm.assert_frame_equal(frame, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame2.ix[:5, [0, 1]] = values
-        tm.assert_frame_equal(frame2, expected)
-
-        # case 6: slice rows with labels, inclusive!
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame = float_frame.copy()
-            expected = float_frame.copy()
-
-            frame.ix[frame.index[5] : frame.index[10]] = 5.0
-            expected.values[5:11] = 5
-        tm.assert_frame_equal(frame, expected)
-
-        # case 7: slice columns
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame = float_frame.copy()
-            frame2 = float_frame.copy()
-            expected = float_frame.copy()
-
-            # slice indices
-            frame.ix[:, 1:3] = 4.0
-            expected.values[:, 1:3] = 4.0
-            tm.assert_frame_equal(frame, expected)
-
-            # slice with labels
-            frame.ix[:, "B":"C"] = 4.0
-            tm.assert_frame_equal(frame, expected)
-
-        # new corner case of boolean slicing / setting
-        frame = DataFrame(zip([2, 3, 9, 6, 7], [np.nan] * 5), columns=["a", "b"])
-        lst = [100]
-        lst.extend([np.nan] * 4)
-        expected = DataFrame(zip([100, 3, 9, 6, 7], lst), columns=["a", "b"])
-        frame[frame["a"] == 2] = 100
-        tm.assert_frame_equal(frame, expected)
-
     def test_fancy_getitem_slice_mixed(self, float_frame, float_string_frame):
         sliced = float_string_frame.iloc[:, -3:]
         assert sliced["D"].dtype == np.float64
@@ -1071,194 +859,6 @@ class TestDataFrameIndexing:
 
         assert (float_frame["C"] == 4).all()
 
-    def test_fancy_setitem_int_labels(self):
-        # integer index defers to label-based indexing
-
-        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tmp = df.copy()
-            exp = df.copy()
-            tmp.ix[[0, 2, 4]] = 5
-            exp.values[:3] = 5
-        tm.assert_frame_equal(tmp, exp)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tmp = df.copy()
-            exp = df.copy()
-            tmp.ix[6] = 5
-            exp.values[3] = 5
-        tm.assert_frame_equal(tmp, exp)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tmp = df.copy()
-            exp = df.copy()
-            tmp.ix[:, 2] = 5
-
-        # tmp correctly sets the dtype
-        # so match the exp way
-        exp[2] = 5
-        tm.assert_frame_equal(tmp, exp)
-
-    def test_fancy_getitem_int_labels(self):
-        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[[4, 2, 0], [2, 0]]
-            expected = df.reindex(index=[4, 2, 0], columns=[2, 0])
-        tm.assert_frame_equal(result, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[[4, 2, 0]]
-            expected = df.reindex(index=[4, 2, 0])
-        tm.assert_frame_equal(result, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[4]
-            expected = df.xs(4)
-        tm.assert_series_equal(result, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[:, 3]
-            expected = df[3]
-        tm.assert_series_equal(result, expected)
-
-    def test_fancy_index_int_labels_exceptions(self, float_frame):
-        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-
-            # labels that aren't contained
-            with pytest.raises(KeyError, match=r"\[1\] not in index"):
-                df.ix[[0, 1, 2], [2, 3, 4]] = 5
-
-            # try to set indices not contained in frame
-            msg = (
-                r"None of \[Index\(\['foo', 'bar', 'baz'\],"
-                r" dtype='object'\)\] are in the \[index\]"
-            )
-            with pytest.raises(KeyError, match=msg):
-                float_frame.ix[["foo", "bar", "baz"]] = 1
-            msg = (
-                r"None of \[Index\(\['E'\], dtype='object'\)\] are in the"
-                r" \[columns\]"
-            )
-            with pytest.raises(KeyError, match=msg):
-                float_frame.ix[:, ["E"]] = 1
-
-            # FIXME: don't leave commented-out
-            # partial setting now allows this GH2578
-            # pytest.raises(KeyError, float_frame.ix.__setitem__,
-            #               (slice(None, None), 'E'), 1)
-
-    def test_setitem_fancy_mixed_2d(self, float_string_frame):
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            float_string_frame.ix[:5, ["C", "B", "A"]] = 5
-            result = float_string_frame.ix[:5, ["C", "B", "A"]]
-            assert (result.values == 5).all()
-
-            float_string_frame.ix[5] = np.nan
-            assert isna(float_string_frame.ix[5]).all()
-
-            float_string_frame.ix[5] = float_string_frame.ix[6]
-            tm.assert_series_equal(
-                float_string_frame.ix[5], float_string_frame.ix[6], check_names=False
-            )
-
-        # #1432
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df = DataFrame({1: [1.0, 2.0, 3.0], 2: [3, 4, 5]})
-            assert df._is_mixed_type
-
-            df.ix[1] = [5, 10]
-
-            expected = DataFrame({1: [1.0, 5.0, 3.0], 2: [3, 10, 5]})
-
-            tm.assert_frame_equal(df, expected)
-
-    def test_ix_align(self):
-        b = Series(np.random.randn(10), name=0).sort_values()
-        df_orig = DataFrame(np.random.randn(10, 4))
-        df = df_orig.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df.ix[:, 0] = b
-            tm.assert_series_equal(df.ix[:, 0].reindex(b.index), b)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            dft = df_orig.T
-            dft.ix[0, :] = b
-            tm.assert_series_equal(dft.ix[0, :].reindex(b.index), b)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df = df_orig.copy()
-            df.ix[:5, 0] = b
-            s = df.ix[:5, 0]
-            tm.assert_series_equal(s, b.reindex(s.index))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            dft = df_orig.T
-            dft.ix[0, :5] = b
-            s = dft.ix[0, :5]
-            tm.assert_series_equal(s, b.reindex(s.index))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df = df_orig.copy()
-            idx = [0, 1, 3, 5]
-            df.ix[idx, 0] = b
-            s = df.ix[idx, 0]
-            tm.assert_series_equal(s, b.reindex(s.index))
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            dft = df_orig.T
-            dft.ix[0, idx] = b
-            s = dft.ix[0, idx]
-            tm.assert_series_equal(s, b.reindex(s.index))
-
-    def test_ix_frame_align(self):
-        b = DataFrame(np.random.randn(3, 4))
-        df_orig = DataFrame(np.random.randn(10, 4))
-        df = df_orig.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df.ix[:3] = b
-            out = b.ix[:3]
-            tm.assert_frame_equal(out, b)
-
-        b.sort_index(inplace=True)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df = df_orig.copy()
-            df.ix[[0, 1, 2]] = b
-            out = df.ix[[0, 1, 2]].reindex(b.index)
-            tm.assert_frame_equal(out, b)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            df = df_orig.copy()
-            df.ix[:3] = b
-            out = df.ix[:3]
-            tm.assert_frame_equal(out, b.reindex(out.index))
-
     def test_getitem_setitem_non_ix_labels(self):
         df = tm.makeTimeDataFrame()
 
@@ -1285,6 +885,7 @@ class TestDataFrameIndexing:
         xp = df.reindex([0])
         tm.assert_frame_equal(rs, xp)
 
+        # FIXME: dont leave commented-out
         """ #1321
         df = DataFrame(np.random.randn(3, 2))
         rs = df.loc[df.index==0, df.columns==1]
@@ -1292,168 +893,6 @@ class TestDataFrameIndexing:
         tm.assert_frame_equal(rs, xp)
         """
 
-    def test_ix_multi_take_nonint_index(self):
-        df = DataFrame(np.random.randn(3, 2), index=["x", "y", "z"], columns=["a", "b"])
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            rs = df.ix[[0], [0]]
-        xp = df.reindex(["x"], columns=["a"])
-        tm.assert_frame_equal(rs, xp)
-
-    def test_ix_multi_take_multiindex(self):
-        df = DataFrame(
-            np.random.randn(3, 2),
-            index=["x", "y", "z"],
-            columns=[["a", "b"], ["1", "2"]],
-        )
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            rs = df.ix[[0], [0]]
-        xp = df.reindex(["x"], columns=[("a", "1")])
-        tm.assert_frame_equal(rs, xp)
-
-    def test_ix_dup(self):
-        idx = Index(["a", "a", "b", "c", "d", "d"])
-        df = DataFrame(np.random.randn(len(idx), 3), idx)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            sub = df.ix[:"d"]
-            tm.assert_frame_equal(sub, df)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            sub = df.ix["a":"c"]
-            tm.assert_frame_equal(sub, df.ix[0:4])
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            sub = df.ix["b":"d"]
-            tm.assert_frame_equal(sub, df.ix[2:])
-
-    def test_getitem_fancy_1d(self, float_frame, float_string_frame):
-        f = float_frame
-
-        # return self if no slicing...for now
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            assert f.ix[:, :] is f
-
-        # low dimensional slice
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            xs1 = f.ix[2, ["C", "B", "A"]]
-        xs2 = f.xs(f.index[2]).reindex(["C", "B", "A"])
-        tm.assert_series_equal(xs1, xs2)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            ts1 = f.ix[5:10, 2]
-        ts2 = f[f.columns[2]][5:10]
-        tm.assert_series_equal(ts1, ts2)
-
-        # positional xs
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            xs1 = f.ix[0]
-        xs2 = f.xs(f.index[0])
-        tm.assert_series_equal(xs1, xs2)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            xs1 = f.ix[f.index[5]]
-        xs2 = f.xs(f.index[5])
-        tm.assert_series_equal(xs1, xs2)
-
-        # single column
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_series_equal(f.ix[:, "A"], f["A"])
-
-        # return view
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            exp = f.copy()
-            exp.values[5] = 4
-            f.ix[5][:] = 4
-        tm.assert_frame_equal(exp, f)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            exp.values[:, 1] = 6
-            f.ix[:, 1][:] = 6
-        tm.assert_frame_equal(exp, f)
-
-        # slice of mixed-frame
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            xs = float_string_frame.ix[5]
-        exp = float_string_frame.xs(float_string_frame.index[5])
-        tm.assert_series_equal(xs, exp)
-
-    def test_setitem_fancy_1d(self, float_frame):
-
-        # case 1: set cross-section for indices
-        frame = float_frame.copy()
-        expected = float_frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[2, ["C", "B", "A"]] = [1.0, 2.0, 3.0]
-        expected["C"][2] = 1.0
-        expected["B"][2] = 2.0
-        expected["A"][2] = 3.0
-        tm.assert_frame_equal(frame, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame2 = float_frame.copy()
-            frame2.ix[2, [3, 2, 1]] = [1.0, 2.0, 3.0]
-        tm.assert_frame_equal(frame, expected)
-
-        # case 2, set a section of a column
-        frame = float_frame.copy()
-        expected = float_frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            vals = np.random.randn(5)
-            expected.values[5:10, 2] = vals
-            frame.ix[5:10, 2] = vals
-        tm.assert_frame_equal(frame, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame2 = float_frame.copy()
-            frame2.ix[5:10, "B"] = vals
-        tm.assert_frame_equal(frame, expected)
-
-        # case 3: full xs
-        frame = float_frame.copy()
-        expected = float_frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[4] = 5.0
-            expected.values[4] = 5.0
-        tm.assert_frame_equal(frame, expected)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[frame.index[4]] = 6.0
-            expected.values[4] = 6.0
-        tm.assert_frame_equal(frame, expected)
-
-        # single column
-        frame = float_frame.copy()
-        expected = float_frame.copy()
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            frame.ix[:, "A"] = 7.0
-            expected["A"] = 7.0
-        tm.assert_frame_equal(frame, expected)
-
     def test_getitem_fancy_scalar(self, float_frame):
         f = float_frame
         ix = f.loc
@@ -1975,15 +1414,11 @@ class TestDataFrameIndexing:
         with pytest.raises(KeyError, match=r"^0$"):
             df._get_value(0, 1)
 
+    # TODO: rename?  remove?
     def test_single_element_ix_dont_upcast(self, float_frame):
         float_frame["E"] = 1
         assert issubclass(float_frame["E"].dtype.type, (int, np.integer))
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = float_frame.ix[float_frame.index[5], "E"]
-            assert is_integer(result)
-
         result = float_frame.loc[float_frame.index[5], "E"]
         assert is_integer(result)
 
@@ -1991,18 +1426,10 @@ class TestDataFrameIndexing:
         df = pd.DataFrame(dict(a=[1.23]))
         df["b"] = 666
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[0, "b"]
-        assert is_integer(result)
         result = df.loc[0, "b"]
         assert is_integer(result)
 
         expected = Series([666], [0], name="b")
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[[0], "b"]
-        tm.assert_series_equal(result, expected)
         result = df.loc[[0], "b"]
         tm.assert_series_equal(result, expected)
 
@@ -2070,45 +1497,12 @@ class TestDataFrameIndexing:
         df = DataFrame(np.random.rand(3, 3), columns=list("ABC"), index=list("aab"))
 
         result = df.iloc[0]
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result2 = df.ix[0]
         assert isinstance(result, Series)
         tm.assert_almost_equal(result.values, df.values[0])
-        tm.assert_series_equal(result, result2)
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.T.iloc[:, 0]
-            result2 = df.T.ix[:, 0]
+        result = df.T.iloc[:, 0]
         assert isinstance(result, Series)
         tm.assert_almost_equal(result.values, df.values[0])
-        tm.assert_series_equal(result, result2)
-
-        # multiindex
-        df = DataFrame(
-            np.random.randn(3, 3),
-            columns=[["i", "i", "j"], ["A", "A", "B"]],
-            index=[["i", "i", "j"], ["X", "X", "Y"]],
-        )
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            rs = df.iloc[0]
-            xp = df.ix[0]
-        tm.assert_series_equal(rs, xp)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            rs = df.iloc[:, 0]
-            xp = df.T.ix[0]
-        tm.assert_series_equal(rs, xp)
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            rs = df.iloc[:, [0]]
-            xp = df.ix[:, [0]]
-        tm.assert_frame_equal(rs, xp)
 
         # #2259
         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=[1, 1, 2])
@@ -2353,9 +1747,6 @@ class TestDataFrameIndexing:
         )
         expect = df.iloc[1:]
         tm.assert_frame_equal(df.loc[0.2], expect)
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(df.ix[0.2], expect)
 
         expect = df.iloc[1:, 0]
         tm.assert_series_equal(df.loc[0.2, "a"], expect)
@@ -2363,9 +1754,6 @@ class TestDataFrameIndexing:
         df.index = [1, 0.2, 0.2]
         expect = df.iloc[1:]
         tm.assert_frame_equal(df.loc[0.2], expect)
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(df.ix[0.2], expect)
 
         expect = df.iloc[1:, 0]
         tm.assert_series_equal(df.loc[0.2, "a"], expect)
@@ -2375,9 +1763,6 @@ class TestDataFrameIndexing:
         )
         expect = df.iloc[1:-1]
         tm.assert_frame_equal(df.loc[0.2], expect)
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(df.ix[0.2], expect)
 
         expect = df.iloc[1:-1, 0]
         tm.assert_series_equal(df.loc[0.2, "a"], expect)
@@ -2385,9 +1770,6 @@ class TestDataFrameIndexing:
         df.index = [0.1, 0.2, 2, 0.2]
         expect = df.iloc[[1, -1]]
         tm.assert_frame_equal(df.loc[0.2], expect)
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            tm.assert_frame_equal(df.ix[0.2], expect)
 
         expect = df.iloc[[1, -1], 0]
         tm.assert_series_equal(df.loc[0.2, "a"], expect)
@@ -2616,11 +1998,6 @@ class TestDataFrameIndexing:
         index = Index([idx1, idx2], name="composite_index", tupleize_cols=False)
         df = DataFrame([(1, 2), (3, 4)], index=index, columns=["A", "B"])
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            result = df.ix[IndexType("foo", "bar")]["A"]
-        assert result == 1
-
         result = df.loc[IndexType("foo", "bar")]["A"]
         assert result == 1
 
diff --git a/pandas/tests/indexing/common.py b/pandas/tests/indexing/common.py
index e5b2c83f2..08e8dbad4 100644
--- a/pandas/tests/indexing/common.py
+++ b/pandas/tests/indexing/common.py
@@ -1,6 +1,6 @@
 """ common utilities """
 import itertools
-from warnings import catch_warnings, filterwarnings
+from warnings import catch_warnings
 
 import numpy as np
 
@@ -136,21 +136,18 @@ class Base:
 
         return xp
 
-    def get_value(self, f, i, values=False):
+    def get_value(self, name, f, i, values=False):
         """ return the value for the location i """
 
         # check against values
         if values:
             return f.values[i]
 
-        # this is equiv of f[col][row].....
-        # v = f
-        # for a in reversed(i):
-        #    v = v.__getitem__(a)
-        # return v
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            return f.ix[i]
+        elif name == "iat":
+            return f.iloc[i]
+        else:
+            assert name == "at"
+            return f.loc[i]
 
     def check_values(self, f, func, values=False):
 
@@ -183,16 +180,11 @@ class Base:
             try:
                 rs = getattr(obj, method1).__getitem__(_axify(obj, key1, axis))
 
-                with catch_warnings(record=True):
-                    filterwarnings("ignore", "\\n.ix", FutureWarning)
-                    try:
-                        xp = self.get_result(
-                            obj=obj, method=method2, key=key2, axis=axis
-                        )
-                    except (KeyError, IndexError):
-                        # TODO: why is this allowed?
-                        result = "no comp"
-                        return
+                try:
+                    xp = self.get_result(obj=obj, method=method2, key=key2, axis=axis)
+                except (KeyError, IndexError):
+                    # TODO: why is this allowed?
+                    return
 
                 if is_scalar(rs) and is_scalar(xp):
                     assert rs == xp
diff --git a/pandas/tests/indexing/multiindex/test_slice.py b/pandas/tests/indexing/multiindex/test_slice.py
index f279b5517..ee0f160b3 100644
--- a/pandas/tests/indexing/multiindex/test_slice.py
+++ b/pandas/tests/indexing/multiindex/test_slice.py
@@ -1,5 +1,3 @@
-from warnings import catch_warnings
-
 import numpy as np
 import pytest
 
@@ -12,7 +10,6 @@ from pandas.tests.indexing.common import _mklbl
 import pandas.util.testing as tm
 
 
-@pytest.mark.filterwarnings("ignore:\\n.ix:FutureWarning")
 class TestMultiIndexSlicers:
     def test_per_axis_per_level_getitem(self):
 
@@ -675,8 +672,6 @@ class TestMultiIndexSlicers:
         def assert_slices_equivalent(l_slc, i_slc):
             tm.assert_series_equal(s.loc[l_slc], s.iloc[i_slc])
             tm.assert_series_equal(s[l_slc], s.iloc[i_slc])
-            with catch_warnings(record=True):
-                tm.assert_series_equal(s.ix[l_slc], s.iloc[i_slc])
 
         assert_slices_equivalent(SLC[::-1], SLC[::-1])
 
diff --git a/pandas/tests/indexing/test_chaining_and_caching.py b/pandas/tests/indexing/test_chaining_and_caching.py
index 6e26d407a..760bb6555 100644
--- a/pandas/tests/indexing/test_chaining_and_caching.py
+++ b/pandas/tests/indexing/test_chaining_and_caching.py
@@ -361,13 +361,12 @@ class TestChaining:
         result4 = df["A"].iloc[2]
         check(result4, expected)
 
-    @pytest.mark.filterwarnings("ignore::FutureWarning")
     def test_cache_updating(self):
         # GH 4939, make sure to update the cache on setitem
 
         df = tm.makeDataFrame()
         df["A"]  # cache series
-        df.ix["Hello Friend"] = df.ix[0]
+        df.loc["Hello Friend"] = df.iloc[0]
         assert "Hello Friend" in df["A"].index
         assert "Hello Friend" in df["B"].index
 
diff --git a/pandas/tests/indexing/test_floats.py b/pandas/tests/indexing/test_floats.py
index cdacecc6c..52d0e30f0 100644
--- a/pandas/tests/indexing/test_floats.py
+++ b/pandas/tests/indexing/test_floats.py
@@ -137,9 +137,8 @@ class TestFloatIndexers:
                 elif s.index.inferred_type in ["datetime64", "timedelta64", "period"]:
 
                     # these should prob work
-                    # and are inconsisten between series/dataframe ATM
-                    # for idxr in [lambda x: x.ix,
-                    #             lambda x: x]:
+                    # and are inconsistent between series/dataframe ATM
+                    # for idxr in [lambda x: x]:
                     #    s2 = s.copy()
                     #
                     #    with pytest.raises(TypeError):
diff --git a/pandas/tests/indexing/test_iloc.py b/pandas/tests/indexing/test_iloc.py
index f9bded5b2..2f27757d6 100644
--- a/pandas/tests/indexing/test_iloc.py
+++ b/pandas/tests/indexing/test_iloc.py
@@ -1,6 +1,6 @@
 """ test positional based indexing with iloc """
 
-from warnings import catch_warnings, filterwarnings, simplefilter
+from warnings import catch_warnings, simplefilter
 
 import numpy as np
 import pytest
@@ -135,26 +135,22 @@ class TestiLoc(Base):
             df.iloc[index_vals, column_vals]
 
     def test_iloc_getitem_int(self):
-
         # integer
-        self.check_result("iloc", 2, "ix", {0: 4, 1: 6, 2: 8}, typs=["ints", "uints"])
         self.check_result(
             "iloc",
             2,
-            "indexer",
+            "iloc",
             2,
             typs=["labels", "mixed", "ts", "floats", "empty"],
             fails=IndexError,
         )
 
     def test_iloc_getitem_neg_int(self):
-
         # neg integer
-        self.check_result("iloc", -1, "ix", {0: 6, 1: 9, 2: 12}, typs=["ints", "uints"])
         self.check_result(
             "iloc",
             -1,
-            "indexer",
+            "iloc",
             -1,
             typs=["labels", "mixed", "ts", "floats", "empty"],
             fails=IndexError,
@@ -187,51 +183,17 @@ class TestiLoc(Base):
         tm.assert_numpy_array_equal(array_with_neg_numbers, array_copy)
 
     def test_iloc_getitem_list_int(self):
-
-        # list of ints
         self.check_result(
             "iloc",
             [0, 1, 2],
-            "ix",
-            {0: [0, 2, 4], 1: [0, 3, 6], 2: [0, 4, 8]},
-            typs=["ints", "uints"],
-        )
-        self.check_result(
-            "iloc", [2], "ix", {0: [4], 1: [6], 2: [8]}, typs=["ints", "uints"],
-        )
-        self.check_result(
             "iloc",
             [0, 1, 2],
-            "indexer",
-            [0, 1, 2],
             typs=["labels", "mixed", "ts", "floats", "empty"],
             fails=IndexError,
         )
 
         # array of ints (GH5006), make sure that a single indexer is returning
         # the correct type
-        self.check_result(
-            "iloc",
-            np.array([0, 1, 2]),
-            "ix",
-            {0: [0, 2, 4], 1: [0, 3, 6], 2: [0, 4, 8]},
-            typs=["ints", "uints"],
-        )
-        self.check_result(
-            "iloc",
-            np.array([2]),
-            "ix",
-            {0: [4], 1: [6], 2: [8]},
-            typs=["ints", "uints"],
-        )
-        self.check_result(
-            "iloc",
-            np.array([0, 1, 2]),
-            "indexer",
-            [0, 1, 2],
-            typs=["labels", "mixed", "ts", "floats", "empty"],
-            fails=IndexError,
-        )
 
     def test_iloc_getitem_neg_int_can_reach_first_index(self):
         # GH10547 and GH10779
@@ -261,15 +223,6 @@ class TestiLoc(Base):
         tm.assert_series_equal(result, expected)
 
     def test_iloc_getitem_dups(self):
-
-        self.check_result(
-            "iloc",
-            [0, 1, 1, 3],
-            "ix",
-            {0: [0, 2, 2, 6], 1: [0, 3, 3, 9]},
-            typs=["ints", "uints"],
-        )
-
         # GH 6766
         df1 = DataFrame([{"A": None, "B": 1}, {"A": 2, "B": 2}])
         df2 = DataFrame([{"A": 3, "B": 3}, {"A": 4, "B": 4}])
@@ -284,30 +237,12 @@ class TestiLoc(Base):
         tm.assert_series_equal(result, expected)
 
     def test_iloc_getitem_array(self):
-
-        # array like
-        s = Series(index=range(1, 4), dtype=object)
-        self.check_result(
-            "iloc",
-            s.index,
-            "ix",
-            {0: [2, 4, 6], 1: [3, 6, 9], 2: [4, 8, 12]},
-            typs=["ints", "uints"],
-        )
+        # TODO: test something here?
+        pass
 
     def test_iloc_getitem_bool(self):
-
-        # boolean indexers
-        b = [True, False, True, False]
-        self.check_result("iloc", b, "ix", b, typs=["ints", "uints"])
-        self.check_result(
-            "iloc",
-            b,
-            "ix",
-            b,
-            typs=["labels", "mixed", "ts", "floats", "empty"],
-            fails=IndexError,
-        )
+        # TODO: test something here?
+        pass
 
     @pytest.mark.parametrize("index", [[True, False], [True, False, True, False]])
     def test_iloc_getitem_bool_diff_len(self, index):
@@ -320,23 +255,8 @@ class TestiLoc(Base):
             _ = s.iloc[index]
 
     def test_iloc_getitem_slice(self):
-
-        # slices
-        self.check_result(
-            "iloc",
-            slice(1, 3),
-            "ix",
-            {0: [2, 4], 1: [3, 6], 2: [4, 8]},
-            typs=["ints", "uints"],
-        )
-        self.check_result(
-            "iloc",
-            slice(1, 3),
-            "indexer",
-            slice(1, 3),
-            typs=["labels", "mixed", "ts", "floats", "empty"],
-            fails=IndexError,
-        )
+        # TODO: test something here?
+        pass
 
     def test_iloc_getitem_slice_dups(self):
 
@@ -441,69 +361,53 @@ class TestiLoc(Base):
         df.iloc[[1, 0], [0, 1]] = df.iloc[[1, 0], [0, 1]].reset_index(drop=True)
         tm.assert_frame_equal(df, expected)
 
+    # TODO: GH#27620 this test used to compare iloc against ix; check if this
+    #  is redundant with another test comparing iloc against loc
     def test_iloc_getitem_frame(self):
         df = DataFrame(
             np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0, 8, 2)
         )
 
         result = df.iloc[2]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            exp = df.ix[4]
+        exp = df.loc[4]
         tm.assert_series_equal(result, exp)
 
         result = df.iloc[2, 2]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            exp = df.ix[4, 4]
+        exp = df.loc[4, 4]
         assert result == exp
 
         # slice
         result = df.iloc[4:8]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[8:14]
+        expected = df.loc[8:14]
         tm.assert_frame_equal(result, expected)
 
         result = df.iloc[:, 2:3]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[:, 4:5]
+        expected = df.loc[:, 4:5]
         tm.assert_frame_equal(result, expected)
 
         # list of integers
         result = df.iloc[[0, 1, 3]]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[[0, 2, 6]]
+        expected = df.loc[[0, 2, 6]]
         tm.assert_frame_equal(result, expected)
 
         result = df.iloc[[0, 1, 3], [0, 1]]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[[0, 2, 6], [0, 2]]
+        expected = df.loc[[0, 2, 6], [0, 2]]
         tm.assert_frame_equal(result, expected)
 
         # neg indices
         result = df.iloc[[-1, 1, 3], [-1, 1]]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[[18, 2, 6], [6, 2]]
+        expected = df.loc[[18, 2, 6], [6, 2]]
         tm.assert_frame_equal(result, expected)
 
         # dups indices
         result = df.iloc[[-1, -1, 1, 3], [-1, 1]]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[[18, 18, 2, 6], [6, 2]]
+        expected = df.loc[[18, 18, 2, 6], [6, 2]]
         tm.assert_frame_equal(result, expected)
 
         # with index-like
         s = Series(index=range(1, 5), dtype=object)
         result = df.iloc[s.index]
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            expected = df.ix[[2, 4, 6, 8]]
+        expected = df.loc[[2, 4, 6, 8]]
         tm.assert_frame_equal(result, expected)
 
     def test_iloc_getitem_labelled_frame(self):
diff --git a/pandas/tests/indexing/test_ix.py b/pandas/tests/indexing/test_ix.py
deleted file mode 100644
index a46cd6516..000000000
--- a/pandas/tests/indexing/test_ix.py
+++ /dev/null
@@ -1,354 +0,0 @@
-""" test indexing with ix """
-
-from warnings import catch_warnings
-
-import numpy as np
-import pytest
-
-from pandas.core.dtypes.common import is_scalar
-
-import pandas as pd
-from pandas import DataFrame, Series, option_context
-import pandas.util.testing as tm
-
-
-def test_ix_deprecation():
-    # GH 15114
-
-    df = DataFrame({"A": [1, 2, 3]})
-    with tm.assert_produces_warning(FutureWarning, check_stacklevel=True):
-        df.ix[1, "A"]
-
-
-@pytest.mark.filterwarnings("ignore:\\n.ix:FutureWarning")
-class TestIX:
-    def test_ix_loc_setitem_consistency(self):
-
-        # GH 5771
-        # loc with slice and series
-        s = Series(0, index=[4, 5, 6])
-        s.loc[4:5] += 1
-        expected = Series([1, 1, 0], index=[4, 5, 6])
-        tm.assert_series_equal(s, expected)
-
-        # GH 5928
-        # chained indexing assignment
-        df = DataFrame({"a": [0, 1, 2]})
-        expected = df.copy()
-        with catch_warnings(record=True):
-            expected.ix[[0, 1, 2], "a"] = -expected.ix[[0, 1, 2], "a"]
-
-        with catch_warnings(record=True):
-            df["a"].ix[[0, 1, 2]] = -df["a"].ix[[0, 1, 2]]
-        tm.assert_frame_equal(df, expected)
-
-        df = DataFrame({"a": [0, 1, 2], "b": [0, 1, 2]})
-        with catch_warnings(record=True):
-            df["a"].ix[[0, 1, 2]] = -df["a"].ix[[0, 1, 2]].astype("float64") + 0.5
-        expected = DataFrame({"a": [0.5, -0.5, -1.5], "b": [0, 1, 2]})
-        tm.assert_frame_equal(df, expected)
-
-        # GH 8607
-        # ix setitem consistency
-        df = DataFrame(
-            {
-                "delta": [1174, 904, 161],
-                "elapsed": [7673, 9277, 1470],
-                "timestamp": [1413840976, 1413842580, 1413760580],
-            }
-        )
-        expected = DataFrame(
-            {
-                "delta": [1174, 904, 161],
-                "elapsed": [7673, 9277, 1470],
-                "timestamp": pd.to_datetime(
-                    [1413840976, 1413842580, 1413760580], unit="s"
-                ),
-            }
-        )
-
-        df2 = df.copy()
-        df2["timestamp"] = pd.to_datetime(df["timestamp"], unit="s")
-        tm.assert_frame_equal(df2, expected)
-
-        df2 = df.copy()
-        df2.loc[:, "timestamp"] = pd.to_datetime(df["timestamp"], unit="s")
-        tm.assert_frame_equal(df2, expected)
-
-        df2 = df.copy()
-        with catch_warnings(record=True):
-            df2.ix[:, 2] = pd.to_datetime(df["timestamp"], unit="s")
-        tm.assert_frame_equal(df2, expected)
-
-    def test_ix_loc_consistency(self):
-
-        # GH 8613
-        # some edge cases where ix/loc should return the same
-        # this is not an exhaustive case
-
-        def compare(result, expected):
-            if is_scalar(expected):
-                assert result == expected
-            else:
-                assert expected.equals(result)
-
-        # failure cases for .loc, but these work for .ix
-        df = DataFrame(np.random.randn(5, 4), columns=list("ABCD"))
-        for key in [
-            slice(1, 3),
-            tuple([slice(0, 2), slice(0, 2)]),
-            tuple([slice(0, 2), df.columns[0:2]]),
-        ]:
-
-            for index in [
-                tm.makeStringIndex,
-                tm.makeUnicodeIndex,
-                tm.makeDateIndex,
-                tm.makePeriodIndex,
-                tm.makeTimedeltaIndex,
-            ]:
-                df.index = index(len(df.index))
-                with catch_warnings(record=True):
-                    df.ix[key]
-
-                msg = (
-                    r"cannot do slice indexing"
-                    r" on {klass} with these indexers \[(0|1)\] of"
-                    r" {kind}".format(klass=type(df.index), kind=str(int))
-                )
-                with pytest.raises(TypeError, match=msg):
-                    df.loc[key]
-
-        df = DataFrame(
-            np.random.randn(5, 4),
-            columns=list("ABCD"),
-            index=pd.date_range("2012-01-01", periods=5),
-        )
-
-        for key in [
-            "2012-01-03",
-            "2012-01-31",
-            slice("2012-01-03", "2012-01-03"),
-            slice("2012-01-03", "2012-01-04"),
-            slice("2012-01-03", "2012-01-06", 2),
-            slice("2012-01-03", "2012-01-31"),
-            tuple([[True, True, True, False, True]]),
-        ]:
-
-            # getitem
-
-            # if the expected raises, then compare the exceptions
-            try:
-                with catch_warnings(record=True):
-                    expected = df.ix[key]
-            except KeyError:
-                with pytest.raises(KeyError, match=r"^'2012-01-31'$"):
-                    df.loc[key]
-                continue
-
-            result = df.loc[key]
-            compare(result, expected)
-
-            # setitem
-            df1 = df.copy()
-            df2 = df.copy()
-
-            with catch_warnings(record=True):
-                df1.ix[key] = 10
-            df2.loc[key] = 10
-            compare(df2, df1)
-
-        # edge cases
-        s = Series([1, 2, 3, 4], index=list("abde"))
-
-        result1 = s["a":"c"]
-        with catch_warnings(record=True):
-            result2 = s.ix["a":"c"]
-        result3 = s.loc["a":"c"]
-        tm.assert_series_equal(result1, result2)
-        tm.assert_series_equal(result1, result3)
-
-        # now work rather than raising KeyError
-        s = Series(range(5), [-2, -1, 1, 2, 3])
-
-        with catch_warnings(record=True):
-            result1 = s.ix[-10:3]
-        result2 = s.loc[-10:3]
-        tm.assert_series_equal(result1, result2)
-
-        with catch_warnings(record=True):
-            result1 = s.ix[0:3]
-        result2 = s.loc[0:3]
-        tm.assert_series_equal(result1, result2)
-
-    def test_ix_weird_slicing(self):
-        # http://stackoverflow.com/q/17056560/1240268
-        df = DataFrame({"one": [1, 2, 3, np.nan, np.nan], "two": [1, 2, 3, 4, 5]})
-        df.loc[df["one"] > 1, "two"] = -df["two"]
-
-        expected = DataFrame(
-            {
-                "one": {0: 1.0, 1: 2.0, 2: 3.0, 3: np.nan, 4: np.nan},
-                "two": {0: 1, 1: -2, 2: -3, 3: 4, 4: 5},
-            }
-        )
-        tm.assert_frame_equal(df, expected)
-
-    def test_ix_assign_column_mixed(self, float_frame):
-        # GH #1142
-        df = float_frame
-        df["foo"] = "bar"
-
-        orig = df.loc[:, "B"].copy()
-        df.loc[:, "B"] = df.loc[:, "B"] + 1
-        tm.assert_series_equal(df.B, orig + 1)
-
-        # GH 3668, mixed frame with series value
-        df = DataFrame({"x": np.arange(10), "y": np.arange(10, 20), "z": "bar"})
-        expected = df.copy()
-
-        for i in range(5):
-            indexer = i * 2
-            v = 1000 + i * 200
-            expected.loc[indexer, "y"] = v
-            assert expected.loc[indexer, "y"] == v
-
-        df.loc[df.x % 2 == 0, "y"] = df.loc[df.x % 2 == 0, "y"] * 100
-        tm.assert_frame_equal(df, expected)
-
-        # GH 4508, making sure consistency of assignments
-        df = DataFrame({"a": [1, 2, 3], "b": [0, 1, 2]})
-        df.loc[[0, 2], "b"] = [100, -100]
-        expected = DataFrame({"a": [1, 2, 3], "b": [100, 1, -100]})
-        tm.assert_frame_equal(df, expected)
-
-        df = DataFrame({"a": list(range(4))})
-        df["b"] = np.nan
-        df.loc[[1, 3], "b"] = [100, -100]
-        expected = DataFrame({"a": [0, 1, 2, 3], "b": [np.nan, 100, np.nan, -100]})
-        tm.assert_frame_equal(df, expected)
-
-        # ok, but chained assignments are dangerous
-        # if we turn off chained assignment it will work
-        with option_context("chained_assignment", None):
-            df = DataFrame({"a": list(range(4))})
-            df["b"] = np.nan
-            df["b"].loc[[1, 3]] = [100, -100]
-            tm.assert_frame_equal(df, expected)
-
-    def test_ix_get_set_consistency(self):
-
-        # GH 4544
-        # ix/loc get/set not consistent when
-        # a mixed int/string index
-        df = DataFrame(
-            np.arange(16).reshape((4, 4)),
-            columns=["a", "b", 8, "c"],
-            index=["e", 7, "f", "g"],
-        )
-
-        with catch_warnings(record=True):
-            assert df.ix["e", 8] == 2
-        assert df.loc["e", 8] == 2
-
-        with catch_warnings(record=True):
-            df.ix["e", 8] = 42
-            assert df.ix["e", 8] == 42
-        assert df.loc["e", 8] == 42
-
-        df.loc["e", 8] = 45
-        with catch_warnings(record=True):
-            assert df.ix["e", 8] == 45
-        assert df.loc["e", 8] == 45
-
-    def test_ix_slicing_strings(self):
-        # see gh-3836
-        data = {
-            "Classification": ["SA EQUITY CFD", "bbb", "SA EQUITY", "SA SSF", "aaa"],
-            "Random": [1, 2, 3, 4, 5],
-            "X": ["correct", "wrong", "correct", "correct", "wrong"],
-        }
-        df = DataFrame(data)
-        x = df[~df.Classification.isin(["SA EQUITY CFD", "SA EQUITY", "SA SSF"])]
-        with catch_warnings(record=True):
-            df.ix[x.index, "X"] = df["Classification"]
-
-        expected = DataFrame(
-            {
-                "Classification": {
-                    0: "SA EQUITY CFD",
-                    1: "bbb",
-                    2: "SA EQUITY",
-                    3: "SA SSF",
-                    4: "aaa",
-                },
-                "Random": {0: 1, 1: 2, 2: 3, 3: 4, 4: 5},
-                "X": {0: "correct", 1: "bbb", 2: "correct", 3: "correct", 4: "aaa"},
-            }
-        )  # bug was 4: 'bbb'
-
-        tm.assert_frame_equal(df, expected)
-
-    def test_ix_setitem_out_of_bounds_axis_0(self):
-        df = DataFrame(
-            np.random.randn(2, 5),
-            index=["row{i}".format(i=i) for i in range(2)],
-            columns=["col{i}".format(i=i) for i in range(5)],
-        )
-        with catch_warnings(record=True):
-            msg = "cannot set by positional indexing with enlargement"
-            with pytest.raises(ValueError, match=msg):
-                df.ix[2, 0] = 100
-
-    def test_ix_setitem_out_of_bounds_axis_1(self):
-        df = DataFrame(
-            np.random.randn(5, 2),
-            index=["row{i}".format(i=i) for i in range(5)],
-            columns=["col{i}".format(i=i) for i in range(2)],
-        )
-        with catch_warnings(record=True):
-            msg = "cannot set by positional indexing with enlargement"
-            with pytest.raises(ValueError, match=msg):
-                df.ix[0, 2] = 100
-
-    def test_ix_empty_list_indexer_is_ok(self):
-        with catch_warnings(record=True):
-
-            df = tm.makeCustomDataframe(5, 2)
-            # vertical empty
-            tm.assert_frame_equal(
-                df.ix[:, []],
-                df.iloc[:, :0],
-                check_index_type=True,
-                check_column_type=True,
-            )
-            # horizontal empty
-            tm.assert_frame_equal(
-                df.ix[[], :],
-                df.iloc[:0, :],
-                check_index_type=True,
-                check_column_type=True,
-            )
-            # horizontal empty
-            tm.assert_frame_equal(
-                df.ix[[]], df.iloc[:0, :], check_index_type=True, check_column_type=True
-            )
-
-    def test_ix_duplicate_returns_series(self):
-        df = DataFrame(
-            np.random.randn(3, 3), index=[0.1, 0.2, 0.2], columns=list("abc")
-        )
-        with catch_warnings(record=True):
-            r = df.ix[0.2, "a"]
-        e = df.loc[0.2, "a"]
-        tm.assert_series_equal(r, e)
-
-    def test_ix_intervalindex(self):
-        # https://github.com/pandas-dev/pandas/issues/27865
-        df = DataFrame(
-            np.random.randn(5, 2),
-            index=pd.IntervalIndex.from_breaks([-np.inf, 0, 1, 2, 3, np.inf]),
-        )
-        result = df.ix[0:2, 0]
-        expected = df.iloc[0:2, 0]
-        tm.assert_series_equal(result, expected)
diff --git a/pandas/tests/indexing/test_loc.py b/pandas/tests/indexing/test_loc.py
index e5e899bfb..6f20ec649 100644
--- a/pandas/tests/indexing/test_loc.py
+++ b/pandas/tests/indexing/test_loc.py
@@ -1,7 +1,6 @@
 """ test label based indexing with loc """
 from io import StringIO
 import re
-from warnings import catch_warnings, filterwarnings
 
 import numpy as np
 import pytest
@@ -96,18 +95,12 @@ class TestLoc(Base):
     def test_loc_getitem_int(self):
 
         # int label
-        self.check_result("loc", 2, "ix", 2, typs=["ints", "uints"], axes=0)
-        self.check_result("loc", 3, "ix", 3, typs=["ints", "uints"], axes=1)
-        self.check_result("loc", 2, "ix", 2, typs=["label"], fails=KeyError)
+        self.check_result("loc", 2, "loc", 2, typs=["label"], fails=KeyError)
 
     def test_loc_getitem_label(self):
 
         # label
-        self.check_result("loc", "c", "ix", "c", typs=["labels"], axes=0)
-        self.check_result("loc", "null", "ix", "null", typs=["mixed"], axes=0)
-        self.check_result("loc", 8, "ix", 8, typs=["mixed"], axes=0)
-        self.check_result("loc", Timestamp("20130102"), "ix", 1, typs=["ts"], axes=0)
-        self.check_result("loc", "c", "ix", "c", typs=["empty"], fails=KeyError)
+        self.check_result("loc", "c", "loc", "c", typs=["empty"], fails=KeyError)
 
     def test_loc_getitem_label_out_of_range(self):
 
@@ -115,49 +108,28 @@ class TestLoc(Base):
         self.check_result(
             "loc",
             "f",
-            "ix",
+            "loc",
             "f",
             typs=["ints", "uints", "labels", "mixed", "ts"],
             fails=KeyError,
         )
         self.check_result("loc", "f", "ix", "f", typs=["floats"], fails=KeyError)
+        self.check_result("loc", "f", "loc", "f", typs=["floats"], fails=KeyError)
         self.check_result(
-            "loc", 20, "ix", 20, typs=["ints", "uints", "mixed"], fails=KeyError,
+            "loc", 20, "loc", 20, typs=["ints", "uints", "mixed"], fails=KeyError,
         )
-        self.check_result("loc", 20, "ix", 20, typs=["labels"], fails=TypeError)
-        self.check_result("loc", 20, "ix", 20, typs=["ts"], axes=0, fails=TypeError)
-        self.check_result("loc", 20, "ix", 20, typs=["floats"], axes=0, fails=KeyError)
+        self.check_result("loc", 20, "loc", 20, typs=["labels"], fails=TypeError)
+        self.check_result("loc", 20, "loc", 20, typs=["ts"], axes=0, fails=TypeError)
+        self.check_result("loc", 20, "loc", 20, typs=["floats"], axes=0, fails=KeyError)
 
     def test_loc_getitem_label_list(self):
-
+        # TODO: test something here?
         # list of labels
-        self.check_result(
-            "loc", [0, 2, 4], "ix", [0, 2, 4], typs=["ints", "uints"], axes=0,
-        )
-        self.check_result(
-            "loc", [3, 6, 9], "ix", [3, 6, 9], typs=["ints", "uints"], axes=1,
-        )
-        self.check_result(
-            "loc", ["a", "b", "d"], "ix", ["a", "b", "d"], typs=["labels"], axes=0,
-        )
-        self.check_result(
-            "loc", ["A", "B", "C"], "ix", ["A", "B", "C"], typs=["labels"], axes=1,
-        )
-        self.check_result(
-            "loc", [2, 8, "null"], "ix", [2, 8, "null"], typs=["mixed"], axes=0,
-        )
-        self.check_result(
-            "loc",
-            [Timestamp("20130102"), Timestamp("20130103")],
-            "ix",
-            [Timestamp("20130102"), Timestamp("20130103")],
-            typs=["ts"],
-            axes=0,
-        )
+        pass
 
     def test_loc_getitem_label_list_with_missing(self):
         self.check_result(
-            "loc", [0, 1, 2], "indexer", [0, 1, 2], typs=["empty"], fails=KeyError,
+            "loc", [0, 1, 2], "loc", [0, 1, 2], typs=["empty"], fails=KeyError,
         )
         self.check_result(
             "loc",
@@ -206,7 +178,7 @@ class TestLoc(Base):
         self.check_result(
             "loc",
             [20, 30, 40],
-            "ix",
+            "loc",
             [20, 30, 40],
             typs=["ints", "uints"],
             axes=1,
@@ -214,35 +186,15 @@ class TestLoc(Base):
         )
 
     def test_loc_getitem_label_array_like(self):
+        # TODO: test something?
         # array like
-        self.check_result(
-            "loc",
-            Series(index=[0, 2, 4], dtype=object).index,
-            "ix",
-            [0, 2, 4],
-            typs=["ints", "uints"],
-            axes=0,
-        )
-        self.check_result(
-            "loc",
-            Series(index=[3, 6, 9], dtype=object).index,
-            "ix",
-            [3, 6, 9],
-            typs=["ints", "uints"],
-            axes=1,
-        )
+        pass
 
     def test_loc_getitem_bool(self):
         # boolean indexers
         b = [True, False, True, False]
-        self.check_result(
-            "loc",
-            b,
-            "ix",
-            b,
-            typs=["ints", "uints", "labels", "mixed", "ts", "floats"],
-        )
-        self.check_result("loc", b, "ix", b, typs=["empty"], fails=IndexError)
+
+        self.check_result("loc", b, "loc", b, typs=["empty"], fails=IndexError)
 
     @pytest.mark.parametrize("index", [[True, False], [True, False, True, False]])
     def test_loc_getitem_bool_diff_len(self, index):
@@ -255,14 +207,8 @@ class TestLoc(Base):
             _ = s.loc[index]
 
     def test_loc_getitem_int_slice(self):
-
-        # ok
-        self.check_result(
-            "loc", slice(2, 4), "ix", [2, 4], typs=["ints", "uints"], axes=0,
-        )
-        self.check_result(
-            "loc", slice(3, 6), "ix", [3, 6], typs=["ints", "uints"], axes=1,
-        )
+        # TODO: test something here?
+        pass
 
     def test_loc_to_fail(self):
 
@@ -356,55 +302,34 @@ class TestLoc(Base):
     def test_loc_getitem_label_slice(self):
 
         # label slices (with ints)
+
+        # real label slices
+
+        # GH 14316
+
         self.check_result(
             "loc",
             slice(1, 3),
-            "ix",
+            "loc",
             slice(1, 3),
             typs=["labels", "mixed", "empty", "ts", "floats"],
             fails=TypeError,
         )
 
-        # real label slices
-        self.check_result(
-            "loc", slice("a", "c"), "ix", slice("a", "c"), typs=["labels"], axes=0,
-        )
-        self.check_result(
-            "loc", slice("A", "C"), "ix", slice("A", "C"), typs=["labels"], axes=1,
-        )
-
         self.check_result(
             "loc",
             slice("20130102", "20130104"),
-            "ix",
-            slice("20130102", "20130104"),
-            typs=["ts"],
-            axes=0,
-        )
-        self.check_result(
             "loc",
             slice("20130102", "20130104"),
-            "ix",
-            slice("20130102", "20130104"),
             typs=["ts"],
             axes=1,
             fails=TypeError,
         )
 
-        # GH 14316
-        self.check_result(
-            "loc",
-            slice("20130104", "20130102"),
-            "indexer",
-            [0, 1, 2],
-            typs=["ts_rev"],
-            axes=0,
-        )
-
         self.check_result(
             "loc",
             slice(2, 8),
-            "ix",
+            "loc",
             slice(2, 8),
             typs=["mixed"],
             axes=0,
@@ -413,7 +338,7 @@ class TestLoc(Base):
         self.check_result(
             "loc",
             slice(2, 8),
-            "ix",
+            "loc",
             slice(2, 8),
             typs=["mixed"],
             axes=1,
@@ -423,7 +348,7 @@ class TestLoc(Base):
         self.check_result(
             "loc",
             slice(2, 4, 2),
-            "ix",
+            "loc",
             slice(2, 4, 2),
             typs=["mixed"],
             axes=0,
@@ -898,11 +823,6 @@ Region_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No"""
         result = df.iloc[[0, 1]].index.name
         assert result == "index_name"
 
-        with catch_warnings(record=True):
-            filterwarnings("ignore", "\\n.ix", FutureWarning)
-            result = df.ix[[0, 1]].index.name
-        assert result == "index_name"
-
         result = df.loc[[0, 1]].index.name
         assert result == "index_name"
 
diff --git a/pandas/tests/indexing/test_partial.py b/pandas/tests/indexing/test_partial.py
index 3adc20633..15c65be37 100644
--- a/pandas/tests/indexing/test_partial.py
+++ b/pandas/tests/indexing/test_partial.py
@@ -1,11 +1,9 @@
 """
 test setting *parts* of objects both positionally and label based
 
-TOD: these should be split among the indexer tests
+TODO: these should be split among the indexer tests
 """
 
-from warnings import catch_warnings
-
 import numpy as np
 import pytest
 
@@ -15,7 +13,6 @@ import pandas.util.testing as tm
 
 
 class TestPartialSetting:
-    @pytest.mark.filterwarnings("ignore:\\n.ix:FutureWarning")
     def test_partial_setting(self):
 
         # GH2578, allow ix and friends to partially set
@@ -87,32 +84,28 @@ class TestPartialSetting:
         # single dtype frame, overwrite
         expected = DataFrame(dict({"A": [0, 2, 4], "B": [0, 2, 4]}))
         df = df_orig.copy()
-        with catch_warnings(record=True):
-            df.ix[:, "B"] = df.ix[:, "A"]
+        df.loc[:, "B"] = df.loc[:, "A"]
         tm.assert_frame_equal(df, expected)
 
         # mixed dtype frame, overwrite
         expected = DataFrame(dict({"A": [0, 2, 4], "B": Series([0, 2, 4])}))
         df = df_orig.copy()
         df["B"] = df["B"].astype(np.float64)
-        with catch_warnings(record=True):
-            df.ix[:, "B"] = df.ix[:, "A"]
+        df.loc[:, "B"] = df.loc[:, "A"]
         tm.assert_frame_equal(df, expected)
 
         # single dtype frame, partial setting
         expected = df_orig.copy()
         expected["C"] = df["A"]
         df = df_orig.copy()
-        with catch_warnings(record=True):
-            df.ix[:, "C"] = df.ix[:, "A"]
+        df.loc[:, "C"] = df.loc[:, "A"]
         tm.assert_frame_equal(df, expected)
 
         # mixed frame, partial setting
         expected = df_orig.copy()
         expected["C"] = df["A"]
         df = df_orig.copy()
-        with catch_warnings(record=True):
-            df.ix[:, "C"] = df.ix[:, "A"]
+        df.loc[:, "C"] = df.loc[:, "A"]
         tm.assert_frame_equal(df, expected)
 
         # GH 8473
@@ -328,7 +321,6 @@ class TestPartialSetting:
         result = ser.iloc[[1, 1, 0, 0]]
         tm.assert_series_equal(result, expected, check_index_type=True)
 
-    @pytest.mark.filterwarnings("ignore:\\n.ix")
     def test_partial_set_invalid(self):
 
         # GH 4940
@@ -339,26 +331,15 @@ class TestPartialSetting:
 
         # don't allow not string inserts
         with pytest.raises(TypeError):
-            with catch_warnings(record=True):
-                df.loc[100.0, :] = df.ix[0]
-
-        with pytest.raises(TypeError):
-            with catch_warnings(record=True):
-                df.loc[100, :] = df.ix[0]
+            df.loc[100.0, :] = df.iloc[0]
 
         with pytest.raises(TypeError):
-            with catch_warnings(record=True):
-                df.ix[100.0, :] = df.ix[0]
-
-        with pytest.raises(ValueError):
-            with catch_warnings(record=True):
-                df.ix[100, :] = df.ix[0]
+            df.loc[100, :] = df.iloc[0]
 
         # allow object conversion here
         df = orig.copy()
-        with catch_warnings(record=True):
-            df.loc["a", :] = df.ix[0]
-            exp = orig.append(Series(df.ix[0], name="a"))
+        df.loc["a", :] = df.iloc[0]
+        exp = orig.append(Series(df.iloc[0], name="a"))
         tm.assert_frame_equal(df, exp)
         tm.assert_index_equal(df.index, Index(orig.index.tolist() + ["a"]))
         assert df.index.dtype == "object"
diff --git a/pandas/tests/indexing/test_scalar.py b/pandas/tests/indexing/test_scalar.py
index b41b90cd9..ddaea5b59 100644
--- a/pandas/tests/indexing/test_scalar.py
+++ b/pandas/tests/indexing/test_scalar.py
@@ -16,7 +16,7 @@ class TestScalar(Base):
                 indicies = self.generate_indices(f, values)
                 for i in indicies:
                     result = getattr(f, func)[i]
-                    expected = self.get_value(f, i, values)
+                    expected = self.get_value(func, f, i, values)
                     tm.assert_almost_equal(result, expected)
 
         for kind in self._kinds:
@@ -44,7 +44,7 @@ class TestScalar(Base):
                 indicies = self.generate_indices(f, values)
                 for i in indicies:
                     getattr(f, func)[i] = 1
-                    expected = self.get_value(f, i, values)
+                    expected = self.get_value(func, f, i, values)
                     tm.assert_almost_equal(expected, 1)
 
         for kind in self._kinds:
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 204cdee2d..ae16d0fa6 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -2,7 +2,6 @@ import datetime
 from io import StringIO
 import itertools
 from itertools import product
-from warnings import catch_warnings, simplefilter
 
 import numpy as np
 from numpy.random import randn
@@ -209,11 +208,6 @@ class TestMultiLevel(Base):
         reindexed = self.frame.loc[[("foo", "one"), ("bar", "one")]]
         tm.assert_frame_equal(reindexed, expected)
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            reindexed = self.frame.ix[[("foo", "one"), ("bar", "one")]]
-        tm.assert_frame_equal(reindexed, expected)
-
     def test_reindex_preserve_levels(self):
         new_index = self.ymd.index[::10]
         chunk = self.ymd.reindex(new_index)
@@ -222,11 +216,6 @@ class TestMultiLevel(Base):
         chunk = self.ymd.loc[new_index]
         assert chunk.index is new_index
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            chunk = self.ymd.ix[new_index]
-        assert chunk.index is new_index
-
         ymdT = self.ymd.T
         chunk = ymdT.reindex(columns=new_index)
         assert chunk.columns is new_index

commit 77ad26510b9f650a35ceadb9a1dce504c7d24072
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Dec 25 21:27:18 2009 +0000

    simpler column reindexing in DataFrame and DataMatrix, some cleanup for release
    
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@96 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/__init__.py b/pandas/__init__.py
index f8f0912cc..7af425b99 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -1,4 +1,4 @@
-# pylint: disable-msg=W0614,W0401,W0611
+# pylint: disable-msg=W0614,W0401,W0611,W0622
 
 __docformat__ = 'restructuredtext'
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 314cac538..b5a04ce6d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -42,9 +42,11 @@ class DataFrame(Picklable, Groupable):
     ----------
     data : dict
         Mapping of column name --> array or Series/TimeSeries objects
-    index : array-like
-        Specific index to use for the Frame, Series will be conformed to this
-        if you provide it.
+    index : array-like, optional
+        Specific index to use for the Frame, Series will be conformed
+        to this if you provide it. If not input, index will be
+        inferred from input Series
+    columns : array-like, optional
 
     Notes
     -----
@@ -56,12 +58,12 @@ class DataFrame(Picklable, Groupable):
     --------
     DataMatrix: more efficient version of DataFrame for most operations
 
-    Example usage
-    -------------
+    Example
+    -------
         >>> d = {'col1' : ts1, 'col2' : ts2}
         >>> df = DataFrame(data=d, index=someIndex)
     """
-    def __init__(self, data=None, index=None):
+    def __init__(self, data=None, index=None, columns=None):
         self._series = {}
         if data is not None and len(data) > 0:
             if index is None:
@@ -75,7 +77,7 @@ class DataFrame(Picklable, Groupable):
 
             for k, v in data.iteritems():
                 if isinstance(v, Series):
-                    # Forces homogoneity and copies data
+                    # Forces homogeneity and copies data
                     self._series[k] = v.reindex(self.index)
                 else:
                     # Copies data and checks length
@@ -169,8 +171,8 @@ class DataFrame(Picklable, Groupable):
 
     def toDict(self):
         """
-        Simpler pseudo-inverse operation of dictToDataFrame, NaN values will be
-        included in the resulting dict-tree.
+        Simpler pseudo-inverse operation of DataFrame.fromDict, NaN
+        values will be included in the resulting dict-tree.
 
         Return
         ------
@@ -316,9 +318,9 @@ class DataFrame(Picklable, Groupable):
 
     def __delitem__(self, key):
         """
-        Delete column from DataFrame (only deletes the reference)
+        Delete column from DataFrame
         """
-        self._series.pop(key, None)
+        del self._series[key]
 
     def pop(self, item):
         """
@@ -611,16 +613,16 @@ class DataFrame(Picklable, Groupable):
 
     def asfreq(self, freq, fillMethod=None):
         """
-        Convert all TimeSeries inside to specified frequency using DateOffset
-        objects. Optionally provide fill method to pad/backfill/interpolate
-        missing values.
+        Convert all TimeSeries inside to specified frequency using
+        DateOffset objects. Optionally provide fill method to pad or
+        backfill missing values.
 
         Parameters
         ----------
         offset : DateOffset object, or string in {'WEEKDAY', 'EOM'}
             DateOffset object or subclass (e.g. monthEnd)
 
-        fillMethod : {'backfill', 'pad', 'interpolate', None}
+        fillMethod : {'backfill', 'pad', None}
                     Method to use for filling holes in new inde
         """
         if isinstance(freq, datetools.DateOffset):
@@ -886,38 +888,53 @@ class DataFrame(Picklable, Groupable):
 
         return _slow_pivot(self[index], self[columns], self[values])
 
-    def reindex(self, newIndex, fillMethod=None):
+    def reindex(self, index=None, columns=None, fillMethod=None):
         """
         Reindex data inside, optionally filling according to some rule.
 
         Parameters
         ----------
-        newIndex :   array-like
+        index : array-like, optional
             preferably an Index object (to avoid duplicating data)
-        fillMethod : {'backfill', 'pad', 'interpolate', None}
-            Method to use for filling holes in reindexed DataFrame
+        columns : array-like, optional
+        fillMethod : {'backfill', 'pad', None}
+            Method to use for filling data holes using the index
+
+        Returns
+        -------
+        y : same type as calling instance
         """
-        if self.index.equals(newIndex):
+        fillMethod = fillMethod.upper() if fillMethod else ''
+
+        if fillMethod not in ['BACKFILL', 'PAD', '']:
+            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
+
+        frame = self
+
+        if index is not None:
+            frame = frame._reindex_index(index, fillMethod)
+
+        if columns is not None:
+            frame = frame._reindex_columns(columns)
+
+        return frame
+
+    def _reindex_index(self, index, method):
+        if self.index.equals(index):
             return self.copy()
 
-        if len(newIndex) == 0:
+        if len(index) == 0:
             return DataFrame(index=NULL_INDEX)
 
-        if not isinstance(newIndex, Index):
-            newIndex = Index(newIndex)
+        if not isinstance(index, Index):
+            index = Index(index)
 
         if len(self.index) == 0:
-            return DataFrame(index=newIndex)
+            return DataFrame(index=index)
 
-        oldMap = self.index.indexMap
-        newMap = newIndex.indexMap
-
-        fillMethod = fillMethod.upper() if fillMethod else ''
-        if fillMethod not in ['BACKFILL', 'PAD', '']:
-            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
-
-        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap,
-                                           newMap, fillMethod)
+        fillVec, mask = tseries.getFillVec(self.index, index,
+                                           self.index.indexMap,
+                                           index.indexMap, method)
 
         # Maybe this is a bit much? Wish I had unit tests...
         typeHierarchy = [
@@ -938,14 +955,26 @@ class DataFrame(Picklable, Groupable):
         newSeries = {}
         for col, series in self.iteritems():
             series = series.view(np.ndarray)
-            for type, dest in typeHierarchy:
-                if issubclass(series.dtype.type, type):
+            for klass, dest in typeHierarchy:
+                if issubclass(series.dtype.type, klass):
                     new = series.take(fillVec).astype(dest)
                     new[-mask] = missingValue[dest]
                     newSeries[col] = new
                     break
 
-        return DataFrame(newSeries, index=newIndex)
+        return DataFrame(newSeries, index=index)
+
+    def _reindex_columns(self, columns):
+        if len(columns) == 0:
+            return DataFrame(index=self.index)
+
+        newFrame = self.filterItems(columns)
+
+        for col in columns:
+            if col not in newFrame:
+                newFrame[col] = NaN
+
+        return newFrame
 
     @property
     def T(self):
@@ -1000,7 +1029,7 @@ class DataFrame(Picklable, Groupable):
                                for col, series in self.iteritems()])
         return DataFrame(data = newValues, index= newIndex)
 
-    def apply(self, func):
+    def apply(self, func, axis=0):
         """
         Applies func to columns (Series) of this DataFrame and returns either
         a DataFrame (if the function produces another series) or a Series
@@ -1011,6 +1040,7 @@ class DataFrame(Picklable, Groupable):
         ----------
         func : function
             Function to apply to each column
+        axis : {0, 1}
 
         Example
         -------
@@ -1019,30 +1049,28 @@ class DataFrame(Picklable, Groupable):
 
         Note
         ----
-        Do NOT use functions that might toy with the index.
+        Functions altering the index are not supported (yet)
         """
         if not len(self.cols()):
             return self
 
-        results = {}
-        for col, series in self.iteritems():
-            result = func(series)
-            results[col] = result
+        if axis == 0:
+            target = self
+        elif axis == 1:
+            target = self.T
+
+        results = dict([(k, func(target[k])) for k in target.columns])
 
         if hasattr(results.values()[0], '__iter__'):
             return DataFrame(data=results, index=self.index)
         else:
-            keyArray = np.asarray(sorted(set(results.keys())), dtype=object)
-            newIndex = Index(keyArray)
-
-            arr = np.array([results[idx] for idx in newIndex])
-            return Series(arr, index=newIndex)
+            return Series.fromDict(results)
 
     def tapply(self, func):
         """
         Apply func to the transposed DataFrame, results as per apply
         """
-        return self.T.apply(func)
+        return self.apply(func, axis=1)
 
     def applymap(self, func):
         """
@@ -1323,8 +1351,8 @@ class DataFrame(Picklable, Groupable):
         Plot the DataFrame's series with the index on the x-axis using
         matplotlib / pylab.
 
-        Params
-        ------
+        Parameters
+        ----------
         kind : {'line', 'bar', 'hist'}
             Default: line for TimeSeries, hist for Series
 
@@ -1414,10 +1442,7 @@ class DataFrame(Picklable, Groupable):
             theCount = self.count(axis)
             theSum[theCount == 0] = NaN
         except Exception:
-            if axis == 0:
-                theSum = self.apply(np.sum)
-            else:
-                theSum = self.tapply(np.sum)
+            theSum = self.apply(np.sum, axis=axis)
 
         if asarray:
             return theSum
@@ -1428,6 +1453,27 @@ class DataFrame(Picklable, Groupable):
         else:
             raise Exception('Must have 0<= axis <= 1')
 
+    def cumsum(self, axis=0):
+        """
+        Return cumulative sum over requested axis as DataFrame
+
+        Parameters
+        ----------
+        axis : {0, 1}
+            0 for row-wise, 1 for column-wise
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        def get_cumsum(y):
+            y = np.array(y)
+            if not issubclass(y.dtype.type, np.int_):
+                y[np.isnan(y)] = 0
+            return y.cumsum()
+
+        return self.apply(get_cumsum, axis=axis)
+
     def product(self, axis=0, asarray=False):
         """
         Return array or Series of products over requested axis.
@@ -1664,22 +1710,6 @@ class DataFrame(Picklable, Groupable):
         else:
             raise Exception('Must have 0<= axis <= 1')
 
-    def _withColumns(self, newCols):
-        """
-        Utility method, force values matrix to have particular columns
-        Can make this as cute as we like
-        """
-        if len(newCols) == 0:
-            return DataFrame(index=self.index)
-
-        newFrame = self.filterItems(newCols)
-
-        for col in newCols:
-            if col not in newFrame:
-                newFrame[col] = NaN
-
-        return newFrame
-
 def _pfixed(s, space, nanRep=None):
     if isinstance(s, float):
         fstring = '%-' + str(space-4) + 'g'
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index af69a4020..cdae16b4c 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -38,10 +38,6 @@ class DataMatrix(DataFrame):
     Transposing is much faster in this regime, as is calling getXS, so please
     take note of this.
     """
-    values = None
-    _columns = None
-    _index = None
-    objects = None
     def __init__(self, data=None, index=None, columns=None, dtype=None,
                  objects=None):
 
@@ -202,6 +198,8 @@ class DataMatrix(DataFrame):
         else:
             self.objects = None
 
+    # Because of DataFrame property
+    values = None
 #-------------------------------------------------------------------------------
 # Alternate constructors
 
@@ -435,6 +433,7 @@ class DataMatrix(DataFrame):
 #-------------------------------------------------------------------------------
 # Properties for index and columns
 
+    _columns = None
     def _get_columns(self):
         return self._columns
 
@@ -457,6 +456,7 @@ class DataMatrix(DataFrame):
 
     columns = property(fget=_get_columns, fset=_set_columns)
 
+    _index = None
     def _set_index(self, index):
         if index is None:
             if self.values is not None and self.values.shape[0] > 0:
@@ -730,31 +730,6 @@ class DataMatrix(DataFrame):
 
         return self.index[selector][0]
 
-    def _withColumns(self, newCols):
-        """
-        Utility method, force values matrix to have particular columns
-        Can make this as cute as we like
-        """
-        if len(newCols) == 0:
-            return DataMatrix(index=self.index)
-
-        T, N = len(self.index), len(newCols)
-
-        resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-        resultMatrix.fill(np.NaN)
-
-        if not isinstance(newCols, Index):
-            newCols = Index(newCols)
-
-        overlap = self.columns.intersection(newCols)
-        thisIndexer = [self.columns.indexMap[col] for col in overlap]
-        resultIndexer = [newCols.indexMap[idx] for idx in overlap]
-
-        resultMatrix[:, resultIndexer] = self.values[:, thisIndexer]
-
-        return DataMatrix(resultMatrix, index=self.index, columns=newCols,
-                          objects=self.objects)
-
     def _combineFrame(self, other, func):
         """
         Methodology, briefly
@@ -1236,58 +1211,77 @@ class DataMatrix(DataFrame):
 
         return self.leftJoin(filledFrame)
 
-    def reindex(self, newIndex, fillMethod=None):
-        """
-        Reindex data inside, optionally filling according to some rule.
-
-        Parameters
-        ----------
-        newIndex :   array-like
-            preferably an Index object (to avoid duplicating data)
-        fillMethod : {'backfill', 'pad', 'interpolate', None}
-            Method to use for filling holes in reindexed DataFrame
-
-        Returns
-        -------
-        DataMatrix
-        """
-        if newIndex is self.index:
+    def _reindex_index(self, index, method):
+        if index is self.index:
             return self.copy()
 
-        if len(newIndex) == 0:
+        if len(index) == 0:
             return DataMatrix(index=NULL_INDEX)
 
-        if not isinstance(newIndex, Index):
-            newIndex = Index(newIndex)
+        if not isinstance(index, Index):
+            index = Index(index)
 
         if len(self.index) == 0:
-            return DataMatrix(index=newIndex, columns=self.columns)
+            return DataMatrix(index=index, columns=self.columns)
 
-        selfM = self.values
-        oldMap = self.index.indexMap
-        newMap = newIndex.indexMap
+        fillVec, mask = tseries.getFillVec(self.index, index,
+                                           self.index.indexMap,
+                                           index.indexMap, method)
 
-        if not fillMethod:
-            fillMethod = ''
+        tmpMatrix = self.values.take(fillVec, axis=0)
+        tmpMatrix[-mask] = np.NaN
 
-        fillMethod = fillMethod.upper()
+        if self.objects is not None and len(self.objects.columns) > 0:
+            newObjects = self.objects.reindex(index)
+        else:
+            newObjects = None
 
-        if fillMethod not in ['BACKFILL', 'PAD', '']:
-            raise Exception("Don't recognize fillMethod: %s" % fillMethod)
+        return DataMatrix(tmpMatrix, index=index,
+                          columns=self.columns,
+                          objects=newObjects)
 
-        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap,
-                                           newMap, fillMethod)
+    def _reindex_columns(self, columns):
+        if len(columns) == 0:
+            return DataMatrix(index=self.index)
 
-        tmpMatrix = selfM.take(fillVec, axis=0)
-        tmpMatrix[-mask] = np.NaN
+        if not isinstance(columns, Index):
+            columns = Index(columns)
 
-        if self.objects is not None and len(self.objects.columns) > 0:
-            newLinks = self.objects.reindex(newIndex)
-        else:
-            newLinks = None
+        indexer, mask = tseries.getFillVec(self.columns, columns,
+                                           self.columns.indexMap,
+                                           columns.indexMap, '')
+
+        newValues = self.values.take(indexer, axis=1)
+        newValues[:, -mask] = np.NaN
+
+        return DataMatrix(newValues, index=self.index, columns=columns,
+                          objects=self.objects)
+
+
+    def _withColumns(self, columns):
+        """
+        Utility method, force values matrix to have particular columns
+        Can make this as cute as we like
+        """
+        if len(columns) == 0:
+            return DataMatrix(index=self.index)
+
+        T, N = len(self.index), len(columns)
+
+        resultMatrix = np.empty((T, N), dtype=self.values.dtype)
+        resultMatrix.fill(np.NaN)
+
+        if not isinstance(columns, Index):
+            columns = Index(columns)
 
-        return DataMatrix(tmpMatrix, index=newIndex,
-                          columns=self.columns, objects=newLinks)
+        overlap = self.columns.intersection(columns)
+        thisIndexer = [self.columns.indexMap[col] for col in overlap]
+        resultIndexer = [columns.indexMap[idx] for idx in overlap]
+
+        resultMatrix[:, resultIndexer] = self.values[:, thisIndexer]
+
+        return DataMatrix(resultMatrix, index=self.index, columns=columns,
+                          objects=self.objects)
 
     @property
     def T(self):
@@ -1392,12 +1386,6 @@ class DataMatrix(DataFrame):
         else:
             raise Exception('Should not reach here')
 
-    def tapply(self, func):
-        """
-        Apply func to the transposed DataMatrix, results as per above.
-        """
-        return self.apply(func, axis=1)
-
     def applymap(self, func):
         """
         Apply a function to a DataMatrix that is intended to operate
@@ -1457,7 +1445,7 @@ class DataMatrix(DataFrame):
         DataMatrix with matching columns
         """
         newCols = Index([c for c in self.columns if arg in c])
-        return self._withColumns(newCols)
+        return self.reindex(columns=newCols)
 
     def append(self, otherFrame):
         if not otherFrame:
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 675477e2e..dce5bde48 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -261,8 +261,8 @@ class WidePanel(Panel):
             value = value.toWide()[value.items[0]]
 
         if isinstance(value, DataFrame):
-            value = value.reindex(self.major_axis)
-            value = value._withColumns(self.minor_axis)
+            value = value.reindex(index=self.major_axis,
+                                  columns=self.minor_axis)
 
             mat = value.values.reshape((1, N, K))
 
@@ -308,7 +308,7 @@ class WidePanel(Panel):
         """
         index, columns = self._get_plane_axes(axis)
 
-        return frame.reindex(index)._withColumns(columns)
+        return frame.reindex(index=index, columns=columns)
 
     def reindex(self, new_index, axis='major', fill_method=None):
         """
@@ -381,7 +381,7 @@ class WidePanel(Panel):
         index, columns = self._get_plane_axes(axis)
         axis = self._wide_axis_number(axis)
 
-        other = other.reindex(index)._withColumns(columns)
+        other = other.reindex(index=index, columns=columns)
 
         if axis == 0:
             newValues = func(self.values, other.values)
@@ -1467,7 +1467,7 @@ def _homogenize(frames, intersect=True):
             if not isinstance(frame, DataMatrix):
                 frame = frame.toDataMatrix()
 
-            result[key] = frame._withColumns(columns).reindex(index)
+            result[key] = frame.reindex(index=index, columns=columns)
 
     return result, index, columns
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index b4ff08766..15383f124 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -89,7 +89,7 @@ class Series(np.ndarray, Picklable, Groupable):
     ----------
     data : array-like
         Underlying values of Series, preferably as numpy ndarray
-    index : array-like, optional
+    index : array-like
         Index object (or other iterable of same length as data)
 
     Note
@@ -98,10 +98,8 @@ class Series(np.ndarray, Picklable, Groupable):
     be present or the value for that index position will be nan. The
     new index is the sorted union of the two Series indices.
 
-    ALSO NOTE: There is currently no restriction on what can be in the
-    index.
-
-    Example usage:
+    Example
+    -------
         >>> s = Series(arr, index=Index(dates))
         >>> t = Series(otherArr, index=Index(otherDates))
         >>> s / t # --> new Series resulting from by-index division of elements
@@ -170,7 +168,7 @@ class Series(np.ndarray, Picklable, Groupable):
     @classmethod
     def fromDict(cls, input, castFloat=True, **kwds):
         """
-        Analogous to asDataFrame, but turns dict into Series
+        Construct Series from dict
 
         Parameters
         ----------
@@ -180,7 +178,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        Series
+        y : Series
         """
         input = input.copy()
         input.update(kwds)
@@ -201,7 +199,7 @@ class Series(np.ndarray, Picklable, Groupable):
     @classmethod
     def fromValue(cls, value=np.NaN, index=None, dtype=None):
         """
-        Analogous to asDataFrame, but turns dict into Series
+        Create Series with all values being the input scalar
 
         Parameters
         ----------
@@ -211,7 +209,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        Series
+        y : Series
         """
         # If we create an empty array using a string to infer
         # the dtype, NumPy will only allocate one character per entry
@@ -281,8 +279,8 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def get(self, key, missingVal=None):
         """
-        Returns value occupying requested index, and
-        return missingVal if not in Index
+        Returns value occupying requested index, default to missingVal
+        if not present
 
         Parameters
         ----------
@@ -290,6 +288,10 @@ class Series(np.ndarray, Picklable, Groupable):
             Index value looking for
         missingVal : object, optional
             Value to return if key not in index
+
+        Returns
+        -------
+        y : scalar
         """
         if key in self.index:
             return ndarray.__getitem__(self, self.index.indexMap[key])
@@ -362,6 +364,17 @@ class Series(np.ndarray, Picklable, Groupable):
 
 #-------------------------------------------------------------------------------
 # Overridden ndarray methods
+
+    def count(self):
+        """
+        Return number of observations of Series.
+
+        Returns
+        -------
+        int (# obs)
+        """
+        return notnull(self.values()).sum()
+
     def _ndarray_statistic(self, funcname):
         arr = self.values()
         retVal = getattr(arr, funcname)()
@@ -374,36 +387,31 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def sum(self, axis=None, dtype=None, out=None):
         """
-        Overridden version of ndarray.sum for Series which excludes
-        NaN automatically
+        Compute sum of non-null values
         """
         return self._ndarray_statistic('sum')
 
     def mean(self, axis=None, dtype=None, out=None):
         """
-        Overridden version of ndarray.mean for Series which excludes
-        NaN automatically
+        Compute mean of non-null values
         """
         return self._ndarray_statistic('mean')
 
     def min(self, axis=None, out=None):
         """
-        Overridden version of ndarray.min for Series which excludes
-        NaN automatically
+        Compute minimum of non-null values
         """
         return self._ndarray_statistic('min')
 
     def max(self, axis=None, out=None):
         """
-        Overridden version of ndarray.max for Series which excludes
-        NaN automatically
+        Compute maximum of non-null values
         """
         return self._ndarray_statistic('max')
 
     def std(self, axis=None, dtype=None, out=None, ddof=1):
         """
-        Overridden version of ndarray.std for Series which excludes
-        NaN automatically
+        Compute unbiased standard deviation of non-null values
         """
         nona = remove_na(self.values())
         if len(nona) < 2:
@@ -412,8 +420,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def var(self, axis=None, dtype=None, out=None, ddof=1):
         """
-        Overridden version of ndarray.var for Series which excludes
-        NaN automatically
+        Compute unbiased variance of non-null values
         """
         nona = remove_na(self.values())
         if len(nona) < 2:
@@ -421,18 +428,14 @@ class Series(np.ndarray, Picklable, Groupable):
         return ndarray.var(nona, axis, dtype, out, ddof)
 
     def skew(self, bias=False):
-        """Computes the skewness of the Series
-
-        For normally distributed data, the skewness should be about 0.
-        A skewness value > 0 means that there is more weight in the left
-        tail of the distribution. The function skewtest() can be used to
-        determine if the skewness value is close enough to 0, statistically
-        speaking.
+        """
+        Computes the skewness of the non-null values
 
         Parameters
         ----------
         bias : bool
-        If False, then the calculations are corrected for statistical bias.
+            If False, then the calculations are corrected for
+            statistical bias.
         """
 
         from scipy.stats import skew
@@ -452,28 +455,32 @@ class Series(np.ndarray, Picklable, Groupable):
     def keys(self):
         """
         Return Series index
-
-        Analogous to dict.keys()
         """
         return self.index
 
     def values(self):
         """
-        Return Series values
-
-        Analogous to dict.values()
+        Return Series as ndarray
         """
         return self.view(ndarray)
 
     def iteritems(self):
         """
-        Iterate over (index, value) tuples
+        Lazily iterate over (index, value) tuples
         """
         return izip(iter(self.index), iter(self))
 
     def append(self, other):
         """
-        Concatenate two Series
+        Concatenate two Series. The indices should not overlap
+
+        Parameters
+        ----------
+        other : Series
+
+        Returns
+        -------
+        y : Series
         """
         newIndex = np.concatenate((self.index, other.index))
 
@@ -492,6 +499,16 @@ class Series(np.ndarray, Picklable, Groupable):
           * another Series index by index
           * a scalar value
           * DataFrame
+
+        Parameters
+        ----------
+        other : {Series, DataFrame, scalar value}
+
+        Returns
+        -------
+        y : {Series or DataFrame}
+            Output depends on input. If a DataFrame is inputted, that
+            will be the return type.
         """
         if isinstance(other, Series):
             newIndex = self.index + other.index
@@ -515,7 +532,8 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        Series formed as union of
+        y : Series
+            formed as union of two Series
         """
         newIndex = self.index + other.index
 
@@ -560,7 +578,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def median(self):
         """
-        Return median value of Series
+        Compute median value of non-null values
         """
         return tseries.median(self.valid())
 
@@ -569,7 +587,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def corr(self, other):
         """
-        Correlation of this Series with another Series, NaN excluded
+        Compute correlation two Series, excluding missing values
 
         Parameters
         ----------
@@ -577,7 +595,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        float (the correlation coefficient)
+        correlation : float
         """
         commonIdx = remove_na(self).index.intersection(remove_na(other).index)
 
@@ -589,16 +607,6 @@ class Series(np.ndarray, Picklable, Groupable):
 
         return np.corrcoef(this, that)[0, 1]
 
-    def count(self):
-        """
-        Return number of observations of Series.
-
-        Returns
-        -------
-        int (# obs)
-        """
-        return notnull(self.values()).sum()
-
     def sort(self, axis=0, kind='quicksort', order=None):
         """
         Overridden NumPy sort, taking care with missing values
@@ -620,7 +628,8 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        SORTED series by values (indices correspond to the appropriate values)
+        y : Series
+            sorted by values
         """
         arr = self.values()
         sortedIdx = np.empty(len(self), dtype=np.int32)
@@ -652,7 +661,8 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        Series with same index
+        y : Series
+            same index as caller
         """
         return Series([func(x) for x in self], index=self.index)
 
@@ -661,8 +671,8 @@ class Series(np.ndarray, Picklable, Groupable):
         Plot the input series with the index on the x-axis using
         matplotlib / pylab.
 
-        Params
-        ------
+        Parameters
+        ----------
         label : label argument to provide to plot
 
         kind : {'line', 'bar', 'hist'}
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index a2507c3dd..1af992611 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -11,7 +11,11 @@ from pandas.core.api import DateRange, DataFrame, Index, Series
 from pandas.core.datetools import bday
 import pandas.core.datetools as datetools
 
-from pandas.core.tests.common import assert_almost_equal, randn
+from pandas.core.tests.common import (assert_almost_equal,
+                                      assert_series_equal,
+                                      assert_frame_equal,
+                                      randn)
+
 import pandas.core.tests.common as common
 
 #-------------------------------------------------------------------------------
@@ -452,7 +456,7 @@ class TestDataFrame(unittest.TestCase):
         common.assert_frame_equal(tsFrame, frame[5:10])
 
         A = frame.getTS(colName='A', nPeriods=5, toDate=frame.index[9])
-        common.assert_series_equal(A, frame['A'][5:10])
+        assert_series_equal(A, frame['A'][5:10])
 
         self.assertRaises(Exception, frame.getTS, nPeriods=5)
 
@@ -557,6 +561,13 @@ class TestDataFrame(unittest.TestCase):
         newFrame = self.frame.reindex(list(self.ts1.index))
         self.assert_(newFrame.index.equals(self.ts1.index))
 
+    def test_reindex_columns(self):
+        newFrame = self.frame.reindex(columns=['A', 'B', 'E'])
+
+        assert_series_equal(newFrame['B'], self.frame['B'])
+        self.assert_(np.isnan(newFrame['E']).all())
+        self.assert_('C' not in newFrame)
+
     def test_reindex_mixed(self):
         pass
 
@@ -677,9 +688,6 @@ class TestDataFrame(unittest.TestCase):
     def test_skew(self):
         pass
 
-    def test_withColumns(self):
-        pass
-
     def testGroupBy(self):
         pass
 
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 451a8b589..210cb760a 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -558,10 +558,6 @@ class TestSeries(unittest.TestCase):
         ts = self.ts[::2]
         self.assertRaises(Exception, ts.reindex, self.ts.index, fillMethod='foo')
 
-        # corner case: pad empty series
-        s = Series([], index=[])
-        reindexed = s.reindex(self.ts.index, fillMethod='pad')
-
     def test_reindex_bool(self):
 
         # A series other than float, int, string, or object
diff --git a/pandas/stats/math.py b/pandas/stats/math.py
index 369366d1c..b5f565f9d 100644
--- a/pandas/stats/math.py
+++ b/pandas/stats/math.py
@@ -78,9 +78,9 @@ def newey_west(m, max_lags, nobs, df, nw_overlap=False):
 
     if nw_overlap and not is_psd(Xeps):
         new_max_lags = int(np.ceil(max_lags * 1.5))
-        print ('nw_overlap is True and newey_west generated a non positive '
-               'semidefinite matrix, so using newey_west with max_lags of %d.'
-               % new_max_lags)
+#         print ('nw_overlap is True and newey_west generated a non positive '
+#                'semidefinite matrix, so using newey_west with max_lags of %d.'
+#                % new_max_lags)
         return newey_west(m, new_max_lags, nobs, df)
 
     return Xeps

commit a22acc2961bc6719f11a2900e004982e55007401
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 6 03:20:35 2018 -0800

    centralize and split frame division tests (#19527)

diff --git a/pandas/tests/frame/test_arithmetic.py b/pandas/tests/frame/test_arithmetic.py
index 9b99a7b73..1bb8e8edf 100644
--- a/pandas/tests/frame/test_arithmetic.py
+++ b/pandas/tests/frame/test_arithmetic.py
@@ -1,8 +1,9 @@
 # -*- coding: utf-8 -*-
-
 import pytest
 import numpy as np
 
+from pandas.compat import range
+
 import pandas as pd
 import pandas.util.testing as tm
 
@@ -58,10 +59,129 @@ class TestFrameComparisons(object):
         result = getattr(empty, opname)(const).get_dtype_counts()
         tm.assert_series_equal(result, pd.Series([2], ['bool']))
 
+    @pytest.mark.parametrize('timestamps', [
+        [pd.Timestamp('2012-01-01 13:00:00+00:00')] * 2,
+        [pd.Timestamp('2012-01-01 13:00:00')] * 2])
+    def test_tz_aware_scalar_comparison(self, timestamps):
+        # Test for issue #15966
+        df = pd.DataFrame({'test': timestamps})
+        expected = pd.DataFrame({'test': [False, False]})
+        tm.assert_frame_equal(df == -1, expected)
+
 
 # -------------------------------------------------------------------
 # Arithmetic
 
+class TestFrameMulDiv(object):
+    """Tests for DataFrame multiplication and division"""
+    # ------------------------------------------------------------------
+    # Mod By Zero
+
+    def test_df_mod_zero_df(self):
+        # GH#3590, modulo as ints
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+
+        # this is technically wrong, as the integer portion is coerced to float
+        # ###
+        first = pd.Series([0, 0, 0, 0], dtype='float64')
+        second = pd.Series([np.nan, np.nan, np.nan, 0])
+        expected = pd.DataFrame({'first': first, 'second': second})
+        result = df % df
+        tm.assert_frame_equal(result, expected)
+
+    def test_df_mod_zero_array(self):
+        # GH#3590, modulo as ints
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+
+        # this is technically wrong, as the integer portion is coerced to float
+        # ###
+        first = pd.Series([0, 0, 0, 0], dtype='float64')
+        second = pd.Series([np.nan, np.nan, np.nan, 0])
+        expected = pd.DataFrame({'first': first, 'second': second})
+
+        # numpy has a slightly different (wrong) treatment
+        with np.errstate(all='ignore'):
+            arr = df.values % df.values
+        result2 = pd.DataFrame(arr, index=df.index,
+                               columns=df.columns, dtype='float64')
+        result2.iloc[0:3, 1] = np.nan
+        tm.assert_frame_equal(result2, expected)
+
+    def test_df_mod_zero_int(self):
+        # GH#3590, modulo as ints
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+
+        result = df % 0
+        expected = pd.DataFrame(np.nan, index=df.index, columns=df.columns)
+        tm.assert_frame_equal(result, expected)
+
+        # numpy has a slightly different (wrong) treatment
+        with np.errstate(all='ignore'):
+            arr = df.values.astype('float64') % 0
+        result2 = pd.DataFrame(arr, index=df.index, columns=df.columns)
+        tm.assert_frame_equal(result2, expected)
+
+    def test_df_mod_zero_series_does_not_commute(self):
+        # GH#3590, modulo as ints
+        # not commutative with series
+        df = pd.DataFrame(np.random.randn(10, 5))
+        ser = df[0]
+        res = ser % df
+        res2 = df % ser
+        assert not res.fillna(0).equals(res2.fillna(0))
+
+    # ------------------------------------------------------------------
+    # Division By Zero
+
+    def test_df_div_zero_df(self):
+        # integer div, but deal with the 0's (GH#9144)
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+        result = df / df
+
+        first = pd.Series([1.0, 1.0, 1.0, 1.0])
+        second = pd.Series([np.nan, np.nan, np.nan, 1])
+        expected = pd.DataFrame({'first': first, 'second': second})
+        tm.assert_frame_equal(result, expected)
+
+    def test_df_div_zero_array(self):
+        # integer div, but deal with the 0's (GH#9144)
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+
+        first = pd.Series([1.0, 1.0, 1.0, 1.0])
+        second = pd.Series([np.nan, np.nan, np.nan, 1])
+        expected = pd.DataFrame({'first': first, 'second': second})
+
+        with np.errstate(all='ignore'):
+            arr = df.values.astype('float') / df.values
+        result = pd.DataFrame(arr, index=df.index,
+                              columns=df.columns)
+        tm.assert_frame_equal(result, expected)
+
+    def test_df_div_zero_int(self):
+        # integer div, but deal with the 0's (GH#9144)
+        df = pd.DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+
+        result = df / 0
+        expected = pd.DataFrame(np.inf, index=df.index, columns=df.columns)
+        expected.iloc[0:3, 1] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+        # numpy has a slightly different (wrong) treatment
+        with np.errstate(all='ignore'):
+            arr = df.values.astype('float64') / 0
+        result2 = pd.DataFrame(arr, index=df.index,
+                               columns=df.columns)
+        tm.assert_frame_equal(result2, expected)
+
+    def test_df_div_zero_series_does_not_commute(self):
+        # integer div, but deal with the 0's (GH#9144)
+        df = pd.DataFrame(np.random.randn(10, 5))
+        ser = df[0]
+        res = ser / df
+        res2 = df / ser
+        assert not res.fillna(0).equals(res2.fillna(0))
+
+
 class TestFrameArithmetic(object):
 
     @pytest.mark.xfail(reason='GH#7996 datetime64 units not converted to nano')
diff --git a/pandas/tests/frame/test_operators.py b/pandas/tests/frame/test_operators.py
index bdccbec61..bf895be8b 100644
--- a/pandas/tests/frame/test_operators.py
+++ b/pandas/tests/frame/test_operators.py
@@ -203,76 +203,6 @@ class TestDataFrameOperators(TestData):
             result = right_f(Timestamp('nat'), df)
             assert_frame_equal(result, expected)
 
-    def test_modulo(self):
-        # GH3590, modulo as ints
-        p = DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
-
-        # this is technically wrong as the integer portion is coerced to float
-        # ###
-        expected = DataFrame({'first': Series([0, 0, 0, 0], dtype='float64'),
-                              'second': Series([np.nan, np.nan, np.nan, 0])})
-        result = p % p
-        assert_frame_equal(result, expected)
-
-        # numpy has a slightly different (wrong) treatement
-        with np.errstate(all='ignore'):
-            arr = p.values % p.values
-        result2 = DataFrame(arr, index=p.index,
-                            columns=p.columns, dtype='float64')
-        result2.iloc[0:3, 1] = np.nan
-        assert_frame_equal(result2, expected)
-
-        result = p % 0
-        expected = DataFrame(np.nan, index=p.index, columns=p.columns)
-        assert_frame_equal(result, expected)
-
-        # numpy has a slightly different (wrong) treatement
-        with np.errstate(all='ignore'):
-            arr = p.values.astype('float64') % 0
-        result2 = DataFrame(arr, index=p.index, columns=p.columns)
-        assert_frame_equal(result2, expected)
-
-        # not commutative with series
-        p = DataFrame(np.random.randn(10, 5))
-        s = p[0]
-        res = s % p
-        res2 = p % s
-        assert not res.fillna(0).equals(res2.fillna(0))
-
-    def test_div(self):
-
-        # integer div, but deal with the 0's (GH 9144)
-        p = DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
-        result = p / p
-
-        expected = DataFrame({'first': Series([1.0, 1.0, 1.0, 1.0]),
-                              'second': Series([nan, nan, nan, 1])})
-        assert_frame_equal(result, expected)
-
-        with np.errstate(all='ignore'):
-            arr = p.values.astype('float') / p.values
-        result2 = DataFrame(arr, index=p.index,
-                            columns=p.columns)
-        assert_frame_equal(result2, expected)
-
-        result = p / 0
-        expected = DataFrame(np.inf, index=p.index, columns=p.columns)
-        expected.iloc[0:3, 1] = nan
-        assert_frame_equal(result, expected)
-
-        # numpy has a slightly different (wrong) treatement
-        with np.errstate(all='ignore'):
-            arr = p.values.astype('float64') / 0
-        result2 = DataFrame(arr, index=p.index,
-                            columns=p.columns)
-        assert_frame_equal(result2, expected)
-
-        p = DataFrame(np.random.randn(10, 5))
-        s = p[0]
-        res = s / p
-        res2 = p / s
-        assert not res.fillna(0).equals(res2.fillna(0))
-
     def test_logical_operators(self):
 
         def _check_bin_op(op):
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index e6b47fd69..25dd285e8 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -738,12 +738,3 @@ class TestDataFrameTimeSeriesMethods(TestData):
         with assert_raises_regex(ValueError, 'not valid'):
             df = DataFrame(index=l0)
             df = getattr(df, fn)('US/Pacific', level=1)
-
-    @pytest.mark.parametrize('timestamps', [
-        [Timestamp('2012-01-01 13:00:00+00:00')] * 2,
-        [Timestamp('2012-01-01 13:00:00')] * 2])
-    def test_tz_aware_scalar_comparison(self, timestamps):
-        # Test for issue #15966
-        df = DataFrame({'test': timestamps})
-        expected = DataFrame({'test': [False, False]})
-        assert_frame_equal(df == -1, expected)

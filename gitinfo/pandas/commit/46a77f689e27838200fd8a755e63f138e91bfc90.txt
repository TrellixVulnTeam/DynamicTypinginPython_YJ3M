commit 46a77f689e27838200fd8a755e63f138e91bfc90
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Feb 9 08:42:14 2020 -0800

    TST: parametrize some indexing tests (#31767)

diff --git a/pandas/tests/indexing/test_floats.py b/pandas/tests/indexing/test_floats.py
index 8bb88cd9f..6cc18a398 100644
--- a/pandas/tests/indexing/test_floats.py
+++ b/pandas/tests/indexing/test_floats.py
@@ -59,115 +59,117 @@ class TestFloatIndexers:
         with pytest.raises(TypeError, match=msg):
             s.iloc[3.0] = 0
 
-    def test_scalar_non_numeric(self):
-
-        # GH 4892
-        # float_indexers should raise exceptions
-        # on appropriate Index types & accessors
-
-        for index in [
+    @pytest.mark.parametrize(
+        "index_func",
+        [
             tm.makeStringIndex,
             tm.makeUnicodeIndex,
             tm.makeCategoricalIndex,
             tm.makeDateIndex,
             tm.makeTimedeltaIndex,
             tm.makePeriodIndex,
-        ]:
+        ],
+    )
+    def test_scalar_non_numeric(self, index_func):
 
-            i = index(5)
+        # GH 4892
+        # float_indexers should raise exceptions
+        # on appropriate Index types & accessors
 
-            for s in [
-                Series(np.arange(len(i)), index=i),
-                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
-            ]:
+        i = index_func(5)
 
-                # getting
-                for idxr, getitem in [(lambda x: x.iloc, False), (lambda x: x, True)]:
+        for s in [
+            Series(np.arange(len(i)), index=i),
+            DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
+        ]:
 
-                    # gettitem on a DataFrame is a KeyError as it is indexing
-                    # via labels on the columns
-                    if getitem and isinstance(s, DataFrame):
-                        error = KeyError
-                        msg = r"^3(\.0)?$"
-                    else:
-                        error = TypeError
-                        msg = (
-                            r"cannot do (label|positional) indexing "
-                            r"on {klass} with these indexers \[3\.0\] of "
-                            r"type float|"
-                            "Cannot index by location index with a "
-                            "non-integer key".format(klass=type(i).__name__)
-                        )
-                    with pytest.raises(error, match=msg):
-                        idxr(s)[3.0]
-
-                # label based can be a TypeError or KeyError
-                if s.index.inferred_type in {
-                    "categorical",
-                    "string",
-                    "unicode",
-                    "mixed",
-                }:
+            # getting
+            for idxr, getitem in [(lambda x: x.iloc, False), (lambda x: x, True)]:
+
+                # gettitem on a DataFrame is a KeyError as it is indexing
+                # via labels on the columns
+                if getitem and isinstance(s, DataFrame):
                     error = KeyError
-                    msg = r"^3\.0$"
+                    msg = r"^3(\.0)?$"
                 else:
                     error = TypeError
                     msg = (
-                        r"cannot do label indexing "
+                        r"cannot do (label|positional) indexing "
                         r"on {klass} with these indexers \[3\.0\] of "
-                        r"type float".format(klass=type(i).__name__)
+                        r"type float|"
+                        "Cannot index by location index with a "
+                        "non-integer key".format(klass=type(i).__name__)
                     )
                 with pytest.raises(error, match=msg):
-                    s.loc[3.0]
-
-                # contains
-                assert 3.0 not in s
-
-                # setting with a float fails with iloc
+                    idxr(s)[3.0]
+
+            # label based can be a TypeError or KeyError
+            if s.index.inferred_type in {
+                "categorical",
+                "string",
+                "unicode",
+                "mixed",
+            }:
+                error = KeyError
+                msg = r"^3\.0$"
+            else:
+                error = TypeError
                 msg = (
                     r"cannot do (label|positional) indexing "
                     r"on {klass} with these indexers \[3\.0\] of "
                     r"type float".format(klass=type(i).__name__)
                 )
-                with pytest.raises(TypeError, match=msg):
-                    s.iloc[3.0] = 0
-
-                # setting with an indexer
-                if s.index.inferred_type in ["categorical"]:
-                    # Value or Type Error
-                    pass
-                elif s.index.inferred_type in ["datetime64", "timedelta64", "period"]:
-
-                    # these should prob work
-                    # and are inconsistent between series/dataframe ATM
-                    # for idxr in [lambda x: x]:
-                    #    s2 = s.copy()
-                    #
-                    #    with pytest.raises(TypeError):
-                    #        idxr(s2)[3.0] = 0
-                    pass
-
-                else:
+            with pytest.raises(error, match=msg):
+                s.loc[3.0]
 
-                    s2 = s.copy()
-                    s2.loc[3.0] = 10
-                    assert s2.index.is_object()
-
-                    for idxr in [lambda x: x]:
-                        s2 = s.copy()
-                        idxr(s2)[3.0] = 0
-                        assert s2.index.is_object()
+            # contains
+            assert 3.0 not in s
 
-            # fallsback to position selection, series only
-            s = Series(np.arange(len(i)), index=i)
-            s[3]
+            # setting with a float fails with iloc
             msg = (
-                r"cannot do label indexing "
+                r"cannot do (label|positional) indexing "
                 r"on {klass} with these indexers \[3\.0\] of "
                 r"type float".format(klass=type(i).__name__)
             )
             with pytest.raises(TypeError, match=msg):
-                s[3.0]
+                s.iloc[3.0] = 0
+
+            # setting with an indexer
+            if s.index.inferred_type in ["categorical"]:
+                # Value or Type Error
+                pass
+            elif s.index.inferred_type in ["datetime64", "timedelta64", "period"]:
+
+                # these should prob work
+                # and are inconsistent between series/dataframe ATM
+                # for idxr in [lambda x: x]:
+                #    s2 = s.copy()
+                #
+                #    with pytest.raises(TypeError):
+                #        idxr(s2)[3.0] = 0
+                pass
+
+            else:
+
+                s2 = s.copy()
+                s2.loc[3.0] = 10
+                assert s2.index.is_object()
+
+                for idxr in [lambda x: x]:
+                    s2 = s.copy()
+                    idxr(s2)[3.0] = 0
+                    assert s2.index.is_object()
+
+        # fallsback to position selection, series only
+        s = Series(np.arange(len(i)), index=i)
+        s[3]
+        msg = (
+            r"cannot do (label|positional) indexing "
+            r"on {klass} with these indexers \[3\.0\] of "
+            r"type float".format(klass=type(i).__name__)
+        )
+        with pytest.raises(TypeError, match=msg):
+            s[3.0]
 
     def test_scalar_with_mixed(self):
 
@@ -222,52 +224,56 @@ class TestFloatIndexers:
         expected = 3
         assert result == expected
 
-    def test_scalar_integer(self):
+    @pytest.mark.parametrize(
+        "index_func", [tm.makeIntIndex, tm.makeRangeIndex],
+    )
+    @pytest.mark.parametrize("klass", [Series, DataFrame])
+    def test_scalar_integer(self, index_func, klass):
 
         # test how scalar float indexers work on int indexes
 
         # integer index
-        for i in [Int64Index(range(5)), RangeIndex(5)]:
+        i = index_func(5)
 
-            for s in [
-                Series(np.arange(len(i))),
-                DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i),
-            ]:
+        if klass is Series:
+            obj = Series(np.arange(len(i)))
+        else:
+            obj = DataFrame(np.random.randn(len(i), len(i)), index=i, columns=i)
 
-                # coerce to equal int
-                for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:
+        # coerce to equal int
+        for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:
 
-                    result = idxr(s)[3.0]
-                    self.check(result, s, 3, getitem)
+            result = idxr(obj)[3.0]
+            self.check(result, obj, 3, getitem)
 
-                # coerce to equal int
-                for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:
+        # coerce to equal int
+        for idxr, getitem in [(lambda x: x.loc, False), (lambda x: x, True)]:
 
-                    if isinstance(s, Series):
+            if isinstance(obj, Series):
 
-                        def compare(x, y):
-                            assert x == y
+                def compare(x, y):
+                    assert x == y
 
-                        expected = 100
-                    else:
-                        compare = tm.assert_series_equal
-                        if getitem:
-                            expected = Series(100, index=range(len(s)), name=3)
-                        else:
-                            expected = Series(100.0, index=range(len(s)), name=3)
+                expected = 100
+            else:
+                compare = tm.assert_series_equal
+                if getitem:
+                    expected = Series(100, index=range(len(obj)), name=3)
+                else:
+                    expected = Series(100.0, index=range(len(obj)), name=3)
 
-                    s2 = s.copy()
-                    idxr(s2)[3.0] = 100
+            s2 = obj.copy()
+            idxr(s2)[3.0] = 100
 
-                    result = idxr(s2)[3.0]
-                    compare(result, expected)
+            result = idxr(s2)[3.0]
+            compare(result, expected)
 
-                    result = idxr(s2)[3]
-                    compare(result, expected)
+            result = idxr(s2)[3]
+            compare(result, expected)
 
-                # contains
-                # coerce to equal int
-                assert 3.0 in s
+        # contains
+        # coerce to equal int
+        assert 3.0 in obj
 
     def test_scalar_float(self):
 
@@ -322,68 +328,70 @@ class TestFloatIndexers:
             with pytest.raises(TypeError, match=msg):
                 s2.iloc[3.0] = 0
 
-    def test_slice_non_numeric(self):
-
-        # GH 4892
-        # float_indexers should raise exceptions
-        # on appropriate Index types & accessors
-
-        for index in [
+    @pytest.mark.parametrize(
+        "index_func",
+        [
             tm.makeStringIndex,
             tm.makeUnicodeIndex,
             tm.makeDateIndex,
             tm.makeTimedeltaIndex,
             tm.makePeriodIndex,
+        ],
+    )
+    def test_slice_non_numeric(self, index_func):
+
+        # GH 4892
+        # float_indexers should raise exceptions
+        # on appropriate Index types & accessors
+
+        index = index_func(5)
+        for s in [
+            Series(range(5), index=index),
+            DataFrame(np.random.randn(5, 2), index=index),
         ]:
 
-            index = index(5)
-            for s in [
-                Series(range(5), index=index),
-                DataFrame(np.random.randn(5, 2), index=index),
-            ]:
+            # getitem
+            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
+
+                msg = (
+                    "cannot do positional indexing "
+                    r"on {klass} with these indexers \[(3|4)\.0\] of "
+                    "type float".format(klass=type(index).__name__)
+                )
+                with pytest.raises(TypeError, match=msg):
+                    s.iloc[l]
 
-                # getitem
-                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
+                for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:
 
                     msg = (
-                        "cannot do positional indexing "
-                        r"on {klass} with these indexers \[(3|4)\.0\] of "
-                        "type float".format(klass=type(index).__name__)
+                        "cannot do (slice|positional) indexing "
+                        r"on {klass} with these indexers "
+                        r"\[(3|4)(\.0)?\] "
+                        r"of type (float|int)".format(klass=type(index).__name__)
                     )
                     with pytest.raises(TypeError, match=msg):
-                        s.iloc[l]
+                        idxr(s)[l]
 
-                    for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:
-
-                        msg = (
-                            "cannot do (slice|positional) indexing "
-                            r"on {klass} with these indexers "
-                            r"\[(3|4)(\.0)?\] "
-                            r"of type (float|int)".format(klass=type(index).__name__)
-                        )
-                        with pytest.raises(TypeError, match=msg):
-                            idxr(s)[l]
+            # setitem
+            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
 
-                # setitem
-                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
+                msg = (
+                    "cannot do positional indexing "
+                    r"on {klass} with these indexers \[(3|4)\.0\] of "
+                    "type float".format(klass=type(index).__name__)
+                )
+                with pytest.raises(TypeError, match=msg):
+                    s.iloc[l] = 0
 
+                for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:
                     msg = (
-                        "cannot do positional indexing "
-                        r"on {klass} with these indexers \[(3|4)\.0\] of "
-                        "type float".format(klass=type(index).__name__)
+                        "cannot do (slice|positional) indexing "
+                        r"on {klass} with these indexers "
+                        r"\[(3|4)(\.0)?\] "
+                        r"of type (float|int)".format(klass=type(index).__name__)
                     )
                     with pytest.raises(TypeError, match=msg):
-                        s.iloc[l] = 0
-
-                    for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:
-                        msg = (
-                            "cannot do (slice|positional) indexing "
-                            r"on {klass} with these indexers "
-                            r"\[(3|4)(\.0)?\] "
-                            r"of type (float|int)".format(klass=type(index).__name__)
-                        )
-                        with pytest.raises(TypeError, match=msg):
-                            idxr(s)[l] = 0
+                        idxr(s)[l] = 0
 
     def test_slice_integer(self):
 
@@ -516,83 +524,86 @@ class TestFloatIndexers:
                 with pytest.raises(TypeError, match=msg):
                     idxr(s)[l]
 
-    def test_slice_integer_frame_getitem(self):
+    @pytest.mark.parametrize(
+        "index_func", [tm.makeIntIndex, tm.makeRangeIndex],
+    )
+    def test_slice_integer_frame_getitem(self, index_func):
 
         # similar to above, but on the getitem dim (of a DataFrame)
-        for index in [Int64Index(range(5)), RangeIndex(5)]:
-
-            s = DataFrame(np.random.randn(5, 2), index=index)
-
-            def f(idxr):
+        index = index_func(5)
 
-                # getitem
-                for l in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:
+        s = DataFrame(np.random.randn(5, 2), index=index)
 
-                    result = idxr(s)[l]
-                    indexer = slice(0, 2)
-                    self.check(result, s, indexer, False)
-
-                    # positional indexing
-                    msg = (
-                        "cannot do slice indexing "
-                        r"on {klass} with these indexers \[(0|1)\.0\] of "
-                        "type float".format(klass=type(index).__name__)
-                    )
-                    with pytest.raises(TypeError, match=msg):
-                        s[l]
+        def f(idxr):
 
-                # getitem out-of-bounds
-                for l in [slice(-10, 10), slice(-10.0, 10.0)]:
+            # getitem
+            for l in [slice(0.0, 1), slice(0, 1.0), slice(0.0, 1.0)]:
 
-                    result = idxr(s)[l]
-                    self.check(result, s, slice(-10, 10), True)
+                result = idxr(s)[l]
+                indexer = slice(0, 2)
+                self.check(result, s, indexer, False)
 
                 # positional indexing
                 msg = (
                     "cannot do slice indexing "
-                    r"on {klass} with these indexers \[-10\.0\] of "
+                    r"on {klass} with these indexers \[(0|1)\.0\] of "
                     "type float".format(klass=type(index).__name__)
                 )
                 with pytest.raises(TypeError, match=msg):
-                    s[slice(-10.0, 10.0)]
+                    s[l]
 
-                # getitem odd floats
-                for l, res in [
-                    (slice(0.5, 1), slice(1, 2)),
-                    (slice(0, 0.5), slice(0, 1)),
-                    (slice(0.5, 1.5), slice(1, 2)),
-                ]:
+            # getitem out-of-bounds
+            for l in [slice(-10, 10), slice(-10.0, 10.0)]:
 
-                    result = idxr(s)[l]
-                    self.check(result, s, res, False)
+                result = idxr(s)[l]
+                self.check(result, s, slice(-10, 10), True)
 
-                    # positional indexing
-                    msg = (
-                        "cannot do slice indexing "
-                        r"on {klass} with these indexers \[0\.5\] of "
-                        "type float".format(klass=type(index).__name__)
-                    )
-                    with pytest.raises(TypeError, match=msg):
-                        s[l]
+            # positional indexing
+            msg = (
+                "cannot do slice indexing "
+                r"on {klass} with these indexers \[-10\.0\] of "
+                "type float".format(klass=type(index).__name__)
+            )
+            with pytest.raises(TypeError, match=msg):
+                s[slice(-10.0, 10.0)]
 
-                # setitem
-                for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
+            # getitem odd floats
+            for l, res in [
+                (slice(0.5, 1), slice(1, 2)),
+                (slice(0, 0.5), slice(0, 1)),
+                (slice(0.5, 1.5), slice(1, 2)),
+            ]:
 
-                    sc = s.copy()
-                    idxr(sc)[l] = 0
-                    result = idxr(sc)[l].values.ravel()
-                    assert (result == 0).all()
+                result = idxr(s)[l]
+                self.check(result, s, res, False)
 
-                    # positional indexing
-                    msg = (
-                        "cannot do slice indexing "
-                        r"on {klass} with these indexers \[(3|4)\.0\] of "
-                        "type float".format(klass=type(index).__name__)
-                    )
-                    with pytest.raises(TypeError, match=msg):
-                        s[l] = 0
+                # positional indexing
+                msg = (
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[0\.5\] of "
+                    "type float".format(klass=type(index).__name__)
+                )
+                with pytest.raises(TypeError, match=msg):
+                    s[l]
+
+            # setitem
+            for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
+
+                sc = s.copy()
+                idxr(sc)[l] = 0
+                result = idxr(sc)[l].values.ravel()
+                assert (result == 0).all()
+
+                # positional indexing
+                msg = (
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[(3|4)\.0\] of "
+                    "type float".format(klass=type(index).__name__)
+                )
+                with pytest.raises(TypeError, match=msg):
+                    s[l] = 0
 
-            f(lambda x: x.loc)
+        f(lambda x: x.loc)
 
     def test_slice_float(self):
 
diff --git a/pandas/tests/indexing/test_scalar.py b/pandas/tests/indexing/test_scalar.py
index 3622b12b8..899c58eb5 100644
--- a/pandas/tests/indexing/test_scalar.py
+++ b/pandas/tests/indexing/test_scalar.py
@@ -9,61 +9,59 @@ from pandas.tests.indexing.common import Base
 
 
 class TestScalar(Base):
-    def test_at_and_iat_get(self):
+    @pytest.mark.parametrize("kind", ["series", "frame"])
+    def test_at_and_iat_get(self, kind):
         def _check(f, func, values=False):
 
             if f is not None:
-                indicies = self.generate_indices(f, values)
-                for i in indicies:
+                indices = self.generate_indices(f, values)
+                for i in indices:
                     result = getattr(f, func)[i]
                     expected = self.get_value(func, f, i, values)
                     tm.assert_almost_equal(result, expected)
 
-        for kind in self._kinds:
+        d = getattr(self, kind)
 
-            d = getattr(self, kind)
+        # iat
+        for f in [d["ints"], d["uints"]]:
+            _check(f, "iat", values=True)
 
-            # iat
-            for f in [d["ints"], d["uints"]]:
-                _check(f, "iat", values=True)
-
-            for f in [d["labels"], d["ts"], d["floats"]]:
-                if f is not None:
-                    msg = "iAt based indexing can only have integer indexers"
-                    with pytest.raises(ValueError, match=msg):
-                        self.check_values(f, "iat")
+        for f in [d["labels"], d["ts"], d["floats"]]:
+            if f is not None:
+                msg = "iAt based indexing can only have integer indexers"
+                with pytest.raises(ValueError, match=msg):
+                    self.check_values(f, "iat")
 
-            # at
-            for f in [d["ints"], d["uints"], d["labels"], d["ts"], d["floats"]]:
-                _check(f, "at")
+        # at
+        for f in [d["ints"], d["uints"], d["labels"], d["ts"], d["floats"]]:
+            _check(f, "at")
 
-    def test_at_and_iat_set(self):
+    @pytest.mark.parametrize("kind", ["series", "frame"])
+    def test_at_and_iat_set(self, kind):
         def _check(f, func, values=False):
 
             if f is not None:
-                indicies = self.generate_indices(f, values)
-                for i in indicies:
+                indices = self.generate_indices(f, values)
+                for i in indices:
                     getattr(f, func)[i] = 1
                     expected = self.get_value(func, f, i, values)
                     tm.assert_almost_equal(expected, 1)
 
-        for kind in self._kinds:
+        d = getattr(self, kind)
 
-            d = getattr(self, kind)
+        # iat
+        for f in [d["ints"], d["uints"]]:
+            _check(f, "iat", values=True)
 
-            # iat
-            for f in [d["ints"], d["uints"]]:
-                _check(f, "iat", values=True)
-
-            for f in [d["labels"], d["ts"], d["floats"]]:
-                if f is not None:
-                    msg = "iAt based indexing can only have integer indexers"
-                    with pytest.raises(ValueError, match=msg):
-                        _check(f, "iat")
+        for f in [d["labels"], d["ts"], d["floats"]]:
+            if f is not None:
+                msg = "iAt based indexing can only have integer indexers"
+                with pytest.raises(ValueError, match=msg):
+                    _check(f, "iat")
 
-            # at
-            for f in [d["ints"], d["uints"], d["labels"], d["ts"], d["floats"]]:
-                _check(f, "at")
+        # at
+        for f in [d["ints"], d["uints"], d["labels"], d["ts"], d["floats"]]:
+            _check(f, "at")
 
 
 class TestScalar2:

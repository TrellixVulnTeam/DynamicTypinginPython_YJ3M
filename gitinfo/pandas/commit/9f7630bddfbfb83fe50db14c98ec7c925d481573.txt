commit 9f7630bddfbfb83fe50db14c98ec7c925d481573
Author: Chang She <chang@lambdafoundry.com>
Date:   Fri May 11 13:39:39 2012 -0400

    Merged extra keyword with parse_dates

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index a275864de..985da7b29 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -54,9 +54,6 @@ parse_dates : boolean or list of column numbers/name, default False
 date_parser : function
     Function to use for converting dates to strings. Defaults to
     dateutil.parser
-date_conversion : list or dict, default None
-    Can combine multiple columns in date-time specification
-    Newly created columns are prepended to the output
 dayfirst : boolean, default False
     DD/MM format dates, international and European format
 thousands : str, default None
@@ -161,7 +158,8 @@ def _read(cls, filepath_or_buffer, kwds):
             f = com._get_handle(filepath_or_buffer, 'r', encoding=encoding)
 
     if kwds.get('date_parser', None) is not None:
-        kwds['parse_dates'] = True
+        if isinstance(kwds['parse_dates'], bool):
+            kwds['parse_dates'] = True
 
     # Extract some of the arguments (pass chunksize on).
     kwds.pop('filepath_or_buffer')
@@ -192,7 +190,6 @@ def read_csv(filepath_or_buffer,
              parse_dates=False,
              dayfirst=False,
              date_parser=None,
-             date_conversion=None,
              nrows=None,
              iterator=False,
              chunksize=None,
@@ -223,7 +220,6 @@ def read_table(filepath_or_buffer,
                parse_dates=False,
                dayfirst=False,
                date_parser=None,
-               date_conversion=None,
                nrows=None,
                iterator=False,
                chunksize=None,
@@ -258,7 +254,6 @@ def read_fwf(filepath_or_buffer,
              parse_dates=False,
              dayfirst=False,
              date_parser=None,
-             date_conversion=None,
              nrows=None,
              iterator=False,
              chunksize=None,
@@ -360,7 +355,6 @@ class TextParser(object):
         Comment out remainder of line
     parse_dates : boolean, default False
     date_parser : function, default None
-    date_conversion : list or dict, default None
     skiprows : list of integers
         Row numbers to skip
     skip_footer : int
@@ -372,7 +366,7 @@ class TextParser(object):
     def __init__(self, f, delimiter=None, names=None, header=0,
                  index_col=None, na_values=None, thousands=None,
                  comment=None, parse_dates=False,
-                 date_parser=None, date_conversion=None, dayfirst=False,
+                 date_parser=None, dayfirst=False,
                  chunksize=None, skiprows=None, skip_footer=0, converters=None,
                  verbose=False, encoding=None):
         """
@@ -392,7 +386,6 @@ class TextParser(object):
 
         self.parse_dates = parse_dates
         self.date_parser = date_parser
-        self.date_conversion = date_conversion
         self.dayfirst = dayfirst
 
         if com.is_integer(skiprows):
@@ -747,16 +740,10 @@ class TextParser(object):
                 col = self.columns[col]
             data[col] = lib.map_infer(data[col], f)
 
-        if not isinstance(self.parse_dates, bool):
-            for x in self.parse_dates:
-                if isinstance(x, int) and x not in data:
-                    x = self.orig_columns[x]
-                if x in self.index_col or x in self.index_name:
-                    continue
-                data[x] = lib.try_parse_dates(data[x], parser=self.date_parser,
-                                              dayfirst=self.dayfirst)
-
-        data, columns = self._process_date_conversion(data, self.columns)
+        columns = self.columns
+        if (self.parse_dates is not None and
+            not isinstance(self.parse_dates, bool)):
+            data, columns = self._process_date_conversion(data, columns)
 
         data = _convert_to_ndarrays(data, self.na_values, self.verbose)
 
@@ -792,9 +779,6 @@ class TextParser(object):
             return i in to_parse or name in to_parse
 
     def _process_date_conversion(self, data_dict, columns):
-        if self.date_conversion is None:
-            return data_dict, columns
-
         new_cols = []
         new_data = {}
 
@@ -804,26 +788,33 @@ class TextParser(object):
                                            dayfirst=self.dayfirst)
             else:
                 try:
-                    return self.date_parser(date_cols)
+                    return self.date_parser(*date_cols)
                 except:
                     return lib.try_parse_dates(_concat_date_cols(date_cols),
                                                parser=self.date_parser,
                                                dayfirst=self.dayfirst)
 
-        if isinstance(self.date_conversion, list):
+        if isinstance(self.parse_dates, list):
             # list of column lists
-            for colspec in self.date_conversion:
-                new_name, col = _try_convert_dates(date_converter, colspec,
-                                               data_dict, columns)
-                if new_name in data_dict:
-                    raise ValueError('Result date column already in dict %s' %
-                                     new_name)
-                new_data[new_name] = col
-                new_cols.append(new_name)
-
-        elif isinstance(self.date_conversion, dict):
+            for colspec in self.parse_dates:
+                if np.isscalar(colspec):
+                    if isinstance(colspec, int) and colspec not in data_dict:
+                        colspec = self.orig_columns[colspec]
+                    if colspec in self.index_col or colspec in self.index_name:
+                        continue
+                    data_dict[colspec] = date_converter(data_dict[colspec])
+                else:
+                    new_name, col = _try_convert_dates(date_converter, colspec,
+                                                       data_dict, columns)
+                    if new_name in data_dict:
+                        raise ValueError('New date column already in dict %s' %
+                                         new_name)
+                    new_data[new_name] = col
+                    new_cols.append(new_name)
+
+        elif isinstance(self.parse_dates, dict):
             # dict of new name to column list
-            for new_name, colspec in self.date_conversion.iteritems():
+            for new_name, colspec in self.parse_dates.iteritems():
                 if new_name in data_dict:
                     raise ValueError('Date column %s already in dict' %
                                      new_name)
@@ -941,6 +932,8 @@ def _try_convert_dates(parser, colspec, data_dict, columns):
     return new_name, new_col
 
 def _concat_date_cols(date_cols):
+    if len(date_cols) == 1:
+        return date_cols[0]
     concat = lambda x: ' '.join(x)
     return np.array(np.apply_along_axis(concat, 0, np.vstack(date_cols)),
                     dtype=object)
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index a26c591b5..d16953565 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -106,8 +106,8 @@ KORD,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
 
         df = read_table(StringIO(data), sep=',', header=None,
                         date_parser=func,
-                        date_conversion={'nominal' : [1, 2],
-                                         'actual' : [1,3]})
+                        parse_dates={'nominal' : [1, 2],
+                                     'actual' : [1,3]})
         self.assert_('nominal' in df)
         self.assert_('actual' in df)
         from datetime import datetime
@@ -123,7 +123,7 @@ KORD,19990127, 22:00:00, 21:56:00, -0.5900, 1.7100, 5.1000, 0.0000, 290.0000
 KORD,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
 """
         df = read_table(StringIO(data), sep=',', header=None,
-                        date_conversion=[[1, 2], [1,3]])
+                        parse_dates=[[1, 2], [1,3]])
         self.assert_('X.2_X.3' in df)
         self.assert_('X.2_X.4' in df)
         from datetime import datetime

commit 3156395c4a2fbc82372b8ce43566dbe97bc6ba66
Author: Jeff Reback <jeff@reback.net>
Date:   Sun Nov 22 10:37:31 2015 -0500

    DEPR: deprecate pd.rolling_*, pd.expanding_*, pd.ewm*

diff --git a/doc/source/api.rst b/doc/source/api.rst
index eb683fff3..3c7ca6d5c 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -1505,9 +1505,9 @@ Window
 ------
 .. currentmodule:: pandas.core.window
 
-Rolling objects are returned by rolling calls: :func:`pandas.DataFrame.rolling`, :func:`pandas.Series.rolling`, etc.
-Expanding objects are returned by rolling calls: :func:`pandas.DataFrame.expanding`, :func:`pandas.Series.expanding`, etc.
-EWM objects are returned by rolling calls: :func:`pandas.DataFrame.ewm`, :func:`pandas.Series.ewm`, etc.
+Rolling objects are returned by ``.rolling`` calls: :func:`pandas.DataFrame.rolling`, :func:`pandas.Series.rolling`, etc.
+Expanding objects are returned by ``.expanding`` calls: :func:`pandas.DataFrame.expanding`, :func:`pandas.Series.expanding`, etc.
+EWM objects are returned by ``.ewm`` calls: :func:`pandas.DataFrame.ewm`, :func:`pandas.Series.ewm`, etc.
 
 Standard moving window functions
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -1526,13 +1526,13 @@ Standard moving window functions
    Rolling.min
    Rolling.max
    Rolling.corr
-   Rolling.corr_pairwise
    Rolling.cov
    Rolling.skew
    Rolling.kurt
    Rolling.apply
    Rolling.quantile
-   Rolling.window
+   Window.mean
+   Window.sum
 
 .. _api.functions_expanding:
 
@@ -1553,7 +1553,6 @@ Standard expanding window functions
    Expanding.min
    Expanding.max
    Expanding.corr
-   Expanding.corr_pairwise
    Expanding.cov
    Expanding.skew
    Expanding.kurt
diff --git a/doc/source/computation.rst b/doc/source/computation.rst
index bf593acd7..d07257bd2 100644
--- a/doc/source/computation.rst
+++ b/doc/source/computation.rst
@@ -203,8 +203,12 @@ Window Functions
 
 .. warning::
 
-   Prior to version 0.18.0, these were module level functions that have been deprecated.
-   You can see the previous documentation
+   Prior to version 0.18.0, ``pd.rolling_*``, ``pd.expanding_*``, and ``pd.ewm*`` were module level
+   functions and are now deprecated and replaced by the corresponding method call.
+
+   The deprecation warning will show the new syntax, see an example :ref:`here <whatsnew_0180.window_deprecations>`
+
+   You can view the previous documentation
    `here <http://pandas.pydata.org/pandas-docs/version/0.17.1/computation.html#moving-rolling-statistics-moments>`__
 
 For working with data, a number of windows functions are provided for
@@ -242,10 +246,6 @@ accept the following arguments:
   result is NA)
 - ``freq``: optionally specify a :ref:`frequency string <timeseries.alias>`
   or :ref:`DateOffset <timeseries.offsets>` to pre-conform the data to.
-- ``how``: optionally specify method for down or re-sampling.  Default is
-  is ``min`` for :meth:`~Rolling.min`, ``max`` for :meth:`~Rolling.max`, ``median`` for
-  :meth:`~Rolling.median`, and ``mean`` for all other rolling functions.  See
-  :meth:`DataFrame.resample`'s how argument for more information.
 
 We can then call functions on these ``rolling`` objects. Which return like-indexed objects:
 
@@ -323,7 +323,7 @@ compute the mean absolute deviation on a rolling basis:
 Rolling Windows
 ~~~~~~~~~~~~~~~
 
-The :meth:`~Window.mean`, and :meth:`~Window.sum` functions performs a generic rolling window computation
+The :meth:`~Window.mean`, and :meth:`~Window.sum` functions perform a generic rolling window computation
 on the input data. The weights used in the window are specified by the ``win_type``
 keyword. The list of recognized types are:
 
@@ -361,6 +361,9 @@ For some windowing functions, additional parameters must be specified:
 
    ser.rolling(window=5, win_type='gaussian').mean(std=0.1)
 
+Centering Windows
+~~~~~~~~~~~~~~~~~
+
 By default the labels are set to the right edge of the window, but a
 ``center`` keyword is available so the labels can be set at the center.
 This keyword is available in other rolling functions as well.
diff --git a/doc/source/conf.py b/doc/source/conf.py
index 23095b7f4..709d9b329 100644
--- a/doc/source/conf.py
+++ b/doc/source/conf.py
@@ -224,16 +224,7 @@ moved_api_pages = [
     'pandas.io.pickle.read_pickle', 'pandas.io.pytables.HDFStore.append', 'pandas.io.pytables.HDFStore.get',
     'pandas.io.pytables.HDFStore.put', 'pandas.io.pytables.HDFStore.select', 'pandas.io.pytables.read_hdf',
     'pandas.io.sql.read_sql', 'pandas.io.sql.read_frame', 'pandas.io.sql.write_frame',
-    'pandas.io.stata.read_stata', 'pandas.stats.moments.ewma', 'pandas.stats.moments.ewmcorr',
-    'pandas.stats.moments.ewmcov', 'pandas.stats.moments.ewmstd', 'pandas.stats.moments.ewmvar',
-    'pandas.stats.moments.expanding_apply', 'pandas.stats.moments.expanding_corr', 'pandas.stats.moments.expanding_count',
-    'pandas.stats.moments.expanding_cov', 'pandas.stats.moments.expanding_kurt', 'pandas.stats.moments.expanding_mean',
-    'pandas.stats.moments.expanding_median', 'pandas.stats.moments.expanding_quantile', 'pandas.stats.moments.expanding_skew',
-    'pandas.stats.moments.expanding_std', 'pandas.stats.moments.expanding_sum', 'pandas.stats.moments.expanding_var',
-    'pandas.stats.moments.rolling_apply', 'pandas.stats.moments.rolling_corr', 'pandas.stats.moments.rolling_count',
-    'pandas.stats.moments.rolling_cov', 'pandas.stats.moments.rolling_kurt', 'pandas.stats.moments.rolling_mean',
-    'pandas.stats.moments.rolling_median', 'pandas.stats.moments.rolling_quantile', 'pandas.stats.moments.rolling_skew',
-    'pandas.stats.moments.rolling_std', 'pandas.stats.moments.rolling_sum', 'pandas.stats.moments.rolling_var']
+    'pandas.io.stata.read_stata']
 
 html_additional_pages = {'generated/' + page: 'api_redirect.html' for page in moved_api_pages}
 
diff --git a/doc/source/cookbook.rst b/doc/source/cookbook.rst
index 92ed85071..4d6a7457b 100644
--- a/doc/source/cookbook.rst
+++ b/doc/source/cookbook.rst
@@ -517,7 +517,7 @@ Unlike agg, apply's callable is passed a sub-DataFrame which gives you access to
    def Red(x):
       return functools.reduce(CumRet,x,1.0)
 
-   pd.expanding_apply(S, Red)
+   S.expanding().apply(Red)
 
 
 `Replacing some values with mean of the rest of a group
@@ -639,7 +639,7 @@ Create a list of dataframes, split using a delineation based on logic included i
    df = pd.DataFrame(data={'Case' : ['A','A','A','B','A','A','B','A','A'],
                            'Data' : np.random.randn(9)})
 
-   dfs = list(zip(*df.groupby(pd.rolling_median((1*(df['Case']=='B')).cumsum(),3,True))))[-1]
+   dfs = list(zip(*df.groupby((1*(df['Case']=='B')).cumsum().rolling(window=3,min_periods=1).median())))[-1]
 
    dfs[0]
    dfs[1]
diff --git a/doc/source/groupby.rst b/doc/source/groupby.rst
index 4ae2ee192..61f87ebe0 100644
--- a/doc/source/groupby.rst
+++ b/doc/source/groupby.rst
@@ -519,7 +519,7 @@ to standardize the data within each group:
 
    index = pd.date_range('10/1/1999', periods=1100)
    ts = pd.Series(np.random.normal(0.5, 2, 1100), index)
-   ts = pd.rolling_mean(ts, 100, 100).dropna()
+   ts = ts.rolling(window=100,min_periods=100).mean().dropna()
 
    ts.head()
    ts.tail()
diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index 7d5c2d4a9..2a568582d 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -210,18 +210,40 @@ Other API Changes
 Deprecations
 ^^^^^^^^^^^^
 
+.. _whatsnew_0180.window_deprecations:
 
+- Function ``pd.rolling_*``, ``pd.expanding_*``, and ``pd.ewm*`` are deprecated and replaced by the corresponding method call. Note that
+  the new suggested syntax includes all of the arguments (even if default) (:issue:`11603`)
 
+  .. code-block:: python
 
+     In [1]: s = Series(range(3))
 
+     In [2]: pd.rolling_mean(s,window=2,min_periods=1)
+             FutureWarning: pd.rolling_mean is deprecated for Series and will be removed in a future version, replace with
+                  Series.rolling(min_periods=1,window=2,center=False).mean()
+     Out[2]:
+             0    0.0
+             1    0.5
+             2    1.5
+             dtype: float64
+
+     In [3]: pd.rolling_cov(s, s, window=2)
+             FutureWarning: pd.rolling_cov is deprecated for Series and will be removed in a future version, replace with
+                  Series.rolling(window=2).cov(other=<Series>)
+     Out[3]:
+             0    NaN
+             1    0.5
+             2    0.5
+             dtype: float64
 
 .. _whatsnew_0180.prior_deprecations:
 
 Removal of prior version deprecations/changes
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
-Removal of ``rolling_corr_parwise`` in favor of ``.rolling().corr(pairwise=True)`` (:issue:`4950`)
-Removal of ``expanding_corr_parwise`` in favor of ``.expanding().corr(pairwise=True)`` (:issue:`4950`)
+- Removal of ``rolling_corr_parwise`` in favor of ``.rolling().corr(pairwise=True)`` (:issue:`4950`)
+- Removal of ``expanding_corr_parwise`` in favor of ``.expanding().corr(pairwise=True)`` (:issue:`4950`)
 
 
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index e8abc96aa..d3cd08407 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -4741,26 +4741,25 @@ class NDFrame(PandasObject):
 
         @Appender(rwindow.rolling.__doc__)
         def rolling(self, window, min_periods=None, freq=None, center=False,
-                    how=None, win_type=None, axis=0):
+                    win_type=None, axis=0):
             axis = self._get_axis_number(axis)
             return rwindow.rolling(self, window=window, min_periods=min_periods, freq=freq, center=center,
-                                   how=how, win_type=win_type, axis=axis)
+                                   win_type=win_type, axis=axis)
         cls.rolling = rolling
 
         @Appender(rwindow.expanding.__doc__)
-        def expanding(self, min_periods=None, freq=None, center=False,
-                      how=None, axis=0):
+        def expanding(self, min_periods=1, freq=None, center=False, axis=0):
             axis = self._get_axis_number(axis)
             return rwindow.expanding(self, min_periods=min_periods, freq=freq, center=center,
-                                     how=how, axis=axis)
+                                     axis=axis)
         cls.expanding = expanding
 
         @Appender(rwindow.ewm.__doc__)
         def ewm(self, com=None, span=None, halflife=None, min_periods=0, freq=None,
-                adjust=True, how=None, ignore_na=False, axis=0):
+                adjust=True, ignore_na=False, axis=0):
             axis = self._get_axis_number(axis)
             return rwindow.ewm(self, com=com, span=span, halflife=halflife, min_periods=min_periods,
-                               freq=freq, adjust=adjust, how=how, ignore_na=ignore_na, axis=axis)
+                               freq=freq, adjust=adjust, ignore_na=ignore_na, axis=axis)
         cls.ewm = ewm
 
 def _doc_parms(cls):
diff --git a/pandas/core/window.py b/pandas/core/window.py
index 2c311a05f..09dc528f6 100644
--- a/pandas/core/window.py
+++ b/pandas/core/window.py
@@ -33,21 +33,19 @@ See also
 """
 
 class _Window(PandasObject, SelectionMixin):
-    _attributes = ['window','min_periods','freq','center','how','win_type','axis']
+    _attributes = ['window','min_periods','freq','center','win_type','axis']
     exclusions = set()
 
     def __init__(self, obj, window=None, min_periods=None, freq=None, center=False,
-                 how=None, win_type=None, axis=0):
+                 win_type=None, axis=0):
         self.blocks = []
         self.obj = obj
         self.window = window
         self.min_periods = min_periods
         self.freq = freq
         self.center = center
-        self.how = how
         self.win_type = win_type
         self.axis = axis
-        self._convert_freq()
         self._setup()
 
     @property
@@ -57,9 +55,18 @@ class _Window(PandasObject, SelectionMixin):
     def _setup(self):
         pass
 
-    def _create_blocks(self):
-        """ split data into blocks """
-        return self._selected_obj.as_blocks(copy=False).values()
+    def _convert_freq(self, how=None):
+        """ resample according to the how, return a new object """
+        obj = self._selected_obj
+        if self.freq is not None and isinstance(obj, (com.ABCSeries, com.ABCDataFrame)):
+            obj = obj.resample(self.freq, how=how)
+        return obj
+
+    def _create_blocks(self, how):
+        """ split data into blocks & return conformed data """
+
+        obj = self._convert_freq(how)
+        return obj.as_blocks(copy=False).values(), obj
 
     def _gotitem(self, key, ndim, subset=None):
         """
@@ -119,7 +126,7 @@ class _Window(PandasObject, SelectionMixin):
                 kwargs[attr] = getattr(self,attr)
         return self._constructor(obj, **kwargs)
 
-    def _prep_values(self, values=None, kill_inf=True):
+    def _prep_values(self, values=None, kill_inf=True, how=None):
 
         if values is None:
             values = getattr(self._selected_obj,'values',self._selected_obj)
@@ -143,10 +150,11 @@ class _Window(PandasObject, SelectionMixin):
 
         return values
 
-    def _wrap_result(self, result, block=None):
+    def _wrap_result(self, result, block=None, obj=None):
         """ wrap a single result """
 
-        obj = self._selected_obj
+        if obj is None:
+            obj = self._selected_obj
         if isinstance(result, np.ndarray):
 
             # coerce if necessary
@@ -163,14 +171,21 @@ class _Window(PandasObject, SelectionMixin):
                              columns=block.columns)
         return result
 
-    def _wrap_results(self, results, blocks):
-        """ wrap lists of results, blocks """
+    def _wrap_results(self, results, blocks, obj):
+        """
+        wrap the results
+
+        Paramters
+        ---------
+        results : list of ndarrays
+        blocks : list of blocks
+        obj : conformed data (may be resampled)
+        """
 
-        obj = self._selected_obj
         final = []
         for result, block in zip(results, blocks):
 
-            result = self._wrap_result(result, block)
+            result = self._wrap_result(result, block=block, obj=obj)
             if result.ndim == 1:
                 return result
             final.append(result)
@@ -196,13 +211,6 @@ class _Window(PandasObject, SelectionMixin):
                 result = np.copy(result[tuple(lead_indexer)])
         return result
 
-    def _convert_freq(self):
-        """ conform to our freq """
-
-        from pandas import Series, DataFrame
-        if self.freq is not None and isinstance(self.obj, (Series, DataFrame)):
-            self.obj = self.obj.resample(self.freq, how=self.how)
-
     def aggregate(self, arg, *args, **kwargs):
         result, how = self._aggregate(arg, *args, **kwargs)
         if result is None:
@@ -212,6 +220,58 @@ class _Window(PandasObject, SelectionMixin):
     agg = aggregate
 
 class Window(_Window):
+    """
+    Provides rolling transformations.
+
+    .. versionadded:: 0.18.0
+
+    Parameters
+    ----------
+    window : int
+       Size of the moving window. This is the number of observations used for
+       calculating the statistic.
+    min_periods : int, default None
+        Minimum number of observations in window required to have a value
+        (otherwise result is NA).
+    freq : string or DateOffset object, optional (default None)
+        Frequency to conform the data to before computing the statistic. Specified
+        as a frequency string or DateOffset object.
+    center : boolean, default False
+        Set the labels at the center of the window.
+    win_type : string, default None
+        prove a window type, see the notes below
+    axis : int, default 0
+
+    Returns
+    -------
+    a Window sub-classed for the particular operation
+
+    Notes
+    -----
+    By default, the result is set to the right edge of the window. This can be
+    changed to the center of the window by setting ``center=True``.
+
+    The `freq` keyword is used to conform time series data to a specified
+    frequency by resampling the data. This is done with the default parameters
+    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
+
+    The recognized window types are:
+
+        * ``boxcar``
+        * ``triang``
+        * ``blackman``
+        * ``hamming``
+        * ``bartlett``
+        * ``parzen``
+        * ``bohman``
+        * ``blackmanharris``
+        * ``nuttall``
+        * ``barthann``
+        * ``kaiser`` (needs beta)
+        * ``gaussian`` (needs std)
+        * ``general_gaussian`` (needs power, width)
+        * ``slepian`` (needs width).
+    """
 
     def _prep_window(self, **kwargs):
         """ provide validation for our window type, return the window """
@@ -229,7 +289,7 @@ class Window(_Window):
 
         raise ValueError('Invalid window %s' % str(window))
 
-    def _apply_window(self, mean=True, **kwargs):
+    def _apply_window(self, mean=True, how=None, **kwargs):
         """
         Applies a moving window of type ``window_type`` on the data.
 
@@ -237,6 +297,8 @@ class Window(_Window):
         ----------
         mean : boolean, default True
             If True computes weighted mean, else weighted sum
+        how : string, default to None
+            how to resample
 
         Returns
         -------
@@ -246,7 +308,8 @@ class Window(_Window):
         window = self._prep_window(**kwargs)
         center = self.center
 
-        results, blocks = [], self._create_blocks()
+        blocks, obj = self._create_blocks(how=how)
+        results = []
         for b in blocks:
             try:
                 values = self._prep_values(b.values)
@@ -271,7 +334,7 @@ class Window(_Window):
                 result = self._center_window(result, window)
             results.append(result)
 
-        return self._wrap_results(results, blocks)
+        return self._wrap_results(results, blocks, obj)
 
     @Substitution(name='rolling')
     @Appender(SelectionMixin._agg_doc)
@@ -309,6 +372,7 @@ class _Rolling(_Window):
         center : boolean, default to self.center
         check_minp : function, default to _use_window
         how : string, default to None
+            how to resample
 
         Returns
         -------
@@ -322,7 +386,8 @@ class _Rolling(_Window):
         if check_minp is None:
             check_minp = _use_window
 
-        results, blocks = [], self._create_blocks()
+        blocks, obj = self._create_blocks(how=how)
+        results = []
         for b in blocks:
             try:
                 values = self._prep_values(b.values)
@@ -365,13 +430,13 @@ class _Rolling(_Window):
 
             results.append(result)
 
-        return self._wrap_results(results, blocks)
+        return self._wrap_results(results, blocks, obj)
 
 class _Rolling_and_Expanding(_Rolling):
 
     _shared_docs['count'] = """%(name)s count of number of non-NaN observations inside provided window."""
     def count(self):
-        obj = self._selected_obj
+        obj = self._convert_freq()
         window = self._get_window()
         window = min(window, len(obj)) if not self.center else window
         try:
@@ -495,7 +560,7 @@ Parameters
 ----------
 other : Series, DataFrame, or ndarray, optional
     if not supplied then will default to self and produce pairwise output
-pairwise : bool, default False
+pairwise : bool, default None
     If False then only matching columns between self and other will be used and
     the output will be a DataFrame.
     If True then all pairwise combinations will be calculated and the output
@@ -504,10 +569,10 @@ pairwise : bool, default False
 ddof : int, default 1
     Delta Degrees of Freedom.  The divisor used in calculations
     is ``N - ddof``, where ``N`` represents the number of elements."""
-    def cov(self, other=None, pairwise=False, ddof=1):
+    def cov(self, other=None, pairwise=None, ddof=1):
         if other is None:
             other = self._selected_obj
-            pairwise = True
+            pairwise = True if pairwise is None else pairwise  # only default unset
         other = self._shallow_copy(other)
         window = self._get_window(other)
 
@@ -525,16 +590,16 @@ Parameters
 ----------
 other : Series, DataFrame, or ndarray, optional
     if not supplied then will default to self and produce pairwise output
-pairwise : bool, default False
+pairwise : bool, default None
     If False then only matching columns between self and other will be used and
     the output will be a DataFrame.
     If True then all pairwise combinations will be calculated and the output
     will be a Panel in the case of DataFrame inputs. In the case of missing
     elements, only complete pairwise observations will be used."""
-    def corr(self, other=None, pairwise=False):
+    def corr(self, other=None, pairwise=None):
         if other is None:
             other = self._selected_obj
-            pairwise = True
+            pairwise = True if pairwise is None else pairwise  # only default unset
         other = self._shallow_copy(other)
         window = self._get_window(other)
 
@@ -552,6 +617,39 @@ pairwise : bool, default False
         return _flex_binary_moment(self._selected_obj, other._selected_obj, _get_corr, pairwise=bool(pairwise))
 
 class Rolling(_Rolling_and_Expanding):
+    """
+    Provides rolling transformations.
+
+    .. versionadded:: 0.18.0
+
+    Parameters
+    ----------
+    window : int
+       Size of the moving window. This is the number of observations used for
+       calculating the statistic.
+    min_periods : int, default None
+        Minimum number of observations in window required to have a value
+        (otherwise result is NA).
+    freq : string or DateOffset object, optional (default None)
+        Frequency to conform the data to before computing the statistic. Specified
+        as a frequency string or DateOffset object.
+    center : boolean, default False
+        Set the labels at the center of the window.
+    axis : int, default 0
+
+    Returns
+    -------
+    a Window sub-classed for the particular operation
+
+    Notes
+    -----
+    By default, the result is set to the right edge of the window. This can be
+    changed to the center of the window by setting ``center=True``.
+
+    The `freq` keyword is used to conform time series data to a specified
+    frequency by resampling the data. This is done with the default parameters
+    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
+    """
 
     @Substitution(name='rolling')
     @Appender(SelectionMixin._agg_doc)
@@ -589,7 +687,7 @@ class Rolling(_Rolling_and_Expanding):
     @Appender(_doc_template)
     @Appender(_shared_docs['min'])
     def min(self, how='min'):
-        return super(Rolling, self).min()
+        return super(Rolling, self).min(how=how)
 
     @Substitution(name='rolling')
     @Appender(_doc_template)
@@ -636,17 +734,51 @@ class Rolling(_Rolling_and_Expanding):
     @Substitution(name='rolling')
     @Appender(_doc_template)
     @Appender(_shared_docs['cov'])
-    def cov(self, other=None, pairwise=False, ddof=1):
+    def cov(self, other=None, pairwise=None, ddof=1):
         return super(Rolling, self).cov(other=other, pairwise=pairwise, ddof=ddof)
 
     @Substitution(name='rolling')
     @Appender(_doc_template)
     @Appender(_shared_docs['corr'])
-    def corr(self, other=None, pairwise=False):
+    def corr(self, other=None, pairwise=None):
         return super(Rolling, self).corr(other=other, pairwise=pairwise)
 
 class Expanding(_Rolling_and_Expanding):
-    _attributes = ['min_periods','freq','center','how','axis']
+    """
+    Provides expanding transformations.
+
+    .. versionadded:: 0.18.0
+
+    Parameters
+    ----------
+    min_periods : int, default None
+        Minimum number of observations in window required to have a value
+        (otherwise result is NA).
+    freq : string or DateOffset object, optional (default None)
+        Frequency to conform the data to before computing the statistic. Specified
+        as a frequency string or DateOffset object.
+    center : boolean, default False
+        Set the labels at the center of the window.
+    axis : int, default 0
+
+    Returns
+    -------
+    a Window sub-classed for the particular operation
+
+    Notes
+    -----
+    By default, the result is set to the right edge of the window. This can be
+    changed to the center of the window by setting ``center=True``.
+
+    The `freq` keyword is used to conform time series data to a specified
+    frequency by resampling the data. This is done with the default parameters
+    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
+    """
+
+    _attributes = ['min_periods','freq','center','axis']
+
+    def __init__(self, obj, min_periods=1, freq=None, center=False, axis=0, **kwargs):
+        return super(Expanding, self).__init__(obj=obj, min_periods=min_periods, freq=freq, center=center, axis=axis)
 
     @property
     def _constructor(self):
@@ -694,7 +826,7 @@ class Expanding(_Rolling_and_Expanding):
     @Appender(_doc_template)
     @Appender(_shared_docs['min'])
     def min(self, how='min'):
-        return super(Expanding, self).min()
+        return super(Expanding, self).min(how=how)
 
     @Substitution(name='expanding')
     @Appender(_doc_template)
@@ -741,29 +873,93 @@ class Expanding(_Rolling_and_Expanding):
     @Substitution(name='expanding')
     @Appender(_doc_template)
     @Appender(_shared_docs['cov'])
-    def cov(self, other=None, pairwise=False, ddof=1):
+    def cov(self, other=None, pairwise=None, ddof=1):
         return super(Expanding, self).cov(other=other, pairwise=pairwise, ddof=ddof)
 
     @Substitution(name='expanding')
     @Appender(_doc_template)
     @Appender(_shared_docs['corr'])
-    def corr(self, other=None, pairwise=False):
+    def corr(self, other=None, pairwise=None):
         return super(Expanding, self).corr(other=other, pairwise=pairwise)
 
 class EWM(_Rolling):
-    _attributes = ['com','min_periods','freq','adjust','how','ignore_na','axis']
+    """
+    .. versionadded:: 0.18.0
+
+    Provides exponential weighted functions
+
+    Parameters
+    ----------
+    com : float. optional
+        Center of mass: :math:`\alpha = 1 / (1 + com)`,
+    span : float, optional
+        Specify decay in terms of span, :math:`\alpha = 2 / (span + 1)`
+    halflife : float, optional
+        Specify decay in terms of halflife, :math:`\alpha = 1 - exp(log(0.5) / halflife)`
+    min_periods : int, default 0
+        Minimum number of observations in window required to have a value
+        (otherwise result is NA).
+    freq : None or string alias / date offset object, default=None
+        Frequency to conform to before computing statistic
+    adjust : boolean, default True
+        Divide by decaying adjustment factor in beginning periods to account for
+        imbalance in relative weightings (viewing EWMA as a moving average)
+    ignore_na : boolean, default False
+        Ignore missing values when calculating weights;
+        specify True to reproduce pre-0.15.0 behavior
+
+    Returns
+    -------
+    a Window sub-classed for the particular operation
+
+    Notes
+    -----
+    Either center of mass, span or halflife must be specified
+
+    EWMA is sometimes specified using a "span" parameter `s`, we have that the
+    decay parameter :math:`\alpha` is related to the span as
+    :math:`\alpha = 2 / (s + 1) = 1 / (1 + c)`
+
+    where `c` is the center of mass. Given a span, the associated center of mass is
+    :math:`c = (s - 1) / 2`
+
+    So a "20-day EWMA" would have center 9.5.
+
+    The `freq` keyword is used to conform time series data to a specified
+    frequency by resampling the data. This is done with the default parameters
+    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
+
+    When adjust is True (default), weighted averages are calculated using weights
+        (1-alpha)**(n-1), (1-alpha)**(n-2), ..., 1-alpha, 1.
+
+    When adjust is False, weighted averages are calculated recursively as:
+       weighted_average[0] = arg[0];
+       weighted_average[i] = (1-alpha)*weighted_average[i-1] + alpha*arg[i].
+
+    When ignore_na is False (default), weights are based on absolute positions.
+    For example, the weights of x and y used in calculating the final weighted
+    average of [x, None, y] are (1-alpha)**2 and 1 (if adjust is True), and
+    (1-alpha)**2 and alpha (if adjust is False).
+
+    When ignore_na is True (reproducing pre-0.15.0 behavior), weights are based on
+    relative positions. For example, the weights of x and y used in calculating
+    the final weighted average of [x, None, y] are 1-alpha and 1 (if adjust is
+    True), and 1-alpha and alpha (if adjust is False).
+
+    More details can be found at
+    http://pandas.pydata.org/pandas-docs/stable/computation.html#exponentially-weighted-moment-functions
+    """
+    _attributes = ['com','min_periods','freq','adjust','ignore_na','axis']
 
     def __init__(self, obj, com=None, span=None, halflife=None, min_periods=0, freq=None,
-                 adjust=True, how=None, ignore_na=False, axis=0):
+                 adjust=True, ignore_na=False, axis=0):
         self.obj = obj
         self.com = _get_center_of_mass(com, span, halflife)
         self.min_periods = min_periods
         self.freq = freq
         self.adjust = adjust
-        self.how = how
         self.ignore_na = ignore_na
         self.axis = axis
-        self._convert_freq()
 
     @property
     def _constructor(self):
@@ -777,20 +973,23 @@ class EWM(_Rolling):
 
     agg = aggregate
 
-    def _apply(self, func, **kwargs):
+    def _apply(self, func, how=None, **kwargs):
         """Rolling statistical measure using supplied function. Designed to be
         used with passed-in Cython array-based functions.
 
         Parameters
         ----------
         func : string/callable to apply
+        how : string, default to None
+            how to resample
 
         Returns
         -------
         y : type of input argument
 
         """
-        results, blocks = [], self._create_blocks()
+        blocks, obj = self._create_blocks(how=how)
+        results = []
         for b in blocks:
             try:
                 values = self._prep_values(b.values)
@@ -813,7 +1012,7 @@ class EWM(_Rolling):
 
             results.append(np.apply_along_axis(func, self.axis, values))
 
-        return self._wrap_results(results, blocks)
+        return self._wrap_results(results, blocks, obj)
 
     @Substitution(name='ewm')
     @Appender(_doc_template)
@@ -857,14 +1056,14 @@ class EWM(_Rolling):
 
     @Substitution(name='ewm')
     @Appender(_doc_template)
-    def cov(self, other=None, pairwise=False, bias=False):
+    def cov(self, other=None, pairwise=None, bias=False):
         """exponential weighted sample covariance
 
         Parameters
         ----------
         other : Series, DataFrame, or ndarray, optional
             if not supplied then will default to self and produce pairwise output
-        pairwise : bool, default False
+        pairwise : bool, default None
             If False then only matching columns between self and other will be used and
             the output will be a DataFrame.
             If True then all pairwise combinations will be calculated and the output
@@ -875,7 +1074,7 @@ class EWM(_Rolling):
         """
         if other is None:
             other = self._selected_obj
-            pairwise = True
+            pairwise = True if pairwise is None else pairwise  # only default unset
         other = self._shallow_copy(other)
 
         def _get_cov(X, Y):
@@ -894,14 +1093,14 @@ class EWM(_Rolling):
 
     @Substitution(name='ewm')
     @Appender(_doc_template)
-    def corr(self, other=None, pairwise=False):
+    def corr(self, other=None, pairwise=None):
         """exponential weighted sample correlation
 
         Parameters
         ----------
         other : Series, DataFrame, or ndarray, optional
             if not supplied then will default to self and produce pairwise output
-        pairwise : bool, default False
+        pairwise : bool, default None
             If False then only matching columns between self and other will be used and
             the output will be a DataFrame.
             If True then all pairwise combinations will be calculated and the output
@@ -910,7 +1109,7 @@ class EWM(_Rolling):
         """
         if other is None:
             other = self._selected_obj
-            pairwise = True
+            pairwise = True if pairwise is None else pairwise  # only default unset
         other = self._shallow_copy(other)
 
         def _get_corr(X, Y):
@@ -1089,60 +1288,6 @@ def _pop_args(win_type, arg_names, kwargs):
 #############################
 
 def rolling(obj, win_type=None, **kwds):
-    """
-    Provides rolling transformations.
-
-    .. versionadded:: 0.18.0
-
-    Parameters
-    ----------
-    window : int
-       Size of the moving window. This is the number of observations used for
-       calculating the statistic.
-    min_periods : int, default None
-        Minimum number of observations in window required to have a value
-        (otherwise result is NA).
-    freq : string or DateOffset object, optional (default None)
-        Frequency to conform the data to before computing the statistic. Specified
-        as a frequency string or DateOffset object.
-    center : boolean, default False
-        Set the labels at the center of the window.
-    how : string, default None
-        Method for down- or re-sampling
-    win_type : string, default None
-        prove a window type, see the notes below
-    axis : int, default 0
-
-    Returns
-    -------
-    a Window sub-classed for the particular operation
-
-    Notes
-    -----
-    By default, the result is set to the right edge of the window. This can be
-    changed to the center of the window by setting ``center=True``.
-
-    The `freq` keyword is used to conform time series data to a specified
-    frequency by resampling the data. This is done with the default parameters
-    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
-
-    The recognized window types are:
-
-        * ``boxcar``
-        * ``triang``
-        * ``blackman``
-        * ``hamming``
-        * ``bartlett``
-        * ``parzen``
-        * ``bohman``
-        * ``blackmanharris``
-        * ``nuttall``
-        * ``barthann``
-        * ``kaiser`` (needs beta)
-        * ``gaussian`` (needs std)
-        * ``general_gaussian`` (needs power, width)
-        * ``slepian`` (needs width).
-    """
     from pandas import Series, DataFrame
     if not isinstance(obj, (Series, DataFrame)):
         raise TypeError('invalid type: %s' % type(obj))
@@ -1151,118 +1296,20 @@ def rolling(obj, win_type=None, **kwds):
         return Window(obj, win_type=win_type, **kwds)
 
     return Rolling(obj, **kwds)
+rolling.__doc__ = Window.__doc__
 
 def expanding(obj, **kwds):
-    """
-    Provides expanding transformations.
-
-    .. versionadded:: 0.18.0
-
-    Parameters
-    ----------
-    min_periods : int, default None
-        Minimum number of observations in window required to have a value
-        (otherwise result is NA).
-    freq : string or DateOffset object, optional (default None)
-        Frequency to conform the data to before computing the statistic. Specified
-        as a frequency string or DateOffset object.
-    center : boolean, default False
-        Set the labels at the center of the window.
-    how : string, default None
-        Method for down- or re-sampling
-    axis : int, default 0
-
-    Returns
-    -------
-    a Window sub-classed for the particular operation
-
-    Notes
-    -----
-    By default, the result is set to the right edge of the window. This can be
-    changed to the center of the window by setting ``center=True``.
-
-    The `freq` keyword is used to conform time series data to a specified
-    frequency by resampling the data. This is done with the default parameters
-    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
-    """
-
     from pandas import Series, DataFrame
     if not isinstance(obj, (Series, DataFrame)):
         raise TypeError('invalid type: %s' % type(obj))
 
     return Expanding(obj, **kwds)
+expanding.__doc__ = Expanding.__doc__
 
 def ewm(obj, **kwds):
-    """
-    .. versionadded:: 0.18.0
-
-    Provides exponential weighted functions
-
-    Parameters
-    ----------
-    com : float. optional
-        Center of mass: :math:`\alpha = 1 / (1 + com)`,
-    span : float, optional
-        Specify decay in terms of span, :math:`\alpha = 2 / (span + 1)`
-    halflife : float, optional
-        Specify decay in terms of halflife, :math:`\alpha = 1 - exp(log(0.5) / halflife)`
-    min_periods : int, default 0
-        Minimum number of observations in window required to have a value
-        (otherwise result is NA).
-    freq : None or string alias / date offset object, default=None
-        Frequency to conform to before computing statistic
-    adjust : boolean, default True
-        Divide by decaying adjustment factor in beginning periods to account for
-        imbalance in relative weightings (viewing EWMA as a moving average)
-    how : string, default 'mean'
-        Method for down- or re-sampling
-    ignore_na : boolean, default False
-        Ignore missing values when calculating weights;
-        specify True to reproduce pre-0.15.0 behavior
-
-    Returns
-    -------
-    a Window sub-classed for the particular operation
-
-    Notes
-    -----
-    Either center of mass, span or halflife must be specified
-
-    EWMA is sometimes specified using a "span" parameter `s`, we have that the
-    decay parameter :math:`\alpha` is related to the span as
-    :math:`\alpha = 2 / (s + 1) = 1 / (1 + c)`
-
-    where `c` is the center of mass. Given a span, the associated center of mass is
-    :math:`c = (s - 1) / 2`
-
-    So a "20-day EWMA" would have center 9.5.
-
-    The `freq` keyword is used to conform time series data to a specified
-    frequency by resampling the data. This is done with the default parameters
-    of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
-
-    When adjust is True (default), weighted averages are calculated using weights
-        (1-alpha)**(n-1), (1-alpha)**(n-2), ..., 1-alpha, 1.
-
-    When adjust is False, weighted averages are calculated recursively as:
-       weighted_average[0] = arg[0];
-       weighted_average[i] = (1-alpha)*weighted_average[i-1] + alpha*arg[i].
-
-    When ignore_na is False (default), weights are based on absolute positions.
-    For example, the weights of x and y used in calculating the final weighted
-    average of [x, None, y] are (1-alpha)**2 and 1 (if adjust is True), and
-    (1-alpha)**2 and alpha (if adjust is False).
-
-    When ignore_na is True (reproducing pre-0.15.0 behavior), weights are based on
-    relative positions. For example, the weights of x and y used in calculating
-    the final weighted average of [x, None, y] are 1-alpha and 1 (if adjust is
-    True), and 1-alpha and alpha (if adjust is False).
-
-    More details can be found at
-    http://pandas.pydata.org/pandas-docs/stable/computation.html#exponentially-weighted-moment-functions
-    """
     from pandas import Series, DataFrame
     if not isinstance(obj, (Series, DataFrame)):
         raise TypeError('invalid type: %s' % type(obj))
 
     return EWM(obj, **kwds)
+ewm.__doc__ = EWM.__doc__
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 71c1ae300..28f35cf26 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -4,7 +4,9 @@ statistics implemented in Cython
 """
 from __future__ import division
 
+import warnings
 import numpy as np
+from pandas import lib
 from pandas.core.api import DataFrame, Series
 from pandas.util.decorators import Substitution, Appender
 
@@ -187,6 +189,10 @@ def ensure_compat(dispatch, name, arg, func_kw=None, *args, **kwargs):
         else:
             raise AssertionError("cannot support ndim > 2 for ndarray compat")
 
+        warnings.warn("pd.{dispatch}_{name} is deprecated for ndarrays and will be removed "
+                      "in a future version".format(dispatch=dispatch,name=name),
+                      FutureWarning, stacklevel=3)
+
     # get the functional keywords here
     if func_kw is None:
         func_kw = []
@@ -195,7 +201,37 @@ def ensure_compat(dispatch, name, arg, func_kw=None, *args, **kwargs):
         value = kwargs.pop(k,None)
         if value is not None:
             kwds[k] = value
+
+    # how is a keyword that if not-None should be in kwds
+    how = kwargs.pop('how',None)
+    if how is not None:
+        kwds['how'] = how
+
     r = getattr(arg,dispatch)(**kwargs)
+
+    if not is_ndarray:
+
+        # give a helpful deprecation message
+        # with copy-pastable arguments
+        pargs = ','.join([ "{a}={b}".format(a=a,b=b) for a,b in kwargs.items() if b is not None ])
+        aargs = ','.join(args)
+        if len(aargs):
+            aargs += ','
+
+        def f(a,b):
+            if lib.isscalar(b):
+                return "{a}={b}".format(a=a,b=b)
+            return "{a}=<{b}>".format(a=a,b=type(b).__name__)
+        aargs = ','.join([ f(a,b) for a,b in kwds.items() if b is not None ])
+        warnings.warn("pd.{dispatch}_{name} is deprecated for {klass} "
+                      "and will be removed in a future version, replace with "
+                      "\n\t{klass}.{dispatch}({pargs}).{name}({aargs})".format(klass=type(arg).__name__,
+                                                                               pargs=pargs,
+                                                                               aargs=aargs,
+                                                                               dispatch=dispatch,
+                                                                               name=name),
+                      FutureWarning, stacklevel=3)
+
     result = getattr(r,name)(*args, **kwds)
 
     if is_ndarray:
@@ -404,8 +440,9 @@ def _rolling_func(name, desc, how=None, func_kw=None, additional_kw=''):
     @Substitution(desc, _unary_arg, _roll_kw%how_arg_str + additional_kw,
                   _type_of_input_retval, _roll_notes)
     @Appender(_doc_template)
-    def f(arg, window, min_periods=None, freq=None, center=False, how=how,
+    def f(arg, window, min_periods=None, freq=None, center=False,
           **kwargs):
+
         return ensure_compat('rolling',
                              name,
                              arg,
@@ -413,7 +450,6 @@ def _rolling_func(name, desc, how=None, func_kw=None, additional_kw=''):
                              min_periods=min_periods,
                              freq=freq,
                              center=center,
-                             how=how,
                              func_kw=func_kw,
                              **kwargs)
     return f
@@ -597,7 +633,6 @@ def rolling_window(arg, window=None, win_type=None, min_periods=None,
                          center=center,
                          min_periods=min_periods,
                          axis=axis,
-                         how=how,
                          func_kw=kwargs.keys(),
                          **kwargs)
 
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index 41d2c8fa8..5517ce967 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -168,22 +168,38 @@ class TestApi(Base):
         expected = pd.concat([a_sum,rcustom],axis=1)
         compare(result, expected)
 
+class TestDeprecations(Base):
+    """ test that we are catching deprecation warnings """
+
+    def setUp(self):
+        self._create_data()
+
+
+    def test_deprecations(self):
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            mom.rolling_mean(np.ones(10),3,center=True ,axis=0)
+            mom.rolling_mean(Series(np.ones(10)),3,center=True ,axis=0)
+
 class TestMoments(Base):
 
     def setUp(self):
         self._create_data()
 
     def test_centered_axis_validation(self):
+
         # ok
-        mom.rolling_mean(Series(np.ones(10)),3,center=True ,axis=0)
+        Series(np.ones(10)).rolling(window=3,center=True ,axis=0).mean()
+
         # bad axis
-        self.assertRaises(ValueError, mom.rolling_mean,Series(np.ones(10)),3,center=True ,axis=1)
+        self.assertRaises(ValueError, lambda : Series(np.ones(10)).rolling(window=3,center=True ,axis=1).mean())
 
         # ok ok
-        mom.rolling_mean(DataFrame(np.ones((10,10))),3,center=True ,axis=0)
-        mom.rolling_mean(DataFrame(np.ones((10,10))),3,center=True ,axis=1)
+        DataFrame(np.ones((10,10))).rolling(window=3,center=True ,axis=0).mean()
+        DataFrame(np.ones((10,10))).rolling(window=3,center=True ,axis=1).mean()
+
         # bad axis
-        self.assertRaises(ValueError, mom.rolling_mean,DataFrame(np.ones((10,10))),3,center=True ,axis=2)
+        self.assertRaises(ValueError, lambda : DataFrame(np.ones((10,10))).rolling(window=3,center=True ,axis=2).mean())
 
     def test_rolling_sum(self):
         self._check_moment_func(mom.rolling_sum, np.sum, name='sum')
@@ -208,11 +224,12 @@ class TestMoments(Base):
         xp = np.array([np.nan, np.nan, 9.962, 11.27 , 11.564, 12.516,
                        12.818,  12.952, np.nan, np.nan])
 
-        rs = mom.rolling_mean(vals, 5, center=True)
-        assert_almost_equal(xp, rs)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            rs = mom.rolling_mean(vals, 5, center=True)
+            assert_almost_equal(xp, rs)
 
         xp = Series(rs)
-        rs = mom.rolling_mean(Series(vals), 5, center=True)
+        rs = Series(vals).rolling(5, center=True).mean()
         assert_series_equal(xp, rs)
 
     def test_cmov_window(self):
@@ -224,13 +241,11 @@ class TestMoments(Base):
         xp = np.array([np.nan, np.nan, 9.962, 11.27 , 11.564, 12.516,
                        12.818,  12.952, np.nan, np.nan])
 
-        rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
-        assert_almost_equal(xp, rs)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
+            assert_almost_equal(xp, rs)
 
         xp = Series(rs)
-        rs = mom.rolling_window(Series(vals), 5, 'boxcar', center=True)
-        assert_series_equal(xp, rs)
-
         rs = Series(vals).rolling(5, win_type='boxcar', center=True).mean()
         assert_series_equal(xp, rs)
 
@@ -241,19 +256,22 @@ class TestMoments(Base):
         # all nan
         vals = np.empty(10, dtype=float)
         vals.fill(np.nan)
-        rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
-        self.assertTrue(np.isnan(rs).all())
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
+            self.assertTrue(np.isnan(rs).all())
 
         # empty
         vals = np.array([])
-        rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
-        self.assertEqual(len(rs), 0)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            rs = mom.rolling_window(vals, 5, 'boxcar', center=True)
+            self.assertEqual(len(rs), 0)
 
         # shorter than window
         vals = np.random.randn(5)
-        rs = mom.rolling_window(vals, 10, 'boxcar')
-        self.assertTrue(np.isnan(rs).all())
-        self.assertEqual(len(rs), 5)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            rs = mom.rolling_window(vals, 10, 'boxcar')
+            self.assertTrue(np.isnan(rs).all())
+            self.assertEqual(len(rs), 5)
 
     def test_cmov_window_frame(self):
         # Gh 8238
@@ -282,9 +300,6 @@ class TestMoments(Base):
                        [ np.nan,  np.nan]])
 
         # DataFrame
-        rs = mom.rolling_window(DataFrame(vals), 5, 'boxcar', center=True)
-        assert_frame_equal(DataFrame(xp), rs)
-
         rs = DataFrame(vals).rolling(5, win_type='boxcar', center=True).mean()
         assert_frame_equal(DataFrame(xp), rs)
 
@@ -314,10 +329,7 @@ class TestMoments(Base):
         vals[4] = np.nan
         vals[8] = np.nan
 
-        xp = mom.rolling_mean(vals, 5, min_periods=4, center=True)
-        rs = mom.rolling_window(vals, 5, 'boxcar', min_periods=4, center=True)
-        assert_series_equal(xp, rs)
-
+        xp = vals.rolling(5, min_periods=4, center=True).mean()
         rs = vals.rolling(5, win_type='boxcar', min_periods=4, center=True).mean()
         assert_series_equal(xp, rs)
 
@@ -350,9 +362,6 @@ class TestMoments(Base):
 
         for wt in win_types:
             xp = Series(xps[wt])
-            rs = mom.rolling_window(Series(vals), 5, wt, center=True)
-            assert_series_equal(xp, rs)
-
             rs = Series(vals).rolling(5, win_type=wt, center=True).mean()
             assert_series_equal(xp, rs)
 
@@ -370,9 +379,6 @@ class TestMoments(Base):
         xp = Series(xp)
 
         for wt in win_types:
-            rs = mom.rolling_window(Series(vals), 5, wt, center=True)
-            assert_series_equal(xp, rs)
-
             rs = Series(vals).rolling(5, win_type=wt, center=True).mean()
             assert_series_equal(xp, rs)
 
@@ -407,9 +413,6 @@ class TestMoments(Base):
 
         for wt in win_types:
             xp = Series(xps[wt])
-            rs = mom.rolling_window(Series(vals), 5, wt, min_periods=3)
-            assert_series_equal(xp, rs)
-
             rs = Series(vals).rolling(5, win_type=wt, min_periods=3).mean()
             assert_series_equal(xp, rs)
 
@@ -438,11 +441,6 @@ class TestMoments(Base):
 
         for wt, k in zip(win_types, kwds):
             xp = Series(xps[wt])
-
-            rs = mom.rolling_window(Series(vals), 5, wt, center=True,
-                                    **k)
-            assert_series_equal(xp, rs)
-
             rs = Series(vals).rolling(5, win_type=wt, center=True).mean(**k)
             assert_series_equal(xp, rs)
 
@@ -461,10 +459,6 @@ class TestMoments(Base):
         xp = Series(xp)
 
         for wt, k in zip(win_types, kwds):
-            rs = mom.rolling_window(Series(vals), 5, wt, center=True,
-                                    **k)
-            assert_series_equal(xp, rs)
-
             rs = Series(vals).rolling(5, win_type=wt, center=True).mean(**k)
             assert_series_equal(xp, rs)
 
@@ -474,22 +468,25 @@ class TestMoments(Base):
     def test_rolling_min(self):
         self._check_moment_func(mom.rolling_min, np.min, name='min')
 
-        a = np.array([1, 2, 3, 4, 5])
-        b = mom.rolling_min(a, window=100, min_periods=1)
-        assert_almost_equal(b, np.ones(len(a)))
 
-        self.assertRaises(ValueError, mom.rolling_min, np.array([1,
-                          2, 3]), window=3, min_periods=5)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            a = np.array([1, 2, 3, 4, 5])
+            b = mom.rolling_min(a, window=100, min_periods=1)
+            assert_almost_equal(b, np.ones(len(a)))
+
+            self.assertRaises(ValueError, mom.rolling_min,
+                              np.array([1,2, 3]), window=3, min_periods=5)
 
     def test_rolling_max(self):
         self._check_moment_func(mom.rolling_max, np.max, name='max')
 
-        a = np.array([1, 2, 3, 4, 5])
-        b = mom.rolling_max(a, window=100, min_periods=1)
-        assert_almost_equal(a, b)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            a = np.array([1, 2, 3, 4, 5])
+            b = mom.rolling_max(a, window=100, min_periods=1)
+            assert_almost_equal(a, b)
 
-        self.assertRaises(ValueError, mom.rolling_max, np.array([1,
-                          2, 3]), window=3, min_periods=5)
+            self.assertRaises(ValueError, mom.rolling_max, np.array([1,2, 3]),
+                              window=3, min_periods=5)
 
     def test_rolling_quantile(self):
         qs = [.1, .5, .9]
@@ -518,11 +515,12 @@ class TestMoments(Base):
             warnings.filterwarnings("ignore", message=".*(empty slice|0 for slice).*", category=RuntimeWarning)
 
             ser = Series([])
-            assert_series_equal(ser, mom.rolling_apply(ser, 10, lambda x: x.mean()))
+            assert_series_equal(ser, ser.rolling(10).apply(lambda x: x.mean()))
 
             f = lambda x: x[np.isfinite(x)].mean()
             def roll_mean(x, window, min_periods=None, freq=None, center=False, **kwargs):
-                return mom.rolling_apply(x, window,
+                return mom.rolling_apply(x,
+                                         window,
                                          func=f,
                                          min_periods=min_periods,
                                          freq=freq,
@@ -531,7 +529,7 @@ class TestMoments(Base):
 
         # GH 8080
         s = Series([None, None, None])
-        result = mom.rolling_apply(s, 2, lambda x: len(x), min_periods=0)
+        result = s.rolling(2,min_periods=0).apply(lambda x: len(x))
         expected = Series([1., 2., 2.])
         assert_series_equal(result, expected)
 
@@ -543,10 +541,12 @@ class TestMoments(Base):
         arr = np.arange(4)
 
         # it works!
-        result = mom.rolling_apply(arr, 10, np.sum)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_apply(arr, 10, np.sum)
         self.assertTrue(isnull(result).all())
 
-        result = mom.rolling_apply(arr, 10, np.sum, min_periods=1)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_apply(arr, 10, np.sum, min_periods=1)
         assert_almost_equal(result, result)
 
     def test_rolling_std(self):
@@ -559,18 +559,21 @@ class TestMoments(Base):
                                 ddof=0)
 
     def test_rolling_std_1obs(self):
-        result = mom.rolling_std(np.array([1., 2., 3., 4., 5.]),
-                                 1, min_periods=1)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_std(np.array([1., 2., 3., 4., 5.]),
+                                     1, min_periods=1)
         expected = np.array([np.nan] * 5)
         assert_almost_equal(result, expected)
 
-        result = mom.rolling_std(np.array([1., 2., 3., 4., 5.]),
-                                 1, min_periods=1, ddof=0)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_std(np.array([1., 2., 3., 4., 5.]),
+                                     1, min_periods=1, ddof=0)
         expected = np.zeros(5)
         assert_almost_equal(result, expected)
 
-        result = mom.rolling_std(np.array([np.nan, np.nan, 3., 4., 5.]),
-                                 3, min_periods=2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_std(np.array([np.nan, np.nan, 3., 4., 5.]),
+                                     3, min_periods=2)
         self.assertTrue(np.isnan(result[2]))
 
     def test_rolling_std_neg_sqrt(self):
@@ -583,10 +586,12 @@ class TestMoments(Base):
                       0.00028718669878572767,
                       0.00028718669878572767,
                       0.00028718669878572767])
-        b = mom.rolling_std(a, window=3)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            b = mom.rolling_std(a, window=3)
         self.assertTrue(np.isfinite(b[2:]).all())
 
-        b = mom.ewmstd(a, span=3)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            b = mom.ewmstd(a, span=3)
         self.assertTrue(np.isfinite(b[2:]).all())
 
     def test_rolling_var(self):
@@ -629,21 +634,26 @@ class TestMoments(Base):
         if sys.byteorder != "little":
             arr = arr.byteswap().newbyteorder()
 
-        result = mom.rolling_sum(arr, 2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_sum(arr, 2)
         self.assertTrue((result[1:] >= 0).all())
 
-        result = mom.rolling_mean(arr, 2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_mean(arr, 2)
         self.assertTrue((result[1:] >= 0).all())
 
-        result = mom.rolling_var(arr, 2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_var(arr, 2)
         self.assertTrue((result[1:] >= 0).all())
 
         # #2527, ugh
         arr = np.array([0.00012456, 0.0003, 0])
-        result = mom.rolling_mean(arr, 1)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_mean(arr, 1)
         self.assertTrue(result[-1] >= 0)
 
-        result = mom.rolling_mean(-arr, 1)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.rolling_mean(-arr, 1)
         self.assertTrue(result[-1] <= 0)
 
     def _check_moment_func(self, f, static_comp,
@@ -657,20 +667,22 @@ class TestMoments(Base):
                            test_stable=False,
                            **kwargs):
 
-        self._check_ndarray(f, static_comp, window=window,
-                            has_min_periods=has_min_periods,
-                            preserve_nan=preserve_nan,
-                            has_center=has_center,
-                            fill_value=fill_value,
-                            test_stable=test_stable,
-                            **kwargs)
-
-        self._check_structures(f, static_comp,
-                               has_min_periods=has_min_periods,
-                               has_time_rule=has_time_rule,
-                               fill_value=fill_value,
-                               has_center=has_center,
-                               **kwargs)
+        with warnings.catch_warnings(record=True):
+            self._check_ndarray(f, static_comp, window=window,
+                                has_min_periods=has_min_periods,
+                                preserve_nan=preserve_nan,
+                                has_center=has_center,
+                                fill_value=fill_value,
+                                test_stable=test_stable,
+                                **kwargs)
+
+        with warnings.catch_warnings(record=True):
+            self._check_structures(f, static_comp,
+                                   has_min_periods=has_min_periods,
+                                   has_time_rule=has_time_rule,
+                                   fill_value=fill_value,
+                                   has_center=has_center,
+                                   **kwargs)
 
         # new API
         if name is not None:
@@ -786,12 +798,13 @@ class TestMoments(Base):
                                            center=center),name)(**kwargs)
 
             # check via the moments API
-            return f(obj,
-                     window=window,
-                     min_periods=min_periods,
-                     freq=freq,
-                     center=center,
-                     **kwargs)
+            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+                return f(obj,
+                         window=window,
+                         min_periods=min_periods,
+                         freq=freq,
+                         center=center,
+                        **kwargs)
 
         series_result = get_result(self.series, window=50)
         frame_result = get_result(self.frame, window=50)
@@ -867,20 +880,18 @@ class TestMoments(Base):
             assert_frame_equal(frame_xp, frame_rs)
 
     def test_ewma(self):
-        self._check_ew(mom.ewma)
+        self._check_ew(mom.ewma,name='mean')
 
         arr = np.zeros(1000)
         arr[5] = 1
-        result = mom.ewma(arr, span=100, adjust=False).sum()
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = mom.ewma(arr, span=100, adjust=False).sum()
         self.assertTrue(np.abs(result - 1) < 1e-2)
 
         s = Series([1.0, 2.0, 4.0, 8.0])
 
         expected = Series([1.0, 1.6, 2.736842, 4.923077])
-        for f in [lambda s: mom.ewma(s, com=2.0, adjust=True),
-                  lambda s: mom.ewma(s, com=2.0, adjust=True, ignore_na=False),
-                  lambda s: mom.ewma(s, com=2.0, adjust=True, ignore_na=True),
-                  lambda s: s.ewm(com=2.0, adjust=True).mean(),
+        for f in [lambda s: s.ewm(com=2.0, adjust=True).mean(),
                   lambda s: s.ewm(com=2.0, adjust=True, ignore_na=False).mean(),
                   lambda s: s.ewm(com=2.0, adjust=True, ignore_na=True).mean(),
                   ]:
@@ -888,10 +899,7 @@ class TestMoments(Base):
             assert_series_equal(result, expected)
 
         expected = Series([1.0, 1.333333, 2.222222, 4.148148])
-        for f in [lambda s: mom.ewma(s, com=2.0, adjust=False),
-                  lambda s: mom.ewma(s, com=2.0, adjust=False, ignore_na=False),
-                  lambda s: mom.ewma(s, com=2.0, adjust=False, ignore_na=True),
-                  lambda s: s.ewm(com=2.0, adjust=False).mean(),
+        for f in [lambda s: s.ewm(com=2.0, adjust=False).mean(),
                   lambda s: s.ewm(com=2.0, adjust=False, ignore_na=False).mean(),
                   lambda s: s.ewm(com=2.0, adjust=False, ignore_na=True).mean(),
                  ]:
@@ -900,11 +908,11 @@ class TestMoments(Base):
 
     def test_ewma_nan_handling(self):
         s = Series([1.] + [np.nan] * 5 + [1.])
-        result = mom.ewma(s, com=5)
+        result = s.ewm(com=5).mean()
         assert_almost_equal(result, [1.] * len(s))
 
         s = Series([np.nan] * 2 + [1.] + [np.nan] * 2 + [1.])
-        result = mom.ewma(s, com=5)
+        result = s.ewm(com=5).mean()
         assert_almost_equal(result, [np.nan] * 2 + [1.] * 4)
 
         # GH 7603
@@ -937,14 +945,11 @@ class TestMoments(Base):
                 (s3, False, True, [(1. - alpha)**2, np.nan, (1. - alpha) * alpha, alpha]),
                 ]:
             expected = simple_wma(s, Series(w))
-            result = mom.ewma(s, com=com, adjust=adjust, ignore_na=ignore_na)
-            assert_series_equal(result, expected)
             result = s.ewm(com=com, adjust=adjust, ignore_na=ignore_na).mean()
+
             assert_series_equal(result, expected)
             if ignore_na is False:
                 # check that ignore_na defaults to False
-                result = mom.ewma(s, com=com, adjust=adjust)
-                assert_series_equal(result, expected)
                 result = s.ewm(com=com, adjust=adjust).mean()
                 assert_series_equal(result, expected)
 
@@ -955,33 +960,30 @@ class TestMoments(Base):
         self._check_ew(mom.ewmvol, name='vol')
 
     def test_ewma_span_com_args(self):
-        A = mom.ewma(self.arr, com=9.5)
-        B = mom.ewma(self.arr, span=20)
-        assert_almost_equal(A, B)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            A = mom.ewma(self.arr, com=9.5)
+            B = mom.ewma(self.arr, span=20)
+            assert_almost_equal(A, B)
 
-        self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, span=20)
-        self.assertRaises(Exception, mom.ewma, self.arr)
+            self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, span=20)
+            self.assertRaises(Exception, mom.ewma, self.arr)
 
     def test_ewma_halflife_arg(self):
-        A = mom.ewma(self.arr, com=13.932726172912965)
-        B = mom.ewma(self.arr, halflife=10.0)
-        assert_almost_equal(A, B)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            A = mom.ewma(self.arr, com=13.932726172912965)
+            B = mom.ewma(self.arr, halflife=10.0)
+            assert_almost_equal(A, B)
 
-        self.assertRaises(Exception, mom.ewma, self.arr, span=20, halflife=50)
-        self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, halflife=50)
-        self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, span=20, halflife=50)
-        self.assertRaises(Exception, mom.ewma, self.arr)
+            self.assertRaises(Exception, mom.ewma, self.arr, span=20, halflife=50)
+            self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, halflife=50)
+            self.assertRaises(Exception, mom.ewma, self.arr, com=9.5, span=20, halflife=50)
+            self.assertRaises(Exception, mom.ewma, self.arr)
 
     def test_moment_preserve_series_name(self):
         # GH 10565
         s = Series(np.arange(100), name='foo')
 
-        s2 = mom.rolling_mean(s, 30)
-        s3 = mom.rolling_sum(s, 20)
-        self.assertEqual(s2.name, 'foo')
-        self.assertEqual(s3.name, 'foo')
-
-        s2 = s.rolling(30).mean()
+        s2 = s.rolling(30).sum()
         s3 = s.rolling(20).sum()
         self.assertEqual(s2.name, 'foo')
         self.assertEqual(s3.name, 'foo')
@@ -991,11 +993,13 @@ class TestMoments(Base):
 
         funcs = [mom.ewma, mom.ewmvol, mom.ewmvar]
         for f in funcs:
-            result = f(arr, 3)
+            with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+                result = f(arr, 3)
             assert_almost_equal(result, arr)
 
     def _check_ew(self, func, name=None):
-        self._check_ew_ndarray(func, name=name)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self._check_ew_ndarray(func, name=name)
         self._check_ew_structures(func, name=name)
 
     def _check_ew_ndarray(self, func, preserve_nan=False, name=None):
@@ -1041,18 +1045,12 @@ class TestMoments(Base):
         result2 = func(np.arange(50), span=10)
         self.assertEqual(result2.dtype, np.float_)
 
-    def _check_ew_structures(self, func, name=None):
-        series_result = func(self.series, com=10)
+    def _check_ew_structures(self, func, name):
+        series_result = getattr(self.series.ewm(com=10),name)()
         tm.assertIsInstance(series_result, Series)
-        if name is not None:
-            series_result = getattr(self.series.ewm(com=10),name)()
-            tm.assertIsInstance(series_result, Series)
 
-        frame_result = func(self.frame, com=10)
+        frame_result = getattr(self.frame.ewm(com=10),name)()
         self.assertEqual(type(frame_result), DataFrame)
-        if name is not None:
-            frame_result = getattr(self.frame.ewm(com=10),name)()
-            self.assertEqual(type(frame_result), DataFrame)
 
 # create the data only once as we are not setting it
 def _create_consistency_data():
@@ -1305,7 +1303,7 @@ class TestMomentsConsistency(Base):
         def _ewma(s, com, min_periods, adjust, ignore_na):
             weights = _weights(s, com=com, adjust=adjust, ignore_na=ignore_na)
             result = s.multiply(weights).cumsum().divide(weights.cumsum()).fillna(method='ffill')
-            result[mom.expanding_count(s) < (max(min_periods, 1) if min_periods else 1)] = np.nan
+            result[s.expanding().count() < (max(min_periods, 1) if min_periods else 1)] = np.nan
             return result
 
         com = 3.
@@ -1315,16 +1313,16 @@ class TestMomentsConsistency(Base):
                     # test consistency between different ewm* moments
                     self._test_moments_consistency(
                         min_periods=min_periods,
-                        count=mom.expanding_count,
-                        mean=lambda x: mom.ewma(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na),
+                        count=lambda x: x.expanding().count(),
+                        mean=lambda x: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).mean(),
                         mock_mean=lambda x: _ewma(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na),
-                        corr=lambda x, y: mom.ewmcorr(x, y, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na),
-                        var_unbiased=lambda x: mom.ewmvar(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=False),
-                        std_unbiased=lambda x: mom.ewmstd(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=False),
-                        cov_unbiased=lambda x, y: mom.ewmcov(x, y, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=False),
-                        var_biased=lambda x: mom.ewmvar(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=True),
-                        std_biased=lambda x: mom.ewmstd(x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=True),
-                        cov_biased=lambda x, y: mom.ewmcov(x, y, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na, bias=True),
+                        corr=lambda x, y: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).corr(y),
+                        var_unbiased=lambda x: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).var(bias=False),
+                        std_unbiased=lambda x: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).std(bias=False),
+                        cov_unbiased=lambda x, y: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).cov(y, bias=False),
+                        var_biased=lambda x: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).var(bias=True),
+                        std_biased=lambda x: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).std(bias=True),
+                        cov_biased=lambda x, y: x.ewm(com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na).cov(y, bias=True),
                         var_debiasing_factors=lambda x: _variance_debiasing_factors(x, com=com, adjust=adjust, ignore_na=ignore_na))
 
     @slow
@@ -1339,17 +1337,17 @@ class TestMomentsConsistency(Base):
                 # test consistency between different expanding_* moments
                 self._test_moments_consistency(
                     min_periods=min_periods,
-                    count=mom.expanding_count,
-                    mean=lambda x: mom.expanding_mean(x, min_periods=min_periods),
-                    mock_mean=lambda x: mom.expanding_sum(x, min_periods=min_periods) / mom.expanding_count(x),
-                    corr=lambda x, y: mom.expanding_corr(x, y, min_periods=min_periods),
-                    var_unbiased=lambda x: mom.expanding_var(x, min_periods=min_periods),
-                    std_unbiased=lambda x: mom.expanding_std(x, min_periods=min_periods),
-                    cov_unbiased=lambda x, y: mom.expanding_cov(x, y, min_periods=min_periods),
-                    var_biased=lambda x: mom.expanding_var(x, min_periods=min_periods, ddof=0),
-                    std_biased=lambda x: mom.expanding_std(x, min_periods=min_periods, ddof=0),
-                    cov_biased=lambda x, y: mom.expanding_cov(x, y, min_periods=min_periods, ddof=0),
-                    var_debiasing_factors=lambda x: mom.expanding_count(x) / (mom.expanding_count(x) - 1.).replace(0., np.nan)
+                    count=lambda x: x.expanding().count(),
+                    mean=lambda x: x.expanding(min_periods=min_periods).mean(),
+                    mock_mean=lambda x: x.expanding(min_periods=min_periods).sum() / x.expanding().count(),
+                    corr=lambda x, y: x.expanding(min_periods=min_periods).corr(y),
+                    var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
+                    std_unbiased=lambda x: x.expanding(min_periods=min_periods).std(),
+                    cov_unbiased=lambda x, y: x.expanding(min_periods=min_periods).cov(y),
+                    var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
+                    std_biased=lambda x: x.expanding(min_periods=min_periods).std(ddof=0),
+                    cov_biased=lambda x, y: x.expanding(min_periods=min_periods).cov(y, ddof=0),
+                    var_debiasing_factors=lambda x: x.expanding().count() / (x.expanding().count() - 1.).replace(0., np.nan)
                     )
 
                 # test consistency between expanding_xyz() and either (a) expanding_apply of Series.xyz(),
@@ -1362,122 +1360,119 @@ class TestMomentsConsistency(Base):
                     if no_nans:
                         functions = self.base_functions + self.no_nan_functions
                     for (f, require_min_periods, name) in functions:
-                        expanding_f = getattr(mom,'expanding_{0}'.format(name))
+                        expanding_f = getattr(x.expanding(min_periods=min_periods),name)
 
                         if require_min_periods and (min_periods is not None) and (min_periods < require_min_periods):
                             continue
 
-                        if expanding_f is mom.expanding_count:
-                            expanding_f_result = expanding_f(x)
-                            expanding_apply_f_result = mom.expanding_apply(x, func=f, min_periods=0)
+                        if name == 'count':
+                            expanding_f_result = expanding_f()
+                            expanding_apply_f_result = x.expanding(min_periods=0).apply(func=f)
                         else:
-                            if expanding_f in [mom.expanding_cov, mom.expanding_corr]:
-                                expanding_f_result = expanding_f(x, min_periods=min_periods, pairwise=False)
+                            if name in ['cov','corr']:
+                                expanding_f_result = expanding_f(pairwise=False)
                             else:
-                                expanding_f_result = expanding_f(x, min_periods=min_periods)
-                            expanding_apply_f_result = mom.expanding_apply(x, func=f, min_periods=min_periods)
+                                expanding_f_result = expanding_f()
+                            expanding_apply_f_result = x.expanding(min_periods=min_periods).apply(func=f)
 
                         if not tm._incompat_bottleneck_version(name):
                             assert_equal(expanding_f_result, expanding_apply_f_result)
 
-                        if (expanding_f in [mom.expanding_cov, mom.expanding_corr]) and isinstance(x, DataFrame):
+                        if (name in ['cov','corr']) and isinstance(x, DataFrame):
                             # test pairwise=True
-                            expanding_f_result = expanding_f(x, x, min_periods=min_periods, pairwise=True)
+                            expanding_f_result = expanding_f(x, pairwise=True)
                             expected = Panel(items=x.index, major_axis=x.columns, minor_axis=x.columns)
                             for i, _ in enumerate(x.columns):
                                 for j, _ in enumerate(x.columns):
-                                    expected.iloc[:, i, j] = expanding_f(x.iloc[:, i], x.iloc[:, j], min_periods=min_periods)
+                                    expected.iloc[:, i, j] = getattr(x.iloc[:, i].expanding(min_periods=min_periods),name)(x.iloc[:, j])
                             assert_panel_equal(expanding_f_result, expected)
 
     @slow
     def test_rolling_consistency(self):
 
-        for window in [1, 2, 3, 10, 20]:
-            for min_periods in set([0, 1, 2, 3, 4, window]):
-                if min_periods and (min_periods > window):
-                    continue
-                for center in [False, True]:
+        # suppress warnings about empty slices, as we are deliberately testing with empty/0-length Series/DataFrames
+        with warnings.catch_warnings():
+            warnings.filterwarnings("ignore", message=".*(empty slice|0 for slice).*", category=RuntimeWarning)
 
-                    # test consistency between different rolling_* moments
-                    self._test_moments_consistency(
-                        min_periods=min_periods,
-                        count=lambda x: mom.rolling_count(x, window=window, center=center),
-                        mean=lambda x: mom.rolling_mean(x, window=window, min_periods=min_periods, center=center),
-                        mock_mean=lambda x: mom.rolling_sum(x, window=window, min_periods=min_periods, center=center).divide(
-                                            mom.rolling_count(x, window=window, center=center)),
-                        corr=lambda x, y: mom.rolling_corr(x, y, window=window, min_periods=min_periods, center=center),
-                        var_unbiased=lambda x: mom.rolling_var(x, window=window, min_periods=min_periods, center=center),
-                        std_unbiased=lambda x: mom.rolling_std(x, window=window, min_periods=min_periods, center=center),
-                        cov_unbiased=lambda x, y: mom.rolling_cov(x, y, window=window, min_periods=min_periods, center=center),
-                        var_biased=lambda x: mom.rolling_var(x, window=window, min_periods=min_periods, center=center, ddof=0),
-                        std_biased=lambda x: mom.rolling_std(x, window=window, min_periods=min_periods, center=center, ddof=0),
-                        cov_biased=lambda x, y: mom.rolling_cov(x, y, window=window, min_periods=min_periods, center=center, ddof=0),
-                        var_debiasing_factors=lambda x: mom.rolling_count(x, window=window, center=center).divide(
-                                                        (mom.rolling_count(x, window=window, center=center) - 1.).replace(0., np.nan)),
-                        )
-
-                    # test consistency between rolling_xyz() and either (a) rolling_apply of Series.xyz(),
-                    #                                                or (b) rolling_apply of np.nanxyz()
-                    for (x, is_constant, no_nans) in self.data:
-
-                        assert_equal = assert_series_equal if isinstance(x, Series) else assert_frame_equal
-                        functions = self.base_functions
-
-                        # GH 8269
-                        if no_nans:
-                            functions = self.base_functions + self.no_nan_functions
-                        for (f, require_min_periods, name) in functions:
-                            rolling_f = getattr(mom,'rolling_{0}'.format(name))
-
-                            if require_min_periods and (min_periods is not None) and (min_periods < require_min_periods):
-                                continue
-
-                            if rolling_f is mom.rolling_count:
-                                rolling_f_result = rolling_f(x, window=window, center=center)
-                                rolling_apply_f_result = mom.rolling_apply(x, window=window, func=f,
-                                                                           min_periods=0, center=center)
-                            else:
-                                if rolling_f in [mom.rolling_cov, mom.rolling_corr]:
-                                    rolling_f_result = rolling_f(x, window=window, min_periods=min_periods, center=center, pairwise=False)
+            for window in [1, 2, 3, 10, 20]:
+                for min_periods in set([0, 1, 2, 3, 4, window]):
+                    if min_periods and (min_periods > window):
+                        continue
+                    for center in [False, True]:
+
+                        # test consistency between different rolling_* moments
+                        self._test_moments_consistency(
+                            min_periods=min_periods,
+                            count=lambda x: x.rolling(window=window, center=center).count(),
+                            mean=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).mean(),
+                            mock_mean=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).sum().divide(
+                                x.rolling(window=window, min_periods=min_periods, center=center).count()),
+                            corr=lambda x, y: x.rolling(window=window, min_periods=min_periods, center=center).corr(y),
+                            var_unbiased=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).var(),
+                            std_unbiased=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).std(),
+                                                        cov_unbiased=lambda x, y: x.rolling(window=window, min_periods=min_periods, center=center).cov(y),
+                            var_biased=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).var(ddof=0),
+                            std_biased=lambda x: x.rolling(window=window, min_periods=min_periods, center=center).std(ddof=0),
+                            cov_biased=lambda x, y: x.rolling(window=window, min_periods=min_periods, center=center).cov(y, ddof=0),
+                            var_debiasing_factors=lambda x: x.rolling(window=window, center=center).count().divide(
+                                (x.rolling(window=window, center=center).count() - 1.).replace(0., np.nan)),
+                            )
+
+                        # test consistency between rolling_xyz() and either (a) rolling_apply of Series.xyz(),
+                        #                                                or (b) rolling_apply of np.nanxyz()
+                        for (x, is_constant, no_nans) in self.data:
+
+                            assert_equal = assert_series_equal if isinstance(x, Series) else assert_frame_equal
+                            functions = self.base_functions
+
+                            # GH 8269
+                            if no_nans:
+                                functions = self.base_functions + self.no_nan_functions
+                            for (f, require_min_periods, name) in functions:
+                                rolling_f = getattr(x.rolling(window=window, center=center, min_periods=min_periods),name)
+
+                                if require_min_periods and (min_periods is not None) and (min_periods < require_min_periods):
+                                    continue
+
+                                if name == 'count':
+                                    rolling_f_result = rolling_f()
+                                    rolling_apply_f_result = x.rolling(window=window,
+                                                                       min_periods=0, center=center).apply(func=f)
                                 else:
-                                    rolling_f_result = rolling_f(x, window=window, min_periods=min_periods, center=center)
-                                rolling_apply_f_result = mom.rolling_apply(x, window=window, func=f,
-                                                                           min_periods=min_periods, center=center)
-                            if not tm._incompat_bottleneck_version(name):
-                                assert_equal(rolling_f_result, rolling_apply_f_result)
-
-                            if (rolling_f in [mom.rolling_cov, mom.rolling_corr]) and isinstance(x, DataFrame):
-                                # test pairwise=True
-                                rolling_f_result = rolling_f(x, x, window=window, min_periods=min_periods,
-                                                             center=center, pairwise=True)
-                                expected = Panel(items=x.index, major_axis=x.columns, minor_axis=x.columns)
-                                for i, _ in enumerate(x.columns):
-                                    for j, _ in enumerate(x.columns):
-                                        expected.iloc[:, i, j] = rolling_f(x.iloc[:, i], x.iloc[:, j],
-                                                                           window=window, min_periods=min_periods, center=center)
-                                assert_panel_equal(rolling_f_result, expected)
+                                    if name in ['cov','corr']:
+                                        rolling_f_result = rolling_f(pairwise=False)
+                                    else:
+                                        rolling_f_result = rolling_f()
+                                    rolling_apply_f_result = x.rolling(window=window,
+                                                                       min_periods=min_periods, center=center).apply(func=f)
+                                if not tm._incompat_bottleneck_version(name):
+                                    assert_equal(rolling_f_result, rolling_apply_f_result)
+
+                                if (name in ['cov','corr']) and isinstance(x, DataFrame):
+                                    # test pairwise=True
+                                    rolling_f_result = rolling_f(x, pairwise=True)
+                                    expected = Panel(items=x.index, major_axis=x.columns, minor_axis=x.columns)
+                                    for i, _ in enumerate(x.columns):
+                                        for j, _ in enumerate(x.columns):
+                                            expected.iloc[:, i, j] = getattr(x.iloc[:, i].rolling(
+                                                window=window, min_periods=min_periods, center=center),name)(x.iloc[:, j])
+                                    assert_panel_equal(rolling_f_result, expected)
 
     # binary moments
     def test_rolling_cov(self):
         A = self.series
         B = A + randn(len(A))
 
-        result = mom.rolling_cov(A, B, 50, min_periods=25)
-        assert_almost_equal(result[-1], np.cov(A[-50:], B[-50:])[0, 1])
-
         result = A.rolling(window=50, min_periods=25).cov(B)
         assert_almost_equal(result[-1], np.cov(A[-50:], B[-50:])[0, 1])
 
     def test_rolling_cov_pairwise(self):
-        self._check_pairwise_moment(mom.rolling_cov, window=10, min_periods=5, name='cov')
+        self._check_pairwise_moment('rolling','cov', window=10, min_periods=5)
 
     def test_rolling_corr(self):
         A = self.series
         B = A + randn(len(A))
 
-        result = mom.rolling_corr(A, B, 50, min_periods=25)
-        assert_almost_equal(result[-1], np.corrcoef(A[-50:], B[-50:])[0, 1])
-
         result = A.rolling(window=50, min_periods=25).corr(B)
         assert_almost_equal(result[-1], np.corrcoef(A[-50:], B[-50:])[0, 1])
 
@@ -1487,18 +1482,16 @@ class TestMomentsConsistency(Base):
         a[:5] = np.nan
         b[:10] = np.nan
 
-        result = mom.rolling_corr(a, b, len(a), min_periods=1)
-        assert_almost_equal(result[-1], a.corr(b))
-
         result = a.rolling(window=len(a), min_periods=1).corr(b)
         assert_almost_equal(result[-1], a.corr(b))
 
     def test_rolling_corr_pairwise(self):
-        self._check_pairwise_moment(mom.rolling_corr, window=10, min_periods=5, name='corr')
+        self._check_pairwise_moment('rolling', 'corr', window=10, min_periods=5)
+
+    def _check_pairwise_moment(self, dispatch, name, **kwargs):
 
-    def _check_pairwise_moment(self, func, name=None, **kwargs):
         def get_result(obj, obj2=None):
-            return func(obj, obj2, **kwargs)
+            return getattr(getattr(obj,dispatch)(**kwargs),name)(obj2)
 
         panel = get_result(self.frame)
         actual = panel.ix[:, 1, 5]
@@ -1506,12 +1499,6 @@ class TestMomentsConsistency(Base):
         tm.assert_series_equal(actual, expected, check_names=False)
         self.assertEqual(actual.name, 5)
 
-        if name is not None:
-            panel = getattr(self.frame.rolling(**kwargs),name)()
-            actual = panel.ix[:, 1, 5]
-            tm.assert_series_equal(actual, expected, check_names=False)
-            self.assertEqual(actual.name, 5)
-
     def test_flex_binary_moment(self):
         # GH3155
         # don't blow the stack
@@ -1529,13 +1516,13 @@ class TestMomentsConsistency(Base):
                       [ 0.78369152,  0.63919667]])
             )
 
-        res = mom.rolling_corr(df[0],df[1],5,center=True)
+        res = df[0].rolling(5,center=True).corr(df[1])
         self.assertTrue(all([np.abs(np.nan_to_num(x)) <=1 for x in res]))
 
         # and some fuzzing
         for i in range(10):
             df = DataFrame(np.random.rand(30,2))
-            res = mom.rolling_corr(df[0],df[1],5,center=True)
+            res = df[0].rolling(5,center=True).corr(df[1])
             try:
                 self.assertTrue(all([np.abs(np.nan_to_num(x)) <=1 for x in res]))
             except:
@@ -1546,9 +1533,9 @@ class TestMomentsConsistency(Base):
         def _check(method):
             series = self.frame[1]
 
-            res = method(series, self.frame, 10)
-            res2 = method(self.frame, series, 10)
-            exp = self.frame.apply(lambda x: method(series, x, 10))
+            res = getattr(series.rolling(window=10),method)(self.frame)
+            res2 = getattr(self.frame.rolling(window=10),method)(series)
+            exp = self.frame.apply(lambda x: getattr(series.rolling(window=10),method)(x))
 
             tm.assert_frame_equal(res, exp)
             tm.assert_frame_equal(res2, exp)
@@ -1556,28 +1543,32 @@ class TestMomentsConsistency(Base):
             frame2 = self.frame.copy()
             frame2.values[:] = np.random.randn(*frame2.shape)
 
-            res3 = method(self.frame, frame2, 10)
-            exp = DataFrame(dict((k, method(self.frame[k], frame2[k], 10))
+            res3 = getattr(self.frame.rolling(window=10),method)(frame2)
+            exp = DataFrame(dict((k, getattr(self.frame[k].rolling(window=10),method)(frame2[k]))
                                  for k in self.frame))
             tm.assert_frame_equal(res3, exp)
 
-        methods = [mom.rolling_corr, mom.rolling_cov]
+        methods = ['corr','cov']
         for meth in methods:
             _check(meth)
 
     def test_ewmcov(self):
-        self._check_binary_ew(mom.ewmcov)
+        self._check_binary_ew('cov')
 
     def test_ewmcov_pairwise(self):
-        self._check_pairwise_moment(mom.ewmcov, span=10, min_periods=5)
+        self._check_pairwise_moment('ewm','cov', span=10, min_periods=5)
 
     def test_ewmcorr(self):
-        self._check_binary_ew(mom.ewmcorr)
+        self._check_binary_ew('corr')
 
     def test_ewmcorr_pairwise(self):
-        self._check_pairwise_moment(mom.ewmcorr, span=10, min_periods=5)
+        self._check_pairwise_moment('ewm','corr', span=10, min_periods=5)
+
+    def _check_binary_ew(self, name):
+
+        def func(A, B, com, **kwargs):
+            return getattr(A.ewm(com, **kwargs),name)(B)
 
-    def _check_binary_ew(self, func):
         A = Series(randn(50), index=np.arange(50))
         B = A[2:] + randn(48)
 
@@ -1607,7 +1598,7 @@ class TestMomentsConsistency(Base):
 
     def test_expanding_apply(self):
         ser = Series([])
-        assert_series_equal(ser, mom.expanding_apply(ser, lambda x: x.mean()))
+        assert_series_equal(ser, ser.expanding().apply(lambda x: x.mean()))
 
         def expanding_mean(x, min_periods=1, freq=None):
             return mom.expanding_apply(x,
@@ -1618,7 +1609,7 @@ class TestMomentsConsistency(Base):
 
         # GH 8080
         s = Series([None, None, None])
-        result = mom.expanding_apply(s, lambda x: len(x), min_periods=0)
+        result = s.expanding(min_periods=0).apply(lambda x: len(x))
         expected = Series([1., 2., 3.])
         assert_series_equal(result, expected)
 
@@ -1628,39 +1619,34 @@ class TestMomentsConsistency(Base):
 
         df = DataFrame(np.random.rand(20, 3))
 
-        expected = mom.expanding_apply(df, np.mean) + 20.
+        expected = df.expanding().apply(np.mean) + 20.
 
-        assert_frame_equal(mom.expanding_apply(df, mean_w_arg, args=(20,)),
-                            expected)
-        assert_frame_equal(mom.expanding_apply(df, mean_w_arg,
-                                               kwargs={'const' : 20}),
+        assert_frame_equal(df.expanding().apply(mean_w_arg, args=(20,)),
                             expected)
+        assert_frame_equal(df.expanding().apply(mean_w_arg,
+                                                kwargs={'const' : 20}),
+                           expected)
 
 
     def test_expanding_corr(self):
         A = self.series.dropna()
         B = (A + randn(len(A)))[:-5]
 
-        result = mom.expanding_corr(A, B)
+        result = A.expanding().corr(B)
 
-        rolling_result = mom.rolling_corr(A, B, len(A), min_periods=1)
+        rolling_result = A.rolling(window=len(A),min_periods=1).corr(B)
 
         assert_almost_equal(rolling_result, result)
 
     def test_expanding_count(self):
-        result = mom.expanding_count(self.series)
-        assert_almost_equal(result, mom.rolling_count(self.series,
-                                                      len(self.series)))
         result = self.series.expanding().count()
-        assert_almost_equal(result, mom.rolling_count(self.series,
-                                                      len(self.series)))
+        assert_almost_equal(result, self.series.rolling(window=len(self.series)).count())
 
     def test_expanding_quantile(self):
-        result = mom.expanding_quantile(self.series, 0.5)
+        result = self.series.expanding().quantile(0.5)
 
-        rolling_result = mom.rolling_quantile(self.series,
-                                              len(self.series),
-                                              0.5, min_periods=1)
+        rolling_result = self.series.rolling(
+            window=len(self.series),min_periods=1).quantile(0.5)
 
         assert_almost_equal(result, rolling_result)
 
@@ -1668,9 +1654,9 @@ class TestMomentsConsistency(Base):
         A = self.series
         B = (A + randn(len(A)))[:-5]
 
-        result = mom.expanding_cov(A, B)
+        result = A.expanding().cov(B)
 
-        rolling_result = mom.rolling_cov(A, B, len(A), min_periods=1)
+        rolling_result = A.rolling(window=len(A), min_periods=1).cov(B)
 
         assert_almost_equal(rolling_result, result)
 
@@ -1678,19 +1664,17 @@ class TestMomentsConsistency(Base):
         self._check_expanding(mom.expanding_max, np.max, preserve_nan=False)
 
     def test_expanding_cov_pairwise(self):
-        result = mom.expanding_cov(self.frame)
+        result = self.frame.expanding().corr()
 
-        rolling_result = mom.rolling_cov(self.frame, len(self.frame),
-                                         min_periods=1)
+        rolling_result = self.frame.rolling(window=len(self.frame),min_periods=1).corr()
 
         for i in result.items:
             assert_almost_equal(result[i], rolling_result[i])
 
     def test_expanding_corr_pairwise(self):
-        result = mom.expanding_corr(self.frame)
+        result = self.frame.expanding().corr()
 
-        rolling_result = mom.rolling_corr(self.frame, len(self.frame),
-                                          min_periods=1)
+        rolling_result = self.frame.rolling(window=len(self.frame), min_periods=1).corr()
 
         for i in result.items:
             assert_almost_equal(result[i], rolling_result[i])
@@ -1699,17 +1683,17 @@ class TestMomentsConsistency(Base):
         # GH 7512
         s1 = Series([1, 2, 3], index=[0, 1, 2])
         s2 = Series([1, 3], index=[0, 2])
-        result = mom.expanding_cov(s1, s2)
+        result = s1.expanding().cov(s2)
         expected = Series([None, None, 2.0])
         assert_series_equal(result, expected)
 
         s2a = Series([1, None, 3], index=[0, 1, 2])
-        result = mom.expanding_cov(s1, s2a)
+        result = s1.expanding().cov(s2a)
         assert_series_equal(result, expected)
 
         s1 = Series([7, 8, 10], index=[0, 1, 3])
         s2 = Series([7, 9, 10], index=[0, 2, 3])
-        result = mom.expanding_cov(s1, s2)
+        result = s1.expanding().cov(s2)
         expected = Series([None, None, None, 4.5])
         assert_series_equal(result, expected)
 
@@ -1717,17 +1701,17 @@ class TestMomentsConsistency(Base):
         # GH 7512
         s1 = Series([1, 2, 3], index=[0, 1, 2])
         s2 = Series([1, 3], index=[0, 2])
-        result = mom.expanding_corr(s1, s2)
+        result = s1.expanding().corr(s2)
         expected = Series([None, None, 1.0])
         assert_series_equal(result, expected)
 
         s2a = Series([1, None, 3], index=[0, 1, 2])
-        result = mom.expanding_corr(s1, s2a)
+        result = s1.expanding().corr(s2a)
         assert_series_equal(result, expected)
 
         s1 = Series([7, 8, 10], index=[0, 1, 3])
         s2 = Series([7, 9, 10], index=[0, 2, 3])
-        result = mom.expanding_corr(s1, s2)
+        result = s1.expanding().corr(s2)
         expected = Series([None, None, None, 1.])
         assert_series_equal(result, expected)
 
@@ -1735,24 +1719,24 @@ class TestMomentsConsistency(Base):
         # GH 7512
         s1 = Series([1, 2, 3], index=[0, 1, 2])
         s2 = Series([1, 3], index=[0, 2])
-        result = mom.rolling_cov(s1, s2, window=3, min_periods=2)
+        result = s1.rolling(window=3, min_periods=2).cov(s2)
         expected = Series([None, None, 2.0])
         assert_series_equal(result, expected)
 
         s2a = Series([1, None, 3], index=[0, 1, 2])
-        result = mom.rolling_cov(s1, s2a, window=3, min_periods=2)
+        result = s1.rolling(window=3, min_periods=2).cov(s2a)
         assert_series_equal(result, expected)
 
     def test_rolling_corr_diff_length(self):
         # GH 7512
         s1 = Series([1, 2, 3], index=[0, 1, 2])
         s2 = Series([1, 3], index=[0, 2])
-        result = mom.rolling_corr(s1, s2, window=3, min_periods=2)
+        result = s1.rolling(window=3, min_periods=2).corr(s2)
         expected = Series([None, None, 1.0])
         assert_series_equal(result, expected)
 
         s2a = Series([1, None, 3], index=[0, 1, 2])
-        result = mom.rolling_corr(s1, s2a, window=3, min_periods=2)
+        result = s1.rolling(window=3, min_periods=2).corr(s2a)
         assert_series_equal(result, expected)
 
     def test_rolling_functions_window_non_shrinkage(self):
@@ -1763,20 +1747,20 @@ class TestMomentsConsistency(Base):
         df_expected = DataFrame(np.nan, index=df.index, columns=df.columns)
         df_expected_panel = Panel(items=df.index, major_axis=df.columns, minor_axis=df.columns)
 
-        functions = [lambda x: mom.rolling_cov(x, x, pairwise=False, window=10, min_periods=5),
-                     lambda x: mom.rolling_corr(x, x, pairwise=False, window=10, min_periods=5),
-                     lambda x: mom.rolling_max(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_min(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_sum(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_mean(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_std(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_var(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_skew(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_kurt(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_quantile(x, quantile=0.5, window=10, min_periods=5),
-                     lambda x: mom.rolling_median(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_apply(x, func=sum, window=10, min_periods=5),
-                     lambda x: mom.rolling_window(x, win_type='boxcar', window=10, min_periods=5),
+        functions = [lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=False),
+                     lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=False),
+                     lambda x: x.rolling(window=10, min_periods=5).max(),
+                     lambda x: x.rolling(window=10, min_periods=5).min(),
+                     lambda x: x.rolling(window=10, min_periods=5).sum(),
+                     lambda x: x.rolling(window=10, min_periods=5).mean(),
+                     lambda x: x.rolling(window=10, min_periods=5).std(),
+                     lambda x: x.rolling(window=10, min_periods=5).var(),
+                     lambda x: x.rolling(window=10, min_periods=5).skew(),
+                     lambda x: x.rolling(window=10, min_periods=5).kurt(),
+                     lambda x: x.rolling(window=10, min_periods=5).quantile(quantile=0.5),
+                     lambda x: x.rolling(window=10, min_periods=5).median(),
+                     lambda x: x.rolling(window=10, min_periods=5).apply(sum),
+                     lambda x: x.rolling(win_type='boxcar', window=10, min_periods=5).mean(),
                     ]
         for f in functions:
             try:
@@ -1790,8 +1774,8 @@ class TestMomentsConsistency(Base):
                 # scipy needed for rolling_window
                 continue
 
-        functions = [lambda x: mom.rolling_cov(x, x, pairwise=True, window=10, min_periods=5),
-                     lambda x: mom.rolling_corr(x, x, pairwise=True, window=10, min_periods=5),
+        functions = [lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=True),
+                     lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=True),
                     ]
         for f in functions:
             df_result_panel = f(df)
@@ -1809,35 +1793,35 @@ class TestMomentsConsistency(Base):
         df2_expected = df2
         df2_expected_panel = Panel(items=df2.index, major_axis=df2.columns, minor_axis=df2.columns)
 
-        functions = [lambda x: mom.expanding_count(x),
-                     lambda x: mom.expanding_cov(x, x, pairwise=False, min_periods=5),
-                     lambda x: mom.expanding_corr(x, x, pairwise=False, min_periods=5),
-                     lambda x: mom.expanding_max(x, min_periods=5),
-                     lambda x: mom.expanding_min(x, min_periods=5),
-                     lambda x: mom.expanding_sum(x, min_periods=5),
-                     lambda x: mom.expanding_mean(x, min_periods=5),
-                     lambda x: mom.expanding_std(x, min_periods=5),
-                     lambda x: mom.expanding_var(x, min_periods=5),
-                     lambda x: mom.expanding_skew(x, min_periods=5),
-                     lambda x: mom.expanding_kurt(x, min_periods=5),
-                     lambda x: mom.expanding_quantile(x, quantile=0.5, min_periods=5),
-                     lambda x: mom.expanding_median(x, min_periods=5),
-                     lambda x: mom.expanding_apply(x, func=sum, min_periods=5),
-                     lambda x: mom.rolling_count(x, window=10),
-                     lambda x: mom.rolling_cov(x, x, pairwise=False, window=10, min_periods=5),
-                     lambda x: mom.rolling_corr(x, x, pairwise=False, window=10, min_periods=5),
-                     lambda x: mom.rolling_max(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_min(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_sum(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_mean(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_std(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_var(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_skew(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_kurt(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_quantile(x, quantile=0.5, window=10, min_periods=5),
-                     lambda x: mom.rolling_median(x, window=10, min_periods=5),
-                     lambda x: mom.rolling_apply(x, func=sum, window=10, min_periods=5),
-                     lambda x: mom.rolling_window(x, win_type='boxcar', window=10, min_periods=5),
+        functions = [lambda x: x.expanding().count(),
+                     lambda x: x.expanding(min_periods=5).cov(x, pairwise=False),
+                     lambda x: x.expanding(min_periods=5).corr(x, pairwise=False),
+                     lambda x: x.expanding(min_periods=5).max(),
+                     lambda x: x.expanding(min_periods=5).min(),
+                     lambda x: x.expanding(min_periods=5).sum(),
+                     lambda x: x.expanding(min_periods=5).mean(),
+                     lambda x: x.expanding(min_periods=5).std(),
+                     lambda x: x.expanding(min_periods=5).var(),
+                     lambda x: x.expanding(min_periods=5).skew(),
+                     lambda x: x.expanding(min_periods=5).kurt(),
+                     lambda x: x.expanding(min_periods=5).quantile(0.5),
+                     lambda x: x.expanding(min_periods=5).median(),
+                     lambda x: x.expanding(min_periods=5).apply(sum),
+                     lambda x: x.rolling(window=10).count(),
+                     lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=False),
+                     lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=False),
+                     lambda x: x.rolling(window=10, min_periods=5).max(),
+                     lambda x: x.rolling(window=10, min_periods=5).min(),
+                     lambda x: x.rolling(window=10, min_periods=5).sum(),
+                     lambda x: x.rolling(window=10, min_periods=5).mean(),
+                     lambda x: x.rolling(window=10, min_periods=5).std(),
+                     lambda x: x.rolling(window=10, min_periods=5).var(),
+                     lambda x: x.rolling(window=10, min_periods=5).skew(),
+                     lambda x: x.rolling(window=10, min_periods=5).kurt(),
+                     lambda x: x.rolling(window=10, min_periods=5).quantile(0.5),
+                     lambda x: x.rolling(window=10, min_periods=5).median(),
+                     lambda x: x.rolling(window=10, min_periods=5).apply(sum),
+                     lambda x: x.rolling(win_type='boxcar', window=10, min_periods=5).mean(),
                     ]
         for f in functions:
             try:
@@ -1854,10 +1838,10 @@ class TestMomentsConsistency(Base):
                 # scipy needed for rolling_window
                 continue
 
-        functions = [lambda x: mom.expanding_cov(x, x, pairwise=True, min_periods=5),
-                     lambda x: mom.expanding_corr(x, x, pairwise=True, min_periods=5),
-                     lambda x: mom.rolling_cov(x, x, pairwise=True, window=10, min_periods=5),
-                     lambda x: mom.rolling_corr(x, x, pairwise=True, window=10, min_periods=5),
+        functions = [lambda x: x.expanding(min_periods=5).cov(x, pairwise=True),
+                     lambda x: x.expanding(min_periods=5).corr(x, pairwise=True),
+                     lambda x: x.rolling(window=10, min_periods=5).cov(x, pairwise=True),
+                     lambda x: x.rolling(window=10, min_periods=5).corr(x, pairwise=True),
                     ]
         for f in functions:
             df1_result_panel = f(df1)
@@ -1872,10 +1856,10 @@ class TestMomentsConsistency(Base):
         df1a = DataFrame([[1,5], [3,9]], index=[0,2], columns=['A','B'])
         df2 = DataFrame([[5,6], [None,None], [2,1]], columns=['X','Y'])
         df2a = DataFrame([[5,6], [2,1]], index=[0,2], columns=['X','Y'])
-        result1 = mom.expanding_cov(df1, df2, pairwise=True)[2]
-        result2 = mom.expanding_cov(df1, df2a, pairwise=True)[2]
-        result3 = mom.expanding_cov(df1a, df2, pairwise=True)[2]
-        result4 = mom.expanding_cov(df1a, df2a, pairwise=True)[2]
+        result1 = df1.expanding().cov(df2a, pairwise=True)[2]
+        result2 = df1.expanding().cov(df2a, pairwise=True)[2]
+        result3 = df1a.expanding().cov(df2, pairwise=True)[2]
+        result4 = df1a.expanding().cov(df2a, pairwise=True)[2]
         expected = DataFrame([[-3., -5.], [-6., -10.]], index=['A','B'], columns=['X','Y'])
         assert_frame_equal(result1, expected)
         assert_frame_equal(result2, expected)
@@ -1888,10 +1872,10 @@ class TestMomentsConsistency(Base):
         df1a = DataFrame([[1,2], [3,4]], index=[0,2], columns=['A','B'])
         df2 = DataFrame([[5,6], [None,None], [2,1]], columns=['X','Y'])
         df2a = DataFrame([[5,6], [2,1]], index=[0,2], columns=['X','Y'])
-        result1 = mom.expanding_corr(df1, df2, pairwise=True)[2]
-        result2 = mom.expanding_corr(df1, df2a, pairwise=True)[2]
-        result3 = mom.expanding_corr(df1a, df2, pairwise=True)[2]
-        result4 = mom.expanding_corr(df1a, df2a, pairwise=True)[2]
+        result1 = df1.expanding().corr(df2, pairwise=True)[2]
+        result2 = df1.expanding().corr(df2a, pairwise=True)[2]
+        result3 = df1a.expanding().corr(df2, pairwise=True)[2]
+        result4 = df1a.expanding().corr(df2a, pairwise=True)[2]
         expected = DataFrame([[-1.0, -1.0], [-1.0, -1.0]], index=['A','B'], columns=['X','Y'])
         assert_frame_equal(result1, expected)
         assert_frame_equal(result2, expected)
@@ -1931,12 +1915,12 @@ class TestMomentsConsistency(Base):
                         self.assert_numpy_array_equal(result, results[0])
 
             # DataFrame with itself, pairwise=True
-            for f in [lambda x: mom.expanding_cov(x, pairwise=True),
-                      lambda x: mom.expanding_corr(x, pairwise=True),
-                      lambda x: mom.rolling_cov(x, window=3, pairwise=True),
-                      lambda x: mom.rolling_corr(x, window=3, pairwise=True),
-                      lambda x: mom.ewmcov(x, com=3, pairwise=True),
-                      lambda x: mom.ewmcorr(x, com=3, pairwise=True),
+            for f in [lambda x: x.expanding().cov(pairwise=True),
+                      lambda x: x.expanding().corr(pairwise=True),
+                      lambda x: x.rolling(window=3).cov(pairwise=True),
+                      lambda x: x.rolling(window=3).corr(pairwise=True),
+                      lambda x: x.ewm(com=3).cov(pairwise=True),
+                      lambda x: x.ewm(com=3).corr(pairwise=True),
                      ]:
                 results = [f(df) for df in df1s]
                 for (df, result) in zip(df1s, results):
@@ -1948,12 +1932,12 @@ class TestMomentsConsistency(Base):
                         self.assert_numpy_array_equal(result, results[0])
 
             # DataFrame with itself, pairwise=False
-            for f in [lambda x: mom.expanding_cov(x, pairwise=False),
-                      lambda x: mom.expanding_corr(x, pairwise=False),
-                      lambda x: mom.rolling_cov(x, window=3, pairwise=False),
-                      lambda x: mom.rolling_corr(x, window=3, pairwise=False),
-                      lambda x: mom.ewmcov(x, com=3, pairwise=False),
-                      lambda x: mom.ewmcorr(x, com=3, pairwise=False),
+            for f in [lambda x: x.expanding().cov(pairwise=False),
+                      lambda x: x.expanding().corr(pairwise=False),
+                      lambda x: x.rolling(window=3).cov(pairwise=False),
+                      lambda x: x.rolling(window=3).corr(pairwise=False),
+                      lambda x: x.ewm(com=3).cov(pairwise=False),
+                      lambda x: x.ewm(com=3).corr(pairwise=False),
                      ]:
                 results = [f(df) for df in df1s]
                 for (df, result) in zip(df1s, results):
@@ -1964,12 +1948,12 @@ class TestMomentsConsistency(Base):
                         self.assert_numpy_array_equal(result, results[0])
 
             # DataFrame with another DataFrame, pairwise=True
-            for f in [lambda x, y: mom.expanding_cov(x, y, pairwise=True),
-                      lambda x, y: mom.expanding_corr(x, y, pairwise=True),
-                      lambda x, y: mom.rolling_cov(x, y, window=3, pairwise=True),
-                      lambda x, y: mom.rolling_corr(x, y, window=3, pairwise=True),
-                      lambda x, y: mom.ewmcov(x, y, com=3, pairwise=True),
-                      lambda x, y: mom.ewmcorr(x, y, com=3, pairwise=True),
+            for f in [lambda x, y: x.expanding().cov(y, pairwise=True),
+                      lambda x, y: x.expanding().corr(y, pairwise=True),
+                      lambda x, y: x.rolling(window=3).cov(y, pairwise=True),
+                      lambda x, y: x.rolling(window=3).corr(y, pairwise=True),
+                      lambda x, y: x.ewm(com=3).cov(y, pairwise=True),
+                      lambda x, y: x.ewm(com=3).corr(y, pairwise=True),
                      ]:
                 results = [f(df, df2) for df in df1s]
                 for (df, result) in zip(df1s, results):
@@ -1981,12 +1965,12 @@ class TestMomentsConsistency(Base):
                         self.assert_numpy_array_equal(result, results[0])
 
             # DataFrame with another DataFrame, pairwise=False
-            for f in [lambda x, y: mom.expanding_cov(x, y, pairwise=False),
-                      lambda x, y: mom.expanding_corr(x, y, pairwise=False),
-                      lambda x, y: mom.rolling_cov(x, y, window=3, pairwise=False),
-                      lambda x, y: mom.rolling_corr(x, y, window=3, pairwise=False),
-                      lambda x, y: mom.ewmcov(x, y, com=3, pairwise=False),
-                      lambda x, y: mom.ewmcorr(x, y, com=3, pairwise=False),
+            for f in [lambda x, y: x.expanding().cov(y, pairwise=False),
+                      lambda x, y: x.expanding().corr(y, pairwise=False),
+                      lambda x, y: x.rolling(window=3).cov(y, pairwise=False),
+                      lambda x, y: x.rolling(window=3).corr(y, pairwise=False),
+                      lambda x, y: x.ewm(com=3).cov(y, pairwise=False),
+                      lambda x, y: x.ewm(com=3).corr(y, pairwise=False),
                      ]:
                 results = [f(df, df2) if df.columns.is_unique else None for df in df1s]
                 for (df, result) in zip(df1s, results):
@@ -2000,12 +1984,12 @@ class TestMomentsConsistency(Base):
                         tm.assertRaisesRegexp(ValueError, "'arg2' columns are not unique", f, df2, df)
 
             # DataFrame with a Series
-            for f in [lambda x, y: mom.expanding_cov(x, y),
-                      lambda x, y: mom.expanding_corr(x, y),
-                      lambda x, y: mom.rolling_cov(x, y, window=3),
-                      lambda x, y: mom.rolling_corr(x, y, window=3),
-                      lambda x, y: mom.ewmcov(x, y, com=3),
-                      lambda x, y: mom.ewmcorr(x, y, com=3),
+            for f in [lambda x, y: x.expanding().cov(y),
+                      lambda x, y: x.expanding().corr(y),
+                      lambda x, y: x.rolling(window=3).cov(y),
+                      lambda x, y: x.rolling(window=3).corr(y),
+                      lambda x, y: x.ewm(com=3).cov(y),
+                      lambda x, y: x.ewm(com=3).corr(y),
                      ]:
                 results = [f(df, s) for df in df1s] + [f(s, df) for df in df1s]
                 for (df, result) in zip(df1s, results):
@@ -2021,12 +2005,12 @@ class TestMomentsConsistency(Base):
 
         # yields all NaN (0 variance)
         d = Series([1] * 5)
-        x = mom.rolling_skew(d, window=5)
+        x = d.rolling(window=5).skew()
         assert_series_equal(all_nan, x)
 
         # yields all NaN (window too small)
         d = Series(np.random.randn(5))
-        x = mom.rolling_skew(d, window=2)
+        x = d.rolling(window=2).skew()
         assert_series_equal(all_nan, x)
 
         # yields [NaN, NaN, NaN, 0.177994, 1.548824]
@@ -2034,7 +2018,7 @@ class TestMomentsConsistency(Base):
                        1.73508164,  0.41941401])
         expected = Series([np.NaN, np.NaN, np.NaN,
                               0.177994, 1.548824])
-        x = mom.rolling_skew(d, window=4)
+        x = d.rolling(window=4).skew()
         assert_series_equal(expected, x)
 
     def test_rolling_kurt_edge_cases(self):
@@ -2043,12 +2027,12 @@ class TestMomentsConsistency(Base):
 
         # yields all NaN (0 variance)
         d = Series([1] * 5)
-        x = mom.rolling_kurt(d, window=5)
+        x = d.rolling(window=5).kurt()
         assert_series_equal(all_nan, x)
 
         # yields all NaN (window too small)
         d = Series(np.random.randn(5))
-        x = mom.rolling_kurt(d, window=3)
+        x = d.rolling(window=3).kurt()
         assert_series_equal(all_nan, x)
 
         # yields [NaN, NaN, NaN, 1.224307, 2.671499]
@@ -2056,7 +2040,7 @@ class TestMomentsConsistency(Base):
                     1.73508164,  0.41941401])
         expected = Series([np.NaN, np.NaN, np.NaN,
                            1.224307, 2.671499])
-        x = mom.rolling_kurt(d, window=4)
+        x = d.rolling(window=4).kurt()
         assert_series_equal(expected, x)
 
     def _check_expanding_ndarray(self, func, static_comp, has_min_periods=True,
@@ -2103,11 +2087,13 @@ class TestMomentsConsistency(Base):
     def _check_expanding(self, func, static_comp, has_min_periods=True,
                          has_time_rule=True,
                          preserve_nan=True):
-        self._check_expanding_ndarray(func, static_comp,
-                                      has_min_periods=has_min_periods,
-                                      has_time_rule=has_time_rule,
-                                      preserve_nan=preserve_nan)
-        self._check_expanding_structures(func)
+        with warnings.catch_warnings(record=True):
+            self._check_expanding_ndarray(func, static_comp,
+                                          has_min_periods=has_min_periods,
+                                          has_time_rule=has_time_rule,
+                                          preserve_nan=preserve_nan)
+        with warnings.catch_warnings(record=True):
+            self._check_expanding_structures(func)
 
     def test_rolling_max_gh6297(self):
         """Replicate result expected in GH #6297"""
@@ -2124,7 +2110,7 @@ class TestMomentsConsistency(Base):
         expected = Series([1.0, 2.0, 6.0, 4.0, 5.0],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_max(series, window=1, freq='D')
+        x = series.rolling(window=1, freq='D').max()
         assert_series_equal(expected, x)
 
     def test_rolling_max_how_resample(self):
@@ -2143,14 +2129,14 @@ class TestMomentsConsistency(Base):
         expected = Series([0.0, 1.0, 2.0, 3.0, 20.0],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_max(series, window=1, freq='D')
+        x = series.rolling(window=1, freq='D').max()
         assert_series_equal(expected, x)
 
         # Now specify median (10.0)
         expected = Series([0.0, 1.0, 2.0, 3.0, 10.0],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_max(series, window=1, freq='D', how='median')
+        x = series.rolling(window=1, freq='D').max(how='median')
         assert_series_equal(expected, x)
 
         # Now specify mean (4+10+20)/3
@@ -2158,7 +2144,7 @@ class TestMomentsConsistency(Base):
         expected = Series([0.0, 1.0, 2.0, 3.0, v],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_max(series, window=1, freq='D', how='mean')
+        x = series.rolling(window=1, freq='D').max(how='mean')
         assert_series_equal(expected, x)
 
 
@@ -2178,7 +2164,7 @@ class TestMomentsConsistency(Base):
         expected = Series([0.0, 1.0, 2.0, 3.0, 4.0],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_min(series, window=1, freq='D')
+        x = series.rolling(window=1, freq='D').min()
         assert_series_equal(expected, x)
 
     def test_rolling_median_how_resample(self):
@@ -2197,7 +2183,7 @@ class TestMomentsConsistency(Base):
         expected = Series([0.0, 1.0, 2.0, 3.0, 10],
                           index=[datetime(1975, 1, i, 0)
                                  for i in range(1, 6)])
-        x = mom.rolling_median(series, window=1, freq='D')
+        x = series.rolling(window=1, freq='D').median()
         assert_series_equal(expected, x)
 
     def test_rolling_median_memory_error(self):

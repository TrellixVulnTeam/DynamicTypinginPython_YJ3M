commit a01644c07f376b4e2eb48d8dfca7222473e3088d
Author: Evan Wright <evanpw@gmail.com>
Date:   Fri Jul 1 10:18:37 2016 -0400

    BUG: Can't store callables using __setitem__ (#13516)
    
    * BUG: Can't store callables using __setitem__
    
    * Use an internal method instead of a new parameter
    
    * Add a docstring, fix pep8 complaints
    
    * Move whatsnew entry to API section

diff --git a/doc/source/whatsnew/v0.18.2.txt b/doc/source/whatsnew/v0.18.2.txt
index 40fec4d07..eae03b2a8 100644
--- a/doc/source/whatsnew/v0.18.2.txt
+++ b/doc/source/whatsnew/v0.18.2.txt
@@ -421,6 +421,7 @@ Other API changes
 - ``TimedeltaIndex.astype(int)`` and ``DatetimeIndex.astype(int)`` will now return ``Int64Index`` instead of ``np.array`` (:issue:`13209`)
 - ``.filter()`` enforces mutual exclusion of the keyword arguments. (:issue:`12399`)
 - ``PeridIndex`` can now accept ``list`` and ``array`` which contains ``pd.NaT`` (:issue:`13430`)
+- ``__setitem__`` will no longer apply a callable rhs as a function instead of storing it. Call ``where`` directly to get the previous behavior. (:issue:`13299`)
 
 .. _whatsnew_0182.deprecations:
 
@@ -482,7 +483,6 @@ Bug Fixes
 - Bug in ``pd.read_hdf()`` where attempting to load an HDF file with a single dataset, that had one or more categorical columns, failed unless the key argument was set to the name of the dataset. (:issue:`13231`)
 - Bug in ``.rolling()`` that allowed a negative integer window in contruction of the ``Rolling()`` object, but would later fail on aggregation (:issue:`13383`)
 
-
 - Bug in various index types, which did not propagate the name of passed index (:issue:`12309`)
 - Bug in ``DatetimeIndex``, which did not honour the ``copy=True`` (:issue:`13205`)
 - Bug in ``DatetimeIndex.is_normalized`` returns incorrectly for normalized date_range in case of local timezones (:issue:`13459`)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index b4b35953b..e804271d8 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2395,7 +2395,7 @@ class DataFrame(NDFrame):
 
         self._check_inplace_setting(value)
         self._check_setitem_copy()
-        self.where(-key, value, inplace=True)
+        self._where(-key, value, inplace=True)
 
     def _ensure_valid_index(self, value):
         """
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 5ce9161fd..6b25cf6ed 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -4424,54 +4424,14 @@ class NDFrame(PandasObject):
             right = right.fillna(fill_value, method=method, limit=limit)
         return left.__finalize__(self), right.__finalize__(other)
 
-    _shared_docs['where'] = ("""
-        Return an object of same shape as self and whose corresponding
-        entries are from self where cond is %(cond)s and otherwise are from
-        other.
-
-        Parameters
-        ----------
-        cond : boolean %(klass)s, array or callable
-            If cond is callable, it is computed on the %(klass)s and
-            should return boolean %(klass)s or array.
-            The callable must not change input %(klass)s
-            (though pandas doesn't check it).
-
-            .. versionadded:: 0.18.1
-
-            A callable can be used as cond.
-
-        other : scalar, %(klass)s, or callable
-            If other is callable, it is computed on the %(klass)s and
-            should return scalar or %(klass)s.
-            The callable must not change input %(klass)s
-            (though pandas doesn't check it).
-
-            .. versionadded:: 0.18.1
-
-            A callable can be used as other.
-
-        inplace : boolean, default False
-            Whether to perform the operation in place on the data
-        axis : alignment axis if needed, default None
-        level : alignment level if needed, default None
-        try_cast : boolean, default False
-            try to cast the result back to the input type (if possible),
-        raise_on_error : boolean, default True
-            Whether to raise on invalid data types (e.g. trying to where on
-            strings)
-
-        Returns
-        -------
-        wh : same type as caller
-        """)
-
-    @Appender(_shared_docs['where'] % dict(_shared_doc_kwargs, cond="True"))
-    def where(self, cond, other=np.nan, inplace=False, axis=None, level=None,
-              try_cast=False, raise_on_error=True):
+    def _where(self, cond, other=np.nan, inplace=False, axis=None, level=None,
+               try_cast=False, raise_on_error=True):
+        """
+        Equivalent to public method `where`, except that `other` is not
+        applied as a function even if callable. Used in __setitem__.
+        """
 
         cond = com._apply_if_callable(cond, self)
-        other = com._apply_if_callable(other, self)
 
         if isinstance(cond, NDFrame):
             cond, _ = cond.align(self, join='right', broadcast_axis=1)
@@ -4627,6 +4587,56 @@ class NDFrame(PandasObject):
 
             return self._constructor(new_data).__finalize__(self)
 
+    _shared_docs['where'] = ("""
+        Return an object of same shape as self and whose corresponding
+        entries are from self where cond is %(cond)s and otherwise are from
+        other.
+
+        Parameters
+        ----------
+        cond : boolean %(klass)s, array or callable
+            If cond is callable, it is computed on the %(klass)s and
+            should return boolean %(klass)s or array.
+            The callable must not change input %(klass)s
+            (though pandas doesn't check it).
+
+            .. versionadded:: 0.18.1
+
+            A callable can be used as cond.
+
+        other : scalar, %(klass)s, or callable
+            If other is callable, it is computed on the %(klass)s and
+            should return scalar or %(klass)s.
+            The callable must not change input %(klass)s
+            (though pandas doesn't check it).
+
+            .. versionadded:: 0.18.1
+
+            A callable can be used as other.
+
+        inplace : boolean, default False
+            Whether to perform the operation in place on the data
+        axis : alignment axis if needed, default None
+        level : alignment level if needed, default None
+        try_cast : boolean, default False
+            try to cast the result back to the input type (if possible),
+        raise_on_error : boolean, default True
+            Whether to raise on invalid data types (e.g. trying to where on
+            strings)
+
+        Returns
+        -------
+        wh : same type as caller
+        """)
+
+    @Appender(_shared_docs['where'] % dict(_shared_doc_kwargs, cond="True"))
+    def where(self, cond, other=np.nan, inplace=False, axis=None, level=None,
+              try_cast=False, raise_on_error=True):
+
+        other = com._apply_if_callable(other, self)
+        return self._where(cond, other, inplace, axis, level, try_cast,
+                           raise_on_error)
+
     @Appender(_shared_docs['where'] % dict(_shared_doc_kwargs, cond="False"))
     def mask(self, cond, other=np.nan, inplace=False, axis=None, level=None,
              try_cast=False, raise_on_error=True):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index cf1639bac..e2726bef0 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -738,7 +738,7 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
             if is_bool_indexer(key):
                 key = check_bool_indexer(self.index, key)
                 try:
-                    self.where(~key, value, inplace=True)
+                    self._where(~key, value, inplace=True)
                     return
                 except InvalidIndexError:
                     pass
diff --git a/pandas/tests/frame/test_indexing.py b/pandas/tests/frame/test_indexing.py
index 78354f32a..d7fed8131 100644
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -207,6 +207,16 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         exp = pd.DataFrame({'A': [11, 12, 13, 14], 'B': [5, 6, 7, 8]})
         tm.assert_frame_equal(df, exp)
 
+    def test_setitem_other_callable(self):
+        # GH 13299
+        inc = lambda x: x + 1
+
+        df = pd.DataFrame([[-1, 1], [1, -1]])
+        df[df > 0] = inc
+
+        expected = pd.DataFrame([[-1, inc], [inc, -1]])
+        tm.assert_frame_equal(df, expected)
+
     def test_getitem_boolean(self):
         # boolean indexing
         d = self.tsframe.index[10]
diff --git a/pandas/tests/series/test_indexing.py b/pandas/tests/series/test_indexing.py
index d01ac3e1a..15ca238ee 100644
--- a/pandas/tests/series/test_indexing.py
+++ b/pandas/tests/series/test_indexing.py
@@ -441,6 +441,16 @@ class TestSeriesIndexing(TestData, tm.TestCase):
         s[lambda x: 'A'] = -1
         tm.assert_series_equal(s, pd.Series([-1, 2, 3, 4], index=list('ABCD')))
 
+    def test_setitem_other_callable(self):
+        # GH 13299
+        inc = lambda x: x + 1
+
+        s = pd.Series([1, 2, -1, 4])
+        s[s < 0] = inc
+
+        expected = pd.Series([1, 2, inc, 4])
+        tm.assert_series_equal(s, expected)
+
     def test_slice(self):
         numSlice = self.series[10:20]
         numSliceEnd = self.series[-10:]

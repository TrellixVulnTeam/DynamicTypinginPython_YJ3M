commit 40393494ed3e3b3de59414e94ab8bf12b6aafe40
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Dec 11 00:47:01 2010 -0500

    Rolling moment plots in docs, API consistency, etc.

diff --git a/doc/make.py b/doc/make.py
index 032f6c76d..1c177578e 100755
--- a/doc/make.py
+++ b/doc/make.py
@@ -24,7 +24,6 @@ import sphinx
 os.environ['PYTHONPATH'] = '..'
 
 SPHINX_BUILD = 'sphinxbuild'
-NEED_AUTOSUMMARY = sphinx.__version__ < 0.7
 
 def sf():
     'push a copy to the sf site'
@@ -55,20 +54,8 @@ def check_build():
         except OSError:
             pass
 
-    if NEED_AUTOSUMMARY:
-        generate_autosummary()
-
-def generate_autosummary():
-    as_gen = "python ./sphinxext/autosummary_generate.py "
-    as_cmd = as_gen + "%s -p dump.xml -o source/generated"
-
-    for path in glob.glob('source/*.rst'):
-        if os.system(as_cmd % path):
-            raise SystemExit("Failed to auto generate "
-                             "summary for %s" % path)
-
 def all():
-    clean()
+    # clean()
     html()
 
 funcd = {
diff --git a/doc/plots/stats/moment_plots.py b/doc/plots/stats/moment_plots.py
new file mode 100644
index 000000000..7c8b6fb56
--- /dev/null
+++ b/doc/plots/stats/moment_plots.py
@@ -0,0 +1,29 @@
+import numpy as np
+
+import matplotlib.pyplot as plt
+import pandas.util.testing as t
+import pandas.stats.moments as m
+
+def test_series(n=1000):
+    t.N = n
+    s = t.makeTimeSeries()
+    return s
+
+def plot_timeseries(*args, **kwds):
+    n = len(args)
+
+    fig, axes = plt.subplots(n, 1, figsize=kwds.get('size', (10, 5)),
+                             sharex=True)
+    titles = kwds.get('titles', None)
+
+    for k in range(1, n + 1):
+        ax = axes[k-1]
+        ts = args[k-1]
+        ax.plot(ts.index, ts.values)
+
+        if titles:
+            ax.set_title(titles[k-1])
+
+    fig.autofmt_xdate()
+    fig.subplots_adjust(bottom=0.10, top=0.95)
+
diff --git a/doc/plots/stats/moments_expw.py b/doc/plots/stats/moments_expw.py
new file mode 100644
index 000000000..4ef856a3e
--- /dev/null
+++ b/doc/plots/stats/moments_expw.py
@@ -0,0 +1,32 @@
+from moment_plots import *
+
+np.random.seed(1)
+
+ts = test_series(500) * 10
+
+# ts[::100] = 20
+
+s = ts.cumsum()
+
+fig, axes = plt.subplots(3, 1, figsize=(8, 10), sharex=True)
+
+ax0, ax1, ax2 = axes
+
+ax0.plot(s.index, s.values)
+ax0.set_title('time series')
+
+ax1.plot(s.index, m.ewma(s, span=50, min_periods=1).values, color='b')
+ax1.plot(s.index, m.rolling_mean(s, 50, min_periods=1).values, color='r')
+ax1.set_title('rolling_mean vs. ewma')
+
+line1 = ax2.plot(s.index, m.ewmstd(s, span=50, min_periods=1).values, color='b')
+line2 = ax2.plot(s.index, m.rolling_std(s, 50, min_periods=1).values, color='r')
+ax2.set_title('rolling_std vs. ewmstd')
+
+fig.legend((line1, line2),
+           ('Exp-weighted', 'Equal-weighted'),
+           loc='upper right')
+fig.autofmt_xdate()
+fig.subplots_adjust(bottom=0.10, top=0.95)
+
+plt.show()
diff --git a/doc/plots/stats/moments_rolling.py b/doc/plots/stats/moments_rolling.py
new file mode 100644
index 000000000..05ed70ccc
--- /dev/null
+++ b/doc/plots/stats/moments_rolling.py
@@ -0,0 +1,23 @@
+from moment_plots import *
+
+ts = test_series()
+s = ts.cumsum()
+
+s[20:50] = np.NaN
+s[120:150] = np.NaN
+plot_timeseries(s,
+                m.rolling_count(s, 50),
+                m.rolling_sum(s, 50, min_periods=10),
+                m.rolling_mean(s, 50, min_periods=10),
+                m.rolling_std(s, 50, min_periods=10),
+                m.rolling_skew(s, 50, min_periods=10),
+                m.rolling_kurt(s, 50, min_periods=10),
+                size=(10, 12),
+                titles=('time series',
+                        'rolling_count',
+                        'rolling_sum',
+                        'rolling_mean',
+                        'rolling_std',
+                        'rolling_skew',
+                        'rolling_kurt'))
+plt.show()
diff --git a/doc/plots/stats/moments_rolling_binary.py b/doc/plots/stats/moments_rolling_binary.py
new file mode 100644
index 000000000..928b0544e
--- /dev/null
+++ b/doc/plots/stats/moments_rolling_binary.py
@@ -0,0 +1,29 @@
+from moment_plots import *
+
+np.random.seed(1)
+
+ts = test_series()
+s = ts.cumsum()
+ts2 = test_series()
+s2 = ts2.cumsum()
+
+s[20:50] = np.NaN
+s[120:150] = np.NaN
+fig, axes = plt.subplots(3, 1, figsize=(8, 10), sharex=True)
+
+ax0, ax1, ax2 = axes
+
+ax0.plot(s.index, s.values)
+ax0.plot(s2.index, s2.values)
+ax0.set_title('time series')
+
+ax1.plot(s.index, m.rolling_corr(s, s2, 50, min_periods=1).values)
+ax1.set_title('rolling_corr')
+
+ax2.plot(s.index, m.rolling_cov(s, s2, 50, min_periods=1).values)
+ax2.set_title('rolling_cov')
+
+fig.autofmt_xdate()
+fig.subplots_adjust(bottom=0.10, top=0.95)
+
+plt.show()
diff --git a/doc/source/stats_moments.rst b/doc/source/stats_moments.rst
index 27c28cfdd..c82fcd0f2 100644
--- a/doc/source/stats_moments.rst
+++ b/doc/source/stats_moments.rst
@@ -15,6 +15,41 @@ deviation, skewness, and kurtosis. All of these methods are in the
 Each of these methods observes the same interface (with relevant
 methods accepting two Series arguments instead of one):
 
+.. function:: Unary moment functions
+
+   :Parameters:
+       **arg** : ndarray, Series, DataFrame, etc.
+	       If a DataFrame is passed, function will be applied to **columns**
+
+       **window** : int
+           Number of periods to include in window
+
+       **min_periods** : int or None
+	       Number of periods to require to compute a value (defaults to
+	       **window**)
+
+       **time_rule** : string or DateOffset
+            Frequency to pre-convert data to
+
+.. function:: Binary moment functions
+
+   :Parameters:
+       **arg1** : ndarray, Series
+	       If a DataFrame is passed, function will be applied to **columns**
+
+       **arg2** : ndarray, Series
+	       Must be same type as **arg1**
+
+       **window** : int
+           Number of periods to include in window
+
+       **min_periods** : int or None
+	       Number of periods to require to compute a value (defaults to
+	       **window**)
+
+       **time_rule** : string or DateOffset
+            Frequency to pre-convert data to
+
 ::
 
     >>> ts
@@ -75,7 +110,15 @@ applied independently to the columns:
 Each of these methods can optionally accept a **time_rule** argument
 (see :ref:`time rules <datetools.timerules>`) which is provided as a
 convenience when the user wishes to guarantee that the window of the
-statistic
+statistic.
+
+Here are some plots of the unary moment functions:
+
+.. plot:: plots/stats/moments_rolling.py
+
+And the binary moment functions:
+
+.. plot:: plots/stats/moments_rolling_binary.py
 
 Method summary
 ~~~~~~~~~~~~~~
@@ -97,20 +140,47 @@ Method summary
 Exponentially weighted moment functions
 ---------------------------------------
 
-.. autofunction:: pandas.stats.moments.ewma
+It's also quite common to want to do non-equally weighted moving statistics,
+such as exponentially weighted (EW) moving average or EW moving standard
+deviation. A number of EW functions are provided using the blending method. For
+example, where :math:`y_t` is the result and :math:`x_t` the input, we compute
+an exponentially weighted moving average as
+
+.. math::
+
+    y_t = (1-\alpha) y_{t-1} + \alpha x_t
 
-.. plot:: plots/stats/moments_ewma.py
+One must have :math:`0 < \alpha \leq 1`, but rather than pass :math:`\alpha`
+directly, it's easier to think about either the **span** or **center of mass
+(com)** of an EW moment:
 
-There are similar functions for other basic moments, like standard
-deviation (a.k.a. volatility):
+.. math::
 
-.. plot:: plots/stats/moments_ewmvol.py
+   \alpha =
+    \begin{cases}
+	\frac{2}{s + 1}, s = \text{span}\\
+	\frac{1}{c + 1}, c = \text{center of mass}
+    \end{cases}
+
+You can pass one or the other to these functions but not both. **Span**
+corresponds to what is commonly called a "20-day EW moving average" for
+example. **Center of mass** has a more physical interpretation. For example,
+**span** = 20 corresponds to **com** = 9.5.
+
+Here are some examples for a univariate time series:
+
+.. plot:: plots/stats/moments_expw.py
+
+The binary `emwcov` and `ewmcorr` are similar to their equal-weighted
+counterparts above.
+
+.. autofunction:: pandas.stats.moments.ewma
 
 .. autosummary::
    :toctree: generated/
 
    ewma
-   ewmvol
+   ewmstd
    ewmvar
    ewmcorr
    ewmcov
diff --git a/doc/sphinxext/plot_directive.py b/doc/sphinxext/plot_directive.py
index efbd0d303..cacd53dbc 100755
--- a/doc/sphinxext/plot_directive.py
+++ b/doc/sphinxext/plot_directive.py
@@ -36,7 +36,7 @@ The ``plot`` directive supports the options
 
     include-source : bool
         Whether to display the source code. Default can be changed in conf.py
-    
+
 and the ``image`` directive options ``alt``, ``height``, ``width``,
 ``scale``, ``align``, ``class``.
 
@@ -94,7 +94,7 @@ def setup(app):
     setup.app = app
     setup.config = app.config
     setup.confdir = app.confdir
-    
+
     app.add_config_value('plot_pre_code', '', True)
     app.add_config_value('plot_include_source', False, True)
     app.add_config_value('plot_formats', ['png', 'hires.png', 'pdf'], True)
@@ -453,7 +453,7 @@ def run_code(code, code_path, ns=None):
     # Reset sys.argv
     old_sys_argv = sys.argv
     sys.argv = [code_path]
-    
+
     try:
         try:
             code = unescape_doctest(code)
@@ -568,7 +568,8 @@ def makefig(code, code_path, output_dir, output_base, config):
             images.append(img)
             for format, dpi in formats:
                 try:
-                    figman.canvas.figure.savefig(img.filename(format), dpi=dpi)
+                    figman.canvas.figure.savefig(img.filename(format), dpi=dpi,
+                                                 bbox_inches='tight')
                 except exceptions.BaseException, err:
                     raise PlotError(traceback.format_exc())
                 img.formats.append(format)
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 145728084..b50802b7d 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -15,7 +15,8 @@ import pandas.lib.tseries as tseries
 __all__ = ['rolling_count', 'rolling_max', 'rolling_min',
            'rolling_sum', 'rolling_mean', 'rolling_std', 'rolling_cov',
            'rolling_corr', 'rolling_var', 'rolling_skew', 'rolling_kurt',
-           'rolling_median', 'ewma', 'ewmstd', 'ewmvol', 'ewmcorr', 'ewmcov']
+           'rolling_median', 'ewma', 'ewmvar', 'ewmstd', 'ewmvol',
+           'ewmcorr', 'ewmcov']
 
 def rolling_count(arg, window, time_rule=None):
     """
@@ -26,10 +27,7 @@ def rolling_count(arg, window, time_rule=None):
     arg :  DataFrame or numpy ndarray-like
     window : Number of observations used for calculating statistic
     """
-    if time_rule is not None and isinstance(arg, (DataFrame, Series)):
-        # Conform to whatever frequency needed.
-        arg = arg.asfreq(time_rule)
-
+    arg = _conv_timerule(arg, time_rule)
     window = min(window, len(arg))
 
     return_hook, values = _process_data_structure(arg, kill_inf=False)
@@ -108,15 +106,9 @@ def _rolling_moment(arg, window, func, minp, axis=0, time_rule=None):
     -------
     y : type of input
     """
-    types = (DataFrame, Series)
-    if time_rule is not None and isinstance(arg, types):
-        # Conform to whatever frequency needed.
-        arg = arg.asfreq(time_rule)
-
+    arg = _conv_timerule(arg, time_rule)
     calc = lambda x: func(x, window, minp=minp)
-
     return_hook, values = _process_data_structure(arg)
-
     # actually calculate the moment. Faster way to do this?
     result = np.apply_along_axis(calc, axis, values)
 
@@ -177,6 +169,8 @@ span : float, optional
 min_periods : int, default 0
     Number of observations in sample to require (only affects
     beginning)
+time_rule : {None, 'WEEKDAY', 'EOM', 'W@MON', ...}, default None
+    Name of time rule to conform to before computing statistic
 %s
 Returns
 -------
@@ -208,8 +202,9 @@ _bias_doc = r"""bias : boolean, default False
     Use a standard estimation bias correction
 """
 
-def ewma(arg, com=None, span=None, min_periods=0):
+def ewma(arg, com=None, span=None, min_periods=0, time_rule=None):
     com = _get_center_of_mass(com, span)
+    arg = _conv_timerule(arg, time_rule)
 
     def _ewma(v):
         result = tseries.ewma(v, com)
@@ -220,15 +215,17 @@ def ewma(arg, com=None, span=None, min_periods=0):
     return_hook, values = _process_data_structure(arg)
     output = np.apply_along_axis(_ewma, 0, values)
     return return_hook(output)
-ewma.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving average",
+ewma.__doc__ = _ewm_doc % ("Exponentially-weighted moving average",
                            _unary_arg, "")
 
 def _first_valid_index(arr):
     # argmax scans from left
     return notnull(arr).argmax()
 
-def ewmvar(arg, com=None, span=None, min_periods=0, bias=False):
+def ewmvar(arg, com=None, span=None, min_periods=0, bias=False,
+           time_rule=None):
     com = _get_center_of_mass(com, span)
+    arg = _conv_timerule(arg, time_rule)
     moment2nd = ewma(arg * arg, com=com, min_periods=min_periods)
     moment1st = ewma(arg, com=com, min_periods=min_periods)
 
@@ -237,20 +234,26 @@ def ewmvar(arg, com=None, span=None, min_periods=0, bias=False):
         result *= (1.0 + 2.0 * com) / (2.0 * com)
 
     return result
-ewmvar.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving variance",
+ewmvar.__doc__ = _ewm_doc % ("Exponentially-weighted moving variance",
                              _unary_arg, _bias_doc)
 
-def ewmstd(arg, com=None, span=None, min_periods=0, bias=False):
-    result = ewmvar(arg, com=com, span=span,
+def ewmstd(arg, com=None, span=None, min_periods=0, bias=False,
+           time_rule=None):
+    result = ewmvar(arg, com=com, span=span, time_rule=time_rule,
                     min_periods=min_periods, bias=bias)
     return np.sqrt(result)
-ewmstd.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving std",
+ewmstd.__doc__ = _ewm_doc % ("Exponentially-weighted moving std",
                              _unary_arg, _bias_doc)
 
 ewmvol = ewmstd
 
-def ewmcov(arg1, arg2, com=None, span=None, min_periods=0, bias=False):
+def ewmcov(arg1, arg2, com=None, span=None, min_periods=0, bias=False,
+           time_rule=None):
     X, Y = _prep_binary(arg1, arg2)
+
+    X = _conv_timerule(X, time_rule)
+    Y = _conv_timerule(Y, time_rule)
+
     mean = lambda x: ewma(x, com=com, span=span, min_periods=min_periods)
 
     result = (mean(X*Y) - mean(X) * mean(Y))
@@ -259,16 +262,21 @@ def ewmcov(arg1, arg2, com=None, span=None, min_periods=0, bias=False):
         result *= (1.0 + 2.0 * com) / (2.0 * com)
 
     return result
-ewmcov.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving covariance",
+ewmcov.__doc__ = _ewm_doc % ("Exponentially-weighted moving covariance",
                              _binary_arg, "")
 
-def ewmcorr(arg1, arg2, com=None, span=None, min_periods=0):
+def ewmcorr(arg1, arg2, com=None, span=None, min_periods=0,
+            time_rule=None):
     X, Y = _prep_binary(arg1, arg2)
+
+    X = _conv_timerule(X, time_rule)
+    Y = _conv_timerule(Y, time_rule)
+
     mean = lambda x: ewma(x, com=com, span=span, min_periods=min_periods)
     var = lambda x: ewmvar(x, com=com, span=span, min_periods=min_periods,
                            bias=True)
     return (mean(X*Y) - mean(X)*mean(Y)) / np.sqrt(var(X) * var(Y))
-ewmcorr.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving "
+ewmcorr.__doc__ = _ewm_doc % ("Exponentially-weighted moving "
                               "correlation", _binary_arg, "")
 
 def _prep_binary(arg1, arg2):
@@ -301,6 +309,14 @@ Returns
 y : type of input argument
 """
 
+def _conv_timerule(arg, time_rule):
+    types = (DataFrame, Series)
+    if time_rule is not None and isinstance(arg, types):
+        # Conform to whatever frequency needed.
+        arg = arg.asfreq(time_rule)
+
+    return arg
+
 def _two_periods(minp, window):
     if minp is None:
         return window
diff --git a/pandas/version.py b/pandas/version.py
index 64724e10a..bcbe3d68a 100644
--- a/pandas/version.py
+++ b/pandas/version.py
@@ -1,3 +1,3 @@
 from datetime import datetime
 
-version = '0.3.0.dev20101119'
+version = '0.3.0dev'
diff --git a/test.sh b/test.sh
index a70147c39..29341bf4f 100755
--- a/test.sh
+++ b/test.sh
@@ -1,5 +1,5 @@
 #!/bin/sh
 coverage erase
-nosetests -w pandas/core --with-coverage --cover-package=pandas.core --pdb-failure
-# nosetests -w pandas/stats --with-coverage --cover-package=pandas.stats
+# nosetests -w pandas/core --with-coverage --cover-package=pandas.core --pdb-failure
+nosetests -w pandas/stats --with-coverage --cover-package=pandas.stats
 # coverage run runtests.py
\ No newline at end of file

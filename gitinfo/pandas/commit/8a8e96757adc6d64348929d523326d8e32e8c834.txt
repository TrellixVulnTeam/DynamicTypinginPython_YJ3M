commit 8a8e96757adc6d64348929d523326d8e32e8c834
Author: William Ayd <will_ayd@innobi.io>
Date:   Mon Jan 20 15:44:48 2020 -0800

    Split out JSON Date Converters (#31057)

diff --git a/pandas/_libs/src/ujson/python/date_conversions.c b/pandas/_libs/src/ujson/python/date_conversions.c
new file mode 100644
index 000000000..fc4bdef84
--- /dev/null
+++ b/pandas/_libs/src/ujson/python/date_conversions.c
@@ -0,0 +1,118 @@
+// Conversion routines that are useful for serialization,
+// but which don't interact with JSON objects directly
+
+#include "date_conversions.h"
+#include <../../../tslibs/src/datetime/np_datetime.h>
+#include <../../../tslibs/src/datetime/np_datetime_strings.h>
+
+/*
+ * Function: scaleNanosecToUnit
+ * -----------------------------
+ *
+ * Scales an integer value representing time in nanoseconds to provided unit.
+ *
+ * Mutates the provided value directly. Returns 0 on success, non-zero on error.
+ */
+int scaleNanosecToUnit(npy_int64 *value, NPY_DATETIMEUNIT unit) {
+    switch (unit) {
+    case NPY_FR_ns:
+        break;
+    case NPY_FR_us:
+        *value /= 1000LL;
+        break;
+    case NPY_FR_ms:
+        *value /= 1000000LL;
+        break;
+    case NPY_FR_s:
+        *value /= 1000000000LL;
+        break;
+    default:
+        return -1;
+    }
+
+    return 0;
+}
+
+/* Converts the int64_t representation of a datetime to ISO; mutates len */
+char *int64ToIso(int64_t value, NPY_DATETIMEUNIT base, size_t *len) {
+    npy_datetimestruct dts;
+    int ret_code;
+
+    pandas_datetime_to_datetimestruct(value, NPY_FR_ns, &dts);
+
+    *len = (size_t)get_datetime_iso_8601_strlen(0, base);
+    char *result = PyObject_Malloc(*len);
+
+    if (result == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    ret_code = make_iso_8601_datetime(&dts, result, *len, base);
+    if (ret_code != 0) {
+        PyErr_SetString(PyExc_ValueError,
+                        "Could not convert datetime value to string");
+        PyObject_Free(result);
+    }
+
+    // Note that get_datetime_iso_8601_strlen just gives a generic size
+    // for ISO string conversion, not the actual size used
+    *len = strlen(result);
+    return result;
+}
+
+npy_datetime NpyDateTimeToEpoch(npy_datetime dt, NPY_DATETIMEUNIT base) {
+    scaleNanosecToUnit(&dt, base);
+    return dt;
+}
+
+/* Convert PyDatetime To ISO C-string. mutates len */
+char *PyDateTimeToIso(PyDateTime_Date *obj, NPY_DATETIMEUNIT base,
+                      size_t *len) {
+    npy_datetimestruct dts;
+    int ret;
+
+    ret = convert_pydatetime_to_datetimestruct(obj, &dts);
+    if (ret != 0) {
+        if (!PyErr_Occurred()) {
+            PyErr_SetString(PyExc_ValueError,
+                            "Could not convert PyDateTime to numpy datetime");
+        }
+        return NULL;
+    }
+
+    *len = (size_t)get_datetime_iso_8601_strlen(0, base);
+    char *result = PyObject_Malloc(*len);
+    ret = make_iso_8601_datetime(&dts, result, *len, base);
+
+    if (ret != 0) {
+        PyErr_SetString(PyExc_ValueError,
+                        "Could not convert datetime value to string");
+        PyObject_Free(result);
+        return NULL;
+    }
+
+    // Note that get_datetime_iso_8601_strlen just gives a generic size
+    // for ISO string conversion, not the actual size used
+    *len = strlen(result);
+    return result;
+}
+
+npy_datetime PyDateTimeToEpoch(PyDateTime_Date *dt, NPY_DATETIMEUNIT base) {
+    npy_datetimestruct dts;
+    int ret;
+
+    ret = convert_pydatetime_to_datetimestruct(dt, &dts);
+    if (ret != 0) {
+        if (!PyErr_Occurred()) {
+            PyErr_SetString(PyExc_ValueError,
+                            "Could not convert PyDateTime to numpy datetime");
+        }
+        // TODO: is setting errMsg required?
+        //((JSONObjectEncoder *)tc->encoder)->errorMsg = "";
+        // return NULL;
+    }
+
+    npy_datetime npy_dt = npy_datetimestruct_to_datetime(NPY_FR_ns, &dts);
+    return NpyDateTimeToEpoch(npy_dt, base);
+}
diff --git a/pandas/_libs/src/ujson/python/date_conversions.h b/pandas/_libs/src/ujson/python/date_conversions.h
new file mode 100644
index 000000000..45455f4d6
--- /dev/null
+++ b/pandas/_libs/src/ujson/python/date_conversions.h
@@ -0,0 +1,31 @@
+#ifndef PANDAS__LIBS_SRC_UJSON_DATE_CONVERSIONS
+#define PANDAS__LIBS_SRC_UJSON_DATE_CONVERSIONS
+
+#define PY_SSIZE_T_CLEAN
+#include <Python.h>
+#include <numpy/ndarraytypes.h>
+#include "datetime.h"
+
+// Scales value inplace from nanosecond resolution to unit resolution
+int scaleNanosecToUnit(npy_int64 *value, NPY_DATETIMEUNIT unit);
+
+// Converts an int64 object representing a date to ISO format
+// up to precision `base` e.g. base="s" yields 2020-01-03T00:00:00Z
+// while base="ns" yields "2020-01-01T00:00:00.000000000Z"
+// len is mutated to save the length of the returned string
+char *int64ToIso(int64_t value, NPY_DATETIMEUNIT base, size_t *len);
+
+// TODO: this function doesn't do a lot; should augment or replace with
+// scaleNanosecToUnit
+npy_datetime NpyDateTimeToEpoch(npy_datetime dt, NPY_DATETIMEUNIT base);
+
+// Converts a Python object representing a Date / Datetime to ISO format
+// up to precision `base` e.g. base="s" yields 2020-01-03T00:00:00Z
+// while base="ns" yields "2020-01-01T00:00:00.000000000Z"
+// len is mutated to save the length of the returned string
+char *PyDateTimeToIso(PyDateTime_Date *obj, NPY_DATETIMEUNIT base, size_t *len);
+
+// Convert a Python Date/Datetime to Unix epoch with resolution base
+npy_datetime PyDateTimeToEpoch(PyDateTime_Date *dt, NPY_DATETIMEUNIT base);
+
+#endif
diff --git a/pandas/_libs/src/ujson/python/objToJSON.c b/pandas/_libs/src/ujson/python/objToJSON.c
index c5ac279ed..0367661e5 100644
--- a/pandas/_libs/src/ujson/python/objToJSON.c
+++ b/pandas/_libs/src/ujson/python/objToJSON.c
@@ -45,8 +45,7 @@ http://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms
 #include <numpy/ndarraytypes.h>
 #include <numpy/npy_math.h>
 #include <ultrajson.h>
-#include <../../../tslibs/src/datetime/np_datetime.h>
-#include <../../../tslibs/src/datetime/np_datetime_strings.h>
+#include "date_conversions.h"
 #include "datetime.h"
 
 static PyTypeObject *type_decimal;
@@ -209,34 +208,6 @@ static TypeContext *createTypeContext(void) {
     return pc;
 }
 
-/*
- * Function: scaleNanosecToUnit
- * -----------------------------
- *
- * Scales an integer value representing time in nanoseconds to provided unit.
- *
- * Mutates the provided value directly. Returns 0 on success, non-zero on error.
- */
-static int scaleNanosecToUnit(npy_int64 *value, NPY_DATETIMEUNIT unit) {
-    switch (unit) {
-    case NPY_FR_ns:
-        break;
-    case NPY_FR_us:
-        *value /= 1000LL;
-        break;
-    case NPY_FR_ms:
-        *value /= 1000000LL;
-        break;
-    case NPY_FR_s:
-        *value /= 1000000000LL;
-        break;
-    default:
-        return -1;
-    }
-
-    return 0;
-}
-
 static PyObject *get_values(PyObject *obj) {
     PyObject *values = NULL;
 
@@ -379,34 +350,6 @@ static char *PyUnicodeToUTF8(JSOBJ _obj, JSONTypeContext *Py_UNUSED(tc),
     return (char *)PyUnicode_AsUTF8AndSize(_obj, (Py_ssize_t *)_outLen);
 }
 
-/* Converts the int64_t representation of a datetime to ISO; mutates len */
-static char *int64ToIso(int64_t value, NPY_DATETIMEUNIT base, size_t *len) {
-    npy_datetimestruct dts;
-    int ret_code;
-
-    pandas_datetime_to_datetimestruct(value, NPY_FR_ns, &dts);
-
-    *len = (size_t)get_datetime_iso_8601_strlen(0, base);
-    char *result = PyObject_Malloc(*len);
-
-    if (result == NULL) {
-        PyErr_NoMemory();
-        return NULL;
-    }
-
-    ret_code = make_iso_8601_datetime(&dts, result, *len, base);
-    if (ret_code != 0) {
-        PyErr_SetString(PyExc_ValueError,
-                        "Could not convert datetime value to string");
-        PyObject_Free(result);
-    }
-
-    // Note that get_datetime_iso_8601_strlen just gives a generic size
-    // for ISO string conversion, not the actual size used
-    *len = strlen(result);
-    return result;
-}
-
 /* JSON callback. returns a char* and mutates the pointer to *len */
 static char *NpyDateTimeToIsoCallback(JSOBJ Py_UNUSED(unused),
                                       JSONTypeContext *tc, size_t *len) {
@@ -414,44 +357,6 @@ static char *NpyDateTimeToIsoCallback(JSOBJ Py_UNUSED(unused),
     return int64ToIso(GET_TC(tc)->longValue, base, len);
 }
 
-static npy_datetime NpyDateTimeToEpoch(npy_datetime dt, NPY_DATETIMEUNIT base) {
-    scaleNanosecToUnit(&dt, base);
-    return dt;
-}
-
-/* Convert PyDatetime To ISO C-string. mutates len */
-static char *PyDateTimeToIso(PyDateTime_Date *obj, NPY_DATETIMEUNIT base,
-                             size_t *len) {
-    npy_datetimestruct dts;
-    int ret;
-
-    ret = convert_pydatetime_to_datetimestruct(obj, &dts);
-    if (ret != 0) {
-        if (!PyErr_Occurred()) {
-            PyErr_SetString(PyExc_ValueError,
-                            "Could not convert PyDateTime to numpy datetime");
-        }
-        return NULL;
-    }
-
-    *len = (size_t)get_datetime_iso_8601_strlen(0, base);
-    char *result = PyObject_Malloc(*len);
-    ret = make_iso_8601_datetime(&dts, result, *len, base);
-
-    if (ret != 0) {
-        PRINTMARK();
-        PyErr_SetString(PyExc_ValueError,
-                        "Could not convert datetime value to string");
-        PyObject_Free(result);
-        return NULL;
-    }
-
-    // Note that get_datetime_iso_8601_strlen just gives a generic size
-    // for ISO string conversion, not the actual size used
-    *len = strlen(result);
-    return result;
-}
-
 /* JSON callback */
 static char *PyDateTimeToIsoCallback(JSOBJ obj, JSONTypeContext *tc,
                                      size_t *len) {
@@ -465,30 +370,6 @@ static char *PyDateTimeToIsoCallback(JSOBJ obj, JSONTypeContext *tc,
     return PyDateTimeToIso(obj, base, len);
 }
 
-static npy_datetime PyDateTimeToEpoch(PyObject *obj, NPY_DATETIMEUNIT base) {
-    npy_datetimestruct dts;
-    int ret;
-
-    if (!PyDate_Check(obj)) {
-        // TODO: raise TypeError
-    }
-    PyDateTime_Date *dt = (PyDateTime_Date *)obj;
-
-    ret = convert_pydatetime_to_datetimestruct(dt, &dts);
-    if (ret != 0) {
-        if (!PyErr_Occurred()) {
-            PyErr_SetString(PyExc_ValueError,
-                            "Could not convert PyDateTime to numpy datetime");
-        }
-        // TODO: is setting errMsg required?
-        //((JSONObjectEncoder *)tc->encoder)->errorMsg = "";
-        // return NULL;
-    }
-
-    npy_datetime npy_dt = npy_datetimestruct_to_datetime(NPY_FR_ns, &dts);
-    return NpyDateTimeToEpoch(npy_dt, base);
-}
-
 static char *PyTimeToJSON(JSOBJ _obj, JSONTypeContext *tc, size_t *outLen) {
     PyObject *obj = (PyObject *)_obj;
     PyObject *str;
@@ -1814,7 +1695,7 @@ void Object_beginTypeContext(JSOBJ _obj, JSONTypeContext *tc) {
             PRINTMARK();
             NPY_DATETIMEUNIT base =
                 ((PyObjectEncoder *)tc->encoder)->datetimeUnit;
-            GET_TC(tc)->longValue = PyDateTimeToEpoch(obj, base);
+            GET_TC(tc)->longValue = PyDateTimeToEpoch((PyDateTime_Date *)obj, base);
             tc->type = JT_LONG;
         }
         return;
@@ -1840,7 +1721,7 @@ void Object_beginTypeContext(JSOBJ _obj, JSONTypeContext *tc) {
             PRINTMARK();
             NPY_DATETIMEUNIT base =
                 ((PyObjectEncoder *)tc->encoder)->datetimeUnit;
-            GET_TC(tc)->longValue = PyDateTimeToEpoch(obj, base);
+            GET_TC(tc)->longValue = PyDateTimeToEpoch((PyDateTime_Date *)obj, base);
             tc->type = JT_LONG;
         }
         return;
diff --git a/setup.py b/setup.py
index 191fe49d1..c7dbde2ff 100755
--- a/setup.py
+++ b/setup.py
@@ -240,6 +240,7 @@ class CleanCommand(Command):
             pjoin(ujson_python, "ujson.c"),
             pjoin(ujson_python, "objToJSON.c"),
             pjoin(ujson_python, "JSONtoObj.c"),
+            pjoin(ujson_python, "date_conversions.c"),
             pjoin(ujson_lib, "ultrajsonenc.c"),
             pjoin(ujson_lib, "ultrajsondec.c"),
             pjoin(util, "move.c"),
@@ -714,11 +715,15 @@ if suffix == ".pyx":
 
 ujson_ext = Extension(
     "pandas._libs.json",
-    depends=["pandas/_libs/src/ujson/lib/ultrajson.h"],
+    depends=[
+        "pandas/_libs/src/ujson/lib/ultrajson.h",
+        "pandas/_libs/src/ujson/python/date_conversions.h",
+    ],
     sources=(
         [
             "pandas/_libs/src/ujson/python/ujson.c",
             "pandas/_libs/src/ujson/python/objToJSON.c",
+            "pandas/_libs/src/ujson/python/date_conversions.c",
             "pandas/_libs/src/ujson/python/JSONtoObj.c",
             "pandas/_libs/src/ujson/lib/ultrajsonenc.c",
             "pandas/_libs/src/ujson/lib/ultrajsondec.c",

commit a9971e35115a97c0489c9dcc59a06a056d5bad85
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Oct 2 12:37:57 2011 -0400

    TST: test coverage for take functions and added out keyword to take_1d

diff --git a/RELEASE.rst b/RELEASE.rst
index c062aa607..33bdc66e2 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -14,7 +14,10 @@ This is an incremental bug fix and performance enhancement release
 
 **New features / modules**
 
-  - Added `Int64Index` type with specialized join, union, intersection
+  - Added fast `Int64Index` type with specialized join, union,
+    intersection. Will result in significant performance enhancements for
+    int64-based time series (e.g. using NumPy's datetime64 one day) and also
+    faster operations on DataFrame objects storing record array-like data.
   - Refactored `Index` classes to have a `join` method and associated data
     alignment routines throughout the codebase to be able to leverage optimized
     joining / merging routines.
@@ -49,6 +52,10 @@ This is an incremental bug fix and performance enhancement release
   - Added informative Exception when passing dict to DataFrame groupby
     aggregation with axis != 0
 
+**API Changes**
+
+None
+
 **Bug fixes**
 
   - Fixed minor unhandled exception in Cython code implementing fast groupby
@@ -103,6 +110,10 @@ improvements
   - Optimized `_ensure_index` function resulting in performance savings in
     type-checking Index objects
 
+**API Changes**
+
+None
+
 **Bug fixes**
 
   - Fixed DataFrame constructor bug causing downstream problems (e.g. .copy()
diff --git a/pandas/core/common.py b/pandas/core/common.py
index d420d4183..b0e7242fe 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -53,7 +53,7 @@ def isnull(obj):
     elif isinstance(obj, PandasObject):
         # TODO: optimize for DataFrame, etc.
         return obj.apply(isnull)
-    else:
+    else:  # pragma: no cover
         raise TypeError('cannot handle %s type' % type(obj))
 
 def notnull(obj):
@@ -130,30 +130,47 @@ def _get_take2d_function(dtype_str, axis=0):
     else:
         return _take2d_axis1_dict[dtype_str]
 
-def take_1d(arr, indexer):
+def take_1d(arr, indexer, out=None):
     """
     Specialized Cython take which sets NaN values in one pass
     """
     dtype_str = arr.dtype.name
 
+    n = len(indexer)
+
+    if not isinstance(indexer, np.ndarray):
+        # Cython methods expects 32-bit integers
+        indexer = np.array(indexer, dtype=np.int32)
+
+    out_passed = out is not None
+
     if dtype_str in ('int32', 'int64', 'bool'):
-        mask = indexer == -1
-        if mask.any():
-            out = arr.take(indexer)
-            out = _maybe_upcast(out)
-            np.putmask(out, mask, np.nan)
-        else:
-            out = np.empty(len(indexer), dtype=arr.dtype)
+        try:
+            if out is None:
+                out = np.empty(n, dtype=arr.dtype)
             take_f = _take1d_dict[dtype_str]
             take_f(arr, indexer, out=out)
+        except ValueError:
+            mask = indexer == -1
+            out = arr.take(indexer, out=out)
+            if mask.any():
+                if out_passed:
+                    raise Exception('out with dtype %s does not support NA' %
+                                    out.dtype)
+                out = _maybe_upcast(out)
+                np.putmask(out, mask, np.nan)
     elif dtype_str in ('float64', 'object'):
-        out = np.empty(len(indexer), dtype=arr.dtype)
+        if out is None:
+            out = np.empty(n, dtype=arr.dtype)
         take_f = _take1d_dict[dtype_str]
         take_f(arr, indexer, out=out)
     else:
-        out = arr.take(indexer)
+        out = arr.take(indexer, out=out)
         mask = indexer == -1
         if mask.any():
+            if out_passed:
+                raise Exception('out with dtype %s does not support NA' %
+                                out.dtype)
             out = _maybe_upcast(out)
             np.putmask(out, mask, np.nan)
 
@@ -169,6 +186,10 @@ def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
     out_shape[axis] = len(indexer)
     out_shape = tuple(out_shape)
 
+    if not isinstance(indexer, np.ndarray):
+        # Cython methods expects 32-bit integers
+        indexer = np.array(indexer, dtype=np.int32)
+
     if dtype_str in ('int32', 'int64', 'bool'):
         if mask is None:
             mask = indexer == -1
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 4dfd327c7..6442560c7 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -1,3 +1,5 @@
+import unittest
+
 from pandas import Series, DataFrame
 from pandas.core.common import notnull, isnull
 import pandas.core.common as common
@@ -122,6 +124,118 @@ def test_groupby():
     for k, v in grouped:
         assert v == expected[k]
 
+class TestTake(unittest.TestCase):
+
+    def setUp(self):
+        pass
+
+    def test_1d_with_out(self):
+        def _test_dtype(dtype):
+            out = np.empty(5, dtype=dtype)
+            arr = np.random.randn(10).astype(dtype)
+            indexer = [0, 2, 4, 7, 1]
+
+            arr.take(indexer, out=out)
+            expected = arr.take(indexer)
+            tm.assert_almost_equal(out, expected)
+
+        _test_dtype(np.float64)
+        _test_dtype(np.float32)
+        _test_dtype(np.int32)
+        _test_dtype(np.int64)
+        _test_dtype(np.object_)
+        _test_dtype(np.bool)
+
+    def test_1d_upcast_with_out(self):
+        def _test_dtype(dtype):
+            out = np.empty(4, dtype=dtype)
+            data = np.random.randint(0, 2, 5).astype(dtype)
+
+            indexer = [2, 1, 0, -1]
+            self.assertRaises(Exception, common.take_1d, data,
+                              indexer, out=out)
+
+        _test_dtype(np.int64)
+        _test_dtype(np.int32)
+        _test_dtype(np.int16)
+        _test_dtype(np.int8)
+        _test_dtype(np.bool)
+
+    def test_2d_upcast_with_out(self):
+        def _test_dtype(dtype):
+            out0 = np.empty((4, 3), dtype=dtype)
+            out1 = np.empty((5, 4), dtype=dtype)
+
+            data = np.random.randint(0, 2, (5, 3)).astype(dtype)
+
+            indexer = [2, 1, 0, -1]
+            self.assertRaises(Exception, common.take_2d, data,
+                              indexer, out=out0, axis=0)
+            self.assertRaises(Exception, common.take_2d, data,
+                              indexer, out=out1, axis=1)
+
+            # no exception o/w
+            data.take(indexer, out=out0, axis=0)
+            data.take(indexer, out=out1, axis=1)
+
+        _test_dtype(np.int64)
+        _test_dtype(np.int32)
+        _test_dtype(np.int16)
+        _test_dtype(np.int8)
+        _test_dtype(np.bool)
+
+    def test_1d_other_dtypes(self):
+        arr = np.random.randn(10).astype(np.float32)
+
+        indexer = [1, 2, 3, -1]
+        result = common.take_1d(arr, indexer)
+        expected = arr.take(indexer)
+        expected[-1] = np.nan
+        tm.assert_almost_equal(result, expected)
+
+    def test_2d_other_dtypes(self):
+        arr = np.random.randn(10, 5).astype(np.float32)
+
+        indexer = [1, 2, 3, -1]
+
+        # axis=0
+        result = common.take_2d(arr, indexer, axis=0)
+        expected = arr.take(indexer, axis=0)
+        expected[-1] = np.nan
+        tm.assert_almost_equal(result, expected)
+
+        # axis=1
+        result = common.take_2d(arr, indexer, axis=1)
+        expected = arr.take(indexer, axis=1)
+        expected[:, -1] = np.nan
+        tm.assert_almost_equal(result, expected)
+
+    def test_1d_bool(self):
+        arr = np.array([0, 1, 0], dtype=bool)
+
+        result = common.take_1d(arr, [0, 2, 2, 1])
+        expected = arr.take([0, 2, 2, 1])
+        self.assert_(np.array_equal(result, expected))
+
+        result = common.take_1d(arr, [0, 2, -1])
+        self.assert_(result.dtype == np.object_)
+
+    def test_2d_bool(self):
+        arr = np.array([[0, 1, 0],
+                        [1, 0, 1],
+                        [0, 1, 1]], dtype=bool)
+
+        result = common.take_2d(arr, [0, 2, 2, 1])
+        expected = arr.take([0, 2, 2, 1], axis=0)
+        self.assert_(np.array_equal(result, expected))
+
+        result = common.take_2d(arr, [0, 2, 2, 1], axis=1)
+        expected = arr.take([0, 2, 2, 1], axis=1)
+        self.assert_(np.array_equal(result, expected))
+
+        result = common.take_2d(arr, [0, 2, -1])
+        self.assert_(result.dtype == np.object_)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],

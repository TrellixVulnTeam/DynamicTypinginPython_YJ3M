commit 9207145815ca3c50ea3db19eebcaeaa04c9e6bd2
Author: Jeff Reback <jeff@reback.net>
Date:   Tue Mar 3 06:28:27 2015 -0500

    clean up semantics on slice_indexer a bit
    
    rename typ -> kind for _convert_*_indexer
    
    add kind argument to _maybe_cast_slice_bound
    
    cleaned up _convert_slice_indexer a bit

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 18500fd05..9e4e79f3d 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1159,11 +1159,11 @@ class NDFrame(PandasObject):
         else:
             self._item_cache.clear()
 
-    def _slice(self, slobj, axis=0, typ=None):
+    def _slice(self, slobj, axis=0, kind=None):
         """
         Construct a slice of this container.
 
-        typ parameter is maintained for compatibility with Series slicing.
+        kind parameter is maintained for compatibility with Series slicing.
 
         """
         axis = self._get_block_manager_axis(axis)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 298f00532..10dcdc5a7 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -632,8 +632,16 @@ class Index(IndexOpsMixin, PandasObject):
     def holds_integer(self):
         return self.inferred_type in ['integer', 'mixed-integer']
 
-    def _convert_scalar_indexer(self, key, typ=None):
-        """ convert a scalar indexer, right now we are converting
+    def _convert_scalar_indexer(self, key, kind=None):
+        """
+        convert a scalar indexer
+
+        Parameters
+        ----------
+        key : label of the slice bound
+        kind : optional, type of the indexing operation (loc/ix/iloc/None)
+
+        right now we are converting
         floats -> ints if the index supports it
         """
 
@@ -643,7 +651,7 @@ class Index(IndexOpsMixin, PandasObject):
                 return self._invalid_indexer('label', key)
             return ikey
 
-        if typ == 'iloc':
+        if kind == 'iloc':
             if is_integer(key):
                 return key
             elif is_float(key):
@@ -661,14 +669,6 @@ class Index(IndexOpsMixin, PandasObject):
 
         return key
 
-    def _validate_slicer(self, key, f):
-        """ validate and raise if needed on a slice indexers according to the
-        passed in function """
-
-        for c in ['start','stop','step']:
-            if not f(getattr(key,c)):
-                self._invalid_indexer('slice {0} value'.format(c), key.start)
-
     def _convert_slice_indexer_getitem(self, key, is_index_slice=False):
         """ called from the getitem slicers, determine how to treat the key
             whether positional or not """
@@ -676,15 +676,22 @@ class Index(IndexOpsMixin, PandasObject):
             return key
         return self._convert_slice_indexer(key)
 
-    def _convert_slice_indexer(self, key, typ=None):
-        """ convert a slice indexer. disallow floats in the start/stop/step """
+    def _convert_slice_indexer(self, key, kind=None):
+        """
+        convert a slice indexer. disallow floats in the start/stop/step
+
+        Parameters
+        ----------
+        key : label of the slice bound
+        kind : optional, type of the indexing operation (loc/ix/iloc/None)
+        """
 
         # if we are not a slice, then we are done
         if not isinstance(key, slice):
             return key
 
         # validate iloc
-        if typ == 'iloc':
+        if kind == 'iloc':
 
             # need to coerce to_int if needed
             def f(c):
@@ -709,13 +716,16 @@ class Index(IndexOpsMixin, PandasObject):
 
             # dissallow floats (except for .ix)
             elif is_float(v):
-                if typ == 'ix':
+                if kind == 'ix':
                     return True
 
                 return False
 
             return True
-        self._validate_slicer(key, validate)
+        for c in ['start','stop','step']:
+            v = getattr(key,c)
+            if not validate(v):
+                self._invalid_indexer('slice {0} value'.format(c), v)
 
         # figure out if this is a positional indexer
         start, stop, step = key.start, key.stop, key.step
@@ -727,7 +737,7 @@ class Index(IndexOpsMixin, PandasObject):
         is_index_slice = is_int(start) and is_int(stop)
         is_positional = is_index_slice and not self.is_integer()
 
-        if typ == 'getitem':
+        if kind == 'getitem':
             return self._convert_slice_indexer_getitem(
                 key, is_index_slice=is_index_slice)
 
@@ -763,16 +773,16 @@ class Index(IndexOpsMixin, PandasObject):
 
         return indexer
 
-    def _convert_list_indexer(self, key, typ=None):
+    def _convert_list_indexer(self, key, kind=None):
         """ convert a list indexer. these should be locations """
         return key
 
-    def _convert_list_indexer_for_mixed(self, keyarr, typ=None):
+    def _convert_list_indexer_for_mixed(self, keyarr, kind=None):
         """ passed a key that is tuplesafe that is integer based
             and we have a mixed index (e.g. number/labels). figure out
             the indexer. return None if we can't help
         """
-        if (typ is None or typ in ['iloc','ix']) and (is_integer_dtype(keyarr) and not self.is_floating()):
+        if (kind is None or kind in ['iloc','ix']) and (is_integer_dtype(keyarr) and not self.is_floating()):
             if self.inferred_type != 'integer':
                 keyarr = np.where(keyarr < 0,
                                   len(self) + keyarr, keyarr)
@@ -793,10 +803,10 @@ class Index(IndexOpsMixin, PandasObject):
     def _invalid_indexer(self, form, key):
         """ consistent invalid indexer message """
         raise TypeError("cannot do {form} indexing on {klass} with these "
-                        "indexers [{key}] of {typ}".format(form=form,
+                        "indexers [{key}] of {kind}".format(form=form,
                                                            klass=type(self),
                                                            key=key,
-                                                           typ=type(key)))
+                                                           kind=type(key)))
 
     def get_duplicates(self):
         from collections import defaultdict
@@ -844,8 +854,8 @@ class Index(IndexOpsMixin, PandasObject):
         """ return a string of the type inferred from the values """
         return lib.infer_dtype(self)
 
-    def is_type_compatible(self, typ):
-        return typ == self.inferred_type
+    def is_type_compatible(self, kind):
+        return kind == self.inferred_type
 
     @cache_readonly
     def is_all_dates(self):
@@ -2082,7 +2092,7 @@ class Index(IndexOpsMixin, PandasObject):
         name = self.name if self.name == other.name else None
         return Index(joined, name=name)
 
-    def slice_indexer(self, start=None, end=None, step=None):
+    def slice_indexer(self, start=None, end=None, step=None, kind=None):
         """
         For an ordered Index, compute the slice indexer for input labels and
         step
@@ -2094,6 +2104,7 @@ class Index(IndexOpsMixin, PandasObject):
         end : label, default None
             If None, defaults to the end
         step : int, default None
+        kind : string, default None
 
         Returns
         -------
@@ -2103,7 +2114,7 @@ class Index(IndexOpsMixin, PandasObject):
         -----
         This function assumes that the data is sorted, so use at your own peril
         """
-        start_slice, end_slice = self.slice_locs(start, end, step=step)
+        start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)
 
         # return a slice
         if not lib.isscalar(start_slice):
@@ -2113,7 +2124,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         return slice(start_slice, end_slice, step)
 
-    def _maybe_cast_slice_bound(self, label, side):
+    def _maybe_cast_slice_bound(self, label, side, kind):
         """
         This function should be overloaded in subclasses that allow non-trivial
         casting on label-slice bounds, e.g. datetime-like indices allowing
@@ -2123,6 +2134,7 @@ class Index(IndexOpsMixin, PandasObject):
         ----------
         label : object
         side : {'left', 'right'}
+        kind : string / None
 
         Returns
         -------
@@ -2134,15 +2146,16 @@ class Index(IndexOpsMixin, PandasObject):
 
         """
 
-        # pass thru float indexers if we have a numeric type index
-        # which then can decide to process / or convert and warng
+        # We are a plain index here (sub-class override this method if they
+        # wish to have special treatment for floats/ints, e.g. Float64Index and
+        # datetimelike Indexes
+        # reject them
         if is_float(label):
-            if not (self.is_integer() or self.is_floating()):
-                self._invalid_indexer('slice',label)
+            self._invalid_indexer('slice',label)
 
-        # we are not an integer based index, and we have an integer label
-        # treat as positional based slicing semantics
-        if not self.is_integer() and is_integer(label):
+        # we are trying to find integer bounds on a non-integer based index
+        # this is rejected (generally .loc gets you here)
+        elif is_integer(label):
             self._invalid_indexer('slice',label)
 
         return label
@@ -2160,7 +2173,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         raise ValueError('index must be monotonic increasing or decreasing')
 
-    def get_slice_bound(self, label, side):
+    def get_slice_bound(self, label, side, kind):
         """
         Calculate slice bound that corresponds to given label.
 
@@ -2171,6 +2184,7 @@ class Index(IndexOpsMixin, PandasObject):
         ----------
         label : object
         side : {'left', 'right'}
+        kind : string / None, the type of indexer
 
         """
         if side not in ('left', 'right'):
@@ -2182,7 +2196,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         # For datetime indices label may be a string that has to be converted
         # to datetime boundary according to its resolution.
-        label = self._maybe_cast_slice_bound(label, side)
+        label = self._maybe_cast_slice_bound(label, side, kind)
 
         # we need to look up the label
         try:
@@ -2217,7 +2231,7 @@ class Index(IndexOpsMixin, PandasObject):
             else:
                 return slc
 
-    def slice_locs(self, start=None, end=None, step=None):
+    def slice_locs(self, start=None, end=None, step=None, kind=None):
         """
         Compute slice locations for input labels.
 
@@ -2227,6 +2241,9 @@ class Index(IndexOpsMixin, PandasObject):
             If None, defaults to the beginning
         end : label, default None
             If None, defaults to the end
+        step : int, defaults None
+            If None, defaults to 1
+        kind : string, defaults None
 
         Returns
         -------
@@ -2241,13 +2258,13 @@ class Index(IndexOpsMixin, PandasObject):
 
         start_slice = None
         if start is not None:
-            start_slice = self.get_slice_bound(start, 'left')
+            start_slice = self.get_slice_bound(start, 'left', kind)
         if start_slice is None:
             start_slice = 0
 
         end_slice = None
         if end is not None:
-            end_slice = self.get_slice_bound(end, 'right')
+            end_slice = self.get_slice_bound(end, 'right', kind)
         if end_slice is None:
             end_slice = len(self)
 
@@ -2504,6 +2521,35 @@ class NumericIndex(Index):
     """
     _is_numeric_dtype = True
 
+    def _maybe_cast_slice_bound(self, label, side, kind):
+        """
+        This function should be overloaded in subclasses that allow non-trivial
+        casting on label-slice bounds, e.g. datetime-like indices allowing
+        strings containing formatted datetimes.
+
+        Parameters
+        ----------
+        label : object
+        side : {'left', 'right'}
+        kind : string / None
+
+        Returns
+        -------
+        label :  object
+
+        Notes
+        -----
+        Value of `side` parameter should be validated in caller.
+
+        """
+
+        # we are a numeric index, so we accept
+        # integer/floats directly
+        if not (is_integer(label) or is_float(label)):
+            self._invalid_indexer('slice',label)
+
+        return label
+
 class Int64Index(NumericIndex):
 
     """
@@ -2677,52 +2723,30 @@ class Float64Index(NumericIndex):
                             self.__class__)
         return Index(self.values, name=self.name, dtype=dtype)
 
-    def _maybe_cast_slice_bound(self, label, side):
+    def _convert_scalar_indexer(self, key, kind=None):
+        if kind == 'iloc':
+            return super(Float64Index, self)._convert_scalar_indexer(key,
+                                                                     kind=kind)
+        return key
+
+    def _convert_slice_indexer(self, key, kind=None):
         """
-        This function should be overloaded in subclasses that allow non-trivial
-        casting on label-slice bounds, e.g. datetime-like indices allowing
-        strings containing formatted datetimes.
+        convert a slice indexer, by definition these are labels
+        unless we are iloc
 
         Parameters
         ----------
-        label : object
-        side : {'left', 'right'}
-
-        Returns
-        -------
-        label :  object
-
-        Notes
-        -----
-        Value of `side` parameter should be validated in caller.
-
+        key : label of the slice bound
+        kind : optional, type of the indexing operation (loc/ix/iloc/None)
         """
-        if not (is_integer(label) or is_float(label)):
-            self._invalid_indexer('slice',label)
-
-        return label
-
-    def _convert_scalar_indexer(self, key, typ=None):
-        if typ == 'iloc':
-            return super(Float64Index, self)._convert_scalar_indexer(key,
-                                                                     typ=typ)
-        return key
-
-    def _convert_slice_indexer(self, key, typ=None):
-        """ convert a slice indexer, by definition these are labels
-            unless we are iloc """
 
         # if we are not a slice, then we are done
         if not isinstance(key, slice):
             return key
 
-        if typ == 'iloc':
+        if kind == 'iloc':
             return super(Float64Index, self)._convert_slice_indexer(key,
-                                                                    typ=typ)
-
-        # allow floats here
-        validator = lambda v: v is None or is_integer(v) or is_float(v)
-        self._validate_slicer(key, validator)
+                                                                    kind=kind)
 
         # translate to locations
         return self.slice_indexer(key.start, key.stop, key.step)
@@ -4147,12 +4171,12 @@ class MultiIndex(Index):
         """
         return Index(self.values)
 
-    def get_slice_bound(self, label, side):
+    def get_slice_bound(self, label, side, kind):
         if not isinstance(label, tuple):
             label = label,
         return self._partial_tup_index(label, side=side)
 
-    def slice_locs(self, start=None, end=None, step=None):
+    def slice_locs(self, start=None, end=None, step=None, kind=None):
         """
         For an ordered MultiIndex, compute the slice locations for input
         labels. They can be tuples representing partial levels, e.g. for a
@@ -4167,6 +4191,7 @@ class MultiIndex(Index):
             If None, defaults to the end
         step : int or None
             Slice step
+        kind : string, optional, defaults None
 
         Returns
         -------
@@ -4178,7 +4203,7 @@ class MultiIndex(Index):
         """
         # This function adds nothing to its parent implementation (the magic
         # happens in get_slice_bound method), but it adds meaningful doc.
-        return super(MultiIndex, self).slice_locs(start, end, step)
+        return super(MultiIndex, self).slice_locs(start, end, step, kind=kind)
 
     def _partial_tup_index(self, tup, side='left'):
         if len(tup) > self.lexsort_depth:
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 2e953fed2..29fc1d1e4 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -91,8 +91,8 @@ class _NDFrameIndexer(object):
     def _get_loc(self, key, axis=0):
         return self.obj._ixs(key, axis=axis)
 
-    def _slice(self, obj, axis=0, typ=None):
-        return self.obj._slice(obj, axis=axis, typ=typ)
+    def _slice(self, obj, axis=0, kind=None):
+        return self.obj._slice(obj, axis=axis, kind=kind)
 
     def _get_setitem_indexer(self, key):
         if self.axis is not None:
@@ -163,12 +163,12 @@ class _NDFrameIndexer(object):
         # if we are accessing via lowered dim, use the last dim
         ax = self.obj._get_axis(min(axis, self.ndim - 1))
         # a scalar
-        return ax._convert_scalar_indexer(key, typ=self.name)
+        return ax._convert_scalar_indexer(key, kind=self.name)
 
     def _convert_slice_indexer(self, key, axis):
         # if we are accessing via lowered dim, use the last dim
         ax = self.obj._get_axis(min(axis, self.ndim - 1))
-        return ax._convert_slice_indexer(key, typ=self.name)
+        return ax._convert_slice_indexer(key, kind=self.name)
 
     def _has_valid_setitem_indexer(self, indexer):
         return True
@@ -960,7 +960,7 @@ class _NDFrameIndexer(object):
                 keyarr = _asarray_tuplesafe(key)
 
             # handle a mixed integer scenario
-            indexer = labels._convert_list_indexer_for_mixed(keyarr, typ=self.name)
+            indexer = labels._convert_list_indexer_for_mixed(keyarr, kind=self.name)
             if indexer is not None:
                 return self.obj.take(indexer, axis=axis)
 
@@ -1107,7 +1107,7 @@ class _NDFrameIndexer(object):
                     objarr = _asarray_tuplesafe(obj)
 
                 # If have integer labels, defer to label-based indexing
-                indexer = labels._convert_list_indexer_for_mixed(objarr, typ=self.name)
+                indexer = labels._convert_list_indexer_for_mixed(objarr, kind=self.name)
                 if indexer is not None:
                     return indexer
 
@@ -1163,7 +1163,7 @@ class _NDFrameIndexer(object):
         indexer = self._convert_slice_indexer(slice_obj, axis)
 
         if isinstance(indexer, slice):
-            return self._slice(indexer, axis=axis, typ='iloc')
+            return self._slice(indexer, axis=axis, kind='iloc')
         else:
             return self.obj.take(indexer, axis=axis, convert=False)
 
@@ -1221,7 +1221,7 @@ class _LocationIndexer(_NDFrameIndexer):
                                        slice_obj.step)
 
         if isinstance(indexer, slice):
-            return self._slice(indexer, axis=axis, typ='iloc')
+            return self._slice(indexer, axis=axis, kind='iloc')
         else:
             return self.obj.take(indexer, axis=axis, convert=False)
 
@@ -1412,7 +1412,7 @@ class _iLocIndexer(_LocationIndexer):
 
         slice_obj = self._convert_slice_indexer(slice_obj, axis)
         if isinstance(slice_obj, slice):
-            return self._slice(slice_obj, axis=axis, typ='iloc')
+            return self._slice(slice_obj, axis=axis, kind='iloc')
         else:
             return self.obj.take(slice_obj, axis=axis, convert=False)
 
@@ -1572,7 +1572,7 @@ def convert_to_index_sliceable(obj, key):
     """
     idx = obj.index
     if isinstance(key, slice):
-        return idx._convert_slice_indexer(key, typ='getitem')
+        return idx._convert_slice_indexer(key, kind='getitem')
 
     elif isinstance(key, compat.string_types):
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 77a5d61ad..036aca72c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -491,7 +491,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             raise
         except:
             if isinstance(i, slice):
-                indexer = self.index._convert_slice_indexer(i, typ='iloc')
+                indexer = self.index._convert_slice_indexer(i, kind='iloc')
                 return self._get_values(indexer)
             else:
                 label = self.index[i]
@@ -504,8 +504,8 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     def _is_mixed_type(self):
         return False
 
-    def _slice(self, slobj, axis=0, typ=None):
-        slobj = self.index._convert_slice_indexer(slobj, typ=typ or 'getitem')
+    def _slice(self, slobj, axis=0, kind=None):
+        slobj = self.index._convert_slice_indexer(slobj, kind=kind or 'getitem')
         return self._get_values(slobj)
 
     def __getitem__(self, key):
@@ -536,7 +536,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             else:
 
                 # we can try to coerce the indexer (or this will raise)
-                new_key = self.index._convert_scalar_indexer(key,typ='getitem')
+                new_key = self.index._convert_scalar_indexer(key,kind='getitem')
                 if type(new_key) != type(key):
                     return self.__getitem__(new_key)
                 raise
@@ -555,7 +555,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     def _get_with(self, key):
         # other: fancy integer or otherwise
         if isinstance(key, slice):
-            indexer = self.index._convert_slice_indexer(key, typ='getitem')
+            indexer = self.index._convert_slice_indexer(key, kind='getitem')
             return self._get_values(indexer)
         elif isinstance(key, ABCDataFrame):
             raise TypeError('Indexing a Series with DataFrame is not supported, '\
@@ -693,7 +693,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     def _set_with(self, key, value):
         # other: fancy integer or otherwise
         if isinstance(key, slice):
-            indexer = self.index._convert_slice_indexer(key, typ='getitem')
+            indexer = self.index._convert_slice_indexer(key, kind='getitem')
             return self._set_values(indexer, value)
         else:
             if isinstance(key, tuple):
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index 821720f40..30b06c8a9 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -378,7 +378,7 @@ class SparseDataFrame(DataFrame):
         return dense.to_sparse(kind=self._default_kind,
                                fill_value=self._default_fill_value)
 
-    def _slice(self, slobj, axis=0, typ=None):
+    def _slice(self, slobj, axis=0, kind=None):
         if axis == 0:
             new_index = self.index[slobj]
             new_columns = self.columns
diff --git a/pandas/sparse/panel.py b/pandas/sparse/panel.py
index ee9edbe36..d3f3f59f2 100644
--- a/pandas/sparse/panel.py
+++ b/pandas/sparse/panel.py
@@ -68,10 +68,10 @@ class SparsePanel(Panel):
     def __init__(self, frames=None, items=None, major_axis=None, minor_axis=None,
                  default_fill_value=np.nan, default_kind='block',
                  copy=False):
-                 
+
         if frames is None:
             frames = {}
-            
+
         if isinstance(frames, np.ndarray):
             new_frames = {}
             for item, vals in zip(items, frames):
@@ -191,7 +191,7 @@ class SparsePanel(Panel):
 
         return self.xs(key, axis=axis)
 
-    def _slice(self, slobj, axis=0, typ=None):
+    def _slice(self, slobj, axis=0, kind=None):
         """
         for compat as we don't support Block Manager here
         """
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index b8650683a..bdf2b43d7 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -1001,8 +1001,8 @@ class TestIndexing(tm.TestCase):
         self.check_result('lab slice', 'loc', slice('W','Z'), 'ix', slice('W','Z'), typs = ['labels'], axes=2)
 
         self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=0)
-        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1, fails=KeyError)
-        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2, fails=KeyError)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1, fails=TypeError)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2, fails=TypeError)
 
         self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=0, fails=TypeError)
         self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=1, fails=KeyError)
diff --git a/pandas/tseries/base.py b/pandas/tseries/base.py
index 9664cef52..048a9ff4b 100644
--- a/pandas/tseries/base.py
+++ b/pandas/tseries/base.py
@@ -298,12 +298,20 @@ class DatetimeIndexOpsMixin(object):
         from pandas.tseries.frequencies import get_reso_string
         return get_reso_string(self._resolution)
 
-    def _convert_scalar_indexer(self, key, typ=None):
-        """ we don't allow integer or float indexing on datetime-like when using loc """
-        if typ in ['loc'] and lib.isscalar(key) and (is_integer(key) or is_float(key)):
+    def _convert_scalar_indexer(self, key, kind=None):
+        """
+        we don't allow integer or float indexing on datetime-like when using loc
+
+        Parameters
+        ----------
+        key : label of the slice bound
+        kind : optional, type of the indexing operation (loc/ix/iloc/None)
+        """
+
+        if kind in ['loc'] and lib.isscalar(key) and (is_integer(key) or is_float(key)):
             self._invalid_indexer('index',key)
 
-        return super(DatetimeIndexOpsMixin, self)._convert_scalar_indexer(key, typ=typ)
+        return super(DatetimeIndexOpsMixin, self)._convert_scalar_indexer(key, kind=kind)
 
     def _add_datelike(self, other):
         raise NotImplementedError
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index f733a7183..24d12078f 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -1262,7 +1262,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
             except (KeyError, ValueError):
                 raise KeyError(key)
 
-    def _maybe_cast_slice_bound(self, label, side):
+    def _maybe_cast_slice_bound(self, label, side, kind):
         """
         If label is a string, cast it to datetime according to resolution.
 
@@ -1270,6 +1270,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         ----------
         label : object
         side : {'left', 'right'}
+        kind : string / None
 
         Returns
         -------
@@ -1300,7 +1301,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
                                        use_rhs=use_rhs)
         return loc
 
-    def slice_indexer(self, start=None, end=None, step=None):
+    def slice_indexer(self, start=None, end=None, step=None, kind=None):
         """
         Return indexer for specified label slice.
         Index.slice_indexer, customized to handle time slicing.
@@ -1335,11 +1336,11 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
                 (end is None or isinstance(end, compat.string_types))):
                 mask = True
                 if start is not None:
-                    start_casted = self._maybe_cast_slice_bound(start, 'left')
+                    start_casted = self._maybe_cast_slice_bound(start, 'left', kind)
                     mask = start_casted <= self
 
                 if end is not None:
-                    end_casted = self._maybe_cast_slice_bound(end, 'right')
+                    end_casted = self._maybe_cast_slice_bound(end, 'right', kind)
                     mask = (self <= end_casted) & mask
 
                 indexer = mask.nonzero()[0][::step]
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 95bbf3825..1a2381441 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -549,7 +549,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
             except KeyError:
                 raise KeyError(key)
 
-    def _maybe_cast_slice_bound(self, label, side):
+    def _maybe_cast_slice_bound(self, label, side, kind):
         """
         If label is a string or a datetime, cast it to Period.ordinal according to
         resolution.
@@ -558,6 +558,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         ----------
         label : object
         side : {'left', 'right'}
+        kind : string / None
 
         Returns
         -------
diff --git a/pandas/tseries/tdi.py b/pandas/tseries/tdi.py
index 4e86bf9d9..e01ff54fe 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/tseries/tdi.py
@@ -675,7 +675,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
             except (KeyError, ValueError):
                 raise KeyError(key)
 
-    def _maybe_cast_slice_bound(self, label, side):
+    def _maybe_cast_slice_bound(self, label, side, kind):
         """
         If label is a string, cast it to timedelta according to resolution.
 
@@ -684,6 +684,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
         ----------
         label : object
         side : {'left', 'right'}
+        kind : string / None
 
         Returns
         -------

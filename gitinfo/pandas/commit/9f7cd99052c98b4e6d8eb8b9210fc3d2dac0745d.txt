commit 9f7cd99052c98b4e6d8eb8b9210fc3d2dac0745d
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Feb 22 07:40:54 2020 -0800

    REF/TST: collect Index join tests (#32171)

diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 4d0beecbb..d33351fe9 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -759,17 +759,6 @@ class TestBusinessDateRange:
         with pytest.raises(TypeError, match=msg):
             bdate_range(START, END, periods=10, freq=None)
 
-    def test_naive_aware_conflicts(self):
-        naive = bdate_range(START, END, freq=BDay(), tz=None)
-        aware = bdate_range(START, END, freq=BDay(), tz="Asia/Hong_Kong")
-
-        msg = "tz-naive.*tz-aware"
-        with pytest.raises(TypeError, match=msg):
-            naive.join(aware)
-
-        with pytest.raises(TypeError, match=msg):
-            aware.join(naive)
-
     def test_misc(self):
         end = datetime(2009, 5, 13)
         dr = bdate_range(end=end, periods=20)
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index ca18d6fbe..1a72ef2bd 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -100,16 +100,13 @@ class TestDatetimeIndex:
         df = DataFrame(np.arange(10), index=idx)
         df["2013-01-14 23:44:34.437768-05:00":]  # no exception here
 
-    def test_append_join_nondatetimeindex(self):
+    def test_append_nondatetimeindex(self):
         rng = date_range("1/1/2000", periods=10)
         idx = Index(["a", "b", "c", "d"])
 
         result = rng.append(idx)
         assert isinstance(result[0], Timestamp)
 
-        # it works
-        rng.join(idx, how="outer")
-
     def test_map(self):
         rng = date_range("1/1/2000", periods=10)
 
@@ -246,25 +243,6 @@ class TestDatetimeIndex:
             index.isin([index[2], 5]), np.array([False, False, True, False])
         )
 
-    def test_does_not_convert_mixed_integer(self):
-        df = tm.makeCustomDataframe(
-            10,
-            10,
-            data_gen_f=lambda *args, **kwargs: randn(),
-            r_idx_type="i",
-            c_idx_type="dt",
-        )
-        cols = df.columns.join(df.index, how="outer")
-        joined = cols.join(df.columns)
-        assert cols.dtype == np.dtype("O")
-        assert cols.dtype == joined.dtype
-        tm.assert_numpy_array_equal(cols.values, joined.values)
-
-    def test_join_self(self, join_type):
-        index = date_range("1/1/2000", periods=10)
-        joined = index.join(index, how=join_type)
-        assert index is joined
-
     def assert_index_parameters(self, index):
         assert index.freq == "40960N"
         assert index.inferred_freq == "40960N"
@@ -282,20 +260,6 @@ class TestDatetimeIndex:
         new_index = pd.date_range(start=index[0], end=index[-1], freq=index.freq)
         self.assert_index_parameters(new_index)
 
-    def test_join_with_period_index(self, join_type):
-        df = tm.makeCustomDataframe(
-            10,
-            10,
-            data_gen_f=lambda *args: np.random.randint(2),
-            c_idx_type="p",
-            r_idx_type="dt",
-        )
-        s = df.iloc[:5, 0]
-
-        expected = df.columns.astype("O").join(s.index, how=join_type)
-        result = df.columns.join(s.index, how=join_type)
-        tm.assert_index_equal(expected, result)
-
     def test_factorize(self):
         idx1 = DatetimeIndex(
             ["2014-01", "2014-01", "2014-02", "2014-02", "2014-03", "2014-03"]
diff --git a/pandas/tests/indexes/datetimes/test_join.py b/pandas/tests/indexes/datetimes/test_join.py
new file mode 100644
index 000000000..e4d6958db
--- /dev/null
+++ b/pandas/tests/indexes/datetimes/test_join.py
@@ -0,0 +1,131 @@
+from datetime import datetime
+
+import numpy as np
+import pytest
+
+from pandas import DatetimeIndex, Index, Timestamp, date_range, to_datetime
+import pandas._testing as tm
+
+from pandas.tseries.offsets import BDay, BMonthEnd
+
+
+class TestJoin:
+    def test_does_not_convert_mixed_integer(self):
+        df = tm.makeCustomDataframe(
+            10,
+            10,
+            data_gen_f=lambda *args, **kwargs: np.random.randn(),
+            r_idx_type="i",
+            c_idx_type="dt",
+        )
+        cols = df.columns.join(df.index, how="outer")
+        joined = cols.join(df.columns)
+        assert cols.dtype == np.dtype("O")
+        assert cols.dtype == joined.dtype
+        tm.assert_numpy_array_equal(cols.values, joined.values)
+
+    def test_join_self(self, join_type):
+        index = date_range("1/1/2000", periods=10)
+        joined = index.join(index, how=join_type)
+        assert index is joined
+
+    def test_join_with_period_index(self, join_type):
+        df = tm.makeCustomDataframe(
+            10,
+            10,
+            data_gen_f=lambda *args: np.random.randint(2),
+            c_idx_type="p",
+            r_idx_type="dt",
+        )
+        s = df.iloc[:5, 0]
+
+        expected = df.columns.astype("O").join(s.index, how=join_type)
+        result = df.columns.join(s.index, how=join_type)
+        tm.assert_index_equal(expected, result)
+
+    def test_join_object_index(self):
+        rng = date_range("1/1/2000", periods=10)
+        idx = Index(["a", "b", "c", "d"])
+
+        result = rng.join(idx, how="outer")
+        assert isinstance(result[0], Timestamp)
+
+    def test_join_utc_convert(self, join_type):
+        rng = date_range("1/1/2011", periods=100, freq="H", tz="utc")
+
+        left = rng.tz_convert("US/Eastern")
+        right = rng.tz_convert("Europe/Berlin")
+
+        result = left.join(left[:-5], how=join_type)
+        assert isinstance(result, DatetimeIndex)
+        assert result.tz == left.tz
+
+        result = left.join(right[:-5], how=join_type)
+        assert isinstance(result, DatetimeIndex)
+        assert result.tz.zone == "UTC"
+
+    @pytest.mark.parametrize("sort", [None, False])
+    def test_datetimeindex_union_join_empty(self, sort):
+        dti = date_range(start="1/1/2001", end="2/1/2001", freq="D")
+        empty = Index([])
+
+        result = dti.union(empty, sort=sort)
+        expected = dti.astype("O")
+        tm.assert_index_equal(result, expected)
+
+        result = dti.join(empty)
+        assert isinstance(result, DatetimeIndex)
+        tm.assert_index_equal(result, dti)
+
+    def test_join_nonunique(self):
+        idx1 = to_datetime(["2012-11-06 16:00:11.477563", "2012-11-06 16:00:11.477563"])
+        idx2 = to_datetime(["2012-11-06 15:11:09.006507", "2012-11-06 15:11:09.006507"])
+        rs = idx1.join(idx2, how="outer")
+        assert rs.is_monotonic
+
+    @pytest.mark.parametrize("freq", ["B", "C"])
+    def test_outer_join(self, freq):
+        # should just behave as union
+        start, end = datetime(2009, 1, 1), datetime(2010, 1, 1)
+        rng = date_range(start=start, end=end, freq=freq)
+
+        # overlapping
+        left = rng[:10]
+        right = rng[5:10]
+
+        the_join = left.join(right, how="outer")
+        assert isinstance(the_join, DatetimeIndex)
+
+        # non-overlapping, gap in middle
+        left = rng[:5]
+        right = rng[10:]
+
+        the_join = left.join(right, how="outer")
+        assert isinstance(the_join, DatetimeIndex)
+        assert the_join.freq is None
+
+        # non-overlapping, no gap
+        left = rng[:5]
+        right = rng[5:10]
+
+        the_join = left.join(right, how="outer")
+        assert isinstance(the_join, DatetimeIndex)
+
+        # overlapping, but different offset
+        other = date_range(start, end, freq=BMonthEnd())
+
+        the_join = rng.join(other, how="outer")
+        assert isinstance(the_join, DatetimeIndex)
+        assert the_join.freq is None
+
+    def test_naive_aware_conflicts(self):
+        start, end = datetime(2009, 1, 1), datetime(2010, 1, 1)
+        naive = date_range(start, end, freq=BDay(), tz=None)
+        aware = date_range(start, end, freq=BDay(), tz="Asia/Hong_Kong")
+
+        msg = "tz-naive.*tz-aware"
+        with pytest.raises(TypeError, match=msg):
+            naive.join(aware)
+
+        with pytest.raises(TypeError, match=msg):
+            aware.join(naive)
diff --git a/pandas/tests/indexes/datetimes/test_setops.py b/pandas/tests/indexes/datetimes/test_setops.py
index 78188c54b..d58ecbad4 100644
--- a/pandas/tests/indexes/datetimes/test_setops.py
+++ b/pandas/tests/indexes/datetimes/test_setops.py
@@ -14,7 +14,6 @@ from pandas import (
     Series,
     bdate_range,
     date_range,
-    to_datetime,
 )
 import pandas._testing as tm
 
@@ -348,25 +347,6 @@ class TestDatetimeIndexSetOps:
         dti2 = date_range(freq="Q-JAN", start=datetime(1997, 12, 31), periods=98)
         assert len(dti1.difference(dti2, sort)) == 2
 
-    @pytest.mark.parametrize("sort", [None, False])
-    def test_datetimeindex_union_join_empty(self, sort):
-        dti = date_range(start="1/1/2001", end="2/1/2001", freq="D")
-        empty = Index([])
-
-        result = dti.union(empty, sort=sort)
-        expected = dti.astype("O")
-        tm.assert_index_equal(result, expected)
-
-        result = dti.join(empty)
-        assert isinstance(result, DatetimeIndex)
-        tm.assert_index_equal(result, dti)
-
-    def test_join_nonunique(self):
-        idx1 = to_datetime(["2012-11-06 16:00:11.477563", "2012-11-06 16:00:11.477563"])
-        idx2 = to_datetime(["2012-11-06 15:11:09.006507", "2012-11-06 15:11:09.006507"])
-        rs = idx1.join(idx2, how="outer")
-        assert rs.is_monotonic
-
 
 class TestBusinessDatetimeIndex:
     def setup_method(self, method):
@@ -408,38 +388,6 @@ class TestBusinessDatetimeIndex:
         the_union = self.rng.union(rng, sort=sort)
         assert isinstance(the_union, DatetimeIndex)
 
-    def test_outer_join(self):
-        # should just behave as union
-
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-        assert the_join.freq is None
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_join = self.rng.join(rng, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-        assert the_join.freq is None
-
     @pytest.mark.parametrize("sort", [None, False])
     def test_union_not_cacheable(self, sort):
         rng = date_range("1/1/2000", periods=50, freq=Minute())
@@ -556,38 +504,6 @@ class TestCustomDatetimeIndex:
         the_union = self.rng.union(rng, sort=sort)
         assert isinstance(the_union, DatetimeIndex)
 
-    def test_outer_join(self):
-        # should just behave as union
-
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-        assert the_join.freq is None
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_join = self.rng.join(rng, how="outer")
-        assert isinstance(the_join, DatetimeIndex)
-        assert the_join.freq is None
-
     def test_intersection_bug(self):
         # GH #771
         a = bdate_range("11/30/2011", "12/31/2011", freq="C")
diff --git a/pandas/tests/indexes/datetimes/test_timezones.py b/pandas/tests/indexes/datetimes/test_timezones.py
index 7574e4501..9c1e8cb0f 100644
--- a/pandas/tests/indexes/datetimes/test_timezones.py
+++ b/pandas/tests/indexes/datetimes/test_timezones.py
@@ -804,20 +804,6 @@ class TestDatetimeIndexTimezones:
     # -------------------------------------------------------------
     # Unsorted
 
-    def test_join_utc_convert(self, join_type):
-        rng = date_range("1/1/2011", periods=100, freq="H", tz="utc")
-
-        left = rng.tz_convert("US/Eastern")
-        right = rng.tz_convert("Europe/Berlin")
-
-        result = left.join(left[:-5], how=join_type)
-        assert isinstance(result, DatetimeIndex)
-        assert result.tz == left.tz
-
-        result = left.join(right[:-5], how=join_type)
-        assert isinstance(result, DatetimeIndex)
-        assert result.tz.zone == "UTC"
-
     @pytest.mark.parametrize(
         "dtype",
         [None, "datetime64[ns, CET]", "datetime64[ns, EST]", "datetime64[ns, UTC]"],
diff --git a/pandas/tests/indexes/numeric/__init__.py b/pandas/tests/indexes/numeric/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/indexes/numeric/test_join.py b/pandas/tests/indexes/numeric/test_join.py
new file mode 100644
index 000000000..c8dffa411
--- /dev/null
+++ b/pandas/tests/indexes/numeric/test_join.py
@@ -0,0 +1,388 @@
+import numpy as np
+import pytest
+
+from pandas import Index, Int64Index, UInt64Index
+import pandas._testing as tm
+
+
+class TestJoinInt64Index:
+    def test_join_non_unique(self):
+        left = Index([4, 4, 3, 3])
+
+        joined, lidx, ridx = left.join(left, return_indexers=True)
+
+        exp_joined = Index([3, 3, 3, 3, 4, 4, 4, 4])
+        tm.assert_index_equal(joined, exp_joined)
+
+        exp_lidx = np.array([2, 2, 3, 3, 0, 0, 1, 1], dtype=np.intp)
+        tm.assert_numpy_array_equal(lidx, exp_lidx)
+
+        exp_ridx = np.array([2, 3, 2, 3, 0, 1, 0, 1], dtype=np.intp)
+        tm.assert_numpy_array_equal(ridx, exp_ridx)
+
+    def test_join_inner(self):
+        index = Int64Index(range(0, 20, 2))
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
+
+        # no guarantee of sortedness, so sort for comparison purposes
+        ind = res.argsort()
+        res = res.take(ind)
+        lidx = lidx.take(ind)
+        ridx = ridx.take(ind)
+
+        eres = Int64Index([2, 12])
+        elidx = np.array([1, 6], dtype=np.intp)
+        eridx = np.array([4, 1], dtype=np.intp)
+
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index.join(other_mono, how="inner", return_indexers=True)
+
+        res2 = index.intersection(other_mono)
+        tm.assert_index_equal(res, res2)
+
+        elidx = np.array([1, 6], dtype=np.intp)
+        eridx = np.array([1, 4], dtype=np.intp)
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_left(self):
+        index = Int64Index(range(0, 20, 2))
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
+        eres = index
+        eridx = np.array([-1, 4, -1, -1, -1, -1, 1, -1, -1, -1], dtype=np.intp)
+
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index.join(other_mono, how="left", return_indexers=True)
+        eridx = np.array([-1, 1, -1, -1, -1, -1, 4, -1, -1, -1], dtype=np.intp)
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # non-unique
+        idx = Index([1, 1, 2, 5])
+        idx2 = Index([1, 2, 5, 7, 9])
+        res, lidx, ridx = idx2.join(idx, how="left", return_indexers=True)
+        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2
+        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
+        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_right(self):
+        index = Int64Index(range(0, 20, 2))
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
+        eres = other
+        elidx = np.array([-1, 6, -1, -1, 1, -1], dtype=np.intp)
+
+        assert isinstance(other, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        assert ridx is None
+
+        # monotonic
+        res, lidx, ridx = index.join(other_mono, how="right", return_indexers=True)
+        eres = other_mono
+        elidx = np.array([-1, 1, -1, -1, 6, -1], dtype=np.intp)
+        assert isinstance(other, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        assert ridx is None
+
+        # non-unique
+        idx = Index([1, 1, 2, 5])
+        idx2 = Index([1, 2, 5, 7, 9])
+        res, lidx, ridx = idx.join(idx2, how="right", return_indexers=True)
+        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2
+        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
+        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_non_int_index(self):
+        index = Int64Index(range(0, 20, 2))
+        other = Index([3, 6, 7, 8, 10], dtype=object)
+
+        outer = index.join(other, how="outer")
+        outer2 = other.join(index, how="outer")
+        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
+        tm.assert_index_equal(outer, outer2)
+        tm.assert_index_equal(outer, expected)
+
+        inner = index.join(other, how="inner")
+        inner2 = other.join(index, how="inner")
+        expected = Index([6, 8, 10])
+        tm.assert_index_equal(inner, inner2)
+        tm.assert_index_equal(inner, expected)
+
+        left = index.join(other, how="left")
+        tm.assert_index_equal(left, index.astype(object))
+
+        left2 = other.join(index, how="left")
+        tm.assert_index_equal(left2, other)
+
+        right = index.join(other, how="right")
+        tm.assert_index_equal(right, other)
+
+        right2 = other.join(index, how="right")
+        tm.assert_index_equal(right2, index.astype(object))
+
+    def test_join_outer(self):
+        index = Int64Index(range(0, 20, 2))
+        other = Int64Index([7, 12, 25, 1, 2, 5])
+        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
+
+        # not monotonic
+        # guarantee of sortedness
+        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
+        noidx_res = index.join(other, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        eres = Int64Index([0, 1, 2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 25])
+        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)
+        eridx = np.array(
+            [-1, 3, 4, -1, 5, -1, 0, -1, -1, 1, -1, -1, -1, 2], dtype=np.intp
+        )
+
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index.join(other_mono, how="outer", return_indexers=True)
+        noidx_res = index.join(other_mono, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)
+        eridx = np.array(
+            [-1, 0, 1, -1, 2, -1, 3, -1, -1, 4, -1, -1, -1, 5], dtype=np.intp
+        )
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+
+class TestJoinUInt64Index:
+    @pytest.fixture
+    def index_large(self):
+        # large values used in TestUInt64Index where no compat needed with Int64/Float64
+        large = [2 ** 63, 2 ** 63 + 10, 2 ** 63 + 15, 2 ** 63 + 20, 2 ** 63 + 25]
+        return UInt64Index(large)
+
+    def test_join_inner(self, index_large):
+        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
+        other_mono = UInt64Index(
+            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
+        )
+
+        # not monotonic
+        res, lidx, ridx = index_large.join(other, how="inner", return_indexers=True)
+
+        # no guarantee of sortedness, so sort for comparison purposes
+        ind = res.argsort()
+        res = res.take(ind)
+        lidx = lidx.take(ind)
+        ridx = ridx.take(ind)
+
+        eres = UInt64Index(2 ** 63 + np.array([10, 25], dtype="uint64"))
+        elidx = np.array([1, 4], dtype=np.intp)
+        eridx = np.array([5, 2], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index_large.join(
+            other_mono, how="inner", return_indexers=True
+        )
+
+        res2 = index_large.intersection(other_mono)
+        tm.assert_index_equal(res, res2)
+
+        elidx = np.array([1, 4], dtype=np.intp)
+        eridx = np.array([3, 5], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_left(self, index_large):
+        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
+        other_mono = UInt64Index(
+            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
+        )
+
+        # not monotonic
+        res, lidx, ridx = index_large.join(other, how="left", return_indexers=True)
+        eres = index_large
+        eridx = np.array([-1, 5, -1, -1, 2], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index_large.join(other_mono, how="left", return_indexers=True)
+        eridx = np.array([-1, 3, -1, -1, 5], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # non-unique
+        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype="uint64"))
+        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype="uint64"))
+        res, lidx, ridx = idx2.join(idx, how="left", return_indexers=True)
+
+        # 1 is in idx2, so it should be x2
+        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype="uint64"))
+        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
+        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
+
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_right(self, index_large):
+        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
+        other_mono = UInt64Index(
+            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
+        )
+
+        # not monotonic
+        res, lidx, ridx = index_large.join(other, how="right", return_indexers=True)
+        eres = other
+        elidx = np.array([-1, -1, 4, -1, -1, 1], dtype=np.intp)
+
+        tm.assert_numpy_array_equal(lidx, elidx)
+        assert isinstance(other, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        assert ridx is None
+
+        # monotonic
+        res, lidx, ridx = index_large.join(
+            other_mono, how="right", return_indexers=True
+        )
+        eres = other_mono
+        elidx = np.array([-1, -1, -1, 1, -1, 4], dtype=np.intp)
+
+        assert isinstance(other, UInt64Index)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_index_equal(res, eres)
+        assert ridx is None
+
+        # non-unique
+        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype="uint64"))
+        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype="uint64"))
+        res, lidx, ridx = idx.join(idx2, how="right", return_indexers=True)
+
+        # 1 is in idx2, so it should be x2
+        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype="uint64"))
+        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
+        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
+
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_non_int_index(self, index_large):
+        other = Index(
+            2 ** 63 + np.array([1, 5, 7, 10, 20], dtype="uint64"), dtype=object
+        )
+
+        outer = index_large.join(other, how="outer")
+        outer2 = other.join(index_large, how="outer")
+        expected = Index(
+            2 ** 63 + np.array([0, 1, 5, 7, 10, 15, 20, 25], dtype="uint64")
+        )
+        tm.assert_index_equal(outer, outer2)
+        tm.assert_index_equal(outer, expected)
+
+        inner = index_large.join(other, how="inner")
+        inner2 = other.join(index_large, how="inner")
+        expected = Index(2 ** 63 + np.array([10, 20], dtype="uint64"))
+        tm.assert_index_equal(inner, inner2)
+        tm.assert_index_equal(inner, expected)
+
+        left = index_large.join(other, how="left")
+        tm.assert_index_equal(left, index_large.astype(object))
+
+        left2 = other.join(index_large, how="left")
+        tm.assert_index_equal(left2, other)
+
+        right = index_large.join(other, how="right")
+        tm.assert_index_equal(right, other)
+
+        right2 = other.join(index_large, how="right")
+        tm.assert_index_equal(right2, index_large.astype(object))
+
+    def test_join_outer(self, index_large):
+        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
+        other_mono = UInt64Index(
+            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
+        )
+
+        # not monotonic
+        # guarantee of sortedness
+        res, lidx, ridx = index_large.join(other, how="outer", return_indexers=True)
+        noidx_res = index_large.join(other, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        eres = UInt64Index(
+            2 ** 63 + np.array([0, 1, 2, 7, 10, 12, 15, 20, 25], dtype="uint64")
+        )
+        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)
+        eridx = np.array([-1, 3, 4, 0, 5, 1, -1, -1, 2], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # monotonic
+        res, lidx, ridx = index_large.join(
+            other_mono, how="outer", return_indexers=True
+        )
+        noidx_res = index_large.join(other_mono, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)
+        eridx = np.array([-1, 0, 1, 2, 3, 4, -1, -1, 5], dtype=np.intp)
+
+        assert isinstance(res, UInt64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
diff --git a/pandas/tests/indexes/period/test_join.py b/pandas/tests/indexes/period/test_join.py
new file mode 100644
index 000000000..9e3df0c32
--- /dev/null
+++ b/pandas/tests/indexes/period/test_join.py
@@ -0,0 +1,43 @@
+import numpy as np
+import pytest
+
+from pandas._libs.tslibs import IncompatibleFrequency
+
+from pandas import Index, PeriodIndex, period_range
+import pandas._testing as tm
+
+
+class TestJoin:
+    def test_joins(self, join_type):
+        index = period_range("1/1/2000", "1/20/2000", freq="D")
+
+        joined = index.join(index[:-5], how=join_type)
+
+        assert isinstance(joined, PeriodIndex)
+        assert joined.freq == index.freq
+
+    def test_join_self(self, join_type):
+        index = period_range("1/1/2000", "1/20/2000", freq="D")
+
+        res = index.join(index, how=join_type)
+        assert index is res
+
+    def test_join_does_not_recur(self):
+        df = tm.makeCustomDataframe(
+            3,
+            2,
+            data_gen_f=lambda *args: np.random.randint(2),
+            c_idx_type="p",
+            r_idx_type="dt",
+        )
+        s = df.iloc[:2, 0]
+
+        res = s.index.join(df.columns, how="outer")
+        expected = Index([s.index[0], s.index[1], df.columns[0], df.columns[1]], object)
+        tm.assert_index_equal(res, expected)
+
+    def test_join_mismatched_freq_raises(self):
+        index = period_range("1/1/2000", "1/20/2000", freq="D")
+        index3 = period_range("1/1/2000", "1/20/2000", freq="2D")
+        with pytest.raises(IncompatibleFrequency):
+            index.join(index3)
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 4db93e850..6479b14e9 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -586,11 +586,6 @@ class TestPeriodIndex(DatetimeLike):
         exp = Index([x.ordinal for x in index])
         tm.assert_index_equal(result, exp)
 
-    def test_join_self(self, join_type):
-        index = period_range("1/1/2000", periods=10)
-        joined = index.join(index, how=join_type)
-        assert index is joined
-
     def test_insert(self):
         # GH 18295 (test missing)
         expected = PeriodIndex(["2017Q1", NaT, "2017Q2", "2017Q3", "2017Q4"], freq="Q")
diff --git a/pandas/tests/indexes/period/test_setops.py b/pandas/tests/indexes/period/test_setops.py
index 6f254b7b4..647d56d33 100644
--- a/pandas/tests/indexes/period/test_setops.py
+++ b/pandas/tests/indexes/period/test_setops.py
@@ -4,7 +4,7 @@ import pytest
 from pandas._libs.tslibs import IncompatibleFrequency
 
 import pandas as pd
-from pandas import Index, PeriodIndex, date_range, period_range
+from pandas import PeriodIndex, date_range, period_range
 import pandas._testing as tm
 
 
@@ -13,34 +13,6 @@ def _permute(obj):
 
 
 class TestPeriodIndex:
-    def test_joins(self, join_type):
-        index = period_range("1/1/2000", "1/20/2000", freq="D")
-
-        joined = index.join(index[:-5], how=join_type)
-
-        assert isinstance(joined, PeriodIndex)
-        assert joined.freq == index.freq
-
-    def test_join_self(self, join_type):
-        index = period_range("1/1/2000", "1/20/2000", freq="D")
-
-        res = index.join(index, how=join_type)
-        assert index is res
-
-    def test_join_does_not_recur(self):
-        df = tm.makeCustomDataframe(
-            3,
-            2,
-            data_gen_f=lambda *args: np.random.randint(2),
-            c_idx_type="p",
-            r_idx_type="dt",
-        )
-        s = df.iloc[:2, 0]
-
-        res = s.index.join(df.columns, how="outer")
-        expected = Index([s.index[0], s.index[1], df.columns[0], df.columns[1]], object)
-        tm.assert_index_equal(res, expected)
-
     @pytest.mark.parametrize("sort", [None, False])
     def test_union(self, sort):
         # union
@@ -181,10 +153,6 @@ class TestPeriodIndex:
         with pytest.raises(IncompatibleFrequency):
             index.union(index2, sort=sort)
 
-        index3 = period_range("1/1/2000", "1/20/2000", freq="2D")
-        with pytest.raises(IncompatibleFrequency):
-            index.join(index3)
-
     # TODO: belongs elsewhere
     def test_union_dataframe_index(self):
         rng1 = period_range("1/1/1999", "1/1/2012", freq="M")
diff --git a/pandas/tests/indexes/ranges/test_join.py b/pandas/tests/indexes/ranges/test_join.py
new file mode 100644
index 000000000..76013d2b7
--- /dev/null
+++ b/pandas/tests/indexes/ranges/test_join.py
@@ -0,0 +1,174 @@
+import numpy as np
+
+from pandas import Index, Int64Index, RangeIndex
+import pandas._testing as tm
+
+
+class TestJoin:
+    def test_join_outer(self):
+        # join with Int64Index
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Int64Index(np.arange(25, 14, -1))
+
+        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
+        noidx_res = index.join(other, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        eres = Int64Index(
+            [0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
+        )
+        elidx = np.array(
+            [0, 1, 2, 3, 4, 5, 6, 7, -1, 8, -1, 9, -1, -1, -1, -1, -1, -1, -1],
+            dtype=np.intp,
+        )
+        eridx = np.array(
+            [-1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],
+            dtype=np.intp,
+        )
+
+        assert isinstance(res, Int64Index)
+        assert not isinstance(res, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # join with RangeIndex
+        other = RangeIndex(25, 14, -1)
+
+        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
+        noidx_res = index.join(other, how="outer")
+        tm.assert_index_equal(res, noidx_res)
+
+        assert isinstance(res, Int64Index)
+        assert not isinstance(res, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_inner(self):
+        # Join with non-RangeIndex
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Int64Index(np.arange(25, 14, -1))
+
+        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
+
+        # no guarantee of sortedness, so sort for comparison purposes
+        ind = res.argsort()
+        res = res.take(ind)
+        lidx = lidx.take(ind)
+        ridx = ridx.take(ind)
+
+        eres = Int64Index([16, 18])
+        elidx = np.array([8, 9], dtype=np.intp)
+        eridx = np.array([9, 7], dtype=np.intp)
+
+        assert isinstance(res, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # Join two RangeIndex
+        other = RangeIndex(25, 14, -1)
+
+        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
+
+        assert isinstance(res, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_left(self):
+        # Join with Int64Index
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Int64Index(np.arange(25, 14, -1))
+
+        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
+        eres = index
+        eridx = np.array([-1, -1, -1, -1, -1, -1, -1, -1, 9, 7], dtype=np.intp)
+
+        assert isinstance(res, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+        # Join withRangeIndex
+        other = Int64Index(np.arange(25, 14, -1))
+
+        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
+
+        assert isinstance(res, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        assert lidx is None
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_right(self):
+        # Join with Int64Index
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Int64Index(np.arange(25, 14, -1))
+
+        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
+        eres = other
+        elidx = np.array([-1, -1, -1, -1, -1, -1, -1, 9, -1, 8, -1], dtype=np.intp)
+
+        assert isinstance(other, Int64Index)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        assert ridx is None
+
+        # Join withRangeIndex
+        other = RangeIndex(25, 14, -1)
+
+        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
+        eres = other
+
+        assert isinstance(other, RangeIndex)
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        assert ridx is None
+
+    def test_join_non_int_index(self):
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Index([3, 6, 7, 8, 10], dtype=object)
+
+        outer = index.join(other, how="outer")
+        outer2 = other.join(index, how="outer")
+        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
+        tm.assert_index_equal(outer, outer2)
+        tm.assert_index_equal(outer, expected)
+
+        inner = index.join(other, how="inner")
+        inner2 = other.join(index, how="inner")
+        expected = Index([6, 8, 10])
+        tm.assert_index_equal(inner, inner2)
+        tm.assert_index_equal(inner, expected)
+
+        left = index.join(other, how="left")
+        tm.assert_index_equal(left, index.astype(object))
+
+        left2 = other.join(index, how="left")
+        tm.assert_index_equal(left2, other)
+
+        right = index.join(other, how="right")
+        tm.assert_index_equal(right, other)
+
+        right2 = other.join(index, how="right")
+        tm.assert_index_equal(right2, index.astype(object))
+
+    def test_join_non_unique(self):
+        index = RangeIndex(start=0, stop=20, step=2)
+        other = Index([4, 4, 3, 3])
+
+        res, lidx, ridx = index.join(other, return_indexers=True)
+
+        eres = Int64Index([0, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18])
+        elidx = np.array([0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9], dtype=np.intp)
+        eridx = np.array([-1, -1, 0, 1, -1, -1, -1, -1, -1, -1, -1], dtype=np.intp)
+
+        tm.assert_index_equal(res, eres)
+        tm.assert_numpy_array_equal(lidx, elidx)
+        tm.assert_numpy_array_equal(ridx, eridx)
+
+    def test_join_self(self, join_type):
+        index = RangeIndex(start=0, stop=20, step=2)
+        joined = index.join(index, how=join_type)
+        assert index is joined
diff --git a/pandas/tests/indexes/ranges/test_range.py b/pandas/tests/indexes/ranges/test_range.py
index 24616f05c..c1cc23039 100644
--- a/pandas/tests/indexes/ranges/test_range.py
+++ b/pandas/tests/indexes/ranges/test_range.py
@@ -294,174 +294,6 @@ class TestRangeIndex(Numeric):
         expected = np.array([-1, 2, -1, -1, 1, -1, -1, 0, -1], dtype=np.intp)
         tm.assert_numpy_array_equal(result, expected)
 
-    def test_join_outer(self):
-        # join with Int64Index
-        index = self.create_index()
-        other = Int64Index(np.arange(25, 14, -1))
-
-        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
-        noidx_res = index.join(other, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        eres = Int64Index(
-            [0, 2, 4, 6, 8, 10, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]
-        )
-        elidx = np.array(
-            [0, 1, 2, 3, 4, 5, 6, 7, -1, 8, -1, 9, -1, -1, -1, -1, -1, -1, -1],
-            dtype=np.intp,
-        )
-        eridx = np.array(
-            [-1, -1, -1, -1, -1, -1, -1, -1, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0],
-            dtype=np.intp,
-        )
-
-        assert isinstance(res, Int64Index)
-        assert not isinstance(res, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # join with RangeIndex
-        other = RangeIndex(25, 14, -1)
-
-        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
-        noidx_res = index.join(other, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        assert isinstance(res, Int64Index)
-        assert not isinstance(res, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_inner(self):
-        # Join with non-RangeIndex
-        index = self.create_index()
-        other = Int64Index(np.arange(25, 14, -1))
-
-        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
-
-        # no guarantee of sortedness, so sort for comparison purposes
-        ind = res.argsort()
-        res = res.take(ind)
-        lidx = lidx.take(ind)
-        ridx = ridx.take(ind)
-
-        eres = Int64Index([16, 18])
-        elidx = np.array([8, 9], dtype=np.intp)
-        eridx = np.array([9, 7], dtype=np.intp)
-
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # Join two RangeIndex
-        other = RangeIndex(25, 14, -1)
-
-        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
-
-        assert isinstance(res, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_left(self):
-        # Join with Int64Index
-        index = self.create_index()
-        other = Int64Index(np.arange(25, 14, -1))
-
-        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
-        eres = index
-        eridx = np.array([-1, -1, -1, -1, -1, -1, -1, -1, 9, 7], dtype=np.intp)
-
-        assert isinstance(res, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # Join withRangeIndex
-        other = Int64Index(np.arange(25, 14, -1))
-
-        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
-
-        assert isinstance(res, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_right(self):
-        # Join with Int64Index
-        index = self.create_index()
-        other = Int64Index(np.arange(25, 14, -1))
-
-        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
-        eres = other
-        elidx = np.array([-1, -1, -1, -1, -1, -1, -1, 9, -1, 8, -1], dtype=np.intp)
-
-        assert isinstance(other, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        assert ridx is None
-
-        # Join withRangeIndex
-        other = RangeIndex(25, 14, -1)
-
-        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
-        eres = other
-
-        assert isinstance(other, RangeIndex)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        assert ridx is None
-
-    def test_join_non_int_index(self):
-        index = self.create_index()
-        other = Index([3, 6, 7, 8, 10], dtype=object)
-
-        outer = index.join(other, how="outer")
-        outer2 = other.join(index, how="outer")
-        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
-        tm.assert_index_equal(outer, outer2)
-        tm.assert_index_equal(outer, expected)
-
-        inner = index.join(other, how="inner")
-        inner2 = other.join(index, how="inner")
-        expected = Index([6, 8, 10])
-        tm.assert_index_equal(inner, inner2)
-        tm.assert_index_equal(inner, expected)
-
-        left = index.join(other, how="left")
-        tm.assert_index_equal(left, index.astype(object))
-
-        left2 = other.join(index, how="left")
-        tm.assert_index_equal(left2, other)
-
-        right = index.join(other, how="right")
-        tm.assert_index_equal(right, other)
-
-        right2 = other.join(index, how="right")
-        tm.assert_index_equal(right2, index.astype(object))
-
-    def test_join_non_unique(self):
-        index = self.create_index()
-        other = Index([4, 4, 3, 3])
-
-        res, lidx, ridx = index.join(other, return_indexers=True)
-
-        eres = Int64Index([0, 2, 4, 4, 6, 8, 10, 12, 14, 16, 18])
-        elidx = np.array([0, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9], dtype=np.intp)
-        eridx = np.array([-1, -1, 0, 1, -1, -1, -1, -1, -1, -1, -1], dtype=np.intp)
-
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_self(self, join_type):
-        index = self.create_index()
-        joined = index.join(index, how=join_type)
-        assert index is joined
-
     def test_nbytes(self):
 
         # memory savings vs int index
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 3b4b6b09d..77163e7a6 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -2056,7 +2056,9 @@ class TestIndex(Base):
         assert index.name == index[1:].name
 
     @pytest.mark.parametrize(
-        "index", ["unicode", "string", "datetime", "int", "float"], indirect=True
+        "index",
+        ["unicode", "string", "datetime", "int", "uint", "float"],
+        indirect=True,
     )
     def test_join_self(self, index, join_type):
         joined = index.join(index, how=join_type)
diff --git a/pandas/tests/indexes/test_numeric.py b/pandas/tests/indexes/test_numeric.py
index 1b504ce99..10d57d861 100644
--- a/pandas/tests/indexes/test_numeric.py
+++ b/pandas/tests/indexes/test_numeric.py
@@ -580,25 +580,6 @@ class NumericInt(Numeric):
 
         assert not index.copy(dtype=object).identical(index.copy(dtype=self._dtype))
 
-    def test_join_non_unique(self):
-        left = Index([4, 4, 3, 3])
-
-        joined, lidx, ridx = left.join(left, return_indexers=True)
-
-        exp_joined = Index([3, 3, 3, 3, 4, 4, 4, 4])
-        tm.assert_index_equal(joined, exp_joined)
-
-        exp_lidx = np.array([2, 2, 3, 3, 0, 0, 1, 1], dtype=np.intp)
-        tm.assert_numpy_array_equal(lidx, exp_lidx)
-
-        exp_ridx = np.array([2, 3, 2, 3, 0, 1, 0, 1], dtype=np.intp)
-        tm.assert_numpy_array_equal(ridx, exp_ridx)
-
-    def test_join_self(self, join_type):
-        index = self.create_index()
-        joined = index.join(index, how=join_type)
-        assert index is joined
-
     def test_union_noncomparable(self):
         # corner case, non-Int64Index
         index = self.create_index()
@@ -798,175 +779,6 @@ class TestInt64Index(NumericInt):
         )
         tm.assert_index_equal(result, expected)
 
-    def test_join_inner(self):
-        index = self.create_index()
-        other = Int64Index([7, 12, 25, 1, 2, 5])
-        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
-
-        # not monotonic
-        res, lidx, ridx = index.join(other, how="inner", return_indexers=True)
-
-        # no guarantee of sortedness, so sort for comparison purposes
-        ind = res.argsort()
-        res = res.take(ind)
-        lidx = lidx.take(ind)
-        ridx = ridx.take(ind)
-
-        eres = Int64Index([2, 12])
-        elidx = np.array([1, 6], dtype=np.intp)
-        eridx = np.array([4, 1], dtype=np.intp)
-
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index.join(other_mono, how="inner", return_indexers=True)
-
-        res2 = index.intersection(other_mono)
-        tm.assert_index_equal(res, res2)
-
-        elidx = np.array([1, 6], dtype=np.intp)
-        eridx = np.array([1, 4], dtype=np.intp)
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_left(self):
-        index = self.create_index()
-        other = Int64Index([7, 12, 25, 1, 2, 5])
-        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
-
-        # not monotonic
-        res, lidx, ridx = index.join(other, how="left", return_indexers=True)
-        eres = index
-        eridx = np.array([-1, 4, -1, -1, -1, -1, 1, -1, -1, -1], dtype=np.intp)
-
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index.join(other_mono, how="left", return_indexers=True)
-        eridx = np.array([-1, 1, -1, -1, -1, -1, 4, -1, -1, -1], dtype=np.intp)
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # non-unique
-        idx = Index([1, 1, 2, 5])
-        idx2 = Index([1, 2, 5, 7, 9])
-        res, lidx, ridx = idx2.join(idx, how="left", return_indexers=True)
-        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2
-        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
-        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_right(self):
-        index = self.create_index()
-        other = Int64Index([7, 12, 25, 1, 2, 5])
-        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
-
-        # not monotonic
-        res, lidx, ridx = index.join(other, how="right", return_indexers=True)
-        eres = other
-        elidx = np.array([-1, 6, -1, -1, 1, -1], dtype=np.intp)
-
-        assert isinstance(other, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        assert ridx is None
-
-        # monotonic
-        res, lidx, ridx = index.join(other_mono, how="right", return_indexers=True)
-        eres = other_mono
-        elidx = np.array([-1, 1, -1, -1, 6, -1], dtype=np.intp)
-        assert isinstance(other, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        assert ridx is None
-
-        # non-unique
-        idx = Index([1, 1, 2, 5])
-        idx2 = Index([1, 2, 5, 7, 9])
-        res, lidx, ridx = idx.join(idx2, how="right", return_indexers=True)
-        eres = Index([1, 1, 2, 5, 7, 9])  # 1 is in idx2, so it should be x2
-        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
-        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_non_int_index(self):
-        index = self.create_index()
-        other = Index([3, 6, 7, 8, 10], dtype=object)
-
-        outer = index.join(other, how="outer")
-        outer2 = other.join(index, how="outer")
-        expected = Index([0, 2, 3, 4, 6, 7, 8, 10, 12, 14, 16, 18])
-        tm.assert_index_equal(outer, outer2)
-        tm.assert_index_equal(outer, expected)
-
-        inner = index.join(other, how="inner")
-        inner2 = other.join(index, how="inner")
-        expected = Index([6, 8, 10])
-        tm.assert_index_equal(inner, inner2)
-        tm.assert_index_equal(inner, expected)
-
-        left = index.join(other, how="left")
-        tm.assert_index_equal(left, index.astype(object))
-
-        left2 = other.join(index, how="left")
-        tm.assert_index_equal(left2, other)
-
-        right = index.join(other, how="right")
-        tm.assert_index_equal(right, other)
-
-        right2 = other.join(index, how="right")
-        tm.assert_index_equal(right2, index.astype(object))
-
-    def test_join_outer(self):
-        index = self.create_index()
-        other = Int64Index([7, 12, 25, 1, 2, 5])
-        other_mono = Int64Index([1, 2, 5, 7, 12, 25])
-
-        # not monotonic
-        # guarantee of sortedness
-        res, lidx, ridx = index.join(other, how="outer", return_indexers=True)
-        noidx_res = index.join(other, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        eres = Int64Index([0, 1, 2, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 25])
-        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)
-        eridx = np.array(
-            [-1, 3, 4, -1, 5, -1, 0, -1, -1, 1, -1, -1, -1, 2], dtype=np.intp
-        )
-
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index.join(other_mono, how="outer", return_indexers=True)
-        noidx_res = index.join(other_mono, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        elidx = np.array([0, -1, 1, 2, -1, 3, -1, 4, 5, 6, 7, 8, 9, -1], dtype=np.intp)
-        eridx = np.array(
-            [-1, 0, 1, -1, 2, -1, 3, -1, -1, 4, -1, -1, -1, 5], dtype=np.intp
-        )
-        assert isinstance(res, Int64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
 
 class TestUInt64Index(NumericInt):
 
@@ -1043,196 +855,6 @@ class TestUInt64Index(NumericInt):
         )
         tm.assert_index_equal(result, expected)
 
-    def test_join_inner(self, index_large):
-        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
-        other_mono = UInt64Index(
-            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
-        )
-
-        # not monotonic
-        res, lidx, ridx = index_large.join(other, how="inner", return_indexers=True)
-
-        # no guarantee of sortedness, so sort for comparison purposes
-        ind = res.argsort()
-        res = res.take(ind)
-        lidx = lidx.take(ind)
-        ridx = ridx.take(ind)
-
-        eres = UInt64Index(2 ** 63 + np.array([10, 25], dtype="uint64"))
-        elidx = np.array([1, 4], dtype=np.intp)
-        eridx = np.array([5, 2], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index_large.join(
-            other_mono, how="inner", return_indexers=True
-        )
-
-        res2 = index_large.intersection(other_mono)
-        tm.assert_index_equal(res, res2)
-
-        elidx = np.array([1, 4], dtype=np.intp)
-        eridx = np.array([3, 5], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_left(self, index_large):
-        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
-        other_mono = UInt64Index(
-            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
-        )
-
-        # not monotonic
-        res, lidx, ridx = index_large.join(other, how="left", return_indexers=True)
-        eres = index_large
-        eridx = np.array([-1, 5, -1, -1, 2], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index_large.join(other_mono, how="left", return_indexers=True)
-        eridx = np.array([-1, 3, -1, -1, 5], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        assert lidx is None
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # non-unique
-        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype="uint64"))
-        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype="uint64"))
-        res, lidx, ridx = idx2.join(idx, how="left", return_indexers=True)
-
-        # 1 is in idx2, so it should be x2
-        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype="uint64"))
-        eridx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
-        elidx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
-
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_right(self, index_large):
-        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
-        other_mono = UInt64Index(
-            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
-        )
-
-        # not monotonic
-        res, lidx, ridx = index_large.join(other, how="right", return_indexers=True)
-        eres = other
-        elidx = np.array([-1, -1, 4, -1, -1, 1], dtype=np.intp)
-
-        tm.assert_numpy_array_equal(lidx, elidx)
-        assert isinstance(other, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        assert ridx is None
-
-        # monotonic
-        res, lidx, ridx = index_large.join(
-            other_mono, how="right", return_indexers=True
-        )
-        eres = other_mono
-        elidx = np.array([-1, -1, -1, 1, -1, 4], dtype=np.intp)
-
-        assert isinstance(other, UInt64Index)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_index_equal(res, eres)
-        assert ridx is None
-
-        # non-unique
-        idx = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5], dtype="uint64"))
-        idx2 = UInt64Index(2 ** 63 + np.array([1, 2, 5, 7, 9], dtype="uint64"))
-        res, lidx, ridx = idx.join(idx2, how="right", return_indexers=True)
-
-        # 1 is in idx2, so it should be x2
-        eres = UInt64Index(2 ** 63 + np.array([1, 1, 2, 5, 7, 9], dtype="uint64"))
-        elidx = np.array([0, 1, 2, 3, -1, -1], dtype=np.intp)
-        eridx = np.array([0, 0, 1, 2, 3, 4], dtype=np.intp)
-
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-    def test_join_non_int_index(self, index_large):
-        other = Index(
-            2 ** 63 + np.array([1, 5, 7, 10, 20], dtype="uint64"), dtype=object
-        )
-
-        outer = index_large.join(other, how="outer")
-        outer2 = other.join(index_large, how="outer")
-        expected = Index(
-            2 ** 63 + np.array([0, 1, 5, 7, 10, 15, 20, 25], dtype="uint64")
-        )
-        tm.assert_index_equal(outer, outer2)
-        tm.assert_index_equal(outer, expected)
-
-        inner = index_large.join(other, how="inner")
-        inner2 = other.join(index_large, how="inner")
-        expected = Index(2 ** 63 + np.array([10, 20], dtype="uint64"))
-        tm.assert_index_equal(inner, inner2)
-        tm.assert_index_equal(inner, expected)
-
-        left = index_large.join(other, how="left")
-        tm.assert_index_equal(left, index_large.astype(object))
-
-        left2 = other.join(index_large, how="left")
-        tm.assert_index_equal(left2, other)
-
-        right = index_large.join(other, how="right")
-        tm.assert_index_equal(right, other)
-
-        right2 = other.join(index_large, how="right")
-        tm.assert_index_equal(right2, index_large.astype(object))
-
-    def test_join_outer(self, index_large):
-        other = UInt64Index(2 ** 63 + np.array([7, 12, 25, 1, 2, 10], dtype="uint64"))
-        other_mono = UInt64Index(
-            2 ** 63 + np.array([1, 2, 7, 10, 12, 25], dtype="uint64")
-        )
-
-        # not monotonic
-        # guarantee of sortedness
-        res, lidx, ridx = index_large.join(other, how="outer", return_indexers=True)
-        noidx_res = index_large.join(other, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        eres = UInt64Index(
-            2 ** 63 + np.array([0, 1, 2, 7, 10, 12, 15, 20, 25], dtype="uint64")
-        )
-        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)
-        eridx = np.array([-1, 3, 4, 0, 5, 1, -1, -1, 2], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
-        # monotonic
-        res, lidx, ridx = index_large.join(
-            other_mono, how="outer", return_indexers=True
-        )
-        noidx_res = index_large.join(other_mono, how="outer")
-        tm.assert_index_equal(res, noidx_res)
-
-        elidx = np.array([0, -1, -1, -1, 1, -1, 2, 3, 4], dtype=np.intp)
-        eridx = np.array([-1, 0, 1, 2, 3, 4, -1, -1, 5], dtype=np.intp)
-
-        assert isinstance(res, UInt64Index)
-        tm.assert_index_equal(res, eres)
-        tm.assert_numpy_array_equal(lidx, elidx)
-        tm.assert_numpy_array_equal(ridx, eridx)
-
 
 @pytest.mark.parametrize("dtype", ["int64", "uint64"])
 def test_int_float_union_dtype(dtype):
diff --git a/pandas/tests/indexes/timedeltas/test_join.py b/pandas/tests/indexes/timedeltas/test_join.py
new file mode 100644
index 000000000..3e73ed35d
--- /dev/null
+++ b/pandas/tests/indexes/timedeltas/test_join.py
@@ -0,0 +1,37 @@
+import numpy as np
+
+from pandas import Index, Timedelta, timedelta_range
+import pandas._testing as tm
+
+
+class TestJoin:
+    def test_append_join_nondatetimeindex(self):
+        rng = timedelta_range("1 days", periods=10)
+        idx = Index(["a", "b", "c", "d"])
+
+        result = rng.append(idx)
+        assert isinstance(result[0], Timedelta)
+
+        # it works
+        rng.join(idx, how="outer")
+
+    def test_join_self(self, join_type):
+        index = timedelta_range("1 day", periods=10)
+        joined = index.join(index, how=join_type)
+        tm.assert_index_equal(index, joined)
+
+    def test_does_not_convert_mixed_integer(self):
+        df = tm.makeCustomDataframe(
+            10,
+            10,
+            data_gen_f=lambda *args, **kwargs: np.random.randn(),
+            r_idx_type="i",
+            c_idx_type="td",
+        )
+        str(df)
+
+        cols = df.columns.join(df.index, how="outer")
+        joined = cols.join(df.columns)
+        assert cols.dtype == np.dtype("O")
+        assert cols.dtype == joined.dtype
+        tm.assert_index_equal(cols, joined)
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index 8a91c9d5e..d4a94f869 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -91,27 +91,6 @@ class TestTimedeltaIndex(DatetimeLike):
         tm.assert_numpy_array_equal(arr, exp_arr)
         tm.assert_index_equal(idx, idx3)
 
-    def test_join_self(self, join_type):
-        index = timedelta_range("1 day", periods=10)
-        joined = index.join(index, how=join_type)
-        tm.assert_index_equal(index, joined)
-
-    def test_does_not_convert_mixed_integer(self):
-        df = tm.makeCustomDataframe(
-            10,
-            10,
-            data_gen_f=lambda *args, **kwargs: randn(),
-            r_idx_type="i",
-            c_idx_type="td",
-        )
-        str(df)
-
-        cols = df.columns.join(df.index, how="outer")
-        joined = cols.join(df.columns)
-        assert cols.dtype == np.dtype("O")
-        assert cols.dtype == joined.dtype
-        tm.assert_index_equal(cols, joined)
-
     def test_sort_values(self):
 
         idx = TimedeltaIndex(["4d", "1d", "2d"])
@@ -181,16 +160,6 @@ class TestTimedeltaIndex(DatetimeLike):
         ):
             hash(index)
 
-    def test_append_join_nondatetimeindex(self):
-        rng = timedelta_range("1 days", periods=10)
-        idx = Index(["a", "b", "c", "d"])
-
-        result = rng.append(idx)
-        assert isinstance(result[0], Timedelta)
-
-        # it works
-        rng.join(idx, how="outer")
-
     def test_append_numpy_bug_1681(self):
 
         td = timedelta_range("1 days", "10 days", freq="2D")

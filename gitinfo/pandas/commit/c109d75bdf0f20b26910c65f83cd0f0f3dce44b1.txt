commit c109d75bdf0f20b26910c65f83cd0f0f3dce44b1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Oct 3 01:58:44 2012 -0400

    ENH: use low_memory by default. fixes

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index aa6253a85..6fcdf4e85 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -238,8 +238,8 @@ _c_parser_defaults = {
     'na_filter': True,
     'compact_ints': False,
     'use_unsigned': False,
-    'low_memory': False,
-    'buffer_lines': 2**14,
+    'low_memory': True,
+    'buffer_lines': 2**16,
     'error_bad_lines': True,
     'warn_bad_lines': True,
     'factorize': True
@@ -282,7 +282,7 @@ def _make_parser_function(name, sep=','):
                  compact_ints=False,
                  use_unsigned=False,
                  low_memory=_c_parser_defaults['low_memory'],
-                 buffer_lines=2**14,
+                 buffer_lines=2**16,
                  warn_bad_lines=True,
                  error_bad_lines=True,
 
@@ -494,13 +494,11 @@ class TextFileReader(object):
             # wait until regex engine integrated
             engine = 'python'
 
-        # can't handle it
-        if options['encoding'] is not None and engine == 'c':
-            engine = 'python'
-
         # C engine not supported yet
-        if options['skip_footer'] > 0 and engine == 'c':
-            engine = 'python'
+        if engine == 'c':
+            if (options['comment'] or options['skip_footer'] > 0
+                or options['encoding'] is not None):
+                engine = 'python'
 
         if engine == 'c':
             for arg in _c_unsupported:
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 8b639f6e6..6343e410e 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -1221,6 +1221,20 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000"""
 
         assert_frame_equal(xp.set_index(['nominal', 'ID']), df)
 
+    def test_comment(self):
+        data = """A,B,C
+1,2.,4.#hello world
+5.,NaN,10.0
+"""
+        expected = [[1., 2., 4.],
+                    [5., np.nan, 10.]]
+        df = self.read_csv(StringIO(data), comment='#')
+        assert_almost_equal(df.values, expected)
+
+        df = self.read_table(StringIO(data), sep=',', comment='#',
+                             na_values=['NaN'])
+        assert_almost_equal(df.values, expected)
+
 
 class TestPythonParser(ParserTests, unittest.TestCase):
 
@@ -1282,19 +1296,6 @@ c   1   2   3   4
         self.assert_(expected.index.name is None)
         assert_frame_equal(df, expected)
 
-    def test_comment(self):
-        data = """A,B,C
-1,2.,4.#hello world
-5.,NaN,10.0
-"""
-        expected = [[1., 2., 4.],
-                    [5., np.nan, 10.]]
-        df = self.read_csv(StringIO(data), comment='#')
-        assert_almost_equal(df.values, expected)
-
-        df = self.read_table(StringIO(data), sep=',', comment='#', na_values=['NaN'])
-        assert_almost_equal(df.values, expected)
-
     def test_1000_fwf(self):
         data = """
  1 2,334.0    5
@@ -1513,16 +1514,50 @@ eight,1,2,3"""
         assert_frame_equal(df3, df2)
 
 
-class TestCParser(ParserTests, unittest.TestCase):
+class TestCParserHighMemory(ParserTests, unittest.TestCase):
+
+    def read_csv(self, *args, **kwds):
+        kwds = kwds.copy()
+        kwds['engine'] = 'c'
+        kwds['low_memory'] = False
+        return read_csv(*args, **kwds)
+
+    def read_table(self, *args, **kwds):
+        kwds = kwds.copy()
+        kwds['engine'] = 'c'
+        kwds['low_memory'] = False
+        return read_table(*args, **kwds)
+
+    def test_compact_ints(self):
+        data = ('0,1,0,0\n'
+                '1,1,0,0\n'
+                '0,1,0,1')
+
+        result = read_csv(StringIO(data), delimiter=',', header=None,
+                          compact_ints=True, as_recarray=True)
+        ex_dtype = np.dtype([(str(i), 'i1') for i in range(4)])
+        self.assertEqual(result.dtype, ex_dtype)
+
+        result = read_csv(StringIO(data), delimiter=',', header=None,
+                          as_recarray=True, compact_ints=True,
+                          use_unsigned=True)
+        ex_dtype = np.dtype([(str(i), 'u1') for i in range(4)])
+        self.assertEqual(result.dtype, ex_dtype)
+
+class TestCParserLowMemory(ParserTests, unittest.TestCase):
 
     def read_csv(self, *args, **kwds):
         kwds = kwds.copy()
         kwds['engine'] = 'c'
+        kwds['low_memory'] = True
+        kwds['buffer_lines'] = 2
         return read_csv(*args, **kwds)
 
     def read_table(self, *args, **kwds):
         kwds = kwds.copy()
         kwds['engine'] = 'c'
+        kwds['low_memory'] = True
+        kwds['buffer_lines'] = 2
         return read_table(*args, **kwds)
 
     def test_compact_ints(self):
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index bf88faf16..71b693ae1 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -88,6 +88,7 @@ cdef extern from "parser/parser.h":
         int chunksize  # Number of bytes to prepare for each chunk
         char *data     # pointer to data to be processed
         int datalen    # amount of data available
+        int datapos
 
         # where to write out tokenized data
         char *stream
@@ -254,7 +255,7 @@ cdef class TextReader:
                   compact_ints=False,
                   use_unsigned=False,
                   low_memory=False,
-                  buffer_lines=2**14,
+                  buffer_lines=2**16,
                   skiprows=None,
                   skip_footer=0,
                   verbose=False):
@@ -513,7 +514,7 @@ cdef class TextReader:
     cdef _read_low_memory(self, rows):
         cdef:
             size_t rows_read = 0
-            list chunks = []
+            chunks = []
 
         if rows is None:
             while True:
@@ -521,21 +522,29 @@ cdef class TextReader:
                     chunk = self._read_high_memory(self.buffer_lines, 0)
                     if len(chunk) == 0:
                         break
-
-                    chunks.append(chunk)
                 except StopIteration:
                     break
+                else:
+                    chunks.append(chunk)
         else:
             while rows_read < rows:
                 try:
-                    chunk = self._read_high_memory(self.buffer_lines, 0)
+                    crows = min(self.buffer_lines, rows - rows_read)
+
+                    chunk = self._read_high_memory(crows, 0)
                     if len(chunk) == 0:
                         break
 
                     rows_read += len(chunk.values()[0])
-                    chunks.append(chunk)
                 except StopIteration:
                     break
+                else:
+                    chunks.append(chunk)
+
+        parser_trim_buffers(self.parser)
+
+        if len(chunks) == 0:
+            raise StopIteration
 
         # destructive to chunks
         return _concatenate_chunks(chunks)
diff --git a/pandas/src/parser/parser.c b/pandas/src/parser/parser.c
index 53f60b48a..33eafec93 100644
--- a/pandas/src/parser/parser.c
+++ b/pandas/src/parser/parser.c
@@ -55,6 +55,8 @@ void *safe_realloc(void *buffer, size_t size) {
         // errno gets set to 12 on my OS Xmachine in some cases even when the
         // realloc succeeds. annoying
         errno = 0;
+    } else {
+        return buffer;
     }
 
     return result;
@@ -1054,6 +1056,8 @@ int inline end_line(parser_t *self) {
         self->line_start[self->lines] = (self->line_start[self->lines - 1] +
                                          fields);
 
+        TRACE(("new line start: %d\n", self->line_start[self->lines]));
+
         // new line start with 0 fields
         self->line_fields[self->lines] = 0;
     }
@@ -1775,15 +1779,31 @@ int parser_consume_rows(parser_t *self, size_t nrows) {
     self->pword_start -= char_count;
     self->word_start -= char_count;
 
+    /* printf("Line_start: "); */
+    /* for (i = 0; i < self->lines; ++i) { */
+    /*     printf("%d ", self->line_start[i]); */
+    /* } */
+    /* printf("\n"); */
+
     /* move line metadata */
-    for (i = 0; i < self->lines - nrows; ++i)
+    for (i = 0; i < self->lines - nrows + 1; ++i)
     {
         offset = i + nrows;
         self->line_start[i] = self->line_start[offset] - word_deletions;
+
+        /* TRACE(("First word in line %d is now %s\n", i, */
+        /*        self->words[self->line_start[i]])); */
+
         self->line_fields[i] = self->line_fields[offset];
     }
     self->lines -= nrows;
-    self->line_fields[self->lines] = 0;
+    /* self->line_fields[self->lines] = 0; */
+
+    /* printf("Line_start: "); */
+    /* for (i = 0; i < self->lines; ++i) { */
+    /*     printf("%d ", self->line_start[i]); */
+    /* } */
+    /* printf("\n"); */
 
     return 0;
 }
diff --git a/pandas/src/parser/parser.h b/pandas/src/parser/parser.h
index 4d88959b9..f1c6a845b 100644
--- a/pandas/src/parser/parser.h
+++ b/pandas/src/parser/parser.h
@@ -53,7 +53,7 @@
 #define ERROR_NO_DATA                  23
 
 
-/* #define VERBOSE */
+// #define VERBOSE
 
 #if defined(VERBOSE)
 #define TRACE(X) printf X;

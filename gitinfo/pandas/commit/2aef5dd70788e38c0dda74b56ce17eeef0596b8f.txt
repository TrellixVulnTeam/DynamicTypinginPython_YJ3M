commit 2aef5dd70788e38c0dda74b56ce17eeef0596b8f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 3 19:16:57 2009 +0000

    made test case stubs for all Index, Series, DataFrame, DataMatrix methods
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@69 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/tests/common.py b/pandas/core/tests/common.py
index 43b71efbd..411e08e79 100644
--- a/pandas/core/tests/common.py
+++ b/pandas/core/tests/common.py
@@ -1,3 +1,5 @@
+# pylint: disable-msg=W0402
+
 from datetime import datetime
 import random
 import string
@@ -7,8 +9,8 @@ import numpy as np
 
 from pandas.core.api import DateRange, Index, Series, DataFrame
 
-N = 100
-K = 10
+N = 30
+K = 4
 
 def rands(n):
     choices = string.letters + string.digits
@@ -53,6 +55,10 @@ def assert_dict_equal(a, b):
     for k in a_keys:
         assert_almost_equal(a[k], b[k])
 
+def assert_contains_all(iterable, dic):
+    for k in iterable:
+        assert(k in dic)
+
 def getCols(k):
     return string.ascii_uppercase[:k]
 
diff --git a/pandas/core/tests/test_datamatrix.py b/pandas/core/tests/test_datamatrix.py
deleted file mode 100644
index dc6bbb1b1..000000000
--- a/pandas/core/tests/test_datamatrix.py
+++ /dev/null
@@ -1,199 +0,0 @@
-from copy import deepcopy
-from datetime import datetime
-import unittest
-
-from numpy.random import randn
-import numpy as np
-
-from pandas.core.api import Index, NULL_INDEX, DataMatrix, Series, DateRange
-from pandas.core.datetools import bday
-import pandas.core.tests.common as common
-
-#-------------------------------------------------------------------------------
-# DataMatrix test cases
-
-class TestDataMatrix(unittest.TestCase):
-    def setUp(self):
-        index1 = DateRange(datetime(2008,4,22), periods=50)
-        index2 = DateRange(datetime(2008,4,29), periods=50)
-        index3 = DateRange(datetime(2008,4,28), periods=50)
-        ts1 = Series(randn(50), index=index1)
-        ts2 = Series(randn(50), index=index2)
-        ts3 = Series(randn(50), index=index3)
-        ts4 = Series(randn(50), index=index1)
-        data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
-        self.frame = DataMatrix(data=data, index=index3)
-        self.ts1 = ts1
-        self.ts2 = ts2
-        self.ts3 = ts3
-        self.ts4 = ts4
-
-    def testReindex(self):
-        newFrame = self.frame.reindex(self.ts1.index)
-        for col in newFrame.cols():
-            for idx, val in newFrame[col].iteritems():
-                if idx in self.frame.index:
-                    if np.isnan(val):
-                        self.assert_(np.isnan(self.frame[col][idx]))
-                    else:
-                        self.assertEqual(val, self.frame[col][idx])
-                else:
-                    self.assert_(np.isnan(val))
-        for col, series in newFrame.iteritems():
-            self.assert_(common.equalContents(series.index, newFrame.index))
-        emptyFrame = self.frame.reindex(Index([]))
-        self.assert_(len(emptyFrame.index) == 0)
-
-        nonContigFrame = self.frame.reindex(self.ts1.index[::2])
-        for col in nonContigFrame.cols():
-            for idx, val in nonContigFrame[col].iteritems():
-                if idx in self.frame.index:
-                    if np.isnan(val):
-                        self.assert_(np.isnan(self.frame[col][idx]))
-                    else:
-                        self.assertEqual(val, self.frame[col][idx])
-                else:
-                    self.assert_(np.isnan(val))
-        for col, series in nonContigFrame.iteritems():
-            self.assert_(common.equalContents(series.index, nonContigFrame.index))
-
-    def testShift(self):
-        shiftedFrame = self.frame.shift(5)
-        for i, idx in enumerate(shiftedFrame.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
-        series = shiftedFrame['col1']
-        for i, idx in enumerate(series.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
-
-    def testOperators(self):
-        garbage = randn(4)
-        colSeries = Series(garbage, index=np.array(self.frame.cols()))
-        idSum = self.frame + self.frame
-        seriesSum = self.frame + colSeries
-        for col, series in idSum.iteritems():
-            for idx, val in series.iteritems():
-                origVal = self.frame[col][idx] * 2
-                if not np.isnan(val):
-                    self.assertEqual(val, origVal)
-                else:
-                    self.assert_(np.isnan(origVal))
-        for col, series in seriesSum.iteritems():
-            for idx, val in series.iteritems():
-                origVal = self.frame[col][idx] + colSeries[col]
-                if not np.isnan(val):
-                    self.assertEqual(val, origVal)
-                else:
-                    self.assert_(np.isnan(origVal))
-
-    def testSlice(self):
-        """Slicing NOT intended for production code"""
-        slice = self.frame[:20]
-        self.assertEqual(20, len(slice.index))
-        for col, series in slice.iteritems():
-            self.assertEqual(20, len(series.index))
-            self.assert_(common.equalContents(series.index, slice.index))
-
-    def testGetItem(self):
-        for key, value in self.frame._series.iteritems():
-            self.assert_(self.frame[key] is not None)
-        self.assert_('random' not in self.frame)
-
-    def testSetItem(self):
-        # not sure what else to do here
-        series = self.frame['col1']
-        self.frame['col5'] = series
-        self.assert_('col5' in self.frame)
-
-    def testStatistics(self):
-        sumFrame = self.frame.apply(np.sum)
-        for col, series in self.frame.iteritems():
-            val = sumFrame[col]
-            if np.isnan(val):
-                print self.frame[col]
-            self.assertEqual(val, series.sum())
-
-    def testDelItem(self):
-        del self.frame['col1']
-        self.assert_('col1' not in self.frame)
-        self.assert_('col1' not in self.frame._series)
-
-    def testGetXS(self):
-        idx = self.frame.index[5]
-        xs = self.frame.getXS(idx)
-        for item, value in xs.iteritems():
-            if np.isnan(value):
-                self.assert_(np.isnan(self.frame[item][idx]))
-            else:
-                self.assertEqual(value, self.frame[item][idx])
-
-    def testGetTS(self):
-        frame = self.frame
-        tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
-        for i, idx in enumerate(tsFrame.index):
-            self.assertEqual(idx, frame.index[5+i])
-            for col, series in tsFrame.iteritems():
-                self.assertEqual(idx, series.index[i])
-        for col, series in frame.iteritems():
-            for idx, value in series.iteritems():
-                if np.isnan(value):
-                    self.assert_(np.isnan(frame[col][idx]))
-                else:
-                    self.assertEqual(value, frame[col][idx])
-
-    def testTranspose(self):
-        frame = self.frame
-        dft = frame.T
-        for idx, series in dft.iteritems():
-            for col, value in series.iteritems():
-                if np.isnan(value):
-                    self.assert_(np.isnan(frame[col][idx]))
-                else:
-                    self.assertEqual(value, frame[col][idx])
-
-    def testAsMatrix(self):
-        frame = self.frame
-        mat = frame.asMatrix()
-        smallerCols = ['col3', 'col1']
-        smallerMat = frame.asMatrix(smallerCols)
-        frameCols = frame.cols()
-        for i, row in enumerate(mat):
-            for j, value in enumerate(row):
-                col = frameCols[j]
-                if np.isnan(value):
-                    self.assert_(np.isnan(frame[col][i]))
-                else:
-                    self.assertEqual(value, frame[col][i])
-
-    def testDeepcopy(self):
-        cp = deepcopy(self.frame)
-        series = cp['col1']
-        series[:] = 10
-        for idx, value in series.iteritems():
-            self.assertNotEqual(self.frame['col1'][idx], value)
-
-    def testFromDict(self):
-        newFrame = DataMatrix.fromDict(col1=self.ts1, col2 = self.ts2)
-        for idx in newFrame.index:
-            if idx in self.ts1.index:
-                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
-            if idx in self.ts2.index:
-                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
-
-    def testFilterItems(self):
-        pass
-
-    def testGroupBy(self):
-
-        pass
-
-    def testApply(self):
-        pass
-
-    def testSort(self):
-        pass
-
-    def testToCSV(self):
-        pass
-
-if __name__ == '__main__':
-    unittest.main()
diff --git a/pandas/core/tests/test_dataframe.py b/pandas/core/tests/test_frame.py
similarity index 62%
rename from pandas/core/tests/test_dataframe.py
rename to pandas/core/tests/test_frame.py
index ee81be223..6c651b8b3 100644
--- a/pandas/core/tests/test_dataframe.py
+++ b/pandas/core/tests/test_frame.py
@@ -1,18 +1,20 @@
-from pandas.core.api import DateRange, DataFrame, Index, Series
-from pandas.core.datetools import bday
 from copy import deepcopy
 from datetime import datetime
+import unittest
 
 from numpy import random
 import numpy as np
 
-import string
-import unittest
+from pandas.core.api import DateRange, DataFrame, Index, Series
+from pandas.core.datetools import bday
+import pandas.core.tests.common as common
 
 #-------------------------------------------------------------------------------
 # DataFrame test cases
 
 class TestDataFrame(unittest.TestCase):
+    klass = DataFrame
+
     def setUp(self):
         index1 = DateRange(datetime(2008,4,22), periods=50)
         index2 = DateRange(datetime(2008,4,29), periods=50)
@@ -22,50 +24,74 @@ class TestDataFrame(unittest.TestCase):
         ts3 = Series(random.random(50), index=index3)
         ts4 = Series(random.random(50), index=index1)
         data = {'col1' : ts1,'col2' : ts2,'col3' : ts3, 'col4' : ts4}
-        self.frame = DataFrame(data=data, index=index3)
+        self.frame = self.klass(data=data, index=index3)
         self.ts1 = ts1
         self.ts2 = ts2
         self.ts3 = ts3
         self.ts4 = ts4
 
-    def testReindex(self):
-        newFrame = self.frame.reindex(self.ts1.index)
-        for col in newFrame.cols():
-            for idx, val in newFrame[col].iteritems():
-                if idx in self.frame.index:
-                    if np.isnan(val):
-                        self.assert_(np.isnan(self.frame[col][idx]))
-                    else:
-                        self.assertEqual(val, self.frame[col][idx])
-                else:
-                    self.assert_(np.isnan(val))
-        for col, series in newFrame.iteritems():
-            self.assert_(equalContents(series.index, newFrame.index))
-        emptyFrame = self.frame.reindex(Index([]))
-        self.assert_(len(emptyFrame.index) == 0)
+    def test_constructor(self):
+        pass
 
-        nonContigFrame = self.frame.reindex(self.ts1.index[::2])
-        for col in nonContigFrame.cols():
-            for idx, val in nonContigFrame[col].iteritems():
-                if idx in self.frame.index:
-                    if np.isnan(val):
-                        self.assert_(np.isnan(self.frame[col][idx]))
-                    else:
-                        self.assertEqual(val, self.frame[col][idx])
-                else:
-                    self.assert_(np.isnan(val))
-        for col, series in nonContigFrame.iteritems():
-            self.assert_(equalContents(series.index, nonContigFrame.index))
+    def test_fromDict(self):
+        newFrame = self.klass.fromDict(col1=self.ts1, col2 = self.ts2)
+        for idx in newFrame.index:
+            if idx in self.ts1.index:
+                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
+            if idx in self.ts2.index:
+                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
 
-    def testShift(self):
-        shiftedFrame = self.frame.shift(5)
-        for i, idx in enumerate(shiftedFrame.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
-        series = shiftedFrame['col1']
-        for i, idx in enumerate(series.index):
-            self.assert_(idx-5*bday == self.frame.index[i])
+    def test_fromRecords(self):
+        pass
+
+    def test_toRecords(self):
+        pass
+
+    def test_fromMatrix(self):
+        pass
+
+    def test_nonzero(self):
+        pass
+
+    def test_repr(self):
+        pass
+
+    def test_getitem(self):
+        """Slicing NOT intended for production code"""
+        sl = self.frame[:20]
+        self.assertEqual(20, len(sl.index))
+        for _, series in sl.iteritems():
+            self.assertEqual(20, len(series.index))
+            self.assert_(common.equalContents(series.index, sl.index))
+
+        for key, _ in self.frame._series.iteritems():
+            self.assert_(self.frame[key] is not None)
+        self.assert_('random' not in self.frame)
+
+    def test_setitem(self):
+        # not sure what else to do here
+        series = self.frame['col1']
+        self.frame['col5'] = series
+        self.assert_('col5' in self.frame)
+
+    def test_delitem(self):
+        del self.frame['col1']
+        self.assert_('col1' not in self.frame)
+        self.assert_('col1' not in self.frame._series)
+
+    def test_pop(self):
+        pass
+
+    def test_iter(self):
+        pass
+
+    def test_len(self):
+        pass
 
-    def testOperators(self):
+    def test_contains(self):
+        pass
+
+    def test_operators(self):
         garbage = random.random(4)
         colSeries = Series(garbage, index=np.array(self.frame.cols()))
         idSum = self.frame + self.frame
@@ -85,45 +111,100 @@ class TestDataFrame(unittest.TestCase):
                 else:
                     self.assert_(np.isnan(origVal))
 
-    def testSlice(self):
-        """Slicing NOT intended for production code"""
-        slice = self.frame[:20]
-        self.assertEqual(20, len(slice.index))
-        for col, series in slice.iteritems():
-            self.assertEqual(20, len(series.index))
-            self.assert_(equalContents(series.index, slice.index))
+    def test_neg(self):
+        pass
 
-    def testGetItem(self):
-        for key, value in self.frame._series.iteritems():
-            self.assert_(self.frame[key] is not None)
-        self.assert_('random' not in self.frame)
+    def test_firstTimeWithNValues(self):
+        pass
 
-    def testSetItem(self):
-        # not sure what else to do here
-        series = self.frame['col1']
-        self.frame['col5'] = series
-        self.assert_('col5' in self.frame)
+    def test_firstTimeWithValue(self):
+        pass
 
-    def testStatistics(self):
-        sumFrame = self.frame.apply(np.sum)
-        for col, series in self.frame.iteritems():
-            self.assertEqual(sumFrame[col], series.sum())
+    def test_lastTimeWithValue(self):
+        pass
 
-    def testDelItem(self):
-        del self.frame['col1']
-        self.assert_('col1' not in self.frame)
-        self.assert_('col1' not in self.frame._series)
+    def test_combineFrame(self):
+        pass
 
-    def testGetXS(self):
-        idx = self.frame.index[5]
-        xs = self.frame.getXS(idx)
-        for item, value in xs.iteritems():
-            if np.isnan(value):
-                self.assert_(np.isnan(self.frame[item][idx]))
-            else:
-                self.assertEqual(value, self.frame[item][idx])
+    def test_combineSeries(self):
+        pass
+
+    def test_combineFunc(self):
+        pass
+
+    def test_toCSV(self):
+        pass
+
+    def test_toDict(self):
+        pass
+
+    def test_toDataMatrix(self):
+        pass
+
+    def test_toString(self):
+        pass
+
+    def test_info(self):
+        pass
+
+    def test_rows(self):
+        pass
+
+    def test_cols(self):
+        pass
+
+    def test_columns(self):
+        pass
+
+    def test_iteritems(self):
+        pass
+
+    def test_append(self):
+        pass
+
+    def test_asfreq(self):
+        pass
+
+    def test_asMatrix(self):
+        frame = self.frame
+        mat = frame.asMatrix()
+        smallerCols = ['col3', 'col1']
+        # smallerMat = frame.asMatrix(smallerCols)
+        frameCols = frame.cols()
+        for i, row in enumerate(mat):
+            for j, value in enumerate(row):
+                col = frameCols[j]
+                if np.isnan(value):
+                    self.assert_(np.isnan(frame[col][i]))
+                else:
+                    self.assertEqual(value, frame[col][i])
+
+    def test_values(self):
+        pass
+
+    def test_deepcopy(self):
+        cp = deepcopy(self.frame)
+        series = cp['col1']
+        series[:] = 10
+        for idx, value in series.iteritems():
+            self.assertNotEqual(self.frame['col1'][idx], value)
+
+    def test_copy(self):
+        pass
+
+    def test_corr(self):
+        pass
+
+    def test_dropEmptyRows(self):
+        pass
+
+    def test_dropIncompleteRows(self):
+        pass
+
+    def test_fill(self):
+        pass
 
-    def testGetTS(self):
+    def test_getTS(self):
         frame = self.frame
         tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
         for i, idx in enumerate(tsFrame.index):
@@ -137,7 +218,51 @@ class TestDataFrame(unittest.TestCase):
                 else:
                     self.assertEqual(value, frame[col][idx])
 
-    def testTranspose(self):
+    def test_truncate(self):
+        pass
+
+    def test_getXS(self):
+        idx = self.frame.index[5]
+        xs = self.frame.getXS(idx)
+        for item, value in xs.iteritems():
+            if np.isnan(value):
+                self.assert_(np.isnan(self.frame[item][idx]))
+            else:
+                self.assertEqual(value, self.frame[item][idx])
+
+    def test_pivot(self):
+        pass
+
+    def test_reindex(self):
+        newFrame = self.frame.reindex(self.ts1.index)
+        for col in newFrame.cols():
+            for idx, val in newFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(np.isnan(val))
+        for col, series in newFrame.iteritems():
+            self.assert_(common.equalContents(series.index, newFrame.index))
+        emptyFrame = self.frame.reindex(Index([]))
+        self.assert_(len(emptyFrame.index) == 0)
+
+        nonContigFrame = self.frame.reindex(self.ts1.index[::2])
+        for col in nonContigFrame.cols():
+            for idx, val in nonContigFrame[col].iteritems():
+                if idx in self.frame.index:
+                    if np.isnan(val):
+                        self.assert_(np.isnan(self.frame[col][idx]))
+                    else:
+                        self.assertEqual(val, self.frame[col][idx])
+                else:
+                    self.assert_(np.isnan(val))
+        for col, series in nonContigFrame.iteritems():
+            self.assert_(common.equalContents(series.index, nonContigFrame.index))
+
+    def test_transpose(self):
         frame = self.frame
         dft = frame.T
         for idx, series in dft.iteritems():
@@ -147,47 +272,102 @@ class TestDataFrame(unittest.TestCase):
                 else:
                     self.assertEqual(value, frame[col][idx])
 
-    def testAsMatrix(self):
-        frame = self.frame
-        mat = frame.asMatrix()
-        smallerCols = ['col3', 'col1']
-        smallerMat = frame.asMatrix(smallerCols)
-        frameCols = frame.cols()
-        for i, row in enumerate(mat):
-            for j, value in enumerate(row):
-                col = frameCols[j]
-                if np.isnan(value):
-                    self.assert_(np.isnan(frame[col][i]))
-                else:
-                    self.assertEqual(value, frame[col][i])
+    def test_diff(self):
+        pass
 
-    def testDeepcopy(self):
-        cp = deepcopy(self.frame)
-        series = cp['col1']
-        series[:] = 10
-        for idx, value in series.iteritems():
-            self.assertNotEqual(self.frame['col1'][idx], value)
+    def test_shift(self):
+        shiftedFrame = self.frame.shift(5)
+        for i, idx in enumerate(shiftedFrame.index):
+            self.assert_(idx-5*bday == self.frame.index[i])
+        series = shiftedFrame['col1']
+        for i, idx in enumerate(series.index):
+            self.assert_(idx-5*bday == self.frame.index[i])
 
-    def testFilterItems(self):
+    def test_apply(self):
         pass
 
-    def testGroupBy(self):
+    def test_tapply(self):
+        pass
 
+    def test_applymap(self):
         pass
 
-    def testApply(self):
+    def test_tgroupby(self):
         pass
 
-    def testSort(self):
+    def test_filterItems(self):
         pass
 
-    def testFromDict(self):
-        newFrame = DataFrame.fromDict(col1=self.ts1, col2 = self.ts2)
-        for idx in newFrame.index:
-            if idx in self.ts1.index:
-                self.assertEqual(newFrame['col1'][idx], self.ts1[idx])
-            if idx in self.ts2.index:
-                self.assertEqual(newFrame['col2'][idx], self.ts2[idx])
+    def test_sortUp(self):
+        pass
+
+    def test_sortDown(self):
+        pass
+
+    def test_filterLike(self):
+        pass
+
+    def test_combineFirst(self):
+        pass
+
+    def test_combineAdd(self):
+        pass
+
+    def test_combineMult(self):
+        pass
+
+    def test_outerJoin(self):
+        pass
+
+    def test_leftJoin(self):
+        pass
+
+    def test_merge(self):
+        pass
+
+    def test_statistics(self):
+        sumFrame = self.frame.apply(np.sum)
+        for col, series in self.frame.iteritems():
+            self.assertEqual(sumFrame[col], series.sum())
+
+    def test_count(self):
+        pass
+
+    def test_sum(self):
+        pass
+
+    def test_product(self):
+        pass
+
+    def test_mean(self):
+        pass
+
+    def test_median(self):
+        pass
+
+    def test_min(self):
+        pass
+
+    def test_max(self):
+        pass
+
+    def test_mad(self):
+        pass
+
+    def test_var(self):
+        pass
+
+    def test_std(self):
+        pass
+
+    def test_skew(self):
+        pass
+
+    def test_withColumns(self):
+        pass
+
+    def testGroupBy(self):
+        pass
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_index.py b/pandas/core/tests/test_index.py
index f1ea91e5f..846385921 100644
--- a/pandas/core/tests/test_index.py
+++ b/pandas/core/tests/test_index.py
@@ -1,3 +1,4 @@
+from datetime import datetime
 from pandas.core.index import Index
 import pandas.core.tests.common as common
 import pandas.lib.tseries as tseries
@@ -12,65 +13,123 @@ class TestIndex(unittest.TestCase):
         self.dateIndex = common.makeStringIndex(100)
         self.intIndex = common.makeIntIndex(100)
 
-    def testSlice(self):
-        strSlice = self.strIndex[10:20]
-        dateSlice = self.dateIndex[10:20]
-        intSlice = self.intIndex[10:20]
-        strMap = tseries.map_indices(np.array(strSlice))
-        dateMap = tseries.map_indices(np.array(dateSlice))
-        intMap = tseries.map_indices(np.array(intSlice))
+    def test_duplicates(self):
+        self.assertRaises(Exception, Index, [0, 0, 0])
 
-        common.assert_dict_equal(strSlice.indexMap, strMap)
-        common.assert_dict_equal(dateSlice.indexMap, dateMap)
-        common.assert_dict_equal(intSlice.indexMap, intMap)
+    def test_sort(self):
+        self.assertRaises(Exception, self.strIndex.sort)
 
-    def testGetItem(self):
-        sl = self.strIndex[[1,2,3]]
-        for i in sl:
-            self.assertEqual(i, sl[sl.indexMap[i]])
+    def test_mutability(self):
+        self.assertRaises(Exception, self.strIndex.__setitem__, 5, 0)
+        self.assertRaises(Exception, self.strIndex.__setitem__, slice(1,5), 0)
+
+    def test_constructor(self):
+        # regular instance creation
+        common.assert_contains_all(self.strIndex, self.strIndex)
+        common.assert_contains_all(self.dateIndex, self.dateIndex)
+
+        # casting
+        arr = np.array(self.strIndex)
+        index = arr.view(Index)
+        common.assert_contains_all(arr, index)
+        self.assert_(np.array_equal(self.strIndex, index))
+
+    def test_equals(self):
+        # same
+        self.assert_(Index(['a', 'b', 'c']).equals(Index(['a', 'b', 'c'])))
+
+        # different length
+        self.assertFalse(Index(['a', 'b', 'c']).equals(Index(['a', 'b'])))
+
+        # same length, different values
+        self.assertFalse(Index(['a', 'b', 'c']).equals(Index(['a', 'b', 'd'])))
+
+    def test_asOfDate(self):
+        pass
+
+    def test_argsort(self):
+        result = self.strIndex.argsort()
+        expected = np.array(self.strIndex).argsort()
+        self.assert_(np.array_equal(result, expected))
+
+    def test_comparators(self):
+        index = self.dateIndex
+        element = index[len(index) // 2]
+        arr = np.array(index)
+
+        self.assert_(np.array_equal(arr == element, index == element))
+        self.assert_(np.array_equal(arr > element, index > element))
+        self.assert_(np.array_equal(arr < element, index < element))
+        self.assert_(np.array_equal(arr >= element, index >= element))
+        self.assert_(np.array_equal(arr <= element, index <= element))
+
+    def test_booleanindex(self):
         boolIdx = np.repeat(True, len(self.strIndex)).astype(bool)
         boolIdx[5:30:2] = False
+
         subIndex = self.strIndex[boolIdx]
-        strMap = tseries.map_indices(subIndex)
-        for key, value in strMap.iteritems():
-            self.assert_(subIndex.indexMap[key] == value)
+        common.assert_dict_equal(tseries.map_indices(subIndex),
+                                 subIndex.indexMap)
 
-    def testAdd(self):
+    def test_fancy(self):
+        sl = self.strIndex[[1,2,3]]
+        for i in sl:
+            self.assertEqual(i, sl[sl.indexMap[i]])
+
+    def test_getitem(self):
+        arr = np.array(self.dateIndex)
+        self.assertEquals(self.dateIndex[5], arr[5])
+
+    def test_add(self):
         firstCat = self.strIndex + self.dateIndex
         secondCat = self.strIndex + self.strIndex
-        self.assert_(common.equalContents(np.append(self.strIndex, self.dateIndex), firstCat))
+
+        self.assert_(common.equalContents(np.append(self.strIndex,
+                                                    self.dateIndex), firstCat))
         self.assert_(common.equalContents(secondCat, self.strIndex))
-        for key in self.strIndex:
-            self.assert_(key in firstCat.indexMap)
-            self.assert_(key in secondCat.indexMap)
-        for key in self.dateIndex:
-            self.assert_(key in firstCat.indexMap)
-
-    def testContains(self):
-        self.assert_(self.strIndex[10] in self.strIndex)
-        self.assert_(self.dateIndex[10] in self.dateIndex)
-        self.assert_(self.intIndex[10] in self.intIndex)
-        strSlice = self.strIndex[10:20]
-        dateSlice = self.dateIndex[10:20]
-        intSlice = self.intIndex[10:20]
-        self.assert_(self.strIndex[9] not in strSlice)
-        self.assert_(self.dateIndex[9] not in dateSlice)
-        self.assert_(self.intIndex[9] not in intSlice)
-
-    def testMutability(self):
-        self.assertRaises(Exception, self.strIndex.__setitem__, 5, 0)
-        self.assertRaises(Exception, self.strIndex.__setitem__, slice(1,5), 0)
+        common.assert_contains_all(self.strIndex, firstCat.indexMap)
+        common.assert_contains_all(self.strIndex, secondCat.indexMap)
+        common.assert_contains_all(self.dateIndex, firstCat.indexMap)
+
+    def test_intersection(self):
+        first = self.strIndex[:20]
+        second = self.strIndex[:10]
+        intersect = first.intersection(second)
+
+        self.assert_(common.equalContents(intersect, second))
+
+    def test_union(self):
+        first = self.strIndex[5:20]
+        second = self.strIndex[:10]
+        everything = self.strIndex[:20]
+        union = first.union(second)
+        self.assert_(common.equalContents(union, everything))
+
+    def test_diff(self):
+        first = self.strIndex[5:20]
+        second = self.strIndex[:10]
+        answer = self.strIndex[10:20]
+        result = first - second
+
+        self.assert_(common.equalContents(result, answer))
+
+    def test_pickle(self):
+        def testit(index):
+            f = open('tmp', 'wb')
+            pickle.dump(index, f)
+            f.close()
+
+            f = open('tmp', 'rb')
+            unPickled = pickle.load(f)
+            f.close()
+
+            os.remove('tmp')
+
+            self.assert_(isinstance(unPickled, Index))
+            self.assert_(np.array_equal(unPickled, index))
+
+            common.assert_dict_equal(unPickled.indexMap, index.indexMap)
+
+        testit(self.strIndex)
+        testit(self.dateIndex)
 
-    def testPickle(self):
-        f = open('tmp', 'wb')
-        pickle.dump(self.strIndex, f)
-        f.close()
-        f = open('tmp', 'rb')
-        unPickled = pickle.load(f)
-        f.close()
-        os.remove('tmp')
-        self.assert_(isinstance(unPickled, Index))
-        self.assert_(common.equalContents(unPickled, self.strIndex))
-        for k, v in self.strIndex.indexMap.iteritems():
-            self.assert_(k in unPickled.indexMap)
-            self.assertEqual(unPickled.indexMap[k], v)
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
new file mode 100644
index 000000000..b08a41812
--- /dev/null
+++ b/pandas/core/tests/test_matrix.py
@@ -0,0 +1,19 @@
+from copy import deepcopy
+from datetime import datetime
+import unittest
+
+from numpy.random import randn
+import numpy as np
+
+from pandas.core.api import DataMatrix
+import pandas.core.tests.test_frame as test_frame
+import pandas.core.tests.common as common
+
+#-------------------------------------------------------------------------------
+# DataMatrix test cases
+
+class TestDataMatrix(test_frame.TestDataFrame):
+    klass = DataMatrix
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 85e6e6471..74632b4de 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -1,7 +1,11 @@
+from copy import deepcopy
+import cPickle as pickle
+import os
 import unittest
 
 import numpy as np
 
+from pandas.core.series import Series
 import pandas.core.tests.common as common
 
 #-------------------------------------------------------------------------------
@@ -9,64 +13,64 @@ import pandas.core.tests.common as common
 
 class TestSeries(unittest.TestCase):
     def setUp(self):
-        index = Index([rands(10) for i in range(50)])
-        dateIndex = DateRange(datetime(2008,4,22), periods=50, offset=bday)
-        self.ts = Series(random.random(50), index=dateIndex)
-        self.series = Series(random.random(50), index=index)
-        self.objSeries = Series(dateIndex, index=index)
+        self.ts = common.makeTimeSeries()
+        self.series = common.makeStringSeries()
+        self.objSeries = common.makeObjectSeries()
 
-    def testSlice(self):
-        numSlice = self.series[10:20]
-        numSliceEnd = self.series[-10:]
-        objSlice = self.objSeries[10:20]
-        self.assert_(self.series.index[9] not in numSlice.index)
-        self.assert_(self.objSeries.index[9] not in objSlice.index)
-        self.assertEqual(len(numSlice), len(numSlice.index))
-        self.assertEqual(self.series[numSlice.index[0]], numSlice[numSlice.index[0]])
-        self.assertEqual(numSlice.index[1], self.series.index[11])
-        self.assert_(common.equalContents(numSliceEnd, array(self.series)[-10:]))
+    def test_constructor(self):
+        pass
 
-    def testGet(self):
-        self.assertEqual(self.series[5], self.series.get(self.series.index[5]))
+    def test_fromDict(self):
+        pass
 
-    def testGetItem(self):
+    def test_fromValue(self):
+        pass
+
+    def test_getitem(self):
         idx1 = self.series.index[5]
         idx2 = self.objSeries.index[5]
         self.assertEqual(self.series[idx1], self.series.get(idx1))
         self.assertEqual(self.objSeries[idx2], self.objSeries.get(idx2))
 
-    def testSetItem(self):
-        self.ts[self.ts.index[5]] = NaN
-        self.ts[[1,2,27]] = NaN
-        self.ts[6] = NaN
+    def test_fancy(self):
+        slice1 = self.series[[1,2,3]]
+        slice2 = self.objSeries[[1,2,3]]
+        self.assertEqual(self.series.index[2], slice1.index[1])
+        self.assertEqual(self.objSeries.index[2], slice2.index[1])
+        self.assertEqual(self.series[2], slice1[1])
+        self.assertEqual(self.objSeries[2], slice2[1])
+
+    def test_setitem(self):
+        self.ts[self.ts.index[5]] = np.NaN
+        self.ts[[1,2,17]] = np.NaN
+        self.ts[6] = np.NaN
         self.assert_(np.isnan(self.ts[6]))
         self.assert_(np.isnan(self.ts[2]))
         self.ts[np.isnan(self.ts)] = 5
         self.assert_(not np.isnan(self.ts[2]))
 
-    def testSetSlice(self):
+    def test_setslice(self):
         slice = self.ts[5:20]
         self.assertEqual(len(slice), len(slice.index))
         self.assertEqual(len(slice.index.indexMap), len(slice.index))
 
-    def testGetSequence(self):
-        slice1 = self.series[[1,2,3]]
-        slice2 = self.objSeries[[1,2,3]]
-        self.assertEqual(self.series.index[2], slice1.index[1])
-        self.assertEqual(self.objSeries.index[2], slice2.index[1])
-        self.assertEqual(self.series[2], slice1[1])
-        self.assertEqual(self.objSeries[2], slice2[1])
+    def test_repr(self):
+        pass
 
-    def testMeta(self):
-        wrapped = Series(self.series)
-        self.assert_(common.equalContents(wrapped.index, self.series.index))
-        # Ensure new index is not created
-        self.assertEquals(id(self.series.index), id(wrapped.index))
+    def test_iter(self):
+        for i, val in enumerate(self.series):
+            self.assertEqual(val, self.series[i])
+        for i, val in enumerate(self.ts):
+            self.assertEqual(val, self.ts[i])
+        for idx, val in self.series.iteritems():
+            self.assertEqual(val, self.series[idx])
+        for idx, val in self.ts.iteritems():
+            self.assertEqual(val, self.ts[idx])
 
-    def testStatistics(self):
-        self.series[5:15] = NaN
+    def test_stats(self):
+        self.series[5:15] = np.NaN
 
-        s1 = array(self.series)
+        s1 = np.array(self.series)
         s1 = s1[-np.isnan(s1)]
         self.assertEquals(np.mean(s1), self.series.mean())
         self.assertEquals(np.std(s1, ddof=1), self.series.std())
@@ -77,7 +81,104 @@ class TestSeries(unittest.TestCase):
         self.assert_(not np.isnan(np.std(self.series)))
         self.assert_(not np.isnan(np.var(self.series)))
 
-    def testPickle(self):
+    def test_keys(self):
+        pass
+
+    def test_values(self):
+        pass
+
+    def test_iteritems(self):
+        pass
+
+    def test_get(self):
+        self.assertEqual(self.series[5], self.series.get(self.series.index[5]))
+
+    def test_append(self):
+        appendedSeries = self.series.append(self.ts)
+        for idx, value in appendedSeries.iteritems():
+            if idx in self.series.index:
+                self.assertEqual(value, self.series[idx])
+            elif idx in self.ts.index:
+                self.assertEqual(value, self.ts[idx])
+            else:
+                self.fail("orphaned index!")
+
+    def test_combineFunc(self):
+        shiftedSum = self.ts + self.ts.shift(5)
+        idSum = self.ts + self.ts
+        self.assert_(np.isnan(shiftedSum[0]))
+        for idx, val in idSum.iteritems():
+            self.assertAlmostEqual(self.ts[idx] + self.ts[idx], val)
+        multiplied = self.ts * 5
+        for idx, val in multiplied.iteritems():
+            self.assertEqual(self.ts[idx] * 5, val)
+
+    def test_combineFirst(self):
+        pass
+
+    def test_argsort(self):
+        pass
+
+    def test_cumsum(self):
+        pass
+
+    def test_cumprod(self):
+        pass
+
+    def test_copy(self):
+        pass
+
+    def test_corr(self):
+        pass
+
+    def test_count(self):
+        pass
+
+    def test_median(self):
+        pass
+
+    def test_sort(self):
+        pass
+
+    def test_order(self):
+        pass
+
+    def test_map(self):
+        pass
+
+    def test_toCSV(self):
+        pass
+
+    def test_toDict(self):
+        pass
+
+    def test_cap(self):
+        pass
+
+    def test_floor(self):
+        pass
+
+    def test_valid(self):
+        pass
+
+    def test_truncate(self):
+        pass
+
+    def test_meta(self):
+        wrapped = Series(self.series)
+        self.assert_(common.equalContents(wrapped.index, self.series.index))
+        # Ensure new index is not created
+        self.assertEquals(id(self.series.index), id(wrapped.index))
+
+    def test_asOf(self):
+        self.ts[5:10] = np.NaN
+        self.ts[15:20] = np.NaN
+        val1 = self.ts.asOf(self.ts.index[7])
+        val2 = self.ts.asOf(self.ts.index[19])
+        self.assertEqual(val1, self.ts[4])
+        self.assertEqual(val2, self.ts[14])
+
+    def test_pickle(self):
         f = open('tmp1', 'wb')
         h = open('tmp3', 'wb')
         pickle.dump(self.series, f)
@@ -103,17 +204,7 @@ class TestSeries(unittest.TestCase):
             self.assert_(idx in unPickledh.index)
             self.assertEqual(unPickledh[idx], self.ts[idx])
 
-    def testIter(self):
-        for i, val in enumerate(self.series):
-            self.assertEqual(val, self.series[i])
-        for i, val in enumerate(self.ts):
-            self.assertEqual(val, self.ts[i])
-        for idx, val in self.series.iteritems():
-            self.assertEqual(val, self.series[idx])
-        for idx, val in self.ts.iteritems():
-            self.assertEqual(val, self.ts[idx])
-
-    def testFromIndex(self):
+    def test_reindex(self):
         identity = self.series.reindex(self.series.index)
         self.assertEqual(id(self.series.index), id(identity.index))
         subIndex = self.series.index[10:20]
@@ -125,7 +216,7 @@ class TestSeries(unittest.TestCase):
         for idx, val in subTS.iteritems():
             self.assertEqual(val, self.ts[idx])
         crapSeries = self.ts.reindex(subIndex)
-        self.assert_(alltrue(np.isnan(crapSeries)))
+        self.assert_(np.isnan(crapSeries).all())
 
         # This is extremely important for the Cython code to not screw up
         nonContigIndex = self.ts.index[::2]
@@ -133,19 +224,9 @@ class TestSeries(unittest.TestCase):
         for idx, val in subNonContig.iteritems():
             self.assertEqual(val, self.ts[idx])
 
-    def testCombineFunc(self):
-        shiftedSum = self.ts + self.ts.shift(5)
-        idSum = self.ts + self.ts
-        self.assert_(np.isnan(shiftedSum[0]))
-        for idx, val in idSum.iteritems():
-            self.assertAlmostEqual(self.ts[idx] + self.ts[idx], val)
-        multiplied = self.ts * 5
-        for idx, val in multiplied.iteritems():
-            self.assertEqual(self.ts[idx] * 5, val)
-
-    def testOperators(self):
+    def test_operators(self):
         newSeries = deepcopy(self.series)
-        newSeries[5:10] = NaN
+        newSeries[5:10] = np.NaN
         newSeries[10:20] = newSeries[10:20] + 1
         newSeries[20:30] = newSeries[20:30] - 1
         eqSeries = (newSeries == self.series)
@@ -156,40 +237,64 @@ class TestSeries(unittest.TestCase):
         self.assertTrue(gtSeries[10])
         self.assertFalse(gtSeries[20])
 
+    def test_preserveRefs(self):
+        slice = self.ts[5:10]
+        seq = self.ts[[5,10,15]]
+        slice[4] = np.NaN
+        seq[1] = np.NaN
+        self.assertFalse(np.isnan(self.ts[9]))
+        self.assertFalse(np.isnan(self.ts[10]))
+
+class TestTimeSeries(unittest.TestCase):
+    def setUp(self):
+        self.ts = common.makeTimeSeries()
+        self.series = common.makeStringSeries()
+        self.objSeries = common.makeObjectSeries()
 
-    def testShift(self):
+    def test_shift(self):
         shifted = self.ts.shift(1)
         unshifted = shifted.shift(-1)
-        #self.assert_(common.equalContents(self.ts.index, unshifted.index))
         idxMap = self.ts.index.indexMap
         for k, v in unshifted.iteritems():
             self.assertEqual(self.ts[idxMap[k]], v)
 
-    def testAsOf(self):
-        self.ts[5:10] = NaN
-        self.ts[15:20] = NaN
-        val1 = self.ts.asOf(self.ts.index[7])
-        val2 = self.ts.asOf(self.ts.index[19])
-        self.assertEqual(val1, self.ts[4])
-        self.assertEqual(val2, self.ts[14])
+    def test_slice(self):
+        numSlice = self.series[10:20]
+        numSliceEnd = self.series[-10:]
+        objSlice = self.objSeries[10:20]
+        self.assert_(self.series.index[9] not in numSlice.index)
+        self.assert_(self.objSeries.index[9] not in objSlice.index)
+        self.assertEqual(len(numSlice), len(numSlice.index))
+        self.assertEqual(self.series[numSlice.index[0]], numSlice[numSlice.index[0]])
+        self.assertEqual(numSlice.index[1], self.series.index[11])
+        self.assert_(common.equalContents(numSliceEnd, np.array(self.series)[-10:]))
 
-    def testPreserveReferences(self):
-        slice = self.ts[5:10]
-        seq = self.ts[[5,10,15]]
-        slice[4] = NaN
-        seq[1] = NaN
-        self.assertFalse(np.isnan(self.ts[9]))
-        self.assertFalse(np.isnan(self.ts[10]))
+    def test_fill(self):
+        pass
 
-    def testAppend(self):
-        appendedSeries = self.series.append(self.ts)
-        for idx, value in appendedSeries.iteritems():
-            if idx in self.series.index:
-                self.assertEqual(value, self.series[idx])
-            elif idx in self.ts.index:
-                self.assertEqual(value, self.ts[idx])
-            else:
-                self.fail("orphaned index!")
+    def test_asfreq(self):
+        pass
+
+    def test_interpolate(self):
+        pass
+
+    def test_weekday(self):
+        pass
+
+    def test_diff(self):
+        pass
+
+    def test_autocorr(self):
+        pass
+
+    def test_firstValid(self):
+        pass
+
+    def test_lastValid(self):
+        pass
+
+    def test_reindex(self):
+        pass
 
 if __name__ == '__main__':
     unittest.main()

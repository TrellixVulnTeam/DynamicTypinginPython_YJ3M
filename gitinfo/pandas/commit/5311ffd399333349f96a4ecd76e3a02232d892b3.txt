commit 5311ffd399333349f96a4ecd76e3a02232d892b3
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Oct 22 16:08:06 2009 +0000

    added sandbox directory and restricted least-squares class
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@34 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3234f10f8..2367c152f 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -4,32 +4,32 @@ from pandas.lib.tseries import map_indices
 
 
 class Index(np.ndarray):
-    """Extension of numpy-array to represent a series index, 
+    """Extension of numpy-array to represent a series index,
     dates or otherwise.
-    
+
     Index is immutable always (don't even try to change elements!).
-    
+
     Note that the Index can ONLY contain immutable objects. Mutable objects are not
     hashable, and that's bad!
     """
-    _md5 = None
+    __md5 = None
     def __new__(cls, data, dtype=object, copy=False):
         subarr = np.array(data, dtype=dtype, copy=copy)
-        
+
         if subarr.ndim == 0:
             raise Exception('Index(...) must be called with a collection '
                             'of some kind, %s was passed' % repr(data))
-            
+
         subarr = subarr.view(cls)
         return subarr
-    
+
     def __array_finalize__(self, obj):
         if self.ndim == 0:
             return self.item()
 
         if len(self) > 0:
             self.indexMap = map_indices(self)
-            
+
             if hasattr(obj, '_allDates'):
                 self._allDates = obj._allDates
             else:
@@ -37,25 +37,25 @@ class Index(np.ndarray):
         else:
             self.indexMap = {}
             self._allDates = False
-    
+
     def __setstate__(self,state):
         """Necessary for making this object picklable"""
         np.ndarray.__setstate__(self,state)
         self.indexMap = map_indices(self)
         self._allDates = isAllDates(self)
-        
+
     def __deepcopy__(self, memo={}):
         """
         Index is not mutable, so disabling deepcopy
         """
         return self
-        
+
     def __contains__(self, date):
         return date in self.indexMap
-        
+
     def __setitem__(self, key, value):
         """Disable the setting of values."""
-        raise Exception(str(self.__class__) + ' object is immutable' ) 
+        raise Exception(str(self.__class__) + ' object is immutable' )
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
@@ -74,33 +74,34 @@ class Index(np.ndarray):
         """
         if self is other:
             return True
-        
-        if not isinstance(other, np.ndarray):
+
+        if not isinstance(other, Index):
             return False
 
         if len(self) != len(other):
             return False
 
-        return self.getMD5() == other.getMD5()
+        return self._md5 == other._md5
 
     def _computeMD5(self):
         import hashlib
         m = hashlib.md5(self.tostring())
-        return m.hexdigest()        
-    
-    def getMD5(self):
+        return m.hexdigest()
+
+    @property
+    def _md5(self):
         """
         Return MD5 hex-digested hash for the Index elements. Note that
         this quantity is only computed once.
         """
-        if self._md5 is None:
-            self._md5 = self._computeMD5()
-            
-        return self._md5
-    
+        if self.__md5 is None:
+            self.__md5 = self._computeMD5()
+
+        return self.__md5
+
     def asOfDate(self, date):
         import bisect
-        
+
         if date not in self.indexMap:
             loc = bisect.bisect(self, date)
             if loc > 0:
@@ -108,7 +109,7 @@ class Index(np.ndarray):
             else:
                 return None
         return date
-        
+
     def sort(self, *args, **kwargs):
         raise Exception('Tried to sort an Index object, too dangerous to be OK!')
 
@@ -121,18 +122,18 @@ class Index(np.ndarray):
     def union(self, other):
         """
         Form the union of two Index objects and sorts if possible
-        
+
         Parameters
         ----------
         other: Index or array-like
-        
+
         Returns
         -------
         Index
         """
         if not hasattr(other, '__iter__'):
             raise Exception('Input must be iterable!')
-        
+
         if other is self:
             return self
         newElts = filter(lambda x: x not in self.indexMap, other)
@@ -146,15 +147,15 @@ class Index(np.ndarray):
             return Index(newSeq)
         else:
             return self
-    
+
     def intersection(self, other):
         """
         Form the intersection of two Index objects and sorts if possible
-        
+
         Parameters
         ----------
         other: Index or array-like
-        
+
         Returns
         -------
         Index
@@ -163,7 +164,7 @@ class Index(np.ndarray):
             raise Exception('Input must be iterable!')
 
         if other is self:
-            return self        
+            return self
         otherArr = np.asarray(other)
         theIntersection = sorted(set(self) & set(other))
         return Index(theIntersection)
@@ -171,17 +172,17 @@ class Index(np.ndarray):
     def diff(self, other):
         if not hasattr(other, '__iter__'):
             raise Exception('Input must be iterable!')
-        
+
         if other is self:
             return Index([])
 
         otherArr = np.asarray(other)
         theDiff = sorted(set(self) - set(otherArr))
         return Index(theDiff)
-    
+
     __sub__ = diff
 
 # For utility purposes
 
 NULL_INDEX = Index([])
-        
+
diff --git a/pandas/sandbox/__init__.py b/pandas/sandbox/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/sandbox/stats/__init__.py b/pandas/sandbox/stats/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/sandbox/stats/rls.py b/pandas/sandbox/stats/rls.py
new file mode 100644
index 000000000..855c8d4b1
--- /dev/null
+++ b/pandas/sandbox/stats/rls.py
@@ -0,0 +1,137 @@
+"""Restricted least squares"""
+
+import numpy as np
+from scikits.statsmodels.regression import WLS, GLS, RegressionResults
+
+class RLS(GLS):
+    """
+    Restricted general least squares model that handles linear constraints
+
+    Parameters
+    ----------
+    endog: array-like
+        n length array containing the dependent variable
+    exog: array-like
+        n-by-p array of independent variables
+    constr: array-like
+        k-by-p array of linear constraints
+    param (0.): array-like or scalar
+        p-by-1 array (or scalar) of constraint parameters
+    sigma (None): scalar or array-like
+        The weighting matrix of the covariance. No scaling by default (OLS).
+        If sigma is a scalar, then it is converted into an n-by-n diagonal
+        matrix with sigma as each diagonal element.
+        If sigma is an n-length array, then it is assumed to be a diagonal
+        matrix with the given sigma on the diagonal (WLS).
+
+    Notes
+    -----
+    endog = exog * beta + epsilon
+    weights' * constr * beta = param
+
+    See Greene and Seaks, "The Restricted Least Squares Estimator:
+    A Pedagogical Note", The Review of Economics and Statistics, 1991.
+    """
+
+    def __init__(self, endog, exog, constr, param=0., sigma=None):
+        N, Q = exog.shape
+        if constr.ndim == 1:
+            K, P = 1, constr.shape[0]
+        else:
+            K, P = constr.shape
+        if Q != P:
+            raise Exception('Constraints and design do not align')
+        self.ncoeffs = Q
+        self.nconstraint = K
+        self.constraint = constr
+        if np.isscalar(param) and K > 1:
+            param = np.ones((K,)) * param
+        self.param = param
+        if sigma is None:
+            sigma = 1.
+        if np.isscalar(sigma):
+            sigma = np.ones(N) * sigma
+        sigma = np.squeeze(sigma)
+        if sigma.ndim == 1:
+            self.sigma = np.diag(sigma)
+            self.cholsigmainv = np.diag(np.sqrt(sigma))
+        else:
+            self.sigma = sigma
+            self.cholsigmainv = np.linalg.cholesky(np.linalg.pinv(self.sigma)).T
+        super(GLS, self).__init__(endog, exog)
+
+    _rwexog = None
+    @property
+    def rwexog(self):
+        """Whitened exogenous variables augmented with restrictions"""
+        if self._rwexog is None:
+            P = self.ncoeffs
+            K = self.nconstraint
+            design = np.zeros((P + K, P + K))
+            design[:P, :P] = np.dot(self.wexog.T, self.wexog) #top left
+            constr = np.reshape(self.constraint, (K, P))
+            design[:P, P:] = constr.T #top right partition
+            design[P:, :P] = constr #bottom left partition
+            design[P:, P:] = np.zeros((K, K)) #bottom right partition
+            self._rwexog = design
+        return self._rwexog
+
+    _inv_rwexog = None
+    @property
+    def inv_rwexog(self):
+        """Inverse of self.rwexog"""
+        if self._inv_rwexog is None:
+            self._inv_rwexog = np.linalg.inv(self.rwexog)
+        return self._inv_rwexog
+
+    _rwendog = None
+    @property
+    def rwendog(self):
+        """Whitened endogenous variable augmented with restriction parameters"""
+        if self._rwendog is None:
+            P = self.ncoeffs
+            K = self.nconstraint
+            response = np.zeros((P + K,))
+            response[:P] = np.dot(self.wexog.T, self.wendog)
+            response[P:] = self.param
+            self._rwendog = response
+        return self._rwendog
+
+    _ncp = None
+    @property
+    def rnorm_cov_params(self):
+        """Parameter covariance under restrictions"""
+        if self._ncp is None:
+            P = self.ncoeffs
+            self._ncp = self.inv_rwexog[:P, :P]
+        return self._ncp
+
+    _wncp = None
+    @property
+    def wrnorm_cov_params(self):
+        """
+        Heteroskedasticity-consistent parameter covariance
+        Used to calculate White standard errors.
+        """
+        if self._wncp is None:
+            df = self.df_resid
+            pred = np.dot(self.wexog, self.coeffs)
+            eps = np.diag((self.wendog - pred) ** 2)
+            sigmaSq = np.sum(eps)
+            pinvX = np.dot(self.rnorm_cov_params, self.wexog.T)
+            self._wncp = np.dot(np.dot(pinvX, eps), pinvX.T) * df / sigmaSq
+        return self._wncp
+
+    _coeffs = None
+    @property
+    def coeffs(self):
+        """Estimated parameters"""
+        if self._coeffs is None:
+            betaLambda = np.dot(self.inv_rwexog, self.rwendog)
+            self._coeffs = betaLambda[:self.ncoeffs]
+        return self._coeffs
+
+    def fit(self):
+        rncp = self.wrnorm_cov_params
+        lfit = RegressionResults(self, self.coeffs, normalized_cov_params=rncp)
+        return lfit

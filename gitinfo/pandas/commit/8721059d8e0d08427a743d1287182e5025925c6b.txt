commit 8721059d8e0d08427a743d1287182e5025925c6b
Author: y-p <yoval@gmx.com>
Date:   Sat Dec 1 04:25:34 2012 +0200

    ENH: dynamic docstrings for options API

diff --git a/pandas/core/config.py b/pandas/core/config.py
index dff60162c..aa7e61d48 100644
--- a/pandas/core/config.py
+++ b/pandas/core/config.py
@@ -53,40 +53,25 @@ import re
 from collections import namedtuple
 import warnings
 
-DeprecatedOption = namedtuple("DeprecatedOption", "key msg rkey removal_ver")
-RegisteredOption = namedtuple("RegisteredOption", "key defval doc validator")
+DeprecatedOption = namedtuple('DeprecatedOption', 'key msg rkey removal_ver')
+RegisteredOption = namedtuple('RegisteredOption', 'key defval doc validator')
+
+_deprecated_options = {}  # holds deprecated option metdata
+_registered_options = {}  # holds registered option metdata
+_global_config = {}  # holds the current values for registered options
+_reserved_keys = ['all']  # keys which have a special meaning
 
-__deprecated_options = {} # holds deprecated option metdata
-__registered_options = {} # holds registered option metdata
-__global_config = {}      # holds the current values for registered options
-__reserved_keys = ["all"] # keys which have a special meaning
 
 ##########################################
 # User API
 
-
-def get_option(pat):
-    """Retrieves the value of the specified option
-
-    Parameters
-    ----------
-    pat - str/regexp which should match a single option.
-
-    Returns
-    -------
-    result - the value of the option
-
-    Raises
-    ------
-    KeyError if no such option exists
-    """
-
+def _get_option(pat):
     keys = _select_options(pat)
     if len(keys) == 0:
         _warn_if_deprecated(pat)
-        raise KeyError("No such keys(s)")
+        raise KeyError('No such keys(s)')
     if len(keys) > 1:
-        raise KeyError("Pattern matched multiple keys")
+        raise KeyError('Pattern matched multiple keys')
     key = keys[0]
 
     _warn_if_deprecated(key)
@@ -99,27 +84,14 @@ def get_option(pat):
     return root[k]
 
 
-def set_option(pat, value):
-    """Sets the value of the specified option
+def _set_option(pat, value):
 
-    Parameters
-    ----------
-    pat - str/regexp which should match a single option.
-
-    Returns
-    -------
-    None
-
-    Raises
-    ------
-    KeyError if no such option exists
-    """
     keys = _select_options(pat)
     if len(keys) == 0:
         _warn_if_deprecated(pat)
-        raise KeyError("No such keys(s)")
+        raise KeyError('No such keys(s)')
     if len(keys) > 1:
-        raise KeyError("Pattern matched multiple keys")
+        raise KeyError('Pattern matched multiple keys')
     key = keys[0]
 
     _warn_if_deprecated(key)
@@ -134,73 +106,173 @@ def set_option(pat, value):
     root[k] = value
 
 
-def describe_option(pat="",_print_desc=True):
-    """ Prints the description for one or more registered options
+def _describe_option(pat='', _print_desc=True):
 
-    Call with not arguments to get a listing for all registered options.
-
-    Parameters
-    ----------
-    pat - str, a regexp pattern. All matching keys will have their
-          description displayed.
-
-    _print_desc - if True (default) the description(s) will be printed
-                 to stdout otherwise, the description(s) will be returned
-                 as a unicode string (for testing).
-
-    Returns
-    -------
-    None by default, the description(s) as a unicode string if _print_desc
-    is False
-
-    """
     keys = _select_options(pat)
     if len(keys) == 0:
-        raise KeyError("No such keys(s)")
+        raise KeyError('No such keys(s)')
 
-    s=u""
-    for k in keys: # filter by pat
+    s = u''
+    for k in keys:  # filter by pat
         s += _build_option_description(k)
 
     if _print_desc:
-        print(s)
+        print s
     else:
-        return(s)
+        return s
 
-def reset_option(pat):
-    """Reset one or more options to their default value.
 
-    pass "all" as argument to reset all options.
-
-    Parameters
-    ----------
-    pat - str/regex  if specified only options matching `prefix`* will be reset
-
-    Returns
-    -------
-    None
+def _reset_option(pat):
 
-    """
     keys = _select_options(pat)
 
-    if pat == u"":
-        raise ValueError("You must provide a non-empty pattern")
+    if pat == u'':
+        raise ValueError('You must provide a non-empty pattern')
 
     if len(keys) == 0:
-        raise KeyError("No such keys(s)")
+        raise KeyError('No such keys(s)')
 
-    if len(keys) > 1 and len(pat)<4 and pat != "all":
-        raise ValueError("You must specify at least 4 characters "
-                         "when resetting multiple keys")
+    if len(keys) > 1 and len(pat) < 4 and pat != 'all':
+        raise ValueError('You must specify at least 4 characters when '
+                         'resetting multiple keys')
 
     for k in keys:
-        set_option(k, __registered_options[k].defval)
+        _set_option(k, _registered_options[k].defval)
+
+
+# For user convenience,  we'd like to have the available options described
+# in the docstring. For dev convenience we'd like to generate the docstrings
+# dynamically instead of maintaining them by hand. To this, we use the
+# class below which wraps functions inside a callable, and converts
+# __doc__ into a propery function. The doctsrings below are templates
+# using the py2.6+ advanced formatting syntax to plug in a concise list
+# of options, and option descriptions.
+
+class CallableDyanmicDoc(object):
+
+    def __init__(self, func, doc_tmpl):
+        self.__doc_tmpl__ = doc_tmpl
+        self.__func__ = func
+
+    def __call__(self, *args, **kwds):
+        return self.__func__(*args, **kwds)
+
+    @property
+    def __doc__(self):
+        opts_desc = _describe_option('all', _print_desc=False)
+        opts_list = pp_options_list(_registered_options.keys())
+        return self.__doc_tmpl__.format(opts_desc=opts_desc,
+                opts_list=opts_list)
+
+_get_option_tmpl = """"get_option(pat) - Retrieves the value of the specified option
+
+Available options:
+{opts_list}
+
+Parameters
+----------
+pat - str/regexp which should match a single option.
+
+Note: partial matches are supported for convenience, but unless you use the
+full option name (e.g. x.y.z.option_name), your code may break in future
+versions if new options with similar names are introduced.
+
+Returns
+-------
+result - the value of the option
+
+Raises
+------
+KeyError if no such option exists
+
+{opts_desc}
+"""
+
+_set_option_tmpl="""set_option(pat,value) - Sets the value of the specified option
+
+Available options:
+{opts_list}
+
+Parameters
+----------
+pat - str/regexp which should match a single option.
+
+Note: partial matches are supported for convenience, but unless you use the
+full option name (e.g. x.y.z.option_name), your code may break in future
+versions if new options with similar names are introduced.
+
+value - new value of function.
+
+Returns
+-------
+None
+
+Raises
+------
+KeyError if no such option exists
+
+{opts_desc}
+"""
+
+_describe_option_tmpl="""describe_option(pat,_print_desc=False) Prints the description
+for one or more registered options.
+
+Call with not arguments to get a listing for all registered options.
+
+Available options:
+{opts_list}
+
+Parameters
+----------
+pat - str, a regexp pattern. All matching keys will have their
+      description displayed.
+
+_print_desc - if True (default) the description(s) will be printed
+             to stdout otherwise, the description(s) will be returned
+             as a unicode string (for testing).
+
+Returns
+-------
+None by default, the description(s) as a unicode string if _print_desc
+is False
+
+{opts_desc}
+"""
+
+_reset_option_tmpl="""reset_option(pat) - Reset one or more options to their default value.
+
+Pass "all" as argument to reset all options.
+
+Available options:
+{opts_list}
+
+Parameters
+----------
+pat - str/regex  if specified only options matching `prefix`* will be reset
+
+Note: partial matches are supported for convenience, but unless you use the
+full option name (e.g. x.y.z.option_name), your code may break in future
+versions if new options with similar names are introduced.
+
+Returns
+-------
+None
+
+{opts_desc}
+"""
+
+# bind the functions with their docstrings into a Callable
+# and use that as the functions exposed in pd.api
+get_option = CallableDyanmicDoc(_get_option, _get_option_tmpl)
+set_option = CallableDyanmicDoc(_set_option, _set_option_tmpl)
+reset_option = CallableDyanmicDoc(_reset_option, _reset_option_tmpl)
+describe_option = CallableDyanmicDoc(_describe_option, _describe_option_tmpl)
+
 
 ######################################################
 # Functions for use by pandas developers, in addition to User - api
 
-
-def register_option(key, defval, doc="", validator=None):
+def register_option(key, defval, doc='', validator=None):
     """Register an option in the package-wide pandas config object
 
     Parameters
@@ -221,11 +293,11 @@ def register_option(key, defval, doc="", validator=None):
 
     """
 
-    key=key.lower()
+    key = key.lower()
 
-    if key in __registered_options:
+    if key in _registered_options:
         raise KeyError("Option '%s' has already been registered" % key)
-    if key in __reserved_keys:
+    if key in _reserved_keys:
         raise KeyError("Option '%s' is a reserved key" % key)
 
     # the default value should be legal
@@ -233,25 +305,25 @@ def register_option(key, defval, doc="", validator=None):
         validator(defval)
 
     # walk the nested dict, creating dicts as needed along the path
-    path = key.split(".")
-    cursor = __global_config
-    for i,p in enumerate(path[:-1]):
-        if not isinstance(cursor,dict):
-            raise KeyError("Path prefix to option '%s' is already an option" %\
-                           ".".join(path[:i]))
+    path = key.split('.')
+    cursor = _global_config
+    for i, p in enumerate(path[:-1]):
+        if not isinstance(cursor, dict):
+            raise KeyError("Path prefix to option '%s' is already an option"
+                           % '.'.join(path[:i]))
         if not cursor.has_key(p):
             cursor[p] = {}
         cursor = cursor[p]
 
-    if not isinstance(cursor,dict):
-        raise KeyError("Path prefix to option '%s' is already an option" %\
-                       ".".join(path[:-1]))
+    if not isinstance(cursor, dict):
+        raise KeyError("Path prefix to option '%s' is already an option"
+                       % '.'.join(path[:-1]))
 
-    cursor[path[-1]] = defval # initialize
+    cursor[path[-1]] = defval  # initialize
 
     # save the option metadata
-    __registered_options[key] = RegisteredOption(key=key, defval=defval,
-                                                 doc=doc, validator=validator)
+    _registered_options[key] = RegisteredOption(key=key, defval=defval,
+            doc=doc, validator=validator)
 
 
 def deprecate_option(key, msg=None, rkey=None, removal_ver=None):
@@ -292,12 +364,15 @@ def deprecate_option(key, msg=None, rkey=None, removal_ver=None):
     KeyError - if key has already been deprecated.
 
     """
-    key=key.lower()
 
-    if key in __deprecated_options:
-        raise KeyError("Option '%s' has already been defined as deprecated." % key)
+    key = key.lower()
+
+    if key in _deprecated_options:
+        raise KeyError("Option '%s' has already been defined as deprecated."
+                       % key)
+
+    _deprecated_options[key] = DeprecatedOption(key, msg, rkey, removal_ver)
 
-    __deprecated_options[key] = DeprecatedOption(key, msg, rkey,removal_ver)
 
 ################################
 # functions internal to the module
@@ -307,16 +382,17 @@ def _select_options(pat):
 
     if pat=="all", returns all registered options
     """
-    keys = sorted(__registered_options.keys())
-    if pat == "all": # reserved key
+
+    keys = sorted(_registered_options.keys())
+    if pat == 'all':  # reserved key
         return keys
 
-    return [k for k in keys if re.search(pat,k,re.I)]
+    return [k for k in keys if re.search(pat, k, re.I)]
 
 
 def _get_root(key):
-    path = key.split(".")
-    cursor = __global_config
+    path = key.split('.')
+    cursor = _global_config
     for p in path[:-1]:
         cursor = cursor[p]
     return cursor, path[-1]
@@ -326,7 +402,7 @@ def _is_deprecated(key):
     """ Returns True if the given option has been deprecated """
 
     key = key.lower()
-    return __deprecated_options.has_key(key)
+    return _deprecated_options.has_key(key)
 
 
 def _get_deprecated_option(key):
@@ -337,8 +413,9 @@ def _get_deprecated_option(key):
     -------
     DeprecatedOption (namedtuple) if key is deprecated, None otherwise
     """
+
     try:
-        d = __deprecated_options[key]
+        d = _deprecated_options[key]
     except KeyError:
         return None
     else:
@@ -353,8 +430,9 @@ def _get_registered_option(key):
     -------
     RegisteredOption (namedtuple) if key is deprecated, None otherwise
     """
+
     try:
-        d = __registered_options[key]
+        d = _registered_options[key]
     except KeyError:
         return None
     else:
@@ -366,6 +444,7 @@ def _translate_key(key):
     if key id deprecated and a replacement key defined, will return the
     replacement key, otherwise returns `key` as - is
     """
+
     d = _get_deprecated_option(key)
     if d:
         return d.rkey or key
@@ -389,34 +468,65 @@ def _warn_if_deprecated(key):
         else:
             msg = "'%s' is deprecated" % key
             if d.removal_ver:
-                msg += " and will be removed in %s" % d.removal_ver
+                msg += ' and will be removed in %s' % d.removal_ver
             if d.rkey:
-                msg += (", please use '%s' instead." % (d.rkey))
+                msg += ", please use '%s' instead." % d.rkey
             else:
-                msg += (", please refrain from using it.")
+                msg += ', please refrain from using it.'
 
             warnings.warn(msg, DeprecationWarning)
         return True
     return False
 
+
 def _build_option_description(k):
     """ Builds a formatted description of a registered option and prints it """
 
     o = _get_registered_option(k)
     d = _get_deprecated_option(k)
-    s = u'%s: ' %k
+    s = u'%s: ' % k
     if o.doc:
-        s += "\n" +"\n    ".join(o.doc.split("\n"))
+        s += '\n' + '\n    '.join(o.doc.strip().split('\n'))
     else:
-        s += "No description available.\n"
+        s += 'No description available.\n'
 
     if d:
-        s += u"\n\t(Deprecated"
-        s += u", use `%s` instead." % d.rkey if d.rkey else ""
-        s += u")\n"
-
-    s += "\n"
-    return(s)
+        s += u'\n\t(Deprecated'
+        s += (u', use `%s` instead.' % d.rkey if d.rkey else '')
+        s += u')\n'
+
+    s += '\n'
+    return s
+
+
+def pp_options_list(keys, width=80, _print=False):
+    """ Builds a concise listing of available options, grouped by prefix """
+
+    from textwrap import wrap
+    from itertools import groupby
+
+    def pp(name, ks):
+        pfx = (name + '.[' if name else '')
+        ls = wrap(', '.join(ks), width, initial_indent=pfx,
+                  subsequent_indent=' ' * len(pfx), break_long_words=False)
+        if ls and ls[-1] and name:
+            ls[-1] = ls[-1] + ']'
+        return ls
+
+    ls = []
+    singles = [x for x in sorted(keys) if x.find('.') < 0]
+    if singles:
+        ls += pp('', singles)
+    keys = [x for x in keys if x.find('.') >= 0]
+
+    for k, g in groupby(sorted(keys), lambda x: x[:x.rfind('.')]):
+        ks = [x[len(k) + 1:] for x in list(g)]
+        ls += pp(k, ks)
+    s = '\n'.join(ls)
+    if _print:
+        print s
+    else:
+        return s
 
 
 ##############
@@ -449,15 +559,18 @@ def config_prefix(prefix):
     will register options "display.font.color", "display.font.size", set the
     value of "display.font.size"... and so on.
     """
+
     # Note: reset_option relies on set_option, and on key directly
     # it does not fit in to this monkey-patching scheme
 
     global register_option, get_option, set_option, reset_option
 
     def wrap(func):
+
         def inner(key, *args, **kwds):
-            pkey="%s.%s" % (prefix, key)
+            pkey = '%s.%s' % (prefix, key)
             return func(pkey, *args, **kwds)
+
         return inner
 
     _register_option = register_option
@@ -466,7 +579,7 @@ def config_prefix(prefix):
     set_option = wrap(set_option)
     get_option = wrap(get_option)
     register_option = wrap(register_option)
-    yield
+    yield None
     set_option = _set_option
     get_option = _get_option
     register_option = _register_option
@@ -474,6 +587,7 @@ def config_prefix(prefix):
 
 # These factories and methods are handy for use as the validator
 # arg in register_option
+
 def is_type_factory(_type):
     """
 
@@ -487,6 +601,7 @@ def is_type_factory(_type):
                 True if type(x) is equal to `_type`
 
     """
+
     def inner(x):
         if type(x) != _type:
             raise ValueError("Value must have type '%s'" % str(_type))
@@ -507,12 +622,14 @@ def is_instance_factory(_type):
                 True if x is an instance of `_type`
 
     """
+
     def inner(x):
         if not isinstance(x, _type):
             raise ValueError("Value must be an instance of '%s'" % str(_type))
 
     return inner
 
+
 # common type validators, for convenience
 # usage: register_option(... , validator = is_int)
 is_int = is_type_factory(int)
diff --git a/pandas/tests/test_config.py b/pandas/tests/test_config.py
index 6b91fa1e7..84459e1e9 100644
--- a/pandas/tests/test_config.py
+++ b/pandas/tests/test_config.py
@@ -13,19 +13,19 @@ class TestConfig(unittest.TestCase):
 
         from copy import deepcopy
         self.cf = pd.core.config
-        self.gc=deepcopy(getattr(self.cf, '__global_config'))
-        self.do=deepcopy(getattr(self.cf, '__deprecated_options'))
-        self.ro=deepcopy(getattr(self.cf, '__registered_options'))
+        self.gc=deepcopy(getattr(self.cf, '_global_config'))
+        self.do=deepcopy(getattr(self.cf, '_deprecated_options'))
+        self.ro=deepcopy(getattr(self.cf, '_registered_options'))
 
     def setUp(self):
-        setattr(self.cf, '__global_config', {})
-        setattr(self.cf, '__deprecated_options', {})
-        setattr(self.cf, '__registered_options', {})
+        setattr(self.cf, '_global_config', {})
+        setattr(self.cf, '_deprecated_options', {})
+        setattr(self.cf, '_registered_options', {})
 
     def tearDown(self):
-        setattr(self.cf, '__global_config',self.gc)
-        setattr(self.cf, '__deprecated_options', self.do)
-        setattr(self.cf, '__registered_options', self.ro)
+        setattr(self.cf, '_global_config',self.gc)
+        setattr(self.cf, '_deprecated_options', self.do)
+        setattr(self.cf, '_registered_options', self.ro)
 
     def test_api(self):
 

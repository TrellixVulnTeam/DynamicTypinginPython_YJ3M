commit d99a119c76559d127823c7fa0f6098b53b94bb30
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Sep 18 15:43:26 2012 -0400

    ENH: improved DataFrame.to_html for hierachical indexes close #1929

diff --git a/RELEASE.rst b/RELEASE.rst
index a92f78d0a..8e3c02141 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -54,6 +54,8 @@ pandas 0.9.0
     text output. Results in easier importing into R (#1583)
   - Can pass tuple/list of axes to DataFrame.dropna to simplify repeated calls
     (dropping both columns and rows) (#924)
+  - Improve DataFrame.to_html output for hierarchically-indexed rows (do not
+    repeat levels) (#1929)
 
 **API Changes**
 
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 333ef5d43..718f145d4 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -335,25 +335,38 @@ class DataFrameFormatter(object):
         def write(s, indent=0):
             elements.append(' ' * indent + _str(s))
 
+        def write_th(s, indent=0, tags=None):
+            return _write_cell(s, kind='th', indent=indent, tags=tags)
 
-        def write_th(s, indent=0):
-            write('<th>%s</th>' % _str(s), indent)
+        def write_td(s, indent=0, tags=None):
+            return _write_cell(s, kind='td', indent=indent, tags=tags)
+
+        def _write_cell(s, kind='td', indent=0, tags=None):
+            if tags is not None:
+                start_tag = '<%s %s>' % (kind, tags)
+            else:
+                start_tag = '<%s>' % kind
+            write('%s%s</%s>' % (start_tag, _str(s), kind), indent)
 
-        def write_td(s, indent=0):
-            write('<td>%s</td>' % _str(s), indent)
 
-        def write_tr(l, indent=0, indent_delta=4, header=False, align=None):
+        def write_tr(line, indent=0, indent_delta=4, header=False, align=None,
+                     tags=None):
+            if tags is None:
+                tags = {}
+
             if align is None:
                 write('<tr>', indent)
             else:
                 write('<tr style="text-align: %s;">' % align, indent)
             indent += indent_delta
-            if header:
-                for s in l:
-                    write_th(s, indent)
-            else:
-                for s in l:
-                    write_td(s, indent)
+
+            for i, s in enumerate(line):
+                val_tag = tags.get(i, None)
+                if header:
+                    write_th(s, indent, tags=val_tag)
+                else:
+                    write_td(s, indent, tags=val_tag)
+
             indent -= indent_delta
             write('</tr>', indent)
 
@@ -435,24 +448,54 @@ class DataFrameFormatter(object):
             for i in range(len(self.columns)):
                 fmt_values[i] = self._format_col(i)
 
+            ncols = len(self.columns)
+
             # write values
-            index_formatter = self.formatters.get('__index__', None)
-            for i in range(len(frame)):
-                row = []
+            if self.index:
+                index_values = frame.index.values
+                if '__index__' in self.formatters:
+                    f = self.formatters['__index__']
+                    index_values = index_values.map(f)
+
+                template = 'rowspan="%d" valign="top"'
+                if isinstance(frame.index, MultiIndex) and self.sparsify:
+                    levels = frame.index.format(sparsify=True, adjoin=False,
+                                                names=False)
+                    level_lengths = _get_level_lengths(levels)
+                    for i in range(len(frame)):
+                        row = []
+                        tags = {}
+
+                        j = 0
+                        for records, v in zip(level_lengths, index_values[i]):
+                            if i in records:
+                                if records[i] > 1:
+                                    tags[j] = template % records[i]
+                            else:
+                                continue
+                            j += 1
+                            row.append(_maybe_bold_row(v))
+
+                        row.extend(fmt_values[j][i] for j in range(ncols))
+                        write_tr(row, indent, indent_delta, tags=tags)
+                elif isinstance(frame.index, MultiIndex):
+                    for i in range(len(frame)):
+                        row = []
+                        row.extend(_maybe_bold_row(x) for x in index_values[i])
+                        row.extend(fmt_values[j][i] for j in range(ncols))
+                        write_tr(row, indent, indent_delta, tags=None)
+                else:
+                    for i in range(len(frame)):
+                        row = []
+                        row.append(_maybe_bold_row(index_values[i]))
+                        row.extend(fmt_values[j][i] for j in range(ncols))
+                        write_tr(row, indent, indent_delta, tags=None)
+            else:
+                for i in range(len(frame)):
+                    row = [fmt_values[j][i] for j in range(ncols)]
+                    write_tr(row, indent, indent_delta, tags=None)
+
 
-                if self.index:
-                    index_value = frame.index[i]
-                    if index_formatter:
-                        index_value = index_formatter(index_value)
-
-                    if isinstance(frame.index, MultiIndex):
-                        row.extend(_maybe_bold_row(index_value))
-                    else:
-                        row.append(_maybe_bold_row(index_value))
-
-                for j in range(len(self.columns)):
-                    row.append(fmt_values[j][i])
-                write_tr(row, indent, indent_delta)
             indent -= indent_delta
             write('</tbody>', indent)
             indent -= indent_delta
@@ -540,6 +583,31 @@ class DataFrameFormatter(object):
             names.append('' if columns.name is None else columns.name)
         return names
 
+def _get_level_lengths(levels):
+    from itertools import groupby
+
+    def _make_grouper():
+        record = {'count': 0}
+        def grouper(x):
+            if x != '':
+                record['count'] += 1
+            return record['count']
+        return grouper
+
+    result = []
+    for lev in levels:
+        i = 0
+        f = _make_grouper()
+        recs = {}
+        for key, gpr in groupby(lev, f):
+            values = list(gpr)
+            recs[i] = len(values)
+            i += len(values)
+
+        result.append(recs)
+
+    return result
+
 #----------------------------------------------------------------------
 # Array formatters
 
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index 1ab8b3961..1c9a7cdf2 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -18,6 +18,7 @@ from pandas import DataFrame, Series, Index
 import pandas.core.format as fmt
 import pandas.util.testing as tm
 import pandas
+import pandas as pd
 
 _frame = DataFrame(tm.getSeriesData())
 
@@ -179,6 +180,48 @@ class TestDataFrameFormatting(unittest.TestCase):
         df = DataFrame({'A' : [u'\u03c3']})
         df.to_html()
 
+    def test_to_html_multiindex_sparsify(self):
+        index = pd.MultiIndex.from_arrays([[0, 0, 1, 1], [0, 1, 0, 1]])
+
+        df = DataFrame([[0, 1], [2, 3], [4, 5], [6, 7]], index=index)
+
+        result = df.to_html()
+        expected = """<table border="1" class="dataframe">
+  <thead>
+    <tr style="text-align: right;">
+      <th></th>
+      <th></th>
+      <th>0</th>
+      <th>1</th>
+    </tr>
+  </thead>
+  <tbody>
+    <tr>
+      <td rowspan="2" valign="top"><strong>0</strong></td>
+      <td><strong>0</strong></td>
+      <td> 0</td>
+      <td> 1</td>
+    </tr>
+    <tr>
+      <td><strong>1</strong></td>
+      <td> 2</td>
+      <td> 3</td>
+    </tr>
+    <tr>
+      <td rowspan="2" valign="top"><strong>1</strong></td>
+      <td><strong>0</strong></td>
+      <td> 4</td>
+      <td> 5</td>
+    </tr>
+    <tr>
+      <td><strong>1</strong></td>
+      <td> 6</td>
+      <td> 7</td>
+    </tr>
+  </tbody>
+</table>"""
+        self.assertEquals(result, expected)
+
     def test_nonunicode_nonascii_alignment(self):
         df = DataFrame([["aa\xc3\xa4\xc3\xa4", 1], ["bbbb", 2]])
         rep_str = df.to_string()

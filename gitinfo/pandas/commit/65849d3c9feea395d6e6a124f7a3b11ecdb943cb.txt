commit 65849d3c9feea395d6e6a124f7a3b11ecdb943cb
Author: Jeffrey Gerard <jeffreygerard+github@gmail.com>
Date:   Mon Jul 11 20:21:06 2016 +0200

    TST: Clean up tests of DataFrame.sort_{index,values} (#13496)
    
    * TST: Clean up tests of DataFrame.sort_{index,values}
    
    * Factor out Series sorting tests to own file.
    
    * Delegate deprecated sort() and order() to their own tests.
    
    Before this commit, the `Series.sort_values()` tests relied on deprecated
    `Series.sort()` and `Series.order()` as the source of truth. However
    they both merely called `Series.sort_values()` under the hood.
    
    This commit consolidates the core test logic against `.sort_values()`
    directly, while `.sort()` and `.order()` merely check for equivalence
    with `.sort_values()`.
    
    Also removes some no-op assertions that had rotted from the old days of
    `sort()`/`order()`.
    
    * Remove 'by' docstring from Series.sort_values
    
    * Document defaults for optional sorting args
    
    * Move more sort_values, sort_index tests to be together.
    
    * Add test for Series.sort_index(sort_remaining=True)
    
    * Improve `sort_values` tests when multiple `by`s
    
    Duplicates values in the test DataFrame are necessary
    to fully test this feature.
    
    * PEP8 cleanup
    
    * Annotate tests with GH issue
    
    * Fix indentation - docstring string replacement

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 356abc67b..b4509c999 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -68,8 +68,12 @@ from pandas.core.config import get_option
 # ---------------------------------------------------------------------
 # Docstring templates
 
-_shared_doc_kwargs = dict(axes='index, columns', klass='DataFrame',
-                          axes_single_arg="{0, 1, 'index', 'columns'}")
+_shared_doc_kwargs = dict(
+    axes='index, columns', klass='DataFrame',
+    axes_single_arg="{0, 1, 'index', 'columns'}",
+    optional_by="""
+        by : str or list of str
+            Name or list of names which refer to the axis items.""")
 
 _numeric_only_doc = """numeric_only : boolean, default None
     Include only float, int, boolean data. If None, will attempt to use
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 7b271df40..1aadc50b7 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -37,10 +37,13 @@ from pandas.core import config
 # goal is to be able to define the docs close to function, while still being
 # able to share
 _shared_docs = dict()
-_shared_doc_kwargs = dict(axes='keywords for axes', klass='NDFrame',
-                          axes_single_arg='int or labels for object',
-                          args_transpose='axes to permute (int or label for'
-                          ' object)')
+_shared_doc_kwargs = dict(
+    axes='keywords for axes', klass='NDFrame',
+    axes_single_arg='int or labels for object',
+    args_transpose='axes to permute (int or label for object)',
+    optional_by="""
+        by : str or list of str
+            Name or list of names which refer to the axis items.""")
 
 
 def is_dictlike(x):
@@ -1961,21 +1964,20 @@ class NDFrame(PandasObject):
         .. versionadded:: 0.17.0
 
         Parameters
-        ----------
-        by : string name or list of names which refer to the axis items
-        axis : %(axes)s to direct sorting
-        ascending : bool or list of bool
+        ----------%(optional_by)s
+        axis : %(axes)s to direct sorting, default 0
+        ascending : bool or list of bool, default True
              Sort ascending vs. descending. Specify list for multiple sort
              orders.  If this is a list of bools, must match the length of
              the by.
-        inplace : bool
+        inplace : bool, default False
              if True, perform operation in-place
-        kind : {`quicksort`, `mergesort`, `heapsort`}
+        kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'
              Choice of sorting algorithm. See also ndarray.np.sort for more
              information.  `mergesort` is the only stable algorithm. For
              DataFrames, this option is only applied when sorting on a single
              column or label.
-        na_position : {'first', 'last'}
+        na_position : {'first', 'last'}, default 'last'
              `first` puts NaNs at the beginning, `last` puts NaNs at the end
 
         Returns
@@ -1997,16 +1999,16 @@ class NDFrame(PandasObject):
             if not None, sort on values in specified index level(s)
         ascending : boolean, default True
             Sort ascending vs. descending
-        inplace : bool
+        inplace : bool, default False
             if True, perform operation in-place
-        kind : {`quicksort`, `mergesort`, `heapsort`}
+        kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'
              Choice of sorting algorithm. See also ndarray.np.sort for more
              information.  `mergesort` is the only stable algorithm. For
              DataFrames, this option is only applied when sorting on a single
              column or label.
-        na_position : {'first', 'last'}
+        na_position : {'first', 'last'}, default 'last'
              `first` puts NaNs at the beginning, `last` puts NaNs at the end
-        sort_remaining : bool
+        sort_remaining : bool, default True
             if true and sorting by level and index is multilevel, sort by other
             levels too (in order) after sorting by specified level
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e2726bef0..801567021 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -62,7 +62,8 @@ _shared_doc_kwargs = dict(
     axes='index', klass='Series', axes_single_arg="{0, 'index'}",
     inplace="""inplace : boolean, default False
         If True, performs operation inplace and returns None.""",
-    duplicated='Series')
+    duplicated='Series',
+    optional_by='')
 
 
 def _coerce_method(converter):
diff --git a/pandas/tests/frame/test_sorting.py b/pandas/tests/frame/test_sorting.py
index ff2159f8b..4d57216c8 100644
--- a/pandas/tests/frame/test_sorting.py
+++ b/pandas/tests/frame/test_sorting.py
@@ -21,75 +21,68 @@ class TestDataFrameSorting(tm.TestCase, TestData):
 
     _multiprocess_can_split_ = True
 
-    def test_sort_values(self):
-        # API for 9816
+    def test_sort_index(self):
+        # GH13496
 
-        # sort_index
         frame = DataFrame(np.arange(16).reshape(4, 4), index=[1, 2, 3, 4],
                           columns=['A', 'B', 'C', 'D'])
 
-        # 9816 deprecated
-        with tm.assert_produces_warning(FutureWarning):
-            frame.sort(columns='A')
-        with tm.assert_produces_warning(FutureWarning):
-            frame.sort()
-
+        # axis=0 : sort rows by index labels
         unordered = frame.ix[[3, 2, 4, 1]]
-        expected = unordered.sort_index()
-
         result = unordered.sort_index(axis=0)
+        expected = frame
         assert_frame_equal(result, expected)
 
-        unordered = frame.ix[:, [2, 1, 3, 0]]
-        expected = unordered.sort_index(axis=1)
+        result = unordered.sort_index(ascending=False)
+        expected = frame[::-1]
+        assert_frame_equal(result, expected)
 
+        # axis=1 : sort columns by column names
+        unordered = frame.ix[:, [2, 1, 3, 0]]
         result = unordered.sort_index(axis=1)
-        assert_frame_equal(result, expected)
+        assert_frame_equal(result, frame)
+
+        result = unordered.sort_index(axis=1, ascending=False)
+        expected = frame.ix[:, ::-1]
         assert_frame_equal(result, expected)
 
-        # sortlevel
-        mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list('ABC'))
+    def test_sort_index_multiindex(self):
+        # GH13496
+
+        # sort rows by specified level of multi-index
+        mi = MultiIndex.from_tuples([[2, 1, 3], [1, 1, 1]], names=list('ABC'))
         df = DataFrame([[1, 2], [3, 4]], mi)
 
         result = df.sort_index(level='A', sort_remaining=False)
         expected = df.sortlevel('A', sort_remaining=False)
         assert_frame_equal(result, expected)
 
+        # sort columns by specified level of multi-index
         df = df.T
         result = df.sort_index(level='A', axis=1, sort_remaining=False)
         expected = df.sortlevel('A', axis=1, sort_remaining=False)
         assert_frame_equal(result, expected)
 
-        # MI sort, but no by
+        # MI sort, but no level: sort_level has no effect
         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list('ABC'))
         df = DataFrame([[1, 2], [3, 4]], mi)
         result = df.sort_index(sort_remaining=False)
         expected = df.sort_index()
         assert_frame_equal(result, expected)
 
-    def test_sort_index(self):
+    def test_sort(self):
         frame = DataFrame(np.arange(16).reshape(4, 4), index=[1, 2, 3, 4],
                           columns=['A', 'B', 'C', 'D'])
 
-        # axis=0
-        unordered = frame.ix[[3, 2, 4, 1]]
-        sorted_df = unordered.sort_index(axis=0)
-        expected = frame
-        assert_frame_equal(sorted_df, expected)
-
-        sorted_df = unordered.sort_index(ascending=False)
-        expected = frame[::-1]
-        assert_frame_equal(sorted_df, expected)
-
-        # axis=1
-        unordered = frame.ix[:, ['D', 'B', 'C', 'A']]
-        sorted_df = unordered.sort_index(axis=1)
-        expected = frame
-        assert_frame_equal(sorted_df, expected)
+        # 9816 deprecated
+        with tm.assert_produces_warning(FutureWarning):
+            frame.sort(columns='A')
+        with tm.assert_produces_warning(FutureWarning):
+            frame.sort()
 
-        sorted_df = unordered.sort_index(axis=1, ascending=False)
-        expected = frame.ix[:, ::-1]
-        assert_frame_equal(sorted_df, expected)
+    def test_sort_values(self):
+        frame = DataFrame([[1, 1, 2], [3, 1, 0], [4, 5, 6]],
+                          index=[1, 2, 3], columns=list('ABC'))
 
         # by column
         sorted_df = frame.sort_values(by='A')
@@ -109,16 +102,17 @@ class TestDataFrameSorting(tm.TestCase, TestData):
         sorted_df = frame.sort_values(by=['A'], ascending=[False])
         assert_frame_equal(sorted_df, expected)
 
-        # check for now
-        sorted_df = frame.sort_values(by='A')
-        assert_frame_equal(sorted_df, expected[::-1])
-        expected = frame.sort_values(by='A')
+        # multiple bys
+        sorted_df = frame.sort_values(by=['B', 'C'])
+        expected = frame.loc[[2, 1, 3]]
         assert_frame_equal(sorted_df, expected)
 
-        expected = frame.sort_values(by=['A', 'B'], ascending=False)
-        sorted_df = frame.sort_values(by=['A', 'B'])
+        sorted_df = frame.sort_values(by=['B', 'C'], ascending=False)
         assert_frame_equal(sorted_df, expected[::-1])
 
+        sorted_df = frame.sort_values(by=['B', 'A'], ascending=[True, False])
+        assert_frame_equal(sorted_df, expected)
+
         self.assertRaises(ValueError, lambda: frame.sort_values(
             by=['A', 'B'], axis=2, inplace=True))
 
@@ -130,6 +124,25 @@ class TestDataFrameSorting(tm.TestCase, TestData):
         with assertRaisesRegexp(ValueError, msg):
             frame.sort_values(by=['A', 'B'], axis=0, ascending=[True] * 5)
 
+    def test_sort_values_inplace(self):
+        frame = DataFrame(np.random.randn(4, 4), index=[1, 2, 3, 4],
+                          columns=['A', 'B', 'C', 'D'])
+
+        sorted_df = frame.copy()
+        sorted_df.sort_values(by='A', inplace=True)
+        expected = frame.sort_values(by='A')
+        assert_frame_equal(sorted_df, expected)
+
+        sorted_df = frame.copy()
+        sorted_df.sort_values(by='A', ascending=False, inplace=True)
+        expected = frame.sort_values(by='A', ascending=False)
+        assert_frame_equal(sorted_df, expected)
+
+        sorted_df = frame.copy()
+        sorted_df.sort_values(by=['A', 'B'], ascending=False, inplace=True)
+        expected = frame.sort_values(by=['A', 'B'], ascending=False)
+        assert_frame_equal(sorted_df, expected)
+
     def test_sort_index_categorical_index(self):
 
         df = (DataFrame({'A': np.arange(6, dtype='int64'),
@@ -361,25 +374,6 @@ class TestDataFrameSorting(tm.TestCase, TestData):
         result = idf['C'].sort_index(ascending=[1, 0])
         assert_series_equal(result, expected['C'])
 
-    def test_sort_inplace(self):
-        frame = DataFrame(np.random.randn(4, 4), index=[1, 2, 3, 4],
-                          columns=['A', 'B', 'C', 'D'])
-
-        sorted_df = frame.copy()
-        sorted_df.sort_values(by='A', inplace=True)
-        expected = frame.sort_values(by='A')
-        assert_frame_equal(sorted_df, expected)
-
-        sorted_df = frame.copy()
-        sorted_df.sort_values(by='A', ascending=False, inplace=True)
-        expected = frame.sort_values(by='A', ascending=False)
-        assert_frame_equal(sorted_df, expected)
-
-        sorted_df = frame.copy()
-        sorted_df.sort_values(by=['A', 'B'], ascending=False, inplace=True)
-        expected = frame.sort_values(by=['A', 'B'], ascending=False)
-        assert_frame_equal(sorted_df, expected)
-
     def test_sort_index_duplicates(self):
 
         # with 9816, these are all translated to .sort_values
diff --git a/pandas/tests/series/test_analytics.py b/pandas/tests/series/test_analytics.py
index 0dbff0a02..d9e2d8096 100644
--- a/pandas/tests/series/test_analytics.py
+++ b/pandas/tests/series/test_analytics.py
@@ -5,7 +5,6 @@ from itertools import product
 from distutils.version import LooseVersion
 
 import nose
-import random
 
 from numpy import nan
 import numpy as np
@@ -1418,141 +1417,6 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
         self.assertFalse(s.is_monotonic)
         self.assertTrue(s.is_monotonic_decreasing)
 
-    def test_sort_values(self):
-
-        ts = self.ts.copy()
-
-        # 9816 deprecated
-        with tm.assert_produces_warning(FutureWarning):
-            ts.sort()
-
-        self.assert_series_equal(ts, self.ts.sort_values())
-        self.assert_index_equal(ts.index, self.ts.sort_values().index)
-
-        ts.sort_values(ascending=False, inplace=True)
-        self.assert_series_equal(ts, self.ts.sort_values(ascending=False))
-        self.assert_index_equal(ts.index,
-                                self.ts.sort_values(ascending=False).index)
-
-        # GH 5856/5853
-        # Series.sort_values operating on a view
-        df = DataFrame(np.random.randn(10, 4))
-        s = df.iloc[:, 0]
-
-        def f():
-            s.sort_values(inplace=True)
-
-        self.assertRaises(ValueError, f)
-
-        # test order/sort inplace
-        # GH6859
-        ts1 = self.ts.copy()
-        ts1.sort_values(ascending=False, inplace=True)
-        ts2 = self.ts.copy()
-        ts2.sort_values(ascending=False, inplace=True)
-        assert_series_equal(ts1, ts2)
-
-        ts1 = self.ts.copy()
-        ts1 = ts1.sort_values(ascending=False, inplace=False)
-        ts2 = self.ts.copy()
-        ts2 = ts.sort_values(ascending=False)
-        assert_series_equal(ts1, ts2)
-
-    def test_sort_index(self):
-        rindex = list(self.ts.index)
-        random.shuffle(rindex)
-
-        random_order = self.ts.reindex(rindex)
-        sorted_series = random_order.sort_index()
-        assert_series_equal(sorted_series, self.ts)
-
-        # descending
-        sorted_series = random_order.sort_index(ascending=False)
-        assert_series_equal(sorted_series,
-                            self.ts.reindex(self.ts.index[::-1]))
-
-    def test_sort_index_inplace(self):
-
-        # For #11402
-        rindex = list(self.ts.index)
-        random.shuffle(rindex)
-
-        # descending
-        random_order = self.ts.reindex(rindex)
-        result = random_order.sort_index(ascending=False, inplace=True)
-        self.assertIs(result, None,
-                      msg='sort_index() inplace should return None')
-        assert_series_equal(random_order, self.ts.reindex(self.ts.index[::-1]))
-
-        # ascending
-        random_order = self.ts.reindex(rindex)
-        result = random_order.sort_index(ascending=True, inplace=True)
-        self.assertIs(result, None,
-                      msg='sort_index() inplace should return None')
-        assert_series_equal(random_order, self.ts)
-
-    def test_sort_API(self):
-
-        # API for 9816
-
-        # sortlevel
-        mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list('ABC'))
-        s = Series([1, 2], mi)
-        backwards = s.iloc[[1, 0]]
-
-        res = s.sort_index(level='A')
-        assert_series_equal(backwards, res)
-
-        # sort_index
-        rindex = list(self.ts.index)
-        random.shuffle(rindex)
-
-        random_order = self.ts.reindex(rindex)
-        sorted_series = random_order.sort_index(level=0)
-        assert_series_equal(sorted_series, self.ts)
-
-        # compat on axis
-        sorted_series = random_order.sort_index(axis=0)
-        assert_series_equal(sorted_series, self.ts)
-
-        self.assertRaises(ValueError, lambda: random_order.sort_values(axis=1))
-
-        sorted_series = random_order.sort_index(level=0, axis=0)
-        assert_series_equal(sorted_series, self.ts)
-
-        self.assertRaises(ValueError,
-                          lambda: random_order.sort_index(level=0, axis=1))
-
-    def test_order(self):
-
-        # 9816 deprecated
-        with tm.assert_produces_warning(FutureWarning):
-            self.ts.order()
-
-        ts = self.ts.copy()
-        ts[:5] = np.NaN
-        vals = ts.values
-
-        result = ts.sort_values()
-        self.assertTrue(np.isnan(result[-5:]).all())
-        self.assert_numpy_array_equal(result[:-5].values, np.sort(vals[5:]))
-
-        result = ts.sort_values(na_position='first')
-        self.assertTrue(np.isnan(result[:5]).all())
-        self.assert_numpy_array_equal(result[5:].values, np.sort(vals[5:]))
-
-        # something object-type
-        ser = Series(['A', 'B'], [1, 2])
-        # no failure
-        ser.sort_values()
-
-        # ascending=False
-        ordered = ts.sort_values(ascending=False)
-        expected = np.sort(ts.valid().values)[::-1]
-        assert_almost_equal(expected, ordered.valid().values)
-        ordered = ts.sort_values(ascending=False, na_position='first')
-        assert_almost_equal(expected, ordered.valid().values)
-
     def test_nsmallest_nlargest(self):
         # float, int, datetime64 (use i8), timedelts64 (same),
         # object that are numbers, object that are strings
diff --git a/pandas/tests/series/test_sorting.py b/pandas/tests/series/test_sorting.py
new file mode 100644
index 000000000..826201adb
--- /dev/null
+++ b/pandas/tests/series/test_sorting.py
@@ -0,0 +1,146 @@
+# coding=utf-8
+
+import numpy as np
+import random
+
+from pandas import (DataFrame, Series, MultiIndex)
+
+from pandas.util.testing import (assert_series_equal, assert_almost_equal)
+import pandas.util.testing as tm
+
+from .common import TestData
+
+
+class TestSeriesSorting(TestData, tm.TestCase):
+
+    _multiprocess_can_split_ = True
+
+    def test_sort(self):
+
+        ts = self.ts.copy()
+
+        # 9816 deprecated
+        with tm.assert_produces_warning(FutureWarning):
+            ts.sort()  # sorts inplace
+        self.assert_series_equal(ts, self.ts.sort_values())
+
+    def test_order(self):
+
+        # 9816 deprecated
+        with tm.assert_produces_warning(FutureWarning):
+            result = self.ts.order()
+        self.assert_series_equal(result, self.ts.sort_values())
+
+    def test_sort_values(self):
+
+        # check indexes are reordered corresponding with the values
+        ser = Series([3, 2, 4, 1], ['A', 'B', 'C', 'D'])
+        expected = Series([1, 2, 3, 4], ['D', 'B', 'A', 'C'])
+        result = ser.sort_values()
+        self.assert_series_equal(expected, result)
+
+        ts = self.ts.copy()
+        ts[:5] = np.NaN
+        vals = ts.values
+
+        result = ts.sort_values()
+        self.assertTrue(np.isnan(result[-5:]).all())
+        self.assert_numpy_array_equal(result[:-5].values, np.sort(vals[5:]))
+
+        # na_position
+        result = ts.sort_values(na_position='first')
+        self.assertTrue(np.isnan(result[:5]).all())
+        self.assert_numpy_array_equal(result[5:].values, np.sort(vals[5:]))
+
+        # something object-type
+        ser = Series(['A', 'B'], [1, 2])
+        # no failure
+        ser.sort_values()
+
+        # ascending=False
+        ordered = ts.sort_values(ascending=False)
+        expected = np.sort(ts.valid().values)[::-1]
+        assert_almost_equal(expected, ordered.valid().values)
+        ordered = ts.sort_values(ascending=False, na_position='first')
+        assert_almost_equal(expected, ordered.valid().values)
+
+        # inplace=True
+        ts = self.ts.copy()
+        ts.sort_values(ascending=False, inplace=True)
+        self.assert_series_equal(ts, self.ts.sort_values(ascending=False))
+        self.assert_index_equal(ts.index,
+                                self.ts.sort_values(ascending=False).index)
+
+        # GH 5856/5853
+        # Series.sort_values operating on a view
+        df = DataFrame(np.random.randn(10, 4))
+        s = df.iloc[:, 0]
+
+        def f():
+            s.sort_values(inplace=True)
+
+        self.assertRaises(ValueError, f)
+
+    def test_sort_index(self):
+        rindex = list(self.ts.index)
+        random.shuffle(rindex)
+
+        random_order = self.ts.reindex(rindex)
+        sorted_series = random_order.sort_index()
+        assert_series_equal(sorted_series, self.ts)
+
+        # descending
+        sorted_series = random_order.sort_index(ascending=False)
+        assert_series_equal(sorted_series,
+                            self.ts.reindex(self.ts.index[::-1]))
+
+        # compat on level
+        sorted_series = random_order.sort_index(level=0)
+        assert_series_equal(sorted_series, self.ts)
+
+        # compat on axis
+        sorted_series = random_order.sort_index(axis=0)
+        assert_series_equal(sorted_series, self.ts)
+
+        self.assertRaises(ValueError, lambda: random_order.sort_values(axis=1))
+
+        sorted_series = random_order.sort_index(level=0, axis=0)
+        assert_series_equal(sorted_series, self.ts)
+
+        self.assertRaises(ValueError,
+                          lambda: random_order.sort_index(level=0, axis=1))
+
+    def test_sort_index_inplace(self):
+
+        # For #11402
+        rindex = list(self.ts.index)
+        random.shuffle(rindex)
+
+        # descending
+        random_order = self.ts.reindex(rindex)
+        result = random_order.sort_index(ascending=False, inplace=True)
+        self.assertIs(result, None,
+                      msg='sort_index() inplace should return None')
+        assert_series_equal(random_order, self.ts.reindex(self.ts.index[::-1]))
+
+        # ascending
+        random_order = self.ts.reindex(rindex)
+        result = random_order.sort_index(ascending=True, inplace=True)
+        self.assertIs(result, None,
+                      msg='sort_index() inplace should return None')
+        assert_series_equal(random_order, self.ts)
+
+    def test_sort_index_multiindex(self):
+
+        mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list('ABC'))
+        s = Series([1, 2], mi)
+        backwards = s.iloc[[1, 0]]
+
+        # implicit sort_remaining=True
+        res = s.sort_index(level='A')
+        assert_series_equal(backwards, res)
+
+        # GH13496
+        # rows share same level='A': sort has no effect without remaining lvls
+        res = s.sort_index(level='A', sort_remaining=False)
+        assert_series_equal(s, res)

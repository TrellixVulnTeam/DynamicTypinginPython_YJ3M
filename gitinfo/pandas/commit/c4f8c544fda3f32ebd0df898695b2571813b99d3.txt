commit c4f8c544fda3f32ebd0df898695b2571813b99d3
Author: jreback <jeff@reback.net>
Date:   Sun Nov 10 12:39:14 2013 -0500

    PERF: perf regression with mixed-type ops using numexpr (GH5481)
    BUG: non-unique ops not aligning correctly

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d8a722ff1..1222b5b93 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2810,11 +2810,28 @@ class DataFrame(NDFrame):
             return func(left, right)
 
         if this._is_mixed_type or other._is_mixed_type:
-            # XXX no good for duplicate columns
-            # but cannot outer join in align if dups anyways?
-            result = {}
-            for col in this:
-                result[col] = _arith_op(this[col].values, other[col].values)
+
+            # unique
+            if this.columns.is_unique:
+
+                def f(col):
+                    r = _arith_op(this[col].values, other[col].values)
+                    return self._constructor_sliced(r,index=new_index,dtype=r.dtype)
+
+                result = dict([ (col, f(col)) for col in this ])
+
+            # non-unique
+            else:
+
+                def f(i):
+                    r = _arith_op(this.iloc[:,i].values, other.iloc[:,i].values)
+                    return self._constructor_sliced(r,index=new_index,dtype=r.dtype)
+
+                result = dict([ (i,f(i)) for i, col in enumerate(this.columns) ])
+                result = self._constructor(result, index=new_index, copy=False)
+                result.columns = new_columns
+                return result
+
         else:
             result = _arith_op(this.values, other.values)
 
@@ -2890,10 +2907,12 @@ class DataFrame(NDFrame):
         # non-unique
         else:
             def _compare(a, b):
-                return [func(a.iloc[:,i], b.iloc[:,i]) for i, col in enumerate(a.columns)]
+                return dict([(i,func(a.iloc[:,i], b.iloc[:,i])) for i, col in enumerate(a.columns)])
             new_data = expressions.evaluate(_compare, str_rep, self, other)
-            return self._constructor(data=new_data, index=self.columns,
-                                     columns=self.index, copy=False).T
+            result = self._constructor(data=new_data, index=self.index,
+                                       copy=False)
+            result.columns = self.columns
+            return result
 
     def _compare_frame(self, other, func, str_rep):
         if not self._indexed_same(other):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index ffc40ffba..5762171b3 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3217,6 +3217,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             this_df['A'] = index
             check(this_df, expected_df)
 
+        # operations
+        for op in ['__add__','__mul__','__sub__','__truediv__']:
+            df = DataFrame(dict(A = np.arange(10), B = np.random.rand(10)))
+            expected = getattr(df,op)(df)
+            expected.columns = ['A','A']
+            df.columns = ['A','A']
+            result = getattr(df,op)(df)
+            check(result,expected)
+
     def test_column_dups_indexing(self):
 
         def check(result, expected=None):

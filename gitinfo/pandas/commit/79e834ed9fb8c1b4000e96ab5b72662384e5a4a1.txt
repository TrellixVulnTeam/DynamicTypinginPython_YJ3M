commit 79e834ed9fb8c1b4000e96ab5b72662384e5a4a1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 13 19:21:50 2011 -0400

    100% test coverage, but perhaps deceptive

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index cba4c789e..b87278195 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -33,10 +33,8 @@ def groupby(obj, grouper, **kwds):
     """
     if isinstance(obj, Series):
         klass = SeriesGroupBy
-    elif isinstance(obj, DataMatrix):
-        klass = DataMatrixGroupBy
     elif isinstance(obj, DataFrame):
-        klass = DataFrameGroupBy
+        klass = DataMatrixGroupBy
     else: # pragma: no cover
         raise TypeError('invalid type: %s' % type(obj))
 
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index d53bfe674..7d52105f4 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -834,13 +834,12 @@ class SparseDataFrame(DataFrame):
                 return self.reindex(dateRange)
 
             elif isinstance(item, np.ndarray):
-
                 if len(item) != len(self.index):
                     raise Exception('Item wrong length %d instead of %d!' %
                                     (len(item), len(self.index)))
                 newIndex = self.index[item]
                 return self.reindex(newIndex)
-            else:
+            else: # pragma: no cover
                 raise
 
     def as_matrix(self, columns=None):
@@ -854,11 +853,10 @@ class SparseDataFrame(DataFrame):
             columns = self.columns
 
         if len(columns) == 0:
-            return np.zeros((0, 0))
+            return np.zeros((len(self.index), 0), dtype=float)
 
         return np.array([self[col].values for col in columns]).T
 
-    asMatrix = as_matrix
     values = property(as_matrix)
 
     def xs(self, key):
@@ -873,16 +871,10 @@ class SparseDataFrame(DataFrame):
         -------
         Series
         """
-        if key not in self.index:
-            raise Exception('No cross-section for %s' % key)
-
-        subset = self.columns
-        rowValues = [self._series[k][key] for k in subset]
-
-        if len(set((type(x) for x in rowValues))) > 1:
-            return Series(np.array(rowValues, dtype=np.object_), index=subset)
-        else:
-            return Series(np.array(rowValues), index=subset)
+        i = self.index.indexMap[key]
+        series = self._series
+        values = [series[k][i] for k in self.columns]
+        return Series(values, index=self.columns)
 
     #----------------------------------------------------------------------
     # Arithmetic-related methods
@@ -897,7 +889,7 @@ class SparseDataFrame(DataFrame):
             other = other.reindex(new_index)
 
         if not self and not other:
-            return DataFrame(index=new_index)
+            return SparseDataFrame(index=new_index)
 
         if not other:
             return self * nan
diff --git a/pandas/core/tests/test_daterange.py b/pandas/core/tests/test_daterange.py
index 98d6691ec..95603bcd6 100644
--- a/pandas/core/tests/test_daterange.py
+++ b/pandas/core/tests/test_daterange.py
@@ -184,6 +184,13 @@ class TestDateRange(unittest.TestCase):
                           datetime(2005, 1, 1, tzinfo=pytz.utc),
                           '1/1/2009', tzinfo=tz)
 
+    def test_tz_localize(self):
+        _skip_if_no_pytz()
+        dr = DateRange('1/1/2009', '1/1/2010')
+        dr_utc = DateRange('1/1/2009', '1/1/2010', tzinfo=pytz.utc)
+        localized = dr.tz_localize(pytz.utc)
+        self.assert_(np.array_equal(dr_utc, localized))
+
     def test_with_tzinfo_ambiguous_times(self):
         _skip_if_no_pytz()
         tz = pytz.timezone('US/Eastern')
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index f34e4cbc0..845b69e31 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -605,6 +605,20 @@ class TestSparseDataFrame(TestCase):
                                           default_fill_value=2,
                                           index=self.dates)
 
+        self.empty = SparseDataFrame()
+
+    def test_as_matrix(self):
+        empty = self.empty.as_matrix()
+        self.assert_(empty.shape == (0, 0))
+
+        no_cols = SparseDataFrame(index=np.arange(10))
+        mat = no_cols.as_matrix()
+        self.assert_(mat.shape == (10, 0))
+
+        no_index = SparseDataFrame(columns=np.arange(10))
+        mat = no_index.as_matrix()
+        self.assert_(mat.shape == (0, 10))
+
     def test_copy(self):
         cp = self.frame.copy()
         self.assert_(isinstance(cp, SparseDataFrame))
@@ -727,6 +741,9 @@ class TestSparseDataFrame(TestCase):
                   SparseSeries([], index=[])]
 
         for op in ops:
+            _compare_to_dense(frame, frame[::2],
+                              frame.to_dense(),
+                              frame[::2].to_dense(), op)
             for s in series:
                 _compare_to_dense(frame, s, frame.to_dense(),
                                   s.to_dense(), op)
@@ -747,10 +764,38 @@ class TestSparseDataFrame(TestCase):
                 _compare_to_dense(s, frame, s,
                                   frame.to_dense(), op)
 
+    def test_op_corners(self):
+        empty = self.empty + self.empty
+        self.assert_(not empty)
+
+        foo = self.frame + self.empty
+        assert_sp_frame_equal(foo, self.frame * np.nan)
+
+        foo = self.empty + self.frame
+        assert_sp_frame_equal(foo, self.frame * np.nan)
+
     def test_scalar_ops(self):
         pass
 
-    def test_insert_item(self):
+    def test_getitem(self):
+        pass
+
+    def test_getitem_overload(self):
+        # slicing
+        sl = self.frame[:20]
+        assert_sp_frame_equal(sl, self.frame.reindex(self.frame.index[:20]))
+
+        # boolean indexing
+        d = self.frame.index[5]
+        indexer = self.frame.index > d
+
+        subindex = self.frame.index[indexer]
+        subframe = self.frame[indexer]
+
+        self.assert_(np.array_equal(subindex, subframe.index))
+        self.assertRaises(Exception, self.frame.__getitem__, indexer[:-1])
+
+    def test_setitem(self):
         def _check_frame(frame):
             N = len(frame)
 
@@ -800,7 +845,7 @@ class TestSparseDataFrame(TestCase):
 
         self._check_all(_check_frame)
 
-    def test_insert_item_corner(self):
+    def test_setitem_corner(self):
         self.frame['a'] = self.frame['B']
         assert_sp_series_equal(self.frame['a'], self.frame['B'])
 
@@ -834,6 +879,15 @@ class TestSparseDataFrame(TestCase):
         self.assert_(isinstance(res, SparseDataFrame))
         assert_frame_equal(res.to_dense(), self.frame.to_dense().corr())
 
+    def test_join(self):
+        left = self.frame.ix[:, ['A', 'B']]
+        right = self.frame.ix[:, ['C', 'D']]
+        joined = left.join(right)
+        assert_sp_frame_equal(joined, self.frame)
+
+        right = self.frame.ix[:, ['B', 'D']]
+        self.assertRaises(Exception, left.join, right)
+
     def test_reindex(self):
 
         def _check_frame(frame):
@@ -1077,9 +1131,6 @@ class TestSparseWidePanel(TestCase,
     def test_values(self):
         pass
 
-    def test_getitem(self):
-        pass
-
     def test_setitem(self):
         self.panel['ItemE'] = self.panel['ItemC']
         self.panel['ItemF'] = self.panel['ItemC'].to_dense()
@@ -1101,11 +1152,6 @@ class TestSparseWidePanel(TestCase,
 
         self.assertRaises(KeyError, self.panel.__delitem__, 'ItemC')
 
-    def test_pickle(self):
-        pickled = pickle.dumps(self.panel)
-        unpickled = pickle.loads(pickled)
-        assert_sp_panel_equal(self.panel, unpickled)
-
     def test_copy(self):
         cop = self.panel.copy()
         assert_sp_panel_equal(cop, self.panel)

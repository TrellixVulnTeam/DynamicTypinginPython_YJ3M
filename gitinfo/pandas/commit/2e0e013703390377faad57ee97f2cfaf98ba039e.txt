commit 2e0e013703390377faad57ee97f2cfaf98ba039e
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Mar 7 02:31:16 2020 -0800

    CLN: assorted cleanups, annotations (#32475)

diff --git a/pandas/_libs/tslibs/timedeltas.pyx b/pandas/_libs/tslibs/timedeltas.pyx
index 7bd02b734..457f3eb07 100644
--- a/pandas/_libs/tslibs/timedeltas.pyx
+++ b/pandas/_libs/tslibs/timedeltas.pyx
@@ -1167,7 +1167,7 @@ class Timedelta(_Timedelta):
 
         Possible values:
 
-        * 'Y', 'M', 'W', 'D', 'T', 'S', 'L', 'U', or 'N'
+        * 'W', 'D', 'T', 'S', 'L', 'U', or 'N'
         * 'days' or 'day'
         * 'hours', 'hour', 'hr', or 'h'
         * 'minutes', 'minute', 'min', or 'm'
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 56939cda6..9f19c7ba0 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -988,7 +988,7 @@ default 'raise'
     # ----------------------------------------------------------------
     # Conversion Methods - Vectorized analogues of Timestamp methods
 
-    def to_pydatetime(self):
+    def to_pydatetime(self) -> np.ndarray:
         """
         Return Datetime Array/Index as object ndarray of datetime.datetime
         objects.
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 749489a0a..dbc0b0b3c 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -825,7 +825,7 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
         """
         return self._maybe_mask_results(1e-9 * self.asi8, fill_value=None)
 
-    def to_pytimedelta(self):
+    def to_pytimedelta(self) -> np.ndarray:
         """
         Return Timedelta Array/Index as object ndarray of datetime.timedelta
         objects.
diff --git a/pandas/core/indexes/accessors.py b/pandas/core/indexes/accessors.py
index db774a03c..71ae92df1 100644
--- a/pandas/core/indexes/accessors.py
+++ b/pandas/core/indexes/accessors.py
@@ -1,6 +1,8 @@
 """
 datetimelike delegation
 """
+from typing import TYPE_CHECKING
+
 import numpy as np
 
 from pandas.core.dtypes.common import (
@@ -21,9 +23,12 @@ from pandas.core.base import NoNewAttributesMixin, PandasObject
 from pandas.core.indexes.datetimes import DatetimeIndex
 from pandas.core.indexes.timedeltas import TimedeltaIndex
 
+if TYPE_CHECKING:
+    from pandas import Series  # noqa:F401
+
 
 class Properties(PandasDelegate, PandasObject, NoNewAttributesMixin):
-    def __init__(self, data, orig):
+    def __init__(self, data: "Series", orig):
         if not isinstance(data, ABCSeries):
             raise TypeError(
                 f"cannot convert an object of type {type(data)} to a datetimelike index"
@@ -137,7 +142,7 @@ class DatetimeProperties(Properties):
     Raises TypeError if the Series does not contain datetimelike values.
     """
 
-    def to_pydatetime(self):
+    def to_pydatetime(self) -> np.ndarray:
         """
         Return the data as an array of native Python datetime objects.
 
@@ -209,7 +214,7 @@ class TimedeltaProperties(Properties):
     Raises TypeError if the Series does not contain datetimelike values.
     """
 
-    def to_pytimedelta(self):
+    def to_pytimedelta(self) -> np.ndarray:
         """
         Return an array of native `datetime.timedelta` objects.
 
@@ -271,7 +276,7 @@ class TimedeltaProperties(Properties):
         2     0      0        0        2             0             0            0
         3     0      0        0        3             0             0            0
         4     0      0        0        4             0             0            0
-        """  # noqa: E501
+        """
         return self._get_values().components.set_index(self._parent.index)
 
     @property
@@ -303,7 +308,7 @@ class PeriodProperties(Properties):
 class CombinedDatetimelikeProperties(
     DatetimeProperties, TimedeltaProperties, PeriodProperties
 ):
-    def __new__(cls, data):
+    def __new__(cls, data: "Series"):
         # CombinedDatetimelikeProperties isn't really instantiated. Instead
         # we need to choose which parent (datetime or timedelta) is
         # appropriate. Since we're checking the dtypes anyway, we'll just
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index f621a3c15..c21d8df24 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -168,7 +168,7 @@ class RangeIndex(Int64Index):
         return self._cached_data
 
     @cache_readonly
-    def _int64index(self):
+    def _int64index(self) -> Int64Index:
         return Int64Index._simple_new(self._data, name=self.name)
 
     def _get_data_as_items(self):
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index f6e79a0f2..98afc5ac3 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -24,7 +24,6 @@ from pandas.core.dtypes.common import (
     is_list_like,
     is_numeric_v_string_like,
     is_scalar,
-    is_sparse,
 )
 from pandas.core.dtypes.concat import concat_compat
 from pandas.core.dtypes.dtypes import ExtensionDtype
@@ -32,6 +31,7 @@ from pandas.core.dtypes.generic import ABCExtensionArray, ABCSeries
 from pandas.core.dtypes.missing import isna
 
 import pandas.core.algorithms as algos
+from pandas.core.arrays.sparse import SparseDtype
 from pandas.core.base import PandasObject
 from pandas.core.indexers import maybe_convert_indices
 from pandas.core.indexes.api import Index, MultiIndex, ensure_index
@@ -843,8 +843,8 @@ class BlockManager(PandasObject):
 
         # TODO: https://github.com/pandas-dev/pandas/issues/22791
         # Give EAs some input on what happens here. Sparse needs this.
-        if is_sparse(dtype):
-            dtype = dtype.subtype  # type: ignore
+        if isinstance(dtype, SparseDtype):
+            dtype = dtype.subtype
         elif is_extension_array_dtype(dtype):
             dtype = "object"
 
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 4398a1569..725d1adc6 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -981,7 +981,7 @@ def nanskew(
     Examples
     --------
     >>> import pandas.core.nanops as nanops
-    >>> s = pd.Series([1,np.nan, 1, 2])
+    >>> s = pd.Series([1, np.nan, 1, 2])
     >>> nanops.nanskew(s)
     1.7320508075688787
     """
@@ -1065,7 +1065,7 @@ def nankurt(
     Examples
     --------
     >>> import pandas.core.nanops as nanops
-    >>> s = pd.Series([1,np.nan, 1, 3, 2])
+    >>> s = pd.Series([1, np.nan, 1, 3, 2])
     >>> nanops.nankurt(s)
     -1.2892561983471076
     """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index bb4e22219..cfdd5635b 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -47,7 +47,6 @@ from pandas.core.dtypes.generic import (
     ABCMultiIndex,
     ABCPeriodIndex,
     ABCSeries,
-    ABCSparseArray,
 )
 from pandas.core.dtypes.inference import is_hashable
 from pandas.core.dtypes.missing import (
@@ -289,9 +288,6 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 pass
             elif isinstance(data, (set, frozenset)):
                 raise TypeError(f"'{type(data).__name__}' type is unordered")
-            elif isinstance(data, ABCSparseArray):
-                # handle sparse passed here (and force conversion)
-                data = data.to_dense()
             else:
                 data = com.maybe_iterable_to_list(data)
 
diff --git a/pandas/tests/frame/indexing/test_datetime.py b/pandas/tests/frame/indexing/test_datetime.py
index 6bfcac379..0fd60c151 100644
--- a/pandas/tests/frame/indexing/test_datetime.py
+++ b/pandas/tests/frame/indexing/test_datetime.py
@@ -40,7 +40,7 @@ class TestDataFrameIndexingDatetimeWithTZ:
         # set/reset
         df = DataFrame({"A": [0, 1, 2]}, index=idx)
         result = df.reset_index()
-        assert result["foo"].dtype, "M8[ns, US/Eastern"
+        assert result["foo"].dtype == "datetime64[ns, US/Eastern]"
 
         df = result.set_index("foo")
         tm.assert_index_equal(df.index, idx)
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 1a1b7e8e1..042635131 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -4,7 +4,6 @@ from typing import Dict, Optional
 import warnings
 
 import numpy as np
-from pytz import AmbiguousTimeError
 
 from pandas._libs.algos import unique_deltas
 from pandas._libs.tslibs import Timedelta, Timestamp
@@ -288,10 +287,7 @@ def infer_freq(index, warn: bool = True) -> Optional[str]:
         index = index.values
 
     if not isinstance(index, pd.DatetimeIndex):
-        try:
-            index = pd.DatetimeIndex(index)
-        except AmbiguousTimeError:
-            index = pd.DatetimeIndex(index.asi8)
+        index = pd.DatetimeIndex(index)
 
     inferer = _FrequencyInferer(index, warn=warn)
     return inferer.get_freq()
@@ -490,6 +486,7 @@ class _FrequencyInferer:
         )
 
     def _get_wom_rule(self) -> Optional[str]:
+        # FIXME: dont leave commented-out
         #         wdiffs = unique(np.diff(self.index.week))
         # We also need -47, -49, -48 to catch index spanning year boundary
         #     if not lib.ismember(wdiffs, set([4, 5, -47, -49, -48])).all():
diff --git a/setup.cfg b/setup.cfg
index bbd848962..42c507a2b 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -98,6 +98,7 @@ exclude_lines =
     # Don't complain if non-runnable code isn't run:
     if 0:
     if __name__ == .__main__.:
+    if TYPE_CHECKING:
 
 [coverage:html]
 directory = coverage_html_report

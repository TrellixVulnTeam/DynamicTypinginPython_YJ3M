commit a7bb9720e969e1bb09165a2e3828b8ef70914196
Author: Kaiqi Dong <kaiqidong1991@gmail.com>
Date:   Mon Dec 3 23:01:00 2018 +0800

    fix quote position (#24065)

diff --git a/pandas/core/accessor.py b/pandas/core/accessor.py
index f2ae7f6b5..fa1dc751c 100644
--- a/pandas/core/accessor.py
+++ b/pandas/core/accessor.py
@@ -41,7 +41,9 @@ class DirNamesMixin(object):
 
 
 class PandasDelegate(object):
-    """ an abstract base class for delegating methods/properties """
+    """
+    an abstract base class for delegating methods/properties
+    """
 
     def _delegate_property_get(self, name, *args, **kwargs):
         raise TypeError("You cannot access the "
@@ -146,7 +148,8 @@ def delegate_names(delegate, accessors, typ, overwrite=False):
 # 2. We use a UserWarning instead of a custom Warning
 
 class CachedAccessor(object):
-    """Custom property-like object (descriptor) for caching accessors.
+    """
+    Custom property-like object (descriptor) for caching accessors.
 
     Parameters
     ----------
@@ -189,7 +192,8 @@ def _register_accessor(name, cls):
     return decorator
 
 
-_doc = """Register a custom accessor on %(klass)s objects.
+_doc = """\
+Register a custom accessor on %(klass)s objects.
 
 Parameters
 ----------
diff --git a/pandas/core/arrays/base.py b/pandas/core/arrays/base.py
index eb2fef482..8877436dc 100644
--- a/pandas/core/arrays/base.py
+++ b/pandas/core/arrays/base.py
@@ -22,7 +22,8 @@ _not_implemented_message = "{} does not implement {}."
 
 
 class ExtensionArray(object):
-    """Abstract base class for custom 1-D array types.
+    """
+    Abstract base class for custom 1-D array types.
 
     pandas will recognize instances of this class as proper arrays
     with a custom type and will not attempt to coerce them to objects. They
@@ -100,7 +101,8 @@ class ExtensionArray(object):
     # ------------------------------------------------------------------------
     @classmethod
     def _from_sequence(cls, scalars, dtype=None, copy=False):
-        """Construct a new ExtensionArray from a sequence of scalars.
+        """
+        Construct a new ExtensionArray from a sequence of scalars.
 
         Parameters
         ----------
@@ -121,7 +123,8 @@ class ExtensionArray(object):
 
     @classmethod
     def _from_factorized(cls, values, original):
-        """Reconstruct an ExtensionArray after factorization.
+        """
+        Reconstruct an ExtensionArray after factorization.
 
         Parameters
         ----------
@@ -143,7 +146,8 @@ class ExtensionArray(object):
 
     def __getitem__(self, item):
         # type (Any) -> Any
-        """Select a subset of self.
+        """
+        Select a subset of self.
 
         Parameters
         ----------
@@ -174,7 +178,8 @@ class ExtensionArray(object):
 
     def __setitem__(self, key, value):
         # type: (Union[int, np.ndarray], Any) -> None
-        """Set one or more values inplace.
+        """
+        Set one or more values inplace.
 
         This method is not required to satisfy the pandas extension array
         interface.
@@ -219,7 +224,8 @@ class ExtensionArray(object):
 
     def __len__(self):
         # type: () -> int
-        """Length of this array
+        """
+        Length of this array
 
         Returns
         -------
@@ -228,8 +234,8 @@ class ExtensionArray(object):
         raise AbstractMethodError(self)
 
     def __iter__(self):
-        """Iterate over elements of the array.
-
+        """
+        Iterate over elements of the array.
         """
         # This needs to be implemented so that pandas recognizes extension
         # arrays as list-like. The default implementation makes successive
@@ -243,26 +249,32 @@ class ExtensionArray(object):
     @property
     def dtype(self):
         # type: () -> ExtensionDtype
-        """An instance of 'ExtensionDtype'."""
+        """
+        An instance of 'ExtensionDtype'.
+        """
         raise AbstractMethodError(self)
 
     @property
     def shape(self):
         # type: () -> Tuple[int, ...]
-        """Return a tuple of the array dimensions."""
+        """
+        Return a tuple of the array dimensions.
+        """
         return (len(self),)
 
     @property
     def ndim(self):
         # type: () -> int
-        """Extension Arrays are only allowed to be 1-dimensional."""
+        """
+        Extension Arrays are only allowed to be 1-dimensional.
+        """
         return 1
 
     @property
     def nbytes(self):
         # type: () -> int
-        """The number of bytes needed to store this object in memory.
-
+        """
+        The number of bytes needed to store this object in memory.
         """
         # If this is expensive to compute, return an approximate lower bound
         # on the number of bytes needed.
@@ -272,7 +284,8 @@ class ExtensionArray(object):
     # Additional Methods
     # ------------------------------------------------------------------------
     def astype(self, dtype, copy=True):
-        """Cast to a NumPy array with 'dtype'.
+        """
+        Cast to a NumPy array with 'dtype'.
 
         Parameters
         ----------
@@ -315,7 +328,8 @@ class ExtensionArray(object):
 
     def _values_for_argsort(self):
         # type: () -> ndarray
-        """Return values for sorting.
+        """
+        Return values for sorting.
 
         Returns
         -------
@@ -365,7 +379,8 @@ class ExtensionArray(object):
         return result
 
     def fillna(self, value=None, method=None, limit=None):
-        """ Fill NA/NaN values using the specified method.
+        """
+        Fill NA/NaN values using the specified method.
 
         Parameters
         ----------
@@ -418,7 +433,8 @@ class ExtensionArray(object):
         return new_values
 
     def dropna(self):
-        """ Return ExtensionArray without NA values
+        """
+        Return ExtensionArray without NA values
 
         Returns
         -------
@@ -462,7 +478,8 @@ class ExtensionArray(object):
         return self._concat_same_type([a, b])
 
     def unique(self):
-        """Compute the ExtensionArray of unique values.
+        """
+        Compute the ExtensionArray of unique values.
 
         Returns
         -------
@@ -475,7 +492,8 @@ class ExtensionArray(object):
 
     def _values_for_factorize(self):
         # type: () -> Tuple[ndarray, Any]
-        """Return an array and missing value suitable for factorization.
+        """
+        Return an array and missing value suitable for factorization.
 
         Returns
         -------
@@ -499,7 +517,8 @@ class ExtensionArray(object):
 
     def factorize(self, na_sentinel=-1):
         # type: (int) -> Tuple[ndarray, ExtensionArray]
-        """Encode the extension array as an enumerated type.
+        """
+        Encode the extension array as an enumerated type.
 
         Parameters
         ----------
@@ -552,7 +571,8 @@ class ExtensionArray(object):
 
     def take(self, indices, allow_fill=False, fill_value=None):
         # type: (Sequence[int], bool, Optional[Any]) -> ExtensionArray
-        """Take elements from an array.
+        """
+        Take elements from an array.
 
         Parameters
         ----------
@@ -641,7 +661,8 @@ class ExtensionArray(object):
 
     def copy(self, deep=False):
         # type: (bool) -> ExtensionArray
-        """Return a copy of the array.
+        """
+        Return a copy of the array.
 
         Parameters
         ----------
@@ -661,13 +682,16 @@ class ExtensionArray(object):
     def _formatting_values(self):
         # type: () -> np.ndarray
         # At the moment, this has to be an array since we use result.dtype
-        """An array of values to be printed in, e.g. the Series repr"""
+        """
+        An array of values to be printed in, e.g. the Series repr
+        """
         return np.array(self)
 
     @classmethod
     def _concat_same_type(cls, to_concat):
         # type: (Sequence[ExtensionArray]) -> ExtensionArray
-        """Concatenate multiple array
+        """
+        Concatenate multiple array
 
         Parameters
         ----------
@@ -689,7 +713,8 @@ class ExtensionArray(object):
     @property
     def _ndarray_values(self):
         # type: () -> np.ndarray
-        """Internal pandas method for lossy conversion to a NumPy ndarray.
+        """
+        Internal pandas method for lossy conversion to a NumPy ndarray.
 
         This method is not part of the pandas interface.
 
diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 42696e479..3ed2a3b39 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -200,7 +200,8 @@ def contains(cat, key, container):
         return any(loc_ in container for loc_ in loc)
 
 
-_codes_doc = """The category codes of this categorical.
+_codes_doc = """\
+The category codes of this categorical.
 
 Level codes are an array if integer which are the positions of the real
 values in the categories array.
@@ -435,7 +436,8 @@ class Categorical(ExtensionArray, PandasObject):
 
     @property
     def categories(self):
-        """The categories of this categorical.
+        """
+        The categories of this categorical.
 
         Setting assigns new values to each category (effectively a rename of
         each individual category).
@@ -474,12 +476,16 @@ class Categorical(ExtensionArray, PandasObject):
 
     @property
     def ordered(self):
-        """Whether the categories have an ordered relationship"""
+        """
+        Whether the categories have an ordered relationship
+        """
         return self.dtype.ordered
 
     @property
     def dtype(self):
-        """The :class:`~pandas.api.types.CategoricalDtype` for this instance"""
+        """
+        The :class:`~pandas.api.types.CategoricalDtype` for this instance
+        """
         return self._dtype
 
     @property
@@ -495,7 +501,9 @@ class Categorical(ExtensionArray, PandasObject):
         return Categorical(scalars, dtype=dtype)
 
     def copy(self):
-        """ Copy constructor. """
+        """
+        Copy constructor.
+        """
         return self._constructor(values=self._codes.copy(),
                                  dtype=self.dtype,
                                  fastpath=True)
@@ -526,17 +534,23 @@ class Categorical(ExtensionArray, PandasObject):
 
     @cache_readonly
     def ndim(self):
-        """Number of dimensions of the Categorical """
+        """
+        Number of dimensions of the Categorical
+        """
         return self._codes.ndim
 
     @cache_readonly
     def size(self):
-        """ return the len of myself """
+        """
+        return the len of myself
+        """
         return len(self)
 
     @cache_readonly
     def itemsize(self):
-        """ return the size of a single category """
+        """
+        return the size of a single category
+        """
         return self.categories.itemsize
 
     def tolist(self):
@@ -551,7 +565,9 @@ class Categorical(ExtensionArray, PandasObject):
 
     @property
     def base(self):
-        """ compat, we are always our own object """
+        """
+        compat, we are always our own object
+        """
         return None
 
     @classmethod
@@ -670,7 +686,8 @@ class Categorical(ExtensionArray, PandasObject):
     _codes = None
 
     def _get_codes(self):
-        """ Get the codes.
+        """
+        Get the codes.
 
         Returns
         -------
@@ -690,7 +707,8 @@ class Categorical(ExtensionArray, PandasObject):
     codes = property(fget=_get_codes, fset=_set_codes, doc=_codes_doc)
 
     def _set_categories(self, categories, fastpath=False):
-        """ Sets new categories inplace
+        """
+        Sets new categories inplace
 
         Parameters
         ----------
@@ -723,7 +741,8 @@ class Categorical(ExtensionArray, PandasObject):
         self._dtype = new_dtype
 
     def _set_dtype(self, dtype):
-        """Internal method for directly updating the CategoricalDtype
+        """
+        Internal method for directly updating the CategoricalDtype
 
         Parameters
         ----------
@@ -785,7 +804,8 @@ class Categorical(ExtensionArray, PandasObject):
 
     def set_categories(self, new_categories, ordered=None, rename=False,
                        inplace=False):
-        """ Sets the categories to the specified new_categories.
+        """
+        Sets the categories to the specified new_categories.
 
         `new_categories` can include new categories (which will result in
         unused categories) or remove old categories (which results in values
@@ -855,7 +875,8 @@ class Categorical(ExtensionArray, PandasObject):
             return cat
 
     def rename_categories(self, new_categories, inplace=False):
-        """ Renames categories.
+        """
+        Renames categories.
 
         Raises
         ------
@@ -948,7 +969,8 @@ class Categorical(ExtensionArray, PandasObject):
             return cat
 
     def reorder_categories(self, new_categories, ordered=None, inplace=False):
-        """ Reorders categories as specified in new_categories.
+        """
+        Reorders categories as specified in new_categories.
 
         `new_categories` need to include all old categories and no new category
         items.
@@ -990,7 +1012,8 @@ class Categorical(ExtensionArray, PandasObject):
                                    inplace=inplace)
 
     def add_categories(self, new_categories, inplace=False):
-        """ Add new categories.
+        """
+        Add new categories.
 
         `new_categories` will be included at the last/highest place in the
         categories and will be unused directly after this call.
@@ -1039,7 +1062,8 @@ class Categorical(ExtensionArray, PandasObject):
             return cat
 
     def remove_categories(self, removals, inplace=False):
-        """ Removes the specified categories.
+        """
+        Removes the specified categories.
 
         `removals` must be included in the old categories. Values which were in
         the removed categories will be set to NaN
@@ -1091,7 +1115,8 @@ class Categorical(ExtensionArray, PandasObject):
                                    rename=False, inplace=inplace)
 
     def remove_unused_categories(self, inplace=False):
-        """ Removes categories which are not used.
+        """
+        Removes categories which are not used.
 
         Parameters
         ----------
@@ -1214,7 +1239,8 @@ class Categorical(ExtensionArray, PandasObject):
     # for Series/ndarray like compat
     @property
     def shape(self):
-        """ Shape of the Categorical.
+        """
+        Shape of the Categorical.
 
         For internal compatibility with numpy arrays.
 
@@ -1306,6 +1332,9 @@ class Categorical(ExtensionArray, PandasObject):
 
     @property
     def T(self):
+        """
+        Return transposed numpy array.
+        """
         return self
 
     @property
@@ -1459,7 +1488,8 @@ class Categorical(ExtensionArray, PandasObject):
         return Series(count, index=CategoricalIndex(ix), dtype='int64')
 
     def get_values(self):
-        """ Return the values.
+        """
+        Return the values.
 
         For internal compatibility with pandas formatting.
 
@@ -1488,7 +1518,8 @@ class Categorical(ExtensionArray, PandasObject):
         # TODO(PY2): use correct signature
         # We have to do *args, **kwargs to avoid a a py2-only signature
         # issue since np.argsort differs from argsort.
-        """Return the indices that would sort the Categorical.
+        """
+        Return the indices that would sort the Categorical.
 
         Parameters
         ----------
@@ -1531,7 +1562,8 @@ class Categorical(ExtensionArray, PandasObject):
         return super(Categorical, self).argsort(*args, **kwargs)
 
     def sort_values(self, inplace=False, ascending=True, na_position='last'):
-        """ Sorts the Categorical by category value returning a new
+        """
+        Sorts the Categorical by category value returning a new
         Categorical by default.
 
         While an ordering is applied to the category values, sorting in this
@@ -1649,7 +1681,8 @@ class Categorical(ExtensionArray, PandasObject):
         return values
 
     def ravel(self, order='C'):
-        """ Return a flattened (numpy) array.
+        """
+        Return a flattened (numpy) array.
 
         For internal compatibility with numpy arrays.
 
@@ -1660,7 +1693,8 @@ class Categorical(ExtensionArray, PandasObject):
         return np.array(self)
 
     def view(self):
-        """Return a view of myself.
+        """
+        Return a view of myself.
 
         For internal compatibility with numpy arrays.
 
@@ -1672,7 +1706,8 @@ class Categorical(ExtensionArray, PandasObject):
         return self
 
     def to_dense(self):
-        """Return my 'dense' representation
+        """
+        Return my 'dense' representation
 
         For internal compatibility with numpy arrays.
 
@@ -1684,7 +1719,8 @@ class Categorical(ExtensionArray, PandasObject):
 
     @deprecate_kwarg(old_arg_name='fill_value', new_arg_name='value')
     def fillna(self, value=None, method=None, limit=None):
-        """ Fill NA/NaN values using the specified method.
+        """
+        Fill NA/NaN values using the specified method.
 
         Parameters
         ----------
@@ -1867,7 +1903,8 @@ class Categorical(ExtensionArray, PandasObject):
     take = take_nd
 
     def _slice(self, slicer):
-        """ Return a slice of myself.
+        """
+        Return a slice of myself.
 
         For internal compatibility with numpy arrays.
         """
@@ -1884,15 +1921,21 @@ class Categorical(ExtensionArray, PandasObject):
         return self._constructor(values=codes, dtype=self.dtype, fastpath=True)
 
     def __len__(self):
-        """The length of this Categorical."""
+        """
+        The length of this Categorical.
+        """
         return len(self._codes)
 
     def __iter__(self):
-        """Returns an Iterator over the values of this Categorical."""
+        """
+        Returns an Iterator over the values of this Categorical.
+        """
         return iter(self.get_values().tolist())
 
     def __contains__(self, key):
-        """Returns True if `key` is in this Categorical."""
+        """
+        Returns True if `key` is in this Categorical.
+        """
         # if key is a NaN, check if any NaN is in self.
         if isna(key):
             return self.isna().any()
@@ -1915,7 +1958,9 @@ class Categorical(ExtensionArray, PandasObject):
         return compat.text_type(result)
 
     def _repr_categories(self):
-        """ return the base repr for the categories """
+        """
+        return the base repr for the categories
+        """
         max_categories = (10 if get_option("display.max_categories") == 0 else
                           get_option("display.max_categories"))
         from pandas.io.formats import format as fmt
@@ -1932,7 +1977,9 @@ class Categorical(ExtensionArray, PandasObject):
         return category_strs
 
     def _repr_categories_info(self):
-        """ Returns a string representation of the footer."""
+        """
+        Returns a string representation of the footer.
+        """
 
         category_strs = self._repr_categories()
         dtype = getattr(self.categories, 'dtype_str',
@@ -1975,7 +2022,9 @@ class Categorical(ExtensionArray, PandasObject):
         return compat.text_type(result)
 
     def __unicode__(self):
-        """ Unicode representation. """
+        """
+        Unicode representation.
+        """
         _maxlen = 10
         if len(self._codes) > _maxlen:
             result = self._tidy_repr(_maxlen)
@@ -1988,13 +2037,17 @@ class Categorical(ExtensionArray, PandasObject):
         return result
 
     def _maybe_coerce_indexer(self, indexer):
-        """ return an indexer coerced to the codes dtype """
+        """
+        return an indexer coerced to the codes dtype
+        """
         if isinstance(indexer, np.ndarray) and indexer.dtype.kind == 'i':
             indexer = indexer.astype(self._codes.dtype)
         return indexer
 
     def __getitem__(self, key):
-        """ Return an item. """
+        """
+        Return an item.
+        """
         if isinstance(key, (int, np.integer)):
             i = self._codes[key]
             if i == -1:
@@ -2006,7 +2059,8 @@ class Categorical(ExtensionArray, PandasObject):
                                      dtype=self.dtype, fastpath=True)
 
     def __setitem__(self, key, value):
-        """ Item assignment.
+        """
+        Item assignment.
 
 
         Raises
@@ -2110,7 +2164,8 @@ class Categorical(ExtensionArray, PandasObject):
         return func(**kwargs)
 
     def min(self, numeric_only=None, **kwargs):
-        """ The minimum value of the object.
+        """
+        The minimum value of the object.
 
         Only ordered `Categoricals` have a minimum!
 
@@ -2135,7 +2190,8 @@ class Categorical(ExtensionArray, PandasObject):
             return self.categories[pointer]
 
     def max(self, numeric_only=None, **kwargs):
-        """ The maximum value of the object.
+        """
+        The maximum value of the object.
 
         Only ordered `Categoricals` have a maximum!
 
@@ -2294,7 +2350,8 @@ class Categorical(ExtensionArray, PandasObject):
             return False
 
     def describe(self):
-        """ Describes this Categorical
+        """
+        Describes this Categorical
 
         Returns
         -------
@@ -2451,6 +2508,9 @@ class CategoricalAccessor(PandasDelegate, PandasObject, NoNewAttributesMixin):
 
     @property
     def codes(self):
+        """
+        Return Series of codes as well as the index.
+        """
         from pandas import Series
         return Series(self._parent.codes, index=self.index)
 
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index a6f254c79..63044eb1a 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -77,7 +77,9 @@ class AttributesMixin(object):
         raise AbstractMethodError(cls)
 
     def _get_attributes_dict(self):
-        """return an attributes dict for my class"""
+        """
+        return an attributes dict for my class
+        """
         return {k: getattr(self, k, None) for k in self._attributes}
 
 
@@ -438,12 +440,16 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin):
 
     @property  # NB: override with cache_readonly in immutable subclasses
     def _isnan(self):
-        """ return if each value is nan"""
+        """
+        return if each value is nan
+        """
         return (self.asi8 == iNaT)
 
     @property  # NB: override with cache_readonly in immutable subclasses
     def hasnans(self):
-        """ return if I have any nans; enables various perf speedups """
+        """
+        return if I have any nans; enables various perf speedups
+        """
         return bool(self._isnan.any())
 
     def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):
@@ -477,7 +483,9 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin):
 
     @property
     def freq(self):
-        """Return the frequency object if it is set, otherwise None"""
+        """
+        Return the frequency object if it is set, otherwise None.
+        """
         return self._freq
 
     @freq.setter
@@ -643,7 +651,9 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin):
         return new_values.view('i8')
 
     def _add_nat(self):
-        """Add pd.NaT to self"""
+        """
+        Add pd.NaT to self
+        """
         if is_period_dtype(self):
             raise TypeError('Cannot add {cls} and {typ}'
                             .format(cls=type(self).__name__,
@@ -658,7 +668,9 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin):
         return type(self)(result, tz=self.tz, freq=None)
 
     def _sub_nat(self):
-        """Subtract pd.NaT from self"""
+        """
+        Subtract pd.NaT from self
+        """
         # GH#19124 Timedelta - datetime is not in general well-defined.
         # We make an exception for pd.NaT, which in this case quacks
         # like a timedelta.
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 45630f810..cfe3afcf3 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -341,6 +341,9 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin,
 
     @property
     def tz(self):
+        """
+        Return timezone.
+        """
         # GH 18595
         return self._tz
 
@@ -359,12 +362,16 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin,
 
     @property  # NB: override with cache_readonly in immutable subclasses
     def _timezone(self):
-        """ Comparable timezone both for pytz / dateutil"""
+        """
+        Comparable timezone both for pytz / dateutil
+        """
         return timezones.get_timezone(self.tzinfo)
 
     @property
     def offset(self):
-        """get/set the frequency of the instance"""
+        """
+        get/set the frequency of the instance
+        """
         msg = ('{cls}.offset has been deprecated and will be removed '
                'in a future version; use {cls}.freq instead.'
                .format(cls=type(self).__name__))
@@ -373,7 +380,9 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin,
 
     @offset.setter
     def offset(self, value):
-        """get/set the frequency of the instance"""
+        """
+        get/set the frequency of the instance
+        """
         msg = ('{cls}.offset has been deprecated and will be removed '
                'in a future version; use {cls}.freq instead.'
                .format(cls=type(self).__name__))
@@ -1063,19 +1072,19 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin,
 
         return tslib.ints_to_pydatetime(timestamps, box="date")
 
-    year = _field_accessor('year', 'Y', "The year of the datetime")
+    year = _field_accessor('year', 'Y', "\n The year of the datetime\n")
     month = _field_accessor('month', 'M',
-                            "The month as January=1, December=12")
-    day = _field_accessor('day', 'D', "The days of the datetime")
-    hour = _field_accessor('hour', 'h', "The hours of the datetime")
-    minute = _field_accessor('minute', 'm', "The minutes of the datetime")
-    second = _field_accessor('second', 's', "The seconds of the datetime")
+                            "\n The month as January=1, December=12 \n")
+    day = _field_accessor('day', 'D', "\nThe days of the datetime\n")
+    hour = _field_accessor('hour', 'h', "\nThe hours of the datetime\n")
+    minute = _field_accessor('minute', 'm', "\nThe minutes of the datetime\n")
+    second = _field_accessor('second', 's', "\nThe seconds of the datetime\n")
     microsecond = _field_accessor('microsecond', 'us',
-                                  "The microseconds of the datetime")
+                                  "\nThe microseconds of the datetime\n")
     nanosecond = _field_accessor('nanosecond', 'ns',
-                                 "The nanoseconds of the datetime")
+                                 "\nThe nanoseconds of the datetime\n")
     weekofyear = _field_accessor('weekofyear', 'woy',
-                                 "The week ordinal of the year")
+                                 "\nThe week ordinal of the year\n")
     week = weekofyear
     _dayofweek_doc = """
     The day of the week with Monday=0, Sunday=6.
@@ -1120,12 +1129,12 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin,
         "The name of day in a week (ex: Friday)\n\n.. deprecated:: 0.23.0")
 
     dayofyear = _field_accessor('dayofyear', 'doy',
-                                "The ordinal day of the year")
-    quarter = _field_accessor('quarter', 'q', "The quarter of the date")
+                                "\nThe ordinal day of the year\n")
+    quarter = _field_accessor('quarter', 'q', "\nThe quarter of the date\n")
     days_in_month = _field_accessor(
         'days_in_month',
         'dim',
-        "The number of days in the month")
+        "\nThe number of days in the month\n")
     daysinmonth = days_in_month
     _is_month_doc = """
         Indicates whether the date is the {first_or_last} day of the month.
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index e9d51aaea..7996e24d0 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -386,7 +386,8 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
         return cls(data, mask)
 
     def astype(self, dtype, copy=True):
-        """Cast to a NumPy array or IntegerArray with 'dtype'.
+        """
+        Cast to a NumPy array or IntegerArray with 'dtype'.
 
         Parameters
         ----------
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 6ed68ee89..e258e474f 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -204,7 +204,8 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, ExtensionArray):
 
     @classmethod
     def _from_datetime64(cls, data, freq, tz=None):
-        """Construct a PeriodArray from a datetime64 array
+        """
+        Construct a PeriodArray from a datetime64 array
 
         Parameters
         ----------
@@ -254,7 +255,9 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, ExtensionArray):
 
     @property
     def freq(self):
-        """Return the frequency object for this PeriodArray."""
+        """
+        Return the frequency object for this PeriodArray.
+        """
         return self.dtype.freq
 
     # --------------------------------------------------------------------
@@ -281,7 +284,9 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, ExtensionArray):
 
     @property
     def is_leap_year(self):
-        """ Logical indicating if the date belongs to a leap year """
+        """
+        Logical indicating if the date belongs to a leap year
+        """
         return isleapyear_arr(np.asarray(self.year))
 
     @property
@@ -570,7 +575,9 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, ExtensionArray):
     # Formatting
 
     def _format_native_types(self, na_rep=u'NaT', date_format=None, **kwargs):
-        """ actually format my specific types """
+        """
+        actually format my specific types
+        """
         # TODO(DatetimeArray): remove
         values = self.astype(object)
 
diff --git a/pandas/core/arrays/sparse.py b/pandas/core/arrays/sparse.py
index 9a5ef3b3a..ae5a4eb70 100644
--- a/pandas/core/arrays/sparse.py
+++ b/pandas/core/arrays/sparse.py
@@ -169,7 +169,9 @@ class SparseDtype(ExtensionDtype):
 
     @property
     def kind(self):
-        """The sparse kind. Either 'integer', or 'block'."""
+        """
+        The sparse kind. Either 'integer', or 'block'.
+        """
         return self.subtype.kind
 
     @property
@@ -285,7 +287,8 @@ class SparseDtype(ExtensionDtype):
         return isinstance(dtype, np.dtype) or dtype == 'Sparse'
 
     def update_dtype(self, dtype):
-        """Convert the SparseDtype to a new dtype.
+        """
+        Convert the SparseDtype to a new dtype.
 
         This takes care of converting the ``fill_value``.
 
@@ -478,7 +481,9 @@ def _sparse_array_op(left, right, op, name):
 
 
 def _wrap_result(name, data, sparse_index, fill_value, dtype=None):
-    """ wrap op result to have correct dtype """
+    """
+    wrap op result to have correct dtype
+    """
     if name.startswith('__'):
         # e.g. __eq__ --> eq
         name = name[2:-2]
@@ -787,7 +792,8 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
 
     @property
     def density(self):
-        """The percent of non- ``fill_value`` points, as decimal.
+        """
+        The percent of non- ``fill_value`` points, as decimal.
 
         Examples
         --------
@@ -800,7 +806,8 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
 
     @property
     def npoints(self):
-        """The number of non- ``fill_value`` points.
+        """
+        The number of non- ``fill_value`` points.
 
         Examples
         --------
@@ -1523,12 +1530,16 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
             return (sp_sum + self.fill_value * nsparse) / (ct + nsparse)
 
     def transpose(self, *axes):
-        """Returns the SparseArray."""
+        """
+        Returns the SparseArray.
+        """
         return self
 
     @property
     def T(self):
-        """Returns the SparseArray."""
+        """
+        Returns the SparseArray.
+        """
         return self
 
     # ------------------------------------------------------------------------
@@ -1742,14 +1753,18 @@ SparseArray._add_unary_ops()
 
 
 def _maybe_to_dense(obj):
-    """ try to convert to dense """
+    """
+    try to convert to dense
+    """
     if hasattr(obj, 'to_dense'):
         return obj.to_dense()
     return obj
 
 
 def _maybe_to_sparse(array):
-    """ array must be SparseSeries or SparseArray """
+    """
+    array must be SparseSeries or SparseArray
+    """
     if isinstance(array, ABCSparseSeries):
         array = array.values.copy()
     return array
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index c0cfa9968..830283d31 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -684,16 +684,16 @@ class TimedeltaArrayMixin(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
         return tslibs.ints_to_pytimedelta(self.asi8)
 
     days = _field_accessor("days", "days",
-                           " Number of days for each element. ")
+                           "\nNumber of days for each element.\n")
     seconds = _field_accessor("seconds", "seconds",
-                              " Number of seconds (>= 0 and less than 1 day) "
-                              "for each element. ")
+                              "\nNumber of seconds (>= 0 and less than 1 day) "
+                              "for each element.\n")
     microseconds = _field_accessor("microseconds", "microseconds",
                                    "\nNumber of microseconds (>= 0 and less "
-                                   "than 1 second) for each\nelement. ")
+                                   "than 1 second) for each element.\n")
     nanoseconds = _field_accessor("nanoseconds", "nanoseconds",
                                   "\nNumber of nanoseconds (>= 0 and less "
-                                  "than 1 microsecond) for each\nelement.\n")
+                                  "than 1 microsecond) for each element.\n")
 
     @property
     def components(self):
diff --git a/pandas/core/base.py b/pandas/core/base.py
index 86de25444..e7c3a45a7 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -631,7 +631,9 @@ class SelectionMixin(object):
             return result
 
     def _shallow_copy(self, obj=None, obj_type=None, **kwargs):
-        """ return a new object with the replacement attributes """
+        """
+        return a new object with the replacement attributes
+        """
         if obj is None:
             obj = self._selected_obj.copy()
         if obj_type is None:
@@ -644,7 +646,9 @@ class SelectionMixin(object):
         return obj_type(obj, **kwargs)
 
     def _is_cython_func(self, arg):
-        """ if we define an internal function for this argument, return it """
+        """
+        if we define an internal function for this argument, return it
+        """
         return self._cython_table.get(arg)
 
     def _is_builtin_func(self, arg):
@@ -675,7 +679,8 @@ class IndexOpsMixin(object):
 
     @property
     def _is_homogeneous_type(self):
-        """Whether the object has a single dtype.
+        """
+        Whether the object has a single dtype.
 
         By definition, Series and Index are always considered homogeneous.
         A MultiIndex may or may not be homogeneous, depending on the
@@ -899,7 +904,8 @@ class IndexOpsMixin(object):
     @property
     def _ndarray_values(self):
         # type: () -> np.ndarray
-        """The data as an ndarray, possibly losing information.
+        """
+        The data as an ndarray, possibly losing information.
 
         The expectation is that this is cheap to compute, and is primarily
         used for interacting with our indexers.
@@ -1046,7 +1052,8 @@ class IndexOpsMixin(object):
         return func(**kwds)
 
     def _map_values(self, mapper, na_action=None):
-        """An internal function that maps values using the input
+        """
+        An internal function that maps values using the input
         correspondence (which can be a dict, Series, or function).
 
         Parameters
@@ -1320,7 +1327,8 @@ class IndexOpsMixin(object):
         return algorithms.factorize(self, sort=sort, na_sentinel=na_sentinel)
 
     _shared_docs['searchsorted'] = (
-        """Find indices where elements should be inserted to maintain order.
+        """
+        Find indices where elements should be inserted to maintain order.
 
         Find the indices into a sorted %(klass)s `self` such that, if the
         corresponding elements in `value` were inserted before the indices,
diff --git a/pandas/core/dtypes/base.py b/pandas/core/dtypes/base.py
index df0e89cce..aa81e88ab 100644
--- a/pandas/core/dtypes/base.py
+++ b/pandas/core/dtypes/base.py
@@ -146,7 +146,8 @@ class _DtypeOpsMixin(object):
 
 
 class ExtensionDtype(_DtypeOpsMixin):
-    """A custom data type, to be paired with an ExtensionArray.
+    """
+    A custom data type, to be paired with an ExtensionArray.
 
     .. versionadded:: 0.23.0
 
@@ -211,7 +212,8 @@ class ExtensionDtype(_DtypeOpsMixin):
     @property
     def type(self):
         # type: () -> type
-        """The scalar type for the array, e.g. ``int``
+        """
+        The scalar type for the array, e.g. ``int``
 
         It's expected ``ExtensionArray[item]`` returns an instance
         of ``ExtensionDtype.type`` for scalar ``item``, assuming
@@ -223,7 +225,8 @@ class ExtensionDtype(_DtypeOpsMixin):
     @property
     def kind(self):
         # type () -> str
-        """A character code (one of 'biufcmMOSUV'), default 'O'
+        """
+        A character code (one of 'biufcmMOSUV'), default 'O'
 
         This should match the NumPy dtype used when the array is
         converted to an ndarray, which is probably 'O' for object if
@@ -239,7 +242,8 @@ class ExtensionDtype(_DtypeOpsMixin):
     @property
     def name(self):
         # type: () -> str
-        """A string identifying the data type.
+        """
+        A string identifying the data type.
 
         Will be used for display in, e.g. ``Series.dtype``
         """
@@ -247,7 +251,8 @@ class ExtensionDtype(_DtypeOpsMixin):
 
     @classmethod
     def construct_array_type(cls):
-        """Return the array type associated with this dtype
+        """
+        Return the array type associated with this dtype
 
         Returns
         -------
@@ -257,7 +262,8 @@ class ExtensionDtype(_DtypeOpsMixin):
 
     @classmethod
     def construct_from_string(cls, string):
-        """Attempt to construct this type from a string.
+        """
+        Attempt to construct this type from a string.
 
         Parameters
         ----------
diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index fee983f96..e432f3604 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -342,7 +342,8 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
 
     @classmethod
     def construct_array_type(cls):
-        """Return the array type associated with this dtype
+        """
+        Return the array type associated with this dtype
 
         Returns
         -------
@@ -353,7 +354,8 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
 
     @classmethod
     def construct_from_string(cls, string):
-        """ attempt to construct this type from a string, raise a TypeError if
+        """
+        attempt to construct this type from a string, raise a TypeError if
         it's not possible """
         try:
             if string == 'category':
@@ -459,7 +461,9 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
 
     @property
     def ordered(self):
-        """Whether the categories have an ordered relationship"""
+        """
+        Whether the categories have an ordered relationship
+        """
         return self._ordered
 
     @property
@@ -488,7 +492,8 @@ class DatetimeTZDtype(PandasExtensionDtype):
     _cache = {}
 
     def __new__(cls, unit=None, tz=None):
-        """ Create a new unit if needed, otherwise return from the cache
+        """
+        Create a new unit if needed, otherwise return from the cache
 
         Parameters
         ----------
@@ -547,7 +552,8 @@ class DatetimeTZDtype(PandasExtensionDtype):
 
     @classmethod
     def construct_array_type(cls):
-        """Return the array type associated with this dtype
+        """
+        Return the array type associated with this dtype
 
         Returns
         -------
@@ -558,7 +564,8 @@ class DatetimeTZDtype(PandasExtensionDtype):
 
     @classmethod
     def construct_from_string(cls, string):
-        """ attempt to construct this type from a string, raise a TypeError if
+        """
+        attempt to construct this type from a string, raise a TypeError if
         it's not possible
         """
         try:
@@ -775,7 +782,8 @@ class IntervalDtype(PandasExtensionDtype, ExtensionDtype):
 
     @classmethod
     def construct_array_type(cls):
-        """Return the array type associated with this dtype
+        """
+        Return the array type associated with this dtype
 
         Returns
         -------
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index c58c84b42..e780c8344 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -152,6 +152,9 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @property
     def is_copy(self):
+        """
+        Return the copy.
+        """
         warnings.warn("Attribute 'is_copy' is deprecated and will be removed "
                       "in a future version.", FutureWarning, stacklevel=2)
         return self._is_copy
@@ -415,12 +418,16 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @property
     def shape(self):
-        """Return a tuple of axis dimensions"""
+        """
+        Return a tuple of axis dimensions
+        """
         return tuple(len(self._get_axis(a)) for a in self._AXIS_ORDERS)
 
     @property
     def axes(self):
-        """Return index label(s) of the internal NDFrame"""
+        """
+        Return index label(s) of the internal NDFrame
+        """
         # we do it this way because if we have reversed axes, then
         # the block manager shows then reversed
         return [self._get_axis(a) for a in self._AXIS_ORDERS]
@@ -685,7 +692,8 @@ class NDFrame(PandasObject, SelectionMixin):
         return self._constructor(new_values, *new_axes).__finalize__(self)
 
     def droplevel(self, level, axis=0):
-        """Return DataFrame with requested index / column level(s) removed.
+        """
+        Return DataFrame with requested index / column level(s) removed.
 
         .. versionadded:: 0.24.0
 
@@ -1457,7 +1465,8 @@ class NDFrame(PandasObject, SelectionMixin):
     __bool__ = __nonzero__
 
     def bool(self):
-        """Return the bool of a single element PandasObject.
+        """
+        Return the bool of a single element PandasObject.
 
         This must be a boolean scalar value, either True or False.  Raise a
         ValueError if the PandasObject does not have exactly 1 element, or that
@@ -1893,7 +1902,9 @@ class NDFrame(PandasObject, SelectionMixin):
     #    return dict(typestr=values.dtype.str,shape=values.shape,data=values)
 
     def to_dense(self):
-        """Return dense representation of NDFrame (as opposed to sparse)"""
+        """
+        Return dense representation of NDFrame (as opposed to sparse)
+        """
         # compat
         return self
 
@@ -3581,7 +3592,8 @@ class NDFrame(PandasObject, SelectionMixin):
     _xs = xs
 
     def select(self, crit, axis=0):
-        """Return data corresponding to axis labels matching criteria
+        """
+        Return data corresponding to axis labels matching criteria
 
         .. deprecated:: 0.21.0
             Use df.loc[df.index.map(crit)] to select via labels
@@ -4342,7 +4354,8 @@ class NDFrame(PandasObject, SelectionMixin):
     def _reindex_multi(self, axes, copy, fill_value):
         return NotImplemented
 
-    _shared_docs['reindex_axis'] = ("""Conform input object to new index
+    _shared_docs['reindex_axis'] = ("""
+        Conform input object to new index
         with optional filling logic, placing NA/NaN in locations having
         no value in the previous index. A new object is produced unless
         the new index is equivalent to the current one and copy=False.
@@ -5147,7 +5160,8 @@ class NDFrame(PandasObject, SelectionMixin):
     # Internal Interface Methods
 
     def as_matrix(self, columns=None):
-        """Convert the frame to its Numpy-array representation.
+        """
+        Convert the frame to its Numpy-array representation.
 
         .. deprecated:: 0.23.0
             Use :meth:`DataFrame.values` instead.
@@ -5793,7 +5807,8 @@ class NDFrame(PandasObject, SelectionMixin):
 
     def convert_objects(self, convert_dates=True, convert_numeric=False,
                         convert_timedeltas=True, copy=True):
-        """Attempt to infer better dtype for object columns.
+        """
+        Attempt to infer better dtype for object columns.
 
         .. deprecated:: 0.21.0
 
@@ -9698,7 +9713,9 @@ class NDFrame(PandasObject, SelectionMixin):
         return d
 
     def _check_percentile(self, q):
-        """Validate percentiles (used by describe and quantile)."""
+        """
+        Validate percentiles (used by describe and quantile).
+        """
 
         msg = ("percentiles should all be in the interval [0, 1]. "
                "Try {0} instead.")
@@ -9857,7 +9874,9 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @classmethod
     def _add_numeric_operations(cls):
-        """Add the operations to the cls; evaluate the doc strings again"""
+        """
+        Add the operations to the cls; evaluate the doc strings again
+        """
 
         axis_descr, name, name2 = _doc_parms(cls)
 
@@ -9983,7 +10002,8 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @classmethod
     def _add_series_only_operations(cls):
-        """Add the series only operations to the cls; evaluate the doc
+        """
+        Add the series only operations to the cls; evaluate the doc
         strings again.
         """
 
@@ -10009,7 +10029,8 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @classmethod
     def _add_series_or_dataframe_operations(cls):
-        """Add the series or dataframe only operations to the cls; evaluate
+        """
+        Add the series or dataframe only operations to the cls; evaluate
         the doc strings again.
         """
 
@@ -10071,7 +10092,8 @@ class NDFrame(PandasObject, SelectionMixin):
         """
 
     def _find_valid_index(self, how):
-        """Retrieves the index of the first valid value.
+        """
+        Retrieves the index of the first valid value.
 
         Parameters
         ----------
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 8bb9d0b96..52127811b 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -33,7 +33,9 @@ _index_doc_kwargs = dict(ibase._index_doc_kwargs)
 
 
 class DatetimeIndexOpsMixin(DatetimeLikeArrayMixin):
-    """ common ops mixin to support a unified interface datetimelike Index """
+    """
+    common ops mixin to support a unified interface datetimelike Index
+    """
 
     # override DatetimeLikeArrayMixin method
     copy = Index.copy
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index 567834b04..4e5894916 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -1,4 +1,3 @@
-
 # pylint: disable=E1101,E1103,W0232
 import datetime
 from sys import getsizeof
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 71f55f902..c1a78b985 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -934,7 +934,8 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index,
         return self.view('i8')
 
     def item(self):
-        """ return the first element of the underlying data as a python
+        """
+        return the first element of the underlying data as a python
         scalar
         """
         # TODO(DatetimeArray): remove
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index cfa451db8..0914324a0 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -2415,7 +2415,8 @@ class _iAtIndexer(_ScalarAccessIndexer):
 
 
 def length_of_indexer(indexer, target=None):
-    """return the length of a single non-tuple indexer which could be a slice
+    """
+    return the length of a single non-tuple indexer which could be a slice
     """
     if target is not None and isinstance(indexer, slice):
         target_len = len(target)
@@ -2443,7 +2444,8 @@ def length_of_indexer(indexer, target=None):
 
 
 def convert_to_index_sliceable(obj, key):
-    """if we are index sliceable, then return my slicer, otherwise return None
+    """
+    if we are index sliceable, then return my slicer, otherwise return None
     """
     idx = obj.index
     if isinstance(key, slice):
@@ -2493,7 +2495,8 @@ def check_bool_indexer(ax, key):
 
 
 def check_setitem_lengths(indexer, value, values):
-    """Validate that value and indexer are the same length.
+    """
+    Validate that value and indexer are the same length.
 
     An special-case is allowed for when the indexer is a boolean array
     and the number of true values equals the length of ``value``. In
@@ -2536,7 +2539,8 @@ def check_setitem_lengths(indexer, value, values):
 
 
 def convert_missing_indexer(indexer):
-    """ reverse convert a missing indexer, which is a dict
+    """
+    reverse convert a missing indexer, which is a dict
     return the scalar indexer and a boolean indicating if we converted
     """
 
@@ -2553,7 +2557,9 @@ def convert_missing_indexer(indexer):
 
 
 def convert_from_missing_indexer_tuple(indexer, axes):
-    """ create a filtered indexer that doesn't have any missing indexers """
+    """
+    create a filtered indexer that doesn't have any missing indexers
+    """
 
     def get_indexer(_i, _idx):
         return (axes[_i].get_loc(_idx['key']) if isinstance(_idx, dict) else
@@ -2607,7 +2613,8 @@ def maybe_convert_indices(indices, n):
 
 
 def validate_indices(indices, n):
-    """Perform bounds-checking for an indexer.
+    """
+    Perform bounds-checking for an indexer.
 
     -1 is allowed for indicating missing values.
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 0d6c9f4d8..8d4d7677c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -389,6 +389,9 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     @property
     def name(self):
+        """
+        Return name of the Series.
+        """
         return self._name
 
     @name.setter
@@ -689,6 +692,9 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     @property
     def real(self):
+        """
+        Return the real value of vector.
+        """
         return self.values.real
 
     @real.setter
@@ -697,6 +703,9 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     @property
     def imag(self):
+        """
+        Return imag value of vector.
+        """
         return self.values.imag
 
     @imag.setter
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index e639e2e65..d3d38d26e 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -2807,7 +2807,8 @@ class StringMethods(NoNewAttributesMixin):
         return self._wrap_result(result)
 
     def normalize(self, form):
-        """Return the Unicode normal form for the strings in the Series/Index.
+        """
+        Return the Unicode normal form for the strings in the Series/Index.
         For more information on the forms, see the
         :func:`unicodedata.normalize`.
 
diff --git a/pandas/core/tools/datetimes.py b/pandas/core/tools/datetimes.py
index 7a87e33c7..658361401 100644
--- a/pandas/core/tools/datetimes.py
+++ b/pandas/core/tools/datetimes.py
@@ -702,9 +702,10 @@ def _assemble_from_unit_mappings(arg, errors):
 
 
 def _attempt_YYYYMMDD(arg, errors):
-    """ try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,
-        arg is a passed in as an object dtype, but could really be ints/strings
-        with nan-like/or floats (e.g. with nan)
+    """
+    try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,
+    arg is a passed in as an object dtype, but could really be ints/strings
+    with nan-like/or floats (e.g. with nan)
 
     Parameters
     ----------
diff --git a/pandas/plotting/_converter.py b/pandas/plotting/_converter.py
index 20e4fdffc..813969413 100644
--- a/pandas/plotting/_converter.py
+++ b/pandas/plotting/_converter.py
@@ -55,7 +55,8 @@ def get_pairs():
 
 
 def register(explicit=True):
-    """Register Pandas Formatters and Converters with matplotlib
+    """
+    Register Pandas Formatters and Converters with matplotlib
 
     This function modifies the global ``matplotlib.units.registry``
     dictionary. Pandas adds custom converters for
@@ -87,7 +88,8 @@ def register(explicit=True):
 
 
 def deregister():
-    """Remove pandas' formatters and converters
+    """
+    Remove pandas' formatters and converters
 
     Removes the custom converters added by :func:`register`. This
     attempts to set the state of the registry back to the state before
diff --git a/pandas/plotting/_core.py b/pandas/plotting/_core.py
index 7ec97df69..ec6743e20 100644
--- a/pandas/plotting/_core.py
+++ b/pandas/plotting/_core.py
@@ -1945,7 +1945,6 @@ _shared_docs['plot'] = """
       for bar plot layout by `position` keyword.
       From 0 (left/bottom-end) to 1 (right/top-end). Default is 0.5 (center)
     %(klass_note)s
-
     """
 
 
@@ -2706,7 +2705,8 @@ class BasePlotMethods(PandasObject):
 
 
 class SeriesPlotMethods(BasePlotMethods):
-    """Series plotting accessor and method
+    """
+    Series plotting accessor and method
 
     Examples
     --------

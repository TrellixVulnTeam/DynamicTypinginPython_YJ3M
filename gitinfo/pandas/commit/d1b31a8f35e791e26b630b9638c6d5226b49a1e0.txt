commit d1b31a8f35e791e26b630b9638c6d5226b49a1e0
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 5 03:32:25 2010 +0000

    more unit testing, starting merge function cleanup
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@151 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9fba03fa4..065239478 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1,5 +1,4 @@
-# pylint: disable-msg=E1101
-# pylint: disable-msg=E1103
+# pylint: disable-msg=E1101,E1103
 # pylint: disable-msg=W0212,W0231,W0703,W0622
 
 from cStringIO import StringIO
@@ -146,7 +145,7 @@ class DataFrame(Picklable, Groupable):
 
                 elif isinstance(v, dict):
                     if index is None:
-                        index = Index(sorted(v.keys()))
+                        index = Index(_try_sort(v))
                     elif need_labels:
                         raise Exception('Cannot mix Series / dict objects'
                                         ' with ndarray / sequence input')
@@ -195,9 +194,10 @@ class DataFrame(Picklable, Groupable):
     def __setstate__(self, state):
         series, idx = state
 
-        self.index = index = _unpickle_array(idx)
+        index = _unpickle_array(idx)
         self._series = dict((k, Series(v, index=index))
                             for k, v in series.iteritems())
+        self.index = index
 
     _index = None
     def _set_index(self, index):
@@ -206,6 +206,9 @@ class DataFrame(Picklable, Groupable):
         else:
             self._index = Index(index)
 
+        for v in self._series.values():
+            v.index = self._index
+
     def _get_index(self):
         return self._index
 
@@ -535,7 +538,7 @@ class DataFrame(Picklable, Groupable):
         series = self._series
 
         if columns is None:
-            columns = sorted(series.keys())
+            columns = _try_sort(series)
         else:
             columns = [c for c in columns if c in self]
 
@@ -567,17 +570,18 @@ class DataFrame(Picklable, Groupable):
 
     def info(self, buffer=sys.stdout):
         """Concise summary of a DataFrame, used in __repr__ when very large."""
-        print >> buffer, 'Index: %s entries, %s to %s' % (len(self.index),
-                                                          min(self.index),
-                                                          max(self.index))
-        print >> buffer, 'Data columns:'
+        print >> buffer, 'Index: %s entries' % len(self.index),
+        if len(self.index) > 0:
+            print >> buffer, ', %s to %s' % (self.index[0], self.index[-1])
+        else:
+            print >> buffer, ''
 
         if len(self._series) == 0:
             print >> buffer, 'DataFrame is empty!'
             return
 
         series = self._series
-        columns = sorted(self.cols())
+        columns = _try_sort(self.cols())
         space = max([len(str(k)) for k in columns]) + 4
         for k in columns:
             out = _pfixed(k, space)
@@ -591,7 +595,7 @@ class DataFrame(Picklable, Groupable):
 
     def cols(self):
         """Return sorted list of frame's columns"""
-        return sorted(self._series.keys())
+        return _try_sort(self._series)
 
     # For DataMatrix compatibility
     columns = property(lambda self: Index(self.cols()))
@@ -1197,7 +1201,7 @@ class DataFrame(Picklable, Groupable):
             frame = self
 
         do_fill = fill_value is not None
-        unionCols = sorted(set(frame.cols() + other.cols()))
+        unionCols = _try_sort(set(frame.cols() + other.cols()))
 
         result = {}
         for col in unionCols:
@@ -1344,7 +1348,7 @@ class DataFrame(Picklable, Groupable):
         overlap = set(self.cols()) & set(other.cols())
 
         if overlap:
-            raise Exception('Columns overlap: %s' % sorted(overlap))
+            raise Exception('Columns overlap: %s' % _try_sort(overlap))
 
         if len(other.index) == 0:
             result = self.copy()
@@ -1387,7 +1391,7 @@ class DataFrame(Picklable, Groupable):
         """
         from pylab import plot
 
-        for col in sorted(self.columns):
+        for col in _try_sort(self.columns):
             s = self[col]
             plot(s.index, s, label=col)
 
@@ -1735,3 +1739,9 @@ class DataFrame(Picklable, Groupable):
 
         return Series(theSkew, index=self._get_agg_axis(axis))
 
+def _try_sort(iterable):
+    listed = list(iterable)
+    try:
+        return sorted(listed)
+    except Exception:
+        return listed
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 96013d9fe..4eecc2c27 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -8,7 +8,7 @@ from numpy import NaN
 import numpy as np
 
 from pandas.core.common import _pfixed, _pickle_array, _unpickle_array
-from pandas.core.frame import DataFrame
+from pandas.core.frame import DataFrame, _try_sort
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series
 from pandas.lib.tseries import isnull, notnull
@@ -137,8 +137,8 @@ class DataMatrix(DataFrame):
                 objectDict[k] = v
 
         if columns is None:
-            columns = Index(sorted(valueDict))
-            objectColumns = Index(sorted(objectDict))
+            columns = Index(_try_sort(valueDict))
+            objectColumns = Index(_try_sort(objectDict))
         else:
             objectColumns = Index([c for c in columns if c in objectDict])
             columns = Index([c for c in columns if c not in objectDict])
@@ -527,18 +527,6 @@ class DataMatrix(DataFrame):
         if value.dtype not in self._dataTypes:
             isObject = True
 
-        if len(self.columns) == 0:
-            if isObject:
-                if self.objects is None:
-                    self.objects = DataMatrix({key : value},
-                                              index=self.index)
-                else:
-                    self.objects[key] = value
-            else:
-                self.values = value.reshape((len(value), 1)).copy()
-                self.columns = Index([key])
-            return
-
         if self.values.dtype == np.object_:
             if key in self.columns:
                 loc = self.columns.indexMap[key]
@@ -604,7 +592,7 @@ class DataMatrix(DataFrame):
         """
         if key in self.columns:
             loc = self.columns.indexMap[key]
-            if loc == self.values.shape[1]:
+            if loc == self.values.shape[1] - 1:
                 newValues = self.values[:, :loc]
                 newColumns = self.columns[:loc]
             else:
@@ -613,9 +601,11 @@ class DataMatrix(DataFrame):
                                                    self.columns[loc+1:])))
             self.values = newValues
             self.columns = newColumns
-
-        if self.objects is not None and key in self.objects:
-            del self.objects[key]
+        else:
+            if self.objects is not None and key in self.objects:
+                del self.objects[key]
+            else:
+                raise KeyError('%s' % key)
 
     def __iter__(self):
         """Iterate over columns of the frame."""
@@ -947,23 +937,22 @@ class DataMatrix(DataFrame):
 
         Returns
         -------
-        DataMatrix with NaN's filled
+        y : DataMatrix
 
         See also
         --------
-        reindex, asfreq
+        DataMatrix.reindex, DataMatrix.asfreq
         """
         if value is None:
             result = {}
-            for col in self._series:
-                series = self._series[col]
-                filledSeries = series.fill(method=method, value=value)
+            series = self._series
+            for col, s in series.iteritems():
+                result[col] = s.fill(method=method, value=value)
 
-                result[col] = filledSeries
             return DataMatrix(result, index=self.index, objects=self.objects)
         else:
-            gotFloat = isinstance(value, (int, float))
-            if gotFloat and self.values.dtype == np.float64:
+            if (isinstance(value, (int, float))
+                and self.values.dtype == np.float64):
                 # Float type values
                 if len(self.columns) == 0:
                     return self
@@ -971,13 +960,13 @@ class DataMatrix(DataFrame):
                 vals = self.values.copy()
                 vals.flat[isnull(vals.ravel())] = value
 
-                objectsToUse = None
+                objects = None
 
                 if self.objects is not None:
-                    objectsToUse = self.objects.copy()
+                    objects = self.objects.copy()
 
                 return DataMatrix(vals, index=self.index, columns=self.columns,
-                                  objects=objectsToUse)
+                                  objects=objects)
 
             else:
                 # Object type values
@@ -1019,7 +1008,7 @@ class DataMatrix(DataFrame):
 
         return result
 
-    def merge(self, other, on=None):
+    def merge(self, other, on=None, how='left'):
         """
         Merge DataFrame or DataMatrix with this one on some many-to-one index
 
@@ -1029,6 +1018,12 @@ class DataMatrix(DataFrame):
             Index should be similar to one of the columns in this one
         on : string
             Column name to use
+        how : {'left', 'right', 'outer', 'inner'}
+            How to handle indexes of the two objects.
+              * left: use calling frame's index
+              * right: use input frame's index
+              * outer: form union of indexes
+              * inner: use intersection of indexes
 
         Examples
         --------
@@ -1045,12 +1040,10 @@ class DataMatrix(DataFrame):
         if on not in self:
             raise Exception('%s column not contained in this frame!' % on)
 
-        otherM = other.values
-        indexMap = other.index.indexMap
+        fillVec, mask = tseries.getMergeVec(self[on],
+                                            other.index.indexMap)
 
-        fillVec, mask = tseries.getMergeVec(self[on], indexMap)
-
-        tmpMatrix = otherM.take(fillVec, axis=0)
+        tmpMatrix = other.values.take(fillVec, axis=0)
         tmpMatrix[-mask] = NaN
 
         seriesDict = dict((col, tmpMatrix[:, j])
@@ -1058,9 +1051,8 @@ class DataMatrix(DataFrame):
 
         if getattr(other, 'objects'):
             objects = other.objects
-            objM = objects.values
 
-            tmpMat = objM.take(fillVec, axis=0)
+            tmpMat = objects.values.take(fillVec, axis=0)
             tmpMat[-mask] = NaN
             objDict = dict((col, tmpMat[:, j])
                            for j, col in enumerate(objects.columns))
@@ -1071,6 +1063,67 @@ class DataMatrix(DataFrame):
 
         return self.leftJoin(filledFrame)
 
+    def leftJoin(self, *frames):
+        """
+        Insert columns of input DataFrames / dicts into this one.
+
+        Columns must not overlap. Returns a copy.
+
+        Parameters
+        ----------
+        *frames : list-like
+            List of frames (DataMatrix or DataFrame) as function arguments
+
+        Returns
+        -------
+        DataMatrix
+        """
+        unionCols = set(self.columns)
+        frames = list(frames)
+
+        for frame in frames:
+            cols = set(frame.columns)
+            if unionCols & cols:
+                raise Exception('Overlapping columns!')
+            unionCols |= cols
+
+        seriesDict = self._series
+
+        for frame in frames:
+            frame = frame.reindex(self.index)
+            seriesDict.update(frame._series)
+
+        return DataMatrix(seriesDict, index=self.index)
+
+    def outerJoin(self, *frames):
+        """
+        Form union of input frames.
+
+        Columns must not overlap. Returns a copy.
+
+        Parameters
+        ----------
+        *frames : list-like
+            List of frames (DataMatrix or DataFrame) as function arguments
+
+        Returns
+        -------
+        DataMatrix
+        """
+        mergedSeries = self._series.copy()
+
+        unionIndex = self.index
+        for frame in frames:
+            unionIndex  = unionIndex + frame.index
+
+        for frame in frames:
+            for col, series in frame.iteritems():
+                if col in mergedSeries:
+                    raise Exception('Overlapping columns!')
+                mergedSeries[col] = series
+
+        return DataMatrix(mergedSeries)
+
     def _reindex_index(self, index, method):
         if index is self.index:
             return self.copy()
@@ -1282,68 +1335,6 @@ class DataMatrix(DataFrame):
         else:
             return super(DataMatrix, self).append(other)
 
-    def outerJoin(self, *frames):
-        """
-        Form union of input frames.
-
-        Columns must not overlap. Returns a copy.
-
-        Parameters
-        ----------
-        *frames : list-like
-            List of frames (DataMatrix or DataFrame) as function arguments
-
-        Returns
-        -------
-        DataMatrix
-        """
-        mergedSeries = self._series.copy()
-
-        unionIndex = self.index
-        for frame in frames:
-            unionIndex  = unionIndex + frame.index
-
-        for frame in frames:
-            for col, series in frame.iteritems():
-                if col in mergedSeries:
-                    raise Exception('Overlapping columns!')
-                mergedSeries[col] = series
-
-        return DataMatrix(mergedSeries)
-
-    def leftJoin(self, *frames):
-        """
-        Insert columns of input DataFrames / dicts into this one.
-
-        Columns must not overlap. Returns a copy.
-
-        Parameters
-        ----------
-        *frames : list-like
-            List of frames (DataMatrix or DataFrame) as function arguments
-
-        Returns
-        -------
-        DataMatrix
-        """
-
-        unionCols = set(self.columns)
-        frames = list(frames)
-
-        for frame in frames:
-            cols = set(frame.columns)
-            if unionCols & cols:
-                raise Exception('Overlapping columns!')
-            unionCols |= cols
-
-        seriesDict = self._series
-
-        for frame in frames:
-            frame = frame.reindex(self.index)
-            seriesDict.update(frame._series)
-
-        return DataMatrix(seriesDict, index=self.index)
-
 def _reorder_columns(mat, current, desired):
     fillVec, mask = tseries.getFillVec(current, desired, current.indexMap,
                                        desired.indexMap, '')
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 18f6702f9..e3e77b438 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -100,15 +100,6 @@ class Series(np.ndarray, Picklable, Groupable):
     If you combine two series, all values for an index position must
     be present or the value for that index position will be nan. The
     new index is the sorted union of the two Series indices.
-
-    Examples
-    --------
-        >>> s = Series(arr, index=Index(dates))
-        >>> t = Series(otherArr, index=Index(otherDates))
-        >>> s / t # --> new Series resulting from by-index division of elements
-        >>> d = s.index[5]
-        >>> s[5]
-        >>> s[d]    # Valid
     """
     def __new__(cls, data, index=None, dtype=None, copy=False):
         if isinstance(data, Series):
@@ -124,6 +115,8 @@ class Series(np.ndarray, Picklable, Groupable):
 
         if subarr.ndim == 0:
             return subarr.item()
+        elif subarr.ndim > 1:
+            raise Exception('Data must be 1-dimensional')
 
         if index is None:
             raise Exception('Index cannot be None!')
@@ -145,6 +138,7 @@ class Series(np.ndarray, Picklable, Groupable):
     def __hash__(self):
         raise TypeError('unhashable type')
 
+    _index = None
     def _get_index(self):
         return self._index
 
@@ -162,7 +156,6 @@ class Series(np.ndarray, Picklable, Groupable):
 
         self._index = index
 
-    _index = None
     index = property(fget=_get_index, fset=_set_index)
 
     def __array_finalize__(self, obj):
@@ -256,16 +249,16 @@ class Series(np.ndarray, Picklable, Groupable):
         indices = Index(self.index.view(ndarray)[key])
         return self.__class__(dataSlice, index=indices)
 
-    def get(self, key, missingVal=None):
+    def get(self, key, default=None):
         """
-        Returns value occupying requested index, default to missingVal
-        if not present
+        Returns value occupying requested index, default to specified
+        missing value if not present
 
         Parameters
         ----------
         key : object
             Index value looking for
-        missingVal : object, optional
+        default : object, optional
             Value to return if key not in index
 
         Returns
@@ -275,7 +268,7 @@ class Series(np.ndarray, Picklable, Groupable):
         if key in self.index:
             return ndarray.__getitem__(self, self.index.indexMap[key])
         else:
-            return missingVal
+            return default
 
     def __getslice__(self, i, j):
         """
@@ -352,7 +345,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        int (# obs)
+        nobs : int
         """
         return notnull(self.values()).sum()
 
@@ -414,7 +407,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
         Returns
         -------
-        float
+        skew : float
         """
         y = np.array(self.values())
         mask = notnull(y)
@@ -430,12 +423,20 @@ class Series(np.ndarray, Picklable, Groupable):
     def keys(self):
         """
         Return Series index
+
+        Returns
+        -------
+        index : Index
         """
         return self.index
 
     def values(self):
         """
         Return Series as ndarray
+
+        Returns
+        -------
+        arr : numpy.ndarray
         """
         return self.view(ndarray)
 
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 61621f622..2887664fa 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1,6 +1,6 @@
 # pylint: disable-msg=W0612
 from copy import deepcopy
-from datetime import timedelta
+from datetime import datetime, timedelta
 from cStringIO import StringIO
 import os
 import unittest
@@ -47,6 +47,19 @@ class TestDataFrame(unittest.TestCase):
         }
         self.empty = self.klass({})
 
+        self.unsortable = self.klass(
+            {'foo' : [1] * 1000,
+             datetime.today() : [1] * 1000,
+             'bar' : ['bar'] * 1000,
+             datetime.today() + timedelta(1) : ['bar'] * 1000},
+            index=np.arange(1000))
+
+    def test_set_index(self):
+        idx = Index(np.arange(len(self.mixed_frame)))
+        self.mixed_frame.index = idx
+
+        self.assert_(self.mixed_frame['foo'].index  is idx)
+
     def test_constructor(self):
         df = self.klass()
         self.assert_(len(df.index) == 0)
@@ -242,6 +255,19 @@ class TestDataFrame(unittest.TestCase):
 
         foo = repr(biggie)
 
+        # exhausting cases in DataMatrix.info
+
+        # columns but no index
+        no_index = self.klass(columns=[0, 1, 3])
+        foo = repr(no_index)
+
+        # no columns or index
+        buf = StringIO()
+        self.empty.info(buffer=buf)
+
+        # columns are not sortable
+        foo = repr(self.unsortable)
+
     def test_toString(self):
         # big mixed
         biggie = self.klass({'A' : randn(1000),
@@ -461,7 +487,13 @@ class TestDataFrame(unittest.TestCase):
         self.assertEqual(len(result), 0)
 
     def test_combineFunc(self):
-        pass
+        result = self.frame * 2
+        self.assert_(np.array_equal(result.values, self.frame.values * 2))
+
+        result = self.empty * 2
+        self.assert_(result.index is self.empty.index)
+        self.assertEqual(len(result.columns), 0)
+
 
     def test_toCSV(self):
         path = '__tmp__'
@@ -1030,6 +1062,9 @@ class TestDataFrame(unittest.TestCase):
 
         # Test when some are missing
 
+        # merge column not p resent
+        self.assertRaises(Exception, target.merge, source, on='E')
+
         # corner cases
 
         # nothing to merge
@@ -1144,6 +1179,11 @@ class TestDataFrame(unittest.TestCase):
 
         assert_series_equal(cumsum['A'], np.cumsum(self.tsframe['A'].fill(0)))
 
+        df = DataFrame({'A' : np.arange(20)}, index=np.arange(20))
+
+        # works
+        result = df.cumsum()
+
     def test_cumprod(self):
         cumprod = self.tsframe.cumprod()
 
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 0ea205429..ff9491588 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -1,3 +1,5 @@
+# pylint: disable-msg=W0612
+
 from datetime import datetime
 import unittest
 
@@ -38,6 +40,11 @@ class TestDataMatrix(test_frame.TestDataFrame):
         # corner, silly
         self.assertRaises(Exception, self.klass, (1, 2, 3))
 
+        # can't cast
+        mat = np.array(['foo', 'bar'], dtype=object).reshape(2, 1)
+        df = DataMatrix(mat, index=[0, 1], columns=[0], dtype=float)
+        self.assert_(df.values.dtype == np.object_)
+
     def test_constructor_with_objects(self):
         index = self.mixed_frame.index[:5]
 
@@ -143,6 +150,21 @@ class TestDataMatrix(test_frame.TestDataFrame):
         dm['A'] = 'bar'
         self.assertEqual('bar', dm['A'][0])
 
+        dm = DataMatrix(index=np.arange(3))
+        dm['A'] = 1
+        dm['foo'] = 'bar'
+        del dm['foo']
+        dm['foo'] = 'bar'
+        self.assertEqual(len(dm.objects.columns), 1)
+
+    def test_delitem_corner(self):
+        f = self.frame.copy()
+        del f['D']
+        self.assertEqual(len(f.columns), 3)
+        self.assertRaises(KeyError, f.__delitem__, 'D')
+        del f['B']
+        self.assertEqual(len(f.columns), 2)
+
     def test_shift_objects(self):
         tsf = self.tsframe.copy()
         tsf['foo'] = 'bar'
@@ -173,6 +195,9 @@ class TestDataMatrix(test_frame.TestDataFrame):
         # XXX
         obj_result = self.mixed_frame.objects.fill(value=0)
 
+	empty_float = self.frame.reindex(columns=[])
+        result = empty_float.fill(value=0)
+
     def test_count_objects(self):
         dm = DataMatrix(self.mixed_frame._series)
         df = DataFrame(self.mixed_frame._series)
@@ -180,5 +205,10 @@ class TestDataMatrix(test_frame.TestDataFrame):
         common.assert_series_equal(dm.count(), df.count())
         common.assert_series_equal(dm.count(1), df.count(1))
 
+    def test_cumsum_corner(self):
+        dm = DataMatrix(np.arange(20).reshape(4, 5),
+                        index=range(4), columns=range(5))
+        result = dm.cumsum()
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 7ce1e803a..d21496522 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -1,9 +1,6 @@
 # pylint: disable-msg=E1101,W0612
 
-from copy import deepcopy
-from cStringIO import StringIO
 from datetime import datetime, timedelta
-import cPickle as pickle
 import os
 import operator
 import unittest
@@ -52,6 +49,9 @@ class TestSeries(unittest.TestCase):
         self.assert_(not isinstance(self.empty, TimeSeries))
         self.assert_(not isinstance(Series({}), TimeSeries))
 
+        self.assertRaises(Exception, Series, np.random.randn(3, 3),
+                          index=np.arange(3))
+
     def test_fromDict(self):
         data = {'a' : 0, 'b' : 1, 'c' : 2, 'd' : 3}
 
@@ -102,31 +102,15 @@ class TestSeries(unittest.TestCase):
     def test_contains(self):
         common.assert_contains_all(self.ts.index, self.ts)
 
-    def test_pickle(self):
-        f = open('tmp1', 'wb')
-        h = open('tmp3', 'wb')
-        pickle.dump(self.series, f)
-        pickle.dump(self.ts, h)
-        f.close()
-        h.close()
-        f = open('tmp1', 'rb')
-        h = open('tmp3', 'rb')
-        unPickledf = pickle.load(f)
-        unPickledh = pickle.load(h)
-        f.close()
-        h.close()
+    def test_save_load(self):
+        self.series.save('tmp1')
+        self.ts.save('tmp3')
+        unp_series = Series.load('tmp1')
+        unp_ts = Series.load('tmp3')
         os.remove('tmp1')
         os.remove('tmp3')
-        self.assert_(isinstance(unPickledf, Series))
-        self.assert_(isinstance(unPickledh, Series))
-        self.assert_(common.equalContents(unPickledf, self.series))
-        self.assert_(common.equalContents(unPickledh, self.ts))
-        for idx in self.series.index:
-            self.assert_(idx in unPickledf.index)
-            self.assertEqual(unPickledf[idx], self.series[idx])
-        for idx in self.ts.index:
-            self.assert_(idx in unPickledh.index)
-            self.assertEqual(unPickledh[idx], self.ts[idx])
+        assert_series_equal(unp_series, self.series)
+        assert_series_equal(unp_ts, self.ts)
 
     def test_getitem_get(self):
         idx1 = self.series.index[5]

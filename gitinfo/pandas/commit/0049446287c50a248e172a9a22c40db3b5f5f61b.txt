commit 0049446287c50a248e172a9a22c40db3b5f5f61b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 21 05:09:08 2010 +0000

    committing tests and changes in broken state, to be fixed ASAP
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@196 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/doc/source/series.rst b/doc/source/series.rst
index 0aff4ab8f..5afb88ce7 100644
--- a/doc/source/series.rst
+++ b/doc/source/series.rst
@@ -553,16 +553,10 @@ Method summary
    Series.median
    Series.cumsum
    Series.cumprod
-
-Additionally, some other useful methods not present in ndarray are
-implemented:
-
-.. autosummary::
-   :toctree: generated/
-
+   Series.clip
+   Series.clip_upper
+   Series.clip_lower
    Series.corr
-   Series.cap
-   Series.floor
 
 Merging Series based on key
 ---------------------------
diff --git a/pandas/core/common.py b/pandas/core/common.py
index d62acdbb4..efa8891f8 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -3,7 +3,7 @@ from cStringIO import StringIO
 from numpy.lib.format import read_array, write_array
 import numpy as np
 
-from pandas.lib.tseries import isnullobj, checknull
+import pandas.lib.tseries as tseries
 
 def isnull(input):
     '''
@@ -21,11 +21,11 @@ def isnull(input):
     if isinstance(input, np.ndarray):
         if input.dtype.kind in ('O', 'S'):
             result = input.astype(bool)
-            result[:] = isnullobj(input)
+            result[:] = tseries.isnullobj(input)
         else:
             result = -np.isfinite(input)
     else:
-        result = checknull(input)
+        result = tseries.checknull(input)
 
     return result
 
@@ -45,7 +45,7 @@ def notnull(input):
     if isinstance(input, np.ndarray):
         return -isnull(input)
     else:
-        return not checknull(input)
+        return not tseries.checknull(input)
 
 def _pickle_array(arr):
     arr = arr.view(np.ndarray)
@@ -73,5 +73,22 @@ def _pfixed(s, space, nanRep=None, float_format=None):
     else:
         return str(s)[:space-4].ljust(space)
 
-#-------------------------------------------------------------------------------
-# Functions needed from scipy
+
+
+def get_indexer(source, target, fill_method):
+    if fill_method:
+        fill_method = fill_method.upper()
+
+    indexer, mask = tseries.getFillVec(source, target, source.indexMap,
+                                       target.indexMap, fill_method)
+
+    return indexer, mask
+
+def null_out_axis(arr, mask, axis):
+    if axis == 0:
+        arr[mask] = np.NaN
+    else:
+        indexer = [slice(None)] * arr.ndim
+        indexer[axis] = mask
+
+        arr[tuple(indexer)] = np.NaN
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 14b454cd1..20035ff44 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -14,6 +14,7 @@ from pandas.core.daterange import DateRange
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.mixins import Picklable, Groupable
 from pandas.core.series import Series
+import pandas.core.common as common
 import pandas.core.datetools as datetools
 import pandas.lib.tseries as tseries
 
@@ -247,13 +248,16 @@ class DataFrame(Picklable, Groupable):
         data = np.genfromtxt(path, delimiter=delimiter, dtype=None,
                              skip_header=header, names=True)
 
-        field = data.dtype.names[index_col]
-        df = cls.fromRecords(data, indexField=field)
+        if index_col is not None:
+            field = data.dtype.names[index_col]
+            df = cls.fromRecords(data, indexField=field)
 
-        # have dates?
-        test_val = datetools.to_datetime(df.index[0])
-        if isinstance(test_val, datetime):
-            df = df.rename(index=datetools.to_datetime)
+            # have dates?
+            test_val = datetools.to_datetime(df.index[0])
+            if isinstance(test_val, datetime):
+                df = df.rename(index=datetools.to_datetime)
+        else:
+            df = cls.fromRecords(data, indexField=None)
 
         return df
 
@@ -921,9 +925,6 @@ class DataFrame(Picklable, Groupable):
         -------
         y : same type as calling instance
         """
-        if fillMethod:
-            fillMethod = fillMethod.upper()
-
         frame = self
 
         if index is not None:
@@ -944,9 +945,7 @@ class DataFrame(Picklable, Groupable):
         if len(self.index) == 0:
             return DataFrame(index=index)
 
-        fillVec, mask = tseries.getFillVec(self.index, index,
-                                           self.index.indexMap,
-                                           index.indexMap, method)
+        indexer, mask = common.get_indexer(self.index, index, method)
 
         # Maybe this is a bit much? Wish I had unit tests...
         typeHierarchy = [
@@ -972,7 +971,7 @@ class DataFrame(Picklable, Groupable):
             series = series.view(np.ndarray)
             for klass, dest in typeHierarchy:
                 if issubclass(series.dtype.type, klass):
-                    new = series.take(fillVec)
+                    new = series.take(indexer)
 
                     if need_cast:
                         new = new.astype(dest)
@@ -1427,12 +1426,12 @@ class DataFrame(Picklable, Groupable):
 
             return result
 
-        fillVec, mask = tseries.getMergeVec(self[on], other.index.indexMap)
+        indexer, mask = tseries.getMergeVec(self[on], other.index.indexMap)
 
         newSeries = {}
 
         for col, series in other.iteritems():
-            arr = series.view(np.ndarray).take(fillVec)
+            arr = series.view(np.ndarray).take(indexer)
             arr[-mask] = NaN
 
             newSeries[col] = arr
@@ -1903,4 +1902,3 @@ def _extract_index(data, index):
         index = Index(index)
 
     return index
-
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 17948b615..6eeb287c6 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -7,11 +7,11 @@ import sys
 from numpy import NaN
 import numpy as np
 
-from pandas.core.common import (_pfixed, _pickle_array, _unpickle_array,
-                                isnull)
+from pandas.core.common import (_pickle_array, _unpickle_array)
 from pandas.core.frame import DataFrame, _try_sort, _extract_index
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series
+import pandas.core.common as common
 import pandas.core.datetools as datetools
 import pandas.lib.tseries as tseries
 
@@ -273,11 +273,8 @@ class DataMatrix(DataFrame):
         if len(self.index) == 0:
             return DataMatrix(index=index, columns=self.columns)
 
-        fillVec, mask = tseries.getFillVec(self.index, index,
-                                           self.index.indexMap,
-                                           index.indexMap, method)
-
-        mat = self.values.take(fillVec, axis=0)
+        indexer, mask = common.get_indexer(self.index, index, method)
+        mat = self.values.take(indexer, axis=0)
 
         notmask = -mask
         if len(index) > 0:
@@ -287,7 +284,7 @@ class DataMatrix(DataFrame):
                 elif issubclass(mat.dtype.type, np.bool_):
                     mat = mat.astype(object)
 
-                mat[-mask] = NaN
+                common.null_out_axis(mat, notmask, 0)
 
         if self.objects is not None and len(self.objects.columns) > 0:
             newObjects = self.objects.reindex(index)
@@ -316,10 +313,7 @@ class DataMatrix(DataFrame):
             return DataMatrix(index=self.index, columns=columns,
                               objects=objects)
 
-        indexer, mask = tseries.getFillVec(self.columns, columns,
-                                           self.columns.indexMap,
-                                           columns.indexMap, None)
-
+        indexer, mask = common.get_indexer(self.columns, columns, None)
         mat = self.values.take(indexer, axis=1)
 
         notmask = -mask
@@ -330,7 +324,7 @@ class DataMatrix(DataFrame):
                 elif issubclass(mat.dtype.type, np.bool_):
                     mat = mat.astype(object)
 
-                mat[:, -mask] = NaN
+                common.null_out_axis(mat, notmask, 1)
 
         return DataMatrix(mat, index=self.index, columns=columns,
                           objects=objects)
@@ -777,6 +771,7 @@ class DataMatrix(DataFrame):
         """
         Output a string version of this DataMatrix
         """
+        _pf = common._pfixed
         formatters = formatters or {}
 
         if columns is None:
@@ -798,16 +793,16 @@ class DataMatrix(DataFrame):
             buffer.write('DataMatrix is empty!\n')
             buffer.write(repr(self.index))
         else:
-            buffer.write(_pfixed('', idxSpace))
+            buffer.write(_pf('', idxSpace))
             for h in columns:
-                buffer.write(_pfixed(h, colSpace))
+                buffer.write(_pf(h, colSpace))
             buffer.write('\n')
 
             for i, idx in enumerate(self.index):
-                buffer.write(_pfixed(idx, idxSpace))
+                buffer.write(_pf(idx, idxSpace))
                 for j, col in enumerate(columns):
                     formatter = formatters.get(col, ident)
-                    buffer.write(_pfixed(formatter(values[i, j]), colSpace,
+                    buffer.write(_pf(formatter(values[i, j]), colSpace,
                                          float_format=float_format,
                                          nanRep=nanRep))
                 buffer.write('\n')
@@ -838,7 +833,7 @@ class DataMatrix(DataFrame):
         columns = []
         for col, count in counts.iteritems():
             columns.append('%s%d  non-null values' %
-                           (_pfixed(col, space), count))
+                           (common._pfixed(col, space), count))
 
         dtypeLine = ''
 
@@ -1070,7 +1065,7 @@ class DataMatrix(DataFrame):
                 return self
 
             vals = self.values.copy()
-            vals.flat[isnull(vals.ravel())] = value
+            vals.flat[common.isnull(vals.ravel())] = value
 
             objects = None
 
@@ -1236,9 +1231,5 @@ class DataMatrix(DataFrame):
         return Series(values.max(axis), index=self._get_agg_axis(axis))
 
 def _reorder_columns(mat, current, desired):
-    fillVec, mask = tseries.getFillVec(current, desired, current.indexMap,
-                                       desired.indexMap, None)
-
-    fillVec = fillVec[mask]
-
-    return mat.take(fillVec, axis=1)
+    indexer, mask = common.get_indexer(current, desired, None)
+    return mat.take(indexer[mask], axis=1)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 01398b6a5..e71bf845f 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -11,13 +11,12 @@ import sys
 
 import numpy as np
 
-from pandas.core.common import (_pickle_array, _unpickle_array,
-                                _pfixed, notnull, isnull)
 from pandas.core.groupby import GroupBy
 from pandas.core.index import Index
 from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
 from pandas.core.mixins import Picklable
+import pandas.core.common as common
 import pandas.lib.tseries as tseries
 
 class PanelError(Exception):
@@ -35,6 +34,48 @@ def _arith_method(func, name):
 
     return f
 
+def _long_arith_method(op, name):
+    def f(self, other, axis='items'):
+        """
+        Wrapper method for %s
+
+        Parameters
+        ----------
+        other : DataFrame or Panel class
+        axis : {'items', 'major', 'minor'}
+
+        Returns
+        -------
+        LongPanel
+        """
+        return self._combine(other, op, axis=axis)
+
+    f.__name__ = name
+    f.__doc__ = f.__doc__ % str(op)
+
+    return f
+
+def _wide_arith_method(op, name):
+    def f(self, other, axis='items'):
+        """
+        Wrapper method for %s
+
+        Parameters
+        ----------
+        other : DataFrame or Panel class
+        axis : {'items', 'major', 'minor'}
+
+        Returns
+        -------
+        WidePanel
+        """
+        return self._combine(other, op, axis=axis)
+
+    f.__name__ = name
+    f.__doc__ = f.__doc__ % str(op)
+
+    return f
+
 class Panel(Picklable):
     """
     Abstract superclass for LongPanel and WidePanel data structures
@@ -70,7 +111,10 @@ class Panel(Picklable):
         minor = 'Minor axis: %s to %s' % (self.minor_axis[0],
                                           self.minor_axis[-1])
 
-        items = 'Items: %s to %s' % (self.items[0], self.items[-1])
+        if len(self.items) > 0:
+            items = 'Items: %s to %s' % (self.items[0], self.items[-1])
+        else:
+            items = 'Items: None'
 
         output = '%s\n%s\n%s\n%s\n%s' % (class_name, dims, items, major, minor)
 
@@ -311,20 +355,20 @@ class WidePanel(Panel):
 
     def __getstate__(self):
         "Returned pickled representation of the panel"
+        _pickle = common._pickle_array
 
-        return (_pickle_array(self.values),
-                _pickle_array(self.items),
-                _pickle_array(self.major_axis),
-                _pickle_array(self.minor_axis))
+        return (_pickle(self.values), _pickle(self.items),
+                _pickle(self.major_axis), _pickle(self.minor_axis))
 
     def __setstate__(self, state):
         "Unpickle the panel"
+        _unpickle = common._unpickle_array
         vals, items, major, minor = state
 
-        self.items = _unpickle_array(items)
-        self.major_axis = _unpickle_array(major)
-        self.minor_axis = _unpickle_array(minor)
-        self.values = _unpickle_array(vals)
+        self.items = _unpickle(items)
+        self.major_axis = _unpickle(major)
+        self.minor_axis = _unpickle(minor)
+        self.values = _unpickle(vals)
 
     def conform(self, frame, axis='items'):
         """
@@ -365,61 +409,37 @@ class WidePanel(Panel):
         result = self
 
         if major is not None:
-            result = result._reindex_major(major, fill_method)
+            result = result._reindex_axis(major, fill_method, 1)
 
         if minor is not None:
-            result = result._reindex_minor(minor, fill_method)
+            result = result._reindex_axis(minor, fill_method, 2)
 
         if items is not None:
-            result = result._reindex_items(items, fill_method)
+            result = result._reindex_axis(items, fill_method, 0)
 
         if result is self:
             raise Exception('Must specify at least one axis')
 
         return result
 
-    def _reindex_items(self, new_index, fill_method):
-        if self.items.equals(new_index):
-            return self.copy()
-
-        if not isinstance(new_index, Index):
-            new_index = Index(new_index)
-
-        indexer, mask = _get_indexer(self.items, new_index, fill_method)
-
-        new_values = self.values.take(indexer, axis=0)
-        new_values[-mask] = np.NaN
-
-        return WidePanel(new_values, new_index, self.major_axis,
-                         self.minor_axis)
+    def _reindex_axis(self, new_index, fill_method, axis):
+        old_index = self._get_axis(axis)
 
-    def _reindex_major(self, new_index, fill_method):
-        if self.major_axis.equals(new_index):
+        if old_index.equals(new_index):
             return self.copy()
 
         if not isinstance(new_index, Index):
             new_index = Index(new_index)
 
-        indexer, mask = _get_indexer(self.major_axis, new_index, fill_method)
+        indexer, mask = common.get_indexer(old_index, new_index, fill_method)
 
-        new_values = self.values.take(indexer, axis=1)
-        new_values[:, -mask, :] = np.NaN
-
-        return WidePanel(new_values, self.items, new_index, self.minor_axis)
-
-    def _reindex_minor(self, new_index, fill_method):
-        if self.minor_axis.equals(new_index):
-            return self.copy()
-
-        if not isinstance(new_index, Index):
-            new_index = Index(new_index)
-
-        indexer, mask = _get_indexer(self.minor_axis, new_index, fill_method)
+        new_values = self.values.take(indexer, axis=axis)
+        common.null_out_axis(new_values, -mask, axis)
 
-        new_values = self.values.take(indexer, axis=2)
-        new_values[:, :, -mask] = np.NaN
+        new_axes = [self._get_axis(i) for i in range(3)]
+        new_axes[axis] = new_index
 
-        return WidePanel(new_values, self.items, self.major_axis, new_index)
+        return WidePanel(new_values, *new_axes)
 
     def _combine(self, other, func, axis=0):
         if isinstance(other, DataFrame):
@@ -484,10 +504,8 @@ class WidePanel(Panel):
             return WidePanel.fromDict(result)
         else:
             # Float type values
-            if len(self.items) == 0:
-                return self
             vals = self.values.copy()
-            vals.flat[isnull(vals.ravel())] = value
+            vals.flat[common.isnull(vals.ravel())] = value
 
             return WidePanel(vals, self.items, self.major_axis,
                              self.minor_axis)
@@ -509,29 +527,10 @@ class WidePanel(Panel):
 
         return WidePanel(result_values, items, major, minor)
 
-    def add(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.add, axis=axis)
-
-    def subtract(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.sub, axis=axis)
-
-    def multiply(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.mul, axis=axis)
-
-    def divide(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.div, axis=axis)
+    add = _wide_arith_method(operator.add, 'add')
+    subtract = _wide_arith_method(operator.sub, 'subtract')
+    divide = _wide_arith_method(operator.div, 'divide')
+    multiply = _wide_arith_method(operator.mul, 'multiply')
 
     def getMajorXS(self, key):
         """
@@ -866,7 +865,7 @@ class WidePanel(Panel):
         y : DataMatrix
         """
         def f(arr):
-            return tseries.median(arr[notnull(arr)])
+            return tseries.median(arr[common.notnull(arr)])
 
         return self.apply(f, axis=axis)
 
@@ -979,28 +978,6 @@ class WidePanel(Panel):
 # LongPanel and friends
 
 
-def _long_arith_method(op, name):
-    def f(self, other, axis='items'):
-        """
-        Wrapper method for %s
-
-        Parameters
-        ----------
-        other : DataFrame or Panel class
-        axis : {'items', 'major', 'minor'}
-
-        Returns
-        -------
-        LongPanel
-        """
-        return self._combine(other, op, axis=axis)
-
-    f.__name__ = name
-    f.__doc__ = f.__doc__ % str(op)
-
-    return f
-
-
 class LongPanel(Panel):
     """
     Represents long or "stacked" format panel data
@@ -1166,6 +1143,10 @@ class LongPanel(Panel):
         if np.isscalar(value):
             mat = np.empty((len(self.values), 1), dtype=float)
             mat.fill(value)
+        elif isinstance(value, np.ndarray):
+            mat = value
+#             if value.ndim == 1:
+#                 value = value.reshape((len(value), 1))
         elif isinstance(value, LongPanel):
             if len(value.items) > 1:
                 raise Exception('input LongPanel must only have one column')
@@ -1183,17 +1164,17 @@ class LongPanel(Panel):
     def __getstate__(self):
         "Returned pickled representation of the panel"
 
-        return (_pickle_array(self.values),
-                _pickle_array(self.items),
+        return (common._pickle_array(self.values),
+                common._pickle_array(self.items),
                 self.index)
 
     def __setstate__(self, state):
         "Unpickle the panel"
         (vals, items, index) = state
 
-        self.items = _unpickle_array(items)
+        self.items = common._unpickle_array(items)
         self.index = index
-        self.values = _unpickle_array(vals)
+        self.values = common._unpickle_array(vals)
 
     def _combine(self, other, func, axis='items'):
         if isinstance(other, DataFrame):
@@ -1287,7 +1268,7 @@ class LongPanel(Panel):
         -------
         WidePanel
         """
-        if not self.index.isConsistent():
+        if not self.index.consistent:
             raise PanelError('Panel has duplicate (major, minor) pairs, '
                              'cannot be reliably converted to wide format.')
 
@@ -1321,20 +1302,21 @@ class LongPanel(Panel):
         """
         Output a screen-friendly version of this Panel
         """
+        _pf = common._pfixed
         major_space = max(max([len(str(idx))
                                for idx in self.major_axis]) + 4, 9)
         minor_space = max(max([len(str(idx))
                                for idx in self.minor_axis]) + 4, 9)
 
         def format_cols(items):
-            return '%s%s%s' % (_pfixed('Major', major_space),
-                               _pfixed('Minor', minor_space),
-                               ''.join(_pfixed(h, col_space) for h in items))
+            return '%s%s%s' % (_pf('Major', major_space),
+                               _pf('Minor', minor_space),
+                               ''.join(_pf(h, col_space) for h in items))
 
         def format_row(major, minor, values):
-            return '%s%s%s' % (_pfixed(major, major_space),
-                               _pfixed(minor, minor_space),
-                               ''.join(_pfixed(v, col_space) for v in values))
+            return '%s%s%s' % (_pf(major, major_space),
+                               _pf(minor, minor_space),
+                               ''.join(_pf(v, col_space) for v in values))
 
         self._textConvert(buffer, format_cols, format_row)
 
@@ -1394,7 +1376,7 @@ class LongPanel(Panel):
         -------
         LongPanel
         """
-        left, right = self.index.getMajorBounds(before, after)
+        left, right = self.index.get_major_bounds(before, after)
         new_index = self.index.truncate(before, after)
 
         return LongPanel(self.values[left : right],
@@ -1418,8 +1400,8 @@ class LongPanel(Panel):
         new_values = self.values.take(indexer, axis=1)
         return LongPanel(new_values, intersection, self.index)
 
-    def getAxisDummies(self, axis='minor', transform=None,
-                       prefix=None):
+    def get_axis_dummies(self, axis='minor', transform=None,
+                         prefix=None):
         """
         Construct 1-0 dummy variables corresponding to designated axis
         labels
@@ -1433,8 +1415,8 @@ class LongPanel(Panel):
             get "day of week" dummies in a time series regression you might
             call:
 
-                panel.getAxisDummies(axis='major',
-                                     transform=lambda d: d.weekday())
+                panel.get_axis_dummies(axis='major',
+                                       transform=lambda d: d.weekday())
         Returns
         -------
         LongPanel, item names taken from chosen axis
@@ -1454,7 +1436,7 @@ class LongPanel(Panel):
             mapped = np.array([transform(val) for val in items])
 
             items = np.array(sorted(set(mapped)))
-            labels = mapped[labels]
+            labels = items.searchsorted(mapped[labels])
             dim = len(items)
 
         values = np.eye(dim, dtype=float)
@@ -1469,29 +1451,7 @@ class LongPanel(Panel):
 
         return result
 
-    def getFrameDummies(self, dataFrame, axis='minor', prefix=None):
-        """
-
-        Returns
-        -------
-        LongPanel
-        """
-        if axis == 'minor':
-            dataFrame = dataFrame.reindex(self.minor_axis)
-            labels = self.index.minor_labels
-        elif axis == 'major':
-            dataFrame = dataFrame.reindex(self.major_axis)
-            labels = self.index.major_labels
-
-        values = dataFrame.values.take(labels, axis=0)
-        result = LongPanel(values, dataFrame.columns, self.index)
-
-        if prefix is not None:
-            result = result.addPrefix(prefix)
-
-        return result
-
-    def getItemDummies(self, item):
+    def get_dummies(self, item):
         """
         Use unique values in column of panel to construct LongPanel
         containing dummy
@@ -1517,7 +1477,13 @@ class LongPanel(Panel):
 
         return LongPanel(dummy_mat, distinct_values, self.index)
 
-    def applyToAxis(self, f, axis='major', broadcast=False):
+    def mean(self, axis='major', broadcast=False):
+        return self.apply(lambda x: np.mean(x, axis=0), axis, broadcast)
+
+    def sum(self, axis='major', broadcast=False):
+        return self.apply(lambda x: np.sum(x, axis=0), axis, broadcast)
+
+    def apply(self, f, axis='major', broadcast=False):
         """
         Aggregate over a particular axis
 
@@ -1534,9 +1500,17 @@ class LongPanel(Panel):
         broadcast=True  -> LongPanel
         broadcast=False -> DataMatrix
         """
-        if axis == 'minor':
+        try:
+            return self._apply_axis(f, axis=axis, broadcast=broadcast)
+        except Exception:
+            # ufunc
+            new_values = f(self.values)
+            return LongPanel(new_values, self.items, self.index)
+
+    def _apply_axis(self, f, axis='major', broadcast=False):
+        if axis == 'major':
             panel = self.swapaxes()
-            result = panel.applyToAxis(f, axis='major', broadcast=broadcast)
+            result = panel._apply_axis(f, axis='minor', broadcast=broadcast)
             if broadcast:
                 result = result.swapaxes()
 
@@ -1557,17 +1531,6 @@ class LongPanel(Panel):
 
         return panel
 
-    def mean(self, axis='major', broadcast=False):
-        return self.applyToAxis(lambda x: np.mean(x, axis=0),
-                                axis, broadcast)
-
-    def sum(self, axis='major', broadcast=False):
-        return self.applyToAxis(lambda x: np.sum(x, axis=0),
-                                axis, broadcast)
-
-    def apply(self, f):
-        return LongPanel(f(self.values), self.items, self.index)
-
     def count(self, axis=0):
         if axis == 0:
             lp = self
@@ -1609,7 +1572,7 @@ class LongPanel(Panel):
         ----
         does *not* copy values matrix
         """
-        new_items = [_makeItemName(item, prefix) for item in self.items]
+        new_items = [_prefix_item(item, prefix) for item in self.items]
 
         return LongPanel(self.values, new_items, self.index)
 
@@ -1637,21 +1600,25 @@ class LongPanelIndex(object):
         return len(self.major_labels)
 
     def __getstate__(self):
-        return (_pickle_array(self.major_axis),
-                _pickle_array(self.minor_axis),
-                _pickle_array(self.major_labels),
-                _pickle_array(self.minor_labels))
+        _pickle = common._pickle_array
+        return (_pickle(self.major_axis),
+                _pickle(self.minor_axis),
+                _pickle(self.major_labels),
+                _pickle(self.minor_labels))
 
     def __setstate__(self, state):
+        _unpickle = common._unpickle_array
+
         major, minor, major_labels, minor_labels = state
 
-        self.major_axis = _unpickle_array(major)
-        self.minor_axis = _unpickle_array(minor)
+        self.major_axis = _unpickle(major)
+        self.minor_axis = _unpickle(minor)
 
-        self.major_labels = _unpickle_array(major_labels)
-        self.minor_labels = _unpickle_array(minor_labels)
+        self.major_labels = _unpickle(major_labels)
+        self.minor_labels = _unpickle(minor_labels)
 
-    def isConsistent(self):
+    @property
+    def consistent(self):
         offset = max(len(self.major_axis), len(self.minor_axis))
 
         # overflow risk
@@ -1685,15 +1652,15 @@ class LongPanelIndex(object):
         -------
         LongPanelIndex
         """
-        i, j = self._getAxisBounds(before, after)
-        left, right = self._getLabelBounds(i, j)
+        i, j = self._get_axis_bounds(before, after)
+        left, right = self._get_label_bounds(i, j)
 
         return LongPanelIndex(self.major_axis[i : j],
                               self.minor_axis,
                               self.major_labels[left : right] - i,
                               self.minor_labels[left : right])
 
-    def getMajorBounds(self, begin=None, end=None):
+    def get_major_bounds(self, begin=None, end=None):
         """
         Return index bounds for slicing LongPanel labels and / or
         values
@@ -1708,12 +1675,12 @@ class LongPanelIndex(object):
         y : tuple
             (left, right) absolute bounds on LongPanel values
         """
-        i, j = self._getAxisBounds(begin, end)
-        left, right = self._getLabelBounds(i, j)
+        i, j = self._get_axis_bounds(begin, end)
+        left, right = self._get_label_bounds(i, j)
 
         return left, right
 
-    def _getAxisBounds(self, begin, end):
+    def _get_axis_bounds(self, begin, end):
         """
         Return major axis locations corresponding to interval values
         """
@@ -1738,7 +1705,7 @@ class LongPanelIndex(object):
 
         return i, j
 
-    def _getLabelBounds(self, i, j):
+    def _get_label_bounds(self, i, j):
         "Return slice points between two major axis locations"
 
         left = self._bounds[i]
@@ -1862,6 +1829,10 @@ def group_agg(values, bounds, f):
         N, K = values.shape
         result = np.empty((len(bounds), K), dtype=float)
 
+    testagg = f(values[:min(1, len(values))])
+    if isinstance(testagg, np.ndarray) and testagg.ndim == 2:
+        raise Exception('Passed function does not aggregate!')
+
     for i, left_bound in enumerate(bounds):
         if i == len(bounds) - 1:
             right_bound = N
@@ -1872,16 +1843,7 @@ def group_agg(values, bounds, f):
 
     return result
 
-def _get_indexer(source, target, fill_method):
-    if fill_method:
-        fill_method = fill_method.upper()
-
-    indexer, mask = tseries.getFillVec(source, target, source.indexMap,
-                                       target.indexMap, fill_method)
-
-    return indexer, mask
-
-def _makeItemName(item, prefix=None):
+def _prefix_item(item, prefix=None):
     if prefix is None:
         return item
 
@@ -2031,6 +1993,9 @@ def _slow_pivot(index, columns, values):
 def _monotonic(arr):
     return not (arr[1:] < arr[:-1]).any()
 
+#-------------------------------------------------------------------------------
+# GroupBy
+
 class WidePanelGroupBy(GroupBy):
 
     def __init__(self, obj, grouper, axis=0):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a432b6a6f..5627ea23c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -534,9 +534,9 @@ class Series(np.ndarray, Picklable, Groupable):
         """
         result = self
         if lower is not None:
-            result = result.caplower(lower)
+            result = result.clip_lower(lower)
         if upper is not None:
-            result = result.capupper(upper)
+            result = result.clip_upper(upper)
 
         return result
 
@@ -704,59 +704,44 @@ class Series(np.ndarray, Picklable, Groupable):
         idx = np.arange(len(self))
         if missingAtEnd:
             n = sum(good)
-            sortedIdx[:n] = idx[good][arr[good].argsort()]
+            sortedIdx[:n] = idx[good][arr[good].argsort(kind='mergesort')]
             sortedIdx[n:] = idx[bad]
         else:
             n = sum(bad)
-            sortedIdx[n:] = idx[good][arr[good].argsort()]
+            sortedIdx[n:] = idx[good][arr[good].argsort(kind='mergesort')]
             sortedIdx[:n] = idx[bad]
 
         return Series(arr[sortedIdx], index=self.index[sortedIdx])
 
-    def map(self, func):
+    def map(self, arg):
         """
-        Apply input Python function element-wise to each element of
-        Series.
+        Map values of Series using input correspondence (which can be
+        a dict, Series, or function).
 
         Parameters
         ----------
-        func : function
-            Element-wise function to apply
+        arg : function, dict, or Series
 
         Returns
         -------
         y : Series
             same index as caller
         """
-        return Series([func(x) for x in self], index=self.index)
+        if isinstance(arg, (dict, Series)):
+            if isinstance(arg, dict):
+                arg = Series(arg)
 
-    def merge(self, other):
-        """
-        If self is {A}->{B} and other is another mapping of {B}->{C}
-        then returns a new Series that is {A}->{C}
-
-        Parameters
-        ----------
-        other : dict or Series
-
-        Returns
-        -------
-        Series having same index as calling instance, with values from
-        input Series
-        """
-        if isinstance(other, dict):
-            other = Series(other)
+            indexer, mask = tseries.getMergeVec(self, arg.index.indexMap)
 
-        if not isinstance(other, Series): # pragma: no cover
-            raise Exception('Argument must be a Series!')
+            newValues = arg.view(np.ndarray).take(indexer)
+            np.putmask(newValues, -mask, np.nan)
 
-        fillVec, mask = tseries.getMergeVec(self, other.index.indexMap)
-
-        newValues = other.view(np.ndarray).take(fillVec)
-        np.putmask(newValues, -mask, np.nan)
+            newSer = Series(newValues, index=self.index)
+            return newSer
+        else:
+            return Series([arg(x) for x in self], index=self.index)
 
-        newSer = Series(newValues, index=self.index)
-        return newSer
+    merge = map
 
     def reindex(self, newIndex, fillMethod=None):
         """Overloaded version of reindex for TimeSeries. Supports filling
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index d834046da..5c0022e97 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1237,13 +1237,13 @@ class TestDataFrame(unittest.TestCase):
         self.assertRaises(Exception, target.join, source, on='C',
                           how='left')
 
-    def test_cap_floor(self):
+    def test_clip(self):
         median = self.frame.median().median()
 
-        capped = self.frame.cap(median)
+        capped = self.frame.clip_upper(median)
         self.assert_(not (capped.values > median).any())
 
-        floored = self.frame.floor(median)
+        floored = self.frame.clip_lower(median)
         self.assert_(not (floored.values < median).any())
 
     def test_statistics(self):
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index f2aca91d6..10f2a8b5d 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -335,6 +335,14 @@ class TestWidePanel(unittest.TestCase, PanelTests):
         assert_frame_equal(larger.getMajorXS(self.panel.major_axis[1]),
                            smaller.getMajorXS(smaller_major[0]))
 
+    def test_fill(self):
+        filled = self.panel.fill(0)
+        self.assert_(np.isfinite(filled.values).all())
+
+        filled = self.panel.fill(method='backfill')
+        assert_frame_equal(filled['ItemA'],
+                           self.panel['ItemA'].fill(method='backfill'))
+
     def test_combineFrame(self):
         def check_op(op, name):
             # items
@@ -520,9 +528,9 @@ class TestLongPanelIndex(unittest.TestCase):
         self.incon = LongPanelIndex(major_axis, minor_axis,
                                     major_labels, minor_labels)
 
-    def test_isConsistent(self):
-        self.assert_(self.index.isConsistent())
-        self.assert_(not self.incon.isConsistent())
+    def test_consistency(self):
+        self.assert_(self.index.consistent)
+        self.assert_(not self.incon.consistent)
 
         # need to construct an overflow
         major_axis = range(70000)
@@ -534,7 +542,7 @@ class TestLongPanelIndex(unittest.TestCase):
         index = LongPanelIndex(major_axis, minor_axis,
                                major_labels, minor_labels)
 
-        self.assert_(index.isConsistent())
+        self.assert_(index.consistent)
 
     def test_truncate(self):
         result = self.index.truncate(before=1)
@@ -742,26 +750,59 @@ class TestLongPanel(unittest.TestCase):
     def test_filter(self):
         pass
 
-    def test_getAxisDummies(self):
-        pass
+    def test_axis_dummies(self):
+        minor_dummies = self.panel.get_axis_dummies('minor')
+        self.assertEqual(len(minor_dummies.items),
+                         len(self.panel.minor_axis))
 
-    def test_getFrameDummies(self):
-        pass
+        major_dummies = self.panel.get_axis_dummies('major')
+        self.assertEqual(len(major_dummies.items),
+                         len(self.panel.major_axis))
 
-    def test_getItemDummies(self):
-        pass
+        mapping = {'A' : 'one',
+                   'B' : 'one',
+                   'C' : 'two',
+                   'D' : 'two'}
 
-    def test_applyToAxis(self):
-        pass
+        transformed = self.panel.get_axis_dummies('minor',
+                                                  transform=mapping.get)
+        self.assertEqual(len(transformed.items), 2)
+        self.assert_(np.array_equal(transformed.items, ['one', 'two']))
+
+        # TODO: test correctness
+
+    def test_get_dummies(self):
+        self.panel['Label'] = self.panel.index.minor_labels
+
+        minor_dummies = self.panel.get_axis_dummies('minor')
+        dummies = self.panel.get_dummies('Label')
+
+        self.assert_(np.array_equal(dummies.values, minor_dummies.values))
+
+    def test_apply(self):
+        # ufunc
+        applied = self.panel.apply(np.sqrt)
+        self.assert_(assert_almost_equal(
+                applied.values, np.sqrt(self.panel.values)))
 
     def test_mean(self):
-        pass
+        means = self.panel.mean('major')
+
+        # test versus WidePanel version
+        wide_means = self.panel.toWide().mean('major')
+        assert_frame_equal(means, wide_means)
+
+        means_broadcast = self.panel.mean('major', broadcast=True)
+        self.assert_(isinstance(means_broadcast, LongPanel))
+
+        # how to check correctness?
 
     def test_sum(self):
-        pass
+        sums = self.panel.sum('major')
 
-    def test_apply(self):
-        pass
+        # test versus WidePanel version
+        wide_sums = self.panel.toWide().sum('major')
+        assert_frame_equal(sums, wide_sums)
 
     def test_count(self):
         pass
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 3ad25fafe..886a02582 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -455,15 +455,14 @@ class TestSeries(unittest.TestCase):
     def test_toDict(self):
         self.assert_(np.array_equal(Series(self.ts.toDict()), self.ts))
 
-    def test_cap(self):
+    def test_clip(self):
         val = self.ts.median()
 
-        self.assertEqual(self.ts.cap(val).max(), val)
+        self.assertEqual(self.ts.clip_lower(val).min(), val)
+        self.assertEqual(self.ts.clip_upper(val).max(), val)
 
-    def test_floor(self):
-        val = self.ts.median()
-
-        self.assertEqual(self.ts.floor(val).min(), val)
+        self.assertEqual(self.ts.clip(lower=val).min(), val)
+        self.assertEqual(self.ts.clip(upper=val).max(), val)
 
     def test_valid(self):
         ts = self.ts.copy()
diff --git a/pandas/setup.py b/pandas/setup.py
index f8118dcd3..249709b6d 100644
--- a/pandas/setup.py
+++ b/pandas/setup.py
@@ -6,6 +6,7 @@ def configuration(parent_package='',top_path=None):
     config.add_subpackage('core')
     config.add_subpackage('io')
     config.add_subpackage('lib')
+    config.add_subpackage('rpy')
     config.add_subpackage('sandbox')
     config.add_subpackage('stats')
     config.add_subpackage('util')
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 6d5c6b78e..b5a6e5a1a 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -239,7 +239,7 @@ class PanelOLS(OLS):
 
         self.log('-- Adding entity fixed effect dummies')
 
-        dummies = panel.getAxisDummies(axis='minor')
+        dummies = panel.get_axis_dummies(axis='minor')
 
         if not self._use_all_dummies:
             if 'entity' in self._dropped_dummies:
@@ -276,7 +276,7 @@ class PanelOLS(OLS):
         for effect in self._x_effects:
             self.log('-- Adding fixed effect dummies for %s' % effect)
 
-            dummies = panel.getItemDummies(effect)
+            dummies = panel.get_dummies(effect)
 
             val_map = cat_mappings.get(effect)
             if val_map:
diff --git a/pandas/stats/tests/test_ols.py b/pandas/stats/tests/test_ols.py
index 646d345ab..5297354f4 100644
--- a/pandas/stats/tests/test_ols.py
+++ b/pandas/stats/tests/test_ols.py
@@ -462,7 +462,7 @@ def _period_slice(panelModel, i):
     index = panelModel._x_trans.index
     period = index.major_axis[i]
 
-    L, R = index.getMajorBounds(period, period)
+    L, R = index.get_major_bounds(period, period)
 
     return slice(L, R)
 
diff --git a/pandas/version.py b/pandas/version.py
index 2988238b8..f5d9e0611 100644
--- a/pandas/version.py
+++ b/pandas/version.py
@@ -1,17 +1,17 @@
-# THIS FILE IS GENERATED FROM PANDAS setup.py
-short_version='0.2.1'
-version='0.2.1'
-release=False
-
-if not release:
-    version += '.dev'
-    import os
-    svn_version_file = os.path.join(os.path.dirname(__file__),
-                                    '__svn_version__.py')
-    if os.path.isfile(svn_version_file):
-        import imp
-        svn = imp.load_module('pandas.__svn_version__',
-                              open(svn_version_file),
-                              svn_version_file,
-                              ('.py','U',1))
-        version += svn.version
+# THIS FILE IS GENERATED FROM PANDAS setup.py
+short_version='0.2.1'
+version='0.2.1'
+release=False
+
+if not release:
+    version += '.dev'
+    import os
+    svn_version_file = os.path.join(os.path.dirname(__file__),
+                                    '__svn_version__.py')
+    if os.path.isfile(svn_version_file):
+        import imp
+        svn = imp.load_module('pandas.__svn_version__',
+                              open(svn_version_file),
+                              svn_version_file,
+                              ('.py','U',1))
+        version += svn.version

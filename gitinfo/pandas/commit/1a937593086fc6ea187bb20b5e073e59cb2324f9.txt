commit 1a937593086fc6ea187bb20b5e073e59cb2324f9
Author: gfyoung <gfyoung17@gmail.com>
Date:   Wed Apr 26 11:42:18 2017 -0400

    MAINT: Rename assertRaisesRegexp to assert_raises_regex (#16119)

diff --git a/pandas/tests/computation/test_eval.py b/pandas/tests/computation/test_eval.py
index 6ec06f75d..cc1428293 100644
--- a/pandas/tests/computation/test_eval.py
+++ b/pandas/tests/computation/test_eval.py
@@ -29,9 +29,8 @@ from pandas.core.computation.ops import (
 import pandas.core.computation.expr as expr
 import pandas.util.testing as tm
 from pandas.util.testing import (assert_frame_equal, randbool,
-                                 assertRaisesRegexp, assert_numpy_array_equal,
-                                 assert_produces_warning, assert_series_equal,
-                                 slow)
+                                 assert_numpy_array_equal, assert_series_equal,
+                                 assert_produces_warning, slow)
 from pandas.compat import PY3, reduce
 
 _series_frame_incompatible = _bool_ops_syms
@@ -1677,17 +1676,17 @@ class TestMathPythonPython(tm.TestCase):
 
     def test_undefined_func(self):
         df = DataFrame({'a': np.random.randn(10)})
-        with tm.assertRaisesRegexp(ValueError,
-                                   "\"mysin\" is not a supported function"):
+        with tm.assert_raises_regex(
+                ValueError, "\"mysin\" is not a supported function"):
             df.eval("mysin(a)",
                     engine=self.engine,
                     parser=self.parser)
 
     def test_keyword_arg(self):
         df = DataFrame({'a': np.random.randn(10)})
-        with tm.assertRaisesRegexp(TypeError,
-                                   "Function \"sin\" does not support "
-                                   "keyword arguments"):
+        with tm.assert_raises_regex(TypeError,
+                                    "Function \"sin\" does not support "
+                                    "keyword arguments"):
             df.eval("sin(x=a)",
                     engine=self.engine,
                     parser=self.parser)
@@ -1748,16 +1747,16 @@ class TestScope(object):
 
 def test_invalid_engine():
     tm.skip_if_no_ne()
-    assertRaisesRegexp(KeyError, 'Invalid engine \'asdf\' passed',
-                       pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
-                       engine='asdf')
+    tm.assert_raises_regex(KeyError, 'Invalid engine \'asdf\' passed',
+                           pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
+                           engine='asdf')
 
 
 def test_invalid_parser():
     tm.skip_if_no_ne()
-    assertRaisesRegexp(KeyError, 'Invalid parser \'asdf\' passed',
-                       pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
-                       parser='asdf')
+    tm.assert_raises_regex(KeyError, 'Invalid parser \'asdf\' passed',
+                           pd.eval, 'x + y', local_dict={'x': 1, 'y': 2},
+                           parser='asdf')
 
 
 _parsers = {'python': PythonExprVisitor, 'pytables': pytables.ExprVisitor,
@@ -1795,18 +1794,20 @@ def test_invalid_local_variable_reference(engine, parser):
 
     for _expr in exprs:
         if parser != 'pandas':
-            with tm.assertRaisesRegexp(SyntaxError, "The '@' prefix is only"):
+            with tm.assert_raises_regex(SyntaxError,
+                                        "The '@' prefix is only"):
                 pd.eval(_expr, engine=engine, parser=parser)
         else:
-            with tm.assertRaisesRegexp(SyntaxError, "The '@' prefix is not"):
+            with tm.assert_raises_regex(SyntaxError,
+                                        "The '@' prefix is not"):
                 pd.eval(_expr, engine=engine, parser=parser)
 
 
 def test_numexpr_builtin_raises(engine, parser):
     sin, dotted_line = 1, 2
     if engine == 'numexpr':
-        with tm.assertRaisesRegexp(NumExprClobberingError,
-                                   'Variables in expression .+'):
+        with tm.assert_raises_regex(NumExprClobberingError,
+                                    'Variables in expression .+'):
             pd.eval('sin + dotted_line', engine=engine, parser=parser)
     else:
         res = pd.eval('sin + dotted_line', engine=engine, parser=parser)
@@ -1815,20 +1816,21 @@ def test_numexpr_builtin_raises(engine, parser):
 
 def test_bad_resolver_raises(engine, parser):
     cannot_resolve = 42, 3.0
-    with tm.assertRaisesRegexp(TypeError, 'Resolver of type .+'):
+    with tm.assert_raises_regex(TypeError, 'Resolver of type .+'):
         pd.eval('1 + 2', resolvers=cannot_resolve, engine=engine,
                 parser=parser)
 
 
 def test_empty_string_raises(engine, parser):
     # GH 13139
-    with tm.assertRaisesRegexp(ValueError, 'expr cannot be an empty string'):
+    with tm.assert_raises_regex(ValueError,
+                                'expr cannot be an empty string'):
         pd.eval('', engine=engine, parser=parser)
 
 
 def test_more_than_one_expression_raises(engine, parser):
-    with tm.assertRaisesRegexp(SyntaxError,
-                               'only a single expression is allowed'):
+    with tm.assert_raises_regex(SyntaxError,
+                                'only a single expression is allowed'):
         pd.eval('1 + 1; 2 + 2', engine=engine, parser=parser)
 
 
diff --git a/pandas/tests/dtypes/test_inference.py b/pandas/tests/dtypes/test_inference.py
index dd8f65a8e..35720b32d 100644
--- a/pandas/tests/dtypes/test_inference.py
+++ b/pandas/tests/dtypes/test_inference.py
@@ -257,7 +257,7 @@ class TestInference(tm.TestCase):
                 tm.assert_numpy_array_equal(out, pos)
 
                 # too many characters
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     lib.maybe_convert_numeric(
                         np.array(['foo_' + infinity], dtype=object),
                         na_values, maybe_int)
@@ -320,7 +320,7 @@ class TestInference(tm.TestCase):
         for coerce in (True, False):
             for arr, na_values in cases:
                 if coerce:
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         lib.maybe_convert_numeric(arr, na_values,
                                                   coerce_numeric=coerce)
                 else:
@@ -339,7 +339,7 @@ class TestInference(tm.TestCase):
         for coerce in (True, False):
             for case in cases:
                 if coerce:
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         lib.maybe_convert_numeric(case, set(),
                                                   coerce_numeric=coerce)
                 else:
diff --git a/pandas/tests/frame/test_alter_axes.py b/pandas/tests/frame/test_alter_axes.py
index b4b86d8ea..0a00d7e01 100644
--- a/pandas/tests/frame/test_alter_axes.py
+++ b/pandas/tests/frame/test_alter_axes.py
@@ -18,9 +18,7 @@ from pandas.core.dtypes.common import (
     is_interval_dtype)
 import pandas as pd
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 
@@ -36,7 +34,7 @@ class TestDataFrameAlterAxes(tm.TestCase, TestData):
         _ = self.mixed_frame['foo']  # noqa
         self.mixed_frame.index = idx
         assert self.mixed_frame['foo'].index is idx
-        with assertRaisesRegexp(ValueError, 'Length mismatch'):
+        with tm.assert_raises_regex(ValueError, 'Length mismatch'):
             self.mixed_frame.index = idx[::2]
 
     def test_set_index_cast(self):
@@ -111,7 +109,8 @@ class TestDataFrameAlterAxes(tm.TestCase, TestData):
         assert_frame_equal(df3, expected_nodrop)
 
         # corner case
-        with assertRaisesRegexp(ValueError, 'Index has duplicate keys'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Index has duplicate keys'):
             df.set_index('A', verify_integrity=True)
 
         # append
@@ -136,7 +135,8 @@ class TestDataFrameAlterAxes(tm.TestCase, TestData):
                         'C': ['a', 'b', 'c', 'd', 'e'],
                         'D': np.random.randn(5),
                         'E': np.random.randn(5)})
-        with assertRaisesRegexp(ValueError, 'Index has duplicate keys'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Index has duplicate keys'):
             df.set_index('A', verify_integrity=True, inplace=True)
         assert 'A' in df
 
@@ -338,7 +338,7 @@ class TestDataFrameAlterAxes(tm.TestCase, TestData):
     def test_set_columns(self):
         cols = Index(np.arange(len(self.mixed_frame.columns)))
         self.mixed_frame.columns = cols
-        with assertRaisesRegexp(ValueError, 'Length mismatch'):
+        with tm.assert_raises_regex(ValueError, 'Length mismatch'):
             self.mixed_frame.columns = cols[::2]
 
     def test_dti_set_index_reindex(self):
diff --git a/pandas/tests/frame/test_analytics.py b/pandas/tests/frame/test_analytics.py
index 0941f0af6..45d93c187 100644
--- a/pandas/tests/frame/test_analytics.py
+++ b/pandas/tests/frame/test_analytics.py
@@ -779,7 +779,7 @@ class TestDataFrameAnalytics(tm.TestCase, TestData):
         # assert_series_equal(result, comp)
 
         # bad axis
-        tm.assertRaisesRegexp(ValueError, 'No axis named 2', f, axis=2)
+        tm.assert_raises_regex(ValueError, 'No axis named 2', f, axis=2)
         # make sure works on mixed-type frame
         getattr(self.mixed_frame, name)(axis=0)
         getattr(self.mixed_frame, name)(axis=1)
@@ -1749,7 +1749,7 @@ class TestDataFrameAnalytics(tm.TestCase, TestData):
         tm.assert_frame_equal(out, expected)
 
         msg = "the 'out' parameter is not supported"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             np.round(df, decimals=0, out=df)
 
     def test_round_mixed_type(self):
@@ -1897,7 +1897,8 @@ class TestDataFrameAnalytics(tm.TestCase, TestData):
         exp = a.dot(a.iloc[0])
         tm.assert_series_equal(result, exp)
 
-        with tm.assertRaisesRegexp(ValueError, 'Dot product shape mismatch'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Dot product shape mismatch'):
             a.dot(row[:-1])
 
         a = np.random.rand(1, 5)
@@ -1914,7 +1915,7 @@ class TestDataFrameAnalytics(tm.TestCase, TestData):
         df = DataFrame(randn(3, 4), index=[1, 2, 3], columns=lrange(4))
         df2 = DataFrame(randn(5, 3), index=lrange(5), columns=[1, 2, 3])
 
-        with tm.assertRaisesRegexp(ValueError, 'aligned'):
+        with tm.assert_raises_regex(ValueError, 'aligned'):
             df.dot(df2)
 
 
@@ -1986,7 +1987,7 @@ class TestNLargestNSmallest(object):
 
             error_msg = self.dtype_error_msg_template.format(
                 column='b', method=method, dtype='object')
-            with tm.assertRaisesRegexp(TypeError, error_msg):
+            with tm.assert_raises_regex(TypeError, error_msg):
                 getattr(df, method)(n, order)
         else:
             ascending = method == 'nsmallest'
@@ -2003,7 +2004,7 @@ class TestNLargestNSmallest(object):
         df = df_main_dtypes
         error_msg = self.dtype_error_msg_template.format(
             column=columns[1], method=method, dtype=df[columns[1]].dtype)
-        with tm.assertRaisesRegexp(TypeError, error_msg):
+        with tm.assert_raises_regex(TypeError, error_msg):
             getattr(df, method)(2, columns)
 
     def test_n_all_dtypes(self, df_main_dtypes):
diff --git a/pandas/tests/frame/test_api.py b/pandas/tests/frame/test_api.py
index 9e16698ba..bd4abd6fc 100644
--- a/pandas/tests/frame/test_api.py
+++ b/pandas/tests/frame/test_api.py
@@ -20,8 +20,7 @@ import pandas as pd
 
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+                                 assert_frame_equal)
 
 import pandas.util.testing as tm
 
@@ -91,11 +90,14 @@ class TestDataFrameMisc(tm.TestCase, SharedWithSparse, TestData):
         assert f._get_axis(0) is f.index
         assert f._get_axis(1) is f.columns
 
-        assertRaisesRegexp(ValueError, 'No axis named', f._get_axis_number, 2)
-        assertRaisesRegexp(ValueError, 'No axis.*foo', f._get_axis_name, 'foo')
-        assertRaisesRegexp(ValueError, 'No axis.*None', f._get_axis_name, None)
-        assertRaisesRegexp(ValueError, 'No axis named', f._get_axis_number,
-                           None)
+        tm.assert_raises_regex(
+            ValueError, 'No axis named', f._get_axis_number, 2)
+        tm.assert_raises_regex(
+            ValueError, 'No axis.*foo', f._get_axis_name, 'foo')
+        tm.assert_raises_regex(
+            ValueError, 'No axis.*None', f._get_axis_name, None)
+        tm.assert_raises_regex(ValueError, 'No axis named',
+                               f._get_axis_number, None)
 
     def test_keys(self):
         getkeys = self.frame.keys
diff --git a/pandas/tests/frame/test_axis_select_reindex.py b/pandas/tests/frame/test_axis_select_reindex.py
index e8f34b977..b8be7c192 100644
--- a/pandas/tests/frame/test_axis_select_reindex.py
+++ b/pandas/tests/frame/test_axis_select_reindex.py
@@ -699,23 +699,23 @@ class TestDataFrameSelectReindex(tm.TestCase, TestData):
         tm.assert_frame_equal(filtered, expected)
 
         # pass in None
-        with tm.assertRaisesRegexp(TypeError, 'Must pass'):
+        with tm.assert_raises_regex(TypeError, 'Must pass'):
             self.frame.filter()
-        with tm.assertRaisesRegexp(TypeError, 'Must pass'):
+        with tm.assert_raises_regex(TypeError, 'Must pass'):
             self.frame.filter(items=None)
-        with tm.assertRaisesRegexp(TypeError, 'Must pass'):
+        with tm.assert_raises_regex(TypeError, 'Must pass'):
             self.frame.filter(axis=1)
 
         # test mutually exclusive arguments
-        with tm.assertRaisesRegexp(TypeError, 'mutually exclusive'):
+        with tm.assert_raises_regex(TypeError, 'mutually exclusive'):
             self.frame.filter(items=['one', 'three'], regex='e$', like='bbi')
-        with tm.assertRaisesRegexp(TypeError, 'mutually exclusive'):
+        with tm.assert_raises_regex(TypeError, 'mutually exclusive'):
             self.frame.filter(items=['one', 'three'], regex='e$', axis=1)
-        with tm.assertRaisesRegexp(TypeError, 'mutually exclusive'):
+        with tm.assert_raises_regex(TypeError, 'mutually exclusive'):
             self.frame.filter(items=['one', 'three'], regex='e$')
-        with tm.assertRaisesRegexp(TypeError, 'mutually exclusive'):
+        with tm.assert_raises_regex(TypeError, 'mutually exclusive'):
             self.frame.filter(items=['one', 'three'], like='bbi', axis=0)
-        with tm.assertRaisesRegexp(TypeError, 'mutually exclusive'):
+        with tm.assert_raises_regex(TypeError, 'mutually exclusive'):
             self.frame.filter(items=['one', 'three'], like='bbi')
 
         # objects
diff --git a/pandas/tests/frame/test_block_internals.py b/pandas/tests/frame/test_block_internals.py
index 63c1f0a50..5e85b890b 100644
--- a/pandas/tests/frame/test_block_internals.py
+++ b/pandas/tests/frame/test_block_internals.py
@@ -17,8 +17,7 @@ import pandas as pd
 
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+                                 assert_frame_equal)
 
 import pandas.util.testing as tm
 
@@ -481,7 +480,7 @@ starting,ending,measure
 
         # via astype, but errors
         converted = self.mixed_frame.copy()
-        with assertRaisesRegexp(ValueError, 'invalid literal'):
+        with tm.assert_raises_regex(ValueError, 'invalid literal'):
             converted['H'].astype('int32')
 
         # mixed in a single column
diff --git a/pandas/tests/frame/test_combine_concat.py b/pandas/tests/frame/test_combine_concat.py
index 6f06a55ad..0e4184b07 100644
--- a/pandas/tests/frame/test_combine_concat.py
+++ b/pandas/tests/frame/test_combine_concat.py
@@ -15,9 +15,7 @@ from pandas.compat import lrange
 from pandas.tests.frame.common import TestData
 
 import pandas.util.testing as tm
-from pandas.util.testing import (assertRaisesRegexp,
-                                 assert_frame_equal,
-                                 assert_series_equal)
+from pandas.util.testing import assert_frame_equal, assert_series_equal
 
 
 class TestDataFrameConcatCommon(tm.TestCase, TestData):
@@ -78,11 +76,13 @@ class TestDataFrameConcatCommon(tm.TestCase, TestData):
                        columns=['foo', 'bar', 'baz', 'qux'])
 
         series = df.loc[4]
-        with assertRaisesRegexp(ValueError, 'Indexes have overlapping values'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Indexes have overlapping values'):
             df.append(series, verify_integrity=True)
         series.name = None
-        with assertRaisesRegexp(TypeError, 'Can only append a Series if '
-                                'ignore_index=True'):
+        with tm.assert_raises_regex(TypeError,
+                                    'Can only append a Series if '
+                                    'ignore_index=True'):
             df.append(series, verify_integrity=True)
 
         result = df.append(series[::-1], ignore_index=True)
@@ -270,7 +270,7 @@ class TestDataFrameConcatCommon(tm.TestCase, TestData):
 
         other = DataFrame([[2., nan],
                            [nan, 7]], index=[1, 3], columns=[1, 2])
-        with assertRaisesRegexp(ValueError, "Data overlaps"):
+        with tm.assert_raises_regex(ValueError, "Data overlaps"):
             df.update(other, raise_conflict=True)
 
     def test_update_from_non_df(self):
@@ -419,7 +419,7 @@ class TestDataFrameConcatCommon(tm.TestCase, TestData):
         assert_frame_equal(concatted_1_series, expected_columns_series)
 
         # Testing ValueError
-        with assertRaisesRegexp(ValueError, 'No axis named'):
+        with tm.assert_raises_regex(ValueError, 'No axis named'):
             pd.concat([series1, series2], axis='something')
 
     def test_concat_numerical_names(self):
diff --git a/pandas/tests/frame/test_constructors.py b/pandas/tests/frame/test_constructors.py
index f6cdb37a2..db0293b71 100644
--- a/pandas/tests/frame/test_constructors.py
+++ b/pandas/tests/frame/test_constructors.py
@@ -290,37 +290,40 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
     def test_constructor_error_msgs(self):
         msg = "Empty data passed with indices specified."
         # passing an empty array with columns specified.
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame(np.empty(0), columns=list('abc'))
 
         msg = "Mixing dicts with non-Series may lead to ambiguous ordering."
         # mix dict and array, wrong size
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame({'A': {'a': 'a', 'b': 'b'},
                        'B': ['a', 'b', 'c']})
 
         # wrong size ndarray, GH 3105
         msg = r"Shape of passed values is \(3, 4\), indices imply \(3, 3\)"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame(np.arange(12).reshape((4, 3)),
                       columns=['foo', 'bar', 'baz'],
                       index=pd.date_range('2000-01-01', periods=3))
 
         # higher dim raise exception
-        with tm.assertRaisesRegexp(ValueError, 'Must pass 2-d input'):
+        with tm.assert_raises_regex(ValueError, 'Must pass 2-d input'):
             DataFrame(np.zeros((3, 3, 3)), columns=['A', 'B', 'C'], index=[1])
 
         # wrong size axis labels
-        with tm.assertRaisesRegexp(ValueError, "Shape of passed values is "
-                                   r"\(3, 2\), indices imply \(3, 1\)"):
+        with tm.assert_raises_regex(ValueError, "Shape of passed values "
+                                    "is \(3, 2\), indices "
+                                    "imply \(3, 1\)"):
             DataFrame(np.random.rand(2, 3), columns=['A', 'B', 'C'], index=[1])
 
-        with tm.assertRaisesRegexp(ValueError, "Shape of passed values is "
-                                   r"\(3, 2\), indices imply \(2, 2\)"):
+        with tm.assert_raises_regex(ValueError, "Shape of passed values "
+                                    "is \(3, 2\), indices "
+                                    "imply \(2, 2\)"):
             DataFrame(np.random.rand(2, 3), columns=['A', 'B'], index=[1, 2])
 
-        with tm.assertRaisesRegexp(ValueError, 'If using all scalar values, '
-                                   'you must pass an index'):
+        with tm.assert_raises_regex(ValueError, "If using all scalar "
+                                    "values, you must pass "
+                                    "an index"):
             DataFrame({'a': False, 'b': True})
 
     def test_constructor_with_embedded_frames(self):
@@ -542,14 +545,14 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
 
         # wrong size axis labels
         msg = r'Shape of passed values is \(3, 2\), indices imply \(3, 1\)'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame(mat, columns=['A', 'B', 'C'], index=[1])
         msg = r'Shape of passed values is \(3, 2\), indices imply \(2, 2\)'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame(mat, columns=['A', 'B'], index=[1, 2])
 
         # higher dim raise exception
-        with tm.assertRaisesRegexp(ValueError, 'Must pass 2-d input'):
+        with tm.assert_raises_regex(ValueError, 'Must pass 2-d input'):
             DataFrame(empty((3, 3, 3)), columns=['A', 'B', 'C'],
                       index=[1])
 
@@ -739,7 +742,7 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
         exp = DataFrame({'a': df['a'].values, 'b': [True] * 10})
 
         tm.assert_frame_equal(df, exp)
-        with tm.assertRaisesRegexp(ValueError, 'must pass an index'):
+        with tm.assert_raises_regex(ValueError, 'must pass an index'):
             DataFrame({'a': False, 'b': True})
 
     def test_constructor_DataFrame(self):
@@ -772,13 +775,13 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
 
         # corner, silly
         # TODO: Fix this Exception to be better...
-        with tm.assertRaisesRegexp(ValueError, 'constructor not '
-                                   'properly called'):
+        with tm.assert_raises_regex(ValueError, 'constructor not '
+                                    'properly called'):
             DataFrame((1, 2, 3))
 
         # can't cast
         mat = np.array(['foo', 'bar'], dtype=object).reshape(2, 1)
-        with tm.assertRaisesRegexp(ValueError, 'cast'):
+        with tm.assert_raises_regex(ValueError, 'cast'):
             DataFrame(mat, index=[0, 1], columns=[0], dtype=float)
 
         dm = DataFrame(DataFrame(self.frame._series))
@@ -1004,8 +1007,8 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
     def test_constructor_ragged(self):
         data = {'A': randn(10),
                 'B': randn(8)}
-        with tm.assertRaisesRegexp(ValueError,
-                                   'arrays must all be same length'):
+        with tm.assert_raises_regex(ValueError,
+                                    'arrays must all be same length'):
             DataFrame(data)
 
     def test_constructor_scalar(self):
@@ -1027,7 +1030,7 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
         self.assertTrue(result.index.is_monotonic)
 
         # ordering ambiguous, raise exception
-        with tm.assertRaisesRegexp(ValueError, 'ambiguous ordering'):
+        with tm.assert_raises_regex(ValueError, 'ambiguous ordering'):
             DataFrame({'A': ['a', 'b'], 'B': {'a': 'a', 'b': 'b'}})
 
         # this is OK though
@@ -1155,8 +1158,9 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
         tm.assert_frame_equal(recons, self.mixed_frame)
         self.assertEqual(recons['A'].dtype, np.float64)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "Must pass columns with orient='index'"):
+        with tm.assert_raises_regex(TypeError,
+                                    "Must pass columns with "
+                                    "orient='index'"):
             DataFrame.from_items(row_items, orient='index')
 
         # orient='index', but thar be tuples
@@ -1183,7 +1187,8 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
                         'B': list(self.frame['B'])}, columns=['A', 'B'])
         tm.assert_frame_equal(df, self.frame.loc[:, ['A', 'B']])
 
-        with tm.assertRaisesRegexp(ValueError, 'does not match index length'):
+        with tm.assert_raises_regex(ValueError, 'does not match '
+                                    'index length'):
             DataFrame({'A': self.frame['A'], 'B': list(self.frame['B'])[:-2]})
 
     def test_constructor_miscast_na_int_dtype(self):
@@ -1192,8 +1197,8 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
         tm.assert_frame_equal(df, expected)
 
     def test_constructor_iterator_failure(self):
-        with tm.assertRaisesRegexp(TypeError, 'iterator'):
-            df = DataFrame(iter([1, 2, 3]))  # noqa
+        with tm.assert_raises_regex(TypeError, 'iterator'):
+            DataFrame(iter([1, 2, 3]))
 
     def test_constructor_column_duplicates(self):
         # it works! #2079
@@ -1242,7 +1247,8 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
 
         pytest.raises(ValueError, DataFrame, 'a', [1, 2])
         pytest.raises(ValueError, DataFrame, 'a', columns=['a', 'c'])
-        with tm.assertRaisesRegexp(TypeError, 'incompatible data and dtype'):
+        with tm.assert_raises_regex(TypeError, 'incompatible data '
+                                    'and dtype'):
             DataFrame('a', [1, 2], ['a', 'c'], float)
 
     def test_constructor_with_datetimes(self):
@@ -1526,7 +1532,7 @@ class TestDataFrameConstructors(tm.TestCase, TestData):
 
         # wrong length
         msg = r'Shape of passed values is \(3, 2\), indices imply \(3, 1\)'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             DataFrame.from_records(arr, index=index[:-1])
 
         indexed_frame = DataFrame.from_records(arr, index='f1')
diff --git a/pandas/tests/frame/test_dtypes.py b/pandas/tests/frame/test_dtypes.py
index 99141e3a8..ed6d72c08 100644
--- a/pandas/tests/frame/test_dtypes.py
+++ b/pandas/tests/frame/test_dtypes.py
@@ -200,17 +200,21 @@ class TestDataFrameDataTypes(tm.TestCase, TestData):
 
     def test_select_dtypes_empty(self):
         df = DataFrame({'a': list('abc'), 'b': list(range(1, 4))})
-        with tm.assertRaisesRegexp(ValueError, 'at least one of include or '
-                                   'exclude must be nonempty'):
+        with tm.assert_raises_regex(ValueError, 'at least one of '
+                                    'include or exclude '
+                                    'must be nonempty'):
             df.select_dtypes()
 
     def test_select_dtypes_raises_on_string(self):
         df = DataFrame({'a': list('abc'), 'b': list(range(1, 4))})
-        with tm.assertRaisesRegexp(TypeError, 'include and exclude .+ non-'):
+        with tm.assert_raises_regex(TypeError, 'include and exclude '
+                                    '.+ non-'):
             df.select_dtypes(include='object')
-        with tm.assertRaisesRegexp(TypeError, 'include and exclude .+ non-'):
+        with tm.assert_raises_regex(TypeError, 'include and exclude '
+                                    '.+ non-'):
             df.select_dtypes(exclude='object')
-        with tm.assertRaisesRegexp(TypeError, 'include and exclude .+ non-'):
+        with tm.assert_raises_regex(TypeError, 'include and exclude '
+                                    '.+ non-'):
             df.select_dtypes(include=int, exclude='object')
 
     def test_select_dtypes_bad_datetime64(self):
@@ -220,10 +224,10 @@ class TestDataFrameDataTypes(tm.TestCase, TestData):
                         'd': np.arange(4.0, 7.0, dtype='float64'),
                         'e': [True, False, True],
                         'f': pd.date_range('now', periods=3).values})
-        with tm.assertRaisesRegexp(ValueError, '.+ is too specific'):
+        with tm.assert_raises_regex(ValueError, '.+ is too specific'):
             df.select_dtypes(include=['datetime64[D]'])
 
-        with tm.assertRaisesRegexp(ValueError, '.+ is too specific'):
+        with tm.assert_raises_regex(ValueError, '.+ is too specific'):
             df.select_dtypes(exclude=['datetime64[as]'])
 
     def test_select_dtypes_datetime_with_tz(self):
@@ -251,11 +255,11 @@ class TestDataFrameDataTypes(tm.TestCase, TestData):
         except NameError:
             pass
         for dt in string_dtypes:
-            with tm.assertRaisesRegexp(TypeError,
-                                       'string dtypes are not allowed'):
+            with tm.assert_raises_regex(TypeError,
+                                        'string dtypes are not allowed'):
                 df.select_dtypes(include=[dt])
-            with tm.assertRaisesRegexp(TypeError,
-                                       'string dtypes are not allowed'):
+            with tm.assert_raises_regex(TypeError,
+                                        'string dtypes are not allowed'):
                 df.select_dtypes(exclude=[dt])
 
     def test_select_dtypes_bad_arg_raises(self):
@@ -266,7 +270,8 @@ class TestDataFrameDataTypes(tm.TestCase, TestData):
                         'd': np.arange(4.0, 7.0, dtype='float64'),
                         'e': [True, False, True],
                         'f': pd.date_range('now', periods=3).values})
-        with tm.assertRaisesRegexp(TypeError, 'data type.*not understood'):
+        with tm.assert_raises_regex(TypeError, 'data type.'
+                                    '*not understood'):
             df.select_dtypes(['blargy, blarg, blarg'])
 
     def test_select_dtypes_typecodes(self):
@@ -396,7 +401,7 @@ class TestDataFrameDataTypes(tm.TestCase, TestData):
         for this_type in types:
             for this_val in values:
                 df = DataFrame([this_val])
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     df.astype(this_type)
 
     def test_astype_str(self):
diff --git a/pandas/tests/frame/test_indexing.py b/pandas/tests/frame/test_indexing.py
index 5f8d04fdb..be4e69fe9 100644
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -28,8 +28,7 @@ from pandas.core.dtypes.common import (
     is_scalar)
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+                                 assert_frame_equal)
 from pandas.core.indexing import IndexingError
 
 import pandas.util.testing as tm
@@ -53,7 +52,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
             assert self.frame[key] is not None
 
         assert 'random' not in self.frame
-        with assertRaisesRegexp(KeyError, 'random'):
+        with tm.assert_raises_regex(KeyError, 'random'):
             self.frame['random']
 
         df = self.frame.copy()
@@ -116,9 +115,9 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
 
         self.assertEqual(result.columns.name, 'foo')
 
-        with assertRaisesRegexp(KeyError, 'not in index'):
+        with tm.assert_raises_regex(KeyError, 'not in index'):
             self.frame[['B', 'A', 'food']]
-        with assertRaisesRegexp(KeyError, 'not in index'):
+        with tm.assert_raises_regex(KeyError, 'not in index'):
             self.frame[Index(['B', 'A', 'foo'])]
 
         # tuples
@@ -152,12 +151,13 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         assert_series_equal(self.frame['B'], data['A'], check_names=False)
         assert_series_equal(self.frame['A'], data['B'], check_names=False)
 
-        with assertRaisesRegexp(ValueError,
-                                'Columns must be same length as key'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Columns must be same length as key'):
             data[['A']] = self.frame[['A', 'B']]
 
-        with assertRaisesRegexp(ValueError, 'Length of values does not match '
-                                'length of index'):
+        with tm.assert_raises_regex(ValueError, 'Length of values '
+                                    'does not match '
+                                    'length of index'):
             data['A'] = range(len(data.index) - 1)
 
         df = DataFrame(0, lrange(3), ['tt1', 'tt2'], dtype=np.int_)
@@ -239,13 +239,13 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         subframe = self.tsframe[indexer]
 
         tm.assert_index_equal(subindex, subframe.index)
-        with assertRaisesRegexp(ValueError, 'Item wrong length'):
+        with tm.assert_raises_regex(ValueError, 'Item wrong length'):
             self.tsframe[indexer[:-1]]
 
         subframe_obj = self.tsframe[indexer_obj]
         assert_frame_equal(subframe_obj, subframe)
 
-        with tm.assertRaisesRegexp(ValueError, 'boolean values only'):
+        with tm.assert_raises_regex(ValueError, 'boolean values only'):
             self.tsframe[self.tsframe]
 
         # test that Series work
@@ -522,8 +522,9 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         values[values == 2] = 3
         assert_almost_equal(df.values, values)
 
-        with assertRaisesRegexp(TypeError, 'Must pass DataFrame with boolean '
-                                'values only'):
+        with tm.assert_raises_regex(TypeError, 'Must pass '
+                                    'DataFrame with '
+                                    'boolean values only'):
             df[df * 0] = 2
 
         # index with DataFrame
@@ -1350,7 +1351,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
 
     def test_getitem_setitem_fancy_exceptions(self):
         ix = self.frame.iloc
-        with assertRaisesRegexp(IndexingError, 'Too many indexers'):
+        with tm.assert_raises_regex(IndexingError, 'Too many indexers'):
             ix[:, :, :]
 
         with pytest.raises(IndexingError):
@@ -1664,7 +1665,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         with pytest.raises(KeyError):
             self.frame.lookup([self.frame.index[0]], ['xyz'])
 
-        with tm.assertRaisesRegexp(ValueError, 'same size'):
+        with tm.assert_raises_regex(ValueError, 'same size'):
             self.frame.lookup(['a', 'b', 'c'], ['a'])
 
     def test_set_value(self):
@@ -2289,7 +2290,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
 
         df1[df1 > 2.0 * df2] = -1
         assert_frame_equal(df1, expected)
-        with assertRaisesRegexp(ValueError, 'Item wrong length'):
+        with tm.assert_raises_regex(ValueError, 'Item wrong length'):
             df1[df1.index[:-1] > 2] = -1
 
     def test_boolean_indexing_mixed(self):
@@ -2320,7 +2321,8 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         assert_frame_equal(df2, expected)
 
         df['foo'] = 'test'
-        with tm.assertRaisesRegexp(TypeError, 'boolean setting on mixed-type'):
+        with tm.assert_raises_regex(TypeError, 'boolean setting '
+                                    'on mixed-type'):
             df[df > 0.3] = 1
 
     def test_where(self):
@@ -2498,7 +2500,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         ]
 
         for cond in conds:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 df.where(cond)
 
         df['b'] = 2
@@ -2514,7 +2516,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         ]
 
         for cond in conds:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 df.where(cond)
 
     def test_where_dataframe_col_match(self):
@@ -2527,7 +2529,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
 
         cond.columns = ["a", "b", "c"]  # Columns no longer match.
         msg = "Boolean array expected for the condition"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.where(cond)
 
     def test_where_ndframe_align(self):
@@ -2535,7 +2537,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         df = DataFrame([[1, 2, 3], [4, 5, 6]])
 
         cond = [True]
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.where(cond)
 
         expected = DataFrame([[1, 2, 3], [np.nan, np.nan, np.nan]])
@@ -2544,7 +2546,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         tm.assert_frame_equal(out, expected)
 
         cond = np.array([False, True, False, True])
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.where(cond)
 
         expected = DataFrame([[np.nan, np.nan, np.nan], [4, 5, 6]])
@@ -2632,7 +2634,8 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         df = DataFrame([{'A': 1, 'B': np.nan, 'C': 'Test'}, {
                        'A': np.nan, 'B': 'Test', 'C': np.nan}])
         expected = df.where(~isnull(df), None)
-        with tm.assertRaisesRegexp(TypeError, 'boolean setting on mixed-type'):
+        with tm.assert_raises_regex(TypeError, 'boolean setting '
+                                    'on mixed-type'):
             df.where(~isnull(df), None, inplace=True)
 
     def test_where_align(self):
@@ -2890,7 +2893,7 @@ class TestDataFrameIndexing(tm.TestCase, TestData):
         dg = df.pivot_table(index='i', columns='c',
                             values=['x', 'y'])
 
-        with assertRaisesRegexp(TypeError, "is an invalid key"):
+        with tm.assert_raises_regex(TypeError, "is an invalid key"):
             str(dg[:, 0])
 
         index = Index(range(2), name='i')
diff --git a/pandas/tests/frame/test_join.py b/pandas/tests/frame/test_join.py
index f7a510023..21807cb42 100644
--- a/pandas/tests/frame/test_join.py
+++ b/pandas/tests/frame/test_join.py
@@ -86,12 +86,13 @@ def test_join_index(frame):
     tm.assert_index_equal(joined.index, frame.index.sort_values())
     tm.assert_index_equal(joined.columns, expected_columns)
 
-    tm.assertRaisesRegexp(ValueError, 'join method', f.join, f2, how='foo')
+    tm.assert_raises_regex(
+        ValueError, 'join method', f.join, f2, how='foo')
 
     # corner case - overlapping columns
     for how in ('outer', 'left', 'inner'):
-        with tm.assertRaisesRegexp(ValueError, 'columns overlap but '
-                                   'no suffix'):
+        with tm.assert_raises_regex(ValueError, 'columns overlap but '
+                                    'no suffix'):
             frame.join(frame, how=how)
 
 
@@ -122,7 +123,7 @@ def test_join_index_series(frame):
     tm.assert_frame_equal(joined, frame, check_names=False)
 
     s.name = None
-    tm.assertRaisesRegexp(ValueError, 'must have a name', df.join, s)
+    tm.assert_raises_regex(ValueError, 'must have a name', df.join, s)
 
 
 def test_join_overlap(frame):
diff --git a/pandas/tests/frame/test_missing.py b/pandas/tests/frame/test_missing.py
index 74f1d3292..721cee7f3 100644
--- a/pandas/tests/frame/test_missing.py
+++ b/pandas/tests/frame/test_missing.py
@@ -13,9 +13,7 @@ from pandas import (DataFrame, Series, Timestamp,
                     date_range)
 import pandas as pd
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 from pandas.tests.frame.common import TestData, _check_mixed_float
@@ -439,7 +437,8 @@ class TestDataFrameMissingData(tm.TestCase, TestData):
         assert_frame_equal(result, expected)
 
         # disable this for now
-        with assertRaisesRegexp(NotImplementedError, 'column by column'):
+        with tm.assert_raises_regex(NotImplementedError,
+                                    'column by column'):
             df.fillna(df.max(1), axis=1)
 
     def test_fillna_dataframe(self):
@@ -479,7 +478,7 @@ class TestDataFrameMissingData(tm.TestCase, TestData):
         assert_frame_equal(result, expected)
 
     def test_fillna_invalid_method(self):
-        with assertRaisesRegexp(ValueError, 'ffil'):
+        with tm.assert_raises_regex(ValueError, 'ffil'):
             self.frame.fillna(method='ffil')
 
     def test_fillna_invalid_value(self):
diff --git a/pandas/tests/frame/test_mutate_columns.py b/pandas/tests/frame/test_mutate_columns.py
index dfaeaea49..b82a549ba 100644
--- a/pandas/tests/frame/test_mutate_columns.py
+++ b/pandas/tests/frame/test_mutate_columns.py
@@ -7,7 +7,7 @@ import numpy as np
 
 from pandas import DataFrame, Series, Index, MultiIndex
 
-from pandas.util.testing import assert_frame_equal, assertRaisesRegexp
+from pandas.util.testing import assert_frame_equal
 
 import pandas.util.testing as tm
 
@@ -91,7 +91,7 @@ class TestDataFrameMutateColumns(tm.TestCase, TestData):
         s = DataFrame({'foo': ['a', 'b', 'c', 'a'], 'fiz': [
                       'g', 'h', 'i', 'j']}).set_index('foo')
         msg = 'cannot reindex from a duplicate axis'
-        with assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df['newcol'] = s
 
         # GH 4107, more descriptive error message
@@ -99,7 +99,7 @@ class TestDataFrameMutateColumns(tm.TestCase, TestData):
                        columns=['a', 'b', 'c', 'd'])
 
         msg = 'incompatible index of inserted column with frame index'
-        with assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             df['gr'] = df.groupby(['b', 'c']).count()
 
     def test_insert_benchmark(self):
@@ -143,7 +143,7 @@ class TestDataFrameMutateColumns(tm.TestCase, TestData):
         result = Series(dict(float64=4, float32=2, int32=1))
         self.assertTrue((df.get_dtype_counts() == result).all())
 
-        with assertRaisesRegexp(ValueError, 'already exists'):
+        with tm.assert_raises_regex(ValueError, 'already exists'):
             df.insert(1, 'a', df['b'])
         pytest.raises(ValueError, df.insert, 1, 'c', df['b'])
 
diff --git a/pandas/tests/frame/test_nonunique_indexes.py b/pandas/tests/frame/test_nonunique_indexes.py
index 9d5a99eaf..5c141b6a4 100644
--- a/pandas/tests/frame/test_nonunique_indexes.py
+++ b/pandas/tests/frame/test_nonunique_indexes.py
@@ -9,9 +9,7 @@ from pandas.compat import lrange, u
 from pandas import DataFrame, Series, MultiIndex, date_range
 import pandas as pd
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 
@@ -53,7 +51,7 @@ class TestDataFrameNonuniqueIndexes(tm.TestCase, TestData):
                               [2, 1, 3, 5, 'bah']],
                              columns=['foo', 'bar', 'foo', 'hello', 'string'])
         check(df, expected)
-        with assertRaisesRegexp(ValueError, 'Length of value'):
+        with tm.assert_raises_regex(ValueError, 'Length of value'):
             df.insert(0, 'AnotherColumn', range(len(df.index) - 1))
 
         # insert same dtype
@@ -103,8 +101,8 @@ class TestDataFrameNonuniqueIndexes(tm.TestCase, TestData):
         check(df, expected)
 
         # insert a dup
-        assertRaisesRegexp(ValueError, 'cannot insert',
-                           df.insert, 2, 'new_col', 4.)
+        tm.assert_raises_regex(ValueError, 'cannot insert',
+                               df.insert, 2, 'new_col', 4.)
         df.insert(2, 'new_col', 4., allow_duplicates=True)
         expected = DataFrame([[1, 1, 4., 5., 'bah', 3],
                               [1, 2, 4., 5., 'bah', 3],
diff --git a/pandas/tests/frame/test_operators.py b/pandas/tests/frame/test_operators.py
index 3f77bc754..d90e85950 100644
--- a/pandas/tests/frame/test_operators.py
+++ b/pandas/tests/frame/test_operators.py
@@ -20,8 +20,7 @@ import pandas as pd
 
 from pandas.util.testing import (assert_numpy_array_equal,
                                  assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+                                 assert_frame_equal)
 
 import pandas.util.testing as tm
 
@@ -423,10 +422,10 @@ class TestDataFrameOperators(tm.TestCase, TestData):
             # ndim >= 3
             ndim_5 = np.ones(self.frame.shape + (3, 4, 5))
             msg = "Unable to coerce to Series/DataFrame"
-            with assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 f(self.frame, ndim_5)
 
-            with assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 getattr(self.frame, op)(ndim_5)
 
         # res_add = self.frame.add(self.frame)
@@ -448,9 +447,9 @@ class TestDataFrameOperators(tm.TestCase, TestData):
 
         result = self.frame[:0].add(self.frame)
         assert_frame_equal(result, self.frame * np.nan)
-        with assertRaisesRegexp(NotImplementedError, 'fill_value'):
+        with tm.assert_raises_regex(NotImplementedError, 'fill_value'):
             self.frame.add(self.frame.iloc[0], fill_value=3)
-        with assertRaisesRegexp(NotImplementedError, 'fill_value'):
+        with tm.assert_raises_regex(NotImplementedError, 'fill_value'):
             self.frame.add(self.frame.iloc[0], axis='index', fill_value=3)
 
     def test_binary_ops_align(self):
@@ -589,7 +588,7 @@ class TestDataFrameOperators(tm.TestCase, TestData):
             # NAs
             msg = "Unable to coerce to Series/DataFrame"
             assert_frame_equal(f(np.nan), o(df, np.nan))
-            with assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 f(ndim_5)
 
         # Series
@@ -921,8 +920,8 @@ class TestDataFrameOperators(tm.TestCase, TestData):
             result = func(df1, df2)
             tm.assert_numpy_array_equal(result.values,
                                         func(df1.values, df2.values))
-            with tm.assertRaisesRegexp(ValueError,
-                                       'Wrong number of dimensions'):
+            with tm.assert_raises_regex(ValueError,
+                                        'Wrong number of dimensions'):
                 func(df1, ndim_5)
 
             result2 = func(self.simple, row)
@@ -933,9 +932,9 @@ class TestDataFrameOperators(tm.TestCase, TestData):
             tm.assert_numpy_array_equal(result3.values,
                                         func(self.frame.values, 0))
 
-            with tm.assertRaisesRegexp(ValueError,
-                                       'Can only compare identically'
-                                       '-labeled DataFrame'):
+            with tm.assert_raises_regex(ValueError,
+                                        'Can only compare identically'
+                                        '-labeled DataFrame'):
                 func(self.simple, self.simple[:2])
 
         test_comp(operator.eq)
@@ -1179,10 +1178,10 @@ class TestDataFrameOperators(tm.TestCase, TestData):
         # length mismatch
         msg = 'Unable to coerce to Series, length must be 3: given 2'
         for val in [[1, 2], (1, 2), np.array([1, 2])]:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 align(df, val, 'index')
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 align(df, val, 'columns')
 
         val = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
@@ -1196,10 +1195,10 @@ class TestDataFrameOperators(tm.TestCase, TestData):
         # shape mismatch
         msg = 'Unable to coerce to DataFrame, shape must be'
         val = np.array([[1, 2, 3], [4, 5, 6]])
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             align(df, val, 'index')
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             align(df, val, 'columns')
 
         val = np.zeros((3, 3, 3))
diff --git a/pandas/tests/frame/test_period.py b/pandas/tests/frame/test_period.py
index c1b5a9272..194b6c0e2 100644
--- a/pandas/tests/frame/test_period.py
+++ b/pandas/tests/frame/test_period.py
@@ -106,7 +106,8 @@ class TestPeriodIndex(tm.TestCase):
         tm.assert_index_equal(result.columns, exp_index)
 
         # invalid axis
-        tm.assertRaisesRegexp(ValueError, 'axis', df.to_timestamp, axis=2)
+        tm.assert_raises_regex(
+            ValueError, 'axis', df.to_timestamp, axis=2)
 
         result1 = df.to_timestamp('5t', axis=1)
         result2 = df.to_timestamp('t', axis=1)
diff --git a/pandas/tests/frame/test_quantile.py b/pandas/tests/frame/test_quantile.py
index 1a5ba3cca..406f81079 100644
--- a/pandas/tests/frame/test_quantile.py
+++ b/pandas/tests/frame/test_quantile.py
@@ -9,9 +9,7 @@ import numpy as np
 from pandas import (DataFrame, Series, Timestamp, _np_version_under1p11)
 import pandas as pd
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 from pandas import _np_version_under1p9
@@ -189,21 +187,21 @@ class TestDataFrameQuantile(tm.TestCase, TestData):
         # interpolation method other than default linear
         expErrMsg = "Interpolation methods other than linear"
         df = DataFrame({"A": [1, 2, 3], "B": [2, 3, 4]}, index=[1, 2, 3])
-        with assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             df.quantile(.5, axis=1, interpolation='nearest')
 
-        with assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             df.quantile([.5, .75], axis=1, interpolation='lower')
 
         # test degenerate case
         df = DataFrame({'x': [], 'y': []})
-        with assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             q = df.quantile(0.1, axis=0, interpolation='higher')
 
         # multi
         df = DataFrame([[1, 1, 1], [2, 2, 2], [3, 3, 3]],
                        columns=['a', 'b', 'c'])
-        with assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             df.quantile([.25, .5], interpolation='midpoint')
 
     def test_quantile_multi(self):
@@ -268,7 +266,7 @@ class TestDataFrameQuantile(tm.TestCase, TestData):
     def test_quantile_invalid(self):
         msg = 'percentiles should all be in the interval \\[0, 1\\]'
         for invalid in [-1, 2, [0.5, -1], [0.5, 2]]:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 self.tsframe.quantile(invalid)
 
     def test_quantile_box(self):
diff --git a/pandas/tests/frame/test_query_eval.py b/pandas/tests/frame/test_query_eval.py
index b787d63d3..2232205a5 100644
--- a/pandas/tests/frame/test_query_eval.py
+++ b/pandas/tests/frame/test_query_eval.py
@@ -138,10 +138,10 @@ class TestDataFrameEval(tm.TestCase, TestData):
         df = pd.DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'b']})
 
         msg = "expr must be a string to be evaluated"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.query(lambda x: x.B == "b")
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.query(111)
 
     def test_query_empty_string(self):
@@ -149,7 +149,7 @@ class TestDataFrameEval(tm.TestCase, TestData):
         df = pd.DataFrame({'A': [1, 2, 3]})
 
         msg = "expr cannot be an empty string"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df.query('')
 
     def test_eval_resolvers_as_list(self):
@@ -552,8 +552,8 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
         df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))
 
         df.index.name = 'sin'
-        with tm.assertRaisesRegexp(NumExprClobberingError,
-                                   'Variables in expression.+'):
+        with tm.assert_raises_regex(NumExprClobberingError,
+                                    'Variables in expression.+'):
             df.query('sin > 5', engine=engine, parser=parser)
 
     def test_query(self):
@@ -686,8 +686,8 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
         engine, parser = self.engine, self.parser
         skip_if_no_pandas_parser(parser)
         df = DataFrame(np.random.rand(10, 2), columns=list('ab'))
-        with tm.assertRaisesRegexp(UndefinedVariableError,
-                                   "local variable 'c' is not defined"):
+        with tm.assert_raises_regex(UndefinedVariableError,
+                                    "local variable 'c' is not defined"):
             df.query('a == @c', engine=engine, parser=parser)
 
     def test_index_resolvers_come_after_columns_with_the_same_name(self):
@@ -1119,9 +1119,9 @@ class TestDataFrameEvalNumExprPandas(tm.TestCase):
         df = DataFrame({'a': [1, 2], 'b': ['c', 'd']})
         ops = '+', '-', '*', '/'
         for op in ops:
-            with tm.assertRaisesRegexp(TypeError,
-                                       r"unsupported operand type\(s\) for "
-                                       r".+: '.+' and '.+'"):
+            with tm.assert_raises_regex(TypeError,
+                                        "unsupported operand type\(s\) "
+                                        "for .+: '.+' and '.+'"):
                 df.eval('a {0} b'.format(op), engine=self.engine,
                         parser=self.parser)
 
diff --git a/pandas/tests/frame/test_replace.py b/pandas/tests/frame/test_replace.py
index bb2baaf0e..262734d09 100644
--- a/pandas/tests/frame/test_replace.py
+++ b/pandas/tests/frame/test_replace.py
@@ -918,7 +918,7 @@ class TestDataFrameReplace(tm.TestCase, TestData):
 
     def test_replace_with_dict_with_bool_keys(self):
         df = DataFrame({0: [True, False], 1: [False, True]})
-        with tm.assertRaisesRegexp(TypeError, 'Cannot compare types .+'):
+        with tm.assert_raises_regex(TypeError, 'Cannot compare types .+'):
             df.replace({'asdf': 'asdb', True: 'yes'})
 
     def test_replace_truthy(self):
@@ -929,7 +929,8 @@ class TestDataFrameReplace(tm.TestCase, TestData):
 
     def test_replace_int_to_int_chain(self):
         df = DataFrame({'a': lrange(1, 5)})
-        with tm.assertRaisesRegexp(ValueError, "Replacement not allowed .+"):
+        with tm.assert_raises_regex(ValueError,
+                                    "Replacement not allowed .+"):
             df.replace({'a': dict(zip(range(1, 5), range(2, 6)))})
 
     def test_replace_str_to_str_chain(self):
@@ -937,7 +938,8 @@ class TestDataFrameReplace(tm.TestCase, TestData):
         astr = a.astype(str)
         bstr = np.arange(2, 6).astype(str)
         df = DataFrame({'a': astr})
-        with tm.assertRaisesRegexp(ValueError, "Replacement not allowed .+"):
+        with tm.assert_raises_regex(ValueError,
+                                    "Replacement not allowed .+"):
             df.replace({'a': dict(zip(astr, bstr))})
 
     def test_replace_swapping_bug(self):
diff --git a/pandas/tests/frame/test_reshape.py b/pandas/tests/frame/test_reshape.py
index 60f19b7e6..c1905fa04 100644
--- a/pandas/tests/frame/test_reshape.py
+++ b/pandas/tests/frame/test_reshape.py
@@ -17,9 +17,7 @@ from pandas import (DataFrame, Index, Series, MultiIndex, date_range,
                     Timedelta, Period)
 import pandas as pd
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 
@@ -67,7 +65,7 @@ class TestDataFrameReshape(tm.TestCase, TestData):
         data = DataFrame({'a': ['bar', 'bar', 'foo', 'foo', 'foo'],
                           'b': ['one', 'two', 'one', 'one', 'two'],
                           'c': [1., 2., 3., 3., 4.]})
-        with assertRaisesRegexp(ValueError, 'duplicate entries'):
+        with tm.assert_raises_regex(ValueError, 'duplicate entries'):
             data.pivot('a', 'b', 'c')
 
     def test_pivot_empty(self):
diff --git a/pandas/tests/frame/test_sorting.py b/pandas/tests/frame/test_sorting.py
index f1bca0d6a..bdb5fd0e8 100644
--- a/pandas/tests/frame/test_sorting.py
+++ b/pandas/tests/frame/test_sorting.py
@@ -11,9 +11,7 @@ from pandas.compat import lrange
 from pandas import (DataFrame, Series, MultiIndex, Timestamp,
                     date_range, NaT, IntervalIndex)
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 
@@ -88,7 +86,7 @@ class TestDataFrameSorting(tm.TestCase, TestData):
         assert_frame_equal(sorted_df, expected)
 
         msg = r'Length of ascending \(5\) != length of by \(2\)'
-        with assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             frame.sort_values(by=['A', 'B'], axis=0, ascending=[True] * 5)
 
     def test_sort_values_inplace(self):
@@ -264,7 +262,7 @@ class TestDataFrameSorting(tm.TestCase, TestData):
 
     def test_frame_column_inplace_sort_exception(self):
         s = self.frame['A']
-        with assertRaisesRegexp(ValueError, "This Series is a view"):
+        with tm.assert_raises_regex(ValueError, "This Series is a view"):
             s.sort_values(inplace=True)
 
         cp = s.copy()
@@ -420,26 +418,26 @@ class TestDataFrameSortIndexKinds(tm.TestCase, TestData):
         df = DataFrame([lrange(5, 9), lrange(4)],
                        columns=['a', 'a', 'b', 'b'])
 
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             # use .sort_values #9816
             with tm.assert_produces_warning(FutureWarning):
                 df.sort_index(by='a')
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             df.sort_values(by='a')
 
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             # use .sort_values #9816
             with tm.assert_produces_warning(FutureWarning):
                 df.sort_index(by=['a'])
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             df.sort_values(by=['a'])
 
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             # use .sort_values #9816
             with tm.assert_produces_warning(FutureWarning):
                 # multi-column 'by' is separate codepath
                 df.sort_index(by=['a', 'b'])
-        with assertRaisesRegexp(ValueError, 'duplicate'):
+        with tm.assert_raises_regex(ValueError, 'duplicate'):
             # multi-column 'by' is separate codepath
             df.sort_values(by=['a', 'b'])
 
@@ -447,11 +445,11 @@ class TestDataFrameSortIndexKinds(tm.TestCase, TestData):
         # GH4370
         df = DataFrame(np.random.randn(4, 2),
                        columns=MultiIndex.from_tuples([('a', 0), ('a', 1)]))
-        with assertRaisesRegexp(ValueError, 'levels'):
+        with tm.assert_raises_regex(ValueError, 'levels'):
             # use .sort_values #9816
             with tm.assert_produces_warning(FutureWarning):
                 df.sort_index(by='a')
-        with assertRaisesRegexp(ValueError, 'levels'):
+        with tm.assert_raises_regex(ValueError, 'levels'):
             df.sort_values(by='a')
 
         # convert tuples to a list of tuples
diff --git a/pandas/tests/frame/test_subclass.py b/pandas/tests/frame/test_subclass.py
index 995abfb1c..db4f4b909 100644
--- a/pandas/tests/frame/test_subclass.py
+++ b/pandas/tests/frame/test_subclass.py
@@ -156,7 +156,7 @@ class TestDataFrameSubclassing(tm.TestCase, TestData):
             @property
             def bar(self):
                 return self.i_dont_exist
-        with tm.assertRaisesRegexp(AttributeError, '.*i_dont_exist.*'):
+        with tm.assert_raises_regex(AttributeError, '.*i_dont_exist.*'):
             A().bar
 
     def test_subclass_align(self):
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index 090f742a6..7a5afa178 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -16,9 +16,7 @@ from pandas import (DataFrame, Series, Index,
 import pandas as pd
 import pandas.tseries.offsets as offsets
 
-from pandas.util.testing import (assert_series_equal,
-                                 assert_frame_equal,
-                                 assertRaisesRegexp)
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 
 import pandas.util.testing as tm
 from pandas.compat import product
@@ -220,8 +218,9 @@ class TestDataFrameTimeSeriesMethods(tm.TestCase, TestData):
         assert_frame_equal(shifted2, shifted3)
         assert_frame_equal(ps, shifted2.shift(-1, 'B'))
 
-        assertRaisesRegexp(ValueError, 'does not match PeriodIndex freq',
-                           ps.shift, freq='D')
+        tm.assert_raises_regex(ValueError,
+                               'does not match PeriodIndex freq',
+                               ps.shift, freq='D')
 
         # shift other axis
         # GH 6371
@@ -281,7 +280,8 @@ class TestDataFrameTimeSeriesMethods(tm.TestCase, TestData):
         shifted3 = ps.tshift(freq=offsets.BDay())
         assert_frame_equal(shifted, shifted3)
 
-        assertRaisesRegexp(ValueError, 'does not match', ps.tshift, freq='M')
+        tm.assert_raises_regex(
+            ValueError, 'does not match', ps.tshift, freq='M')
 
         # DatetimeIndex
         shifted = self.tsframe.tshift(1)
diff --git a/pandas/tests/frame/test_to_csv.py b/pandas/tests/frame/test_to_csv.py
index 0fd1df0b7..ffce52543 100644
--- a/pandas/tests/frame/test_to_csv.py
+++ b/pandas/tests/frame/test_to_csv.py
@@ -17,9 +17,8 @@ import pandas as pd
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
                                  assert_frame_equal,
-                                 ensure_clean,
-                                 makeCustomDataframe as mkdf,
-                                 assertRaisesRegexp, slow)
+                                 ensure_clean, slow,
+                                 makeCustomDataframe as mkdf)
 import pandas.util.testing as tm
 
 from pandas.tests.frame.common import TestData
@@ -588,13 +587,13 @@ class TestDataFrameToCSV(tm.TestCase, TestData):
 
             for i in [6, 7]:
                 msg = 'len of {i}, but only 5 lines in file'.format(i=i)
-                with assertRaisesRegexp(ParserError, msg):
+                with tm.assert_raises_regex(ParserError, msg):
                     read_csv(path, tupleize_cols=False,
                              header=lrange(i), index_col=0)
 
             # write with cols
-            with assertRaisesRegexp(TypeError, 'cannot specify cols with a '
-                                    'MultiIndex'):
+            with tm.assert_raises_regex(TypeError, 'cannot specify cols '
+                                        'with a MultiIndex'):
                 df.to_csv(path, tupleize_cols=False, columns=['foo', 'bar'])
 
         with ensure_clean('__tmp_to_csv_multiindex__') as path:
@@ -1106,11 +1105,11 @@ class TestDataFrameToCSV(tm.TestCase, TestData):
         self.assertEqual(result, expected)
 
         msg = "need to escape, but no escapechar set"
-        tm.assertRaisesRegexp(csv.Error, msg, df.to_csv,
-                              quoting=csv.QUOTE_NONE)
-        tm.assertRaisesRegexp(csv.Error, msg, df.to_csv,
-                              quoting=csv.QUOTE_NONE,
-                              escapechar=None)
+        tm.assert_raises_regex(csv.Error, msg, df.to_csv,
+                               quoting=csv.QUOTE_NONE)
+        tm.assert_raises_regex(csv.Error, msg, df.to_csv,
+                               quoting=csv.QUOTE_NONE,
+                               escapechar=None)
 
         expected = """\
 ,c_bool,c_float,c_int,c_string
diff --git a/pandas/tests/groupby/test_aggregate.py b/pandas/tests/groupby/test_aggregate.py
index e32dbb784..e3f166d22 100644
--- a/pandas/tests/groupby/test_aggregate.py
+++ b/pandas/tests/groupby/test_aggregate.py
@@ -577,7 +577,8 @@ class TestGroupByAggregate(tm.TestCase):
                            'b': ['foo', 'bar'] * 25,
                            'dates': pd.date_range('now', periods=50,
                                                   freq='T')})
-        with tm.assertRaisesRegexp(DataError, "No numeric types to aggregate"):
+        with tm.assert_raises_regex(DataError,
+                                    "No numeric types to aggregate"):
             frame.groupby('b').dates.mean()
 
     def test_cython_agg_frame_columns(self):
diff --git a/pandas/tests/groupby/test_filters.py b/pandas/tests/groupby/test_filters.py
index 5f39f320b..2cfbe0ab6 100644
--- a/pandas/tests/groupby/test_filters.py
+++ b/pandas/tests/groupby/test_filters.py
@@ -578,7 +578,8 @@ class TestGroupByFilter(tm.TestCase):
             ['worst', 'd', 'y'],
             ['best', 'd', 'z'],
         ], columns=['a', 'b', 'c'])
-        with tm.assertRaisesRegexp(TypeError, 'filter function returned a.*'):
+        with tm.assert_raises_regex(TypeError,
+                                    'filter function returned a.*'):
             df.groupby('c').filter(lambda g: g['a'] == 'best')
 
     def test_filter_non_bool_raises(self):
@@ -591,7 +592,8 @@ class TestGroupByFilter(tm.TestCase):
             ['worst', 'd', 1],
             ['best', 'd', 1],
         ], columns=['a', 'b', 'c'])
-        with tm.assertRaisesRegexp(TypeError, 'filter function returned a.*'):
+        with tm.assert_raises_regex(TypeError,
+                                    'filter function returned a.*'):
             df.groupby('a').filter(lambda g: g.c.mean())
 
     def test_filter_dropna_with_empty_groups(self):
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index 8ca8ddded..177c2345e 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -14,7 +14,7 @@ from pandas import (date_range, bdate_range, Timestamp,
 from pandas.errors import UnsupportedFunctionCall, PerformanceWarning
 from pandas.util.testing import (assert_panel_equal, assert_frame_equal,
                                  assert_series_equal, assert_almost_equal,
-                                 assert_index_equal, assertRaisesRegexp)
+                                 assert_index_equal)
 from pandas.compat import (range, long, lrange, StringIO, lmap, lzip, map, zip,
                            builtins, OrderedDict, product as cart_product)
 from pandas import compat
@@ -82,7 +82,7 @@ class TestGroupBy(MixIn, tm.TestCase):
         pytest.raises(KeyError, g.__getitem__, ['C'])  # g[['C']]
 
         pytest.raises(KeyError, g.__getitem__, ['A', 'C'])  # g[['A', 'C']]
-        with assertRaisesRegexp(KeyError, '^[^A]+$'):
+        with tm.assert_raises_regex(KeyError, '^[^A]+$'):
             # A should not be referenced as a bad column...
             # will have to rethink regex if you change message!
             g[['A', 'C']]
@@ -1874,16 +1874,14 @@ class TestGroupBy(MixIn, tm.TestCase):
         def j():
             frame.groupby()
 
-        tm.assertRaisesRegexp(TypeError,
-                              "You have to supply one of 'by' and 'level'",
-                              j)
+        tm.assert_raises_regex(TypeError, "You have to supply one of "
+                               "'by' and 'level'", j)
 
         def k():
             frame.groupby(by=None, level=None)
 
-        tm.assertRaisesRegexp(TypeError,
-                              "You have to supply one of 'by' and 'level'",
-                              k)
+        tm.assert_raises_regex(TypeError, "You have to supply one of "
+                               "'by' and 'level'", k)
 
     def test_groupby_level_mapper(self):
         frame = self.mframe
@@ -3753,10 +3751,10 @@ class TestGroupBy(MixIn, tm.TestCase):
         msg = "numpy operations are not valid with groupby"
 
         for func in ('mean', 'var', 'std', 'cumprod', 'cumsum'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(g, func), 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(g, func), foo=1)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(g, func), 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(g, func), foo=1)
 
     def test_grouping_string_repr(self):
         # GH 13394
diff --git a/pandas/tests/groupby/test_transform.py b/pandas/tests/groupby/test_transform.py
index 4624d43df..e0d81003e 100644
--- a/pandas/tests/groupby/test_transform.py
+++ b/pandas/tests/groupby/test_transform.py
@@ -556,7 +556,8 @@ class TestGroupBy(MixIn, tm.TestCase):
         df = pd.DataFrame(np.random.randint(1, 10, (4, 12)),
                           columns=cols,
                           index=['A', 'C', 'G', 'T'])
-        tm.assertRaisesRegexp(ValueError, 'transform must return a scalar '
-                              'value for each group.*', df.groupby
-                              (axis=1, level=1).transform,
-                              lambda z: z.div(z.sum(axis=1), axis=0))
+        tm.assert_raises_regex(ValueError, 'transform must return '
+                               'a scalar value for each '
+                               'group.*',
+                               df.groupby(axis=1, level=1).transform,
+                               lambda z: z.div(z.sum(axis=1), axis=0))
diff --git a/pandas/tests/groupby/test_whitelist.py b/pandas/tests/groupby/test_whitelist.py
index 5a4f28278..5d131717f 100644
--- a/pandas/tests/groupby/test_whitelist.py
+++ b/pandas/tests/groupby/test_whitelist.py
@@ -223,7 +223,7 @@ def test_groupby_blacklist(df_letters):
         for obj in (df, s):
             gb = obj.groupby(df.letters)
             msg = fmt.format(bl, type(gb).__name__)
-            with tm.assertRaisesRegexp(AttributeError, msg):
+            with tm.assert_raises_regex(AttributeError, msg):
                 getattr(gb, bl)
 
 
diff --git a/pandas/tests/indexes/common.py b/pandas/tests/indexes/common.py
index b62cab6cc..56a9af73e 100644
--- a/pandas/tests/indexes/common.py
+++ b/pandas/tests/indexes/common.py
@@ -13,7 +13,6 @@ from pandas import (Series, Index, Float64Index, Int64Index, UInt64Index,
                     notnull, isnull)
 from pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin
 from pandas.core.dtypes.common import needs_i8_conversion
-from pandas.util.testing import assertRaisesRegexp
 from pandas._libs.tslib import iNaT
 
 import pandas.util.testing as tm
@@ -91,26 +90,26 @@ class Base(object):
     def test_numeric_compat(self):
 
         idx = self.create_index()
-        tm.assertRaisesRegexp(TypeError, "cannot perform __mul__",
-                              lambda: idx * 1)
-        tm.assertRaisesRegexp(TypeError, "cannot perform __mul__",
-                              lambda: 1 * idx)
+        tm.assert_raises_regex(TypeError, "cannot perform __mul__",
+                               lambda: idx * 1)
+        tm.assert_raises_regex(TypeError, "cannot perform __mul__",
+                               lambda: 1 * idx)
 
         div_err = "cannot perform __truediv__" if PY3 \
                   else "cannot perform __div__"
-        tm.assertRaisesRegexp(TypeError, div_err, lambda: idx / 1)
-        tm.assertRaisesRegexp(TypeError, div_err, lambda: 1 / idx)
-        tm.assertRaisesRegexp(TypeError, "cannot perform __floordiv__",
-                              lambda: idx // 1)
-        tm.assertRaisesRegexp(TypeError, "cannot perform __floordiv__",
-                              lambda: 1 // idx)
+        tm.assert_raises_regex(TypeError, div_err, lambda: idx / 1)
+        tm.assert_raises_regex(TypeError, div_err, lambda: 1 / idx)
+        tm.assert_raises_regex(TypeError, "cannot perform __floordiv__",
+                               lambda: idx // 1)
+        tm.assert_raises_regex(TypeError, "cannot perform __floordiv__",
+                               lambda: 1 // idx)
 
     def test_logical_compat(self):
         idx = self.create_index()
-        tm.assertRaisesRegexp(TypeError, 'cannot perform all',
-                              lambda: idx.all())
-        tm.assertRaisesRegexp(TypeError, 'cannot perform any',
-                              lambda: idx.any())
+        tm.assert_raises_regex(TypeError, 'cannot perform all',
+                               lambda: idx.all())
+        tm.assert_raises_regex(TypeError, 'cannot perform any',
+                               lambda: idx.any())
 
     def test_boolean_context_compat(self):
 
@@ -121,7 +120,7 @@ class Base(object):
             if idx:
                 pass
 
-        tm.assertRaisesRegexp(ValueError, 'The truth value of a', f)
+        tm.assert_raises_regex(ValueError, 'The truth value of a', f)
 
     def test_reindex_base(self):
         idx = self.create_index()
@@ -130,7 +129,7 @@ class Base(object):
         actual = idx.get_indexer(idx)
         tm.assert_numpy_array_equal(expected, actual)
 
-        with tm.assertRaisesRegexp(ValueError, 'Invalid fill method'):
+        with tm.assert_raises_regex(ValueError, 'Invalid fill method'):
             idx.get_indexer(idx, method='invalid')
 
     def test_ndarray_compat_properties(self):
@@ -178,7 +177,7 @@ class Base(object):
             ind.names = ["apple", "banana", "carrot"]
 
         for ind in self.indices.values():
-            assertRaisesRegexp(ValueError, "^Length", testit, ind)
+            tm.assert_raises_regex(ValueError, "^Length", testit, ind)
 
     def test_set_name_methods(self):
         new_name = "This is the new name for this index"
@@ -198,10 +197,10 @@ class Base(object):
             assert res is None
             self.assertEqual(ind.name, new_name)
             self.assertEqual(ind.names, [new_name])
-            # with assertRaisesRegexp(TypeError, "list-like"):
+            # with tm.assert_raises_regex(TypeError, "list-like"):
             #    # should still fail even if it would be the right length
             #    ind.set_names("a")
-            with assertRaisesRegexp(ValueError, "Level must be None"):
+            with tm.assert_raises_regex(ValueError, "Level must be None"):
                 ind.set_names("a", level=0)
 
             # rename in place just leaves tuples and other containers alone
@@ -212,8 +211,8 @@ class Base(object):
 
     def test_hash_error(self):
         for ind in self.indices.values():
-            with tm.assertRaisesRegexp(TypeError, "unhashable type: %r" %
-                                       type(ind).__name__):
+            with tm.assert_raises_regex(TypeError, "unhashable type: %r" %
+                                        type(ind).__name__):
                 hash(ind)
 
     def test_copy_name(self):
@@ -427,16 +426,16 @@ class Base(object):
             # backwards compatibility concerns
             if isinstance(type(ind), (CategoricalIndex, RangeIndex)):
                 msg = "the 'axis' parameter is not supported"
-                tm.assertRaisesRegexp(ValueError, msg,
-                                      np.argsort, ind, axis=1)
+                tm.assert_raises_regex(ValueError, msg,
+                                       np.argsort, ind, axis=1)
 
                 msg = "the 'kind' parameter is not supported"
-                tm.assertRaisesRegexp(ValueError, msg, np.argsort,
-                                      ind, kind='mergesort')
+                tm.assert_raises_regex(ValueError, msg, np.argsort,
+                                       ind, kind='mergesort')
 
                 msg = "the 'order' parameter is not supported"
-                tm.assertRaisesRegexp(ValueError, msg, np.argsort,
-                                      ind, order=('a', 'b'))
+                tm.assert_raises_regex(ValueError, msg, np.argsort,
+                                       ind, order=('a', 'b'))
 
     def test_pickle(self):
         for ind in self.indices.values():
@@ -467,16 +466,16 @@ class Base(object):
         indices = [1, 2]
 
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, idx.take,
-                              indices, foo=2)
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, out=indices)
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
 
     def test_repeat(self):
         rep = 2
@@ -496,8 +495,8 @@ class Base(object):
         tm.assert_index_equal(np.repeat(i, rep), expected)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.repeat,
-                              i, rep, axis=0)
+        tm.assert_raises_regex(ValueError, msg, np.repeat,
+                               i, rep, axis=0)
 
     def test_where(self):
         i = self.create_index()
@@ -533,9 +532,10 @@ class Base(object):
 
             for method in methods:
                 for case in cases:
-                    assertRaisesRegexp(TypeError,
-                                       "Input must be Index or array-like",
-                                       method, case)
+                    tm.assert_raises_regex(TypeError,
+                                           "Input must be Index "
+                                           "or array-like",
+                                           method, case)
 
     def test_intersection_base(self):
         for name, idx in compat.iteritems(self.indices):
@@ -554,7 +554,7 @@ class Base(object):
             for case in cases:
                 if isinstance(idx, PeriodIndex):
                     msg = "can only call with other PeriodIndex-ed objects"
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         result = first.intersection(case)
                 elif isinstance(idx, CategoricalIndex):
                     pass
@@ -564,7 +564,7 @@ class Base(object):
 
             if isinstance(idx, MultiIndex):
                 msg = "other must be a MultiIndex or a list of tuples"
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     result = first.intersection([1, 2, 3])
 
     def test_union_base(self):
@@ -581,7 +581,7 @@ class Base(object):
             for case in cases:
                 if isinstance(idx, PeriodIndex):
                     msg = "can only call with other PeriodIndex-ed objects"
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         result = first.union(case)
                 elif isinstance(idx, CategoricalIndex):
                     pass
@@ -591,7 +591,7 @@ class Base(object):
 
             if isinstance(idx, MultiIndex):
                 msg = "other must be a MultiIndex or a list of tuples"
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     result = first.union([1, 2, 3])
 
     def test_difference_base(self):
@@ -612,7 +612,7 @@ class Base(object):
             for case in cases:
                 if isinstance(idx, PeriodIndex):
                     msg = "can only call with other PeriodIndex-ed objects"
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         result = first.difference(case)
                 elif isinstance(idx, CategoricalIndex):
                     pass
@@ -625,7 +625,7 @@ class Base(object):
 
             if isinstance(idx, MultiIndex):
                 msg = "other must be a MultiIndex or a list of tuples"
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     result = first.difference([1, 2, 3])
 
     def test_symmetric_difference(self):
@@ -645,7 +645,7 @@ class Base(object):
             for case in cases:
                 if isinstance(idx, PeriodIndex):
                     msg = "can only call with other PeriodIndex-ed objects"
-                    with tm.assertRaisesRegexp(ValueError, msg):
+                    with tm.assert_raises_regex(ValueError, msg):
                         result = first.symmetric_difference(case)
                 elif isinstance(idx, CategoricalIndex):
                     pass
@@ -655,7 +655,7 @@ class Base(object):
 
             if isinstance(idx, MultiIndex):
                 msg = "other must be a MultiIndex or a list of tuples"
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     result = first.symmetric_difference([1, 2, 3])
 
         # 12591 deprecated
@@ -728,7 +728,7 @@ class Base(object):
         index_b = index_a[0:-1]
         index_c = index_a[0:-1].append(index_a[-2:-1])
         index_d = index_a[0:1]
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == index_b
         expected1 = np.array([True] * n)
         expected2 = np.array([True] * (n - 1) + [False])
@@ -740,7 +740,7 @@ class Base(object):
         array_b = np.array(index_a[0:-1])
         array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))
         array_d = np.array(index_a[0:1])
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == array_b
         tm.assert_numpy_array_equal(index_a == array_a, expected1)
         tm.assert_numpy_array_equal(index_a == array_c, expected2)
@@ -750,22 +750,22 @@ class Base(object):
         series_b = Series(array_b)
         series_c = Series(array_c)
         series_d = Series(array_d)
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == series_b
         tm.assert_numpy_array_equal(index_a == series_a, expected1)
         tm.assert_numpy_array_equal(index_a == series_c, expected2)
 
         # cases where length is 1 for one of them
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == index_d
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == series_d
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             index_a == array_d
         msg = "Can only compare identically-labeled Series objects"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             series_a == series_d
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             series_a == array_d
 
         # comparing with a scalar should broadcast; note that we are excluding
@@ -875,7 +875,7 @@ class Base(object):
             elif isinstance(index, MultiIndex):
                 idx = index.copy()
                 msg = "isnull is not defined for MultiIndex"
-                with tm.assertRaisesRegexp(NotImplementedError, msg):
+                with tm.assert_raises_regex(NotImplementedError, msg):
                     idx.fillna(idx[0])
             else:
                 idx = index.copy()
@@ -884,7 +884,7 @@ class Base(object):
                 self.assertFalse(result is idx)
 
                 msg = "'value' must be a scalar, passed: "
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     idx.fillna([idx[0]])
 
                 idx = index.copy()
@@ -918,7 +918,7 @@ class Base(object):
             elif isinstance(index, MultiIndex):
                 idx = index.copy()
                 msg = "isnull is not defined for MultiIndex"
-                with tm.assertRaisesRegexp(NotImplementedError, msg):
+                with tm.assert_raises_regex(NotImplementedError, msg):
                     idx.isnull()
             else:
 
diff --git a/pandas/tests/indexes/datetimes/test_construction.py b/pandas/tests/indexes/datetimes/test_construction.py
index ca673e305..ea9f7c65f 100644
--- a/pandas/tests/indexes/datetimes/test_construction.py
+++ b/pandas/tests/indexes/datetimes/test_construction.py
@@ -246,7 +246,8 @@ class TestDatetimeIndex(tm.TestCase):
                            Timestamp('2011-01-02 10:00', tz='US/Eastern')],
                           name='idx')
 
-        with tm.assertRaisesRegexp(TypeError, 'data is already tz-aware'):
+        with tm.assert_raises_regex(TypeError,
+                                    'data is already tz-aware'):
             DatetimeIndex([Timestamp('2011-01-01 10:00'),
                            Timestamp('2011-01-02 10:00', tz='US/Eastern')],
                           tz='Asia/Tokyo', name='idx')
@@ -256,7 +257,8 @@ class TestDatetimeIndex(tm.TestCase):
                            Timestamp('2011-01-02 10:00', tz='US/Eastern')],
                           tz='US/Eastern', name='idx')
 
-        with tm.assertRaisesRegexp(TypeError, 'data is already tz-aware'):
+        with tm.assert_raises_regex(TypeError,
+                                    'data is already tz-aware'):
             # passing tz should results in DatetimeIndex, then mismatch raises
             # TypeError
             Index([pd.NaT, Timestamp('2011-01-01 10:00'),
diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 6e49b1612..e570313b7 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -212,31 +212,31 @@ class TestBusinessDateRange(tm.TestCase):
         naive = bdate_range(START, END, freq=BDay(), tz=None)
         aware = bdate_range(START, END, freq=BDay(),
                             tz="Asia/Hong_Kong")
-        tm.assertRaisesRegexp(TypeError, "tz-naive.*tz-aware",
-                              naive.join, aware)
-        tm.assertRaisesRegexp(TypeError, "tz-naive.*tz-aware",
-                              aware.join, naive)
+        tm.assert_raises_regex(TypeError, "tz-naive.*tz-aware",
+                               naive.join, aware)
+        tm.assert_raises_regex(TypeError, "tz-naive.*tz-aware",
+                               aware.join, naive)
 
     def test_cached_range(self):
         DatetimeIndex._cached_range(START, END, offset=BDay())
         DatetimeIndex._cached_range(START, periods=20, offset=BDay())
         DatetimeIndex._cached_range(end=START, periods=20, offset=BDay())
 
-        tm.assertRaisesRegexp(TypeError, "offset",
-                              DatetimeIndex._cached_range,
-                              START, END)
+        tm.assert_raises_regex(TypeError, "offset",
+                               DatetimeIndex._cached_range,
+                               START, END)
 
-        tm.assertRaisesRegexp(TypeError, "specify period",
-                              DatetimeIndex._cached_range, START,
-                              offset=BDay())
+        tm.assert_raises_regex(TypeError, "specify period",
+                               DatetimeIndex._cached_range, START,
+                               offset=BDay())
 
-        tm.assertRaisesRegexp(TypeError, "specify period",
-                              DatetimeIndex._cached_range, end=END,
-                              offset=BDay())
+        tm.assert_raises_regex(TypeError, "specify period",
+                               DatetimeIndex._cached_range, end=END,
+                               offset=BDay())
 
-        tm.assertRaisesRegexp(TypeError, "start or end",
-                              DatetimeIndex._cached_range, periods=20,
-                              offset=BDay())
+        tm.assert_raises_regex(TypeError, "start or end",
+                               DatetimeIndex._cached_range, periods=20,
+                               offset=BDay())
 
     def test_cached_range_bug(self):
         rng = date_range('2010-09-01 05:00:00', periods=50,
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index abfc52728..8a4cff297 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -40,7 +40,7 @@ class TestDatetimeIndex(tm.TestCase):
                                      tolerance=np.timedelta64(1, 'D')), 1)
         self.assertEqual(idx.get_loc('2000-01-01T12', method='nearest',
                                      tolerance=timedelta(1)), 1)
-        with tm.assertRaisesRegexp(ValueError, 'must be convertible'):
+        with tm.assert_raises_regex(ValueError, 'must be convertible'):
             idx.get_loc('2000-01-01T12', method='nearest', tolerance='foo')
         with pytest.raises(KeyError):
             idx.get_loc('2000-01-01T03', method='nearest', tolerance='2 hours')
@@ -212,8 +212,8 @@ class TestDatetimeIndex(tm.TestCase):
 
     def test_hash_error(self):
         index = date_range('20010101', periods=10)
-        with tm.assertRaisesRegexp(TypeError, "unhashable type: %r" %
-                                   type(index).__name__):
+        with tm.assert_raises_regex(TypeError, "unhashable type: %r" %
+                                    type(index).__name__):
             hash(index)
 
     def test_stringified_slice_with_tz(self):
@@ -508,9 +508,9 @@ class TestDatetimeIndex(tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -539,9 +539,9 @@ class TestDatetimeIndex(tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -645,8 +645,9 @@ class TestDatetimeIndex(tm.TestCase):
         joins = 'left', 'right', 'inner', 'outer'
 
         for join in joins:
-            with tm.assertRaisesRegexp(ValueError, 'can only call with other '
-                                       'PeriodIndex-ed objects'):
+            with tm.assert_raises_regex(ValueError,
+                                        'can only call with other '
+                                        'PeriodIndex-ed objects'):
                 df.columns.join(s.index, how=join)
 
     def test_factorize(self):
@@ -755,12 +756,12 @@ class TestDatetimeIndex(tm.TestCase):
     def test_slice_with_zero_step_raises(self):
         ts = Series(np.arange(20),
                     date_range('2014-01-01', periods=20, freq='MS'))
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
 
     def test_slice_bounds_empty(self):
         # GH 14354
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index d531d0913..020bb0e27 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -131,16 +131,18 @@ class TestDatetimeIndexOps(Ops):
                          Timestamp('2016-01-20 00:00:00', freq='D'))
 
         errmsg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, errmsg, np.min, dr, out=0)
-        tm.assertRaisesRegexp(ValueError, errmsg, np.max, dr, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.min, dr, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.max, dr, out=0)
 
         self.assertEqual(np.argmin(dr), 0)
         self.assertEqual(np.argmax(dr), 5)
 
         if not _np_version_under1p10:
             errmsg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmin, dr, out=0)
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmax, dr, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmin, dr, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmax, dr, out=0)
 
     def test_round(self):
         for tz in self.tz:
@@ -161,14 +163,14 @@ class TestDatetimeIndexOps(Ops):
             self.assertEqual(elt.round(freq='H'), expected_elt)
 
             msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 rng.round(freq='foo')
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 elt.round(freq='foo')
 
             msg = "<MonthEnd> is a non-fixed frequency"
-            tm.assertRaisesRegexp(ValueError, msg, rng.round, freq='M')
-            tm.assertRaisesRegexp(ValueError, msg, elt.round, freq='M')
+            tm.assert_raises_regex(ValueError, msg, rng.round, freq='M')
+            tm.assert_raises_regex(ValueError, msg, elt.round, freq='M')
 
             # GH 14440 & 15578
             index = pd.DatetimeIndex(['2016-10-17 12:00:00.0015'], tz=tz)
@@ -245,8 +247,8 @@ class TestDatetimeIndexOps(Ops):
             assert res.freq is None
 
             tm.assert_index_equal(np.repeat(rng, reps), expected_rng)
-            tm.assertRaisesRegexp(ValueError, msg, np.repeat,
-                                  rng, reps, axis=1)
+            tm.assert_raises_regex(ValueError, msg, np.repeat,
+                                   rng, reps, axis=1)
 
     def test_representation(self):
 
@@ -433,10 +435,10 @@ Freq: D"""
 
         idx = DatetimeIndex(['2011-01-01', '2011-01-02'])
         msg = "cannot add a datelike to a DatetimeIndex"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             idx + Timestamp('2011-01-01')
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Timestamp('2011-01-01') + idx
 
     def test_add_dti_dti(self):
@@ -830,16 +832,16 @@ Freq: D"""
         indices = [1, 6, 5, 9, 10, 13, 15, 3]
 
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, idx.take,
-                              indices, foo=2)
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, out=indices)
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
 
     def test_infer_freq(self):
         # GH 11018
diff --git a/pandas/tests/indexes/datetimes/test_partial_slicing.py b/pandas/tests/indexes/datetimes/test_partial_slicing.py
index 352e066c6..c3eda8b37 100644
--- a/pandas/tests/indexes/datetimes/test_partial_slicing.py
+++ b/pandas/tests/indexes/datetimes/test_partial_slicing.py
@@ -122,8 +122,8 @@ class TestSlicing(tm.TestCase):
         tm.assert_series_equal(s['2005-1-1 00:01:00'], s.iloc[10:])
 
         self.assertEqual(s[Timestamp('2005-1-1 00:00:59.999990')], s.iloc[0])
-        tm.assertRaisesRegexp(KeyError, '2005-1-1 00:00:00',
-                              lambda: s['2005-1-1 00:00:00'])
+        tm.assert_raises_regex(KeyError, '2005-1-1 00:00:00',
+                               lambda: s['2005-1-1 00:00:00'])
 
     def test_partial_slicing_dataframe(self):
         # GH14856
@@ -249,14 +249,14 @@ class TestSlicing(tm.TestCase):
         timestamp = pd.Timestamp('2014-01-10')
 
         tm.assert_series_equal(nonmonotonic['2014-01-10':], expected)
-        tm.assertRaisesRegexp(KeyError,
-                              r"Timestamp\('2014-01-10 00:00:00'\)",
-                              lambda: nonmonotonic[timestamp:])
+        tm.assert_raises_regex(KeyError,
+                               r"Timestamp\('2014-01-10 00:00:00'\)",
+                               lambda: nonmonotonic[timestamp:])
 
         tm.assert_series_equal(nonmonotonic.loc['2014-01-10':], expected)
-        tm.assertRaisesRegexp(KeyError,
-                              r"Timestamp\('2014-01-10 00:00:00'\)",
-                              lambda: nonmonotonic.loc[timestamp:])
+        tm.assert_raises_regex(KeyError,
+                               r"Timestamp\('2014-01-10 00:00:00'\)",
+                               lambda: nonmonotonic.loc[timestamp:])
 
     def test_loc_datetime_length_one(self):
         # GH16071
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index c637b36d1..715825417 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -1308,13 +1308,13 @@ class TestDatetimeParsingWrappers(tm.TestCase):
     def test_parsers_quarterly_with_freq(self):
         msg = ('Incorrect quarterly string is given, quarter '
                'must be between 1 and 4: 2013Q5')
-        with tm.assertRaisesRegexp(tslib.DateParseError, msg):
+        with tm.assert_raises_regex(tslib.DateParseError, msg):
             tools.parse_time_string('2013Q5')
 
         # GH 5418
         msg = ('Unable to retrieve month information from given freq: '
                'INVLD-L-DEC-SAT')
-        with tm.assertRaisesRegexp(tslib.DateParseError, msg):
+        with tm.assert_raises_regex(tslib.DateParseError, msg):
             tools.parse_time_string('2013Q1', freq='INVLD-L-DEC-SAT')
 
         cases = {('2013Q2', None): datetime(2013, 4, 1),
diff --git a/pandas/tests/indexes/period/test_construction.py b/pandas/tests/indexes/period/test_construction.py
index 8f2b03829..434271cbe 100644
--- a/pandas/tests/indexes/period/test_construction.py
+++ b/pandas/tests/indexes/period/test_construction.py
@@ -181,7 +181,7 @@ class TestPeriodIndex(tm.TestCase):
         self.assertEqual(res.dtype, 'period[M]')
 
         msg = 'specified freq and dtype are different'
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             PeriodIndex(['2011-01'], freq='M', dtype='period[D]')
 
     def test_constructor_empty(self):
@@ -190,7 +190,7 @@ class TestPeriodIndex(tm.TestCase):
         self.assertEqual(len(idx), 0)
         self.assertEqual(idx.freq, 'M')
 
-        with tm.assertRaisesRegexp(ValueError, 'freq not specified'):
+        with tm.assert_raises_regex(ValueError, 'freq not specified'):
             pd.PeriodIndex([])
 
     def test_constructor_pi_nat(self):
@@ -216,35 +216,35 @@ class TestPeriodIndex(tm.TestCase):
         idx = PeriodIndex([pd.NaT, pd.NaT, '2011-01', '2011-01'], freq='M')
         tm.assert_index_equal(idx, exp)
 
-        with tm.assertRaisesRegexp(ValueError, 'freq not specified'):
+        with tm.assert_raises_regex(ValueError, 'freq not specified'):
             PeriodIndex([pd.NaT, pd.NaT])
 
-        with tm.assertRaisesRegexp(ValueError, 'freq not specified'):
+        with tm.assert_raises_regex(ValueError, 'freq not specified'):
             PeriodIndex(np.array([pd.NaT, pd.NaT]))
 
-        with tm.assertRaisesRegexp(ValueError, 'freq not specified'):
+        with tm.assert_raises_regex(ValueError, 'freq not specified'):
             PeriodIndex(['NaT', 'NaT'])
 
-        with tm.assertRaisesRegexp(ValueError, 'freq not specified'):
+        with tm.assert_raises_regex(ValueError, 'freq not specified'):
             PeriodIndex(np.array(['NaT', 'NaT']))
 
     def test_constructor_incompat_freq(self):
         msg = "Input has different freq=D from PeriodIndex\\(freq=M\\)"
 
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             PeriodIndex([Period('2011-01', freq='M'), pd.NaT,
                          Period('2011-01', freq='D')])
 
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             PeriodIndex(np.array([Period('2011-01', freq='M'), pd.NaT,
                                   Period('2011-01', freq='D')]))
 
         # first element is pd.NaT
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             PeriodIndex([pd.NaT, Period('2011-01', freq='M'),
                          Period('2011-01', freq='D')])
 
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             PeriodIndex(np.array([pd.NaT, Period('2011-01', freq='M'),
                                   Period('2011-01', freq='D')]))
 
@@ -332,15 +332,15 @@ class TestPeriodIndex(tm.TestCase):
 
         msg = ('Frequency must be positive, because it'
                ' represents span: -1M')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             PeriodIndex(['2011-01'], freq='-1M')
 
         msg = ('Frequency must be positive, because it' ' represents span: 0M')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             PeriodIndex(['2011-01'], freq='0M')
 
         msg = ('Frequency must be positive, because it' ' represents span: 0M')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             period_range('2011-01', periods=3, freq='0M')
 
     def test_constructor_freq_mult_dti_compat(self):
@@ -437,11 +437,11 @@ class TestPeriodIndex(tm.TestCase):
         end_intv = Period('2006-12-31', ('w', 1))
 
         msg = 'Start and end must have same freq'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             PeriodIndex(start=start, end=end_intv)
 
         msg = 'Must specify 2 of start, end, periods'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             PeriodIndex(start=start)
 
     def test_recreate_from_data(self):
diff --git a/pandas/tests/indexes/period/test_indexing.py b/pandas/tests/indexes/period/test_indexing.py
index 4d5fdd748..7af9e9ae3 100644
--- a/pandas/tests/indexes/period/test_indexing.py
+++ b/pandas/tests/indexes/period/test_indexing.py
@@ -103,10 +103,10 @@ class TestGetItem(tm.TestCase):
         tm.assert_series_equal(exp, result)
 
         ts = ts[10:].append(ts[10:])
-        tm.assertRaisesRegexp(KeyError,
-                              "left slice bound for non-unique "
-                              "label: '2008'",
-                              ts.__getitem__, slice('2008', '2009'))
+        tm.assert_raises_regex(KeyError,
+                               "left slice bound for non-unique "
+                               "label: '2008'",
+                               ts.__getitem__, slice('2008', '2009'))
 
     def test_getitem_datetime(self):
         rng = period_range(start='2012-01-01', periods=10, freq='W-MON')
@@ -311,9 +311,9 @@ class TestIndexing(tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
diff --git a/pandas/tests/indexes/period/test_ops.py b/pandas/tests/indexes/period/test_ops.py
index 4f54f44b7..70c0879a0 100644
--- a/pandas/tests/indexes/period/test_ops.py
+++ b/pandas/tests/indexes/period/test_ops.py
@@ -105,16 +105,18 @@ class TestPeriodIndexOps(Ops):
         self.assertEqual(np.max(pr), Period('2016-01-20', freq='D'))
 
         errmsg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, errmsg, np.min, pr, out=0)
-        tm.assertRaisesRegexp(ValueError, errmsg, np.max, pr, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.min, pr, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.max, pr, out=0)
 
         self.assertEqual(np.argmin(pr), 0)
         self.assertEqual(np.argmax(pr), 5)
 
         if not _np_version_under1p10:
             errmsg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmin, pr, out=0)
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmax, pr, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmin, pr, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmax, pr, out=0)
 
     def test_representation(self):
         # GH 7601
@@ -309,7 +311,8 @@ Freq: Q-DEC"""
                   timedelta(365), Timedelta(days=365)]:
             msg = ('Input has different freq(=.+)? '
                    'from PeriodIndex\\(freq=A-DEC\\)')
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng + o
 
         rng = pd.period_range('2014-01', '2016-12', freq='M')
@@ -324,7 +327,8 @@ Freq: Q-DEC"""
                   timedelta(365), Timedelta(days=365)]:
             rng = pd.period_range('2014-01', '2016-12', freq='M')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng + o
 
         # Tick
@@ -345,7 +349,8 @@ Freq: Q-DEC"""
                   timedelta(hours=23), Timedelta('23:00:00')]:
             rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng + o
 
         offsets = [pd.offsets.Hour(2), timedelta(hours=2),
@@ -367,9 +372,11 @@ Freq: Q-DEC"""
             rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
                                   freq='H')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
-                result = rng + delta
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + delta
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng += delta
 
         # int
@@ -415,7 +422,8 @@ Freq: Q-DEC"""
             rng = pd.period_range('2014', '2024', freq='A')
             msg = ('Input has different freq(=.+)? '
                    'from PeriodIndex\\(freq=A-DEC\\)')
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng - o
 
         rng = pd.period_range('2014-01', '2016-12', freq='M')
@@ -430,7 +438,8 @@ Freq: Q-DEC"""
                   timedelta(365)]:
             rng = pd.period_range('2014-01', '2016-12', freq='M')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng - o
 
         # Tick
@@ -450,7 +459,8 @@ Freq: Q-DEC"""
                   timedelta(hours=23)]:
             rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng - o
 
         offsets = [pd.offsets.Hour(2), timedelta(hours=2),
@@ -471,9 +481,11 @@ Freq: Q-DEC"""
             rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
                                   freq='H')
             msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
-                result = rng + delta
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + delta
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 rng += delta
 
         # int
@@ -884,14 +896,14 @@ class TestPeriodIndexSeriesMethods(tm.TestCase):
 
         for obj in [idx, s]:
             for ng in ["str", 1.5]:
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     obj + ng
 
                 with pytest.raises(TypeError):
                     # error message differs between PY2 and 3
                     ng + obj
 
-                with tm.assertRaisesRegexp(TypeError, msg):
+                with tm.assert_raises_regex(TypeError, msg):
                     obj - ng
 
                 with pytest.raises(TypeError):
@@ -987,13 +999,16 @@ class TestPeriodIndexSeriesMethods(tm.TestCase):
         msg_idx = r"Input has different freq from PeriodIndex\(freq=D\)"
         msg_s = r"Input cannot be converted to Period\(freq=D\)"
         for obj, msg in [(idx, msg_idx), (s, msg_s)]:
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 obj + offsets.Hour(2)
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 offsets.Hour(2) + obj
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 obj - offsets.Hour(2)
 
     def test_pi_sub_period(self):
@@ -1247,25 +1262,31 @@ class TestPeriodIndexComparisons(tm.TestCase):
 
             # different base freq
             msg = "Input has different freq=A-DEC from PeriodIndex"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 base <= Period('2011', freq='A')
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 Period('2011', freq='A') >= base
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 idx = PeriodIndex(['2011', '2012', '2013', '2014'], freq='A')
                 base <= idx
 
-            # different mult
+            # Different frequency
             msg = "Input has different freq=4M from PeriodIndex"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 base <= Period('2011', freq='4M')
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 Period('2011', freq='4M') >= base
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 idx = PeriodIndex(['2011', '2012', '2013', '2014'], freq='4M')
                 base <= idx
 
@@ -1317,8 +1338,10 @@ class TestPeriodIndexComparisons(tm.TestCase):
             diff = PeriodIndex(['2011-02', '2011-01', '2011-04',
                                 'NaT'], freq='4M')
             msg = "Input has different freq=4M from PeriodIndex"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 idx1 > diff
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 idx1 == diff
diff --git a/pandas/tests/indexes/period/test_partial_slicing.py b/pandas/tests/indexes/period/test_partial_slicing.py
index b13e231db..7c1279a12 100644
--- a/pandas/tests/indexes/period/test_partial_slicing.py
+++ b/pandas/tests/indexes/period/test_partial_slicing.py
@@ -42,12 +42,12 @@ class TestPeriodIndex(tm.TestCase):
     def test_slice_with_zero_step_raises(self):
         ts = Series(np.arange(20),
                     period_range('2014-01', periods=20, freq='M'))
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
 
     def test_slice_keep_name(self):
         idx = period_range('20010101', periods=10, freq='D', name='bob')
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 6036d6c0f..e563f683b 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -82,11 +82,11 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
                                      tolerance=np.timedelta64(1, 'D')), 1)
         self.assertEqual(idx.get_loc('2000-01-02T12', method='nearest',
                                      tolerance=timedelta(1)), 1)
-        with tm.assertRaisesRegexp(ValueError, 'must be convertible'):
+        with tm.assert_raises_regex(ValueError, 'must be convertible'):
             idx.get_loc('2000-01-10', method='nearest', tolerance='foo')
 
         msg = 'Input has different freq from PeriodIndex\\(freq=D\\)'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.get_loc('2000-01-10', method='nearest', tolerance='1 hour')
         with pytest.raises(KeyError):
             idx.get_loc('2000-01-10', method='nearest', tolerance='1 day')
@@ -151,7 +151,7 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
                                     np.array([0, -1, 1], dtype=np.intp))
 
         msg = 'Input has different freq from PeriodIndex\\(freq=H\\)'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.get_indexer(target, 'nearest', tolerance='1 minute')
 
         tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest',
@@ -223,8 +223,8 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
 
     def test_hash_error(self):
         index = period_range('20010101', periods=10)
-        with tm.assertRaisesRegexp(TypeError, "unhashable type: %r" %
-                                   type(index).__name__):
+        with tm.assert_raises_regex(TypeError, "unhashable type: %r" %
+                                    type(index).__name__):
             hash(index)
 
     def test_make_time_series(self):
@@ -679,7 +679,8 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
         tm.assert_index_equal(np.repeat(index, 2), expected)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.repeat, index, 2, axis=1)
+        tm.assert_raises_regex(
+            ValueError, msg, np.repeat, index, 2, axis=1)
 
     def test_pindex_multiples(self):
         pi = PeriodIndex(start='1/1/11', end='12/31/11', freq='2M')
diff --git a/pandas/tests/indexes/period/test_setops.py b/pandas/tests/indexes/period/test_setops.py
index 97f9cff2d..e1fdc85d6 100644
--- a/pandas/tests/indexes/period/test_setops.py
+++ b/pandas/tests/indexes/period/test_setops.py
@@ -112,7 +112,7 @@ class TestPeriodIndex(tm.TestCase):
             index.union(index2)
 
         msg = 'can only call with other PeriodIndex-ed objects'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             index.join(index.to_timestamp())
 
         index3 = period_range('1/1/2000', '1/20/2000', freq='2D')
diff --git a/pandas/tests/indexes/period/test_tools.py b/pandas/tests/indexes/period/test_tools.py
index 3887463ca..60ad8fed3 100644
--- a/pandas/tests/indexes/period/test_tools.py
+++ b/pandas/tests/indexes/period/test_tools.py
@@ -271,7 +271,7 @@ class TestPeriodIndex(tm.TestCase):
 
         msg = ('Frequency must be positive, because it'
                ' represents span: -2A')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             result.to_period(freq='-2A')
 
     def test_to_timestamp_pi_mult(self):
@@ -386,7 +386,7 @@ class TestPeriodIndex(tm.TestCase):
         self.assertEqual(prng.freq, 'M')
 
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             date_range('01-Jan-2012', periods=8, freq='EOM')
 
     def test_period_dt64_round_trip(self):
@@ -439,11 +439,13 @@ class TestPeriodIndex(tm.TestCase):
             self.assertEqual(pidx.searchsorted(p2), 3)
 
             msg = "Input has different freq=H from PeriodIndex"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 pidx.searchsorted(pd.Period('2014-01-01', freq='H'))
 
             msg = "Input has different freq=5D from PeriodIndex"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 pidx.searchsorted(pd.Period('2014-01-01', freq='5D'))
 
             with tm.assert_produces_warning(FutureWarning):
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 06f98527d..caf2dde24 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -206,10 +206,10 @@ class TestIndex(Base, tm.TestCase):
         data = [np.nan]
         msg = "cannot convert"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Index(data, dtype='int64')
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Index(data, dtype='uint64')
 
         # This, however, should not break
@@ -1062,10 +1062,10 @@ class TestIndex(Base, tm.TestCase):
         # GH10411
         idx = Index(np.arange(10))
 
-        with tm.assertRaisesRegexp(ValueError, 'tolerance argument'):
+        with tm.assert_raises_regex(ValueError, 'tolerance argument'):
             idx.get_indexer([1, 0], tolerance=1)
 
-        with tm.assertRaisesRegexp(ValueError, 'limit argument'):
+        with tm.assert_raises_regex(ValueError, 'limit argument'):
             idx.get_indexer([1, 0], limit=1)
 
     def test_get_indexer_nearest(self):
@@ -1099,7 +1099,7 @@ class TestIndex(Base, tm.TestCase):
             tm.assert_numpy_array_equal(actual, np.array(expected,
                                                          dtype=np.intp))
 
-        with tm.assertRaisesRegexp(ValueError, 'limit argument'):
+        with tm.assert_raises_regex(ValueError, 'limit argument'):
             idx.get_indexer([1, 0], method='nearest', limit=1)
 
     def test_get_indexer_nearest_decreasing(self):
@@ -1154,9 +1154,9 @@ class TestIndex(Base, tm.TestCase):
             with pytest.raises(KeyError):
                 idx.get_loc(1.1, method, tolerance=0.05)
 
-        with tm.assertRaisesRegexp(ValueError, 'must be numeric'):
+        with tm.assert_raises_regex(ValueError, 'must be numeric'):
             idx.get_loc(1.1, 'nearest', tolerance='invalid')
-        with tm.assertRaisesRegexp(ValueError, 'tolerance .* valid if'):
+        with tm.assert_raises_regex(ValueError, 'tolerance .* valid if'):
             idx.get_loc(1.1, tolerance=1)
 
         idx = pd.Index(['a', 'c'])
@@ -1450,8 +1450,8 @@ class TestIndex(Base, tm.TestCase):
                    MultiIndex.from_tuples([('foo', '1'), ('bar', '3')]),
                    PeriodIndex(start='2000', end='2010', freq='A')]
         for idx in indices:
-            with tm.assertRaisesRegexp(AttributeError,
-                                       'only use .str accessor'):
+            with tm.assert_raises_regex(AttributeError,
+                                        'only use .str accessor'):
                 idx.str.repeat(2)
 
         idx = Index(['a b c', 'd e', 'f'])
@@ -1526,9 +1526,9 @@ class TestIndex(Base, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -1537,8 +1537,8 @@ class TestIndex(Base, tm.TestCase):
     def test_reshape_raise(self):
         msg = "reshaping is not supported"
         idx = pd.Index([0, 1, 2])
-        tm.assertRaisesRegexp(NotImplementedError, msg,
-                              idx.reshape, idx.shape)
+        tm.assert_raises_regex(NotImplementedError, msg,
+                               idx.reshape, idx.shape)
 
     def test_reindex_preserves_name_if_target_is_list_or_ndarray(self):
         # GH6552
@@ -1617,11 +1617,11 @@ class TestIndex(Base, tm.TestCase):
         mi2 = MultiIndex.from_tuples([(1, 2), (4, 6)])
         tm.assert_numpy_array_equal(df.index == mi2, np.array([True, False]))
         mi3 = MultiIndex.from_tuples([(1, 2), (4, 5), (8, 9)])
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             df.index == mi3
 
         index_a = Index(['foo', 'bar', 'baz'])
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             df.index == index_a
         tm.assert_numpy_array_equal(index_a == mi3,
                                     np.array([False, False, False]))
@@ -1821,10 +1821,10 @@ class TestMixedIntIndex(Base, tm.TestCase):
     def test_argsort(self):
         idx = self.create_index()
         if PY36:
-            with tm.assertRaisesRegexp(TypeError, "'>' not supported"):
+            with tm.assert_raises_regex(TypeError, "'>' not supported"):
                 result = idx.argsort()
         elif PY3:
-            with tm.assertRaisesRegexp(TypeError, "unorderable types"):
+            with tm.assert_raises_regex(TypeError, "unorderable types"):
                 result = idx.argsort()
         else:
             result = idx.argsort()
@@ -1834,10 +1834,10 @@ class TestMixedIntIndex(Base, tm.TestCase):
     def test_numpy_argsort(self):
         idx = self.create_index()
         if PY36:
-            with tm.assertRaisesRegexp(TypeError, "'>' not supported"):
+            with tm.assert_raises_regex(TypeError, "'>' not supported"):
                 result = np.argsort(idx)
         elif PY3:
-            with tm.assertRaisesRegexp(TypeError, "unorderable types"):
+            with tm.assert_raises_regex(TypeError, "unorderable types"):
                 result = np.argsort(idx)
         else:
             result = np.argsort(idx)
@@ -2002,7 +2002,7 @@ class TestMixedIntIndex(Base, tm.TestCase):
         tm.assert_index_equal(nanidx.dropna(), idx)
 
         msg = "invalid how option: xxx"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             pd.Index([1, 2, 3]).dropna(how='xxx')
 
     def test_get_combined_index(self):
diff --git a/pandas/tests/indexes/test_category.py b/pandas/tests/indexes/test_category.py
index 057ea1a41..5dcd45e8c 100644
--- a/pandas/tests/indexes/test_category.py
+++ b/pandas/tests/indexes/test_category.py
@@ -373,7 +373,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
         actual = idx.get_indexer(idx)
         tm.assert_numpy_array_equal(expected, actual)
 
-        with tm.assertRaisesRegexp(ValueError, 'Invalid fill method'):
+        with tm.assert_raises_regex(ValueError, 'Invalid fill method'):
             idx.get_indexer(idx, method='invalid')
 
     def test_reindexing(self):
@@ -579,7 +579,7 @@ class TestCategoricalIndex(Base, tm.TestCase):
         self.assertTrue((ci1 == ci1.values).all())
 
         # invalid comparisons
-        with tm.assertRaisesRegexp(ValueError, "Lengths must match"):
+        with tm.assert_raises_regex(ValueError, "Lengths must match"):
             ci1 == Index(['a', 'b', 'c'])
         pytest.raises(TypeError, lambda: ci1 == ci2)
         pytest.raises(
@@ -806,8 +806,8 @@ class TestCategoricalIndex(Base, tm.TestCase):
         tm.assert_index_equal(idx.fillna(1.0), exp)
 
         # fill by value not in categories raises ValueError
-        with tm.assertRaisesRegexp(ValueError,
-                                   'fill value must be in categories'):
+        with tm.assert_raises_regex(ValueError,
+                                    'fill value must be in categories'):
             idx.fillna(2.0)
 
     def test_take_fill_value(self):
@@ -861,9 +861,9 @@ class TestCategoricalIndex(Base, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -899,9 +899,9 @@ class TestCategoricalIndex(Base, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -912,13 +912,13 @@ class TestCategoricalIndex(Base, tm.TestCase):
         indices = [1, 0, -1]
 
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, idx.take,
-                              indices, foo=2)
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, out=indices)
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
diff --git a/pandas/tests/indexes/test_interval.py b/pandas/tests/indexes/test_interval.py
index 8e020846f..ec56791a6 100644
--- a/pandas/tests/indexes/test_interval.py
+++ b/pandas/tests/indexes/test_interval.py
@@ -602,9 +602,9 @@ class TestIntervalIndex(Base, tm.TestCase):
         actual = self.index == self.index.left
         tm.assert_numpy_array_equal(actual, np.array([False, False]))
 
-        with tm.assertRaisesRegexp(TypeError, 'unorderable types'):
+        with tm.assert_raises_regex(TypeError, 'unorderable types'):
             self.index > 0
-        with tm.assertRaisesRegexp(TypeError, 'unorderable types'):
+        with tm.assert_raises_regex(TypeError, 'unorderable types'):
             self.index <= 0
         with pytest.raises(TypeError):
             self.index > np.arange(2)
diff --git a/pandas/tests/indexes/test_multi.py b/pandas/tests/indexes/test_multi.py
index 34051a974..ab403cf56 100644
--- a/pandas/tests/indexes/test_multi.py
+++ b/pandas/tests/indexes/test_multi.py
@@ -22,9 +22,7 @@ from pandas._libs.lib import Timestamp
 
 import pandas.util.testing as tm
 
-from pandas.util.testing import (assertRaisesRegexp,
-                                 assert_almost_equal, assert_copy)
-
+from pandas.util.testing import assert_almost_equal, assert_copy
 
 from .common import Base
 
@@ -61,7 +59,7 @@ class TestMultiIndex(Base, tm.TestCase):
             if common:
                 pass
 
-        tm.assertRaisesRegexp(ValueError, 'The truth value of a', f)
+        tm.assert_raises_regex(ValueError, 'The truth value of a', f)
 
     def test_labels_dtypes(self):
 
@@ -125,7 +123,8 @@ class TestMultiIndex(Base, tm.TestCase):
         tm.assert_index_equal(np.repeat(m, reps), expected)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.repeat, m, reps, axis=1)
+        tm.assert_raises_regex(
+            ValueError, msg, np.repeat, m, reps, axis=1)
 
     def test_set_name_methods(self):
         # so long as these are synonyms, we don't need to test set_names
@@ -134,7 +133,7 @@ class TestMultiIndex(Base, tm.TestCase):
         ind = self.index.set_names(new_names)
         self.assertEqual(self.index.names, self.index_names)
         self.assertEqual(ind.names, new_names)
-        with assertRaisesRegexp(ValueError, "^Length"):
+        with tm.assert_raises_regex(ValueError, "^Length"):
             ind.set_names(new_names + new_names)
         new_names2 = [name + "SUFFIX2" for name in new_names]
         res = ind.set_names(new_names2, inplace=True)
@@ -224,23 +223,23 @@ class TestMultiIndex(Base, tm.TestCase):
         # GH 13754
         original_index = self.index.copy()
         for inplace in [True, False]:
-            with assertRaisesRegexp(ValueError, "^On"):
+            with tm.assert_raises_regex(ValueError, "^On"):
                 self.index.set_levels(['c'], level=0, inplace=inplace)
             assert_matching(self.index.levels, original_index.levels,
                             check_dtype=True)
 
-            with assertRaisesRegexp(ValueError, "^On"):
+            with tm.assert_raises_regex(ValueError, "^On"):
                 self.index.set_labels([0, 1, 2, 3, 4, 5], level=0,
                                       inplace=inplace)
             assert_matching(self.index.labels, original_index.labels,
                             check_dtype=True)
 
-            with assertRaisesRegexp(TypeError, "^Levels"):
+            with tm.assert_raises_regex(TypeError, "^Levels"):
                 self.index.set_levels('c', level=0, inplace=inplace)
             assert_matching(self.index.levels, original_index.levels,
                             check_dtype=True)
 
-            with assertRaisesRegexp(TypeError, "^Labels"):
+            with tm.assert_raises_regex(TypeError, "^Labels"):
                 self.index.set_labels(1, level=0, inplace=inplace)
             assert_matching(self.index.labels, original_index.labels,
                             check_dtype=True)
@@ -313,46 +312,46 @@ class TestMultiIndex(Base, tm.TestCase):
         levels, labels = self.index.levels, self.index.labels
         names = self.index.names
 
-        with tm.assertRaisesRegexp(ValueError, 'Length of levels'):
+        with tm.assert_raises_regex(ValueError, 'Length of levels'):
             self.index.set_levels([levels[0]])
 
-        with tm.assertRaisesRegexp(ValueError, 'Length of labels'):
+        with tm.assert_raises_regex(ValueError, 'Length of labels'):
             self.index.set_labels([labels[0]])
 
-        with tm.assertRaisesRegexp(ValueError, 'Length of names'):
+        with tm.assert_raises_regex(ValueError, 'Length of names'):
             self.index.set_names([names[0]])
 
         # shouldn't scalar data error, instead should demand list-like
-        with tm.assertRaisesRegexp(TypeError, 'list of lists-like'):
+        with tm.assert_raises_regex(TypeError, 'list of lists-like'):
             self.index.set_levels(levels[0])
 
         # shouldn't scalar data error, instead should demand list-like
-        with tm.assertRaisesRegexp(TypeError, 'list of lists-like'):
+        with tm.assert_raises_regex(TypeError, 'list of lists-like'):
             self.index.set_labels(labels[0])
 
         # shouldn't scalar data error, instead should demand list-like
-        with tm.assertRaisesRegexp(TypeError, 'list-like'):
+        with tm.assert_raises_regex(TypeError, 'list-like'):
             self.index.set_names(names[0])
 
         # should have equal lengths
-        with tm.assertRaisesRegexp(TypeError, 'list of lists-like'):
+        with tm.assert_raises_regex(TypeError, 'list of lists-like'):
             self.index.set_levels(levels[0], level=[0, 1])
 
-        with tm.assertRaisesRegexp(TypeError, 'list-like'):
+        with tm.assert_raises_regex(TypeError, 'list-like'):
             self.index.set_levels(levels, level=0)
 
         # should have equal lengths
-        with tm.assertRaisesRegexp(TypeError, 'list of lists-like'):
+        with tm.assert_raises_regex(TypeError, 'list of lists-like'):
             self.index.set_labels(labels[0], level=[0, 1])
 
-        with tm.assertRaisesRegexp(TypeError, 'list-like'):
+        with tm.assert_raises_regex(TypeError, 'list-like'):
             self.index.set_labels(labels, level=0)
 
         # should have equal lengths
-        with tm.assertRaisesRegexp(ValueError, 'Length of names'):
+        with tm.assert_raises_regex(ValueError, 'Length of names'):
             self.index.set_names(names[0], level=[0, 1])
 
-        with tm.assertRaisesRegexp(TypeError, 'string'):
+        with tm.assert_raises_regex(TypeError, 'string'):
             self.index.set_names(names, level=0)
 
     def test_set_levels_categorical(self):
@@ -375,18 +374,18 @@ class TestMultiIndex(Base, tm.TestCase):
         levels, labels = self.index.levels, self.index.labels
         # shouldn't be able to set at either the top level or base level
         mutable_regex = re.compile('does not support mutable operations')
-        with assertRaisesRegexp(TypeError, mutable_regex):
+        with tm.assert_raises_regex(TypeError, mutable_regex):
             levels[0] = levels[0]
-        with assertRaisesRegexp(TypeError, mutable_regex):
+        with tm.assert_raises_regex(TypeError, mutable_regex):
             levels[0][0] = levels[0][0]
         # ditto for labels
-        with assertRaisesRegexp(TypeError, mutable_regex):
+        with tm.assert_raises_regex(TypeError, mutable_regex):
             labels[0] = labels[0]
-        with assertRaisesRegexp(TypeError, mutable_regex):
+        with tm.assert_raises_regex(TypeError, mutable_regex):
             labels[0][0] = labels[0][0]
         # and for names
         names = self.index.names
-        with assertRaisesRegexp(TypeError, mutable_regex):
+        with tm.assert_raises_regex(TypeError, mutable_regex):
             names[0] = names[0]
 
     def test_inplace_mutation_resets_values(self):
@@ -494,22 +493,23 @@ class TestMultiIndex(Base, tm.TestCase):
 
         # setting bad names on existing
         index = self.index
-        assertRaisesRegexp(ValueError, "^Length of names", setattr, index,
-                           "names", list(index.names) + ["third"])
-        assertRaisesRegexp(ValueError, "^Length of names", setattr, index,
-                           "names", [])
+        tm.assert_raises_regex(ValueError, "^Length of names",
+                               setattr, index, "names",
+                               list(index.names) + ["third"])
+        tm.assert_raises_regex(ValueError, "^Length of names",
+                               setattr, index, "names", [])
 
         # initializing with bad names (should always be equivalent)
         major_axis, minor_axis = self.index.levels
         major_labels, minor_labels = self.index.labels
-        assertRaisesRegexp(ValueError, "^Length of names", MultiIndex,
-                           levels=[major_axis, minor_axis],
-                           labels=[major_labels, minor_labels],
-                           names=['first'])
-        assertRaisesRegexp(ValueError, "^Length of names", MultiIndex,
-                           levels=[major_axis, minor_axis],
-                           labels=[major_labels, minor_labels],
-                           names=['first', 'second', 'third'])
+        tm.assert_raises_regex(ValueError, "^Length of names", MultiIndex,
+                               levels=[major_axis, minor_axis],
+                               labels=[major_labels, minor_labels],
+                               names=['first'])
+        tm.assert_raises_regex(ValueError, "^Length of names", MultiIndex,
+                               levels=[major_axis, minor_axis],
+                               labels=[major_labels, minor_labels],
+                               names=['first', 'second', 'third'])
 
         # names are assigned
         index.names = ["a", "b"]
@@ -533,7 +533,7 @@ class TestMultiIndex(Base, tm.TestCase):
         assert_copy(actual.labels, expected.labels)
         self.check_level_names(actual, expected.names)
 
-        with assertRaisesRegexp(TypeError, "^Setting.*dtype.*object"):
+        with tm.assert_raises_regex(TypeError, "^Setting.*dtype.*object"):
             self.index.astype(np.dtype(int))
 
     def test_constructor_single_level(self):
@@ -548,46 +548,47 @@ class TestMultiIndex(Base, tm.TestCase):
         assert single_level.name is None
 
     def test_constructor_no_levels(self):
-        tm.assertRaisesRegexp(ValueError, "non-zero number of levels/labels",
-                              MultiIndex, levels=[], labels=[])
+        tm.assert_raises_regex(ValueError, "non-zero number "
+                               "of levels/labels",
+                               MultiIndex, levels=[], labels=[])
         both_re = re.compile('Must pass both levels and labels')
-        with tm.assertRaisesRegexp(TypeError, both_re):
+        with tm.assert_raises_regex(TypeError, both_re):
             MultiIndex(levels=[])
-        with tm.assertRaisesRegexp(TypeError, both_re):
+        with tm.assert_raises_regex(TypeError, both_re):
             MultiIndex(labels=[])
 
     def test_constructor_mismatched_label_levels(self):
         labels = [np.array([1]), np.array([2]), np.array([3])]
         levels = ["a"]
-        assertRaisesRegexp(ValueError, "Length of levels and labels must be"
-                           " the same", MultiIndex, levels=levels,
-                           labels=labels)
+        tm.assert_raises_regex(ValueError, "Length of levels and labels "
+                               "must be the same", MultiIndex,
+                               levels=levels, labels=labels)
         length_error = re.compile('>= length of level')
         label_error = re.compile(r'Unequal label lengths: \[4, 2\]')
 
         # important to check that it's looking at the right thing.
-        with tm.assertRaisesRegexp(ValueError, length_error):
+        with tm.assert_raises_regex(ValueError, length_error):
             MultiIndex(levels=[['a'], ['b']],
                        labels=[[0, 1, 2, 3], [0, 3, 4, 1]])
 
-        with tm.assertRaisesRegexp(ValueError, label_error):
+        with tm.assert_raises_regex(ValueError, label_error):
             MultiIndex(levels=[['a'], ['b']], labels=[[0, 0, 0, 0], [0, 0]])
 
         # external API
-        with tm.assertRaisesRegexp(ValueError, length_error):
+        with tm.assert_raises_regex(ValueError, length_error):
             self.index.copy().set_levels([['a'], ['b']])
 
-        with tm.assertRaisesRegexp(ValueError, label_error):
+        with tm.assert_raises_regex(ValueError, label_error):
             self.index.copy().set_labels([[0, 0, 0, 0], [0, 0]])
 
         # deprecated properties
         with warnings.catch_warnings():
             warnings.simplefilter('ignore')
 
-            with tm.assertRaisesRegexp(ValueError, length_error):
+            with tm.assert_raises_regex(ValueError, length_error):
                 self.index.copy().levels = [['a'], ['b']]
 
-            with tm.assertRaisesRegexp(ValueError, label_error):
+            with tm.assert_raises_regex(ValueError, label_error):
                 self.index.copy().labels = [[0, 0, 0, 0], [0, 0]]
 
     def assert_multiindex_copied(self, copy, original):
@@ -650,16 +651,16 @@ class TestMultiIndex(Base, tm.TestCase):
 
     def test_duplicate_names(self):
         self.index.names = ['foo', 'foo']
-        assertRaisesRegexp(KeyError, 'Level foo not found',
-                           self.index._get_level_number, 'foo')
+        tm.assert_raises_regex(KeyError, 'Level foo not found',
+                               self.index._get_level_number, 'foo')
 
     def test_get_level_number_integer(self):
         self.index.names = [1, 0]
         self.assertEqual(self.index._get_level_number(1), 0)
         self.assertEqual(self.index._get_level_number(0), 1)
         pytest.raises(IndexError, self.index._get_level_number, 2)
-        assertRaisesRegexp(KeyError, 'Level fourth not found',
-                           self.index._get_level_number, 'fourth')
+        tm.assert_raises_regex(KeyError, 'Level fourth not found',
+                               self.index._get_level_number, 'fourth')
 
     def test_from_arrays(self):
         arrays = []
@@ -762,7 +763,7 @@ class TestMultiIndex(Base, tm.TestCase):
 
     def test_from_arrays_empty(self):
         # 0 levels
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 ValueError, "Must pass non-zero number of levels/labels"):
             MultiIndex.from_arrays(arrays=[])
 
@@ -787,21 +788,24 @@ class TestMultiIndex(Base, tm.TestCase):
             pytest.raises(TypeError, MultiIndex.from_arrays, arrays=i)
 
     def test_from_arrays_different_lengths(self):
-        # GH13599
+        # see gh-13599
         idx1 = [1, 2, 3]
         idx2 = ['a', 'b']
-        assertRaisesRegexp(ValueError, '^all arrays must be same length$',
-                           MultiIndex.from_arrays, [idx1, idx2])
+        tm.assert_raises_regex(ValueError, '^all arrays must '
+                               'be same length$',
+                               MultiIndex.from_arrays, [idx1, idx2])
 
         idx1 = []
         idx2 = ['a', 'b']
-        assertRaisesRegexp(ValueError, '^all arrays must be same length$',
-                           MultiIndex.from_arrays, [idx1, idx2])
+        tm.assert_raises_regex(ValueError, '^all arrays must '
+                               'be same length$',
+                               MultiIndex.from_arrays, [idx1, idx2])
 
         idx1 = [1, 2, 3]
         idx2 = []
-        assertRaisesRegexp(ValueError, '^all arrays must be same length$',
-                           MultiIndex.from_arrays, [idx1, idx2])
+        tm.assert_raises_regex(ValueError, '^all arrays must '
+                               'be same length$',
+                               MultiIndex.from_arrays, [idx1, idx2])
 
     def test_from_product(self):
 
@@ -820,7 +824,7 @@ class TestMultiIndex(Base, tm.TestCase):
 
     def test_from_product_empty(self):
         # 0 levels
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 ValueError, "Must pass non-zero number of levels/labels"):
             MultiIndex.from_product([])
 
@@ -990,8 +994,8 @@ class TestMultiIndex(Base, tm.TestCase):
 
     def test_reorder_levels(self):
         # this blows up
-        assertRaisesRegexp(IndexError, '^Too many levels',
-                           self.index.reorder_levels, [2, 1, 0])
+        tm.assert_raises_regex(IndexError, '^Too many levels',
+                               self.index.reorder_levels, [2, 1, 0])
 
     def test_nlevels(self):
         self.assertEqual(self.index.nlevels, 2)
@@ -1189,17 +1193,19 @@ class TestMultiIndex(Base, tm.TestCase):
         df = tm.makeTimeDataFrame()
         stacked = df.stack()
         idx = stacked.index
-        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs,
-                           (1, 3))
-        assertRaisesRegexp(TypeError, '^Level type mismatch', idx.slice_locs,
-                           df.index[5] + timedelta(seconds=30), (5, 2))
+        tm.assert_raises_regex(TypeError, '^Level type mismatch',
+                               idx.slice_locs, (1, 3))
+        tm.assert_raises_regex(TypeError, '^Level type mismatch',
+                               idx.slice_locs,
+                               df.index[5] + timedelta(
+                                   seconds=30), (5, 2))
         df = tm.makeCustomDataframe(5, 5)
         stacked = df.stack()
         idx = stacked.index
-        with assertRaisesRegexp(TypeError, '^Level type mismatch'):
+        with tm.assert_raises_regex(TypeError, '^Level type mismatch'):
             idx.slice_locs(timedelta(seconds=30))
         # TODO: Try creating a UnicodeDecodeError in exception message
-        with assertRaisesRegexp(TypeError, '^Level type mismatch'):
+        with tm.assert_raises_regex(TypeError, '^Level type mismatch'):
             idx.slice_locs(df.index[1], (16, "a"))
 
     def test_slice_locs_not_sorted(self):
@@ -1207,9 +1213,9 @@ class TestMultiIndex(Base, tm.TestCase):
             lrange(4))], labels=[np.array([0, 0, 1, 2, 2, 2, 3, 3]), np.array(
                 [0, 1, 0, 0, 0, 1, 0, 1]), np.array([1, 0, 1, 1, 0, 0, 1, 0])])
 
-        assertRaisesRegexp(KeyError, "[Kk]ey length.*greater than MultiIndex"
-                           " lexsort depth", index.slice_locs, (1, 0, 1),
-                           (2, 1, 0))
+        tm.assert_raises_regex(KeyError, "[Kk]ey length.*greater than "
+                               "MultiIndex lexsort depth",
+                               index.slice_locs, (1, 0, 1), (2, 1, 0))
 
         # works
         sorted_index, _ = index.sortlevel(0)
@@ -1348,7 +1354,7 @@ class TestMultiIndex(Base, tm.TestCase):
         idx2 = Index(lrange(20))
 
         msg = "Reindexing only valid with uniquely valued Index objects"
-        with assertRaisesRegexp(InvalidIndexError, msg):
+        with tm.assert_raises_regex(InvalidIndexError, msg):
             idx1.get_indexer(idx2)
 
     def test_get_indexer_nearest(self):
@@ -1695,12 +1701,14 @@ class TestMultiIndex(Base, tm.TestCase):
             'foo', 'two'), ('qux', 'one'), ('qux', 'two')])
         expected.names = first.names
         self.assertEqual(first.names, result.names)
-        assertRaisesRegexp(TypeError, "other must be a MultiIndex or a list"
-                           " of tuples", first.difference, [1, 2, 3, 4, 5])
+        tm.assert_raises_regex(TypeError, "other must be a MultiIndex "
+                               "or a list of tuples",
+                               first.difference, [1, 2, 3, 4, 5])
 
     def test_from_tuples(self):
-        assertRaisesRegexp(TypeError, 'Cannot infer number of levels from'
-                           ' empty list', MultiIndex.from_tuples, [])
+        tm.assert_raises_regex(TypeError, 'Cannot infer number of levels '
+                               'from empty list',
+                               MultiIndex.from_tuples, [])
 
         idx = MultiIndex.from_tuples(((1, 2), (3, 4)), names=['a', 'b'])
         self.assertEqual(len(idx), 2)
@@ -1880,7 +1888,7 @@ class TestMultiIndex(Base, tm.TestCase):
 
         # key wrong length
         msg = "Item must have length equal to number of levels"
-        with assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.index.insert(0, ('foo2', ))
 
         left = pd.DataFrame([['a', 'b', 0], ['b', 'd', 1]],
@@ -1964,9 +1972,9 @@ class TestMultiIndex(Base, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -1979,16 +1987,16 @@ class TestMultiIndex(Base, tm.TestCase):
         indices = [1, 2]
 
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, idx.take,
-                              indices, foo=2)
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, out=indices)
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
 
     def test_join_level(self):
         def _check_how(other, how):
@@ -2031,8 +2039,8 @@ class TestMultiIndex(Base, tm.TestCase):
         result = idx.join(self.index, level='second')
         assert isinstance(result, MultiIndex)
 
-        assertRaisesRegexp(TypeError, "Join.*MultiIndex.*ambiguous",
-                           self.index.join, self.index, level=1)
+        tm.assert_raises_regex(TypeError, "Join.*MultiIndex.*ambiguous",
+                               self.index.join, self.index, level=1)
 
     def test_join_self(self):
         kinds = 'outer', 'inner', 'left', 'right'
@@ -2102,12 +2110,13 @@ class TestMultiIndex(Base, tm.TestCase):
         exp_indexer2 = np.array([0, -1, 0, -1, 0, -1])
         tm.assert_numpy_array_equal(indexer2, exp_indexer2, check_dtype=False)
 
-        assertRaisesRegexp(TypeError, "Fill method not supported",
-                           self.index.reindex, self.index, method='pad',
-                           level='second')
+        tm.assert_raises_regex(TypeError, "Fill method not supported",
+                               self.index.reindex, self.index,
+                               method='pad', level='second')
 
-        assertRaisesRegexp(TypeError, "Fill method not supported", idx.reindex,
-                           idx, method='bfill', level='first')
+        tm.assert_raises_regex(TypeError, "Fill method not supported",
+                               idx.reindex, idx, method='bfill',
+                               level='first')
 
     def test_duplicates(self):
         self.assertFalse(self.index.has_duplicates)
@@ -2760,7 +2769,7 @@ class TestMultiIndex(Base, tm.TestCase):
         tm.assert_index_equal(idx.dropna(how='all'), exp)
 
         msg = "invalid how option: xxx"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.dropna(how='xxx')
 
     def test_unsortedindex(self):
diff --git a/pandas/tests/indexes/test_numeric.py b/pandas/tests/indexes/test_numeric.py
index f0c42a3da..8a46da375 100644
--- a/pandas/tests/indexes/test_numeric.py
+++ b/pandas/tests/indexes/test_numeric.py
@@ -349,7 +349,7 @@ class TestFloat64Index(Numeric, tm.TestCase):
         pytest.raises(KeyError, idx.get_loc, 1.5, method='pad',
                       tolerance=0.1)
 
-        with tm.assertRaisesRegexp(ValueError, 'must be numeric'):
+        with tm.assert_raises_regex(ValueError, 'must be numeric'):
             idx.get_loc(1.4, method='nearest', tolerance='foo')
 
     def test_get_loc_na(self):
@@ -438,9 +438,9 @@ class TestFloat64Index(Numeric, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -566,7 +566,7 @@ class NumericInt(Numeric):
                "{name} cannot contain NA").format(name=name)
 
         # fill_value=True
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -1]), fill_value=True)
 
         # allow_fill=False
@@ -575,9 +575,9 @@ class NumericInt(Numeric):
         expected = self._holder([2, 1, 3], name='xxx')
         tm.assert_index_equal(result, expected)
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -672,11 +672,11 @@ class TestInt64Index(NumericInt, tm.TestCase):
 
         # preventing casting
         arr = np.array([1, '2', 3, '4'], dtype=object)
-        with tm.assertRaisesRegexp(TypeError, 'casting'):
+        with tm.assert_raises_regex(TypeError, 'casting'):
             Int64Index(arr)
 
         arr_with_floats = [0, 2, 3, 4, 5, 1.25, 3, -1]
-        with tm.assertRaisesRegexp(TypeError, 'casting'):
+        with tm.assert_raises_regex(TypeError, 'casting'):
             Int64Index(arr_with_floats)
 
     def test_coerce_list(self):
diff --git a/pandas/tests/indexes/test_range.py b/pandas/tests/indexes/test_range.py
index 6f87687f8..c3ffb32c3 100644
--- a/pandas/tests/indexes/test_range.py
+++ b/pandas/tests/indexes/test_range.py
@@ -12,7 +12,6 @@ import numpy as np
 
 from pandas import (notnull, Series, Index, Float64Index,
                     Int64Index, RangeIndex)
-from pandas.util.testing import assertRaisesRegexp
 
 import pandas.util.testing as tm
 
@@ -65,7 +64,7 @@ class TestRangeIndex(Numeric, tm.TestCase):
         def testit():
             self.index.names = ["roger", "harold"]
 
-        assertRaisesRegexp(ValueError, "^Length", testit)
+        tm.assert_raises_regex(ValueError, "^Length", testit)
 
     def test_constructor(self):
         index = RangeIndex(5)
@@ -90,7 +89,7 @@ class TestRangeIndex(Numeric, tm.TestCase):
         tm.assert_index_equal(Index(expected), index)
 
         msg = "RangeIndex\\(\\.\\.\\.\\) must be called with integers"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             RangeIndex()
 
         for index in [RangeIndex(0), RangeIndex(start=0), RangeIndex(stop=0),
@@ -102,7 +101,7 @@ class TestRangeIndex(Numeric, tm.TestCase):
             self.assertEqual(index._step, 1)
             tm.assert_index_equal(Index(expected), index)
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             RangeIndex(name='Foo')
 
         for index in [RangeIndex(0, name='Foo'),
@@ -724,7 +723,7 @@ class TestRangeIndex(Numeric, tm.TestCase):
 
         # fill_value
         msg = "Unable to fill values because RangeIndex cannot contain NA"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -1]), fill_value=True)
 
         # allow_fill=False
@@ -734,9 +733,9 @@ class TestRangeIndex(Numeric, tm.TestCase):
         tm.assert_index_equal(result, expected)
 
         msg = "Unable to fill values because RangeIndex cannot contain NA"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index da23f8698..c3cc05271 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -87,16 +87,18 @@ class TestTimedeltaIndexOps(Ops):
         self.assertEqual(np.max(td), Timedelta('16820 days'))
 
         errmsg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, errmsg, np.min, td, out=0)
-        tm.assertRaisesRegexp(ValueError, errmsg, np.max, td, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.min, td, out=0)
+        tm.assert_raises_regex(ValueError, errmsg, np.max, td, out=0)
 
         self.assertEqual(np.argmin(td), 0)
         self.assertEqual(np.argmax(td), 5)
 
         if not _np_version_under1p10:
             errmsg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmin, td, out=0)
-            tm.assertRaisesRegexp(ValueError, errmsg, np.argmax, td, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmin, td, out=0)
+            tm.assert_raises_regex(
+                ValueError, errmsg, np.argmax, td, out=0)
 
     def test_round(self):
         td = pd.timedelta_range(start='16801 days', periods=5, freq='30Min')
@@ -115,14 +117,14 @@ class TestTimedeltaIndexOps(Ops):
         self.assertEqual(elt.round(freq='H'), expected_elt)
 
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             td.round(freq='foo')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             elt.round(freq='foo')
 
         msg = "<MonthEnd> is a non-fixed frequency"
-        tm.assertRaisesRegexp(ValueError, msg, td.round, freq='M')
-        tm.assertRaisesRegexp(ValueError, msg, elt.round, freq='M')
+        tm.assert_raises_regex(ValueError, msg, td.round, freq='M')
+        tm.assert_raises_regex(ValueError, msg, elt.round, freq='M')
 
     def test_representation(self):
         idx1 = TimedeltaIndex([], freq='D')
@@ -262,7 +264,7 @@ Freq: D"""
 
         idx = TimedeltaIndex(['1 day', '2 day'])
         msg = "cannot subtract a datelike from a TimedeltaIndex"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             idx - Timestamp('2011-01-01')
 
         result = Timestamp('2011-01-01') + idx
@@ -497,7 +499,7 @@ Freq: D"""
 
     def test_comp_nat(self):
         left = pd.TimedeltaIndex([pd.Timedelta('1 days'), pd.NaT,
-                                 pd.Timedelta('3 days')])
+                                  pd.Timedelta('3 days')])
         right = pd.TimedeltaIndex([pd.NaT, pd.NaT, pd.Timedelta('3 days')])
 
         for l, r in [(left, right), (left.asobject, right.asobject)]:
@@ -751,16 +753,16 @@ Freq: D"""
         indices = [1, 6, 5, 9, 10, 13, 15, 3]
 
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, idx.take,
-                              indices, foo=2)
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, out=indices)
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, idx.take,
-                              indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
 
     def test_infer_freq(self):
         # GH 11018
@@ -1248,22 +1250,22 @@ class TestSlicing(tm.TestCase):
     def test_add_overflow(self):
         # see gh-14068
         msg = "too (big|large) to convert"
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             to_timedelta(106580, 'D') + Timestamp('2000')
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             Timestamp('2000') + to_timedelta(106580, 'D')
 
         _NaT = int(pd.NaT) + 1
         msg = "Overflow in int64 addition"
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             to_timedelta([106580], 'D') + Timestamp('2000')
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             Timestamp('2000') + to_timedelta([106580], 'D')
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             to_timedelta([_NaT]) - Timedelta('1 days')
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             to_timedelta(['5 days', _NaT]) - Timedelta('1 days')
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             (to_timedelta([_NaT, '5 days', '1 hours']) -
              to_timedelta(['7 seconds', _NaT, '4 hours']))
 
diff --git a/pandas/tests/indexes/timedeltas/test_partial_slicing.py b/pandas/tests/indexes/timedeltas/test_partial_slicing.py
index ccb9a7f18..230dbe91b 100644
--- a/pandas/tests/indexes/timedeltas/test_partial_slicing.py
+++ b/pandas/tests/indexes/timedeltas/test_partial_slicing.py
@@ -75,9 +75,9 @@ class TestSlicing(tm.TestCase):
 
     def test_slice_with_zero_step_raises(self):
         ts = Series(np.arange(20), timedelta_range('0', periods=20, freq='H'))
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: ts.loc[::0])
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index b93f76c14..b5bdf0311 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -59,7 +59,7 @@ class TestTimedeltaIndex(DatetimeLike, tm.TestCase):
             idx.get_loc(idx[1], 'pad', tolerance=np.timedelta64(0, 's')), 1)
         self.assertEqual(idx.get_loc(idx[1], 'pad', tolerance=timedelta(0)), 1)
 
-        with tm.assertRaisesRegexp(ValueError, 'must be convertible'):
+        with tm.assert_raises_regex(ValueError, 'must be convertible'):
             idx.get_loc(idx[1], method='nearest', tolerance='foo')
 
         for method, loc in [('pad', 1), ('backfill', 2), ('nearest', 1)]:
@@ -235,9 +235,9 @@ class TestTimedeltaIndex(DatetimeLike, tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             idx.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -461,8 +461,8 @@ class TestTimedeltaIndex(DatetimeLike, tm.TestCase):
 
     def test_hash_error(self):
         index = timedelta_range('1 days', periods=10)
-        with tm.assertRaisesRegexp(TypeError, "unhashable type: %r" %
-                                   type(index).__name__):
+        with tm.assert_raises_regex(TypeError, "unhashable type: %r" %
+                                    type(index).__name__):
             hash(index)
 
     def test_append_join_nondatetimeindex(self):
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta_range.py b/pandas/tests/indexes/timedeltas/test_timedelta_range.py
index 8bd56b588..55f16c10e 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta_range.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta_range.py
@@ -37,10 +37,10 @@ class TestTimedeltas(tm.TestCase):
         arr = np.arange(10).reshape(2, 5)
         df = pd.DataFrame(np.arange(10).reshape(2, 5))
         for arg in (arr, df):
-            with tm.assertRaisesRegexp(TypeError, "1-d array"):
+            with tm.assert_raises_regex(TypeError, "1-d array"):
                 to_timedelta(arg)
             for errors in ['ignore', 'raise', 'coerce']:
-                with tm.assertRaisesRegexp(TypeError, "1-d array"):
+                with tm.assert_raises_regex(TypeError, "1-d array"):
                     to_timedelta(arg, errors=errors)
 
         # issue10583
diff --git a/pandas/tests/indexes/timedeltas/test_tools.py b/pandas/tests/indexes/timedeltas/test_tools.py
index b4f6f33a6..12ed8a2e3 100644
--- a/pandas/tests/indexes/timedeltas/test_tools.py
+++ b/pandas/tests/indexes/timedeltas/test_tools.py
@@ -113,8 +113,8 @@ class TestTimedeltas(tm.TestCase):
 
         # bad value for errors parameter
         msg = "errors must be one of"
-        tm.assertRaisesRegexp(ValueError, msg, to_timedelta,
-                              ['foo'], errors='never')
+        tm.assert_raises_regex(ValueError, msg, to_timedelta,
+                               ['foo'], errors='never')
 
         # these will error
         pytest.raises(ValueError, lambda: to_timedelta([1, 2], unit='foo'))
diff --git a/pandas/tests/indexing/test_categorical.py b/pandas/tests/indexing/test_categorical.py
index e0f95a1fd..f9fcef16c 100644
--- a/pandas/tests/indexing/test_categorical.py
+++ b/pandas/tests/indexing/test_categorical.py
@@ -135,7 +135,7 @@ class TestCategoricalIndex(tm.TestCase):
         exp = DataFrame({'A': [1, 1, 2], 'B': [4, 4, 5]}, index=exp_index)
         tm.assert_frame_equal(res, exp, check_index_type=True)
 
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 KeyError,
                 'a list-indexer must only include values that are '
                 'in the categories'):
@@ -160,7 +160,7 @@ class TestCategoricalIndex(tm.TestCase):
                    ]}, index=CategoricalIndex(['a', 'a', 'a', 'a', 'b']))
         tm.assert_frame_equal(res, exp, check_index_type=True)
 
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 KeyError,
                 'a list-indexer must only include values '
                 'that are in the categories'):
@@ -190,7 +190,7 @@ class TestCategoricalIndex(tm.TestCase):
                                                categories=list('abcde')))
         tm.assert_frame_equal(res, exp, check_index_type=True)
 
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 KeyError,
                 'a list-indexer must only include values '
                 'that are in the categories'):
diff --git a/pandas/tests/indexing/test_coercion.py b/pandas/tests/indexing/test_coercion.py
index 15a56d97e..b8030d84e 100644
--- a/pandas/tests/indexing/test_coercion.py
+++ b/pandas/tests/indexing/test_coercion.py
@@ -423,12 +423,12 @@ class TestInsertIndexCoercion(CoercionBase, tm.TestCase):
 
         # ToDo: must coerce to object
         msg = "Passed item and index have different timezone"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             obj.insert(1, pd.Timestamp('2012-01-01', tz='US/Eastern'))
 
         # ToDo: must coerce to object
         msg = "cannot insert DatetimeIndex with incompatible label"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.insert(1, 1)
 
     def test_insert_index_datetime64tz(self):
@@ -445,17 +445,17 @@ class TestInsertIndexCoercion(CoercionBase, tm.TestCase):
 
         # ToDo: must coerce to object
         msg = "Passed item and index have different timezone"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             obj.insert(1, pd.Timestamp('2012-01-01'))
 
         # ToDo: must coerce to object
         msg = "Passed item and index have different timezone"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             obj.insert(1, pd.Timestamp('2012-01-01', tz='Asia/Tokyo'))
 
         # ToDo: must coerce to object
         msg = "cannot insert DatetimeIndex with incompatible label"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.insert(1, 1)
 
     def test_insert_index_timedelta64(self):
@@ -469,12 +469,12 @@ class TestInsertIndexCoercion(CoercionBase, tm.TestCase):
 
         # ToDo: must coerce to object
         msg = "cannot insert TimedeltaIndex with incompatible label"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.insert(1, pd.Timestamp('2012-01-01'))
 
         # ToDo: must coerce to object
         msg = "cannot insert TimedeltaIndex with incompatible label"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.insert(1, 1)
 
     def test_insert_index_period(self):
@@ -778,7 +778,7 @@ class TestWhereCoercion(CoercionBase, tm.TestCase):
 
         # ToDo: coerce to object
         msg = "cannot coerce a Timestamp with a tz on a naive Block"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.where(cond, pd.Timestamp('2012-01-01', tz='US/Eastern'))
 
         # ToDo: do not coerce to UTC, must be object
@@ -819,7 +819,7 @@ class TestWhereCoercion(CoercionBase, tm.TestCase):
         # ToDo: coerce to object
         msg = ("Index\\(\\.\\.\\.\\) must be called with a collection "
                "of some kind")
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             obj.where(cond, pd.Timestamp('2012-01-01', tz='US/Eastern'))
 
         # ToDo: do not ignore timezone, must be object
diff --git a/pandas/tests/indexing/test_floats.py b/pandas/tests/indexing/test_floats.py
index 02df4de01..bdee41acb 100644
--- a/pandas/tests/indexing/test_floats.py
+++ b/pandas/tests/indexing/test_floats.py
@@ -48,9 +48,9 @@ class TestFloatIndexers(tm.TestCase):
 
             def f():
                 s.iloc[3.0]
-            tm.assertRaisesRegexp(TypeError,
-                                  'cannot do positional indexing',
-                                  f)
+            tm.assert_raises_regex(TypeError,
+                                   'cannot do positional indexing',
+                                   f)
 
             def f():
                 s.iloc[3.0] = 0
diff --git a/pandas/tests/indexing/test_iloc.py b/pandas/tests/indexing/test_iloc.py
index 174026a00..18b169559 100644
--- a/pandas/tests/indexing/test_iloc.py
+++ b/pandas/tests/indexing/test_iloc.py
@@ -22,8 +22,9 @@ class TestiLoc(Base, tm.TestCase):
         expected = df
 
         # lists of positions should raise IndexErrror!
-        with tm.assertRaisesRegexp(IndexError,
-                                   'positional indexers are out-of-bounds'):
+        with tm.assert_raises_regex(IndexError,
+                                    'positional indexers '
+                                    'are out-of-bounds'):
             df.iloc[:, [0, 1, 2, 3, 4, 5]]
         pytest.raises(IndexError, lambda: df.iloc[[1, 30]])
         pytest.raises(IndexError, lambda: df.iloc[[1, -30]])
@@ -35,14 +36,14 @@ class TestiLoc(Base, tm.TestCase):
 
         # still raise on a single indexer
         msg = 'single positional indexer is out-of-bounds'
-        with tm.assertRaisesRegexp(IndexError, msg):
+        with tm.assert_raises_regex(IndexError, msg):
             df.iloc[30]
         pytest.raises(IndexError, lambda: df.iloc[-30])
 
         # GH10779
         # single positive/negative indexer exceeding Series bounds should raise
         # an IndexError
-        with tm.assertRaisesRegexp(IndexError, msg):
+        with tm.assert_raises_regex(IndexError, msg):
             s.iloc[30]
         pytest.raises(IndexError, lambda: s.iloc[-30])
 
diff --git a/pandas/tests/indexing/test_indexing.py b/pandas/tests/indexing/test_indexing.py
index f7a9c9fe5..f8a7c57ad 100644
--- a/pandas/tests/indexing/test_indexing.py
+++ b/pandas/tests/indexing/test_indexing.py
@@ -716,13 +716,14 @@ class TestMisc(Base, tm.TestCase):
 
     def test_slice_with_zero_step_raises(self):
         s = Series(np.arange(20), index=_mklbl('A', 20))
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: s[::0])
-        tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                              lambda: s.loc[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: s[::0])
+        tm.assert_raises_regex(ValueError, 'slice step cannot be zero',
+                               lambda: s.loc[::0])
         with catch_warnings(record=True):
-            tm.assertRaisesRegexp(ValueError, 'slice step cannot be zero',
-                                  lambda: s.ix[::0])
+            tm.assert_raises_regex(ValueError,
+                                   'slice step cannot be zero',
+                                   lambda: s.ix[::0])
 
     def test_indexing_assignment_dict_already_exists(self):
         df = pd.DataFrame({'x': [1, 2, 6],
diff --git a/pandas/tests/indexing/test_multiindex.py b/pandas/tests/indexing/test_multiindex.py
index 18cb9a3a0..a85c6bb44 100644
--- a/pandas/tests/indexing/test_multiindex.py
+++ b/pandas/tests/indexing/test_multiindex.py
@@ -294,9 +294,9 @@ class TestMultiIndexBasic(tm.TestCase):
         tm.assert_frame_equal(result, expected)
 
         # missing item:
-        with tm.assertRaisesRegexp(KeyError, '1'):
+        with tm.assert_raises_regex(KeyError, '1'):
             df[1]
-        with tm.assertRaisesRegexp(KeyError, "'\[1\] not in index'"):
+        with tm.assert_raises_regex(KeyError, "'\[1\] not in index'"):
             df[[1]]
 
     def test_loc_multiindex_indexer_none(self):
@@ -801,7 +801,7 @@ class TestMultiIndexSlicers(tm.TestCase):
         self.assertEqual(df.index.lexsort_depth, 2)
         df = df.sort_index(level=1, axis=0)
         self.assertEqual(df.index.lexsort_depth, 0)
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 UnsortedIndexError,
                 'MultiIndex Slicing requires the index to be fully '
                 r'lexsorted tuple len \(2\), lexsort depth \(0\)'):
diff --git a/pandas/tests/indexing/test_scalar.py b/pandas/tests/indexing/test_scalar.py
index a583bf1c5..70c7eaf74 100644
--- a/pandas/tests/indexing/test_scalar.py
+++ b/pandas/tests/indexing/test_scalar.py
@@ -154,8 +154,8 @@ class TestScalar(Base, tm.TestCase):
         df.columns = ['x', 'x', 'z']
 
         # Check that we get the correct value in the KeyError
-        tm.assertRaisesRegexp(KeyError, r"\['y'\] not in index",
-                              lambda: df[['x', 'y', 'z']])
+        tm.assert_raises_regex(KeyError, r"\['y'\] not in index",
+                               lambda: df[['x', 'y', 'z']])
 
     def test_at_with_tz(self):
         # gh-15822
diff --git a/pandas/tests/io/formats/test_to_csv.py b/pandas/tests/io/formats/test_to_csv.py
index 51295fd75..02c73019b 100644
--- a/pandas/tests/io/formats/test_to_csv.py
+++ b/pandas/tests/io/formats/test_to_csv.py
@@ -31,7 +31,7 @@ $1$,$2$
                 self.assertEqual(f.read(), expected)
 
         with tm.ensure_clean('test.csv') as path:
-            with tm.assertRaisesRegexp(TypeError, 'quotechar'):
+            with tm.assert_raises_regex(TypeError, 'quotechar'):
                 df.to_csv(path, quoting=1, quotechar=None)
 
     def test_to_csv_doublequote(self):
@@ -49,7 +49,7 @@ $1$,$2$
 
         from _csv import Error
         with tm.ensure_clean('test.csv') as path:
-            with tm.assertRaisesRegexp(Error, 'escapechar'):
+            with tm.assert_raises_regex(Error, 'escapechar'):
                 df.to_csv(path, doublequote=False)  # no escapechar set
 
     def test_to_csv_escapechar(self):
diff --git a/pandas/tests/io/json/test_pandas.py b/pandas/tests/io/json/test_pandas.py
index a8ea76ff9..0dfae0fb8 100644
--- a/pandas/tests/io/json/test_pandas.py
+++ b/pandas/tests/io/json/test_pandas.py
@@ -342,7 +342,8 @@ class TestPandasContainer(tm.TestCase):
         json = StringIO('{"badkey":["A","B"],'
                         '"index":["2","3"],'
                         '"data":[[1.0,"1"],[2.0,"2"],[null,"3"]]}')
-        with tm.assertRaisesRegexp(ValueError, r"unexpected key\(s\): badkey"):
+        with tm.assert_raises_regex(ValueError,
+                                    r"unexpected key\(s\): badkey"):
             read_json(json, orient="split")
 
     def test_frame_from_json_nones(self):
@@ -783,7 +784,7 @@ class TestPandasContainer(tm.TestCase):
 DataFrame\\.index values are different \\(100\\.0 %\\)
 \\[left\\]:  Index\\(\\[u?'a', u?'b'\\], dtype='object'\\)
 \\[right\\]: RangeIndex\\(start=0, stop=2, step=1\\)"""
-        with tm.assertRaisesRegexp(AssertionError, error_msg):
+        with tm.assert_raises_regex(AssertionError, error_msg):
             assert_frame_equal(result, expected, check_index_type=False)
 
         result = read_json('[{"a": 1, "b": 2}, {"b":2, "a" :1}]')
@@ -1036,7 +1037,7 @@ DataFrame\\.index values are different \\(100\\.0 %\\)
 
     def test_latin_encoding(self):
         if compat.PY2:
-            tm.assertRaisesRegexp(
+            tm.assert_raises_regex(
                 TypeError, r'\[unicode\] is not implemented as a table column')
             return
 
diff --git a/pandas/tests/io/json/test_ujson.py b/pandas/tests/io/json/test_ujson.py
index f0ccce583..037e47bfc 100644
--- a/pandas/tests/io/json/test_ujson.py
+++ b/pandas/tests/io/json/test_ujson.py
@@ -923,7 +923,7 @@ class UltraJSONTests(TestCase):
 
         def my_handler_raises(obj):
             raise TypeError("I raise for anything")
-        with tm.assertRaisesRegexp(TypeError, "I raise for anything"):
+        with tm.assert_raises_regex(TypeError, "I raise for anything"):
             ujson.encode(_TestObject("foo"), default_handler=my_handler_raises)
 
         def my_int_handler(obj):
diff --git a/pandas/tests/io/parser/c_parser_only.py b/pandas/tests/io/parser/c_parser_only.py
index f4ca632e0..7ce8c6177 100644
--- a/pandas/tests/io/parser/c_parser_only.py
+++ b/pandas/tests/io/parser/c_parser_only.py
@@ -96,7 +96,7 @@ nan 2
 3.0 3
 """
         # fallback casting, but not castable
-        with tm.assertRaisesRegexp(ValueError, 'cannot safely convert'):
+        with tm.assert_raises_regex(ValueError, 'cannot safely convert'):
             self.read_csv(StringIO(data), sep=r'\s+', header=None,
                           names=['a', 'b'], dtype={'a': np.int32})
 
diff --git a/pandas/tests/io/parser/common.py b/pandas/tests/io/parser/common.py
index deeeaef63..9abd3c5bf 100644
--- a/pandas/tests/io/parser/common.py
+++ b/pandas/tests/io/parser/common.py
@@ -44,7 +44,7 @@ bar2,12,13,14,15
 """
         # Parsers support only length-1 decimals
         msg = 'Only length-1 decimal markers supported'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(data), decimal='')
 
     def test_bad_stream_exception(self):
@@ -64,7 +64,7 @@ bar2,12,13,14,15
             msg = "'utf-8' codec can't decode byte"
         else:
             msg = "'utf8' codec can't decode byte"
-        with tm.assertRaisesRegexp(UnicodeDecodeError, msg):
+        with tm.assert_raises_regex(UnicodeDecodeError, msg):
             self.read_csv(stream)
         stream.close()
 
@@ -126,7 +126,7 @@ A,B,C
 2,3,4
 """
         msg = 'Expected 3 fields in line 4, saw 5'
-        with tm.assertRaisesRegexp(Exception, msg):
+        with tm.assert_raises_regex(Exception, msg):
             self.read_table(StringIO(data), sep=',',
                             header=1, comment='#')
 
@@ -140,7 +140,7 @@ skip
 2,3,4
 """
         msg = 'Expected 3 fields in line 6, saw 5'
-        with tm.assertRaisesRegexp(Exception, msg):
+        with tm.assert_raises_regex(Exception, msg):
             it = self.read_table(StringIO(data), sep=',',
                                  header=1, comment='#',
                                  iterator=True, chunksize=1,
@@ -157,7 +157,7 @@ skip
 2,3,4
 """
         msg = 'Expected 3 fields in line 6, saw 5'
-        with tm.assertRaisesRegexp(Exception, msg):
+        with tm.assert_raises_regex(Exception, msg):
             it = self.read_table(StringIO(data), sep=',', header=1,
                                  comment='#', iterator=True, chunksize=1,
                                  skiprows=[2])
@@ -173,7 +173,7 @@ skip
 2,3,4
 """
         msg = 'Expected 3 fields in line 6, saw 5'
-        with tm.assertRaisesRegexp(Exception, msg):
+        with tm.assert_raises_regex(Exception, msg):
             it = self.read_table(StringIO(data), sep=',', header=1,
                                  comment='#', iterator=True, chunksize=1,
                                  skiprows=[2])
@@ -190,7 +190,7 @@ A,B,C
 footer
 """
             msg = 'Expected 3 fields in line 4, saw 5'
-            with tm.assertRaisesRegexp(Exception, msg):
+            with tm.assert_raises_regex(Exception, msg):
                 self.read_table(StringIO(data), sep=',',
                                 header=1, comment='#',
                                 skipfooter=1)
@@ -385,13 +385,13 @@ bar,foo"""
 
         msg = r"'nrows' must be an integer >=0"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), nrows=1.2)
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), nrows='foo')
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), nrows=-1)
 
     def test_read_chunksize(self):
@@ -407,13 +407,13 @@ bar,foo"""
         # with invalid chunksize value:
         msg = r"'chunksize' must be an integer >=1"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), chunksize=1.3)
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), chunksize='foo')
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(self.data1), chunksize=0)
 
     def test_read_chunksize_and_nrows(self):
@@ -1104,7 +1104,7 @@ A,B,C
         # make sure that an error is still thrown
         # when the 'usecols' parameter is not provided
         msg = r"Expected \d+ fields in line \d+, saw \d+"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             df = self.read_csv(StringIO(csv))
 
         expected = DataFrame({
@@ -1130,10 +1130,10 @@ A,B,C
         # throws the correct error, with or without usecols
         errmsg = "No columns to parse from file"
 
-        with tm.assertRaisesRegexp(EmptyDataError, errmsg):
+        with tm.assert_raises_regex(EmptyDataError, errmsg):
             self.read_csv(StringIO(''))
 
-        with tm.assertRaisesRegexp(EmptyDataError, errmsg):
+        with tm.assert_raises_regex(EmptyDataError, errmsg):
             self.read_csv(StringIO(''), usecols=usecols)
 
         expected = DataFrame(columns=usecols, index=[0], dtype=np.float64)
@@ -1172,7 +1172,8 @@ A,B,C
     def test_raise_on_sep_with_delim_whitespace(self):
         # see gh-6607
         data = 'a b c\n1 2 3'
-        with tm.assertRaisesRegexp(ValueError, 'you can only specify one'):
+        with tm.assert_raises_regex(ValueError,
+                                    'you can only specify one'):
             self.read_table(StringIO(data), sep=r'\s', delim_whitespace=True)
 
     def test_single_char_leading_whitespace(self):
@@ -1563,7 +1564,7 @@ j,-inF"""
             tm.assert_frame_equal(out, expected)
         else:
             msg = "NULL byte detected"
-            with tm.assertRaisesRegexp(ParserError, msg):
+            with tm.assert_raises_regex(ParserError, msg):
                 self.read_csv(StringIO(data), names=cols)
 
     def test_utf8_bom(self):
@@ -1681,13 +1682,13 @@ j,-inF"""
 
         msg = "Invalid file path or buffer object type"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(InvalidBuffer())
 
         if PY3:
             from unittest import mock
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 self.read_csv(mock.Mock())
 
     @tm.capture_stderr
diff --git a/pandas/tests/io/parser/compression.py b/pandas/tests/io/parser/compression.py
index 26e216cfb..55c0506ac 100644
--- a/pandas/tests/io/parser/compression.py
+++ b/pandas/tests/io/parser/compression.py
@@ -45,18 +45,19 @@ class CompressionTests(object):
                 tmp.writestr(file_name, data)
             tmp.close()
 
-            tm.assertRaisesRegexp(ValueError, 'Multiple files',
-                                  self.read_csv, path, compression='zip')
+            tm.assert_raises_regex(ValueError, 'Multiple files',
+                                   self.read_csv, path, compression='zip')
 
-            tm.assertRaisesRegexp(ValueError, 'Multiple files',
-                                  self.read_csv, path, compression='infer')
+            tm.assert_raises_regex(ValueError, 'Multiple files',
+                                   self.read_csv, path,
+                                   compression='infer')
 
         with tm.ensure_clean() as path:
             tmp = zipfile.ZipFile(path, mode='w')
             tmp.close()
 
-            tm.assertRaisesRegexp(ValueError, 'Zero files',
-                                  self.read_csv, path, compression='zip')
+            tm.assert_raises_regex(ValueError, 'Zero files',
+                                   self.read_csv, path, compression='zip')
 
         with tm.ensure_clean() as path:
             with open(path, 'wb') as f:
@@ -167,5 +168,5 @@ class CompressionTests(object):
 
     def test_invalid_compression(self):
         msg = 'Unrecognized compression type: sfark'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv('test_file.zip', compression='sfark')
diff --git a/pandas/tests/io/parser/converters.py b/pandas/tests/io/parser/converters.py
index f2b3ce532..6cea0f3e7 100644
--- a/pandas/tests/io/parser/converters.py
+++ b/pandas/tests/io/parser/converters.py
@@ -24,7 +24,7 @@ class ConverterTests(object):
         data = """index,A,B,C,D
 foo,2,3,4,5
 """
-        with tm.assertRaisesRegexp(TypeError, 'Type converters.+'):
+        with tm.assert_raises_regex(TypeError, 'Type converters.+'):
             self.read_csv(StringIO(data), converters=0)
 
     def test_converters(self):
diff --git a/pandas/tests/io/parser/dialect.py b/pandas/tests/io/parser/dialect.py
index 82871628e..f756fe71b 100644
--- a/pandas/tests/io/parser/dialect.py
+++ b/pandas/tests/io/parser/dialect.py
@@ -61,7 +61,7 @@ pear:tomato
         data = 'a\n1'
         msg = 'Invalid dialect'
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(data), dialect=InvalidDialect)
 
     def test_dialect_conflict(self):
diff --git a/pandas/tests/io/parser/header.py b/pandas/tests/io/parser/header.py
index 2f0ca5b31..f7967f4fe 100644
--- a/pandas/tests/io/parser/header.py
+++ b/pandas/tests/io/parser/header.py
@@ -19,7 +19,7 @@ class HeaderTests(object):
     def test_read_with_bad_header(self):
         errmsg = r"but only \d+ lines in file"
 
-        with tm.assertRaisesRegexp(ValueError, errmsg):
+        with tm.assert_raises_regex(ValueError, errmsg):
             s = StringIO(',,')
             self.read_csv(s, header=[10])
 
diff --git a/pandas/tests/io/parser/parse_dates.py b/pandas/tests/io/parser/parse_dates.py
index f0a1f58be..3833fa3d7 100644
--- a/pandas/tests/io/parser/parse_dates.py
+++ b/pandas/tests/io/parser/parse_dates.py
@@ -435,11 +435,11 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
         data = """A,B,C
         1,2,2003-11-1"""
 
-        tm.assertRaisesRegexp(TypeError, errmsg, self.read_csv,
-                              StringIO(data), parse_dates="C")
-        tm.assertRaisesRegexp(TypeError, errmsg, self.read_csv,
-                              StringIO(data), parse_dates="C",
-                              index_col="C")
+        tm.assert_raises_regex(TypeError, errmsg, self.read_csv,
+                               StringIO(data), parse_dates="C")
+        tm.assert_raises_regex(TypeError, errmsg, self.read_csv,
+                               StringIO(data), parse_dates="C",
+                               index_col="C")
 
     def test_read_with_parse_dates_invalid_type(self):
         errmsg = ("Only booleans, lists, and "
@@ -448,12 +448,13 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
         data = """A,B,C
         1,2,2003-11-1"""
 
-        tm.assertRaisesRegexp(TypeError, errmsg, self.read_csv,
-                              StringIO(data), parse_dates=(1,))
-        tm.assertRaisesRegexp(TypeError, errmsg, self.read_csv,
-                              StringIO(data), parse_dates=np.array([4, 5]))
-        tm.assertRaisesRegexp(TypeError, errmsg, self.read_csv,
-                              StringIO(data), parse_dates=set([1, 3, 3]))
+        tm.assert_raises_regex(TypeError, errmsg, self.read_csv,
+                               StringIO(data), parse_dates=(1,))
+        tm.assert_raises_regex(TypeError, errmsg,
+                               self.read_csv, StringIO(data),
+                               parse_dates=np.array([4, 5]))
+        tm.assert_raises_regex(TypeError, errmsg, self.read_csv,
+                               StringIO(data), parse_dates=set([1, 3, 3]))
 
     def test_parse_dates_empty_string(self):
         # see gh-2263
diff --git a/pandas/tests/io/parser/python_parser_only.py b/pandas/tests/io/parser/python_parser_only.py
index c5fa64d06..1356ace4b 100644
--- a/pandas/tests/io/parser/python_parser_only.py
+++ b/pandas/tests/io/parser/python_parser_only.py
@@ -24,17 +24,17 @@ class PythonParserTests(object):
 
         # see gh-15925 (comment)
         msg = "skipfooter must be an integer"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(text), skipfooter="foo")
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(text), skipfooter=1.5)
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(text), skipfooter=True)
 
         msg = "skipfooter cannot be negative"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(text), skipfooter=-1)
 
     def test_sniff_delimiter(self):
@@ -208,13 +208,13 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         data = 'a,,b\n1,,a\n2,,"2,,b"'
         msg = 'ignored when a multi-char delimiter is used'
 
-        with tm.assertRaisesRegexp(ParserError, msg):
+        with tm.assert_raises_regex(ParserError, msg):
             self.read_csv(StringIO(data), sep=',,')
 
         # We expect no match, so there should be an assertion
         # error out of the inner context manager.
         with pytest.raises(AssertionError):
-            with tm.assertRaisesRegexp(ParserError, msg):
+            with tm.assert_raises_regex(ParserError, msg):
                 self.read_csv(StringIO(data), sep=',,',
                               quoting=csv.QUOTE_NONE)
 
@@ -226,11 +226,11 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
 
         for data in ('a\n1\n"b"a',
                      'a,b,c\ncat,foo,bar\ndog,foo,"baz'):
-            with tm.assertRaisesRegexp(ParserError, msg):
+            with tm.assert_raises_regex(ParserError, msg):
                 self.read_csv(StringIO(data), skipfooter=1)
 
             # We expect no match, so there should be an assertion
             # error out of the inner context manager.
             with pytest.raises(AssertionError):
-                with tm.assertRaisesRegexp(ParserError, msg):
+                with tm.assert_raises_regex(ParserError, msg):
                     self.read_csv(StringIO(data))
diff --git a/pandas/tests/io/parser/quoting.py b/pandas/tests/io/parser/quoting.py
index a692e03e8..15427aaf9 100644
--- a/pandas/tests/io/parser/quoting.py
+++ b/pandas/tests/io/parser/quoting.py
@@ -20,29 +20,29 @@ class QuotingTests(object):
         # Python 2.x: "...must be an 1-character..."
         # Python 3.x: "...must be a 1-character..."
         msg = '"quotechar" must be a(n)? 1-character string'
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quotechar='foo')
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quotechar='foo')
 
         msg = 'quotechar must be set if quoting enabled'
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quotechar=None,
-                              quoting=csv.QUOTE_MINIMAL)
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quotechar=None,
+                               quoting=csv.QUOTE_MINIMAL)
 
         msg = '"quotechar" must be string, not int'
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quotechar=2)
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quotechar=2)
 
     def test_bad_quoting(self):
         data = '1,2,3'
 
         msg = '"quoting" must be an integer'
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quoting='foo')
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quoting='foo')
 
         # quoting must in the range [0, 3]
         msg = 'bad "quoting" value'
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quoting=5)
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quoting=5)
 
     def test_quote_char_basic(self):
         data = 'a,b,c\n1,2,"cat"'
@@ -68,13 +68,13 @@ class QuotingTests(object):
         # sanity checks
         msg = 'quotechar must be set if quoting enabled'
 
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quotechar=None,
-                              quoting=csv.QUOTE_MINIMAL)
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quotechar=None,
+                               quoting=csv.QUOTE_MINIMAL)
 
-        tm.assertRaisesRegexp(TypeError, msg, self.read_csv,
-                              StringIO(data), quotechar='',
-                              quoting=csv.QUOTE_MINIMAL)
+        tm.assert_raises_regex(TypeError, msg, self.read_csv,
+                               StringIO(data), quotechar='',
+                               quoting=csv.QUOTE_MINIMAL)
 
         # no errors should be raised if quoting is None
         expected = DataFrame([[1, 2, 3]],
diff --git a/pandas/tests/io/parser/skiprows.py b/pandas/tests/io/parser/skiprows.py
index cb1b656e4..fb08ec044 100644
--- a/pandas/tests/io/parser/skiprows.py
+++ b/pandas/tests/io/parser/skiprows.py
@@ -215,11 +215,11 @@ line 22",2
 
         skiprows = lambda x: True
         msg = "No columns to parse from file"
-        with tm.assertRaisesRegexp(EmptyDataError, msg):
+        with tm.assert_raises_regex(EmptyDataError, msg):
             self.read_csv(StringIO(data), skiprows=skiprows)
 
         # This is a bad callable and should raise.
         msg = "by zero"
         skiprows = lambda x: 1 / 0
-        with tm.assertRaisesRegexp(ZeroDivisionError, msg):
+        with tm.assert_raises_regex(ZeroDivisionError, msg):
             self.read_csv(StringIO(data), skiprows=skiprows)
diff --git a/pandas/tests/io/parser/test_read_fwf.py b/pandas/tests/io/parser/test_read_fwf.py
index 9498a7d83..ffb04c52e 100644
--- a/pandas/tests/io/parser/test_read_fwf.py
+++ b/pandas/tests/io/parser/test_read_fwf.py
@@ -67,10 +67,11 @@ class TestFwfParsing(tm.TestCase):
             StringIO(data3), colspecs=colspecs, delimiter='~', header=None)
         tm.assert_frame_equal(df, expected)
 
-        with tm.assertRaisesRegexp(ValueError, "must specify only one of"):
+        with tm.assert_raises_regex(ValueError,
+                                    "must specify only one of"):
             read_fwf(StringIO(data3), colspecs=colspecs, widths=[6, 10, 10, 7])
 
-        with tm.assertRaisesRegexp(ValueError, "Must specify either"):
+        with tm.assert_raises_regex(ValueError, "Must specify either"):
             read_fwf(StringIO(data3), colspecs=None, widths=None)
 
     def test_BytesIO_input(self):
@@ -93,9 +94,9 @@ foo2,12,13,14,15
 bar2,12,13,14,15
 """
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   'column specifications must be a list or '
-                                   'tuple.+'):
+        with tm.assert_raises_regex(TypeError,
+                                    'column specifications must '
+                                    'be a list or tuple.+'):
             pd.io.parsers.FixedWidthReader(StringIO(data),
                                            {'a': 1}, ',', '#')
 
@@ -109,8 +110,9 @@ foo2,12,13,14,15
 bar2,12,13,14,15
 """
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   'Each column specification must be.+'):
+        with tm.assert_raises_regex(TypeError,
+                                    'Each column specification '
+                                    'must be.+'):
             read_fwf(StringIO(data), [('a', 1)])
 
     def test_fwf_colspecs_None(self):
diff --git a/pandas/tests/io/parser/test_unsupported.py b/pandas/tests/io/parser/test_unsupported.py
index 9637b449d..6c2d883ae 100644
--- a/pandas/tests/io/parser/test_unsupported.py
+++ b/pandas/tests/io/parser/test_unsupported.py
@@ -25,7 +25,7 @@ class TestUnsupportedFeatures(tm.TestCase):
         msg = 'is not supported'
 
         for engine in ('c', 'python'):
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 read_csv(StringIO(data), engine=engine,
                          mangle_dupe_cols=False)
 
@@ -35,14 +35,14 @@ class TestUnsupportedFeatures(tm.TestCase):
         msg = 'does not support'
 
         # specify C engine with unsupported options (raise)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_table(StringIO(data), engine='c',
                        sep=None, delim_whitespace=False)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_table(StringIO(data), engine='c', sep=r'\s')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_table(StringIO(data), engine='c', quotechar=chr(128))
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_table(StringIO(data), engine='c', skipfooter=1)
 
         # specify C-unsupported options without python-unsupported options
@@ -62,9 +62,9 @@ a   q   20      4     0.4473  1.4152  0.2834  1.00661  0.1744
 x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         msg = 'Error tokenizing data'
 
-        with tm.assertRaisesRegexp(ParserError, msg):
+        with tm.assert_raises_regex(ParserError, msg):
             read_table(StringIO(text), sep='\\s+')
-        with tm.assertRaisesRegexp(ParserError, msg):
+        with tm.assert_raises_regex(ParserError, msg):
             read_table(StringIO(text), engine='c', sep='\\s+')
 
         msg = "Only length-1 thousands markers supported"
@@ -72,14 +72,14 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
 1|2,334|5
 10|13|10.
 """
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_csv(StringIO(data), thousands=',,')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_csv(StringIO(data), thousands='')
 
         msg = "Only length-1 line terminators supported"
         data = 'a,b,c~~1,2,3~~4,5,6'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             read_csv(StringIO(data), lineterminator='~~')
 
     def test_python_engine(self):
@@ -98,7 +98,7 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
                        'with the %r engine' % (default, engine))
 
                 kwargs = {default: object()}
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     read_csv(StringIO(data), engine=engine, **kwargs)
 
 
diff --git a/pandas/tests/io/parser/usecols.py b/pandas/tests/io/parser/usecols.py
index 1ea735342..db8e5b765 100644
--- a/pandas/tests/io/parser/usecols.py
+++ b/pandas/tests/io/parser/usecols.py
@@ -28,7 +28,7 @@ class UsecolsTests(object):
                "all integers or a callable")
         usecols = [0, 'b', 2]
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(data), usecols=usecols)
 
     def test_usecols(self):
@@ -351,10 +351,10 @@ a,b,c
         msg = ("'usecols' must either be all strings, all unicode, "
                "all integers or a callable")
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(s), usecols=[u'AAA', b'BBB'])
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.read_csv(StringIO(s), usecols=[b'AAA', u'BBB'])
 
     def test_usecols_with_multibyte_characters(self):
diff --git a/pandas/tests/io/test_common.py b/pandas/tests/io/test_common.py
index fd29caefb..82819b944 100644
--- a/pandas/tests/io/test_common.py
+++ b/pandas/tests/io/test_common.py
@@ -108,13 +108,14 @@ class TestMMapWrapper(tm.TestCase):
             msg = "[Errno 22]"
             err = mmap.error
 
-        tm.assertRaisesRegexp(err, msg, common.MMapWrapper, non_file)
+        tm.assert_raises_regex(err, msg, common.MMapWrapper, non_file)
 
         target = open(self.mmap_file, 'r')
         target.close()
 
         msg = "I/O operation on closed file"
-        tm.assertRaisesRegexp(ValueError, msg, common.MMapWrapper, target)
+        tm.assert_raises_regex(
+            ValueError, msg, common.MMapWrapper, target)
 
     def test_get_attr(self):
         with open(self.mmap_file, 'r') as target:
diff --git a/pandas/tests/io/test_excel.py b/pandas/tests/io/test_excel.py
index 02652be21..2a3a4992e 100644
--- a/pandas/tests/io/test_excel.py
+++ b/pandas/tests/io/test_excel.py
@@ -1870,7 +1870,7 @@ def raise_wrapper(major_ver):
             else:
                 msg = (r'Installed openpyxl is not supported at this '
                        r'time\. Use.+')
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     orig_method(self, *args, **kwargs)
         return wrapped
     return versioned_raise_wrapper
@@ -2292,7 +2292,7 @@ class XlsxWriterTests_NoMerge(ExcelWriterBase, tm.TestCase):
 class ExcelWriterEngineTests(tm.TestCase):
 
     def test_ExcelWriter_dispatch(self):
-        with tm.assertRaisesRegexp(ValueError, 'No engine'):
+        with tm.assert_raises_regex(ValueError, 'No engine'):
             ExcelWriter('nothing')
 
         try:
diff --git a/pandas/tests/io/test_html.py b/pandas/tests/io/test_html.py
index e7eaab098..5a30ff2af 100644
--- a/pandas/tests/io/test_html.py
+++ b/pandas/tests/io/test_html.py
@@ -219,8 +219,8 @@ class TestReadHtml(tm.TestCase, ReadHtmlMixin):
         assert_framelist_equal(df1, df2)
 
     def test_skiprows_invalid(self):
-        with tm.assertRaisesRegexp(TypeError,
-                                   'is not a valid type for skipping rows'):
+        with tm.assert_raises_regex(TypeError, 'is not a valid type '
+                                    'for skipping rows'):
             self.read_html(self.spam_data, '.*Water.*', skiprows='asdf')
 
     def test_index(self):
@@ -302,7 +302,7 @@ class TestReadHtml(tm.TestCase, ReadHtmlMixin):
     @tm.slow
     def test_invalid_table_attrs(self):
         url = self.banklist_data
-        with tm.assertRaisesRegexp(ValueError, 'No tables found'):
+        with tm.assert_raises_regex(ValueError, 'No tables found'):
             self.read_html(url, 'First Federal Bank of Florida',
                            attrs={'id': 'tasdfable'})
 
@@ -353,8 +353,8 @@ class TestReadHtml(tm.TestCase, ReadHtmlMixin):
             assert isinstance(df, DataFrame)
 
     def test_negative_skiprows(self):
-        with tm.assertRaisesRegexp(ValueError,
-                                   r'\(you passed a negative value\)'):
+        with tm.assert_raises_regex(ValueError,
+                                    r'\(you passed a negative value\)'):
             self.read_html(self.spam_data, 'Water', skiprows=-1)
 
     @network
@@ -652,9 +652,10 @@ class TestReadHtml(tm.TestCase, ReadHtmlMixin):
 
     def test_computer_sales_page(self):
         data = os.path.join(DATA_PATH, 'computer_sales_page.html')
-        with tm.assertRaisesRegexp(ParserError, r"Passed header=\[0,1\] are "
-                                   "too many rows for this multi_index "
-                                   "of columns"):
+        with tm.assert_raises_regex(ParserError,
+                                    r"Passed header=\[0,1\] are "
+                                    r"too many rows for this "
+                                    r"multi_index of columns"):
             self.read_html(data, header=[0, 1])
 
     def test_wikipedia_states_table(self):
diff --git a/pandas/tests/io/test_pickle.py b/pandas/tests/io/test_pickle.py
index 94e4fec07..875b5bd30 100644
--- a/pandas/tests/io/test_pickle.py
+++ b/pandas/tests/io/test_pickle.py
@@ -403,8 +403,8 @@ class TestCompression(object):
 
     @pytest.mark.parametrize('compression', ['', 'None', 'bad', '7z'])
     def test_write_explicit_bad(self, compression, get_random_path):
-        with tm.assertRaisesRegexp(ValueError,
-                                   "Unrecognized compression type"):
+        with tm.assert_raises_regex(ValueError,
+                                    "Unrecognized compression type"):
             with tm.ensure_clean(get_random_path) as path:
                 df = tm.makeDataFrame()
                 df.to_pickle(path, compression=compression)
diff --git a/pandas/tests/io/test_pytables.py b/pandas/tests/io/test_pytables.py
index 7d2c7a97f..1b656e7b1 100644
--- a/pandas/tests/io/test_pytables.py
+++ b/pandas/tests/io/test_pytables.py
@@ -971,7 +971,7 @@ class TestHDFStore(Base, tm.TestCase):
     def test_latin_encoding(self):
 
         if compat.PY2:
-            tm.assertRaisesRegexp(
+            tm.assert_raises_regex(
                 TypeError, r'\[unicode\] is not implemented as a table column')
             return
 
@@ -2563,7 +2563,7 @@ class TestHDFStore(Base, tm.TestCase):
                 for t in terms:
                     store.select('p4d', t)
 
-                with tm.assertRaisesRegexp(
+                with tm.assert_raises_regex(
                         TypeError, 'Only named functions are supported'):
                     store.select(
                         'wp',
@@ -2575,8 +2575,9 @@ class TestHDFStore(Base, tm.TestCase):
                 expected = Panel({-1: wpneg[-1]})
                 tm.assert_panel_equal(res, expected)
 
-                with tm.assertRaisesRegexp(NotImplementedError,
-                                           'Unary addition not supported'):
+                with tm.assert_raises_regex(NotImplementedError,
+                                            'Unary addition '
+                                            'not supported'):
                     store.select('wpneg', 'items == +1')
 
     def test_term_compat(self):
@@ -4388,7 +4389,7 @@ class TestHDFStore(Base, tm.TestCase):
 
             def f():
                 store.select('df')
-            tm.assertRaisesRegexp(ClosedFileError, 'file is not open', f)
+            tm.assert_raises_regex(ClosedFileError, 'file is not open', f)
 
     def test_pytables_native_read(self):
 
diff --git a/pandas/tests/io/test_sql.py b/pandas/tests/io/test_sql.py
index 63fcfb0d2..36ff3bdbb 100644
--- a/pandas/tests/io/test_sql.py
+++ b/pandas/tests/io/test_sql.py
@@ -984,7 +984,7 @@ class TestSQLApi(SQLAlchemyMixIn, _TestSQLApi, unittest.TestCase):
         # using driver that will not be installed on Travis to trigger error
         # in sqlalchemy.create_engine -> test passing of this error to user
         db_uri = "postgresql+pg8000://user:pass@host/dbname"
-        with tm.assertRaisesRegexp(ImportError, "pg8000"):
+        with tm.assert_raises_regex(ImportError, "pg8000"):
             sql.read_sql("select * from table", db_uri)
 
     def _make_iris_table_metadata(self):
@@ -2380,8 +2380,8 @@ class TestSQLFlavorDeprecation(tm.TestCase):
         msg = 'is not supported'
 
         for func in self.funcs:
-            tm.assertRaisesRegexp(ValueError, msg, getattr(sql, func),
-                                  self.con, flavor='mysql')
+            tm.assert_raises_regex(ValueError, msg, getattr(sql, func),
+                                   self.con, flavor='mysql')
 
     def test_deprecated_flavor(self):
         for func in self.funcs:
diff --git a/pandas/tests/reshape/test_concat.py b/pandas/tests/reshape/test_concat.py
index cc71cf6b1..2bde4349f 100644
--- a/pandas/tests/reshape/test_concat.py
+++ b/pandas/tests/reshape/test_concat.py
@@ -124,10 +124,12 @@ class TestConcatAppendCommon(ConcatenateBase):
             tm.assert_index_equal(res, exp)
 
             # cannot append non-index
-            with tm.assertRaisesRegexp(TypeError, 'all inputs must be Index'):
+            with tm.assert_raises_regex(TypeError,
+                                        'all inputs must be Index'):
                 pd.Index(vals1).append(vals2)
 
-            with tm.assertRaisesRegexp(TypeError, 'all inputs must be Index'):
+            with tm.assert_raises_regex(TypeError,
+                                        'all inputs must be Index'):
                 pd.Index(vals1).append([pd.Index(vals2), vals3])
 
             # ----- Series ----- #
@@ -175,16 +177,16 @@ class TestConcatAppendCommon(ConcatenateBase):
 
             # cannot append non-index
             msg = "cannot concatenate a non-NDFrame object"
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 pd.Series(vals1).append(vals2)
 
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 pd.Series(vals1).append([pd.Series(vals2), vals3])
 
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 pd.concat([pd.Series(vals1), vals2])
 
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 pd.concat([pd.Series(vals1), pd.Series(vals2), vals3])
 
     def test_concatlike_dtypes_coercion(self):
diff --git a/pandas/tests/reshape/test_join.py b/pandas/tests/reshape/test_join.py
index 7e39806b4..475b17d9f 100644
--- a/pandas/tests/reshape/test_join.py
+++ b/pandas/tests/reshape/test_join.py
@@ -234,9 +234,9 @@ class TestJoin(tm.TestCase):
         df = DataFrame({'a': [1, 1]})
 
         for obj in wrongly_typed:
-            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
+            with tm.assert_raises_regex(ValueError, str(type(obj))):
                 merge(obj, df, left_on='a', right_on='a')
-            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
+            with tm.assert_raises_regex(ValueError, str(type(obj))):
                 merge(df, obj, left_on='a', right_on='a')
 
     def test_join_on_pass_vector(self):
diff --git a/pandas/tests/reshape/test_merge_ordered.py b/pandas/tests/reshape/test_merge_ordered.py
index e445ad932..77f47ff0a 100644
--- a/pandas/tests/reshape/test_merge_ordered.py
+++ b/pandas/tests/reshape/test_merge_ordered.py
@@ -83,7 +83,7 @@ class TestOrderedMerge(tm.TestCase):
             ([None, None], none_pat)
         ]
         for df_seq, pattern in test_cases:
-            tm.assertRaisesRegexp(ValueError, pattern, pd.concat, df_seq)
+            tm.assert_raises_regex(ValueError, pattern, pd.concat, df_seq)
 
         pd.concat([pd.DataFrame()])
         pd.concat([None, pd.DataFrame()])
diff --git a/pandas/tests/reshape/test_pivot.py b/pandas/tests/reshape/test_pivot.py
index 242011d6f..f15616a16 100644
--- a/pandas/tests/reshape/test_pivot.py
+++ b/pandas/tests/reshape/test_pivot.py
@@ -1321,22 +1321,22 @@ class TestCrosstab(tm.TestCase):
                            'c': [1, 1, np.nan, 1, 1]})
 
         error = 'values cannot be used without an aggfunc.'
-        with tm.assertRaisesRegexp(ValueError, error):
+        with tm.assert_raises_regex(ValueError, error):
             pd.crosstab(df.a, df.b, values=df.c)
 
         error = 'aggfunc cannot be used without values'
-        with tm.assertRaisesRegexp(ValueError, error):
+        with tm.assert_raises_regex(ValueError, error):
             pd.crosstab(df.a, df.b, aggfunc=np.mean)
 
         error = 'Not a valid normalize argument'
-        with tm.assertRaisesRegexp(ValueError, error):
+        with tm.assert_raises_regex(ValueError, error):
             pd.crosstab(df.a, df.b, normalize='42')
 
-        with tm.assertRaisesRegexp(ValueError, error):
+        with tm.assert_raises_regex(ValueError, error):
             pd.crosstab(df.a, df.b, normalize=42)
 
         error = 'Not a valid margins argument'
-        with tm.assertRaisesRegexp(ValueError, error):
+        with tm.assert_raises_regex(ValueError, error):
             pd.crosstab(df.a, df.b, normalize='all', margins=42)
 
     def test_crosstab_with_categorial_columns(self):
diff --git a/pandas/tests/reshape/test_reshape.py b/pandas/tests/reshape/test_reshape.py
index f41c977cc..87f16cfaf 100644
--- a/pandas/tests/reshape/test_reshape.py
+++ b/pandas/tests/reshape/test_reshape.py
@@ -117,7 +117,7 @@ class TestMelt(tm.TestCase):
 
         for id_vars, value_vars in ((tuple_a, list_b), (list_a, tuple_b),
                                     (tuple_a, tuple_b)):
-            with tm.assertRaisesRegexp(ValueError, r'MultiIndex'):
+            with tm.assert_raises_regex(ValueError, r'MultiIndex'):
                 self.df1.melt(id_vars=id_vars, value_vars=value_vars)
 
     def test_custom_var_name(self):
diff --git a/pandas/tests/reshape/test_tile.py b/pandas/tests/reshape/test_tile.py
index 8aaa8a51d..1cc5c5f22 100644
--- a/pandas/tests/reshape/test_tile.py
+++ b/pandas/tests/reshape/test_tile.py
@@ -192,8 +192,8 @@ class TestCut(tm.TestCase):
         tm.assert_categorical_equal(factor, expected)
 
     def test_qcut_all_bins_same(self):
-        tm.assertRaisesRegexp(ValueError, "edges.*unique", qcut,
-                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 3)
+        tm.assert_raises_regex(ValueError, "edges.*unique", qcut,
+                               [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 3)
 
     def test_cut_out_of_bounds(self):
         arr = np.random.randn(100)
diff --git a/pandas/tests/reshape/test_union_categoricals.py b/pandas/tests/reshape/test_union_categoricals.py
index 1c67b13a9..5cc476718 100644
--- a/pandas/tests/reshape/test_union_categoricals.py
+++ b/pandas/tests/reshape/test_union_categoricals.py
@@ -58,11 +58,11 @@ class TestUnionCategoricals(tm.TestCase):
         s = Categorical([0, 1.2, 2])
         s2 = Categorical([2, 3, 4])
         msg = 'dtype of categories must be the same'
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([s, s2])
 
         msg = 'No Categoricals to union'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             union_categoricals([])
 
     def test_union_categoricals_nan(self):
@@ -139,7 +139,7 @@ class TestUnionCategoricals(tm.TestCase):
         c2 = Categorical([1, 2, 3], ordered=False)
 
         msg = 'Categorical.ordered must be the same'
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([c1, c2])
 
         res = union_categoricals([c1, c1])
@@ -157,7 +157,7 @@ class TestUnionCategoricals(tm.TestCase):
         c2 = Categorical([1, 2, 3], categories=[3, 2, 1], ordered=True)
 
         msg = "to union ordered Categoricals, all categories must be the same"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([c1, c2])
 
     def test_union_categoricals_ignore_order(self):
@@ -170,7 +170,7 @@ class TestUnionCategoricals(tm.TestCase):
         tm.assert_categorical_equal(res, exp)
 
         msg = 'Categorical.ordered must be the same'
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([c1, c2], ignore_order=False)
 
         res = union_categoricals([c1, c1], ignore_order=True)
@@ -208,10 +208,10 @@ class TestUnionCategoricals(tm.TestCase):
         tm.assert_categorical_equal(result, expected)
 
         msg = "to union ordered Categoricals, all categories must be the same"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([c1, c2], ignore_order=False)
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             union_categoricals([c1, c2])
 
     def test_union_categoricals_sort(self):
diff --git a/pandas/tests/reshape/test_util.py b/pandas/tests/reshape/test_util.py
index fd3a683e8..a7fbe8d30 100644
--- a/pandas/tests/reshape/test_util.py
+++ b/pandas/tests/reshape/test_util.py
@@ -46,4 +46,4 @@ class TestCartesianProduct(tm.TestCase):
                           'a', ['a'], ['a', 'b'], [['a'], 'b']]
         msg = "Input must be a list-like of list-likes"
         for X in invalid_inputs:
-            tm.assertRaisesRegexp(TypeError, msg, cartesian_product, X=X)
+            tm.assert_raises_regex(TypeError, msg, cartesian_product, X=X)
diff --git a/pandas/tests/scalar/test_interval.py b/pandas/tests/scalar/test_interval.py
index ea267fabd..526a2916e 100644
--- a/pandas/tests/scalar/test_interval.py
+++ b/pandas/tests/scalar/test_interval.py
@@ -46,7 +46,7 @@ class TestInterval(tm.TestCase):
         self.assertNotEqual(Interval(0, 1), 0)
 
     def test_comparison(self):
-        with tm.assertRaisesRegexp(TypeError, 'unorderable types'):
+        with tm.assert_raises_regex(TypeError, 'unorderable types'):
             Interval(0, 1) < 2
 
         self.assertTrue(Interval(0, 1) < Interval(1, 2))
diff --git a/pandas/tests/scalar/test_period.py b/pandas/tests/scalar/test_period.py
index f8b103836..b5c243952 100644
--- a/pandas/tests/scalar/test_period.py
+++ b/pandas/tests/scalar/test_period.py
@@ -135,11 +135,11 @@ class TestPeriodProperties(tm.TestCase):
 
         msg = ('Frequency must be positive, because it'
                ' represents span: -3M')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='-3M')
 
         msg = ('Frequency must be positive, because it' ' represents span: 0M')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='0M')
 
     def test_period_cons_combined(self):
@@ -185,28 +185,28 @@ class TestPeriodProperties(tm.TestCase):
 
         msg = ('Frequency must be positive, because it'
                ' represents span: -25H')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='-1D1H')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='-1H1D')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(ordinal=1, freq='-1D1H')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(ordinal=1, freq='-1H1D')
 
         msg = ('Frequency must be positive, because it'
                ' represents span: 0D')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='0D0H')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(ordinal=1, freq='0D0H')
 
         # You can only combine together day and intraday offsets
         msg = ('Invalid frequency: 1W1D')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='1W1D')
         msg = ('Invalid frequency: 1D1W')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='1D1W')
 
     def test_timestamp_tz_arg(self):
@@ -518,9 +518,9 @@ class TestPeriodProperties(tm.TestCase):
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
         for exp, freqs in iteritems(cases):
             for freq in freqs:
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     Period('2016-03-01 09:00', freq=freq)
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     Period(ordinal=1, freq=freq)
 
             # check supported freq-aliases still works
@@ -762,7 +762,7 @@ class TestPeriodProperties(tm.TestCase):
         self.assertEqual(exp.days_in_month, 29)
 
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK', year=2007, month=1, day=7)
 
     def test_properties_daily(self):
@@ -1032,14 +1032,14 @@ class TestMethods(tm.TestCase):
         dt1 = Period(freq='D', year=2008, month=1, day=1)
         dt2 = Period(freq='D', year=2008, month=1, day=2)
         msg = r"unsupported operand type\(s\)"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             dt1 + "str"
 
         msg = r"unsupported operand type\(s\)"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             "str" + dt1
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             dt1 + dt2
 
     def test_sub(self):
@@ -1050,7 +1050,7 @@ class TestMethods(tm.TestCase):
         self.assertEqual(dt2 - dt1, 14)
 
         msg = r"Input has different freq=M from Period\(freq=D\)"
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             dt1 - pd.Period('2011-02', freq='M')
 
     def test_add_offset(self):
@@ -1414,8 +1414,8 @@ class TestMethods(tm.TestCase):
         self.assertEqual(result, exp)
 
         msg = r"Input cannot be converted to Period\(freq=D\)"
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             p + offsets.Hour(2)
 
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             p - offsets.Hour(2)
diff --git a/pandas/tests/scalar/test_period_asfreq.py b/pandas/tests/scalar/test_period_asfreq.py
index 611a1cc97..84793658a 100644
--- a/pandas/tests/scalar/test_period_asfreq.py
+++ b/pandas/tests/scalar/test_period_asfreq.py
@@ -295,26 +295,26 @@ class TestFreqConversion(tm.TestCase):
         self.assertEqual(ival_W.asfreq('W'), ival_W)
 
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             ival_W.asfreq('WK')
 
     def test_conv_weekly_legacy(self):
         # frequency conversion tests: from Weekly Frequency
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK', year=2007, month=1, day=1)
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-SAT', year=2007, month=1, day=6)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-FRI', year=2007, month=1, day=5)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-THU', year=2007, month=1, day=4)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-WED', year=2007, month=1, day=3)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-TUE', year=2007, month=1, day=2)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             Period(freq='WK-MON', year=2007, month=1, day=1)
 
     def test_conv_business(self):
@@ -712,10 +712,10 @@ class TestFreqConversion(tm.TestCase):
                          Period('2013-01', 'M'))
 
         msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             initial.asfreq(freq="MS", how="S")
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             pd.Period('2013-01', 'MS')
 
         self.assertTrue(_period_code_map.get("MS") is None)
diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index 4cced3e48..86b02d20b 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -125,16 +125,17 @@ class TestTimedeltas(tm.TestCase):
         pytest.raises(ValueError, lambda: Timedelta('3.1415'))
 
         # invalid construction
-        tm.assertRaisesRegexp(ValueError, "cannot construct a Timedelta",
-                              lambda: Timedelta())
-        tm.assertRaisesRegexp(ValueError, "unit abbreviation w/o a number",
-                              lambda: Timedelta('foo'))
-        tm.assertRaisesRegexp(ValueError,
-                              "cannot construct a Timedelta from the passed "
-                              "arguments, allowed keywords are ",
-                              lambda: Timedelta(day=10))
-
-        # roundtripping both for string and value
+        tm.assert_raises_regex(ValueError, "cannot construct a Timedelta",
+                               lambda: Timedelta())
+        tm.assert_raises_regex(ValueError,
+                               "unit abbreviation w/o a number",
+                               lambda: Timedelta('foo'))
+        tm.assert_raises_regex(ValueError,
+                               "cannot construct a Timedelta from the "
+                               "passed arguments, allowed keywords are ",
+                               lambda: Timedelta(day=10))
+
+        # round-trip both for string and value
         for v in ['1s', '-1s', '1us', '-1us', '1 day', '-1 day',
                   '-23:59:59.999999', '-1 days +23:59:59.999999', '-1ns',
                   '1ns', '-23:59:59.999999999']:
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index b7b1b4c19..bad0b697e 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -172,9 +172,9 @@ class TestTimestamp(tm.TestCase):
         self.assertEqual(result, eval(repr(result)))
 
     def test_constructor_invalid(self):
-        with tm.assertRaisesRegexp(TypeError, 'Cannot convert input'):
+        with tm.assert_raises_regex(TypeError, 'Cannot convert input'):
             Timestamp(slice(2))
-        with tm.assertRaisesRegexp(ValueError, 'Cannot convert Period'):
+        with tm.assert_raises_regex(ValueError, 'Cannot convert Period'):
             Timestamp(Period('1000-01-01'))
 
     def test_constructor_positional(self):
@@ -245,7 +245,7 @@ class TestTimestamp(tm.TestCase):
             self.assertEqual(ts.offset, 'D')
 
         msg = "Can only specify freq or offset, not both"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Timestamp('2011-01-01', offset='D', freq='D')
 
     def test_constructor_offset_depr_fromordinal(self):
@@ -260,7 +260,7 @@ class TestTimestamp(tm.TestCase):
         self.assertEqual(base.toordinal(), ts.toordinal())
 
         msg = "Can only specify freq or offset, not both"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Timestamp.fromordinal(base.toordinal(), offset='D', freq='D')
 
     def test_conversion(self):
@@ -393,14 +393,14 @@ class TestTimestamp(tm.TestCase):
                       ambiguous='infer')
 
         # GH 8025
-        with tm.assertRaisesRegexp(TypeError,
-                                   'Cannot localize tz-aware Timestamp, use '
-                                   'tz_convert for conversions'):
+        with tm.assert_raises_regex(TypeError,
+                                    'Cannot localize tz-aware Timestamp, '
+                                    'use tz_convert for conversions'):
             Timestamp('2011-01-01', tz='US/Eastern').tz_localize('Asia/Tokyo')
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   'Cannot convert tz-naive Timestamp, use '
-                                   'tz_localize to localize'):
+        with tm.assert_raises_regex(TypeError,
+                                    'Cannot convert tz-naive Timestamp, '
+                                    'use tz_localize to localize'):
             Timestamp('2011-01-01').tz_convert('Asia/Tokyo')
 
     def test_tz_localize_nonexistent(self):
@@ -710,7 +710,7 @@ class TestTimestamp(tm.TestCase):
             _check_round(freq, expected)
 
         msg = frequencies._INVALID_FREQ_ERROR
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             stamp.round('foo')
 
     def test_class_ops_pytz(self):
diff --git a/pandas/tests/series/test_analytics.py b/pandas/tests/series/test_analytics.py
index 02748aee4..eb8a83bb8 100644
--- a/pandas/tests/series/test_analytics.py
+++ b/pandas/tests/series/test_analytics.py
@@ -550,8 +550,8 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
 
             # Unimplemented numeric_only parameter.
             if 'numeric_only' in compat.signature(f).args:
-                tm.assertRaisesRegexp(NotImplementedError, name, f,
-                                      self.series, numeric_only=True)
+                tm.assert_raises_regex(NotImplementedError, name, f,
+                                       self.series, numeric_only=True)
 
         testit()
 
@@ -596,12 +596,12 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
         tm.assert_series_equal(np.compress(cond, s), expected)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.compress,
-                              cond, s, axis=1)
+        tm.assert_raises_regex(ValueError, msg, np.compress,
+                               cond, s, axis=1)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.compress,
-                              cond, s, out=s)
+        tm.assert_raises_regex(ValueError, msg, np.compress,
+                               cond, s, out=s)
 
     def test_round(self):
         self.ts.index.name = "index_name"
@@ -619,7 +619,7 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
         assert_series_equal(out, expected)
 
         msg = "the 'out' parameter is not supported"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             np.round(s, decimals=0, out=s)
 
     def test_built_in_round(self):
@@ -1184,8 +1184,8 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
 
         if not _np_version_under1p10:
             msg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.argmin,
-                                  Series(data), out=data)
+            tm.assert_raises_regex(ValueError, msg, np.argmin,
+                                   Series(data), out=data)
 
     def test_idxmax(self):
         # test idxmax
@@ -1240,8 +1240,8 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
 
         if not _np_version_under1p10:
             msg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.argmax,
-                                  Series(data), out=data)
+            tm.assert_raises_regex(ValueError, msg, np.argmax,
+                                   Series(data), out=data)
 
     def test_ptp(self):
         N = 1000
@@ -1307,7 +1307,7 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
         assert_series_equal(np.repeat(s, 2), expected)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.repeat, s, 2, axis=0)
+        tm.assert_raises_regex(ValueError, msg, np.repeat, s, 2, axis=0)
 
     def test_searchsorted(self):
         s = Series([1, 2, 3])
@@ -1483,11 +1483,13 @@ class TestSeriesAnalytics(TestData, tm.TestCase):
 
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             msg = "'foo' is an invalid keyword argument for this function"
-            tm.assertRaisesRegexp(TypeError, msg, a.reshape, (2, 2), foo=2)
+            tm.assert_raises_regex(
+                TypeError, msg, a.reshape, (2, 2), foo=2)
 
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             msg = r"reshape\(\) got an unexpected keyword argument 'foo'"
-            tm.assertRaisesRegexp(TypeError, msg, a.reshape, a.shape, foo=2)
+            tm.assert_raises_regex(
+                TypeError, msg, a.reshape, a.shape, foo=2)
 
     def test_numpy_reshape(self):
         a = Series([1, 2, 3, 4])
@@ -1697,7 +1699,7 @@ class TestNLargestNSmallest(object):
         args = 2, len(r), 0, -1
         methods = r.nlargest, r.nsmallest
         for method, arg in product(methods, args):
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 method(arg)
 
     @pytest.mark.parametrize(
@@ -1729,9 +1731,9 @@ class TestNLargestNSmallest(object):
         assert_series_equal(s.nsmallest(), s.iloc[[2, 3, 0, 4]])
 
         msg = 'keep must be either "first", "last"'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.nsmallest(keep='invalid')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.nlargest(keep='invalid')
 
         # GH 15297
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index f1a904498..397058c4b 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -341,7 +341,8 @@ class TestSeriesMisc(TestData, SharedWithSparse, tm.TestCase):
 
         # str accessor only valid with string values
         s = Series(range(5))
-        with tm.assertRaisesRegexp(AttributeError, 'only use .str accessor'):
+        with tm.assert_raises_regex(AttributeError,
+                                    'only use .str accessor'):
             s.str.repeat(2)
 
     def test_empty_method(self):
diff --git a/pandas/tests/series/test_combine_concat.py b/pandas/tests/series/test_combine_concat.py
index 51a2a5ed6..b4615e542 100644
--- a/pandas/tests/series/test_combine_concat.py
+++ b/pandas/tests/series/test_combine_concat.py
@@ -55,9 +55,9 @@ class TestSeriesCombine(TestData, tm.TestCase):
                                exp, check_index_type=True)
 
         msg = 'Indexes have overlapping values:'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s1.append(s2, verify_integrity=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             pd.concat([s1, s2], verify_integrity=True)
 
     def test_combine_first(self):
diff --git a/pandas/tests/series/test_constructors.py b/pandas/tests/series/test_constructors.py
index 74c2544d9..c46155664 100644
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -851,10 +851,10 @@ class TestSeriesConstructors(TestData, tm.TestCase):
 
     def test_constructor_cant_cast_datetime64(self):
         msg = "Cannot cast datetime64 to "
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Series(date_range('1/1/2000', periods=10), dtype=float)
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Series(date_range('1/1/2000', periods=10), dtype=int)
 
     def test_constructor_cast_object(self):
@@ -882,9 +882,9 @@ class TestSeriesConstructors(TestData, tm.TestCase):
         # These timestamps have the wrong frequencies,
         # so an Exception should be raised now.
         msg = "cannot convert timedeltalike"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Series([], dtype='m8[ps]')
 
         msg = "cannot convert datetimelike"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             Series([], dtype='M8[ps]')
diff --git a/pandas/tests/series/test_datetime_values.py b/pandas/tests/series/test_datetime_values.py
index ecb457b4f..74a4e37f0 100644
--- a/pandas/tests/series/test_datetime_values.py
+++ b/pandas/tests/series/test_datetime_values.py
@@ -251,7 +251,7 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
 
         # no setting allowed
         s = Series(date_range('20130101', periods=5, freq='D'), name='xxx')
-        with tm.assertRaisesRegexp(ValueError, "modifications"):
+        with tm.assert_raises_regex(ValueError, "modifications"):
             s.dt.hour = 5
 
         # trying to set a copy
@@ -265,8 +265,8 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
     def test_dt_accessor_no_new_attributes(self):
         # https://github.com/pandas-dev/pandas/issues/10673
         s = Series(date_range('20130101', periods=5, freq='D'))
-        with tm.assertRaisesRegexp(AttributeError,
-                                   "You cannot add any new attribute"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "You cannot add any new attribute"):
             s.dt.xlabel = "a"
 
     def test_strftime(self):
@@ -375,8 +375,8 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
 
         for s in [Series(np.arange(5)), Series(list('abcde')),
                   Series(np.random.randn(5))]:
-            with tm.assertRaisesRegexp(AttributeError,
-                                       "only use .dt accessor"):
+            with tm.assert_raises_regex(AttributeError,
+                                        "only use .dt accessor"):
                 s.dt
             self.assertFalse(hasattr(s, 'dt'))
 
diff --git a/pandas/tests/series/test_dtypes.py b/pandas/tests/series/test_dtypes.py
index 6bbf00d6c..e084fa58d 100644
--- a/pandas/tests/series/test_dtypes.py
+++ b/pandas/tests/series/test_dtypes.py
@@ -50,7 +50,7 @@ class TestSeriesDtypes(TestData):
         msg = 'Cannot convert non-finite values \\(NA or inf\\) to integer'
         s = Series([value])
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.astype(dtype)
 
     @pytest.mark.parametrize("dtype", [int, np.int8, np.int64])
diff --git a/pandas/tests/series/test_indexing.py b/pandas/tests/series/test_indexing.py
index 135e20887..6907cc194 100644
--- a/pandas/tests/series/test_indexing.py
+++ b/pandas/tests/series/test_indexing.py
@@ -808,9 +808,9 @@ class TestSeriesIndexing(TestData, tm.TestCase):
 
     def test_basic_getitem_setitem_corner(self):
         # invalid tuples, e.g. self.ts[:, None] vs. self.ts[:, 2]
-        with tm.assertRaisesRegexp(ValueError, 'tuple-index'):
+        with tm.assert_raises_regex(ValueError, 'tuple-index'):
             self.ts[:, 2]
-        with tm.assertRaisesRegexp(ValueError, 'tuple-index'):
+        with tm.assert_raises_regex(ValueError, 'tuple-index'):
             self.ts[:, 2] = 2
 
         # weird lists. [slice(0, 5)] will work but not two slices
@@ -1206,11 +1206,11 @@ class TestSeriesIndexing(TestData, tm.TestCase):
         ]
 
         for cond in conds:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 s.where(cond)
 
         msg = "Array conditional must be same shape as self"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.where([True])
 
     def test_where_ndframe_align(self):
@@ -1218,7 +1218,7 @@ class TestSeriesIndexing(TestData, tm.TestCase):
         s = Series([1, 2, 3])
 
         cond = [True]
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.where(cond)
 
         expected = Series([1, np.nan, np.nan])
@@ -1227,7 +1227,7 @@ class TestSeriesIndexing(TestData, tm.TestCase):
         tm.assert_series_equal(out, expected)
 
         cond = np.array([False, True, False, True])
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             s.where(cond)
 
         expected = Series([np.nan, 2, np.nan])
diff --git a/pandas/tests/series/test_operators.py b/pandas/tests/series/test_operators.py
index 159b29aca..89ed7975e 100644
--- a/pandas/tests/series/test_operators.py
+++ b/pandas/tests/series/test_operators.py
@@ -612,7 +612,7 @@ class TestSeriesOperators(TestData, tm.TestCase):
             # defined
             for op_str in ops:
                 op = getattr(get_ser, op_str, None)
-                with tm.assertRaisesRegexp(TypeError, 'operate'):
+                with tm.assert_raises_regex(TypeError, 'operate'):
                     op(test_ser)
 
         # ## timedelta64 ###
@@ -1260,7 +1260,7 @@ class TestSeriesOperators(TestData, tm.TestCase):
         #
         msg = 'No axis named 1 for object type'
         for op in ['eq', 'ne', 'le', 'le', 'gt', 'ge']:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 getattr(left, op)(right, axis=1)
 
     def test_comparison_flex_alignment(self):
@@ -1539,23 +1539,23 @@ class TestSeriesOperators(TestData, tm.TestCase):
         for l, r in [(s1, s2), (s2, s1), (s3, s4), (s4, s3)]:
 
             msg = "Can only compare identically-labeled Series objects"
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l == r
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l != r
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l < r
 
             msg = "Can only compare identically-labeled DataFrame objects"
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l.to_frame() == r.to_frame()
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l.to_frame() != r.to_frame()
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 l.to_frame() < r.to_frame()
 
     def test_bool_ops_df_compat(self):
diff --git a/pandas/tests/series/test_period.py b/pandas/tests/series/test_period.py
index a67d097f3..fdc12459f 100644
--- a/pandas/tests/series/test_period.py
+++ b/pandas/tests/series/test_period.py
@@ -161,10 +161,12 @@ class TestSeriesPeriod(tm.TestCase):
 
             # different base freq
             msg = "Input has different freq=A-DEC from Period"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 base <= Period('2011', freq='A')
 
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 Period('2011', freq='A') >= base
 
     def test_comp_series_period_series(self):
@@ -199,7 +201,8 @@ class TestSeriesPeriod(tm.TestCase):
 
             # different base freq
             msg = "Input has different freq=A-DEC from Period"
-            with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
                 base <= s2
 
     def test_comp_series_period_object(self):
@@ -244,5 +247,5 @@ class TestSeriesPeriod(tm.TestCase):
         for kind in ['inner', 'outer', 'left', 'right']:
             ts.align(ts[::2], join=kind)
         msg = "Input has different freq=D from PeriodIndex\\(freq=A-DEC\\)"
-        with tm.assertRaisesRegexp(period.IncompatibleFrequency, msg):
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
             ts + ts.asfreq('D', how="end")
diff --git a/pandas/tests/series/test_quantile.py b/pandas/tests/series/test_quantile.py
index e61297bdc..6f9c65e37 100644
--- a/pandas/tests/series/test_quantile.py
+++ b/pandas/tests/series/test_quantile.py
@@ -43,7 +43,7 @@ class TestSeriesQuantile(TestData, tm.TestCase):
 
         msg = 'percentiles should all be in the interval \\[0, 1\\]'
         for invalid in [-1, 2, [0.5, -1], [0.5, 2]]:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 self.ts.quantile(invalid)
 
     def test_quantile_multi(self):
@@ -109,11 +109,11 @@ class TestSeriesQuantile(TestData, tm.TestCase):
 
         # interpolation other than linear
         expErrMsg = "Interpolation methods other than "
-        with tm.assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             self.ts.quantile(0.9, interpolation='nearest')
 
         # object dtype
-        with tm.assertRaisesRegexp(ValueError, expErrMsg):
+        with tm.assert_raises_regex(ValueError, expErrMsg):
             q = Series(self.ts, dtype=object).quantile(0.7,
                                                        interpolation='higher')
 
diff --git a/pandas/tests/series/test_replace.py b/pandas/tests/series/test_replace.py
index a9a9204cf..ee7b264bd 100644
--- a/pandas/tests/series/test_replace.py
+++ b/pandas/tests/series/test_replace.py
@@ -78,7 +78,7 @@ class TestSeriesReplace(TestData, tm.TestCase):
 
         # make sure that we aren't just masking a TypeError because bools don't
         # implement indexing
-        with tm.assertRaisesRegexp(TypeError, 'Cannot compare types .+'):
+        with tm.assert_raises_regex(TypeError, 'Cannot compare types .+'):
             ser.replace([1, 2], [np.nan, 0])
 
         ser = pd.Series([0, 1, 2, 3, 4])
@@ -186,7 +186,7 @@ class TestSeriesReplace(TestData, tm.TestCase):
 
     def test_replace_with_dict_with_bool_keys(self):
         s = pd.Series([True, False, True])
-        with tm.assertRaisesRegexp(TypeError, 'Cannot compare types .+'):
+        with tm.assert_raises_regex(TypeError, 'Cannot compare types .+'):
             s.replace({'asdf': 'asdb', True: 'yes'})
 
     def test_replace2(self):
diff --git a/pandas/tests/sparse/test_array.py b/pandas/tests/sparse/test_array.py
index df14a3139..bb6ff7a0c 100644
--- a/pandas/tests/sparse/test_array.py
+++ b/pandas/tests/sparse/test_array.py
@@ -11,7 +11,7 @@ import numpy as np
 from pandas import _np_version_under1p8
 from pandas.core.sparse.api import SparseArray, SparseSeries
 from pandas.core.sparse.libsparse import IntIndex
-from pandas.util.testing import assert_almost_equal, assertRaisesRegexp
+from pandas.util.testing import assert_almost_equal
 import pandas.util.testing as tm
 
 
@@ -142,8 +142,8 @@ class TestSparseArray(tm.TestCase):
         self.assertEqual(self.zarr[7], 5)
 
         errmsg = re.compile("bounds")
-        assertRaisesRegexp(IndexError, errmsg, lambda: self.arr[11])
-        assertRaisesRegexp(IndexError, errmsg, lambda: self.arr[-11])
+        tm.assert_raises_regex(IndexError, errmsg, lambda: self.arr[11])
+        tm.assert_raises_regex(IndexError, errmsg, lambda: self.arr[-11])
         self.assertEqual(self.arr[-1], self.arr[len(self.arr) - 1])
 
     def test_take(self):
@@ -179,21 +179,22 @@ class TestSparseArray(tm.TestCase):
         tm.assert_sp_array_equal(self.arr.take([-4, -3, -2]), exp)
 
     def test_bad_take(self):
-        assertRaisesRegexp(IndexError, "bounds", lambda: self.arr.take(11))
+        tm.assert_raises_regex(
+            IndexError, "bounds", lambda: self.arr.take(11))
         pytest.raises(IndexError, lambda: self.arr.take(-11))
 
     def test_take_invalid_kwargs(self):
         msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assertRaisesRegexp(TypeError, msg, self.arr.take,
-                              [2, 3], foo=2)
+        tm.assert_raises_regex(TypeError, msg, self.arr.take,
+                               [2, 3], foo=2)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, self.arr.take,
-                              [2, 3], out=self.arr)
+        tm.assert_raises_regex(ValueError, msg, self.arr.take,
+                               [2, 3], out=self.arr)
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, self.arr.take,
-                              [2, 3], mode='clip')
+        tm.assert_raises_regex(ValueError, msg, self.arr.take,
+                               [2, 3], mode='clip')
 
     def test_take_filling(self):
         # similar tests as GH 12631
@@ -215,9 +216,9 @@ class TestSparseArray(tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             sparse.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             sparse.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -247,9 +248,9 @@ class TestSparseArray(tm.TestCase):
 
         msg = ('When allow_fill=True and fill_value is not None, '
                'all indices must be >= -1')
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             sparse.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             sparse.take(np.array([1, 0, -5]), fill_value=True)
 
         with pytest.raises(IndexError):
@@ -283,12 +284,12 @@ class TestSparseArray(tm.TestCase):
         def setslice():
             self.arr[1:5] = 2
 
-        assertRaisesRegexp(TypeError, "item assignment", setitem)
-        assertRaisesRegexp(TypeError, "item assignment", setslice)
+        tm.assert_raises_regex(TypeError, "item assignment", setitem)
+        tm.assert_raises_regex(TypeError, "item assignment", setslice)
 
     def test_constructor_from_too_large_array(self):
-        assertRaisesRegexp(TypeError, "expected dimension <= 1 data",
-                           SparseArray, np.arange(10).reshape((2, 5)))
+        tm.assert_raises_regex(TypeError, "expected dimension <= 1 data",
+                               SparseArray, np.arange(10).reshape((2, 5)))
 
     def test_constructor_from_sparse(self):
         res = SparseArray(self.zarr)
@@ -354,16 +355,16 @@ class TestSparseArray(tm.TestCase):
         self.assertFalse((self.arr.sp_values[:3] == 27).any())
 
         msg = "unable to coerce current fill_value nan to int64 dtype"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.arr.astype('i8')
 
         arr = SparseArray([0, np.nan, 0, 1])
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.astype('i8')
 
         arr = SparseArray([0, np.nan, 0, 1], fill_value=0)
         msg = 'Cannot convert non-finite values \\(NA or inf\\) to integer'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.astype('i8')
 
     def test_astype_all(self):
@@ -390,11 +391,11 @@ class TestSparseArray(tm.TestCase):
 
         # coerces to int
         msg = "unable to set fill_value 3\\.1 to int64 dtype"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.fill_value = 3.1
 
         msg = "unable to set fill_value nan to int64 dtype"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.fill_value = np.nan
 
         arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool)
@@ -403,17 +404,17 @@ class TestSparseArray(tm.TestCase):
 
         # coerces to bool
         msg = "unable to set fill_value 0 to bool dtype"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.fill_value = 0
 
         msg = "unable to set fill_value nan to bool dtype"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             arr.fill_value = np.nan
 
         # invalid
         msg = "fill_value must be a scalar"
         for val in [[1, 2, 3], np.array([1, 2]), (1, 2, 3)]:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 arr.fill_value = val
 
     def test_copy_shallow(self):
@@ -682,12 +683,12 @@ class TestSparseArrayAnalytics(tm.TestCase):
         self.assertEqual(out, 40.0)
 
         msg = "the 'dtype' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.sum,
-                              SparseArray(data), dtype=np.int64)
+        tm.assert_raises_regex(ValueError, msg, np.sum,
+                               SparseArray(data), dtype=np.int64)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.sum,
-                              SparseArray(data), out=out)
+        tm.assert_raises_regex(ValueError, msg, np.sum,
+                               SparseArray(data), out=out)
 
     def test_cumsum(self):
         non_null_data = np.array([1, 2, 3, 4, 5], dtype=float)
@@ -711,7 +712,7 @@ class TestSparseArrayAnalytics(tm.TestCase):
 
             axis = 1  # SparseArray currently 1-D, so only axis = 0 is valid.
             msg = "axis\\(={axis}\\) out of bounds".format(axis=axis)
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 SparseArray(data).cumsum(axis=axis)
 
     def test_numpy_cumsum(self):
@@ -735,12 +736,12 @@ class TestSparseArrayAnalytics(tm.TestCase):
             tm.assert_sp_array_equal(out, expected)
 
             msg = "the 'dtype' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                                  SparseArray(data), dtype=np.int64)
+            tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                                   SparseArray(data), dtype=np.int64)
 
             msg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                                  SparseArray(data), out=out)
+            tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                                   SparseArray(data), out=out)
 
     def test_mean(self):
         data = np.arange(10).astype(float)
@@ -761,12 +762,12 @@ class TestSparseArrayAnalytics(tm.TestCase):
         self.assertEqual(out, 40.0 / 9)
 
         msg = "the 'dtype' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.mean,
-                              SparseArray(data), dtype=np.int64)
+        tm.assert_raises_regex(ValueError, msg, np.mean,
+                               SparseArray(data), dtype=np.int64)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.mean,
-                              SparseArray(data), out=out)
+        tm.assert_raises_regex(ValueError, msg, np.mean,
+                               SparseArray(data), out=out)
 
     def test_ufunc(self):
         # GH 13853 make sure ufunc is applied to fill_value
diff --git a/pandas/tests/sparse/test_frame.py b/pandas/tests/sparse/test_frame.py
index cf6d80e9c..a5080bbd8 100644
--- a/pandas/tests/sparse/test_frame.py
+++ b/pandas/tests/sparse/test_frame.py
@@ -151,10 +151,10 @@ class TestSparseDataFrame(tm.TestCase, SharedWithSparse):
                       level=1)
 
         # wrong length index / columns
-        with tm.assertRaisesRegexp(ValueError, "^Index length"):
+        with tm.assert_raises_regex(ValueError, "^Index length"):
             SparseDataFrame(self.frame.values, index=self.frame.index[:-1])
 
-        with tm.assertRaisesRegexp(ValueError, "^Column length"):
+        with tm.assert_raises_regex(ValueError, "^Column length"):
             SparseDataFrame(self.frame.values, columns=self.frame.columns[:-1])
 
     # GH 9272
@@ -798,8 +798,8 @@ class TestSparseDataFrame(tm.TestCase, SharedWithSparse):
         right = self.frame.loc[:, ['B', 'D']]
         pytest.raises(Exception, left.join, right)
 
-        with tm.assertRaisesRegexp(ValueError,
-                                   'Other Series must have a name'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Other Series must have a name'):
             self.frame.join(Series(
                 np.random.randn(len(self.frame)), index=self.frame.index))
 
@@ -1042,7 +1042,7 @@ class TestSparseDataFrame(tm.TestCase, SharedWithSparse):
         tm.assert_sp_frame_equal(result, sdf)
 
         msg = "the 'axes' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.transpose, sdf, axes=1)
+        tm.assert_raises_regex(ValueError, msg, np.transpose, sdf, axes=1)
 
     def test_combine_first(self):
         df = self.frame
@@ -1303,12 +1303,12 @@ class TestSparseDataFrameAnalytics(tm.TestCase):
         tm.assert_sp_frame_equal(result, expected)
 
         msg = "the 'dtype' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                              self.frame, dtype=np.int64)
+        tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                               self.frame, dtype=np.int64)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                              self.frame, out=result)
+        tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                               self.frame, out=result)
 
     def test_numpy_func_call(self):
         # no exception should be raised even though
diff --git a/pandas/tests/sparse/test_indexing.py b/pandas/tests/sparse/test_indexing.py
index cf91e4162..bfa0a0440 100644
--- a/pandas/tests/sparse/test_indexing.py
+++ b/pandas/tests/sparse/test_indexing.py
@@ -440,7 +440,7 @@ class TestSparseSeriesIndexing(tm.TestCase):
 
                 msg = ("iLocation based boolean indexing cannot use an "
                        "indexable as a mask")
-                with tm.assertRaisesRegexp(ValueError, msg):
+                with tm.assert_raises_regex(ValueError, msg):
                     s.iloc[indexer]
 
 
diff --git a/pandas/tests/sparse/test_libsparse.py b/pandas/tests/sparse/test_libsparse.py
index 14038777f..63ed11845 100644
--- a/pandas/tests/sparse/test_libsparse.py
+++ b/pandas/tests/sparse/test_libsparse.py
@@ -479,37 +479,37 @@ class TestIntIndex(tm.TestCase):
         # Too many indices than specified in self.length
         msg = "Too many indices"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=1, indices=[1, 2, 3])
 
         # No index can be negative.
         msg = "No index can be less than zero"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, -2, 3])
 
         # No index can be negative.
         msg = "No index can be less than zero"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, -2, 3])
 
         # All indices must be less than the length.
         msg = "All indices must be less than the length"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, 2, 5])
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, 2, 6])
 
         # Indices must be strictly ascending.
         msg = "Indices must be strictly increasing"
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, 3, 2])
 
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             IntIndex(length=5, indices=[1, 3, 3])
 
     def test_int_internal(self):
diff --git a/pandas/tests/sparse/test_series.py b/pandas/tests/sparse/test_series.py
index 1502aaa7e..e0b0809c7 100644
--- a/pandas/tests/sparse/test_series.py
+++ b/pandas/tests/sparse/test_series.py
@@ -506,12 +506,12 @@ class TestSparseSeries(tm.TestCase, SharedWithSparse):
                                np.take(sp.to_dense(), indices, axis=0))
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.take,
-                              sp, indices, out=np.empty(sp.shape))
+        tm.assert_raises_regex(ValueError, msg, np.take,
+                               sp, indices, out=np.empty(sp.shape))
 
         msg = "the 'mode' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.take,
-                              sp, indices, mode='clip')
+        tm.assert_raises_regex(ValueError, msg, np.take,
+                               sp, indices, mode='clip')
 
     def test_setitem(self):
         self.bseries[5] = 7.
@@ -703,8 +703,8 @@ class TestSparseSeries(tm.TestCase, SharedWithSparse):
         first_series = SparseSeries(values1,
                                     sparse_index=IntIndex(length, index1),
                                     fill_value=nan)
-        with tm.assertRaisesRegexp(TypeError,
-                                   'new index must be a SparseIndex'):
+        with tm.assert_raises_regex(TypeError,
+                                    'new index must be a SparseIndex'):
             reindexed = first_series.sparse_reindex(0)  # noqa
 
     def test_repr(self):
@@ -797,7 +797,7 @@ class TestSparseSeries(tm.TestCase, SharedWithSparse):
         # must have NaN fill value
         data = {'a': SparseSeries(np.arange(7), sparse_index=expected2,
                                   fill_value=0)}
-        with tm.assertRaisesRegexp(TypeError, "NaN fill value"):
+        with tm.assert_raises_regex(TypeError, "NaN fill value"):
             spf.homogenize(data)
 
     def test_fill_value_corner(self):
@@ -1332,7 +1332,7 @@ class TestSparseSeriesAnalytics(tm.TestCase):
 
         axis = 1  # Series is 1-D, so only axis = 0 is valid.
         msg = "No axis named {axis}".format(axis=axis)
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             self.bseries.cumsum(axis=axis)
 
     def test_numpy_cumsum(self):
@@ -1345,12 +1345,12 @@ class TestSparseSeriesAnalytics(tm.TestCase):
         tm.assert_series_equal(result, expected)
 
         msg = "the 'dtype' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                              self.bseries, dtype=np.int64)
+        tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                               self.bseries, dtype=np.int64)
 
         msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.cumsum,
-                              self.zbseries, out=result)
+        tm.assert_raises_regex(ValueError, msg, np.cumsum,
+                               self.zbseries, out=result)
 
     def test_numpy_func_call(self):
         # no exception should be raised even though
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index 01c18dc64..96628322e 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -133,15 +133,16 @@ class TestSafeSort(tm.TestCase):
             pytest.raises(TypeError, algos.safe_sort, arr)
 
     def test_exceptions(self):
-        with tm.assertRaisesRegexp(TypeError,
-                                   "Only list-like objects are allowed"):
+        with tm.assert_raises_regex(TypeError,
+                                    "Only list-like objects are allowed"):
             algos.safe_sort(values=1)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "Only list-like objects or None"):
+        with tm.assert_raises_regex(TypeError,
+                                    "Only list-like objects or None"):
             algos.safe_sort(values=[0, 1, 2], labels=1)
 
-        with tm.assertRaisesRegexp(ValueError, "values should be unique"):
+        with tm.assert_raises_regex(ValueError,
+                                    "values should be unique"):
             algos.safe_sort(values=[0, 1, 2, 1], labels=[0, 1])
 
 
@@ -1152,7 +1153,7 @@ class TestRank(tm.TestCase):
         arr = np.array([[[1, 2, 3], [4, 5, 6], [7, 8, 9]]])
         msg = "Array with ndim > 2 are not supported"
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             algos.rank(arr)
 
 
@@ -1335,27 +1336,27 @@ def test_int64_add_overflow():
     m = np.iinfo(np.int64).max
     n = np.iinfo(np.int64).min
 
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, m]), m)
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([n, n]), n)
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([n, n]), np.array([n, n]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, n]), np.array([n, n]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                    arr_mask=np.array([False, True]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                    b_mask=np.array([False, True]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                    arr_mask=np.array([False, True]),
                                    b_mask=np.array([False, True]))
-    with tm.assertRaisesRegexp(OverflowError, msg):
+    with tm.assert_raises_regex(OverflowError, msg):
         with tm.assert_produces_warning(RuntimeWarning):
             algos.checked_add_with_arr(np.array([m, m]),
                                        np.array([np.nan, m]))
@@ -1364,15 +1365,15 @@ def test_int64_add_overflow():
     # the addition overflows. We don't check the result but just
     # the fact that an OverflowError is not raised.
     with pytest.raises(AssertionError):
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                        arr_mask=np.array([True, True]))
     with pytest.raises(AssertionError):
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                        b_mask=np.array([True, True]))
     with pytest.raises(AssertionError):
-        with tm.assertRaisesRegexp(OverflowError, msg):
+        with tm.assert_raises_regex(OverflowError, msg):
             algos.checked_add_with_arr(np.array([m, m]), np.array([m, m]),
                                        arr_mask=np.array([True, False]),
                                        b_mask=np.array([False, True]))
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index bec743fac..86343e441 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -47,7 +47,8 @@ class CheckImmutable(object):
     def check_mutable_error(self, *args, **kwargs):
         # Pass whatever function you normally would to assertRaisesRegexp
         # (after the Exception kind).
-        tm.assertRaisesRegexp(TypeError, self.mutable_regex, *args, **kwargs)
+        tm.assert_raises_regex(
+            TypeError, self.mutable_regex, *args, **kwargs)
 
     def test_no_mutable_funcs(self):
         def setitem():
@@ -831,7 +832,7 @@ class TestIndexOps(Ops):
                 result = idx.drop_duplicates(keep=False)
                 tm.assert_index_equal(result, idx[~expected])
 
-                with tm.assertRaisesRegexp(
+                with tm.assert_raises_regex(
                         TypeError, r"drop_duplicates\(\) got an unexpected "
                         "keyword argument"):
                     idx.drop_duplicates(inplace=True)
@@ -995,10 +996,10 @@ class TestTranspose(Ops):
 
     def test_transpose_non_default_axes(self):
         for obj in self.objs:
-            tm.assertRaisesRegexp(ValueError, self.errmsg,
-                                  obj.transpose, 1)
-            tm.assertRaisesRegexp(ValueError, self.errmsg,
-                                  obj.transpose, axes=1)
+            tm.assert_raises_regex(ValueError, self.errmsg,
+                                   obj.transpose, 1)
+            tm.assert_raises_regex(ValueError, self.errmsg,
+                                   obj.transpose, axes=1)
 
     def test_numpy_transpose(self):
         for obj in self.objs:
@@ -1007,8 +1008,8 @@ class TestTranspose(Ops):
             else:
                 tm.assert_series_equal(np.transpose(obj), obj)
 
-            tm.assertRaisesRegexp(ValueError, self.errmsg,
-                                  np.transpose, obj, axes=1)
+            tm.assert_raises_regex(ValueError, self.errmsg,
+                                   np.transpose, obj, axes=1)
 
 
 class TestNoNewAttributesMixin(tm.TestCase):
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index d516448ac..bbcd42b14 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -452,10 +452,10 @@ class TestCategorical(tm.TestCase):
         # This should be a boolean.
         ordered = np.array([0, 1, 2])
 
-        with tm.assertRaisesRegexp(exp_err, exp_msg):
+        with tm.assert_raises_regex(exp_err, exp_msg):
             Categorical([1, 2, 3], ordered=ordered)
 
-        with tm.assertRaisesRegexp(exp_err, exp_msg):
+        with tm.assert_raises_regex(exp_err, exp_msg):
             Categorical.from_codes([0, 0, 1], categories=['a', 'b', 'c'],
                                    ordered=ordered)
 
@@ -587,16 +587,16 @@ class TestCategorical(tm.TestCase):
                                     check_dtype=False)
 
         msg = "the 'kind' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.argsort,
-                              c, kind='mergesort')
+        tm.assert_raises_regex(ValueError, msg, np.argsort,
+                               c, kind='mergesort')
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.argsort,
-                              c, axis=0)
+        tm.assert_raises_regex(ValueError, msg, np.argsort,
+                               c, axis=0)
 
         msg = "the 'order' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.argsort,
-                              c, order='C')
+        tm.assert_raises_regex(ValueError, msg, np.argsort,
+                               c, order='C')
 
     def test_na_flags_int_categories(self):
         # #1457
@@ -835,9 +835,9 @@ Categories (3, object): [ああああ, いいいいい, ううううううう]""
 
         # removed in 0.19.0
         msg = "can\'t set attribute"
-        with tm.assertRaisesRegexp(AttributeError, msg):
+        with tm.assert_raises_regex(AttributeError, msg):
             cat.ordered = True
-        with tm.assertRaisesRegexp(AttributeError, msg):
+        with tm.assert_raises_regex(AttributeError, msg):
             cat.ordered = False
 
     def test_set_categories(self):
@@ -1955,7 +1955,7 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         # invalid accessor
         pytest.raises(AttributeError, lambda: Series([1, 2, 3]).cat)
-        tm.assertRaisesRegexp(
+        tm.assert_raises_regex(
             AttributeError,
             r"Can only use .cat accessor with a 'category' dtype",
             lambda: Series([1, 2, 3]).cat)
@@ -3987,7 +3987,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
         tm.assert_categorical_equal(np.repeat(cat, 2), exp)
 
         msg = "the 'axis' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.repeat, cat, 2, axis=1)
+        tm.assert_raises_regex(ValueError, msg, np.repeat, cat, 2, axis=1)
 
     def test_reshape(self):
         cat = pd.Categorical([], categories=["a", "b"])
@@ -4012,7 +4012,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             msg = "can only specify one unknown dimension"
             cat = pd.Categorical(["a", "b"], categories=["a", "b"])
-            tm.assertRaisesRegexp(ValueError, msg, cat.reshape, (-2, -1))
+            tm.assert_raises_regex(ValueError, msg, cat.reshape, (-2, -1))
 
     def test_numpy_reshape(self):
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
@@ -4021,8 +4021,8 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
 
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             msg = "the 'order' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.reshape,
-                                  cat, cat.shape, order='F')
+            tm.assert_raises_regex(ValueError, msg, np.reshape,
+                                   cat, cat.shape, order='F')
 
     def test_na_actions(self):
 
@@ -4223,15 +4223,16 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
         assert isinstance(s.cat, CategoricalAccessor)
 
         invalid = Series([1])
-        with tm.assertRaisesRegexp(AttributeError, "only use .cat accessor"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "only use .cat accessor"):
             invalid.cat
         self.assertFalse(hasattr(invalid, 'cat'))
 
     def test_cat_accessor_no_new_attributes(self):
         # https://github.com/pandas-dev/pandas/issues/10673
         c = Series(list('aabbcde')).astype('category')
-        with tm.assertRaisesRegexp(AttributeError,
-                                   "You cannot add any new attribute"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "You cannot add any new attribute"):
             c.cat.xlabel = "a"
 
     def test_str_accessor_api_for_categorical(self):
@@ -4304,8 +4305,9 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
                 tm.assert_series_equal(res, exp)
 
         invalid = Series([1, 2, 3]).astype('category')
-        with tm.assertRaisesRegexp(AttributeError,
-                                   "Can only use .str accessor with string"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "Can only use .str "
+                                    "accessor with string"):
             invalid.str
         self.assertFalse(hasattr(invalid, 'str'))
 
@@ -4385,7 +4387,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
                 tm.assert_almost_equal(res, exp)
 
         invalid = Series([1, 2, 3]).astype('category')
-        with tm.assertRaisesRegexp(
+        with tm.assert_raises_regex(
                 AttributeError, "Can only use .dt accessor with datetimelike"):
             invalid.dt
         self.assertFalse(hasattr(invalid, 'str'))
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 435fca14d..d7dbaccb8 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -12,7 +12,7 @@ import pandas.util.testing as tm
 
 def test_mut_exclusive():
     msg = "mutually exclusive arguments: '[ab]' and '[ab]'"
-    with tm.assertRaisesRegexp(TypeError, msg):
+    with tm.assert_raises_regex(TypeError, msg):
         com._mut_exclusive(a=1, b=2)
     assert com._mut_exclusive(a=1, b=None) == 1
     assert com._mut_exclusive(major=None, major_axis=None) is None
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index ddbaedc3e..14e08411f 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -390,22 +390,22 @@ class TestExpressions(tm.TestCase):
                 f = getattr(operator, name)
                 err_msg = re.escape(msg % op)
 
-                with tm.assertRaisesRegexp(NotImplementedError, err_msg):
+                with tm.assert_raises_regex(NotImplementedError, err_msg):
                     f(df, df)
 
-                with tm.assertRaisesRegexp(NotImplementedError, err_msg):
+                with tm.assert_raises_regex(NotImplementedError, err_msg):
                     f(df.a, df.b)
 
-                with tm.assertRaisesRegexp(NotImplementedError, err_msg):
+                with tm.assert_raises_regex(NotImplementedError, err_msg):
                     f(df.a, True)
 
-                with tm.assertRaisesRegexp(NotImplementedError, err_msg):
+                with tm.assert_raises_regex(NotImplementedError, err_msg):
                     f(False, df.a)
 
-                with tm.assertRaisesRegexp(TypeError, err_msg):
+                with tm.assert_raises_regex(TypeError, err_msg):
                     f(False, df)
 
-                with tm.assertRaisesRegexp(TypeError, err_msg):
+                with tm.assert_raises_regex(TypeError, err_msg):
                     f(df, True)
 
     def test_bool_ops_warn_on_arithmetic(self):
diff --git a/pandas/tests/test_internals.py b/pandas/tests/test_internals.py
index f58a6d4b1..61b4369d2 100644
--- a/pandas/tests/test_internals.py
+++ b/pandas/tests/test_internals.py
@@ -1090,8 +1090,8 @@ class TestBlockPlacement(tm.TestCase):
 
     def test_unbounded_slice_raises(self):
         def assert_unbounded_slice_error(slc):
-            tm.assertRaisesRegexp(ValueError, "unbounded slice",
-                                  lambda: BlockPlacement(slc))
+            tm.assert_raises_regex(ValueError, "unbounded slice",
+                                   lambda: BlockPlacement(slc))
 
         assert_unbounded_slice_error(slice(None, None))
         assert_unbounded_slice_error(slice(10, None))
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index e81e6e2d9..f350ef435 100755
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -320,7 +320,7 @@ class TestMultiLevel(Base, tm.TestCase):
         np.putmask(values[:-1], values[:-1] < 0, 2)
         tm.assert_almost_equal(df.values, values)
 
-        with tm.assertRaisesRegexp(TypeError, 'boolean values only'):
+        with tm.assert_raises_regex(TypeError, 'boolean values only'):
             df[df * 0] = 2
 
     def test_frame_getitem_setitem_slice(self):
@@ -755,7 +755,8 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
 
         # can't call with level on regular DataFrame
         df = tm.makeTimeDataFrame()
-        tm.assertRaisesRegexp(TypeError, 'hierarchical', df.count, level=0)
+        tm.assert_raises_regex(
+            TypeError, 'hierarchical', df.count, level=0)
 
         self.frame['D'] = 'foo'
         result = self.frame.count(level=0, numeric_only=True)
@@ -792,9 +793,10 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         tm.assert_frame_equal(result, expected)
 
     def test_get_level_number_out_of_bounds(self):
-        with tm.assertRaisesRegexp(IndexError, "Too many levels"):
+        with tm.assert_raises_regex(IndexError, "Too many levels"):
             self.frame.index._get_level_number(2)
-        with tm.assertRaisesRegexp(IndexError, "not a valid level number"):
+        with tm.assert_raises_regex(IndexError,
+                                    "not a valid level number"):
             self.frame.index._get_level_number(-3)
 
     def test_unstack(self):
@@ -1011,16 +1013,17 @@ Thur,Lunch,Yes,51.51,17"""
         unstacked = self.ymd.unstack(['year', 'month'])
 
         # Can't use mixture of names and numbers to stack
-        with tm.assertRaisesRegexp(ValueError, "level should contain"):
+        with tm.assert_raises_regex(ValueError, "level should contain"):
             unstacked.stack([0, 'month'])
 
     def test_stack_multiple_out_of_bounds(self):
         # nlevels == 3
         unstacked = self.ymd.unstack(['year', 'month'])
 
-        with tm.assertRaisesRegexp(IndexError, "Too many levels"):
+        with tm.assert_raises_regex(IndexError, "Too many levels"):
             unstacked.stack([2, 3])
-        with tm.assertRaisesRegexp(IndexError, "not a valid level number"):
+        with tm.assert_raises_regex(IndexError,
+                                    "not a valid level number"):
             unstacked.stack([-4, -3])
 
     def test_unstack_period_series(self):
@@ -1275,10 +1278,10 @@ Thur,Lunch,Yes,51.51,17"""
         expected = self.ymd.T.swaplevel(0, 1, axis=1).swaplevel(1, 2, axis=1)
         tm.assert_frame_equal(result, expected)
 
-        with tm.assertRaisesRegexp(TypeError, 'hierarchical axis'):
+        with tm.assert_raises_regex(TypeError, 'hierarchical axis'):
             self.ymd.reorder_levels([1, 2], axis=1)
 
-        with tm.assertRaisesRegexp(IndexError, 'Too many levels'):
+        with tm.assert_raises_regex(IndexError, 'Too many levels'):
             self.ymd.index.reorder_levels([1, 2, 3])
 
     def test_insert_index(self):
@@ -2244,11 +2247,10 @@ Thur,Lunch,Yes,51.51,17"""
         result = df[['B']].reset_index()
         tm.assert_frame_equal(result, expected)
 
-        # GH 16120
-        # already existing column
-        with tm.assertRaisesRegexp(ValueError,
-                                   ("cannot insert \('A', ''\), "
-                                    "already exists")):
+        # gh-16120: already existing column
+        with tm.assert_raises_regex(ValueError,
+                                    ("cannot insert \('A', ''\), "
+                                     "already exists")):
             df.reset_index()
 
     def test_set_index_period(self):
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 17bc06b5e..322ea32a9 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -23,9 +23,8 @@ from pandas.compat import range, lrange, StringIO, OrderedDict, signature
 from pandas.tseries.offsets import BDay, MonthEnd
 from pandas.util.testing import (assert_panel_equal, assert_frame_equal,
                                  assert_series_equal, assert_almost_equal,
-                                 ensure_clean, assertRaisesRegexp,
-                                 makeCustomDataframe as mkdf,
-                                 makeMixedDataFrame)
+                                 ensure_clean, makeMixedDataFrame,
+                                 makeCustomDataframe as mkdf)
 import pandas.core.panel as panelm
 import pandas.util.testing as tm
 
@@ -180,8 +179,8 @@ class SafeForLongAndSparse(object):
 
         # Unimplemented numeric_only parameter.
         if 'numeric_only' in signature(f).args:
-            tm.assertRaisesRegexp(NotImplementedError, name, f,
-                                  numeric_only=True)
+            tm.assert_raises_regex(NotImplementedError, name, f,
+                                   numeric_only=True)
 
 
 class SafeForSparse(object):
@@ -227,10 +226,10 @@ class SafeForSparse(object):
         self.assertEqual(self.panel._get_axis_number('major'), 1)
         self.assertEqual(self.panel._get_axis_number('minor'), 2)
 
-        with tm.assertRaisesRegexp(ValueError, "No axis named foo"):
+        with tm.assert_raises_regex(ValueError, "No axis named foo"):
             self.panel._get_axis_number('foo')
 
-        with tm.assertRaisesRegexp(ValueError, "No axis named foo"):
+        with tm.assert_raises_regex(ValueError, "No axis named foo"):
             self.panel.__ge__(self.panel, axis='foo')
 
     def test_get_axis_name(self):
@@ -514,9 +513,10 @@ class CheckIndexing(object):
 
             # bad shape
             p = Panel(np.random.randn(4, 3, 2))
-            with tm.assertRaisesRegexp(ValueError,
-                                       r"shape of value must be \(3, 2\), "
-                                       r"shape of given object was \(4, 2\)"):
+            with tm.assert_raises_regex(ValueError,
+                                        r"shape of value must be "
+                                        r"\(3, 2\), shape of given "
+                                        r"object was \(4, 2\)"):
                 p[0] = np.random.randn(4, 2)
 
     def test_setitem_ndarray(self):
@@ -874,8 +874,9 @@ class CheckIndexing(object):
                     result = self.panel.get_value(item, mjr, mnr)
                     expected = self.panel[item][mnr][mjr]
                     assert_almost_equal(result, expected)
-        with tm.assertRaisesRegexp(TypeError,
-                                   "There must be an argument for each axis"):
+        with tm.assert_raises_regex(TypeError,
+                                    "There must be an argument "
+                                    "for each axis"):
             self.panel.get_value('a')
 
     def test_set_value(self):
@@ -897,7 +898,7 @@ class CheckIndexing(object):
 
             msg = ("There must be an argument for each "
                    "axis plus the value provided")
-            with tm.assertRaisesRegexp(TypeError, msg):
+            with tm.assert_raises_regex(TypeError, msg):
                 self.panel.set_value('a')
 
 
@@ -1041,7 +1042,7 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
 
     def test_constructor_fails_with_not_3d_input(self):
         with catch_warnings(record=True):
-            with tm.assertRaisesRegexp(ValueError, "The number of dimensions required is 3"):  # noqa
+            with tm.assert_raises_regex(ValueError, "The number of dimensions required is 3"):  # noqa
                     Panel(np.random.randn(10, 2))
 
     def test_consolidate(self):
@@ -1181,28 +1182,31 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
                 Panel(np.random.randn(3, 4, 5),
                       lrange(4), lrange(5), lrange(5))
 
-            assertRaisesRegexp(ValueError,
-                               r"Shape of passed values is \(3, 4, 5\), "
-                               r"indices imply \(4, 5, 5\)",
-                               testit)
+            tm.assert_raises_regex(ValueError,
+                                   r"Shape of passed values is "
+                                   r"\(3, 4, 5\), indices imply "
+                                   r"\(4, 5, 5\)",
+                                   testit)
 
             def testit():
                 Panel(np.random.randn(3, 4, 5),
                       lrange(5), lrange(4), lrange(5))
 
-            assertRaisesRegexp(ValueError,
-                               r"Shape of passed values is \(3, 4, 5\), "
-                               r"indices imply \(5, 4, 5\)",
-                               testit)
+            tm.assert_raises_regex(ValueError,
+                                   r"Shape of passed values is "
+                                   r"\(3, 4, 5\), indices imply "
+                                   r"\(5, 4, 5\)",
+                                   testit)
 
             def testit():
                 Panel(np.random.randn(3, 4, 5),
                       lrange(5), lrange(5), lrange(4))
 
-            assertRaisesRegexp(ValueError,
-                               r"Shape of passed values is \(3, 4, 5\), "
-                               r"indices imply \(5, 5, 4\)",
-                               testit)
+            tm.assert_raises_regex(ValueError,
+                                   r"Shape of passed values is "
+                                   r"\(3, 4, 5\), indices imply "
+                                   r"\(5, 5, 4\)",
+                                   testit)
 
     def test_conform(self):
         with catch_warnings(record=True):
@@ -1660,12 +1664,12 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
             assert_panel_equal(result, expected)
 
             # duplicate axes
-            with tm.assertRaisesRegexp(TypeError,
-                                       'not enough/duplicate arguments'):
+            with tm.assert_raises_regex(TypeError,
+                                        'not enough/duplicate arguments'):
                 self.panel.transpose('minor', maj='major', minor='items')
 
-            with tm.assertRaisesRegexp(ValueError,
-                                       'repeated axis in transpose'):
+            with tm.assert_raises_regex(ValueError,
+                                        'repeated axis in transpose'):
                 self.panel.transpose('minor', 'major', major='minor',
                                      minor='items')
 
@@ -1867,7 +1871,7 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
         with catch_warnings(record=True):
             df = DataFrame({'a': [0, 0, 1], 'b': [1, 1, 1], 'c': [1, 2, 3]})
             idf = df.set_index(['a', 'b'])
-            assertRaisesRegexp(
+            tm.assert_raises_regex(
                 ValueError, 'non-uniquely indexed', idf.to_panel)
 
     def test_panel_dups(self):
@@ -1992,8 +1996,8 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
             shifted3 = ps.tshift(freq=BDay())
             assert_panel_equal(shifted, shifted3)
 
-            assertRaisesRegexp(ValueError, 'does not match',
-                               ps.tshift, freq='M')
+            tm.assert_raises_regex(ValueError, 'does not match',
+                                   ps.tshift, freq='M')
 
             # DatetimeIndex
             panel = make_test_panel()
@@ -2108,7 +2112,7 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
             assert_panel_equal(expected, result)
 
             msg = "the 'out' parameter is not supported"
-            tm.assertRaisesRegexp(ValueError, msg, np.round, p, out=p)
+            tm.assert_raises_regex(ValueError, msg, np.round, p, out=p)
 
     def test_multiindex_get(self):
         with catch_warnings(record=True):
@@ -2540,8 +2544,8 @@ class TestLongPanel(tm.TestCase):
     def test_to_sparse(self):
         if isinstance(self.panel, Panel):
             msg = 'sparsifying is not supported'
-            tm.assertRaisesRegexp(NotImplementedError, msg,
-                                  self.panel.to_sparse)
+            tm.assert_raises_regex(NotImplementedError, msg,
+                                   self.panel.to_sparse)
 
     def test_truncate(self):
         with catch_warnings(record=True):
diff --git a/pandas/tests/test_resample.py b/pandas/tests/test_resample.py
index e5795eea1..f5309a985 100644
--- a/pandas/tests/test_resample.py
+++ b/pandas/tests/test_resample.py
@@ -272,7 +272,7 @@ class TestResampleAPI(tm.TestCase):
         pytest.raises(KeyError, g.__getitem__, ['D'])
 
         pytest.raises(KeyError, g.__getitem__, ['A', 'D'])
-        with tm.assertRaisesRegexp(KeyError, '^[^A]+$'):
+        with tm.assert_raises_regex(KeyError, '^[^A]+$'):
             # A should not be referenced as a bad column...
             # will have to rethink regex if you change message!
             g[['A', 'D']]
@@ -983,11 +983,11 @@ class TestDatetimeIndex(Base, tm.TestCase):
 
         for func in ('min', 'max', 'sum', 'prod',
                      'mean', 'var', 'std'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(r, func),
-                                  func, 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(r, func), axis=1)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(r, func),
+                                   func, 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(r, func), axis=1)
 
     def test_resample_how_callables(self):
         # GH 7929
@@ -3081,17 +3081,18 @@ class TestTimeGrouper(tm.TestCase):
         for name, func in zip(index_names, index_funcs):
             index = func(n)
             df = DataFrame({'a': np.random.randn(n)}, index=index)
-            with tm.assertRaisesRegexp(TypeError,
-                                       "Only valid with DatetimeIndex, "
-                                       "TimedeltaIndex or PeriodIndex, "
-                                       "but got an instance of %r" % name):
+            with tm.assert_raises_regex(TypeError,
+                                        "Only valid with "
+                                        "DatetimeIndex, TimedeltaIndex "
+                                        "or PeriodIndex, but got an "
+                                        "instance of %r" % name):
                 df.groupby(TimeGrouper('D'))
 
         # PeriodIndex gives a specific error message
         df = DataFrame({'a': np.random.randn(n)}, index=tm.makePeriodIndex(n))
-        with tm.assertRaisesRegexp(TypeError,
-                                   "axis must be a DatetimeIndex, but "
-                                   "got an instance of 'PeriodIndex'"):
+        with tm.assert_raises_regex(TypeError,
+                                    "axis must be a DatetimeIndex, but "
+                                    "got an instance of 'PeriodIndex'"):
             df.groupby(TimeGrouper('D'))
 
     def test_aaa_group_order(self):
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index 6733fbdc3..db0c2fdc8 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -29,7 +29,8 @@ class TestStringMethods(tm.TestCase):
 
         # GH 9184
         invalid = Series([1])
-        with tm.assertRaisesRegexp(AttributeError, "only use .str accessor"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "only use .str accessor"):
             invalid.str
         self.assertFalse(hasattr(invalid, 'str'))
 
@@ -451,15 +452,15 @@ class TestStringMethods(tm.TestCase):
                      r'(?(3)required )positional arguments?')
 
         repl = lambda: None
-        with tm.assertRaisesRegexp(TypeError, p_err):
+        with tm.assert_raises_regex(TypeError, p_err):
             values.str.replace('a', repl)
 
         repl = lambda m, x: None
-        with tm.assertRaisesRegexp(TypeError, p_err):
+        with tm.assert_raises_regex(TypeError, p_err):
             values.str.replace('a', repl)
 
         repl = lambda m, x, y=None: None
-        with tm.assertRaisesRegexp(TypeError, p_err):
+        with tm.assert_raises_regex(TypeError, p_err):
             values.str.replace('a', repl)
 
         # test regex named groups
@@ -512,13 +513,16 @@ class TestStringMethods(tm.TestCase):
         values = Series(['fooBAD__barBAD__bad', NA])
         pat = re.compile(r'BAD[_]*')
 
-        with tm.assertRaisesRegexp(ValueError, "case and flags cannot be"):
+        with tm.assert_raises_regex(ValueError,
+                                    "case and flags cannot be"):
             result = values.str.replace(pat, '', flags=re.IGNORECASE)
 
-        with tm.assertRaisesRegexp(ValueError, "case and flags cannot be"):
+        with tm.assert_raises_regex(ValueError,
+                                    "case and flags cannot be"):
             result = values.str.replace(pat, '', case=False)
 
-        with tm.assertRaisesRegexp(ValueError, "case and flags cannot be"):
+        with tm.assert_raises_regex(ValueError,
+                                    "case and flags cannot be"):
             result = values.str.replace(pat, '', case=True)
 
         # test with callable
@@ -648,7 +652,7 @@ class TestStringMethods(tm.TestCase):
         # Index only works with one regex group since
         # multi-group would expand to a frame
         idx = Index(['A1', 'A2', 'A3', 'A4', 'B5'])
-        with tm.assertRaisesRegexp(ValueError, "supported"):
+        with tm.assert_raises_regex(ValueError, "supported"):
             idx.str.extract('([AB])([123])', expand=False)
 
         # these should work for both Series and Index
@@ -1124,7 +1128,7 @@ class TestStringMethods(tm.TestCase):
         # no capture groups. (it returns DataFrame with one column for
         # each capture group)
         s = Series(['a3', 'b3', 'd4c2'], name='series_name')
-        with tm.assertRaisesRegexp(ValueError, "no capture groups"):
+        with tm.assert_raises_regex(ValueError, "no capture groups"):
             s.str.extractall(r'[a-z]')
 
     def test_extract_index_one_two_groups(self):
@@ -1504,12 +1508,12 @@ class TestStringMethods(tm.TestCase):
                             dtype=np.int64)
         tm.assert_numpy_array_equal(result.values, expected)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "expected a string object, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "expected a string object, not int"):
             result = values.str.find(0)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "expected a string object, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "expected a string object, not int"):
             result = values.str.rfind(0)
 
     def test_find_nan(self):
@@ -1579,11 +1583,13 @@ class TestStringMethods(tm.TestCase):
                                 dtype=np.int64)
             tm.assert_numpy_array_equal(result.values, expected)
 
-            with tm.assertRaisesRegexp(ValueError, "substring not found"):
+            with tm.assert_raises_regex(ValueError,
+                                        "substring not found"):
                 result = s.str.index('DE')
 
-            with tm.assertRaisesRegexp(TypeError,
-                                       "expected a string object, not int"):
+            with tm.assert_raises_regex(TypeError,
+                                        "expected a string "
+                                        "object, not int"):
                 result = s.str.index(0)
 
         # test with nan
@@ -1667,12 +1673,14 @@ class TestStringMethods(tm.TestCase):
         exp = Series(['XXaXX', 'XXbXX', NA, 'XXcXX', NA, 'eeeeee'])
         tm.assert_almost_equal(result, exp)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not str"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not str"):
             result = values.str.pad(5, fillchar='XY')
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not int"):
             result = values.str.pad(5, fillchar=5)
 
     def test_pad_width(self):
@@ -1680,8 +1688,9 @@ class TestStringMethods(tm.TestCase):
         s = Series(['1', '22', 'a', 'bb'])
 
         for f in ['center', 'ljust', 'rjust', 'zfill', 'pad']:
-            with tm.assertRaisesRegexp(TypeError,
-                                       "width must be of integer type, not*"):
+            with tm.assert_raises_regex(TypeError,
+                                        "width must be of "
+                                        "integer type, not*"):
                 getattr(s.str, f)('f')
 
     def test_translate(self):
@@ -1713,7 +1722,7 @@ class TestStringMethods(tm.TestCase):
                 expected = klass(['abcde', 'abcc', 'cddd', 'cde'])
                 _check(result, expected)
             else:
-                with tm.assertRaisesRegexp(
+                with tm.assert_raises_regex(
                         ValueError, "deletechars is not a valid argument"):
                     result = s.str.translate(table, deletechars='fg')
 
@@ -1802,28 +1811,34 @@ class TestStringMethods(tm.TestCase):
         # If fillchar is not a charatter, normal str raises TypeError
         # 'aaa'.ljust(5, 'XY')
         # TypeError: must be char, not str
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not str"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not str"):
             result = values.str.center(5, fillchar='XY')
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not str"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not str"):
             result = values.str.ljust(5, fillchar='XY')
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not str"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not str"):
             result = values.str.rjust(5, fillchar='XY')
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not int"):
             result = values.str.center(5, fillchar=1)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not int"):
             result = values.str.ljust(5, fillchar=1)
 
-        with tm.assertRaisesRegexp(TypeError,
-                                   "fillchar must be a character, not int"):
+        with tm.assert_raises_regex(TypeError,
+                                    "fillchar must be a "
+                                    "character, not int"):
             result = values.str.rjust(5, fillchar=1)
 
     def test_zfill(self):
@@ -2005,7 +2020,7 @@ class TestStringMethods(tm.TestCase):
                         index=['preserve', 'me'])
         tm.assert_frame_equal(result, exp)
 
-        with tm.assertRaisesRegexp(ValueError, "expand must be"):
+        with tm.assert_raises_regex(ValueError, "expand must be"):
             s.str.split('_', expand="not_a_boolean")
 
     def test_split_to_multiindex_expand(self):
@@ -2030,7 +2045,7 @@ class TestStringMethods(tm.TestCase):
         tm.assert_index_equal(result, exp)
         self.assertEqual(result.nlevels, 6)
 
-        with tm.assertRaisesRegexp(ValueError, "expand must be"):
+        with tm.assert_raises_regex(ValueError, "expand must be"):
             idx.str.split('_', expand="not_a_boolean")
 
     def test_rsplit_to_dataframe_expand(self):
@@ -2651,7 +2666,8 @@ class TestStringMethods(tm.TestCase):
         result = s.str.normalize('NFC')
         tm.assert_series_equal(result, expected)
 
-        with tm.assertRaisesRegexp(ValueError, "invalid normalization form"):
+        with tm.assert_raises_regex(ValueError,
+                                    "invalid normalization form"):
             s.str.normalize('xxx')
 
         s = Index([u'ＡＢＣ', u'１２３', u'ｱｲｴ'])
@@ -2680,9 +2696,9 @@ class TestStringMethods(tm.TestCase):
         # https://github.com/pandas-dev/pandas/issues/11334
         s = Series(['a', 'b', 'c', 'd'])
         message = "Did you mean to supply a `sep` keyword?"
-        with tm.assertRaisesRegexp(ValueError, message):
+        with tm.assert_raises_regex(ValueError, message):
             s.str.cat('|')
-        with tm.assertRaisesRegexp(ValueError, message):
+        with tm.assert_raises_regex(ValueError, message):
             s.str.cat('    ')
 
     def test_index_str_accessor_visibility(self):
@@ -2720,9 +2736,9 @@ class TestStringMethods(tm.TestCase):
         for values, tp in cases:
             idx = Index(values)
             message = 'Can only use .str accessor with string values'
-            with tm.assertRaisesRegexp(AttributeError, message):
+            with tm.assert_raises_regex(AttributeError, message):
                 Series(values).str
-            with tm.assertRaisesRegexp(AttributeError, message):
+            with tm.assert_raises_regex(AttributeError, message):
                 idx.str
             self.assertEqual(idx.inferred_type, tp)
 
@@ -2730,14 +2746,14 @@ class TestStringMethods(tm.TestCase):
         idx = MultiIndex.from_tuples([('a', 'b'), ('a', 'b')])
         self.assertEqual(idx.inferred_type, 'mixed')
         message = 'Can only use .str accessor with Index, not MultiIndex'
-        with tm.assertRaisesRegexp(AttributeError, message):
+        with tm.assert_raises_regex(AttributeError, message):
             idx.str
 
     def test_str_accessor_no_new_attributes(self):
         # https://github.com/pandas-dev/pandas/issues/10673
         s = Series(list('aabbcde'))
-        with tm.assertRaisesRegexp(AttributeError,
-                                   "You cannot add any new attribute"):
+        with tm.assert_raises_regex(AttributeError,
+                                    "You cannot add any new attribute"):
             s.str.xlabel = "a"
 
     def test_method_on_bytes(self):
diff --git a/pandas/tests/test_take.py b/pandas/tests/test_take.py
index 4d60750fb..9fb61998f 100644
--- a/pandas/tests/test_take.py
+++ b/pandas/tests/test_take.py
@@ -32,7 +32,7 @@ class TestTake(tm.TestCase):
                 expected[3] = np.nan
                 tm.assert_almost_equal(out, expected)
             else:
-                with tm.assertRaisesRegexp(TypeError, self.fill_error):
+                with tm.assert_raises_regex(TypeError, self.fill_error):
                     algos.take_1d(data, indexer, out=out)
                 # no exception o/w
                 data.take(indexer, out=out)
@@ -123,7 +123,8 @@ class TestTake(tm.TestCase):
                 tm.assert_almost_equal(out1, expected1)
             else:
                 for i, out in enumerate([out0, out1]):
-                    with tm.assertRaisesRegexp(TypeError, self.fill_error):
+                    with tm.assert_raises_regex(TypeError,
+                                                self.fill_error):
                         algos.take_nd(data, indexer, out=out, axis=i)
                     # no exception o/w
                     data.take(indexer, out=out, axis=i)
@@ -235,7 +236,8 @@ class TestTake(tm.TestCase):
                 tm.assert_almost_equal(out2, expected2)
             else:
                 for i, out in enumerate([out0, out1, out2]):
-                    with tm.assertRaisesRegexp(TypeError, self.fill_error):
+                    with tm.assert_raises_regex(TypeError,
+                                                self.fill_error):
                         algos.take_nd(data, indexer, out=out, axis=i)
                     # no exception o/w
                     data.take(indexer, out=out, axis=i)
diff --git a/pandas/tests/test_testing.py b/pandas/tests/test_testing.py
index 4a9e4f4fb..45994fd40 100644
--- a/pandas/tests/test_testing.py
+++ b/pandas/tests/test_testing.py
@@ -6,10 +6,9 @@ import numpy as np
 import sys
 from pandas import Series, DataFrame
 import pandas.util.testing as tm
-from pandas.util.testing import (assert_almost_equal, assertRaisesRegexp,
-                                 raise_with_traceback, assert_index_equal,
-                                 assert_series_equal, assert_frame_equal,
-                                 assert_numpy_array_equal,
+from pandas.util.testing import (assert_almost_equal, raise_with_traceback,
+                                 assert_index_equal, assert_series_equal,
+                                 assert_frame_equal, assert_numpy_array_equal,
                                  RNGContext)
 from pandas.compat import is_platform_windows
 
@@ -144,13 +143,13 @@ class TestAssertAlmostEqual(tm.TestCase):
 class TestUtilTesting(tm.TestCase):
 
     def test_raise_with_traceback(self):
-        with assertRaisesRegexp(LookupError, "error_text"):
+        with tm.assert_raises_regex(LookupError, "error_text"):
             try:
                 raise ValueError("THIS IS AN ERROR")
             except ValueError as e:
                 e = LookupError("error_text")
                 raise_with_traceback(e)
-        with assertRaisesRegexp(LookupError, "error_text"):
+        with tm.assert_raises_regex(LookupError, "error_text"):
             try:
                 raise ValueError("This is another error")
             except ValueError:
@@ -173,18 +172,18 @@ numpy array shapes are different
 \\[left\\]:  \\(2,\\)
 \\[right\\]: \\(3,\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([1, 2]), np.array([3, 4, 5]))
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([1, 2]), np.array([3, 4, 5]))
 
         # scalar comparison
         expected = """Expected type """
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(1, 2)
         expected = """expected 2\\.00000 but got 1\\.00000, with decimal 5"""
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(1, 2)
 
         # array / scalar array comparison
@@ -194,10 +193,10 @@ numpy array classes are different
 \\[left\\]:  ndarray
 \\[right\\]: int"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             # numpy_array_equal only accepts np.ndarray
             assert_numpy_array_equal(np.array([1]), 1)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([1]), 1)
 
         # scalar / array comparison
@@ -207,9 +206,9 @@ numpy array classes are different
 \\[left\\]:  int
 \\[right\\]: ndarray"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(1, np.array([1]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(1, np.array([1]))
 
         expected = """numpy array are different
@@ -218,10 +217,10 @@ numpy array values are different \\(66\\.66667 %\\)
 \\[left\\]:  \\[nan, 2\\.0, 3\\.0\\]
 \\[right\\]: \\[1\\.0, nan, 3\\.0\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([np.nan, 2, 3]),
                                      np.array([1, np.nan, 3]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([np.nan, 2, 3]),
                                 np.array([1, np.nan, 3]))
 
@@ -231,9 +230,9 @@ numpy array values are different \\(50\\.0 %\\)
 \\[left\\]:  \\[1, 2\\]
 \\[right\\]: \\[1, 3\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([1, 2]), np.array([1, 3]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([1, 2]), np.array([1, 3]))
 
         expected = """numpy array are different
@@ -242,7 +241,7 @@ numpy array values are different \\(50\\.0 %\\)
 \\[left\\]:  \\[1\\.1, 2\\.000001\\]
 \\[right\\]: \\[1\\.1, 2.0\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(
                 np.array([1.1, 2.000001]), np.array([1.1, 2.0]))
 
@@ -255,10 +254,10 @@ numpy array values are different \\(16\\.66667 %\\)
 \\[left\\]:  \\[\\[1, 2\\], \\[3, 4\\], \\[5, 6\\]\\]
 \\[right\\]: \\[\\[1, 3\\], \\[3, 4\\], \\[5, 6\\]\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([[1, 2], [3, 4], [5, 6]]),
                                      np.array([[1, 3], [3, 4], [5, 6]]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([[1, 2], [3, 4], [5, 6]]),
                                 np.array([[1, 3], [3, 4], [5, 6]]))
 
@@ -268,10 +267,10 @@ numpy array values are different \\(25\\.0 %\\)
 \\[left\\]:  \\[\\[1, 2\\], \\[3, 4\\]\\]
 \\[right\\]: \\[\\[1, 3\\], \\[3, 4\\]\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([[1, 2], [3, 4]]),
                                      np.array([[1, 3], [3, 4]]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([[1, 2], [3, 4]]),
                                 np.array([[1, 3], [3, 4]]))
 
@@ -282,10 +281,10 @@ Index shapes are different
 \\[left\\]:  \\(2,\\)
 \\[right\\]: \\(3,\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(np.array([1, 2]), np.array([3, 4, 5]),
                                      obj='Index')
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(np.array([1, 2]), np.array([3, 4, 5]),
                                 obj='Index')
 
@@ -304,9 +303,9 @@ numpy array values are different \\(50\\.0 %\\)
 \\[left\\]:  \\[2011-01-01 00:00:00, 2011-01-01 00:00:00\\]
 \\[right\\]: \\[2011-01-01 00:00:00, 2011-01-02 00:00:00\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(a, b)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal(a, b)
 
     def test_numpy_array_equal_copy_flag(self):
@@ -314,10 +313,10 @@ numpy array values are different \\(50\\.0 %\\)
         b = a.copy()
         c = a.view()
         expected = r'array\(\[1, 2, 3\]\) is not array\(\[1, 2, 3\]\)'
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(a, b, check_same='same')
         expected = r'array\(\[1, 2, 3\]\) is array\(\[1, 2, 3\]\)'
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_numpy_array_equal(a, c, check_same='copy')
 
     def test_assert_almost_equal_iterable_message(self):
@@ -328,7 +327,7 @@ Iterable length are different
 \\[left\\]:  2
 \\[right\\]: 3"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal([1, 2], [3, 4, 5])
 
         expected = """Iterable are different
@@ -337,7 +336,7 @@ Iterable values are different \\(50\\.0 %\\)
 \\[left\\]:  \\[1, 2\\]
 \\[right\\]: \\[1, 3\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_almost_equal([1, 2], [1, 3])
 
 
@@ -355,7 +354,7 @@ Index levels are different
         idx1 = pd.Index([1, 2, 3])
         idx2 = pd.MultiIndex.from_tuples([('A', 1), ('A', 2),
                                           ('B', 3), ('B', 4)])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, exact=False)
 
         expected = """MultiIndex level \\[1\\] are different
@@ -368,9 +367,9 @@ MultiIndex level \\[1\\] values are different \\(25\\.0 %\\)
                                           ('B', 3), ('B', 4)])
         idx2 = pd.MultiIndex.from_tuples([('A', 1), ('A', 2),
                                           ('B', 3), ('B', 4)])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, check_exact=False)
 
         expected = """Index are different
@@ -381,9 +380,9 @@ Index length are different
 
         idx1 = pd.Index([1, 2, 3])
         idx2 = pd.Index([1, 2, 3, 4])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, check_exact=False)
 
         expected = """Index are different
@@ -394,9 +393,9 @@ Index classes are different
 
         idx1 = pd.Index([1, 2, 3])
         idx2 = pd.Index([1, 2, 3.0])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, exact=True)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, exact=True, check_exact=False)
 
         expected = """Index are different
@@ -407,7 +406,7 @@ Index values are different \\(33\\.33333 %\\)
 
         idx1 = pd.Index([1, 2, 3.])
         idx2 = pd.Index([1, 2, 3.0000000001])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
 
         # must success
@@ -421,9 +420,9 @@ Index values are different \\(33\\.33333 %\\)
 
         idx1 = pd.Index([1, 2, 3.])
         idx2 = pd.Index([1, 2, 3.0001])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, check_exact=False)
         # must success
         assert_index_equal(idx1, idx2, check_exact=False,
@@ -437,9 +436,9 @@ Index values are different \\(33\\.33333 %\\)
 
         idx1 = pd.Index([1, 2, 3])
         idx2 = pd.Index([1, 2, 4])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, check_less_precise=True)
 
         expected = """MultiIndex level \\[1\\] are different
@@ -452,9 +451,9 @@ MultiIndex level \\[1\\] values are different \\(25\\.0 %\\)
                                           ('B', 3), ('B', 4)])
         idx2 = pd.MultiIndex.from_tuples([('A', 1), ('A', 2),
                                           ('B', 3), ('B', 4)])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2, check_exact=False)
 
     def test_index_equal_metadata_message(self):
@@ -467,7 +466,7 @@ Attribute "names" are different
 
         idx1 = pd.Index([1, 2, 3])
         idx2 = pd.Index([1, 2, 3], name='x')
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
 
         # same name, should pass
@@ -484,7 +483,7 @@ Attribute "names" are different
 
         idx1 = pd.Index([1, 2, 3], name=np.nan)
         idx2 = pd.Index([1, 2, 3], name=pd.NaT)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_index_equal(idx1, idx2)
 
 
@@ -566,7 +565,7 @@ Series length are different
 \\[left\\]:  3, RangeIndex\\(start=0, stop=3, step=1\\)
 \\[right\\]: 4, RangeIndex\\(start=0, stop=4, step=1\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_series_equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 3, 4]))
 
         expected = """Series are different
@@ -575,9 +574,9 @@ Series values are different \\(33\\.33333 %\\)
 \\[left\\]:  \\[1, 2, 3\\]
 \\[right\\]: \\[1, 2, 4\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_series_equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 4]))
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_series_equal(pd.Series([1, 2, 3]), pd.Series([1, 2, 4]),
                                 check_less_precise=True)
 
@@ -637,7 +636,7 @@ DataFrame shape mismatch
 \\[left\\]:  \\(3, 2\\)
 \\[right\\]: \\(3, 1\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_frame_equal(pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}),
                                pd.DataFrame({'A': [1, 2, 3]}))
 
@@ -647,7 +646,7 @@ DataFrame\\.index values are different \\(33\\.33333 %\\)
 \\[left\\]:  Index\\(\\[u?'a', u?'b', u?'c'\\], dtype='object'\\)
 \\[right\\]: Index\\(\\[u?'a', u?'b', u?'d'\\], dtype='object'\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_frame_equal(pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]},
                                             index=['a', 'b', 'c']),
                                pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]},
@@ -659,7 +658,7 @@ DataFrame\\.columns values are different \\(50\\.0 %\\)
 \\[left\\]:  Index\\(\\[u?'A', u?'B'\\], dtype='object'\\)
 \\[right\\]: Index\\(\\[u?'A', u?'b'\\], dtype='object'\\)"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_frame_equal(pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]},
                                             index=['a', 'b', 'c']),
                                pd.DataFrame({'A': [1, 2, 3], 'b': [4, 5, 6]},
@@ -671,11 +670,11 @@ DataFrame\\.iloc\\[:, 1\\] values are different \\(33\\.33333 %\\)
 \\[left\\]:  \\[4, 5, 6\\]
 \\[right\\]: \\[4, 5, 7\\]"""
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_frame_equal(pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}),
                                pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 7]}))
 
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             assert_frame_equal(pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]}),
                                pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 7]}),
                                by_blocks=True)
@@ -693,7 +692,7 @@ Categorical\\.categories values are different \\(25\\.0 %\\)
 
         a = pd.Categorical([1, 2, 3, 4])
         b = pd.Categorical([1, 2, 3, 5])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             tm.assert_categorical_equal(a, b)
 
         expected = """Categorical\\.codes are different
@@ -704,7 +703,7 @@ Categorical\\.codes values are different \\(50\\.0 %\\)
 
         a = pd.Categorical([1, 2, 4, 3], categories=[1, 2, 3, 4])
         b = pd.Categorical([1, 2, 3, 4], categories=[1, 2, 3, 4])
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             tm.assert_categorical_equal(a, b)
 
         expected = """Categorical are different
@@ -715,7 +714,7 @@ Attribute "ordered" are different
 
         a = pd.Categorical([1, 2, 3, 4], ordered=False)
         b = pd.Categorical([1, 2, 3, 4], ordered=True)
-        with assertRaisesRegexp(AssertionError, expected):
+        with tm.assert_raises_regex(AssertionError, expected):
             tm.assert_categorical_equal(a, b)
 
 
diff --git a/pandas/tests/test_util.py b/pandas/tests/test_util.py
index 375463ec2..6581e7688 100644
--- a/pandas/tests/test_util.py
+++ b/pandas/tests/test_util.py
@@ -93,7 +93,7 @@ class TestValidateArgs(tm.TestCase):
 
     def test_bad_min_fname_arg_count(self):
         msg = "'max_fname_arg_count' must be non-negative"
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             validate_args(self.fname, (None,), -1, 'foo')
 
     def test_bad_arg_length_max_value_single(self):
@@ -108,7 +108,7 @@ class TestValidateArgs(tm.TestCase):
                .format(fname=self.fname, max_length=max_length,
                        actual_length=actual_length))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_args(self.fname, args,
                           min_fname_arg_count,
                           compat_args)
@@ -125,7 +125,7 @@ class TestValidateArgs(tm.TestCase):
                .format(fname=self.fname, max_length=max_length,
                        actual_length=actual_length))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_args(self.fname, args,
                           min_fname_arg_count,
                           compat_args)
@@ -144,7 +144,7 @@ class TestValidateArgs(tm.TestCase):
         arg_vals = (1, -1, 3)
 
         for i in range(1, 3):
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 validate_args(self.fname, arg_vals[:i], 2, compat_args)
 
     def test_validation(self):
@@ -173,7 +173,7 @@ class TestValidateKwargs(tm.TestCase):
                r"keyword argument '{arg}'".format(
                    fname=self.fname, arg=badarg))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_kwargs(self.fname, kwargs, compat_args)
 
     def test_not_all_none(self):
@@ -194,7 +194,7 @@ class TestValidateKwargs(tm.TestCase):
             kwargs = dict(zip(kwarg_keys[:i],
                               kwarg_vals[:i]))
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 validate_kwargs(self.fname, kwargs, compat_args)
 
     def test_validation(self):
@@ -213,10 +213,11 @@ class TestValidateKwargs(tm.TestCase):
 
         for name in arg_names:
             for value in invalid_values:
-                with tm.assertRaisesRegexp(ValueError,
-                                           ("For argument \"%s\" expected "
-                                            "type bool, received type %s") %
-                                           (name, type(value).__name__)):
+                with tm.assert_raises_regex(ValueError,
+                                            "For argument \"%s\" "
+                                            "expected type bool, "
+                                            "received type %s" %
+                                            (name, type(value).__name__)):
                     validate_bool_kwarg(value, name)
 
             for value in valid_values:
@@ -239,7 +240,7 @@ class TestValidateKwargsAndArgs(tm.TestCase):
                .format(fname=self.fname, max_length=max_length,
                        actual_length=actual_length))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_args_and_kwargs(self.fname, args, kwargs,
                                      min_fname_arg_count,
                                      compat_args)
@@ -257,7 +258,7 @@ class TestValidateKwargsAndArgs(tm.TestCase):
                .format(fname=self.fname, max_length=max_length,
                        actual_length=actual_length))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_args_and_kwargs(self.fname, args, kwargs,
                                      min_fname_arg_count,
                                      compat_args)
@@ -276,17 +277,17 @@ class TestValidateKwargsAndArgs(tm.TestCase):
 
         args = ()
         kwargs = {'foo': -5, bad_arg: 2}
-        tm.assertRaisesRegexp(ValueError, msg,
-                              validate_args_and_kwargs,
-                              self.fname, args, kwargs,
-                              min_fname_arg_count, compat_args)
+        tm.assert_raises_regex(ValueError, msg,
+                               validate_args_and_kwargs,
+                               self.fname, args, kwargs,
+                               min_fname_arg_count, compat_args)
 
         args = (-5, 2)
         kwargs = {}
-        tm.assertRaisesRegexp(ValueError, msg,
-                              validate_args_and_kwargs,
-                              self.fname, args, kwargs,
-                              min_fname_arg_count, compat_args)
+        tm.assert_raises_regex(ValueError, msg,
+                               validate_args_and_kwargs,
+                               self.fname, args, kwargs,
+                               min_fname_arg_count, compat_args)
 
     def test_duplicate_argument(self):
         min_fname_arg_count = 2
@@ -300,7 +301,7 @@ class TestValidateKwargsAndArgs(tm.TestCase):
         msg = (r"{fname}\(\) got multiple values for keyword "
                r"argument '{arg}'".format(fname=self.fname, arg='foo'))
 
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             validate_args_and_kwargs(self.fname, args, kwargs,
                                      min_fname_arg_count,
                                      compat_args)
@@ -327,7 +328,7 @@ class TestMove(tm.TestCase):
         ``move_into_mutable_buffer`` which has a bunch of checks in it.
         """
         msg = "cannot create 'pandas.util._move.stolenbuf' instances"
-        with tm.assertRaisesRegexp(TypeError, msg):
+        with tm.assert_raises_regex(TypeError, msg):
             stolenbuf()
 
     def test_more_than_one_ref(self):
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index aea2525a3..adfecc901 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -74,7 +74,7 @@ class TestApi(Base):
         pytest.raises(KeyError, g.__getitem__, ['C'])  # g[['C']]
 
         pytest.raises(KeyError, g.__getitem__, ['A', 'C'])  # g[['A', 'C']]
-        with tm.assertRaisesRegexp(KeyError, '^[^A]+$'):
+        with tm.assert_raises_regex(KeyError, '^[^A]+$'):
             # A should not be referenced as a bad column...
             # will have to rethink regex if you change message!
             g[['A', 'C']]
@@ -352,10 +352,10 @@ class TestWindow(Base):
         msg = "numpy operations are not valid with window objects"
 
         for func in ('sum', 'mean'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(w, func), 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(w, func), dtype=np.float64)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(w, func), 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(w, func), dtype=np.float64)
 
 
 class TestRolling(Base):
@@ -430,10 +430,10 @@ class TestRolling(Base):
         msg = "numpy operations are not valid with window objects"
 
         for func in ('std', 'mean', 'sum', 'max', 'min', 'var'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(r, func), 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(r, func), dtype=np.float64)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(r, func), 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(r, func), dtype=np.float64)
 
     def test_closed(self):
         df = DataFrame({'A': [0, 1, 2, 3, 4]})
@@ -478,10 +478,10 @@ class TestExpanding(Base):
         msg = "numpy operations are not valid with window objects"
 
         for func in ('std', 'mean', 'sum', 'max', 'min', 'var'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(e, func), 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(e, func), dtype=np.float64)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(e, func), 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(e, func), dtype=np.float64)
 
 
 class TestEWM(Base):
@@ -540,10 +540,10 @@ class TestEWM(Base):
         msg = "numpy operations are not valid with window objects"
 
         for func in ('std', 'mean', 'var'):
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(e, func), 1, 2, 3)
-            tm.assertRaisesRegexp(UnsupportedFunctionCall, msg,
-                                  getattr(e, func), dtype=np.float64)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(e, func), 1, 2, 3)
+            tm.assert_raises_regex(UnsupportedFunctionCall, msg,
+                                   getattr(e, func), dtype=np.float64)
 
 
 class TestDeprecations(Base):
@@ -1825,10 +1825,10 @@ class TestPairwise(object):
                 tm.assert_index_equal(result.index, expected_index)
                 tm.assert_index_equal(result.columns, expected_columns)
             else:
-                tm.assertRaisesRegexp(
+                tm.assert_raises_regex(
                     ValueError, "'arg1' columns are not unique", f, df,
                     self.df2)
-                tm.assertRaisesRegexp(
+                tm.assert_raises_regex(
                     ValueError, "'arg2' columns are not unique", f,
                     self.df2, df)
 
diff --git a/pandas/tests/tools/test_numeric.py b/pandas/tests/tools/test_numeric.py
index 137610141..290c03af3 100644
--- a/pandas/tests/tools/test_numeric.py
+++ b/pandas/tests/tools/test_numeric.py
@@ -39,7 +39,7 @@ class TestToNumeric(tm.TestCase):
     def test_error(self):
         s = pd.Series([1, -3.14, 'apple'])
         msg = 'Unable to parse string "apple" at position 2'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             to_numeric(s, errors='raise')
 
         res = to_numeric(s, errors='ignore')
@@ -52,13 +52,13 @@ class TestToNumeric(tm.TestCase):
 
         s = pd.Series(['orange', 1, -3.14, 'apple'])
         msg = 'Unable to parse string "orange" at position 0'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             to_numeric(s, errors='raise')
 
     def test_error_seen_bool(self):
         s = pd.Series([True, False, 'apple'])
         msg = 'Unable to parse string "apple" at position 2'
-        with tm.assertRaisesRegexp(ValueError, msg):
+        with tm.assert_raises_regex(ValueError, msg):
             to_numeric(s, errors='raise')
 
         res = to_numeric(s, errors='ignore')
@@ -149,10 +149,10 @@ class TestToNumeric(tm.TestCase):
     def test_type_check(self):
         # GH 11776
         df = pd.DataFrame({'a': [1, -3.14, 7], 'b': ['4', '5', '6']})
-        with tm.assertRaisesRegexp(TypeError, "1-d array"):
+        with tm.assert_raises_regex(TypeError, "1-d array"):
             to_numeric(df)
         for errors in ['ignore', 'raise', 'coerce']:
-            with tm.assertRaisesRegexp(TypeError, "1-d array"):
+            with tm.assert_raises_regex(TypeError, "1-d array"):
                 to_numeric(df, errors=errors)
 
     def test_scalar(self):
@@ -253,7 +253,7 @@ class TestToNumeric(tm.TestCase):
         res = pd.to_numeric(s, errors='ignore')
         tm.assert_series_equal(res, pd.Series([[10.0, 2], 1.0, 'apple']))
 
-        with tm.assertRaisesRegexp(TypeError, "Invalid object type"):
+        with tm.assert_raises_regex(TypeError, "Invalid object type"):
             pd.to_numeric(s)
 
     def test_downcast(self):
@@ -274,7 +274,7 @@ class TestToNumeric(tm.TestCase):
         smallest_float_dtype = float_32_char
 
         for data in (mixed_data, int_data, date_data):
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 pd.to_numeric(data, downcast=invalid_downcast)
 
             expected = np.array([1, 2, 3], dtype=np.int64)
diff --git a/pandas/tests/tseries/test_frequencies.py b/pandas/tests/tseries/test_frequencies.py
index c9de997cd..af544d10a 100644
--- a/pandas/tests/tseries/test_frequencies.py
+++ b/pandas/tests/tseries/test_frequencies.py
@@ -101,7 +101,8 @@ class TestToOffset(tm.TestCase):
         assert (result == expected)
 
         # malformed
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: 2h20m'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: 2h20m'):
             frequencies.to_offset('2h20m')
 
     def test_to_offset_negative(self):
@@ -123,17 +124,23 @@ class TestToOffset(tm.TestCase):
 
     def test_to_offset_invalid(self):
         # GH 13930
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: U1'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: U1'):
             frequencies.to_offset('U1')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: -U'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: -U'):
             frequencies.to_offset('-U')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: 3U1'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: 3U1'):
             frequencies.to_offset('3U1')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: -2-3U'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: -2-3U'):
             frequencies.to_offset('-2-3U')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: -2D:3H'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: -2D:3H'):
             frequencies.to_offset('-2D:3H')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: 1.5.0S'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: 1.5.0S'):
             frequencies.to_offset('1.5.0S')
 
         # split offsets with spaces are valid
@@ -146,10 +153,11 @@ class TestToOffset(tm.TestCase):
 
         # special cases
         assert frequencies.to_offset('2SMS-15') == offsets.SemiMonthBegin(2)
-        with tm.assertRaisesRegexp(ValueError,
-                                   'Invalid frequency: 2SMS-15-15'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: 2SMS-15-15'):
             frequencies.to_offset('2SMS-15-15')
-        with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: 2SMS-15D'):
+        with tm.assert_raises_regex(ValueError,
+                                    'Invalid frequency: 2SMS-15D'):
             frequencies.to_offset('2SMS-15D')
 
     def test_to_offset_leading_zero(self):
@@ -244,7 +252,8 @@ class TestToOffset(tm.TestCase):
                            'SMS-1', 'SMS-28', 'SMS-30',
                            'SMS-BAR', 'BSMS', 'SMS--2']
         for invalid_anchor in invalid_anchors:
-            with tm.assertRaisesRegexp(ValueError, 'Invalid frequency: '):
+            with tm.assert_raises_regex(ValueError,
+                                        'Invalid frequency: '):
                 frequencies.to_offset(invalid_anchor)
 
 
@@ -306,7 +315,7 @@ def test_period_str_to_code():
 
         msg = frequencies._INVALID_FREQ_ERROR
         for alias in aliases:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 frequencies._period_str_to_code(alias)
 
     _assert_depr("M", 3000, ["MTH", "MONTH", "MONTHLY"])
@@ -780,7 +789,7 @@ class TestFrequencyInference(tm.TestCase):
         for freq in ['Y']:
 
             msg = frequencies._INVALID_FREQ_ERROR
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 s = Series(period_range('2013', periods=10, freq=freq))
             pytest.raises(TypeError, lambda: frequencies.infer_freq(s))
 
@@ -807,10 +816,10 @@ class TestFrequencyInference(tm.TestCase):
 
         msg = frequencies._INVALID_FREQ_ERROR
         for freq in freqs:
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 frequencies.get_offset(freq)
 
-            with tm.assertRaisesRegexp(ValueError, msg):
+            with tm.assert_raises_regex(ValueError, msg):
                 date_range('2011-01-01', periods=5, freq=freq)
 
 
diff --git a/pandas/tests/tseries/test_offsets.py b/pandas/tests/tseries/test_offsets.py
index ff38d5ec4..cb3fc3b60 100644
--- a/pandas/tests/tseries/test_offsets.py
+++ b/pandas/tests/tseries/test_offsets.py
@@ -35,7 +35,6 @@ import pandas.tseries.offsets as offsets
 from pandas.io.pickle import read_pickle
 from pandas._libs.tslib import normalize_date, NaT, Timestamp, Timedelta
 import pandas._libs.tslib as tslib
-from pandas.util.testing import assertRaisesRegexp
 import pandas.util.testing as tm
 from pandas.tseries.holiday import USFederalHolidayCalendar
 
@@ -2226,7 +2225,8 @@ class TestWeek(Base):
 
     def test_corner(self):
         pytest.raises(ValueError, Week, weekday=7)
-        assertRaisesRegexp(ValueError, "Day must be", Week, weekday=-1)
+        tm.assert_raises_regex(
+            ValueError, "Day must be", Week, weekday=-1)
 
     def test_isAnchored(self):
         self.assertTrue(Week(weekday=0).isAnchored())
@@ -2291,16 +2291,16 @@ class TestWeekOfMonth(Base):
     _offset = WeekOfMonth
 
     def test_constructor(self):
-        assertRaisesRegexp(ValueError, "^N cannot be 0", WeekOfMonth, n=0,
-                           week=1, weekday=1)
-        assertRaisesRegexp(ValueError, "^Week", WeekOfMonth, n=1, week=4,
-                           weekday=0)
-        assertRaisesRegexp(ValueError, "^Week", WeekOfMonth, n=1, week=-1,
-                           weekday=0)
-        assertRaisesRegexp(ValueError, "^Day", WeekOfMonth, n=1, week=0,
-                           weekday=-1)
-        assertRaisesRegexp(ValueError, "^Day", WeekOfMonth, n=1, week=0,
-                           weekday=7)
+        tm.assert_raises_regex(ValueError, "^N cannot be 0",
+                               WeekOfMonth, n=0, week=1, weekday=1)
+        tm.assert_raises_regex(ValueError, "^Week", WeekOfMonth,
+                               n=1, week=4, weekday=0)
+        tm.assert_raises_regex(ValueError, "^Week", WeekOfMonth,
+                               n=1, week=-1, weekday=0)
+        tm.assert_raises_regex(ValueError, "^Day", WeekOfMonth,
+                               n=1, week=0, weekday=-1)
+        tm.assert_raises_regex(ValueError, "^Day", WeekOfMonth,
+                               n=1, week=0, weekday=7)
 
     def test_repr(self):
         self.assertEqual(repr(WeekOfMonth(weekday=1, week=2)),
@@ -2377,12 +2377,13 @@ class TestLastWeekOfMonth(Base):
     _offset = LastWeekOfMonth
 
     def test_constructor(self):
-        assertRaisesRegexp(ValueError, "^N cannot be 0", LastWeekOfMonth, n=0,
-                           weekday=1)
+        tm.assert_raises_regex(ValueError, "^N cannot be 0",
+                               LastWeekOfMonth, n=0, weekday=1)
 
-        assertRaisesRegexp(ValueError, "^Day", LastWeekOfMonth, n=1,
-                           weekday=-1)
-        assertRaisesRegexp(ValueError, "^Day", LastWeekOfMonth, n=1, weekday=7)
+        tm.assert_raises_regex(ValueError, "^Day", LastWeekOfMonth, n=1,
+                               weekday=-1)
+        tm.assert_raises_regex(
+            ValueError, "^Day", LastWeekOfMonth, n=1, weekday=7)
 
     def test_offset(self):
         # Saturday
@@ -4567,9 +4568,9 @@ class TestOffsetNames(tm.TestCase):
 
 
 def test_get_offset():
-    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+    with tm.assert_raises_regex(ValueError, _INVALID_FREQ_ERROR):
         get_offset('gibberish')
-    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+    with tm.assert_raises_regex(ValueError, _INVALID_FREQ_ERROR):
         get_offset('QS-JAN-B')
 
     pairs = [
@@ -4597,7 +4598,7 @@ def test_get_offset():
 def test_get_offset_legacy():
     pairs = [('w@Sat', Week(weekday=5))]
     for name, expected in pairs:
-        with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+        with tm.assert_raises_regex(ValueError, _INVALID_FREQ_ERROR):
             get_offset(name)
 
 
@@ -4637,7 +4638,7 @@ def test_get_standard_freq():
     with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
         assert fstr == get_standard_freq(('W', 1))
 
-    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+    with tm.assert_raises_regex(ValueError, _INVALID_FREQ_ERROR):
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             get_standard_freq('WeEk')
 
@@ -4646,7 +4647,7 @@ def test_get_standard_freq():
     with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
         assert fstr == get_standard_freq('5q')
 
-    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+    with tm.assert_raises_regex(ValueError, _INVALID_FREQ_ERROR):
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             get_standard_freq('5QuarTer')
 
diff --git a/pandas/tests/tseries/test_timezones.py b/pandas/tests/tseries/test_timezones.py
index e3f2c242e..807d6866c 100644
--- a/pandas/tests/tseries/test_timezones.py
+++ b/pandas/tests/tseries/test_timezones.py
@@ -1335,8 +1335,8 @@ class TestTimeZones(tm.TestCase):
         # Can't localize if already tz-aware
         rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
         ts = Series(1, index=rng)
-        tm.assertRaisesRegexp(TypeError, 'Already tz-aware', ts.tz_localize,
-                              'US/Eastern')
+        tm.assert_raises_regex(TypeError, 'Already tz-aware',
+                               ts.tz_localize, 'US/Eastern')
 
     def test_series_frame_tz_convert(self):
         rng = date_range('1/1/2011', periods=200, freq='D', tz='US/Eastern')
@@ -1359,8 +1359,8 @@ class TestTimeZones(tm.TestCase):
         # can't convert tz-naive
         rng = date_range('1/1/2011', periods=200, freq='D')
         ts = Series(1, index=rng)
-        tm.assertRaisesRegexp(TypeError, "Cannot convert tz-naive",
-                              ts.tz_convert, 'US/Eastern')
+        tm.assert_raises_regex(TypeError, "Cannot convert tz-naive",
+                               ts.tz_convert, 'US/Eastern')
 
     def test_tz_convert_roundtrip(self):
         for tz in self.timezones:
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 75d24938e..3f07937a6 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -2423,7 +2423,8 @@ def stdin_encoding(encoding=None):
     sys.stdin = _stdin
 
 
-def assertRaisesRegexp(_exception, _regexp, _callable=None, *args, **kwargs):
+def assert_raises_regex(_exception, _regexp, _callable=None,
+                        *args, **kwargs):
     """
     Check that the specified Exception is raised and that the error message
     matches a given regular expression pattern. This may be a regular
@@ -2440,27 +2441,26 @@ def assertRaisesRegexp(_exception, _regexp, _callable=None, *args, **kwargs):
 
     Examples
     --------
-    >>> assertRaisesRegexp(ValueError, 'invalid literal for.*XYZ',
-    ...                                int, 'XYZ')
+    >>> assert_raises_regex(ValueError, 'invalid literal for.*XYZ', int, 'XYZ')
     >>> import re
-    >>> assertRaisesRegexp(ValueError, re.compile('literal'), int, 'XYZ')
+    >>> assert_raises_regex(ValueError, re.compile('literal'), int, 'XYZ')
 
     If an exception of a different type is raised, it bubbles up.
 
-    >>> assertRaisesRegexp(TypeError, 'literal', int, 'XYZ')
+    >>> assert_raises_regex(TypeError, 'literal', int, 'XYZ')
     Traceback (most recent call last):
         ...
     ValueError: invalid literal for int() with base 10: 'XYZ'
     >>> dct = dict()
-    >>> assertRaisesRegexp(KeyError, 'pear', dct.__getitem__, 'apple')
+    >>> assert_raises_regex(KeyError, 'pear', dct.__getitem__, 'apple')
     Traceback (most recent call last):
         ...
     AssertionError: "pear" does not match "'apple'"
 
     You can also use this in a with statement.
-    >>> with assertRaisesRegexp(TypeError, 'unsupported operand type\(s\)'):
+    >>> with assert_raises_regex(TypeError, 'unsupported operand type\(s\)'):
     ...     1 + {}
-    >>> with assertRaisesRegexp(TypeError, 'banana'):
+    >>> with assert_raises_regex(TypeError, 'banana'):
     ...     'apple'[0] = 'b'
     Traceback (most recent call last):
         ...
@@ -2477,7 +2477,7 @@ item assignment"
 
 class _AssertRaisesContextmanager(object):
     """
-    Context manager behind assertRaisesRegexp.
+    Context manager behind `assert_raises_regex`.
     """
 
     def __init__(self, exception, regexp=None):

commit b90d10171a94394f44f84aceb24f850c07222bf8
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Apr 4 01:08:43 2012 -0400

    ENH: index tests pass

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 49077ebfb..02511119c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -253,7 +253,10 @@ class Index(np.ndarray):
         return self
 
     def __contains__(self, key):
-        return key in self._engine
+        try:
+            return key in self._engine
+        except TypeError:
+            return False
 
     def __hash__(self):
         return hash(self.view(np.ndarray))
@@ -638,18 +641,18 @@ class Index(np.ndarray):
             this = Index(self, dtype=object)
             target = Index(target, dtype=object)
             return this.get_indexer(target, method=method)
-        # if self.dtype != target.dtype:
-        #     target = Index(target, dtype=object)
 
         if method == 'pad':
-            indexer = self._pad(self, target, self.indexMap, target.indexMap)
+            assert(self.is_unique and self.is_monotonic)
+            indexer = self._engine.get_pad_indexer(target)
         elif method == 'backfill':
-            indexer = self._backfill(self, target, self.indexMap,
-                                     target.indexMap)
+            assert(self.is_unique and self.is_monotonic)
+            indexer = self._engine.get_backfill_indexer(target)
         elif method is None:
-            indexer = self._get_indexer_standard(target)
+            indexer = self._engine.get_indexer(target)
         else:
             raise ValueError('unrecognized method: %s' % method)
+
         return indexer
 
     def _get_indexer_standard(self, other):
@@ -2963,13 +2966,13 @@ class MultiIndex(Index):
             self_index = self.get_tuple_index()
 
         if method == 'pad':
-            indexer = self._pad(self_index, target_index, self_index.indexMap,
-                                target.indexMap)
+            assert(self.is_unique and self.is_monotonic)
+            indexer = self_index._engine.get_pad_indexer(target_index)
         elif method == 'backfill':
-            indexer = self._backfill(self_index, target_index,
-                                     self_index.indexMap, target.indexMap)
+            assert(self.is_unique and self.is_monotonic)
+            indexer = self_index._engine.get_backfill_indexer(target_index)
         else:
-            indexer = self._engine.get_indexer(target_index)
+            indexer = self_index._engine.get_indexer(target_index)
 
         return indexer
 
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 6d6ce610b..ee9dc09df 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -98,7 +98,12 @@ cdef class IndexEngine:
     cdef inline _do_monotonic_check(self):
         try:
             values = self._get_index_values()
-            self.monotonic, self.unique = self._call_monotonic(values)
+            self.monotonic, unique = self._call_monotonic(values)
+
+            if unique is not None:
+                self.unique = unique
+                self.unique_check = 1
+
         except TypeError:
             self.monotonic = 0
         self.monotonic_check = 1
@@ -149,57 +154,6 @@ cdef class IndexEngine:
         self._ensure_mapping_populated()
         return self.mapping.lookup(values)
 
-    def get_pad_indexer(self, values):
-        pass
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def backfill_object(ndarray[object] old, ndarray[object] new, limit=None):
-    cdef Py_ssize_t i, j, nleft, nright
-    cdef ndarray[int32_t, ndim=1] indexer
-    cdef object cur, prev
-    cdef int lim
-
-    nleft = len(old)
-    nright = len(new)
-    indexer = np.empty(nright, dtype=np.int32)
-    indexer.fill(-1)
-
-    if limit is None:
-        lim = nright
-    else:
-        # TODO: > 0?
-        lim = limit
-
-    if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
-        return indexer
-
-    i = nleft - 1
-    j = nright - 1
-
-    cur = old[nleft - 1]
-    while True:
-        if j == 0:
-            break
-
-        if i == 0:
-            while j > 0 and new[j] >= cur:
-                indexer[j] = i
-                j -= 1
-            break
-
-        prev = old[i - 1]
-
-        while j > 0 and prev < new[j] <= cur:
-            indexer[j] = i
-            j -= 1
-
-        i -= 1
-        cur = prev
-
-    return indexer
-
 
 
 # @cache_readonly
@@ -223,6 +177,12 @@ cdef class Int64Engine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_int64(values)
 
+    def get_pad_indexer(self, other):
+        return _tseries.pad_int64(self._get_index_values(), other)
+
+    def get_backfill_indexer(self, other):
+        return _tseries.backfill_int64(self._get_index_values(), other)
+
 cdef class Float64Engine(IndexEngine):
 
     # cdef Float64HashTable mapping
@@ -233,6 +193,12 @@ cdef class Float64Engine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_float64(values)
 
+    def get_pad_indexer(self, other):
+        return _tseries.pad_float64(self._get_index_values(), other)
+
+    def get_backfill_indexer(self, other):
+        return _tseries.backfill_float64(self._get_index_values(), other)
+
 
 cdef class ObjectEngine(IndexEngine):
 
@@ -244,6 +210,12 @@ cdef class ObjectEngine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_object(values)
 
+    def get_pad_indexer(self, other):
+        return _tseries.pad_object(self._get_index_values(), other)
+
+    def get_backfill_indexer(self, other):
+        return _tseries.backfill_object(self._get_index_values(), other)
+
 
 cdef class DatetimeEngine(IndexEngine):
 
@@ -282,7 +254,7 @@ cdef class DatetimeEngine(IndexEngine):
             val = np.datetime64(val)
             val = val.view('i8')
 
-        return self.mapping[val]
+        return self.mapping.get_item(val)
 
 
 # ctypedef fused idxvalue_t:
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index f5c2c3459..e3c9d9a6f 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -181,7 +181,7 @@ def backfill_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -257,7 +257,7 @@ def pad_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -334,7 +334,7 @@ def is_monotonic_%(name)s(ndarray[%(c_type)s] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 95af9f6bf..97041c706 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -140,7 +140,7 @@ def pad_float64(ndarray[float64_t] old, ndarray[float64_t] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -191,7 +191,7 @@ def pad_object(ndarray[object] old, ndarray[object] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -242,7 +242,7 @@ def pad_int32(ndarray[int32_t] old, ndarray[int32_t] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -293,7 +293,7 @@ def pad_int64(ndarray[int64_t] old, ndarray[int64_t] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -344,7 +344,7 @@ def pad_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
         j += 1
 
     while True:
-        if j == nright - 1:
+        if j == nright:
             break
 
         if i == nleft - 1:
@@ -397,7 +397,7 @@ def backfill_float64(ndarray[float64_t] old, ndarray[float64_t] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -449,7 +449,7 @@ def backfill_object(ndarray[object] old, ndarray[object] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -501,7 +501,7 @@ def backfill_int32(ndarray[int32_t] old, ndarray[int32_t] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -553,7 +553,7 @@ def backfill_int64(ndarray[int64_t] old, ndarray[int64_t] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -605,7 +605,7 @@ def backfill_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
         j -= 1
 
     while True:
-        if j == 0:
+        if j < 0:
             break
 
         if i == 0:
@@ -975,7 +975,7 @@ def is_monotonic_float64(ndarray[float64_t] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
@@ -1002,7 +1002,7 @@ def is_monotonic_object(ndarray[object] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
@@ -1029,7 +1029,7 @@ def is_monotonic_int32(ndarray[int32_t] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
@@ -1056,7 +1056,7 @@ def is_monotonic_int64(ndarray[int64_t] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
@@ -1083,7 +1083,7 @@ def is_monotonic_bool(ndarray[uint8_t] arr):
     n = len(arr)
 
     if n < 2:
-        return True
+        return True, True
 
     prev = arr[0]
     for i in range(1, n):
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 565d00287..d72ebfa18 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -118,7 +118,7 @@ def is_lexsorted(list list_of_arrays):
 
     cdef int32_t **vecs = <int32_t**> malloc(nlevels * sizeof(int32_t*))
     for i from 0 <= i < nlevels:
-        vecs[i] = <int32_t *> (<ndarray> list_of_arrays[i]).data
+        # vecs[i] = <int32_t *> (<ndarray> list_of_arrays[i]).data
 
         arr = list_of_arrays[i]
         vecs[i] = <int32_t *> arr.data
diff --git a/pandas/src/reduce.pyx b/pandas/src/reduce.pyx
index e987af9c0..102afc930 100644
--- a/pandas/src/reduce.pyx
+++ b/pandas/src/reduce.pyx
@@ -319,13 +319,13 @@ cdef class Slider:
 
         self.buf.data = self.values.data
 
-    cdef inline advance(self, Py_ssize_t k):
+    cpdef advance(self, Py_ssize_t k):
         self.buf.data = <char*> self.buf.data + self.stride * k
 
-    cdef inline set_length(self, Py_ssize_t length):
+    cpdef set_length(self, Py_ssize_t length):
         self.buf.shape[0] = length
 
-    cdef inline cleanup(self):
+    cpdef cleanup(self):
         self.buf.shape[0] = self.orig_len
         self.buf.data = self.orig_data
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 9a4db66c5..a7f03815a 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -832,6 +832,10 @@ class TestMultiIndex(unittest.TestCase):
         obj2 = MultiIndex.from_tuples(obj.values)
         self.assert_(obj.equals(obj2))
 
+        res = obj.get_indexer(obj)
+        exp = np.arange(len(obj))
+        assert_almost_equal(res, exp)
+
         res = obj.get_indexer(obj2[::-1])
         exp = obj.get_indexer(obj[::-1])
         exp2 = obj2.get_indexer(obj2[::-1])

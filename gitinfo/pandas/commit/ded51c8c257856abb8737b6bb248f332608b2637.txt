commit ded51c8c257856abb8737b6bb248f332608b2637
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Aug 12 22:44:55 2012 -0400

    BUG: .ix setting logic error with non-unique MultiIndex close #1750

diff --git a/RELEASE.rst b/RELEASE.rst
index 6cce2ded0..35bf9257f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -88,6 +88,7 @@ pandas 0.8.2
   - Fix handling of DatetimeIndex in DataFrame.to_records (#1720)
   - Fix handling of general objects in isnull on which bool(...) fails (#1749)
   - Fix .ix indexing with MultiIndex ambiguity (#1678)
+  - Fix .ix setting logic error with non-unique MultiIndex (#1750)
 
 pandas 0.8.1
 ============
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 00bb072b0..08af7932c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -2022,7 +2022,10 @@ class MultiIndex(Index):
         """
         if isinstance(key, tuple):
             if len(key) == self.nlevels:
-                return self._engine.get_loc(key)
+                if self.is_unique:
+                    return self._engine.get_loc(key)
+                else:
+                    return slice(*self.slice_locs(key, key))
             else:
                 # partial selection
                 result = slice(*self.slice_locs(key, key))
@@ -2078,7 +2081,11 @@ class MultiIndex(Index):
 
             if not any(isinstance(k, slice) for k in key):
                 if len(key) == self.nlevels:
-                    return self._engine.get_loc(key), None
+                    if self.is_unique:
+                        return self._engine.get_loc(key), None
+                    else:
+                        indexer = slice(*self.slice_locs(key, key))
+                        return indexer, self[indexer]
                 else:
                     # partial selection
                     indexer = slice(*self.slice_locs(key, key))
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index cff54af42..4dce75a29 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -3,6 +3,7 @@
 from pandas.core.common import _asarray_tuplesafe
 from pandas.core.index import Index, MultiIndex
 import pandas.core.common as com
+import pandas.lib as lib
 
 import numpy as np
 
@@ -409,7 +410,20 @@ class _NDFrameIndexer(object):
                     check = labels.levels[0].get_indexer(objarr)
                 else:
                     level = None
-                    indexer = check = labels.get_indexer(objarr)
+                    # XXX
+                    if labels.is_unique:
+                        indexer = check = labels.get_indexer(objarr)
+                    else:
+                        mask = np.zeros(len(labels), dtype=bool)
+                        lvalues = labels.values
+                        for x in objarr:
+                            # ugh
+                            to_or = lib.map_infer(lvalues, x.__eq__)
+                            if not to_or.any():
+                                raise KeyError('%s not in index' % str(x))
+                            mask |= to_or
+
+                        indexer = check = mask.nonzero()[0]
 
                 mask = check == -1
                 if mask.any():
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index b17c736dd..b923e4e74 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -1456,6 +1456,17 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
         self.assert_(isinstance(result, Series))
         assert_series_equal(result, exp)
 
+    def test_nonunique_assignment_1750(self):
+        df = DataFrame([[1, 1, "x", "X"], [1, 1, "y", "Y"], [1, 2, "z", "Z"]],
+                       columns=list("ABCD"))
+
+        df = df.set_index(['A', 'B'])
+        ix = MultiIndex.from_tuples([(1, 1)])
+
+        df.ix[ix, "C"] = '_'
+
+        self.assert_((df.xs((1, 1))['C'] == '_').all())
+
 if __name__ == '__main__':
 
     # unittest.main()

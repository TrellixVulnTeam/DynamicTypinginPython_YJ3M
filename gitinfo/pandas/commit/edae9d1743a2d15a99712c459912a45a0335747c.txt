commit edae9d1743a2d15a99712c459912a45a0335747c
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Mar 7 03:26:54 2020 -0800

    Implement __array__ on ExtensionIndex (#32255)

diff --git a/doc/source/whatsnew/v1.1.0.rst b/doc/source/whatsnew/v1.1.0.rst
index 44deab25d..ff9655ab7 100644
--- a/doc/source/whatsnew/v1.1.0.rst
+++ b/doc/source/whatsnew/v1.1.0.rst
@@ -91,6 +91,8 @@ Backwards incompatible API changes
   now raise a  ``TypeError`` if a not-accepted keyword argument is passed into it.
   Previously a ``UnsupportedFunctionCall`` was raised (``AssertionError`` if ``min_count`` passed into :meth:`~DataFrameGroupby.median``) (:issue:`31485`)
 - :meth:`DataFrame.at` and :meth:`Series.at` will raise a ``TypeError`` instead of a ``ValueError`` if an incompatible key is passed, and ``KeyError`` if a missing key is passed, matching the behavior of ``.loc[]`` (:issue:`31722`)
+- Passing an integer dtype other than ``int64`` to ``np.array(period_index, dtype=...)`` will now raise ``TypeError`` instead of incorrectly using ``int64`` (:issue:`32255`)
+-
 
 .. _whatsnew_110.api_breaking.indexing_raises_key_errors:
 
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 8141e2c78..5eeee644b 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -282,7 +282,12 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin, dtl.DatelikeOps):
         return self.dtype.freq
 
     def __array__(self, dtype=None) -> np.ndarray:
-        # overriding DatetimelikeArray
+        if dtype == "i8":
+            return self.asi8
+        elif dtype == bool:
+            return ~self._isnan
+
+        # This will raise TypeErorr for non-object dtypes
         return np.array(list(self), dtype=object)
 
     def __arrow_array__(self, type=None):
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index d43ae8eb5..5997843f7 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -364,10 +364,6 @@ class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
         hash(key)
         return contains(self, key, container=self._engine)
 
-    def __array__(self, dtype=None) -> np.ndarray:
-        """ the array interface, return my values """
-        return np.array(self._data, dtype=dtype)
-
     @Appender(Index.astype.__doc__)
     def astype(self, dtype, copy=True):
         if is_interval_dtype(dtype):
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index c9fefd46e..2a1153f07 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -267,9 +267,6 @@ class DatetimeIndex(DatetimeTimedeltaMixin):
 
     # --------------------------------------------------------------------
 
-    def __array__(self, dtype=None) -> np.ndarray:
-        return np.asarray(self._data, dtype=dtype)
-
     @cache_readonly
     def _is_dates_only(self) -> bool:
         """
diff --git a/pandas/core/indexes/extension.py b/pandas/core/indexes/extension.py
index daccb3586..7b11df15f 100644
--- a/pandas/core/indexes/extension.py
+++ b/pandas/core/indexes/extension.py
@@ -224,6 +224,9 @@ class ExtensionIndex(Index):
 
     # ---------------------------------------------------------------------
 
+    def __array__(self, dtype=None) -> np.ndarray:
+        return np.asarray(self._data, dtype=dtype)
+
     @property
     def _ndarray_values(self) -> np.ndarray:
         return self._data._ndarray_values
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index ebf69c49c..6a7595a66 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -19,7 +19,6 @@ from pandas.core.dtypes.common import (
     is_dtype_equal,
     is_float,
     is_integer,
-    is_integer_dtype,
     is_object_dtype,
     is_scalar,
     pandas_dtype,
@@ -338,12 +337,6 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
     # ------------------------------------------------------------------------
     # Index Methods
 
-    def __array__(self, dtype=None) -> np.ndarray:
-        if is_integer_dtype(dtype):
-            return self.asi8
-        else:
-            return self.astype(object).values
-
     def __array_wrap__(self, result, context=None):
         """
         Gets called after a ufunc. Needs additional handling as
diff --git a/pandas/tests/arrays/test_datetimelike.py b/pandas/tests/arrays/test_datetimelike.py
index 17818b6ce..f99ee542d 100644
--- a/pandas/tests/arrays/test_datetimelike.py
+++ b/pandas/tests/arrays/test_datetimelike.py
@@ -687,10 +687,10 @@ class TestPeriodArray(SharedTests):
         result = np.asarray(arr, dtype=object)
         tm.assert_numpy_array_equal(result, expected)
 
-        # to other dtypes
-        with pytest.raises(TypeError):
-            np.asarray(arr, dtype="int64")
+        result = np.asarray(arr, dtype="int64")
+        tm.assert_numpy_array_equal(result, arr.asi8)
 
+        # to other dtypes
         with pytest.raises(TypeError):
             np.asarray(arr, dtype="float64")
 
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index ab3e967f1..b4c223be0 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -681,3 +681,32 @@ def test_is_monotonic_with_nat():
         assert not obj.is_monotonic_increasing
         assert not obj.is_monotonic_decreasing
         assert obj.is_unique
+
+
+@pytest.mark.parametrize("array", [True, False])
+def test_dunder_array(array):
+    obj = PeriodIndex(["2000-01-01", "2001-01-01"], freq="D")
+    if array:
+        obj = obj._data
+
+    expected = np.array([obj[0], obj[1]], dtype=object)
+    result = np.array(obj)
+    tm.assert_numpy_array_equal(result, expected)
+
+    result = np.asarray(obj)
+    tm.assert_numpy_array_equal(result, expected)
+
+    expected = obj.asi8
+    for dtype in ["i8", "int64", np.int64]:
+        result = np.array(obj, dtype=dtype)
+        tm.assert_numpy_array_equal(result, expected)
+
+        result = np.asarray(obj, dtype=dtype)
+        tm.assert_numpy_array_equal(result, expected)
+
+    for dtype in ["float64", "int32", "uint64"]:
+        msg = "argument must be"
+        with pytest.raises(TypeError, match=msg):
+            np.array(obj, dtype=dtype)
+        with pytest.raises(TypeError, match=msg):
+            np.array(obj, dtype=getattr(np, dtype))

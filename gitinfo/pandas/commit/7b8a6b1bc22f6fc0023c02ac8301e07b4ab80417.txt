commit 7b8a6b1bc22f6fc0023c02ac8301e07b4ab80417
Author: Sam Foo <sfoohei@gmail.com>
Date:   Wed Apr 12 13:49:49 2017 -0700

    VIS: Allow 'C0'-like plotting for plotting colors #15516 (#15873)
    
    * VIS: Allow 'C0'-like plotting for plotting colors
    
    * Added case color='' and support for mpl < 2.0
    
    * Updated prop_cycle references to be compatible with matplotlib 1.5 and 2.0
    
    * Separated test; Used more consise regex

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index fd1cd3d00..defabee3c 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -345,6 +345,7 @@ Other Enhancements
 - The ``skiprows`` argument in ``pd.read_csv()`` now accepts a callable function as a value  (:issue:`10882`)
 - The ``nrows`` and ``chunksize`` arguments in ``pd.read_csv()`` are supported if both are passed (:issue:`6774`, :issue:`15755`)
 - ``pd.DataFrame.plot`` now prints a title above each subplot if ``suplots=True`` and ``title`` is a list of strings (:issue:`14753`)
+- ``pd.DataFrame.plot`` can pass `matplotlib 2.0 default color cycle as a single string as color parameter <http://matplotlib.org/2.0.0/users/colors.html#cn-color-selection>`__. (:issue:`15516`)
 - ``pd.Series.interpolate`` now supports timedelta as an index type with ``method='time'`` (:issue:`6424`)
 - ``Timedelta.isoformat`` method added for formatting Timedeltas as an `ISO 8601 duration`_. See the :ref:`Timedelta docs <timedeltas.isoformat>` (:issue:`15136`)
 - ``.select_dtypes()`` now allows the string 'datetimetz' to generically select datetimes with tz (:issue:`14910`)
diff --git a/pandas/tests/plotting/test_frame.py b/pandas/tests/plotting/test_frame.py
index 1527637ea..8090b9cc4 100644
--- a/pandas/tests/plotting/test_frame.py
+++ b/pandas/tests/plotting/test_frame.py
@@ -141,6 +141,22 @@ class TestDataFramePlots(TestPlotBase):
             result = ax.get_axes()  # deprecated
         self.assertIs(result, axes[0])
 
+    # GH 15516
+    def test_mpl2_color_cycle_str(self):
+        # test CN mpl 2.0 color cycle
+        if self.mpl_ge_2_0_0:
+            colors = ['C' + str(x) for x in range(10)]
+            df = DataFrame(randn(10, 3), columns=['a', 'b', 'c'])
+            for c in colors:
+                _check_plot_works(df.plot, color=c)
+        else:
+            pytest.skip("not supported in matplotlib < 2.0.0")
+
+    def test_color_empty_string(self):
+        df = DataFrame(randn(10, 2))
+        with tm.assertRaises(ValueError):
+            df.plot(color='')
+
     def test_color_and_style_arguments(self):
         df = DataFrame({'x': [1, 2], 'y': [3, 4]})
         # passing both 'color' and 'style' arguments should be allowed
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index f70a2b0b2..99e56ca80 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -225,10 +225,18 @@ def _get_standard_colors(num_colors=None, colormap=None, color_type='default',
         # check whether each character can be convertable to colors
         maybe_color_cycle = _maybe_valid_colors(list(colors))
         if maybe_single_color and maybe_color_cycle and len(colors) > 1:
-            msg = ("'{0}' can be parsed as both single color and "
-                   "color cycle. Specify each color using a list "
-                   "like ['{0}'] or {1}")
-            raise ValueError(msg.format(colors, list(colors)))
+            # Special case for single str 'CN' match and convert to hex
+            # for supporting matplotlib < 2.0.0
+            if re.match(r'\AC[0-9]\Z', colors) and _mpl_ge_2_0_0():
+                hex_color = [c['color']
+                             for c in list(plt.rcParams['axes.prop_cycle'])]
+                colors = [hex_color[int(colors[1])]]
+            else:
+                # this may no longer be required
+                msg = ("'{0}' can be parsed as both single color and "
+                       "color cycle. Specify each color using a list "
+                       "like ['{0}'] or {1}")
+                raise ValueError(msg.format(colors, list(colors)))
         elif maybe_single_color:
             colors = [colors]
         else:
@@ -237,7 +245,10 @@ def _get_standard_colors(num_colors=None, colormap=None, color_type='default',
             pass
 
     if len(colors) != num_colors:
-        multiple = num_colors // len(colors) - 1
+        try:
+            multiple = num_colors // len(colors) - 1
+        except ZeroDivisionError:
+            raise ValueError("Invalid color argument: ''")
         mod = num_colors % len(colors)
 
         colors += multiple * colors

commit d79203af0552e73933e6f80f4284ac2697372eaa
Author: Tom Augspurger <TomAugspurger@users.noreply.github.com>
Date:   Fri Jun 8 11:54:36 2018 -0500

    Revert change to comparison op with datetime.date objects (#21361)

diff --git a/doc/source/whatsnew/v0.23.1.txt b/doc/source/whatsnew/v0.23.1.txt
index 896ada19c..1a8b1603d 100644
--- a/doc/source/whatsnew/v0.23.1.txt
+++ b/doc/source/whatsnew/v0.23.1.txt
@@ -15,6 +15,47 @@ and bug fixes. We recommend that all users upgrade to this version.
 Fixed Regressions
 ~~~~~~~~~~~~~~~~~
 
+**Comparing Series with datetime.date**
+
+We've reverted a 0.23.0 change to comparing a :class:`Series` holding datetimes and a ``datetime.date`` object (:issue:`21152`).
+In pandas 0.22 and earlier, comparing a Series holding datetimes and ``datetime.date`` objects would coerce the ``datetime.date`` to a datetime before comapring.
+This was inconsistent with Python, NumPy, and :class:`DatetimeIndex`, which never consider a datetime and ``datetime.date`` equal.
+
+In 0.23.0, we unified operations between DatetimeIndex and Series, and in the process changed comparisons between a Series of datetimes and ``datetime.date`` without warning.
+
+We've temporarily restored the 0.22.0 behavior, so datetimes and dates may again compare equal, but restore the 0.23.0 behavior in a future release.
+
+To summarize, here's the behavior in 0.22.0, 0.23.0, 0.23.1:
+
+.. code-block:: python
+
+   # 0.22.0... Silently coerce the datetime.date
+   >>> Series(pd.date_range('2017', periods=2)) == datetime.date(2017, 1, 1)
+   0     True
+   1    False
+   dtype: bool
+
+   # 0.23.0... Do not coerce the datetime.date
+   >>> Series(pd.date_range('2017', periods=2)) == datetime.date(2017, 1, 1)
+   0    False
+   1    False
+   dtype: bool
+
+   # 0.23.1... Coerce the datetime.date with a warning
+   >>> Series(pd.date_range('2017', periods=2)) == datetime.date(2017, 1, 1)
+   /bin/python:1: FutureWarning: Comparing Series of datetimes with 'datetime.date'.  Currently, the
+   'datetime.date' is coerced to a datetime. In the future pandas will
+   not coerce, and the values not compare equal to the 'datetime.date'.
+   To retain the current behavior, convert the 'datetime.date' to a
+   datetime with 'pd.Timestamp'.
+     #!/bin/python3
+   0     True
+   1    False
+   dtype: bool
+
+In addition, ordering comparisons will raise a ``TypeError`` in the future.
+
+**Other Fixes**
 
 - Reverted the ability of :func:`~DataFrame.to_sql` to perform multivalue
   inserts as this caused regression in certain cases (:issue:`21103`).
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index e14f82906..540ebeee4 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -5,7 +5,10 @@ This is not a public API.
 """
 # necessary to enforce truediv in Python 2.X
 from __future__ import division
+import datetime
 import operator
+import textwrap
+import warnings
 
 import numpy as np
 import pandas as pd
@@ -1197,8 +1200,35 @@ def _comp_method_SERIES(cls, op, special):
         if is_datetime64_dtype(self) or is_datetime64tz_dtype(self):
             # Dispatch to DatetimeIndex to ensure identical
             # Series/Index behavior
+            if (isinstance(other, datetime.date) and
+                    not isinstance(other, datetime.datetime)):
+                # https://github.com/pandas-dev/pandas/issues/21152
+                # Compatibility for difference between Series comparison w/
+                # datetime and date
+                msg = (
+                    "Comparing Series of datetimes with 'datetime.date'.  "
+                    "Currently, the 'datetime.date' is coerced to a "
+                    "datetime. In the future pandas will not coerce, "
+                    "and {future}. "
+                    "To retain the current behavior, "
+                    "convert the 'datetime.date' to a datetime with "
+                    "'pd.Timestamp'."
+                )
+
+                if op in {operator.lt, operator.le, operator.gt, operator.ge}:
+                    future = "a TypeError will be raised"
+                else:
+                    future = (
+                        "'the values will not compare equal to the "
+                        "'datetime.date'"
+                    )
+                msg = '\n'.join(textwrap.wrap(msg.format(future=future)))
+                warnings.warn(msg, FutureWarning, stacklevel=2)
+                other = pd.Timestamp(other)
+
             res_values = dispatch_to_index_op(op, self, other,
                                               pd.DatetimeIndex)
+
             return self._constructor(res_values, index=self.index,
                                      name=res_name)
 
diff --git a/pandas/tests/series/test_arithmetic.py b/pandas/tests/series/test_arithmetic.py
index ec0d7296e..95836f046 100644
--- a/pandas/tests/series/test_arithmetic.py
+++ b/pandas/tests/series/test_arithmetic.py
@@ -88,6 +88,46 @@ class TestSeriesComparison(object):
 
 
 class TestTimestampSeriesComparison(object):
+    def test_dt64_ser_cmp_date_warning(self):
+        # https://github.com/pandas-dev/pandas/issues/21359
+        # Remove this test and enble invalid test below
+        ser = pd.Series(pd.date_range('20010101', periods=10), name='dates')
+        date = ser.iloc[0].to_pydatetime().date()
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser == date
+        expected = pd.Series([True] + [False] * 9, name='dates')
+        tm.assert_series_equal(result, expected)
+        assert "Comparing Series of datetimes " in str(m[0].message)
+        assert "will not compare equal" in str(m[0].message)
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser != date
+        tm.assert_series_equal(result, ~expected)
+        assert "will not compare equal" in str(m[0].message)
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser <= date
+        tm.assert_series_equal(result, expected)
+        assert "a TypeError will be raised" in str(m[0].message)
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser < date
+        tm.assert_series_equal(result, pd.Series([False] * 10, name='dates'))
+        assert "a TypeError will be raised" in str(m[0].message)
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser >= date
+        tm.assert_series_equal(result, pd.Series([True] * 10, name='dates'))
+        assert "a TypeError will be raised" in str(m[0].message)
+
+        with tm.assert_produces_warning(FutureWarning) as m:
+            result = ser > date
+        tm.assert_series_equal(result, pd.Series([False] + [True] * 9,
+                                                 name='dates'))
+        assert "a TypeError will be raised" in str(m[0].message)
+
+    @pytest.mark.skip(reason="GH-21359")
     def test_dt64ser_cmp_date_invalid(self):
         # GH#19800 datetime.date comparison raises to
         # match DatetimeIndex/Timestamp.  This also matches the behavior

commit 4a3da960e8c3c607befb835a42f7237ce3564774
Author: y-p <yoval@gmx.com>
Date:   Mon Dec 31 15:11:02 2012 +0200

    BUG: when parsing partial date, use sane defaults for missing fields GH2618
    
    dateutil uses the current date to fill in missing fields, this
    is desirable for year and month, but will cause an exception
    when code is run on the 31st day of a month, and trying to parse
    "2000 2" as feb 2000, because feb doesn't have 31 days.
    
    So we default to current year and month, but always the first of the month.

diff --git a/RELEASE.rst b/RELEASE.rst
index eded818ae..51aec0833 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -103,6 +103,7 @@ pandas 0.10.1
   - Upconvert datetime + datetime64 values when concatenating frames (GH2624_)
   - Raise a more helpful error message in merge operations when one DataFrame
     has duplicate columns (GH2649_)
+  - Fix partial date parsing issue occuring only when code is run at EOM  (GH2618_)
 
 **API Changes**
 
@@ -140,6 +141,7 @@ pandas 0.10.1
 .. _GH2700: https://github.com/pydata/pandas/issues/2700
 .. _GH2694: https://github.com/pydata/pandas/issues/2694
 .. _GH2686: https://github.com/pydata/pandas/issues/2686
+.. _GH2618: https://github.com/pydata/pandas/issues/2618
 
 pandas 0.10.0
 =============
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 30d809c9f..41ac1b3f3 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -513,20 +513,24 @@ def convert_sql_column(x):
     return maybe_convert_objects(x, try_float=1)
 
 def try_parse_dates(ndarray[object] values, parser=None,
-                    dayfirst=False):
+                    dayfirst=False,default=None):
     cdef:
         Py_ssize_t i, n
         ndarray[object] result
 
-    from datetime import datetime
+    from datetime import datetime, timedelta
 
     n = len(values)
     result = np.empty(n, dtype='O')
 
     if parser is None:
+        if default is None: # GH2618
+           date=datetime.now()
+           default=datetime(date.year,date.month,1)
+
         try:
             from dateutil.parser import parse
-            parse_date = lambda x: parse(x, dayfirst=dayfirst)
+            parse_date = lambda x: parse(x, dayfirst=dayfirst,default=default)
         except ImportError: # pragma: no cover
             def parse_date(s):
                 try:
@@ -560,12 +564,12 @@ def try_parse_dates(ndarray[object] values, parser=None,
 
 def try_parse_date_and_time(ndarray[object] dates, ndarray[object] times,
                             date_parser=None, time_parser=None,
-                            dayfirst=False):
+                            dayfirst=False,default=None):
     cdef:
         Py_ssize_t i, n
         ndarray[object] result
 
-    from datetime import date, time, datetime
+    from datetime import date, time, datetime, timedelta
 
     n = len(dates)
     if len(times) != n:
@@ -573,9 +577,13 @@ def try_parse_date_and_time(ndarray[object] dates, ndarray[object] times,
     result = np.empty(n, dtype='O')
 
     if date_parser is None:
+        if default is None: # GH2618
+           date=datetime.now()
+           default=datetime(date.year,date.month,1)
+
         try:
             from dateutil.parser import parse
-            parse_date = lambda x: parse(x, dayfirst=dayfirst)
+            parse_date = lambda x: parse(x, dayfirst=dayfirst, default=default)
         except ImportError: # pragma: no cover
             def parse_date(s):
                 try:

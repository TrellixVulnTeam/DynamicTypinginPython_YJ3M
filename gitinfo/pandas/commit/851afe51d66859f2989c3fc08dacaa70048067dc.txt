commit 851afe51d66859f2989c3fc08dacaa70048067dc
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 14 17:10:24 2012 -0400

    ENH: more flexible multiple function application in DataFrameGroupBy, close #642

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 36b80af0f..e5ce4ffdf 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1212,7 +1212,7 @@ class SeriesGroupBy(GroupBy):
             arg = arg.items()
         elif isinstance(arg[0], (tuple, list)):
             # indicated column order
-            columns = zip(*arg)[0]
+            columns = list(zip(*arg))[0]
         else:
             # list of functions
             columns = [func.__name__ for func in arg]
@@ -1405,22 +1405,38 @@ class NDFrameGroupBy(GroupBy):
 
             obj = self._obj_with_exclusions
 
+            if any(isinstance(x, (list, tuple, dict)) for x in arg.values()):
+                new_arg = {}
+                for k, v in arg.iteritems():
+                    if not isinstance(v, (tuple, list, dict)):
+                        new_arg[k] = [v]
+                    else:
+                        new_arg[k] = v
+                arg = new_arg
+
+            keys = []
             if self._selection is not None:
                 subset = obj[self._selection]
                 if isinstance(subset, DataFrame):
                     raise NotImplementedError
 
-                for fname, func in arg.iteritems():
+                for fname, agg_how in arg.iteritems():
                     colg = SeriesGroupBy(subset, selection=self._selection,
                                          grouper=self.grouper)
-                    result[fname] = colg.aggregate(func)
+                    result[fname] = colg.aggregate(agg_how)
+                    keys.append(fname)
             else:
-                for col, func in arg.iteritems():
+                for col, agg_how in arg.iteritems():
                     colg = SeriesGroupBy(obj[col], selection=col,
                                          grouper=self.grouper)
-                    result[col] = colg.aggregate(func)
+                    result[col] = colg.aggregate(agg_how)
+                    keys.append(col)
 
-            result = DataFrame(result)
+            if isinstance(result.values()[0], DataFrame):
+                from pandas.tools.merge import concat
+                result = concat([result[k] for k in keys], keys=keys, axis=1)
+            else:
+                result = DataFrame(result)
         elif isinstance(arg, list):
             return self._aggregate_multiple_funcs(arg)
         else:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 232ff886d..992b6718e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1635,8 +1635,8 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         # cast type
         frame = DataFrame(mat, columns=['A', 'B', 'C'],
-                           index=[1, 2], dtype=int)
-        self.assert_(frame.values.dtype == int)
+                           index=[1, 2], dtype=np.int64)
+        self.assert_(frame.values.dtype == np.int64)
 
         # Check non-masked values
         mat2 = ma.copy(mat)
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index a4fbe444d..524738e09 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -1730,13 +1730,47 @@ class TestGroupBy(unittest.TestCase):
         assert_frame_equal(result2, expected)
 
     def test_agg_multiple_functions_maintain_order(self):
-
+        # GH #610
         funcs = [('mean', np.mean), ('max', np.max), ('min', np.min)]
         result = self.df.groupby('A')['C'].agg(funcs)
         exp_cols = ['mean', 'max', 'min']
 
         self.assert_(np.array_equal(result.columns, exp_cols))
 
+    def test_more_flexible_frame_multi_function(self):
+        from pandas import concat
+
+        grouped = self.df.groupby('A')
+
+        exmean = grouped.agg({'C' : np.mean, 'D' : np.mean})
+        exstd = grouped.agg({'C' : np.std, 'D' : np.std})
+
+        expected = concat([exmean, exstd], keys=['mean', 'std'], axis=1)
+        expected = expected.swaplevel(0, 1, axis=1).sortlevel(0, axis=1)
+
+        result = grouped.aggregate({'C' : [np.mean, np.std],
+                                    'D' : [np.mean, np.std]})
+
+        assert_frame_equal(result, expected)
+
+        # be careful
+        result = grouped.aggregate({'C' : np.mean,
+                                     'D' : [np.mean, np.std]})
+        expected = grouped.aggregate({'C' : [np.mean],
+                                      'D' : [np.mean, np.std]})
+        assert_frame_equal(result, expected)
+
+
+        def foo(x): return np.mean(x)
+        def bar(x): return np.std(x, ddof=1)
+        result = grouped.aggregate({'C' : np.mean,
+                                    'D' : {'foo': np.mean,
+                                           'bar': np.std}})
+        expected = grouped.aggregate({'C' : [np.mean],
+                                      'D' : [foo, bar]})
+        assert_frame_equal(result, expected)
+
+
 
 def _check_groupby(df, result, keys, field, f=lambda x: x.sum()):
     tups = map(tuple, df[keys].values)

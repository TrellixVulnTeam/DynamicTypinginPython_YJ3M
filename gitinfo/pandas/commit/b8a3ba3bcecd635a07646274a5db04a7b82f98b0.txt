commit b8a3ba3bcecd635a07646274a5db04a7b82f98b0
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Sat Sep 14 16:42:55 2013 -0400

    CLN: correct in and not in
    
    Also added tests for nan in and not in and disallowed ops like
    
        pd.eval('1 or 2')
    
    since that should be performed in regular Python

diff --git a/doc/source/enhancingperf.rst b/doc/source/enhancingperf.rst
index b876b6fe7..6d5717e42 100644
--- a/doc/source/enhancingperf.rst
+++ b/doc/source/enhancingperf.rst
@@ -384,6 +384,14 @@ Now let's do the same thing but with comparisons:
 
    %timeit pd.eval('df1 + df2 + df3 + df4 + s')
 
+.. note::
+
+   Operations such as ``1 and 2`` should be performed in Python. An exception
+   will be raised if you try to performed any boolean or bitwise operations
+   with scalar operands that are not of type ``bool`` or ``np.bool_``. *This
+   includes bitwise operations on scalars.* You should perform these kinds of
+   operations in Python.
+
 The ``DataFrame.eval`` method
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -393,7 +401,7 @@ evaluate an expression in the "context" of a ``DataFrame``.
 
 .. ipython:: python
 
-   df = DataFrame(randn(10, 2), columns=['a', 'b'])
+   df = DataFrame(randn(5, 2), columns=['a', 'b'])
    df.eval('a + b')
 
 
@@ -410,7 +418,7 @@ You can refer to local variables the same way you would in vanilla Python
 
 .. ipython:: python
 
-   df = DataFrame(randn(10, 2), columns=['a', 'b'])
+   df = DataFrame(randn(5, 2), columns=['a', 'b'])
    newcol = randn(len(df))
    df.eval('b + newcol')
 
@@ -419,16 +427,22 @@ You can refer to local variables the same way you would in vanilla Python
    The one exception is when you have a local (or global) with the same name as
    a column in the ``DataFrame``
 
-    .. ipython:: python
-       :okexcept:
+    .. code-block:: python
 
-       df = DataFrame(randn(10, 2), columns=['a', 'b'])
+       df = DataFrame(randn(5, 2), columns=['a', 'b'])
        a = randn(len(df))
        df.eval('a + b')
+       NameResolutionError: resolvers and locals overlap on names ['a']
+
 
    To deal with these conflicts, a special syntax exists for referring
    variables with the same name as a column
 
+    .. ipython:: python
+       :suppress:
+
+       a = randn(len(df))
+
     .. ipython:: python
 
        df.eval('@a + b')
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 003be5a79..7d22fb533 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -1014,8 +1014,7 @@ The :meth:`~pandas.DataFrame.query` Method
 .. versionadded:: 0.13
 
 :class:`~pandas.DataFrame` objects have a :meth:`~pandas.DataFrame.query`
-method that allows selection using a string consisting of columns of the
-calling :class:`~pandas.DataFrame`.
+method that allows selection using a boolean expression.
 
 You can get the value of the frame where column ``b`` has values
 between the values of columns ``a`` and ``c``.
@@ -1027,7 +1026,7 @@ between the values of columns ``a`` and ``c``.
 
 .. ipython:: python
 
-   n = 20
+   n = 10
    df = DataFrame(rand(n, 3), columns=list('abc'))
    df
    df[(df.a < df.b) & (df.b < df.c)]
@@ -1038,7 +1037,7 @@ with the name ``a``.
 
 .. ipython:: python
 
-   df = DataFrame(randint(n, size=(n, 2)), columns=list('bc'))
+   df = DataFrame(randint(n / 2, size=(n, 2)), columns=list('bc'))
    df.index.name = 'a'
    df
    df.query('a < b and b < c')
@@ -1075,13 +1074,14 @@ You can also use the levels of a ``DataFrame`` with a
 
    import pandas.util.testing as tm
 
-   colors = tm.choice(['red', 'green'], size=10)
-   foods = tm.choice(['eggs', 'ham'], size=10)
+   n = 10
+   colors = tm.choice(['red', 'green'], size=n)
+   foods = tm.choice(['eggs', 'ham'], size=n)
    colors
    foods
 
    index = MultiIndex.from_arrays([colors, foods], names=['color', 'food'])
-   df = DataFrame(randn(10, 2), index=index)
+   df = DataFrame(randn(n, 2), index=index)
    df
    df.query('color == "red"')
 
@@ -1091,8 +1091,7 @@ special names:
 
 .. ipython:: python
 
-   index.names = [None, None]
-   df = DataFrame(randn(10, 2), index=index)
+   df.index.names = [None, None]
    df
    df.query('ilevel_0 == "red"')
 
@@ -1111,9 +1110,9 @@ having to specify which frame you're interested in querying
 
 .. ipython:: python
 
-   df = DataFrame(randint(n, size=(n, 2)), columns=list('bc'))
+   df = DataFrame(randint(n / 2, size=(n, 2)), columns=list('bc'))
    df.index.name = 'a'
-   df2 = DataFrame(randint(n + 10, size=(n + 10, 3)), columns=list('abc'))
+   df2 = DataFrame(randint(n + 5, size=(n + 5, 3)), columns=list('abc'))
    df2
    expr = 'a < b & b < c'
    map(lambda frame: frame.query(expr), [df, df2])
@@ -1141,7 +1140,7 @@ Full numpy-like syntax
 
 .. ipython:: python
 
-   df = DataFrame(randint(n, size=(n, 3)), columns=list('abc'))
+   df = DataFrame(randint(n / 2, size=(n, 3)), columns=list('abc'))
    df
    df['(a < b) & (b < c)']
    df[(df.a < df.b) & (df.b < df.c)]
@@ -1164,10 +1163,6 @@ Pretty close to how you might write it on paper
 
    df['a < b < c']
 
-As you can see, these are all equivalent ways to express the same operation (in
-fact, they are all ultimately parsed into something very similar to the first
-example of the indexing syntax above).
-
 The ``in`` and ``not in`` operators
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -1184,7 +1179,7 @@ The ``in`` and ``not in`` operators
 .. ipython:: python
 
    # get all rows where columns "a" and "b" have overlapping values
-   df = DataFrame({'a': list('aaaabbbbcccc'), 'b': list('aabbccddeeff'),
+   df = DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
                    'c': randint(5, size=12), 'd': randint(9, size=12)})
    df
    df['a in b']
diff --git a/pandas/computation/expr.py b/pandas/computation/expr.py
index d8969e129..db92e7f57 100644
--- a/pandas/computation/expr.py
+++ b/pandas/computation/expr.py
@@ -461,10 +461,10 @@ class BaseExprVisitor(ast.NodeVisitor):
                 name = self.env.add_tmp([right.value])
                 right = self.term_type(name, self.env)
 
-            # swap the operands so things like a == [1, 2] are translated to
-            # [1, 2] in a -> a.isin([1, 2])
-            if right_list or right_str:
-                left, right = right, left
+            if left_str:
+                self.env.remove_tmp(left.name)
+                name = self.env.add_tmp([left.value])
+                left = self.term_type(name, self.env)
 
         op = self.visit(op_instance)
         return op, op_instance, left, right
@@ -662,13 +662,14 @@ class BaseExprVisitor(ast.NodeVisitor):
         return reduce(visitor, operands)
 
 
-_python_not_supported = frozenset(['Assign', 'Tuple', 'Dict', 'Call',
-                                   'BoolOp', 'In', 'NotIn'])
+_python_not_supported = frozenset(['Assign', 'Dict', 'Call', 'BoolOp',
+                                   'In', 'NotIn'])
 _numexpr_supported_calls = frozenset(_reductions + _mathops)
 
 
 @disallow((_unsupported_nodes | _python_not_supported) -
-          (_boolop_nodes | frozenset(['BoolOp', 'Attribute', 'In', 'NotIn'])))
+          (_boolop_nodes | frozenset(['BoolOp', 'Attribute', 'In', 'NotIn',
+                                      'Tuple'])))
 class PandasExprVisitor(BaseExprVisitor):
     def __init__(self, env, engine, parser,
                  preparser=lambda x: _replace_locals(_replace_booleans(x))):
diff --git a/pandas/computation/ops.py b/pandas/computation/ops.py
index 14f67a3ab..debc79e33 100644
--- a/pandas/computation/ops.py
+++ b/pandas/computation/ops.py
@@ -193,6 +193,13 @@ class Term(StringMixin):
     def name(self, new_name):
         self._name = new_name
 
+    @property
+    def ndim(self):
+        try:
+            return self._value.ndim
+        except AttributeError:
+            return 0
+
 
 class Constant(Term):
     def __init__(self, value, env, side=None, encoding=None):
@@ -207,6 +214,7 @@ class Constant(Term):
         return self.value
 
 
+
 _bool_op_map = {'not': '~', 'and': '&', 'or': '|'}
 
 
@@ -236,17 +244,24 @@ class Op(StringMixin):
             return np.bool_
         return np.result_type(*(term.type for term in com.flatten(self)))
 
+    @property
+    def isscalar(self):
+        return all(operand.isscalar for operand in self.operands)
+
 
 def _in(x, y):
     """Compute the vectorized membership of ``x in y`` if possible, otherwise
     use Python.
     """
     try:
-        return y.isin(x)
+        return x.isin(y)
     except AttributeError:
+        if com.is_list_like(x):
+            try:
+                return y.isin(x)
+            except AttributeError:
+                pass
         return x in y
-    except TypeError:
-        return y.isin([x])
 
 
 def _not_in(x, y):
@@ -254,11 +269,14 @@ def _not_in(x, y):
     otherwise use Python.
     """
     try:
-        return ~y.isin(x)
+        return ~x.isin(y)
     except AttributeError:
+        if com.is_list_like(x):
+            try:
+                return ~y.isin(x)
+            except AttributeError:
+                pass
         return x not in y
-    except TypeError:
-        return ~y.isin([x])
 
 
 _cmp_ops_syms = '>', '<', '>=', '<=', '==', '!=', 'in', 'not in'
@@ -322,14 +340,17 @@ class BinOp(Op):
         self.lhs = lhs
         self.rhs = rhs
 
+        self._disallow_scalar_only_bool_ops()
+
         self.convert_values()
 
         try:
             self.func = _binary_ops_dict[op]
         except KeyError:
-            keys = _binary_ops_dict.keys()
+            # has to be made a list for python3
+            keys = list(_binary_ops_dict.keys())
             raise ValueError('Invalid binary operator {0!r}, valid'
-                                      ' operators are {1}'.format(op, keys))
+                             ' operators are {1}'.format(op, keys))
 
     def __call__(self, env):
         """Recursively evaluate an expression in Python space.
@@ -425,6 +446,13 @@ class BinOp(Op):
                 v = v.tz_convert('UTC')
             self.lhs.update(v)
 
+    def _disallow_scalar_only_bool_ops(self):
+        if ((self.lhs.isscalar or self.rhs.isscalar) and
+            self.op in _bool_ops_dict and
+            (not (issubclass(self.rhs.return_type, (bool, np.bool_)) and
+                  issubclass(self.lhs.return_type, (bool, np.bool_))))):
+            raise NotImplementedError("cannot evaluate scalar only bool ops")
+
 
 class Div(BinOp):
     """Div operator to special case casting.
diff --git a/pandas/computation/tests/test_eval.py b/pandas/computation/tests/test_eval.py
index 8fb1b35ab..d5bcf85d4 100755
--- a/pandas/computation/tests/test_eval.py
+++ b/pandas/computation/tests/test_eval.py
@@ -85,7 +85,12 @@ def skip_incompatible_operand(f):
         if _series_and_2d_ndarray(lhs, rhs):
             self.assertRaises(Exception, pd.eval, 'lhs {0} rhs'.format(arith1),
                               local_dict={'lhs': lhs, 'rhs': rhs},
-                              engine=self.engine)
+                              engine=self.engine, parser=self.parser)
+        elif (np.isscalar(lhs) and np.isscalar(rhs) and arith1 in
+                _bool_ops_syms):
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('lhs {0} rhs'.format(arith1), engine=self.engine,
+                        parser=self.parser)
         else:
             f(self, lhs, arith1, rhs, *args, **kwargs)
     return wrapper
@@ -215,6 +220,17 @@ class TestEvalNumexprPandas(unittest.TestCase):
             self.assertRaises(TypeError, pd.eval, ex,
                               local_dict={'lhs': lhs, 'rhs': rhs},
                               engine=self.engine, parser=self.parser)
+        elif _bool_and_frame(lhs, rhs):
+            self.assertRaises(TypeError, _eval_single_bin, lhs_new, '&',
+                              rhs_new, self.engine)
+            self.assertRaises(TypeError, pd.eval, ex,
+                              local_dict={'lhs': lhs, 'rhs': rhs},
+                              engine=self.engine, parser=self.parser)
+        elif (np.isscalar(lhs) and np.isnan(lhs) and
+                not np.isscalar(rhs) and (cmp1 in skip_these or cmp2 in
+                    skip_these)):
+            with tm.assertRaises(TypeError):
+                _eval_single_bin(lhs, binop, rhs, self.engine)
         else:
             lhs_new = _eval_single_bin(lhs, cmp1, rhs, self.engine)
             rhs_new = _eval_single_bin(lhs, cmp2, rhs, self.engine)
@@ -231,7 +247,16 @@ class TestEvalNumexprPandas(unittest.TestCase):
                 #except AssertionError:
                     #import ipdb; ipdb.set_trace()
                     #raise
-
+            elif (np.isscalar(lhs_new) and np.isnan(lhs_new) and
+                    not np.isscalar(rhs_new) and binop in skip_these):
+                with tm.assertRaises(TypeError):
+                    _eval_single_bin(lhs_new, binop, rhs_new, self.engine)
+            elif _bool_and_frame(lhs_new, rhs_new):
+                with tm.assertRaises(TypeError):
+                    _eval_single_bin(lhs_new, binop, rhs_new, self.engine)
+                with tm.assertRaises(TypeError):
+                    pd.eval('lhs_new & rhs_new'.format(binop),
+                            engine=self.engine, parser=self.parser)
             else:
                 expected = _eval_single_bin(lhs_new, binop, rhs_new, self.engine)
                 result = pd.eval(ex, engine=self.engine, parser=self.parser)
@@ -242,6 +267,21 @@ class TestEvalNumexprPandas(unittest.TestCase):
         skip_these = 'in', 'not in'
 
         def check_operands(left, right, cmp_op):
+            if (np.isscalar(left) and np.isnan(left) and not np.isscalar(right)
+                    and cmp_op in skip_these):
+                ex = 'left {0} right'.format(cmp_op)
+                with tm.assertRaises(ValueError):
+                    pd.eval(ex, engine=self.engine, parser=self.parser)
+                return
+            if (np.isscalar(left) and np.isscalar(right) and
+                    cmp_op in _bool_ops_syms):
+                ex1 = 'lhs {0} mid {1} rhs'.format(cmp1, cmp2)
+                ex2 = 'lhs {0} mid and mid {1} rhs'.format(cmp1, cmp2)
+                ex3 = '(lhs {0} mid) & (mid {1} rhs)'.format(cmp1, cmp2)
+                for ex in (ex1, ex2, ex3):
+                    with assertRaises(NotImplementedError):
+                        pd.eval(ex, engine=self.engine, parser=self.parser)
+                return
             if (np.isscalar(right) and not np.isscalar(left) and cmp_op in
                     skip_these):
                 self.assertRaises(Exception, _eval_single_bin, left, cmp_op,
@@ -294,8 +334,8 @@ class TestEvalNumexprPandas(unittest.TestCase):
         ex = 'lhs {0} rhs'.format(cmp1)
         if cmp1 in ('in', 'not in') and not com.is_list_like(rhs):
             self.assertRaises(TypeError, pd.eval, ex, engine=self.engine,
-                              parser=self.parser, local_dict={'lhs': lhs,
-                                                              'rhs': rhs})
+                            parser=self.parser, local_dict={'lhs': lhs,
+                                                            'rhs': rhs})
         else:
             expected = _eval_single_bin(lhs, cmp1, rhs, self.engine)
             result = pd.eval(ex, engine=self.engine, parser=self.parser)
@@ -414,11 +454,19 @@ class TestEvalNumexprPandas(unittest.TestCase):
             self.assertRaises(TypeError, pd.eval, ex, engine=self.engine,
                               parser=self.parser, local_dict={'lhs': lhs,
                                                               'rhs': rhs})
+        elif (np.isscalar(lhs) and np.isnan(lhs) and not np.isscalar(rhs)
+                and cmp1 in skip_these):
+            with tm.assertRaises(ValueError):
+                pd.eval(ex, engine=self.engine, parser=self.parser)
         else:
             # compound
             if np.isscalar(lhs) and np.isscalar(rhs):
                 lhs, rhs = map(lambda x: np.array([x]), (lhs, rhs))
-            expected = ~_eval_single_bin(lhs, cmp1, rhs, self.engine)
+            expected = _eval_single_bin(lhs, cmp1, rhs, self.engine)
+            if np.isscalar(expected):
+                expected = not expected
+            else:
+                expected = ~expected
             result = pd.eval(ex, engine=self.engine, parser=self.parser)
             assert_array_equal(expected, result)
 
@@ -647,6 +695,18 @@ class TestEvalNumexprPandas(unittest.TestCase):
         self.assertEqual(pd.eval('+True', parser=self.parser, engine=self.engine), +True)
         self.assertEqual(pd.eval('+False', parser=self.parser, engine=self.engine), +False)
 
+    def test_disallow_scalar_bool_ops(self):
+        exprs = '1 or 2', '1 and 2'
+        exprs += 'a and b', 'a or b'
+        exprs += '1 or 2 and (3 + 2) > 3',
+        exprs += '2 * x > 2 or 1 and 2',
+        exprs += '2 * df > 3 and 1 or a',
+
+        x, a, b, df = np.random.randn(3), 1, 2, DataFrame(randn(3, 2))
+        for ex in exprs:
+            with tm.assertRaises(NotImplementedError):
+                pd.eval(ex, engine=self.engine, parser=self.parser)
+
 
 class TestEvalNumexprPython(TestEvalNumexprPandas):
     @classmethod
@@ -999,21 +1059,18 @@ class TestOperationsNumExprPandas(unittest.TestCase):
     def test_simple_bool_ops(self):
         for op, lhs, rhs in product(expr._bool_ops_syms, (True, False),
                                     (True, False)):
-            expec = _eval_single_bin(lhs, op, rhs, self.engine)
-            x = self.eval('lhs {0} rhs'.format(op), local_dict={'lhs': lhs,
-                                                                'rhs': rhs},
-                          engine=self.engine, parser=self.parser)
-            assert_equal(x, expec)
+            ex = '{0} {1} {2}'.format(lhs, op, rhs)
+            res = self.eval(ex)
+            exp = eval(ex)
+            self.assertEqual(res, exp)
 
     def test_bool_ops_with_constants(self):
-        asteval = ast.literal_eval
         for op, lhs, rhs in product(expr._bool_ops_syms, ('True', 'False'),
                                     ('True', 'False')):
-            expec = _eval_single_bin(asteval(lhs), op, asteval(rhs),
-                                     self.engine)
-            x = self.eval('{0} {1} {2}'.format(lhs, op, rhs),
-                          local_dict={'lhs': lhs, 'rhs': rhs})
-            assert_equal(x, expec)
+            ex = '{0} {1} {2}'.format(lhs, op, rhs)
+            res = self.eval(ex)
+            exp = eval(ex)
+            self.assertEqual(res, exp)
 
     def test_panel_fails(self):
         x = Panel(randn(3, 4, 5))
@@ -1142,10 +1199,69 @@ class TestOperationsNumExprPandas(unittest.TestCase):
     def test_date_boolean(self):
         df = DataFrame(randn(5, 3))
         df['dates1'] = date_range('1/1/2012', periods=5)
-        res = self.eval('df.dates1 < 20130101', local_dict={'df': df})
+        res = self.eval('df.dates1 < 20130101', local_dict={'df': df},
+                        engine=self.engine, parser=self.parser)
         expec = df.dates1 < '20130101'
         assert_series_equal(res, expec)
 
+    def test_simple_in_ops(self):
+        if self.parser != 'python':
+            res = pd.eval('1 in [1, 2]', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('2 in (1, 2)', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('3 in (1, 2)', engine=self.engine,
+                          parser=self.parser)
+            self.assertFalse(res)
+
+            res = pd.eval('3 not in (1, 2)', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('[3] not in (1, 2)', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('[3] in ([3], 2)', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('[[3]] in [[[3]], 2]', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('(3,) in [(3,), 2]', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+
+            res = pd.eval('(3,) not in [(3,), 2]', engine=self.engine,
+                          parser=self.parser)
+            self.assertFalse(res)
+
+            res = pd.eval('[(3,)] in [[(3,)], 2]', engine=self.engine,
+                          parser=self.parser)
+            self.assertTrue(res)
+        else:
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('1 in [1, 2]', engine=self.engine, parser=self.parser)
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('2 in (1, 2)', engine=self.engine, parser=self.parser)
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('3 in (1, 2)', engine=self.engine, parser=self.parser)
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('3 not in (1, 2)', engine=self.engine,
+                        parser=self.parser)
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('[(3,)] in (1, 2, [(3,)])', engine=self.engine,
+                        parser=self.parser)
+            with tm.assertRaises(NotImplementedError):
+                pd.eval('[3] not in (1, 2, [[3]])', engine=self.engine,
+                        parser=self.parser)
+
 
 class TestOperationsNumExprPython(TestOperationsNumExprPandas):
     @classmethod
@@ -1178,47 +1294,39 @@ class TestOperationsNumExprPython(TestOperationsNumExprPandas):
 
     def test_fails_ampersand(self):
         df = DataFrame(np.random.randn(5, 3))
-        self.assertRaises(TypeError, pd.eval,
-                          '(df + 2)[df > 1] > 0 & (df > 0)',
-                          local_dict={'df': df}, parser=self.parser,
-                          engine=self.engine)
+        ex = '(df + 2)[df > 1] > 0 & (df > 0)'
+        with tm.assertRaises(NotImplementedError):
+            pd.eval(ex, parser=self.parser, engine=self.engine)
 
     def test_fails_pipe(self):
         df = DataFrame(np.random.randn(5, 3))
-        self.assertRaises(TypeError, pd.eval,
-                          '(df + 2)[df > 1] > 0 | (df > 0)',
-                          local_dict={'df': df}, parser=self.parser,
-                          engine=self.engine)
+        ex = '(df + 2)[df > 1] > 0 | (df > 0)'
+        with tm.assertRaises(NotImplementedError):
+            pd.eval(ex, parser=self.parser, engine=self.engine)
 
     def test_bool_ops_with_constants(self):
-        from ast import literal_eval as asteval
         for op, lhs, rhs in product(expr._bool_ops_syms, ('True', 'False'),
                                     ('True', 'False')):
-            if op not in ('and', 'or'):
-                expec = _eval_single_bin(asteval(lhs), op, asteval(rhs),
-                                        self.engine)
-                x = self.eval('{0} {1} {2}'.format(lhs, op, rhs),
-                            local_dict={'lhs': lhs, 'rhs': rhs})
-                assert_equal(x, expec)
+            ex = '{0} {1} {2}'.format(lhs, op, rhs)
+            if op in ('and', 'or'):
+                with tm.assertRaises(NotImplementedError):
+                    self.eval(ex)
             else:
-                self.assertRaises(NotImplementedError,
-                                  self.eval,
-                                  '{0} {1} {2}'.format(lhs, op, rhs),
-                                  local_dict={'lhs': lhs, 'rhs': rhs})
+                res = self.eval(ex)
+                exp = eval(ex)
+                self.assertEqual(res, exp)
 
     def test_simple_bool_ops(self):
-        for op, lhs, rhs in product(expr._bool_ops_syms, (True, False), (True,
-                                                                        False)):
-            if op not in ('and', 'or'):
-                expec = _eval_single_bin(lhs, op, rhs, self.engine)
-                x = self.eval('lhs {0} rhs'.format(op), local_dict={'lhs': lhs,
-                                                                    'rhs': rhs})
-                assert_equal(x, expec)
+        for op, lhs, rhs in product(expr._bool_ops_syms, (True, False),
+                                    (True, False)):
+            ex = 'lhs {0} rhs'.format(op)
+            if op in ('and', 'or'):
+                with tm.assertRaises(NotImplementedError):
+                    pd.eval(ex, engine=self.engine, parser=self.parser)
             else:
-                self.assertRaises(NotImplementedError,
-                                  self.eval,
-                                  'lhs {0} rhs'.format(op),
-                                  local_dict={'lhs': lhs, 'rhs': rhs})
+                res = pd.eval(ex, engine=self.engine, parser=self.parser)
+                exp = eval(ex)
+                self.assertEqual(res, exp)
 
 
 class TestOperationsPythonPython(TestOperationsNumExprPython):
@@ -1229,20 +1337,6 @@ class TestOperationsPythonPython(TestOperationsNumExprPython):
         cls.arith_ops = filter(lambda x: x not in ('in', 'not in'),
                                cls.arith_ops)
 
-    def test_fails_ampersand(self):
-        df = DataFrame(np.random.randn(5, 3))
-        self.assertRaises(TypeError, pd.eval,
-                          '(df + 2)[df > 1] > 0 & (df > 0)',
-                          local_dict={'df': df}, parser=self.parser,
-                          engine=self.engine)
-
-    def test_fails_pipe(self):
-        df = DataFrame(np.random.randn(5, 3))
-        self.assertRaises(TypeError, pd.eval,
-                          '(df + 2)[df > 1] > 0 | (df > 0)',
-                          local_dict={'df': df}, parser=self.parser,
-                          engine=self.engine)
-
 
 class TestOperationsPythonPandas(TestOperationsNumExprPandas):
     @classmethod
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index ae37953da..b871a43e6 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -11782,11 +11782,11 @@ class TestDataFrameQueryStrings(object):
                         'd': np.random.randint(9, size=12)})
         if parser == 'pandas':
             res = df.query('a in b', parser=parser, engine=engine)
-            expec = df[df.b.isin(df.a)]
+            expec = df[df.a.isin(df.b)]
             assert_frame_equal(res, expec)
 
             res = df.query('a in b and c < d', parser=parser, engine=engine)
-            expec = df[df.b.isin(df.a) & (df.c < df.d)]
+            expec = df[df.a.isin(df.b) & (df.c < df.d)]
             assert_frame_equal(res, expec)
         else:
             with assertRaises(NotImplementedError):
@@ -11806,11 +11806,11 @@ class TestDataFrameQueryStrings(object):
                         'c': np.random.randint(5, size=12),
                         'd': np.random.randint(9, size=12)})
         res = df['a in b']
-        expec = df[df.b.isin(df.a)]
+        expec = df[df.a.isin(df.b)]
         assert_frame_equal(res, expec)
 
         res = df['a in b and c < d']
-        expec = df[df.b.isin(df.a) & (df.c < df.d)]
+        expec = df[df.a.isin(df.b) & (df.c < df.d)]
         assert_frame_equal(res, expec)
 
     def check_object_array_eq_ne(self, parser, engine):

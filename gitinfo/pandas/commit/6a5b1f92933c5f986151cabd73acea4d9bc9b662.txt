commit 6a5b1f92933c5f986151cabd73acea4d9bc9b662
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Dec 9 14:42:11 2012 -0500

    ENH: add tokenizer that can handle custom length-1 line terminators. close #2457

diff --git a/RELEASE.rst b/RELEASE.rst
index a98b455ab..d02cae9df 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -52,6 +52,7 @@ pandas 0.10.0
     - Substantially improved performance in the parsing of integers with
       thousands markers and lines with comments
     - Easy of European (and other) decimal formats (`decimal` option)
+    - Custom line terminators (e.g. lineterminator='~') (#2457)
 
   - Add error handling to Series.str.encode/decode (#2276)
   - Add ``where`` and ``mask`` to Series (#2337)
@@ -93,6 +94,11 @@ pandas 0.10.0
     `header` argument will be respected. If there is an existing header column,
     this can rename the columns. To fix legacy code, put ``header=None`` when
     passing ``names``
+  - Default column names for header-less parsed files (yielded by read_csv,
+    etc.) are now the integers 0, 1, .... A new argument `prefix` has been
+    added; to get the v0.9.x behavior specify ``prefix='X'`` (#2034). This API
+    change was made to make the default column names more consistent with the
+    DataFrame constructor's default column names when none are specified.
   - DataFrame selection using a boolean frame now preserves input shape
   - If function passed to Series.apply yields a Series, result will be a
     DataFrame (#2316)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index fb92d3947..8a8df8dc6 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -106,6 +106,16 @@ encoding : string, default None
 squeeze : boolean, default False
     If the parsed data only contains one column then return a Series
 
+**Dialect options**
+
+lineterminator : string (length 1), default None
+    Character to break file into lines. Only valid with C parser
+quotechar : string
+quoting : string
+skipinitialspace : boolean, default False
+    Skip spaces after delimiter
+escapechar : string
+
 Returns
 -------
 result : DataFrame or TextParser
@@ -205,6 +215,7 @@ _parser_defaults = {
     'quotechar': '"',
     'quoting': csv.QUOTE_MINIMAL,
     'skipinitialspace': False,
+    'lineterminator': None,
 
     'header': 0,
     'index_col': None,
@@ -275,6 +286,7 @@ def _make_parser_function(name, sep=','):
                  quotechar='"',
                  quoting=csv.QUOTE_MINIMAL,
                  skipinitialspace=False,
+                 lineterminator=None,
 
                  header=0,
                  index_col=None,
@@ -335,6 +347,7 @@ def _make_parser_function(name, sep=','):
                     quotechar=quotechar,
                     quoting=quoting,
                     skipinitialspace=skipinitialspace,
+                    lineterminator=lineterminator,
 
                     header=header,
                     index_col=index_col,
@@ -1090,7 +1103,9 @@ class PythonParser(ParserBase):
         self.escapechar = kwds['escapechar']
         self.doublequote = kwds['doublequote']
         self.skipinitialspace = kwds['skipinitialspace']
+        self.lineterminator = kwds['lineterminator']
         self.quoting = kwds['quoting']
+
         self.has_index_names = False
         if 'has_index_names' in kwds:
             self.has_index_names = kwds['has_index_names']
@@ -1134,6 +1149,10 @@ class PythonParser(ParserBase):
         sep = self.delimiter
 
         if sep is None or len(sep) == 1:
+            if self.lineterminator:
+                raise ValueError('Custom line terminators not supported in '
+                                 'python parser (yet)')
+
             class MyDialect(csv.Dialect):
                 delimiter = self.delimiter
                 quotechar = self.quotechar
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index b0e0a5ab6..29fbabf82 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -1875,6 +1875,18 @@ No,No,No"""
         self.assert_(df2['Number2'].dtype == float)
         self.assert_(df2['Number3'].dtype == float)
 
+    def test_custom_lineterminator(self):
+        data = 'a,b,c~1,2,3~4,5,6'
+
+        result = self.read_csv(StringIO(data), lineterminator='~')
+        expected = self.read_csv(StringIO(data.replace('~', '\n')))
+
+        tm.assert_frame_equal(result, expected)
+
+        data2 = data.replace('~', '~~')
+        result = self.assertRaises(ValueError, read_csv, StringIO(data2),
+                                   lineterminator='~~')
+
 
 class TestParseSQL(unittest.TestCase):
 
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index 3051b2e9e..7f822081f 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -120,6 +120,7 @@ cdef extern from "parser/tokenizer.h":
         int delim_whitespace       # consume tabs / spaces instead
         char quotechar             # quote character */
         char escapechar            # escape character */
+        char lineterminator
         int skipinitialspace       # ignore spaces following delimiter? */
         int quoting                # style of quoting to write */
 
@@ -270,6 +271,8 @@ cdef class TextReader:
                   doublequote=True,
                   quotechar=b'"',
                   quoting=0,
+                  lineterminator=None,
+
                   encoding=None,
 
                   comment=None,
@@ -323,6 +326,11 @@ cdef class TextReader:
         self.parser.doublequote = doublequote
         self.parser.skipinitialspace = skipinitialspace
 
+        if lineterminator is not None:
+            if len(lineterminator) != 1:
+                raise ValueError('Only length-1 line terminators supported')
+            self.parser.lineterminator = ord(lineterminator)
+
         if len(decimal) != 1:
             raise ValueError('Only length-1 decimal markers supported')
         self.parser.decimal = ord(decimal)
diff --git a/pandas/src/parser/tokenizer.c b/pandas/src/parser/tokenizer.c
index 65fdf68f5..97b107ca4 100644
--- a/pandas/src/parser/tokenizer.c
+++ b/pandas/src/parser/tokenizer.c
@@ -140,6 +140,9 @@ void parser_set_default_options(parser_t *self) {
     self->doublequote = 0;
     self->quotechar = '"';
     self->escapechar = 0;
+
+    self->lineterminator = '\0'; /* NUL->standard logic */
+
     self->skipinitialspace = 0;
     self->quoting = QUOTE_MINIMAL;
     self->allow_embedded_newline = 1;
@@ -866,6 +869,210 @@ linelimit:
     return 0;
 }
 
+/* custom line terminator */
+int tokenize_delim_customterm(parser_t *self, size_t line_limit)
+{
+
+    int i, slen, start_lines;
+    char c;
+    char *stream;
+    char *buf = self->data + self->datapos;
+
+
+    start_lines = self->lines;
+
+    if (make_stream_space(self, self->datalen - self->datapos) < 0) {
+        self->error_msg = "out of memory";
+        return -1;
+    }
+
+    stream = self->stream + self->stream_len;
+    slen = self->stream_len;
+
+    TRACE(("%s\n", buf));
+
+    for (i = self->datapos; i < self->datalen; ++i)
+    {
+        // Next character in file
+        c = *buf++;
+
+        TRACE(("Iter: %d Char: %c Line %d field_count %d, state %d\n",
+               i, c, self->file_lines + 1, self->line_fields[self->lines],
+               self->state));
+
+        switch(self->state) {
+        case START_RECORD:
+            // start of record
+            if (c == self->lineterminator) {
+                // \n\r possible?
+                END_LINE();
+                break;
+            }
+            /* normal character - handle as START_FIELD */
+            self->state = START_FIELD;
+            /* fallthru */
+        case START_FIELD:
+            /* expecting field */
+            if (c == self->lineterminator) {
+                END_FIELD();
+                END_LINE();
+                /* self->state = START_RECORD; */
+            }
+            else if (c == self->quotechar &&
+                     self->quoting != QUOTE_NONE) {
+                /* start quoted field */
+                self->state = IN_QUOTED_FIELD;
+            }
+            else if (c == self->escapechar) {
+                /* possible escaped character */
+                self->state = ESCAPED_CHAR;
+            }
+            else if (c == ' ' && self->skipinitialspace)
+                /* ignore space at start of field */
+                ;
+            else if (c == self->delimiter) {
+                /* save empty field */
+                END_FIELD();
+            }
+            else if (c == self->commentchar) {
+                END_FIELD();
+                self->state = EAT_COMMENT;
+            }
+            else {
+                /* begin new unquoted field */
+                if (self->quoting == QUOTE_NONNUMERIC)
+                    self->numeric_field = 1;
+
+                // TRACE(("pushing %c", c));
+                PUSH_CHAR(c);
+                self->state = IN_FIELD;
+            }
+            break;
+
+        case ESCAPED_CHAR:
+            /* if (c == '\0') */
+            /*  c = '\n'; */
+
+            PUSH_CHAR(c);
+            self->state = IN_FIELD;
+            break;
+
+        case IN_FIELD:
+            /* in unquoted field */
+            if (c == self->lineterminator) {
+                END_FIELD();
+                END_LINE();
+                /* self->state = START_RECORD; */
+            }
+            else if (c == self->escapechar) {
+                /* possible escaped character */
+                self->state = ESCAPED_CHAR;
+            }
+            else if (c == self->delimiter) {
+                // End of field. End of line not reached yet
+                END_FIELD();
+                self->state = START_FIELD;
+            }
+            else if (c == self->commentchar) {
+                END_FIELD();
+                self->state = EAT_COMMENT;
+            }
+            else {
+                /* normal character - save in field */
+                PUSH_CHAR(c);
+            }
+            break;
+
+        case IN_QUOTED_FIELD:
+            /* in quoted field */
+            if (c == self->escapechar) {
+                /* Possible escape character */
+                self->state = ESCAPE_IN_QUOTED_FIELD;
+            }
+            else if (c == self->quotechar &&
+                     self->quoting != QUOTE_NONE) {
+                if (self->doublequote) {
+                    /* doublequote; " represented by "" */
+                    self->state = QUOTE_IN_QUOTED_FIELD;
+                }
+                else {
+                    /* end of quote part of field */
+                    self->state = IN_FIELD;
+                }
+            }
+            else {
+                /* normal character - save in field */
+                PUSH_CHAR(c);
+            }
+            break;
+
+        case ESCAPE_IN_QUOTED_FIELD:
+            PUSH_CHAR(c);
+            self->state = IN_QUOTED_FIELD;
+            break;
+
+        case QUOTE_IN_QUOTED_FIELD:
+            /* doublequote - seen a quote in an quoted field */
+            if (self->quoting != QUOTE_NONE && c == self->quotechar) {
+                /* save "" as " */
+
+                PUSH_CHAR(c);
+                self->state = IN_QUOTED_FIELD;
+            }
+            else if (c == self->delimiter) {
+                // End of field. End of line not reached yet
+
+                END_FIELD();
+                self->state = START_FIELD;
+            }
+            else if (c == self->lineterminator) {
+                END_FIELD();
+                END_LINE();
+                /* self->state = START_RECORD; */
+            }
+            else if (!self->strict) {
+                PUSH_CHAR(c);
+                self->state = IN_FIELD;
+            }
+            else {
+                self->error_msg = (char*) malloc(50);
+                sprintf(self->error_msg, "'%c' expected after '%c'",
+                        self->delimiter, self->quotechar);
+                goto parsingerror;
+            }
+            break;
+
+        case EAT_COMMENT:
+            if (c == self->lineterminator) {
+                END_LINE();
+            }
+            break;
+
+        default:
+            break;
+
+        }
+    }
+
+    _TOKEN_CLEANUP();
+
+    TRACE(("Finished tokenizing input\n"))
+
+    return 0;
+
+parsingerror:
+    i++;
+    _TOKEN_CLEANUP();
+
+    return -1;
+
+linelimit:
+    i++;
+    _TOKEN_CLEANUP();
+
+    return 0;
+}
+
 int tokenize_whitespace(parser_t *self, size_t line_limit)
 {
     int i, slen, start_lines;
@@ -1289,8 +1496,10 @@ int _tokenize_helper(parser_t *self, size_t nrows, int all) {
 
     if (self->delim_whitespace) {
         tokenize_bytes = tokenize_whitespace;
-    } else {
+    } else if (self->lineterminator == '\0') {
         tokenize_bytes = tokenize_delimited;
+    } else {
+        tokenize_bytes = tokenize_delim_customterm;
     }
 
     if (self->state == FINISHED) {
diff --git a/pandas/src/parser/tokenizer.h b/pandas/src/parser/tokenizer.h
index 8ec261382..6f8d539f9 100644
--- a/pandas/src/parser/tokenizer.h
+++ b/pandas/src/parser/tokenizer.h
@@ -172,6 +172,7 @@ typedef struct parser_t {
     int delim_whitespace;       /* delimit by consuming space/tabs instead */
     char quotechar;             /* quote character */
     char escapechar;            /* escape character */
+    char lineterminator;
     int skipinitialspace;       /* ignore spaces following delimiter? */
     int quoting;                /* style of quoting to write */
 

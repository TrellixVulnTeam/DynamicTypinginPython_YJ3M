commit f38020f33052ea9029b410d7fae79bc8f249c0ac
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Jul 9 14:54:25 2019 -0700

    TST: parametrize sparse array arithmetic tests (#27271)

diff --git a/pandas/conftest.py b/pandas/conftest.py
index 29833ab2f..ef2758d26 100644
--- a/pandas/conftest.py
+++ b/pandas/conftest.py
@@ -1,5 +1,6 @@
 from datetime import date, time, timedelta, timezone
 from decimal import Decimal
+import operator
 import os
 
 from dateutil.tz import tzlocal, tzutc
@@ -13,6 +14,7 @@ import pandas.util._test_decorators as td
 
 import pandas as pd
 from pandas import DataFrame
+from pandas.core import ops
 import pandas.util.testing as tm
 
 hypothesis.settings.register_profile(
@@ -163,6 +165,34 @@ def all_arithmetic_operators(request):
     return request.param
 
 
+@pytest.fixture(
+    params=[
+        operator.add,
+        ops.radd,
+        operator.sub,
+        ops.rsub,
+        operator.mul,
+        ops.rmul,
+        operator.truediv,
+        ops.rtruediv,
+        operator.floordiv,
+        ops.rfloordiv,
+        operator.mod,
+        ops.rmod,
+        operator.pow,
+        ops.rpow,
+    ]
+)
+def all_arithmetic_functions(request):
+    """
+    Fixture for operator and roperator arithmetic functions.
+
+    Note: This includes divmod and rdivmod, whereas all_arithmetic_operators
+    does not.
+    """
+    return request.param
+
+
 _all_numeric_reductions = [
     "sum",
     "max",
diff --git a/pandas/tests/arrays/sparse/test_arithmetics.py b/pandas/tests/arrays/sparse/test_arithmetics.py
index 7bfedff21..0f8f3d261 100644
--- a/pandas/tests/arrays/sparse/test_arithmetics.py
+++ b/pandas/tests/arrays/sparse/test_arithmetics.py
@@ -4,10 +4,23 @@ import numpy as np
 import pytest
 
 import pandas as pd
+from pandas.core import ops
 from pandas.core.sparse.api import SparseDtype
 import pandas.util.testing as tm
 
 
+@pytest.fixture(params=["integer", "block"])
+def kind(request):
+    """kind kwarg to pass to SparseArray/SparseSeries"""
+    return request.param
+
+
+@pytest.fixture(params=[True, False])
+def mix(request):
+    # whether to operate op(sparse, dense) instead of op(sparse, sparse)
+    return request.param
+
+
 @pytest.mark.filterwarnings("ignore:Sparse:FutureWarning")
 @pytest.mark.filterwarnings("ignore:Series.to_sparse:FutureWarning")
 class TestSparseArrayArithmetics:
@@ -18,60 +31,25 @@ class TestSparseArrayArithmetics:
     def _assert(self, a, b):
         tm.assert_numpy_array_equal(a, b)
 
-    def _check_numeric_ops(self, a, b, a_dense, b_dense):
+    def _check_numeric_ops(self, a, b, a_dense, b_dense, mix, op):
         with np.errstate(invalid="ignore", divide="ignore"):
-            # Unfortunately, trying to wrap the computation of each expected
-            # value is with np.errstate() is too tedious.
-
-            # sparse & sparse
-            self._assert((a + b).to_dense(), a_dense + b_dense)
-            self._assert((b + a).to_dense(), b_dense + a_dense)
-
-            self._assert((a - b).to_dense(), a_dense - b_dense)
-            self._assert((b - a).to_dense(), b_dense - a_dense)
-
-            self._assert((a * b).to_dense(), a_dense * b_dense)
-            self._assert((b * a).to_dense(), b_dense * a_dense)
-
-            # pandas uses future division
-            self._assert((a / b).to_dense(), a_dense * 1.0 / b_dense)
-            self._assert((b / a).to_dense(), b_dense * 1.0 / a_dense)
-
-            # ToDo: FIXME in GH 13843
-            if not (self._base == pd.Series and a.dtype.subtype == np.dtype("int64")):
-                self._assert((a // b).to_dense(), a_dense // b_dense)
-                self._assert((b // a).to_dense(), b_dense // a_dense)
-
-            self._assert((a % b).to_dense(), a_dense % b_dense)
-            self._assert((b % a).to_dense(), b_dense % a_dense)
-
-            self._assert((a ** b).to_dense(), a_dense ** b_dense)
-            self._assert((b ** a).to_dense(), b_dense ** a_dense)
-
-            # sparse & dense
-            self._assert((a + b_dense).to_dense(), a_dense + b_dense)
-            self._assert((b_dense + a).to_dense(), b_dense + a_dense)
-
-            self._assert((a - b_dense).to_dense(), a_dense - b_dense)
-            self._assert((b_dense - a).to_dense(), b_dense - a_dense)
-
-            self._assert((a * b_dense).to_dense(), a_dense * b_dense)
-            self._assert((b_dense * a).to_dense(), b_dense * a_dense)
+            if op in [operator.floordiv, ops.rfloordiv]:
+                # FIXME: GH#13843
+                if self._base == pd.Series and a.dtype.subtype == np.dtype("int64"):
+                    pytest.xfail("Not defined/working.  See GH#13843")
 
-            # pandas uses future division
-            self._assert((a / b_dense).to_dense(), a_dense * 1.0 / b_dense)
-            self._assert((b_dense / a).to_dense(), b_dense * 1.0 / a_dense)
+            if mix:
+                result = op(a, b_dense).to_dense()
+            else:
+                result = op(a, b).to_dense()
 
-            # ToDo: FIXME in GH 13843
-            if not (self._base == pd.Series and a.dtype.subtype == np.dtype("int64")):
-                self._assert((a // b_dense).to_dense(), a_dense // b_dense)
-                self._assert((b_dense // a).to_dense(), b_dense // a_dense)
+            if op in [operator.truediv, ops.rtruediv]:
+                # pandas uses future division
+                expected = op(a_dense * 1.0, b_dense)
+            else:
+                expected = op(a_dense, b_dense)
 
-            self._assert((a % b_dense).to_dense(), a_dense % b_dense)
-            self._assert((b_dense % a).to_dense(), b_dense % a_dense)
-
-            self._assert((a ** b_dense).to_dense(), a_dense ** b_dense)
-            self._assert((b_dense ** a).to_dense(), b_dense ** a_dense)
+            self._assert(result, expected)
 
     def _check_bool_result(self, res):
         assert isinstance(res, self._klass)
@@ -136,289 +114,275 @@ class TestSparseArrayArithmetics:
         self._check_bool_result(a | b_dense)
         self._assert((a | b_dense).to_dense(), a_dense | b_dense)
 
-    def test_float_scalar(self):
+    @pytest.mark.parametrize("scalar", [0, 1, 3])
+    @pytest.mark.parametrize("fill_value", [None, 0, 2])
+    def test_float_scalar(
+        self, kind, mix, all_arithmetic_functions, fill_value, scalar
+    ):
+        op = all_arithmetic_functions
         values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
 
-        for kind in ["integer", "block"]:
-            a = self._klass(values, kind=kind)
-            self._check_numeric_ops(a, 1, values, 1)
-            self._check_numeric_ops(a, 0, values, 0)
-            self._check_numeric_ops(a, 3, values, 3)
-
-            a = self._klass(values, kind=kind, fill_value=0)
-            self._check_numeric_ops(a, 1, values, 1)
-            self._check_numeric_ops(a, 0, values, 0)
-            self._check_numeric_ops(a, 3, values, 3)
-
-            a = self._klass(values, kind=kind, fill_value=2)
-            self._check_numeric_ops(a, 1, values, 1)
-            self._check_numeric_ops(a, 0, values, 0)
-            self._check_numeric_ops(a, 3, values, 3)
+        a = self._klass(values, kind=kind, fill_value=fill_value)
+        self._check_numeric_ops(a, scalar, values, scalar, mix, op)
 
-    def test_float_scalar_comparison(self):
+    def test_float_scalar_comparison(self, kind):
         values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
 
-        for kind in ["integer", "block"]:
-            a = self._klass(values, kind=kind)
-            self._check_comparison_ops(a, 1, values, 1)
-            self._check_comparison_ops(a, 0, values, 0)
-            self._check_comparison_ops(a, 3, values, 3)
+        a = self._klass(values, kind=kind)
+        self._check_comparison_ops(a, 1, values, 1)
+        self._check_comparison_ops(a, 0, values, 0)
+        self._check_comparison_ops(a, 3, values, 3)
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            self._check_comparison_ops(a, 1, values, 1)
-            self._check_comparison_ops(a, 0, values, 0)
-            self._check_comparison_ops(a, 3, values, 3)
+        a = self._klass(values, kind=kind, fill_value=0)
+        self._check_comparison_ops(a, 1, values, 1)
+        self._check_comparison_ops(a, 0, values, 0)
+        self._check_comparison_ops(a, 3, values, 3)
 
-            a = self._klass(values, kind=kind, fill_value=2)
-            self._check_comparison_ops(a, 1, values, 1)
-            self._check_comparison_ops(a, 0, values, 0)
-            self._check_comparison_ops(a, 3, values, 3)
+        a = self._klass(values, kind=kind, fill_value=2)
+        self._check_comparison_ops(a, 1, values, 1)
+        self._check_comparison_ops(a, 0, values, 0)
+        self._check_comparison_ops(a, 3, values, 3)
 
-    def test_float_same_index(self):
+    def test_float_same_index(self, kind, mix, all_arithmetic_functions):
         # when sp_index are the same
-        for kind in ["integer", "block"]:
-            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
-            rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
+        op = all_arithmetic_functions
+        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
+        rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
 
-            a = self._klass(values, kind=kind)
-            b = self._klass(rvalues, kind=kind)
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-            values = self._base([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
-            rvalues = self._base([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
+        values = self._base([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
+        rvalues = self._base([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind, fill_value=0)
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-    def test_float_same_index_comparison(self):
+    def test_float_same_index_comparison(self, kind):
         # when sp_index are the same
-        for kind in ["integer", "block"]:
-            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
-            rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
+        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
+        rvalues = self._base([np.nan, 2, 3, 4, np.nan, 0, 1, 3, 2, np.nan])
 
-            a = self._klass(values, kind=kind)
-            b = self._klass(rvalues, kind=kind)
-            self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-            values = self._base([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
-            rvalues = self._base([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
+        values = self._base([0.0, 1.0, 2.0, 6.0, 0.0, 0.0, 1.0, 2.0, 1.0, 0.0])
+        rvalues = self._base([0.0, 2.0, 3.0, 4.0, 0.0, 0.0, 1.0, 3.0, 2.0, 0.0])
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind, fill_value=0)
-            self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        self._check_comparison_ops(a, b, values, rvalues)
+
+    def test_float_array(self, kind, mix, all_arithmetic_functions):
+        op = all_arithmetic_functions
 
-    def test_float_array(self):
         values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
         rvalues = self._base([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
 
-        for kind in ["integer", "block"]:
-            a = self._klass(values, kind=kind)
-            b = self._klass(rvalues, kind=kind)
-            self._check_numeric_ops(a, b, values, rvalues)
-            self._check_numeric_ops(a, b * 0, values, rvalues * 0)
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
+        self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
+
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind)
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind, fill_value=0)
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=1)
+        b = self._klass(rvalues, kind=kind, fill_value=2)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-            a = self._klass(values, kind=kind, fill_value=1)
-            b = self._klass(rvalues, kind=kind, fill_value=2)
-            self._check_numeric_ops(a, b, values, rvalues)
+    def test_float_array_different_kind(self, mix, all_arithmetic_functions):
+        op = all_arithmetic_functions
 
-    def test_float_array_different_kind(self):
         values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
         rvalues = self._base([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
 
         a = self._klass(values, kind="integer")
         b = self._klass(rvalues, kind="block")
-        self._check_numeric_ops(a, b, values, rvalues)
-        self._check_numeric_ops(a, b * 0, values, rvalues * 0)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
+        self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
 
         a = self._klass(values, kind="integer", fill_value=0)
         b = self._klass(rvalues, kind="block")
-        self._check_numeric_ops(a, b, values, rvalues)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
         a = self._klass(values, kind="integer", fill_value=0)
         b = self._klass(rvalues, kind="block", fill_value=0)
-        self._check_numeric_ops(a, b, values, rvalues)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
         a = self._klass(values, kind="integer", fill_value=1)
         b = self._klass(rvalues, kind="block", fill_value=2)
-        self._check_numeric_ops(a, b, values, rvalues)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-    def test_float_array_comparison(self):
+    def test_float_array_comparison(self, kind):
         values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
         rvalues = self._base([2, np.nan, 2, 3, np.nan, 0, 1, 5, 2, np.nan])
 
-        for kind in ["integer", "block"]:
-            a = self._klass(values, kind=kind)
-            b = self._klass(rvalues, kind=kind)
-            self._check_comparison_ops(a, b, values, rvalues)
-            self._check_comparison_ops(a, b * 0, values, rvalues * 0)
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        self._check_comparison_ops(a, b, values, rvalues)
+        self._check_comparison_ops(a, b * 0, values, rvalues * 0)
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind)
-            self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-            a = self._klass(values, kind=kind, fill_value=0)
-            b = self._klass(rvalues, kind=kind, fill_value=0)
-            self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-            a = self._klass(values, kind=kind, fill_value=1)
-            b = self._klass(rvalues, kind=kind, fill_value=2)
-            self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=1)
+        b = self._klass(rvalues, kind=kind, fill_value=2)
+        self._check_comparison_ops(a, b, values, rvalues)
+
+    def test_int_array(self, kind, mix, all_arithmetic_functions):
+        op = all_arithmetic_functions
 
-    def test_int_array(self):
         # have to specify dtype explicitly until fixing GH 667
         dtype = np.int64
 
         values = self._base([0, 1, 2, 0, 0, 0, 1, 2, 1, 0], dtype=dtype)
         rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=dtype)
 
-        for kind in ["integer", "block"]:
-            a = self._klass(values, dtype=dtype, kind=kind)
-            assert a.dtype == SparseDtype(dtype)
-            b = self._klass(rvalues, dtype=dtype, kind=kind)
-            assert b.dtype == SparseDtype(dtype)
-
-            self._check_numeric_ops(a, b, values, rvalues)
-            self._check_numeric_ops(a, b * 0, values, rvalues * 0)
+        a = self._klass(values, dtype=dtype, kind=kind)
+        assert a.dtype == SparseDtype(dtype)
+        b = self._klass(rvalues, dtype=dtype, kind=kind)
+        assert b.dtype == SparseDtype(dtype)
 
-            a = self._klass(values, fill_value=0, dtype=dtype, kind=kind)
-            assert a.dtype == SparseDtype(dtype)
-            b = self._klass(rvalues, dtype=dtype, kind=kind)
-            assert b.dtype == SparseDtype(dtype)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
+        self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
 
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, fill_value=0, dtype=dtype, kind=kind)
+        assert a.dtype == SparseDtype(dtype)
+        b = self._klass(rvalues, dtype=dtype, kind=kind)
+        assert b.dtype == SparseDtype(dtype)
 
-            a = self._klass(values, fill_value=0, dtype=dtype, kind=kind)
-            assert a.dtype == SparseDtype(dtype)
-            b = self._klass(rvalues, fill_value=0, dtype=dtype, kind=kind)
-            assert b.dtype == SparseDtype(dtype)
-            self._check_numeric_ops(a, b, values, rvalues)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-            a = self._klass(values, fill_value=1, dtype=dtype, kind=kind)
-            assert a.dtype == SparseDtype(dtype, fill_value=1)
-            b = self._klass(rvalues, fill_value=2, dtype=dtype, kind=kind)
-            assert b.dtype == SparseDtype(dtype, fill_value=2)
-            self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, fill_value=0, dtype=dtype, kind=kind)
+        assert a.dtype == SparseDtype(dtype)
+        b = self._klass(rvalues, fill_value=0, dtype=dtype, kind=kind)
+        assert b.dtype == SparseDtype(dtype)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-    def test_int_array_comparison(self):
+        a = self._klass(values, fill_value=1, dtype=dtype, kind=kind)
+        assert a.dtype == SparseDtype(dtype, fill_value=1)
+        b = self._klass(rvalues, fill_value=2, dtype=dtype, kind=kind)
+        assert b.dtype == SparseDtype(dtype, fill_value=2)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
+    def test_int_array_comparison(self, kind):
+        dtype = "int64"
         # int32 NI ATM
-        for dtype in ["int64"]:
-            values = self._base([0, 1, 2, 0, 0, 0, 1, 2, 1, 0], dtype=dtype)
-            rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=dtype)
 
-            for kind in ["integer", "block"]:
-                a = self._klass(values, dtype=dtype, kind=kind)
-                b = self._klass(rvalues, dtype=dtype, kind=kind)
-                self._check_comparison_ops(a, b, values, rvalues)
-                self._check_comparison_ops(a, b * 0, values, rvalues * 0)
+        values = self._base([0, 1, 2, 0, 0, 0, 1, 2, 1, 0], dtype=dtype)
+        rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=dtype)
+
+        a = self._klass(values, dtype=dtype, kind=kind)
+        b = self._klass(rvalues, dtype=dtype, kind=kind)
+        self._check_comparison_ops(a, b, values, rvalues)
+        self._check_comparison_ops(a, b * 0, values, rvalues * 0)
 
-                a = self._klass(values, dtype=dtype, kind=kind, fill_value=0)
-                b = self._klass(rvalues, dtype=dtype, kind=kind)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, dtype=dtype, kind=kind, fill_value=0)
+        b = self._klass(rvalues, dtype=dtype, kind=kind)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-                a = self._klass(values, dtype=dtype, kind=kind, fill_value=0)
-                b = self._klass(rvalues, dtype=dtype, kind=kind, fill_value=0)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, dtype=dtype, kind=kind, fill_value=0)
+        b = self._klass(rvalues, dtype=dtype, kind=kind, fill_value=0)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-                a = self._klass(values, dtype=dtype, kind=kind, fill_value=1)
-                b = self._klass(rvalues, dtype=dtype, kind=kind, fill_value=2)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, dtype=dtype, kind=kind, fill_value=1)
+        b = self._klass(rvalues, dtype=dtype, kind=kind, fill_value=2)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-    def test_bool_same_index(self):
+    @pytest.mark.parametrize("fill_value", [True, False, np.nan])
+    def test_bool_same_index(self, kind, fill_value):
         # GH 14000
         # when sp_index are the same
-        for kind in ["integer", "block"]:
-            values = self._base([True, False, True, True], dtype=np.bool)
-            rvalues = self._base([True, False, True, True], dtype=np.bool)
-
-            for fill_value in [True, False, np.nan]:
-                a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
-                b = self._klass(
-                    rvalues, kind=kind, dtype=np.bool, fill_value=fill_value
-                )
-                self._check_logical_ops(a, b, values, rvalues)
-
-    def test_bool_array_logical(self):
+        values = self._base([True, False, True, True], dtype=np.bool)
+        rvalues = self._base([True, False, True, True], dtype=np.bool)
+
+        a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
+        b = self._klass(rvalues, kind=kind, dtype=np.bool, fill_value=fill_value)
+        self._check_logical_ops(a, b, values, rvalues)
+
+    @pytest.mark.parametrize("fill_value", [True, False, np.nan])
+    def test_bool_array_logical(self, kind, fill_value):
         # GH 14000
         # when sp_index are the same
-        for kind in ["integer", "block"]:
-            values = self._base([True, False, True, False, True, True], dtype=np.bool)
-            rvalues = self._base([True, False, False, True, False, True], dtype=np.bool)
+        values = self._base([True, False, True, False, True, True], dtype=np.bool)
+        rvalues = self._base([True, False, False, True, False, True], dtype=np.bool)
 
-            for fill_value in [True, False, np.nan]:
-                a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
-                b = self._klass(
-                    rvalues, kind=kind, dtype=np.bool, fill_value=fill_value
-                )
-                self._check_logical_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
+        b = self._klass(rvalues, kind=kind, dtype=np.bool, fill_value=fill_value)
+        self._check_logical_ops(a, b, values, rvalues)
 
-    def test_mixed_array_float_int(self):
+    def test_mixed_array_float_int(self, kind, mix, all_arithmetic_functions):
+        op = all_arithmetic_functions
 
-        for rdtype in ["int64"]:
-            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
-            rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
+        rdtype = "int64"
 
-            for kind in ["integer", "block"]:
-                a = self._klass(values, kind=kind)
-                b = self._klass(rvalues, kind=kind)
-                assert b.dtype == SparseDtype(rdtype)
+        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
+        rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
 
-                self._check_numeric_ops(a, b, values, rvalues)
-                self._check_numeric_ops(a, b * 0, values, rvalues * 0)
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        assert b.dtype == SparseDtype(rdtype)
 
-                a = self._klass(values, kind=kind, fill_value=0)
-                b = self._klass(rvalues, kind=kind)
-                assert b.dtype == SparseDtype(rdtype)
-                self._check_numeric_ops(a, b, values, rvalues)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
+        self._check_numeric_ops(a, b * 0, values, rvalues * 0, mix, op)
 
-                a = self._klass(values, kind=kind, fill_value=0)
-                b = self._klass(rvalues, kind=kind, fill_value=0)
-                assert b.dtype == SparseDtype(rdtype)
-                self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind)
+        assert b.dtype == SparseDtype(rdtype)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-                a = self._klass(values, kind=kind, fill_value=1)
-                b = self._klass(rvalues, kind=kind, fill_value=2)
-                assert b.dtype == SparseDtype(rdtype, fill_value=2)
-                self._check_numeric_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        assert b.dtype == SparseDtype(rdtype)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
-    def test_mixed_array_comparison(self):
+        a = self._klass(values, kind=kind, fill_value=1)
+        b = self._klass(rvalues, kind=kind, fill_value=2)
+        assert b.dtype == SparseDtype(rdtype, fill_value=2)
+        self._check_numeric_ops(a, b, values, rvalues, mix, op)
 
+    def test_mixed_array_comparison(self, kind):
+        rdtype = "int64"
         # int32 NI ATM
-        for rdtype in ["int64"]:
-            values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
-            rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
 
-            for kind in ["integer", "block"]:
-                a = self._klass(values, kind=kind)
-                b = self._klass(rvalues, kind=kind)
-                assert b.dtype == SparseDtype(rdtype)
+        values = self._base([np.nan, 1, 2, 0, np.nan, 0, 1, 2, 1, np.nan])
+        rvalues = self._base([2, 0, 2, 3, 0, 0, 1, 5, 2, 0], dtype=rdtype)
+
+        a = self._klass(values, kind=kind)
+        b = self._klass(rvalues, kind=kind)
+        assert b.dtype == SparseDtype(rdtype)
 
-                self._check_comparison_ops(a, b, values, rvalues)
-                self._check_comparison_ops(a, b * 0, values, rvalues * 0)
+        self._check_comparison_ops(a, b, values, rvalues)
+        self._check_comparison_ops(a, b * 0, values, rvalues * 0)
 
-                a = self._klass(values, kind=kind, fill_value=0)
-                b = self._klass(rvalues, kind=kind)
-                assert b.dtype == SparseDtype(rdtype)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind)
+        assert b.dtype == SparseDtype(rdtype)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-                a = self._klass(values, kind=kind, fill_value=0)
-                b = self._klass(rvalues, kind=kind, fill_value=0)
-                assert b.dtype == SparseDtype(rdtype)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=0)
+        b = self._klass(rvalues, kind=kind, fill_value=0)
+        assert b.dtype == SparseDtype(rdtype)
+        self._check_comparison_ops(a, b, values, rvalues)
 
-                a = self._klass(values, kind=kind, fill_value=1)
-                b = self._klass(rvalues, kind=kind, fill_value=2)
-                assert b.dtype == SparseDtype(rdtype, fill_value=2)
-                self._check_comparison_ops(a, b, values, rvalues)
+        a = self._klass(values, kind=kind, fill_value=1)
+        b = self._klass(rvalues, kind=kind, fill_value=2)
+        assert b.dtype == SparseDtype(rdtype, fill_value=2)
+        self._check_comparison_ops(a, b, values, rvalues)
 
 
 class TestSparseSeriesArithmetic(TestSparseArrayArithmetics):
@@ -429,7 +393,9 @@ class TestSparseSeriesArithmetic(TestSparseArrayArithmetics):
     def _assert(self, a, b):
         tm.assert_series_equal(a, b)
 
-    def test_alignment(self):
+    def test_alignment(self, mix, all_arithmetic_functions):
+        op = all_arithmetic_functions
+
         da = pd.Series(np.arange(4))
         db = pd.Series(np.arange(4), index=[1, 2, 3, 4])
 
@@ -437,13 +403,13 @@ class TestSparseSeriesArithmetic(TestSparseArrayArithmetics):
         sb = pd.SparseSeries(
             np.arange(4), index=[1, 2, 3, 4], dtype=np.int64, fill_value=0
         )
-        self._check_numeric_ops(sa, sb, da, db)
+        self._check_numeric_ops(sa, sb, da, db, mix, op)
 
         sa = pd.SparseSeries(np.arange(4), dtype=np.int64, fill_value=np.nan)
         sb = pd.SparseSeries(
             np.arange(4), index=[1, 2, 3, 4], dtype=np.int64, fill_value=np.nan
         )
-        self._check_numeric_ops(sa, sb, da, db)
+        self._check_numeric_ops(sa, sb, da, db, mix, op)
 
         da = pd.Series(np.arange(4))
         db = pd.Series(np.arange(4), index=[10, 11, 12, 13])
@@ -452,13 +418,13 @@ class TestSparseSeriesArithmetic(TestSparseArrayArithmetics):
         sb = pd.SparseSeries(
             np.arange(4), index=[10, 11, 12, 13], dtype=np.int64, fill_value=0
         )
-        self._check_numeric_ops(sa, sb, da, db)
+        self._check_numeric_ops(sa, sb, da, db, mix, op)
 
         sa = pd.SparseSeries(np.arange(4), dtype=np.int64, fill_value=np.nan)
         sb = pd.SparseSeries(
             np.arange(4), index=[10, 11, 12, 13], dtype=np.int64, fill_value=np.nan
         )
-        self._check_numeric_ops(sa, sb, da, db)
+        self._check_numeric_ops(sa, sb, da, db, mix, op)
 
 
 @pytest.mark.parametrize("op", [operator.eq, operator.add])

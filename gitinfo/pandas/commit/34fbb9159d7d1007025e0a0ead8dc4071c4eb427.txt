commit 34fbb9159d7d1007025e0a0ead8dc4071c4eb427
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Aug 8 19:27:08 2011 -0400

    ENH: partial indexing with multi-level index, and various related tests

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index a1742d010..ea7d6b63d 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -196,7 +196,7 @@ class GroupBy(object):
 
         if len(self.groupings) > 1:
             masked = [raveled[mask] for _, raveled in name_list]
-            index = MultiIndex.from_arrays(*masked)
+            index = MultiIndex.from_arrays(masked)
             return DataFrame(output, index=index)
         else:
             return DataFrame(output, index=name_list[0][1])
@@ -238,7 +238,7 @@ class GroupBy(object):
 
         if len(self.groupings) > 1:
             masked = [raveled[mask] for _, raveled in name_list]
-            index = MultiIndex.from_arrays(*masked)
+            index = MultiIndex.from_arrays(masked)
             return DataFrame(output, index=index)
         else:
             return DataFrame(output, index=name_list[0][1])
@@ -278,13 +278,6 @@ class Grouping(object):
 
         self.indices = _tseries.groupby_indices(self.grouper)
 
-        # # eager beaver
-        # if isinstance(self.grouper, np.ndarray):
-        #     self.indices = _tseries.groupby_indices(self.grouper)
-        # else:
-        #     # some kind of callable
-        #     self.indices = _tseries.func_groupby_indices(index, self.grouper)
-
     def __repr__(self):
         return 'Grouping(%s)' % self.name
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index b501198e9..09aacf0cb 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -370,13 +370,18 @@ class MultiIndex(Index):
 
     """
 
-    def __new__(cls, levels=None, labels=None):
+    def __new__(cls, levels=None, labels=None, sortorder=None):
         return np.arange(len(labels[0]), dtype=object).view(cls)
 
-    def __init__(self, levels, labels):
+    def __init__(self, levels, labels, sortorder=None):
         self.levels = [_ensure_index(lev) for lev in levels]
         self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
 
+        if sortorder is not None:
+            self.sortorder = int(sortorder)
+        else:
+            self.sortorder = sortorder
+
     def __iter__(self):
         values = [np.asarray(lev).take(lab)
                   for lev, lab in zip(self.levels, self.labels)]
@@ -393,10 +398,16 @@ class MultiIndex(Index):
         return False
 
     @classmethod
-    def from_arrays(cls, *arrays):
+    def from_arrays(cls, arrays, sortorder=None):
         """
         Convert arrays to MultiIndex
 
+        Parameters
+        ----------
+        arrays : list / sequence
+        sortorder : int or None
+            Level of sortedness (must be lexicographically sorted by that level)
+
         Returns
         -------
         index : MultiIndex
@@ -408,7 +419,7 @@ class MultiIndex(Index):
             levels.append(factor.levels)
             labels.append(factor.labels)
 
-        return MultiIndex(levels=levels, labels=labels)
+        return MultiIndex(levels=levels, labels=labels, sortorder=sortorder)
 
     @property
     def indexMap(self):
@@ -467,23 +478,18 @@ class MultiIndex(Index):
     def format(self, space=2):
         stringified_levels = [lev.format().split('\n') for lev in self.levels]
 
-        padded_levels = []
+        result_levels = []
         for lab, lev in zip(self.labels, stringified_levels):
-            # maxlen = max(len(x) for x in lev)
-            # adjoin does this automatically
-            # padded = [x.ljust(maxlen) for x in lev]
-            padded = np.array(lev, dtype=object).take(lab)
-            padded_levels.append(padded)
+            taken = np.array(lev, dtype=object).take(lab)
+            result_levels.append(taken)
 
-        return adjoin(2, *padded_levels)
-
-    def sort(self, level=0):
-        pass
+        return adjoin(space, *result_levels)
 
     def get_loc(self, key):
         if isinstance(key, tuple):
             return self._get_tuple_loc(key)
         else:
+            assert(self.sortorder == 0)
             # slice level 0
             level = self.levels[0]
             labels = self.labels[0]
@@ -554,35 +560,55 @@ class MultiIndex(Index):
         -----
         This function assumes that the data is sorted by the first level
         """
+        assert(self.sortorder == 0)
+
         level0 = self.levels[0]
 
         if start is None:
             start_slice = 0
         elif isinstance(start, tuple):
-            pass
+            start_slice = self._partial_tup_index(start, side='left')
         else:
-            try:
-                start_label = level0.indexMap[start]
-            except KeyError:
-                start_label = level0.searchsorted(start)
-
+            start_label = self._get_label_key_approx(start, side='right')
             start_slice = self.labels[0].searchsorted(start_label)
 
         if end is None:
             end_slice = len(self)
         elif isinstance(end, tuple):
-            pass
+            end_slice = self._partial_tup_index(end, side='right')
         else:
+            end_label = self._get_label_key_approx(end, side='right')
+            end_slice = self.labels[0].searchsorted(end_label, side='right')
+
+        return start_slice, end_slice
+
+    def _partial_tup_index(self, tup, side='left'):
+        assert(self.sortorder == 0)
+        tup_labels = self._get_label_key_approx(tup, side=side)
+
+        n = len(tup_labels)
+        start, end = 0, len(self)
+        for k, (idx, labs) in enumerate(zip(tup_labels, self.labels)):
+            section = labs[start:end]
+            if k < n - 1:
+                start = start + section.searchsorted(idx, side='left')
+                end = start + section.searchsorted(idx, side='right')
+            else:
+                return start + labs.searchsorted(idx, side=side)
+
+    def _get_label_key_approx(self, tup, side='left'):
+        result = []
+        for lev, v in zip(self.levels, tup):
             try:
-                end_label = level0.indexMap[end]
+                label = lev.get_loc(v)
             except KeyError:
-                end_label = level0.searchsorted(end, side='right')
-                if end_label > 0:
-                    end_label -= 1
+                label = lev.searchsorted(v, side=side)
 
-            end_slice = self.labels[0].searchsorted(end_label, side='right')
+                if side == 'right' and label > 0:
+                    label -= 1
 
-        return start_slice, end_slice
+            result.append(label)
+        return tuple(result)
 
     def truncate(self, before=None, after=None):
         """
@@ -778,7 +804,8 @@ class MultiIndex(Index):
             indexer = indexer[::-1]
 
         new_labels = [lab.take(indexer) for lab in self.labels]
-        new_index = MultiIndex(levels=self.levels, labels=new_labels)
+        new_index = MultiIndex(levels=self.levels, labels=new_labels,
+                               sortorder=level)
 
         return new_index, indexer
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 0b666aa3a..f487a7f7d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -261,11 +261,13 @@ class Series(np.ndarray, PandasObject):
               will be returned, otherwise a single value.
         """
         try:
-            if isinstance(self.index, MultiIndex):
+            if isinstance(key, int):
+                return self._regular_index(key)
+            elif isinstance(self.index, MultiIndex):
                 return self._multilevel_index(key)
             else:
                 return self._regular_index(key)
-        except TypeError:
+        except Exception:
             pass
 
         self._check_bool_indexer(key)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 9bb8423b7..3b5d3d649 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -301,7 +301,7 @@ class TestMultiIndex(unittest.TestCase):
         for lev, lab in zip(self.index.levels, self.index.labels):
             arrays.append(np.asarray(lev).take(lab))
 
-        result = MultiIndex.from_arrays(*arrays)
+        result = MultiIndex.from_arrays(arrays)
         self.assertEquals(list(result), list(self.index))
 
     def test_nlevels(self):
@@ -343,6 +343,16 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(result.equals(expected))
         self.assert_(result2.equals(expected))
 
+    def test_getitem_group_select(self):
+        sorted_idx, _ = self.index.sortlevel(0)
+        self.assertEquals(sorted_idx.get_loc('baz'), slice(3, 4))
+        self.assertEquals(sorted_idx.get_loc('foo'), slice(0, 2))
+
+    def test_slice_locs_partial(self):
+        sorted_idx, _ = self.index.sortlevel(0)
+        result = sorted_idx.slice_locs(('foo', 'two'), ('qux', 'one'))
+        self.assertEquals(result, (1, 5))
+
     def test_consistency(self):
         # need to construct an overflow
         major_axis = range(70000)
@@ -384,6 +394,9 @@ class TestMultiIndex(unittest.TestCase):
         result = index.truncate(before=1, after=2)
         self.assertEqual(len(result.levels[0]), 2)
 
+    def test_format(self):
+        self.index.format()
+
     def test_getMajorBounds(self):
         pass
 

commit 1e57f11f0d3821e6308392c9a69dacf061538ebc
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu May 26 23:28:06 2011 +0100

    added fancy indexing 'ix' property to DataFrame, unit tests. TODO: update docs for ix property

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3cd0b6424..4cdcbefe8 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1213,25 +1213,9 @@ class DataFrame(Picklable, Groupable):
         -------
         DataFrame
         """
-        beg_slice, end_slice = self._getIndices(before, after)
-
-        return self[beg_slice:end_slice]
-
-    def _getIndices(self, before, after):
         before = datetools.to_datetime(before)
         after = datetools.to_datetime(after)
-
-        if before is None:
-            beg_slice = 0
-        else:
-            beg_slice = self.index.searchsorted(before, side='left')
-
-        if after is None:
-            end_slice = len(self.index)
-        else:
-            end_slice = self.index.searchsorted(after, side='right')
-
-        return beg_slice, end_slice
+        return self.ix[before:after]
 
     def xs(self, key):
         """
@@ -1325,7 +1309,7 @@ class DataFrame(Picklable, Groupable):
         indexer, mask = self.index.get_indexer(index, method=method)
 
         # Maybe this is a bit much? Wish I had more unit tests...
-        typeHierarchy = [
+        type_hierarchy = [
             (float, float),
             (int, float),
             (bool, float),
@@ -1346,7 +1330,7 @@ class DataFrame(Picklable, Groupable):
         newSeries = {}
         for col, series in self.iteritems():
             series = series.view(np.ndarray)
-            for klass, dest in typeHierarchy:
+            for klass, dest in type_hierarchy:
                 if issubclass(series.dtype.type, klass):
                     new = series.take(indexer)
 
@@ -2388,13 +2372,23 @@ class DataFrame(Picklable, Groupable):
     @property
     def ix(self):
         if self._ix is None:
-            self._ix = DataFrameIndexer(self)
+            self._ix = _DataFrameIndexer(self)
 
         return self._ix
 
-class DataFrameIndexer(object):
+class _DataFrameIndexer(object):
     """
     Class to support fancy indexing, potentially using labels of DataFrame
+
+    Notes
+    -----
+    Indexing based on labels is INCLUSIVE
+    Slicing uses PYTHON SEMANTICS (endpoint is exluded)
+
+    Examples
+    --------
+    >>> frame.ix[5:10, ['A', 'B']]
+    >>> frame.ix[date1:date2, 'A']
     """
 
     def __init__(self, frame):
@@ -2402,15 +2396,75 @@ class DataFrameIndexer(object):
 
     def __getitem__(self, key):
         if isinstance(key, slice):
-            return self._get_index_slice(key)
+            return _index_axis(self.frame, key, axis=0)
         elif isinstance(key, tuple):
-            pass
-
-    def _get_index_slice(self, obj):
-        pass
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            return _index_tuple(self.frame, *key)
 
     def __setitem__(self, key, value):
-        pass
+        raise NotImplementedError
+
+
+def _index_tuple(frame, rowkey, colkey):
+    result = _index_axis(frame, colkey, axis=1)
+
+    if isinstance(result, Series):
+        result = result[rowkey]
+    else:
+        result = _index_axis(result, rowkey, axis=0)
+
+    return result
+
+def _index_axis(frame, key, axis=0):
+    axis_name = DataFrame._get_axis_name(axis)
+    if isinstance(key, slice):
+        return _slice_axis(frame, key, axis=axis)
+    elif _is_list_like(key):
+        return frame.reindex(**{axis_name : key})
+    elif axis == 0:
+        idx = key
+        if isinstance(key, int):
+            idx = frame.index[key]
+
+        return frame.xs(idx)
+    else:
+        col = key
+        if isinstance(key, int):
+            col = frame.columns[key]
+
+        return frame[col]
+
+def _slice_axis(frame, slice_obj, axis=0):
+    _check_step(slice_obj)
+
+    if not _need_slice(slice_obj):
+        return frame
+
+    axis_name = DataFrame._get_axis_name(axis)
+
+    labels = getattr(frame, axis_name)
+    if _is_label_slice(slice_obj):
+        i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
+        new_labels = labels[i:j]
+    else:
+        new_labels = labels[slice_obj]
+
+    return frame.reindex(**{axis_name : new_labels})
+
+def _is_list_like(obj):
+    return isinstance(obj, (list, np.ndarray))
+
+def _is_label_slice(obj):
+    crit = lambda x: isinstance(x, int) or x is None
+    return not crit(obj.start) or not crit(obj.stop)
+
+def _need_slice(obj):
+    return obj.start is not None or obj.stop is not None
+
+def _check_step(obj):
+    if obj.step is not None:
+        raise Exception('steps other than 1 are not supported')
 
 def try_sort(iterable):
     listed = list(iterable)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 05c4eb7fd..8bf4f686a 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -243,9 +243,35 @@ class Index(np.ndarray):
 
         indexer, mask = tseries.getFillVec(self, target, self.indexMap,
                                            target.indexMap, method)
-
         return indexer, mask
 
+    def slice_locs(self, start=None, end=None):
+        """
+
+
+        Returns
+        -------
+
+        Notes
+        -----
+        This function assumes that the data is sorted, so use at your own peril
+        """
+        if start is None:
+            beg_slice = 0
+        elif start in self:
+            beg_slice = self.indexMap[start]
+        else:
+            beg_slice = self.searchsorted(start, side='left')
+
+        if end is None:
+            end_slice = len(self)
+        elif end in self.indexMap:
+            end_slice = self.indexMap[end] + 1
+        else:
+            end_slice = self.searchsorted(end, side='right')
+
+        return beg_slice, end_slice
+
 # For utility purposes
 
 NULL_INDEX = Index([])
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 782d09085..79c5bdf93 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1707,11 +1707,44 @@ class TestDataFrame(unittest.TestCase):
         assert_series_equal(ix[:, 'A'], f['A'])
         assert_frame_equal(ix[:, ['B', 'A']], f.reindex(columns=['B', 'A']))
 
-        # slicing, ints
+        # slicing rows, etc.
         assert_frame_equal(ix[5:10], f[5:10])
         assert_frame_equal(ix[5:10, :], f[5:10])
+        assert_frame_equal(ix[:5, ['A', 'B']],
+                           f.reindex(index=f.index[:5], columns=['A', 'B']))
 
+        # slice rows with labels, inclusive!
+        expected = ix[5:11]
+        result = ix[f.index[5]:f.index[10]]
+        assert_frame_equal(expected, result)
 
+        # slice columns
+        assert_frame_equal(ix[:, :2], f.reindex(columns=['A', 'B']))
+
+        # return self if no slicing...for now
+        self.assert_(ix[:, :] is f)
+
+        # low dimensional slice
+        xs1 = ix[2, ['C', 'B', 'A']]
+        xs2 = f.xs(f.index[2]).reindex(['C', 'B', 'A'])
+        assert_series_equal(xs1, xs2)
+
+        ts1 = ix[5:10, 2]
+        ts2 = f[f.columns[2]][5:10]
+        assert_series_equal(ts1, ts2)
+
+        # individual value
+        for col in f.columns:
+            ts = f[col]
+            for idx in f.index[::5]:
+                assert_almost_equal(ix[idx, col], ts[idx])
+
+        self.assertRaises(Exception, ix.__getitem__,
+                          (slice(None, None, None),
+                           slice(None, None, None),
+                           slice(None, None, None)))
+
+        self.assertRaises(Exception, ix.__getitem__, slice(None, None, 2))
 
 if __name__ == '__main__':
     import nose

commit ee53c1ae29a3e8353e17f642d2c20ec8feff9056
Author: Jeff Tratner <jeffrey.tratner@gmail.com>
Date:   Thu Jul 4 11:57:24 2013 -0400

    ENH: Additional keyword arguments for Index.copy()
    
    * Index derivatives can set `name` or `names` as well as
      `dtype` on copy. MultiIndex can set `levels`, `labels`, and `names`.
    * Also, `__deepcopy__` just calls `copy(deep=True)`
    * Now, BlockManager.copy() takes an additional argument `copy_axes` which
      copies axes as well. Defaults to False.
    * `Series.copy()` takes an optional deep argument, which causes it to
      copy its index.
    * `DataFrame.copy()` passes `copy_axes=True` when deepcopying.
    * Add copy kwarg to MultiIndex `__new__`

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 58dcce9b9..ab7a347ef 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -47,6 +47,9 @@ pandas 0.13
   - Added a more informative error message when plot arguments contain
     overlapping color and style arguments (:issue:`4402`)
   - Significant table writing performance improvements in ``HDFStore``
+  - ``Index.copy()`` and ``MultiIndex.copy()`` now accept keyword arguments to
+    change attributes (i.e., ``names``, ``levels``, ``labels``)
+    (:issue:`4039`)
   - Add ``rename`` and ``set_names`` methods to ``Index`` as well as
     ``set_names``, ``set_levels``, ``set_labels`` to ``MultiIndex``.
     (:issue:`4039`)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 9b7960389..7be19302d 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -110,6 +110,12 @@ class Index(FrozenNDArray):
                 return Int64Index(data, copy=copy, dtype=dtype, name=name)
 
             subarr = com._asarray_tuplesafe(data, dtype=object)
+
+            # _asarray_tuplesafe does not always copy underlying data,
+            # so need to make sure that this happens
+            if copy:
+                subarr = subarr.copy()
+
         elif np.isscalar(data):
             raise TypeError('Index(...) must be called with a collection '
                              'of some kind, %s was passed' % repr(data))
@@ -120,7 +126,7 @@ class Index(FrozenNDArray):
         if dtype is None:
             inferred = lib.infer_dtype(subarr)
             if inferred == 'integer':
-                return Int64Index(subarr.astype('i8'), name=name)
+                return Int64Index(subarr.astype('i8'), copy=copy, name=name)
             elif inferred != 'string':
                 if (inferred.startswith('datetime') or
                         tslib.is_timestamp_array(subarr)):
@@ -145,6 +151,41 @@ class Index(FrozenNDArray):
     def _shallow_copy(self):
         return self.view()
 
+    def copy(self, names=None, name=None, dtype=None, deep=False):
+        """
+        Make a copy of this object.  Name and dtype sets those attributes on
+        the new object.
+
+        Parameters
+        ----------
+        name : string, optional
+        dtype : numpy dtype or pandas type
+
+        Returns
+        -------
+        copy : Index
+
+        Notes
+        -----
+        In most cases, there should be no functional difference from using
+        ``deep``, but if ``deep`` is passed it will attempt to deepcopy.
+        """
+        if names is not None and name is not None:
+            raise TypeError("Can only provide one of `names` and `name`")
+        if deep:
+            from copy import deepcopy
+            new_index = np.ndarray.__deepcopy__(self, {}).view(self.__class__)
+            name = name or deepcopy(self.name)
+        else:
+            new_index = super(Index, self).copy()
+        if name is not None:
+            names = [name]
+        if names:
+            new_index = new_index.set_names(names)
+        if dtype:
+            new_index = new_index.astype(dtype)
+        return new_index
+
     def __unicode__(self):
         """
         Return a string representation for a particular Index
@@ -338,10 +379,7 @@ class Index(FrozenNDArray):
             np.ndarray.__setstate__(self, state)
 
     def __deepcopy__(self, memo={}):
-        """
-        Index is not mutable, so disabling deepcopy
-        """
-        return self._shallow_copy()
+        return self.copy(deep=True)
 
     def __contains__(self, key):
         hash(key)
@@ -1440,9 +1478,9 @@ class MultiIndex(Index):
 
     Parameters
     ----------
-    levels : list or tuple of arrays
+    levels : sequence of arrays
         The unique labels for each level
-    labels : list or tuple of arrays
+    labels : sequence of arrays
         Integers for each level designating which label at each location
     sortorder : optional int
         Level of sortedness (must be lexicographically sorted by that
@@ -1455,7 +1493,8 @@ class MultiIndex(Index):
     _levels = FrozenList()
     _labels = FrozenList()
 
-    def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
+    def __new__(cls, levels=None, labels=None, sortorder=None, names=None,
+                copy=False):
         if len(levels) != len(labels):
             raise ValueError(
                 'Length of levels and labels must be the same')
@@ -1467,12 +1506,12 @@ class MultiIndex(Index):
             else:
                 name = None
 
-            return Index(levels[0], name=name).take(labels[0])
+            return Index(levels[0], name=name, copy=True).take(labels[0])
 
         # v3, 0.8.0
         subarr = np.empty(0, dtype=object).view(cls)
-        subarr._set_levels(levels)
-        subarr._set_labels(labels)
+        subarr._set_levels(levels, copy=copy)
+        subarr._set_labels(labels, copy=copy)
 
         if names is not None:
             subarr._set_names(names)
@@ -1489,13 +1528,13 @@ class MultiIndex(Index):
         return self._levels
 
 
-    def _set_levels(self, levels):
+    def _set_levels(self, levels, copy=False):
         # This is NOT part of the levels property because it should be
         # externally not allowed to set levels. User beware if you change
         # _levels directly
         if len(levels) == 0:
             raise ValueError("Must set non-zero number of levels.")
-        levels = FrozenList(_ensure_index(lev)._shallow_copy()
+        levels = FrozenList(_ensure_index(lev, copy=copy)._shallow_copy()
                             for lev in levels)
         names = self.names
         self._levels = levels
@@ -1534,10 +1573,11 @@ class MultiIndex(Index):
     def _get_labels(self):
         return self._labels
 
-    def _set_labels(self, labels):
+    def _set_labels(self, labels, copy=False):
         if len(labels) != self.nlevels:
             raise ValueError("Length of levels and labels must be the same.")
-        self._labels = FrozenList(_ensure_frozen(labs)._shallow_copy() for labs in labels)
+        self._labels = FrozenList(_ensure_frozen(labs,copy=copy)._shallow_copy()
+                                  for labs in labels)
 
     def set_labels(self, labels, inplace=False):
         """
@@ -1546,8 +1586,8 @@ class MultiIndex(Index):
 
         Parameters
         ----------
-        labels : sequence
-            new levels to apply
+        labels : sequence of arrays
+            new labels to apply
         inplace : bool
             if True, mutates in place
 
@@ -1592,6 +1632,11 @@ class MultiIndex(Index):
         This could be potentially expensive on large MultiIndex objects.
         """
         new_index = np.ndarray.copy(self)
+        if deep:
+            from copy import deepcopy
+            levels = levels if levels is not None else deepcopy(self.levels)
+            labels = labels if labels is not None else deepcopy(self.labels)
+            names = names if names is not None else deepcopy(self.names)
         if levels is not None:
             new_index = new_index.set_levels(levels)
         if labels is not None:
@@ -2831,11 +2876,13 @@ def _sparsify(label_list, start=0,sentinal=''):
     return lzip(*result)
 
 
-def _ensure_index(index_like):
+def _ensure_index(index_like, copy=False):
     if isinstance(index_like, Index):
+        if copy:
+            index_like = index_like.copy()
         return index_like
     if hasattr(index_like, 'name'):
-        return Index(index_like, name=index_like.name)
+        return Index(index_like, name=index_like.name, copy=copy)
 
     # must check for exactly list here because of strict type
     # check in clean_index_list
@@ -2849,15 +2896,27 @@ def _ensure_index(index_like):
             return MultiIndex.from_arrays(converted)
         else:
             index_like = converted
+    else:
+       # clean_index_list does the equivalent of copying
+       # so only need to do this if not list instance
+        if copy:
+            from copy import copy
+            index_like = copy(index_like)
 
     return Index(index_like)
 
-def _ensure_frozen(nd_array_like):
-    if isinstance(nd_array_like, FrozenNDArray):
-        return nd_array_like
-    else:
+
+def _ensure_frozen(nd_array_like, copy=False):
+    if not isinstance(nd_array_like, FrozenNDArray):
         arr = np.asarray(nd_array_like, dtype=np.int_)
-        return arr.view(FrozenNDArray)
+        # have to do this separately so that non-index input gets copied
+        if copy:
+            arr = arr.copy()
+        nd_array_like = arr.view(FrozenNDArray)
+    else:
+        if copy:
+            nd_array_like = nd_array_like.copy()
+    return nd_array_like
 
 
 def _validate_join_method(method):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 58fd0a055..e28305820 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1309,16 +1309,31 @@ class Series(generic.PandasContainer, pa.Array):
         """
         return self.view(ndarray)
 
-    def copy(self, order='C'):
+    def copy(self, order='C', deep=False):
         """
         Return new Series with copy of underlying values
 
+        Parameters
+        ----------
+        deep : boolean, default False
+            deep copy index along with data
+        order : boolean, default 'C'
+            order for underlying numpy array
+
         Returns
         -------
         cp : Series
         """
-        return Series(self.values.copy(order), index=self.index,
-                      name=self.name)
+        if deep:
+            from copy import deepcopy
+            index = self.index.copy(deep=deep)
+            name = deepcopy(self.name)
+        else:
+            index = self.index
+            name = self.name
+
+        return Series(self.values.copy(order), index=index,
+                      name=name)
 
     def tolist(self):
         """
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 3660b31b9..946e640d3 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -9,6 +9,7 @@ import numpy as np
 from pandas.tslib import iNaT
 
 from pandas import Series, DataFrame, date_range, DatetimeIndex, Timestamp
+import pandas.compat as compat
 from pandas.compat import range, long, lrange, lmap, u
 from pandas.core.common import notnull, isnull
 import pandas.compat as compat
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index b6c32a1e4..a5f981078 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -12,8 +12,10 @@ import numpy as np
 from numpy.testing import assert_array_equal
 
 from pandas.core.index import Index, Int64Index, MultiIndex, InvalidIndexError
-from pandas.util.testing import(assert_almost_equal, assertRaisesRegexp,
-                                assert_copy)
+from pandas.core.frame import DataFrame
+from pandas.core.series import Series
+from pandas.util.testing import (assert_almost_equal, assertRaisesRegexp,
+                                 assert_copy)
 from pandas import compat
 
 import pandas.util.testing as tm
@@ -54,12 +56,18 @@ class TestIndex(unittest.TestCase):
         self.assert_(new_index.ndim == 2)
         tm.assert_isinstance(new_index, np.ndarray)
 
-    def test_deepcopy(self):
-        from copy import deepcopy
+    def test_copy_and_deepcopy(self):
+        from copy import copy, deepcopy
 
-        copy = deepcopy(self.strIndex)
-        self.assert_(copy is not self.strIndex)
-        self.assert_(copy.equals(self.strIndex))
+        for func in (copy, deepcopy):
+            idx_copy = func(self.strIndex)
+            self.assert_(idx_copy is not self.strIndex)
+            self.assert_(idx_copy.equals(self.strIndex))
+
+        new_copy = self.strIndex.copy(deep=True, name="banana")
+        self.assertEqual(new_copy.name, "banana")
+        new_copy2 = self.intIndex.copy(dtype=int)
+        self.assertEqual(new_copy2.dtype.kind, 'i')
 
     def test_duplicates(self):
         idx = Index([0, 0, 0])
@@ -88,6 +96,8 @@ class TestIndex(unittest.TestCase):
         tm.assert_isinstance(index, Index)
         self.assert_(index.name == 'name')
         assert_array_equal(arr, index)
+        arr[0] = "SOMEBIGLONGSTRING"
+        self.assertNotEqual(index[0], "SOMEBIGLONGSTRING")
 
         # what to do here?
         # arr = np.array(5.)
@@ -598,6 +608,15 @@ class TestInt64Index(unittest.TestCase):
         # scalar raise Exception
         self.assertRaises(ValueError, Int64Index, 5)
 
+        # copy
+        arr = self.index.values
+        new_index = Int64Index(arr, copy=True)
+        self.assert_(np.array_equal(new_index, self.index))
+        val = arr[0] + 3000
+        # this should not change index
+        arr[0] = val
+        self.assertNotEqual(new_index[0], val)
+
     def test_constructor_corner(self):
         arr = np.array([1, 2, 3, 4], dtype=object)
         index = Int64Index(arr)
@@ -970,6 +989,35 @@ class TestMultiIndex(unittest.TestCase):
                                 labels=[major_labels, minor_labels],
                                 names=self.index_names)
 
+    def test_copy_in_constructor(self):
+        levels = np.array(["a", "b", "c"])
+        labels = np.array([1, 1, 2, 0, 0, 1, 1])
+        val = labels[0]
+        mi = MultiIndex(levels=[levels, levels], labels=[labels, labels],
+                        copy=True)
+        self.assertEqual(mi.labels[0][0], val)
+        labels[0] = 15
+        self.assertEqual(mi.labels[0][0], val)
+        val = levels[0]
+        levels[0] = "PANDA"
+        self.assertEqual(mi.levels[0][0], val)
+
+    def test_set_value_keeps_names(self):
+        # motivating example from #3742
+        lev1 = ['hans', 'hans', 'hans', 'grethe', 'grethe', 'grethe']
+        lev2 = ['1', '2', '3'] * 2
+        idx = pd.MultiIndex.from_arrays(
+            [lev1, lev2],
+            names=['Name', 'Number'])
+        df = pd.DataFrame(
+            np.random.randn(6, 4),
+            columns=['one', 'two', 'three', 'four'],
+            index=idx)
+        df = df.sortlevel()
+        self.assertEqual(df.index.names, ('Name', 'Number'))
+        df = df.set_value(('grethe', '4'), 'one', 99.34)
+        self.assertEqual(df.index.names, ('Name', 'Number'))
+
     def test_names(self):
 
         # names are assigned in __init__
@@ -1046,11 +1094,11 @@ class TestMultiIndex(unittest.TestCase):
         self.assert_(copy.labels is not original.labels)
 
         # names doesn't matter which way copied
-        self.assert_(copy.names == original.names)
+        self.assertEqual(copy.names, original.names)
         self.assert_(copy.names is not original.names)
 
         # sort order should be copied
-        self.assert_(copy.sortorder == original.sortorder)
+        self.assertEqual(copy.sortorder, original.sortorder)
 
     def test_copy(self):
         i_copy = self.index.copy()
@@ -1469,7 +1517,7 @@ class TestMultiIndex(unittest.TestCase):
 
         # create index with duplicates
         idx1 = Index(lrange(10) + lrange(10))
-        idx2 = Index(range(20))
+        idx2 = Index(lrange(20))
         assertRaisesRegexp(InvalidIndexError, "Reindexing only valid with"
                            " uniquely valued Index objects",
                            idx1.get_indexer, idx2)
@@ -1672,22 +1720,6 @@ class TestMultiIndex(unittest.TestCase):
         assertRaisesRegexp(TypeError, "other must be a MultiIndex or a list"
                            " of tuples", first.diff, [1,2,3,4,5])
 
-    def test_set_value_keeps_names(self):
-        # motivating example from #3742
-        lev1 = ['hans', 'hans', 'hans', 'grethe', 'grethe', 'grethe']
-        lev2 = ['1', '2', '3'] * 2
-        idx = pd.MultiIndex.from_arrays(
-            [lev1, lev2],
-            names=['Name', 'Number'])
-        df = pd.DataFrame(
-            np.random.randn(6, 4),
-            columns=['one', 'two', 'three', 'four'],
-            index=idx)
-        df = df.sortlevel()
-        self.assertEqual(tuple(df.index.names), ('Name', 'Number'))
-        df = df.set_value(('grethe', 'hans'), 'one', 99.34)
-        self.assertEqual(tuple(df.index.names), ('Name', 'Number'))
-
     def test_from_tuples(self):
         assertRaisesRegexp(TypeError, 'Cannot infer number of levels from'
                            ' empty list', MultiIndex.from_tuples, [])
@@ -1957,7 +1989,6 @@ def test_get_combined_index():
     result = _get_combined_index([])
     assert(result.equals(Index([])))
 
-
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)

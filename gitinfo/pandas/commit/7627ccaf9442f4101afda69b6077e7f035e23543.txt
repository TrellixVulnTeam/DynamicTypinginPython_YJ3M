commit 7627ccaf9442f4101afda69b6077e7f035e23543
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Nov 29 05:24:00 2017 -0800

    check for datetime+period addition (#18524)

diff --git a/doc/source/whatsnew/v0.22.0.txt b/doc/source/whatsnew/v0.22.0.txt
index 1eb1b5487..4a27bf54d 100644
--- a/doc/source/whatsnew/v0.22.0.txt
+++ b/doc/source/whatsnew/v0.22.0.txt
@@ -208,4 +208,5 @@ Other
 
 - Improved error message when attempting to use a Python keyword as an identifier in a numexpr query (:issue:`18221`)
 - Fixed a bug where creating a Series from an array that contains both tz-naive and tz-aware values will result in a Series whose dtype is tz-aware instead of object (:issue:`16406`)
+- Adding a ``Period`` object to a ``datetime`` or ``Timestamp`` object will now correctly raise a ``TypeError`` (:issue:`17983`)
 -
diff --git a/pandas/_libs/period.pyx b/pandas/_libs/period.pyx
index 2b09e9376..b95632b5b 100644
--- a/pandas/_libs/period.pyx
+++ b/pandas/_libs/period.pyx
@@ -17,6 +17,10 @@ from pandas.compat import PY2
 
 cimport cython
 
+from cpython.datetime cimport PyDateTime_Check, PyDateTime_IMPORT
+# import datetime C API
+PyDateTime_IMPORT
+
 from tslibs.np_datetime cimport (pandas_datetimestruct,
                                  dtstruct_to_dt64, dt64_to_dtstruct,
                                  is_leapyear)
@@ -647,9 +651,19 @@ cdef class _Period(object):
             elif util.is_integer_object(other):
                 ordinal = self.ordinal + other * self.freq.n
                 return Period(ordinal=ordinal, freq=self.freq)
+            elif (PyDateTime_Check(other) or
+                  is_period_object(other) or util.is_datetime64_object(other)):
+                # can't add datetime-like
+                # GH#17983
+                sname = type(self).__name__
+                oname = type(other).__name__
+                raise TypeError("unsupported operand type(s) for +: '{self}' "
+                                "and '{other}'".format(self=sname,
+                                                       other=oname))
             else:  # pragma: no cover
                 return NotImplemented
         elif is_period_object(other):
+            # this can be reached via __radd__ because of cython rules
             return other + self
         else:
             return NotImplemented
diff --git a/pandas/tests/scalar/test_period.py b/pandas/tests/scalar/test_period.py
index 8cfdf7a46..3bd4a28b7 100644
--- a/pandas/tests/scalar/test_period.py
+++ b/pandas/tests/scalar/test_period.py
@@ -1038,6 +1038,29 @@ class TestMethods(object):
         with tm.assert_raises_regex(TypeError, msg):
             dt1 + dt2
 
+    boxes = [lambda x: x, lambda x: pd.Series([x]), lambda x: pd.Index([x])]
+
+    @pytest.mark.parametrize('lbox', boxes)
+    @pytest.mark.parametrize('rbox', boxes)
+    def test_add_timestamp_raises(self, rbox, lbox):
+        # GH # 17983
+        ts = pd.Timestamp('2017')
+        per = pd.Period('2017', freq='M')
+
+        # We may get a different message depending on which class raises
+        # the error.
+        msg = (r"cannot add|unsupported operand|"
+               r"can only operate on a|incompatible type|"
+               r"ufunc add cannot use operands")
+        with tm.assert_raises_regex(TypeError, msg):
+            lbox(ts) + rbox(per)
+
+        with tm.assert_raises_regex(TypeError, msg):
+            lbox(per) + rbox(ts)
+
+        with tm.assert_raises_regex(TypeError, msg):
+            lbox(per) + rbox(per)
+
     def test_sub(self):
         dt1 = Period('2011-01-01', freq='D')
         dt2 = Period('2011-01-15', freq='D')

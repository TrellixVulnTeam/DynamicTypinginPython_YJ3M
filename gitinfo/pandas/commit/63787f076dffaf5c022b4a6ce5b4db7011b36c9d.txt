commit 63787f076dffaf5c022b4a6ce5b4db7011b36c9d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 30 12:13:41 2012 -0400

    Python 3 compatibility in datetime string parsing, hacks around unorderable type errors from index engine

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 70630d480..e4496772f 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -623,6 +623,9 @@ class Index(np.ndarray):
             except Exception:  # pragma: no cover
                 raise e1
         except TypeError:
+            # python 3
+            if np.isscalar(key):  # pragma: no cover
+                raise IndexError(key)
             raise InvalidIndexError(key)
 
     def set_value(self, arr, key, value):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e5b20e905..ff6c058b3 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -480,7 +480,10 @@ copy : boolean, default False
                 return
 
             raise KeyError('%s not in this series!' % str(key))
-        except TypeError:
+        except TypeError, e:
+            # python 3 type errors should be raised
+            if 'unorderable' in str(e):  # pragma: no cover
+                raise IndexError(key)
             # Could not hash item
             pass
 
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index cf9da9266..e89be7f52 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -96,6 +96,8 @@ cdef extern from "np_datetime_strings.h":
 
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
 
+    int parse_python_string(object obj, npy_datetimestruct *out) except -1
+
 cdef extern from "period.h":
     ctypedef struct date_info:
         int64_t absdate
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index a16c87e87..17a4b7318 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -10,6 +10,7 @@ from datetime cimport *
 from util cimport is_integer_object, is_datetime64_object
 
 from dateutil.parser import parse as parse_date
+cimport util
 
 # initialize numpy
 import_array()
@@ -202,7 +203,7 @@ cdef class _TSObject:
             return self.value
 
 # helper to extract datetime and int64 from several different possibilities
-cdef convert_to_tsobject(object ts, object tzinfo=None):
+cpdef convert_to_tsobject(object ts, object tzinfo=None):
     """
     Extract datetime and int64 from any of:
         - np.int64
@@ -213,9 +214,6 @@ cdef convert_to_tsobject(object ts, object tzinfo=None):
         - another timestamp object
     """
     cdef:
-        Py_ssize_t strlen
-        npy_bool islocal, special
-        NPY_DATETIMEUNIT out_bestunit
         npy_datetimestruct dts
         _Timestamp tmp
         _TSObject retval
@@ -242,10 +240,8 @@ cdef convert_to_tsobject(object ts, object tzinfo=None):
                             dts.day, dts.hour,
                             dts.min, dts.sec, dts.us)
     # this is pretty cheap
-    elif PyString_Check(ts):
-        # we might want to fall back on dateutil parser?
-        parse_iso_8601_datetime(ts, len(ts), NPY_FR_us, NPY_UNSAFE_CASTING,
-                                &dts, &islocal, &out_bestunit, &special)
+    elif util.is_string_object(ts):
+        parse_python_string(ts, &dts)
         retval.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
         retval.dtval = <object>PyDateTime_FromDateAndTime(
                             dts.year, dts.month,
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 7d5c037f8..6f4dae152 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -116,8 +116,10 @@ cdef class IndexEngine:
 
         if self.is_monotonic:
             values = self._get_index_values()
+
             left = values.searchsorted(val, side='left')
             right = values.searchsorted(val, side='right')
+
             diff = right - left
             if diff == 0:
                 raise KeyError(val)
diff --git a/pandas/src/np_datetime_strings.c b/pandas/src/np_datetime_strings.c
index d377ced94..132b6811d 100644
--- a/pandas/src/np_datetime_strings.c
+++ b/pandas/src/np_datetime_strings.c
@@ -305,6 +305,41 @@ convert_datetimestruct_local_to_utc(npy_datetimestruct *out_dts_utc,
     return 0;
 }
 
+int
+parse_python_string(PyObject* obj, npy_datetimestruct *dts) {
+    PyObject *bytes = NULL;
+    char *str = NULL;
+    Py_ssize_t len = 0;
+    NPY_DATETIMEUNIT bestunit = -1;
+
+    /* Convert to an ASCII string for the date parser */
+    if (PyUnicode_Check(obj)) {
+        bytes = PyUnicode_AsASCIIString(obj);
+        if (bytes == NULL) {
+            return -1;
+        }
+    }
+    else {
+        bytes = obj;
+        Py_INCREF(bytes);
+    }
+    if (PyBytes_AsStringAndSize(bytes, &str, &len) == -1) {
+        Py_DECREF(bytes);
+        return -1;
+    }
+
+    /* Parse the ISO date */
+    if (parse_iso_8601_datetime(str, len, NPY_FR_us, NPY_UNSAFE_CASTING,
+                            &dts, NULL, &bestunit, NULL) < 0) {
+        Py_DECREF(bytes);
+        return -1;
+    }
+    Py_DECREF(bytes);
+
+    return 0;
+}
+
+
 /*
  * Parses (almost) standard ISO 8601 date strings. The differences are:
  *
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 90dba85b2..04733f2f6 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -26,6 +26,7 @@ import cPickle as pickle
 import pandas.core.datetools as dt
 from numpy.random import rand
 from pandas.util.testing import assert_frame_equal
+import pandas.util.py3compat as py3compat
 from pandas.core.datetools import BDay
 import pandas.core.common as com
 
@@ -409,6 +410,7 @@ class TestTimeSeries(unittest.TestCase):
         assert_series_equal(result, expected)
 
     def test_take_dont_lose_meta(self):
+        _skip_if_no_pytz()
         rng = date_range('1/1/2000', periods=20, tz='US/Eastern')
 
         result = rng.take(range(5))
@@ -541,6 +543,9 @@ class TestLegacySupport(unittest.TestCase):
 
     @classmethod
     def setUpClass(cls):
+        if py3compat.PY3:
+            raise nose.SkipTest
+
         pth, _ = os.path.split(os.path.abspath(__file__))
         filepath = os.path.join(pth, 'data', 'frame.pickle')
 
@@ -1015,6 +1020,7 @@ class TestDatetime64(unittest.TestCase):
         self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
 
     def test_asobject_tz_box(self):
+        _skip_if_no_pytz()
         tz = pytz.timezone('US/Eastern')
         index = DatetimeIndex(start='1/1/2005', periods=10, tz=tz,
                               freq='B')

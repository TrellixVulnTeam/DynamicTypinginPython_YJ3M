commit 188ddd7dd291dd6b5212500d44df3e3569f4d5fb
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Aug 11 23:24:02 2012 -0400

    BUG: fix tz-aware daterange generation issue close #1674

diff --git a/RELEASE.rst b/RELEASE.rst
index f91ed2516..af750cc23 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -70,6 +70,7 @@ pandas 0.8.2
   - When grouping by level, exclude unobserved levels (#1697)
   - Don't lose tzinfo in DatetimeIndex when shifting by different offset (#1683)
   - Hack to support storing data with a zero-length axis in HDFStore (#1707)
+  - Fix DatetimeIndex tz-aware range generation issue (#1674)
 
 pandas 0.8.1
 ============
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index ca56b6e97..7b88a00e6 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -260,6 +260,35 @@ class DatetimeIndex(Int64Index):
 
         if start is not None:
             start = Timestamp(start)
+
+        if end is not None:
+            end = Timestamp(end)
+
+        inferred_tz = tools._infer_tzinfo(start, end)
+
+        if tz is not None and inferred_tz is not None:
+            assert(inferred_tz == tz)
+        elif inferred_tz is not None:
+            tz = inferred_tz
+
+        if inferred_tz is None and tz is not None:
+            # naive dates
+            if start is not None and start.tz is None:
+                start = start.tz_localize(tz)
+
+            if end is not None and end.tz is None:
+                end = end.tz_localize(tz)
+        elif inferred_tz is not None:
+            pass
+
+        if start and end:
+            if start.tz is None and end.tz is not None:
+                start = start.tz_localize(end.tz)
+
+            if end.tz is None and start.tz is not None:
+                end = end.tz_localize(start.tz)
+
+        if start is not None:
             if normalize:
                 start = normalize_date(start)
                 _normalized = True
@@ -267,15 +296,13 @@ class DatetimeIndex(Int64Index):
                 _normalized = _normalized and start.time() == _midnight
 
         if end is not None:
-            end = Timestamp(end)
-
             if normalize:
                 end = normalize_date(end)
                 _normalized = True
             else:
                 _normalized = _normalized and end.time() == _midnight
 
-        start, end, tz = tools._figure_out_timezone(start, end, tz)
+        tz = tools._maybe_get_tz(tz)
 
         if com._count_not_none(start, end, periods) < 2:
             raise ValueError('Must specify two of start, end, or periods')
@@ -288,12 +315,6 @@ class DatetimeIndex(Int64Index):
         else:
             index = _generate_regular_range(start, end, periods, offset)
 
-        if tz is not None:
-            # Convert local to UTC
-            ints = index.view('i8', type=np.ndarray)
-            index = lib.tz_localize_to_utc(ints, tz)
-            index = index.view(_NS_DTYPE)
-
         index = index.view(cls)
         index.name = name
         index.offset = offset
@@ -1298,7 +1319,9 @@ def _generate_regular_range(start, end, periods, offset):
         xdr = generate_range(start=start, end=end,
             periods=periods, offset=offset)
 
-        data = np.array(list(xdr), dtype=_NS_DTYPE)
+        dates = list(xdr)
+        utc = len(dates) > 0 and dates[0].tzinfo is not None
+        data = tools.to_datetime(dates, utc=utc)
 
     return data
 
@@ -1408,6 +1431,8 @@ def _naive_in_cache_range(start, end):
     if start is None or end is None:
         return False
     else:
+        if start.tzinfo is not None or end.tzinfo is not None:
+            return False
         return _in_range(start, end, _CACHE_START, _CACHE_END)
 
 def _in_range(start, end, rng_start, rng_end):
@@ -1416,3 +1441,13 @@ def _in_range(start, end, rng_start, rng_end):
 def _time_to_micros(time):
     seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
     return 1000000 * seconds + time.microsecond
+
+def _utc_naive(dt):
+    if dt is None:
+        return dt
+
+    if dt.tz is not None:
+        dt = dt.tz_convert('utc').replace(tzinfo=None)
+
+    return dt
+
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 1d09654f9..cae4167dc 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -165,8 +165,8 @@ class TestTimeZoneSupport(unittest.TestCase):
         self.assertEquals(exp.hour, 1)
         self.assertEquals(rng[1], exp)
 
-        self.assertRaises(pytz.NonExistentTimeError, date_range,
-                          '3/11/2012 00:00', periods=10, freq='H', tz='US/Eastern')
+        rng = date_range('3/11/2012 00:00', periods=10, freq='H', tz='US/Eastern')
+        self.assert_(rng[2].hour == 3)
 
     def test_utc_box_timestamp_and_localize(self):
         rng = date_range('3/11/2012', '3/12/2012', freq='H', tz='utc')
@@ -404,6 +404,13 @@ class TestTimeZoneSupport(unittest.TestCase):
         result = dr_tz.shift(1, '10T')
         self.assert_(result.tz == dr_tz.tz)
 
+    def test_tz_aware_asfreq(self):
+        dr = date_range('2011-12-01','2012-07-20',freq = 'D', tz = 'US/Eastern')
+
+        s = Series(np.random.randn(len(dr)), index=dr)
+
+        # it works!
+        s.asfreq('T')
 
 class TestTimeZones(unittest.TestCase):
 
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 1cd1b1f28..57330ac99 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -26,7 +26,7 @@ def _infer_tzinfo(start, end):
     def _infer(a, b):
         tz = a.tzinfo
         if b and b.tzinfo:
-            assert(tz == b.tzinfo)
+            assert(tz.zone == b.tzinfo.zone)
         return tz
     tz = None
     if start is not None:
@@ -42,24 +42,6 @@ def _maybe_get_tz(tz):
         tz = pytz.timezone(tz)
     return tz
 
-def _figure_out_timezone(start, end, tzinfo):
-    inferred_tz = _infer_tzinfo(start, end)
-    tzinfo = _maybe_get_tz(tzinfo)
-
-    tz = inferred_tz
-    if inferred_tz is None and tzinfo is not None:
-        tz = tzinfo
-    elif tzinfo is not None:
-        assert(inferred_tz == tzinfo)
-        # make tz naive for now
-
-    # tz = _maybe_get_tz(tz)
-
-    start = start if start is None else start.replace(tzinfo=None)
-    end = end if end is None else end.replace(tzinfo=None)
-
-    return start, end, tz
-
 
 def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True):
     """

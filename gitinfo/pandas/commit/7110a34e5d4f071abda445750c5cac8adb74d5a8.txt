commit 7110a34e5d4f071abda445750c5cac8adb74d5a8
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Jul 26 05:41:32 2018 -0700

    CLN: Remove Unneeded BlockManager methods (#22002)

diff --git a/pandas/_libs/internals.pyx b/pandas/_libs/internals.pyx
index 55f2e06a1..97cc7f96c 100644
--- a/pandas/_libs/internals.pyx
+++ b/pandas/_libs/internals.pyx
@@ -32,6 +32,8 @@ cdef class BlockPlacement:
     def __init__(self, val):
         cdef slice slc
 
+        self._as_slice = None
+        self._as_array = None
         self._has_slice = False
         self._has_array = False
 
@@ -144,6 +146,7 @@ cdef class BlockPlacement:
             other_int = <Py_ssize_t>other
 
             if other_int == 0:
+                # BlockPlacement is treated as immutable
                 return self
 
             start, stop, step, l = slice_get_indices_ex(s)
@@ -155,33 +158,21 @@ cdef class BlockPlacement:
                 raise ValueError("iadd causes length change")
 
             if stop < 0:
-                self._as_slice = slice(start, None, step)
+                val = slice(start, None, step)
             else:
-                self._as_slice = slice(start, stop, step)
+                val = slice(start, stop, step)
 
-            self._has_array = False
-            self._as_array = None
+            return BlockPlacement(val)
         else:
             newarr = self.as_array + other
             if (newarr < 0).any():
                 raise ValueError("iadd causes length change")
 
-            self._as_array = newarr
-            self._has_array = True
-            self._has_slice = False
-            self._as_slice = None
-
-        return self
-
-    cdef BlockPlacement copy(self):
-        cdef slice s = self._ensure_has_slice()
-        if s is not None:
-            return BlockPlacement(s)
-        else:
-            return BlockPlacement(self._as_array)
+            val = newarr
+            return BlockPlacement(val)
 
     def add(self, other):
-        return self.copy().iadd(other)
+        return self.iadd(other)
 
     def sub(self, other):
         return self.add(-other)
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index 8ad569003..e7b7cb463 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -82,7 +82,6 @@ class BlockManager(PandasObject):
     get_slice(slice_like, axis)
     get(label)
     iget(loc)
-    get_scalar(label_tup)
 
     take(indexer, axis)
     reindex_axis(new_labels, axis)
@@ -993,21 +992,6 @@ class BlockManager(PandasObject):
                                          ndim=1)],
             self.axes[1])
 
-    def get_scalar(self, tup):
-        """
-        Retrieve single item
-        """
-        full_loc = [ax.get_loc(x) for ax, x in zip(self.axes, tup)]
-        blk = self.blocks[self._blknos[full_loc[0]]]
-        values = blk.values
-
-        # FIXME: this may return non-upcasted types?
-        if values.ndim == 1:
-            return values[full_loc[1]]
-
-        full_loc[0] = self._blklocs[full_loc[0]]
-        return values[tuple(full_loc)]
-
     def delete(self, item):
         """
         Delete selected item (items if non-unique) in-place.
@@ -1382,9 +1366,9 @@ class BlockManager(PandasObject):
                                     axis=axis, allow_dups=True)
 
     def merge(self, other, lsuffix='', rsuffix=''):
-        if not self._is_indexed_like(other):
-            raise AssertionError('Must have same axes to merge managers')
-
+        # We assume at this point that the axes of self and other match.
+        # This is only called from Panel.join, which reindexes prior
+        # to calling to ensure this assumption holds.
         l, r = items_overlap_with_suffix(left=self.items, lsuffix=lsuffix,
                                          right=other.items, rsuffix=rsuffix)
         new_items = _concat_indexes([l, r])
@@ -1402,19 +1386,6 @@ class BlockManager(PandasObject):
 
         return self.__class__(_consolidate(new_blocks), new_axes)
 
-    def _is_indexed_like(self, other):
-        """
-        Check all axes except items
-        """
-        if self.ndim != other.ndim:
-            raise AssertionError(
-                'Number of dimensions must agree got {ndim} and '
-                '{oth_ndim}'.format(ndim=self.ndim, oth_ndim=other.ndim))
-        for ax, oax in zip(self.axes[1:], other.axes[1:]):
-            if not ax.equals(oax):
-                return False
-        return True
-
     def equals(self, other):
         self_axes, other_axes = self.axes, other.axes
         if len(self_axes) != len(other_axes):
diff --git a/pandas/tests/internals/test_internals.py b/pandas/tests/internals/test_internals.py
index 39418fb72..0b0677532 100644
--- a/pandas/tests/internals/test_internals.py
+++ b/pandas/tests/internals/test_internals.py
@@ -329,17 +329,6 @@ class TestBlockManager(object):
         assert create_mgr('a,b:f8; c,d: f4').is_mixed_type
         assert create_mgr('a,b:f8; c,d: object').is_mixed_type
 
-    def test_is_indexed_like(self):
-        mgr1 = create_mgr('a,b: f8')
-        mgr2 = create_mgr('a:i8; b:bool')
-        mgr3 = create_mgr('a,b,c: f8')
-        assert mgr1._is_indexed_like(mgr1)
-        assert mgr1._is_indexed_like(mgr2)
-        assert mgr1._is_indexed_like(mgr3)
-
-        assert not mgr1._is_indexed_like(mgr1.get_slice(
-            slice(-1), axis=1))
-
     def test_duplicate_ref_loc_failure(self):
         tmp_mgr = create_mgr('a:bool; a: f8')
 
@@ -396,15 +385,6 @@ class TestBlockManager(object):
         smgr2 = tm.round_trip_pickle(smgr)
         assert_series_equal(Series(smgr), Series(smgr2))
 
-    def test_get_scalar(self, mgr):
-        for item in mgr.items:
-            for i, index in enumerate(mgr.axes[1]):
-                res = mgr.get_scalar((item, index))
-                exp = mgr.get(item, fastpath=False)[i]
-                assert res == exp
-                exp = mgr.get(item).internal_values()[i]
-                assert res == exp
-
     def test_get(self):
         cols = Index(list('abc'))
         values = np.random.rand(3, 3)

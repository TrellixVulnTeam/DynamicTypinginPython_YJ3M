commit bd52f05a890f2d5185c57f0a175ab6dddba94d73
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Aug 8 17:58:19 2011 -0400

    TST: Index/MultiIndex testing and minor refactoring

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index f09178a07..5ed271665 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -110,8 +110,7 @@ class DateRange(Index):
         self.tzinfo = tzinfo
         Index.__setstate__(self, *index_state)
 
-    @property
-    def _allDates(self):
+    def is_all_dates(self):
         return True
 
     @classmethod
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 6d9a4cbb1..59e7940cf 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2756,6 +2756,8 @@ def _homogenize(data, index, columns, dtype=None):
             # only *attempt* to cast to dtype
             try:
                 arr = np.asarray(v, dtype=dtype)
+
+                # prevent NumPy from casting things to string when it shouldn't
                 if issubclass(arr.dtype.type, basestring):
                     arr = np.array(v, dtype=object, copy=False)
                 v = arr
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 7e8e4a022..b501198e9 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1,8 +1,11 @@
 # pylint: disable=E1101,E1103,W0232
 
+from datetime import time
+from itertools import izip
+
 import numpy as np
 
-from pandas.core.common import _ensure_index, _is_bool_indexer
+from pandas.core.common import _format, adjoin, _ensure_index, _is_bool_indexer
 import pandas.core.common as common
 import pandas._tseries as _tseries
 
@@ -37,25 +40,19 @@ class Index(np.ndarray):
     def __new__(cls, data, dtype=object, copy=False):
         if isinstance(data, np.ndarray):
             subarr = np.array(data, dtype=dtype, copy=copy)
+        elif np.isscalar(data):
+            raise ValueError('Index(...) must be called with a collection '
+                             'of some kind, %s was passed' % repr(data))
         else:
             subarr = np.empty(len(data), dtype=dtype)
             subarr[:] = data
 
-        if subarr.ndim == 0:
-            raise Exception('Index(...) must be called with a collection '
-                            'of some kind, %s was passed' % repr(data))
-
+        assert(subarr.ndim == 1)
         return subarr.view(cls)
 
-    def __array_finalize__(self, obj):
-        if self.ndim == 0:
-            # tolist will cause a bus error if this is not here, hmm
-            return self.item()
-            # raise Exception('Cannot create 0-dimensional Index!')
-
     def summary(self):
         if len(self) > 0:
-            index_summary = ', %s to %s' % (self[0], self[-1])
+            index_summary = ', %s to %s' % (str(self[0]), str(self[-1]))
         else:
             index_summary = ''
         return 'Index: %s entries%s' % (len(self), index_summary)
@@ -68,16 +65,12 @@ class Index(np.ndarray):
 
         return self._cache_indexMap
 
-    @property
-    def _allDates(self):
+    def is_all_dates(self):
         if not hasattr(self, '_cache_allDates'):
             self._cache_allDates = _tseries.isAllDates(self)
 
         return self._cache_allDates
 
-    def is_all_dates(self):
-        return self._allDates
-
     def _verify_integrity(self):
         if len(self.indexMap) < len(self):
             raise Exception('Index cannot contain duplicate values!')
@@ -95,8 +88,8 @@ class Index(np.ndarray):
         """
         return self
 
-    def __contains__(self, date):
-        return date in self.indexMap
+    def __contains__(self, key):
+        return key in self.indexMap
 
     def __hash__(self):
         return hash(self.view(np.ndarray))
@@ -114,21 +107,12 @@ class Index(np.ndarray):
             if _is_bool_indexer(key):
                 key = np.asarray(key)
 
-            # easier to ask forgiveness than permission
-            try:
-                return Index(arr_idx[key])
-            except Exception, e1:
-                try:
-                    return Index(arr_idx[np.asarray(key)])
-                except Exception: # pragma: no cover
-                    raise e1
+            return Index(arr_idx[key])
 
     def format(self):
         """
         Render a string representation of the Index
         """
-        from datetime import time
-
         if self.is_all_dates():
             to_join = []
             zero_time = time(0, 0)
@@ -289,6 +273,7 @@ class Index(np.ndarray):
 
         Returns
         -------
+        (begin, end) : tuple
 
         Notes
         -----
@@ -311,6 +296,9 @@ class Index(np.ndarray):
         return beg_slice, end_slice
 
 
+class DateIndex(Index):
+    pass
+
 
 class Factor(object):
     """
@@ -389,10 +377,20 @@ class MultiIndex(Index):
         self.levels = [_ensure_index(lev) for lev in levels]
         self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
 
-    def __array_finalize__(self, obj):
-        pass
-        # self.labels = getattr(obj, 'labels', None)
-        # self.levels = getattr(obj, 'levels', None)
+    def __iter__(self):
+        values = [np.asarray(lev).take(lab)
+                  for lev, lab in zip(self.levels, self.labels)]
+        return izip(*values)
+
+    def __contains__(self, key):
+        try:
+            label_key = self._get_label_key(key)
+            return label_key in self.indexMap
+        except Exception:
+            return False
+
+    def is_all_dates(self):
+        return False
 
     @classmethod
     def from_arrays(cls, *arrays):
@@ -454,17 +452,8 @@ class MultiIndex(Index):
             if _is_bool_indexer(key):
                 key = np.asarray(key)
 
-            # easier to ask forgiveness than permission
-            try:
-                new_tuples = arr_idx[key]
-                new_labels = [lab[key] for lab in self.labels]
-            except Exception, e1:
-                try:
-                    key = np.asarray(key)
-                    new_tuples = arr_idx[key]
-                    new_labels = [lab[key] for lab in self.labels]
-                except Exception: # pragma: no cover
-                    raise e1
+            new_tuples = arr_idx[key]
+            new_labels = [lab[key] for lab in self.labels]
 
             # an optimization
             result = new_tuples.view(MultiIndex)
@@ -476,8 +465,6 @@ class MultiIndex(Index):
         return self.__getitem__(slice(i, j))
 
     def format(self, space=2):
-        from pandas.core.common import _format, adjoin
-
         stringified_levels = [lev.format().split('\n') for lev in self.levels]
 
         padded_levels = []
@@ -509,13 +496,15 @@ class MultiIndex(Index):
         return self.indexMap[key]
 
     def _get_tuple_loc(self, tup):
-        zipped = zip(self.levels, tup)
-        indexer = tuple(lev.get_loc(v) for lev, v in zipped)
+        indexer = self._get_label_key(tup)
         try:
             return self.indexMap[indexer]
         except KeyError:
             raise KeyError(str(tup))
 
+    def _get_label_key(self, tup):
+        return tuple(lev.get_loc(v) for lev, v in zip(self.levels, tup))
+
     def get_indexer(self, target, method=None):
         """
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index fa65fc3bb..18988c2b4 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -740,6 +740,11 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(frame['A'].dtype == np.object_)
         self.assert_(frame['B'].dtype == np.float_)
 
+    def test_constructor_dict_dont_upcast(self):
+        d = {'Col1': {'Row1': 'A String', 'Row2': np.nan}}
+        df = DataFrame(d)
+        self.assert_(isinstance(df['Col1']['Row2'], float))
+
     def test_constructor_ndarray(self):
         mat = np.zeros((2, 3), dtype=float)
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 8fc24f644..9bb8423b7 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -1,11 +1,12 @@
-from datetime import timedelta
+from datetime import datetime, timedelta
 import operator
 import pickle
 import unittest
 
 import numpy as np
 
-from pandas.core.index import Index, Factor, MultiIndex
+from pandas.core.index import Index, Factor, MultiIndex, NULL_INDEX
+from pandas.util.testing import assert_almost_equal
 import pandas.util.testing as common
 import pandas._tseries as tseries
 
@@ -15,6 +16,8 @@ class TestIndex(unittest.TestCase):
         self.strIndex = common.makeStringIndex(100)
         self.dateIndex = common.makeDateIndex(100)
         self.intIndex = common.makeIntIndex(100)
+        self.empty = Index([])
+        self.tuples = Index(zip(['foo', 'bar', 'baz'], [1, 2, 3]))
 
     def test_hash_error(self):
         self.assertRaises(TypeError, hash, self.strIndex)
@@ -47,12 +50,14 @@ class TestIndex(unittest.TestCase):
         common.assert_contains_all(arr, index)
         self.assert_(np.array_equal(self.strIndex, index))
 
-        # corner case
-        self.assertRaises(Exception, Index, 0)
-
+        # what to do here?
         # arr = np.array(5.)
         # self.assertRaises(Exception, arr.view, Index)
 
+    def test_constructor_corner(self):
+        # corner case
+        self.assertRaises(Exception, Index, 0)
+
     def test_compat(self):
         self.strIndex.tolist()
 
@@ -123,28 +128,6 @@ class TestIndex(unittest.TestCase):
         arr = np.array(self.dateIndex)
         self.assertEquals(self.dateIndex[5], arr[5])
 
-    def test_add(self):
-        firstCat = self.strIndex + self.dateIndex
-        secondCat = self.strIndex + self.strIndex
-
-        self.assert_(common.equalContents(np.append(self.strIndex,
-                                                    self.dateIndex), firstCat))
-        self.assert_(common.equalContents(secondCat, self.strIndex))
-        common.assert_contains_all(self.strIndex, firstCat.indexMap)
-        common.assert_contains_all(self.strIndex, secondCat.indexMap)
-        common.assert_contains_all(self.dateIndex, firstCat.indexMap)
-
-        # this is valid too
-        shifted = self.dateIndex + timedelta(1)
-
-    def test_add_string(self):
-        # from bug report
-        index = Index(['a', 'b', 'c'])
-        index2 = index + 'foo'
-
-        self.assert_('a' not in index2.indexMap)
-        self.assert_('afoo' in index2.indexMap)
-
     def test_shift(self):
         shifted = self.dateIndex.shift(0, timedelta(1))
         self.assert_(shifted is self.dateIndex)
@@ -183,6 +166,28 @@ class TestIndex(unittest.TestCase):
         # non-iterable input
         self.assertRaises(Exception, first.union, 0.5)
 
+    def test_add(self):
+        firstCat = self.strIndex + self.dateIndex
+        secondCat = self.strIndex + self.strIndex
+
+        self.assert_(common.equalContents(np.append(self.strIndex,
+                                                    self.dateIndex), firstCat))
+        self.assert_(common.equalContents(secondCat, self.strIndex))
+        common.assert_contains_all(self.strIndex, firstCat.indexMap)
+        common.assert_contains_all(self.strIndex, secondCat.indexMap)
+        common.assert_contains_all(self.dateIndex, firstCat.indexMap)
+
+        # this is valid too
+        shifted = self.dateIndex + timedelta(1)
+
+    def test_add_string(self):
+        # from bug report
+        index = Index(['a', 'b', 'c'])
+        index2 = index + 'foo'
+
+        self.assert_('a' not in index2.indexMap)
+        self.assert_('afoo' in index2.indexMap)
+
     def test_diff(self):
         first = self.strIndex[5:20]
         second = self.strIndex[:10]
@@ -210,12 +215,80 @@ class TestIndex(unittest.TestCase):
         testit(self.strIndex)
         testit(self.dateIndex)
 
+    # def test_always_get_null_index(self):
+    #     empty = Index([])
+    #     self.assert_(empty is NULL_INDEX)
+    #     self.assert_(self.dateIndex[15:15] is NULL_INDEX)
+
+    def test_is_all_dates(self):
+        self.assert_(self.dateIndex.is_all_dates())
+        self.assert_(not self.strIndex.is_all_dates())
+        self.assert_(not self.intIndex.is_all_dates())
+
+    def test_summary(self):
+        self._check_method_works(Index.summary)
+
+    def test_format(self):
+        self._check_method_works(Index.format)
+
+        index = Index([datetime.now()])
+        formatted = index.format()
+        expected = str(index[0])
+        self.assertEquals(formatted, expected)
+
+    def test_take(self):
+        indexer = [4, 3, 0, 2]
+        result = self.dateIndex.take(indexer)
+        expected = self.dateIndex[indexer]
+        self.assert_(result.equals(expected))
+
+    def _check_method_works(self, method):
+        method(self.empty)
+        method(self.dateIndex)
+        method(self.strIndex)
+        method(self.intIndex)
+        method(self.tuples)
+
+    def test_get_indexer(self):
+        idx1 = Index([1, 2, 3, 4, 5])
+        idx2 = Index([2, 4, 6])
+
+        r1, r2 = idx1.get_indexer(idx2)
+        assert_almost_equal(r1, [1, 3, -1])
+        assert_almost_equal(r2, [True, True, False])
+
+        r1, r2 = idx2.get_indexer(idx1, method='pad')
+        assert_almost_equal(r1, [-1, 0, 0, 1, 1])
+        assert_almost_equal(r2, [False, True, True, True, True])
+
+        rffill1, rffill2 = idx2.get_indexer(idx1, method='ffill')
+        assert_almost_equal(r1, rffill1)
+        assert_almost_equal(r2, rffill2)
+
+        r1, r2 = idx2.get_indexer(idx1, method='backfill')
+        assert_almost_equal(r1, [0, 0, 1, 1, 2])
+        assert_almost_equal(r2, [True, True, True, True, True])
+
+        rbfill1, rbfill2 = idx2.get_indexer(idx1, method='bfill')
+        assert_almost_equal(r1, rbfill1)
+        assert_almost_equal(r2, rbfill2)
+
+    def test_slice_locs(self):
+        idx = Index([0, 1, 2, 5, 6, 7, 9, 10])
+        n = len(idx)
+
+        self.assertEquals(idx.slice_locs(start=2), (2, n))
+        self.assertEquals(idx.slice_locs(start=3), (3, n))
+        self.assertEquals(idx.slice_locs(3, 8), (3, 6))
+        self.assertEquals(idx.slice_locs(5, 10), (3, n))
+        self.assertEquals(idx.slice_locs(end=8), (0, 6))
+        self.assertEquals(idx.slice_locs(end=9), (0, 7))
 
 class TestMultiIndex(unittest.TestCase):
 
     def setUp(self):
-        major_axis = Index([1, 2, 3, 4])
-        minor_axis = Index([1, 2])
+        major_axis = Index(['foo', 'bar', 'baz', 'qux'])
+        minor_axis = Index(['one', 'two'])
 
         major_labels = np.array([0, 0, 1, 2, 3, 3])
         minor_labels = np.array([0, 1, 0, 1, 0, 1])
@@ -223,6 +296,53 @@ class TestMultiIndex(unittest.TestCase):
         self.index = MultiIndex(levels=[major_axis, minor_axis],
                                 labels=[major_labels, minor_labels])
 
+    def test_from_arrays(self):
+        arrays = []
+        for lev, lab in zip(self.index.levels, self.index.labels):
+            arrays.append(np.asarray(lev).take(lab))
+
+        result = MultiIndex.from_arrays(*arrays)
+        self.assertEquals(list(result), list(self.index))
+
+    def test_nlevels(self):
+        self.assertEquals(self.index.nlevels, 2)
+
+    def test_iter(self):
+        result = list(self.index)
+        expected = [('foo', 'one'), ('foo', 'two'), ('bar', 'one'),
+                    ('baz', 'two'), ('qux', 'one'), ('qux', 'two')]
+        self.assert_(result == expected)
+
+    def test_pickle(self):
+        import pickle
+        pickled = pickle.dumps(self.index)
+        unpickled = pickle.loads(pickled)
+        self.assert_(self.index.equals(unpickled))
+
+    def test_contains(self):
+        self.assert_(('foo', 'two') in self.index)
+        self.assert_(('bar', 'two') not in self.index)
+        self.assert_(None not in self.index)
+
+    def test_is_all_dates(self):
+        self.assert_(not self.index.is_all_dates())
+
+    def test_getitem(self):
+        # scalar
+        self.assertEquals(self.index[2], ('bar', 'one'))
+
+        # slice
+        result = self.index[2:5]
+        expected = self.index[[2,3,4]]
+        self.assert_(result.equals(expected))
+
+        # boolean
+        result = self.index[[True, False, True, False, True, True]]
+        result2 = self.index[np.array([True, False, True, False, True, True])]
+        expected = self.index[[0, 2, 4, 5]]
+        self.assert_(result.equals(expected))
+        self.assert_(result2.equals(expected))
+
     def test_consistency(self):
         # need to construct an overflow
         major_axis = range(70000)
@@ -244,15 +364,24 @@ class TestMultiIndex(unittest.TestCase):
         self.assertRaises(Exception, getattr, index, 'indexMap')
 
     def test_truncate(self):
-        result = self.index.truncate(before=1)
-        self.assert_(0 not in result.levels[0])
+        major_axis = Index(range(4))
+        minor_axis = Index(range(2))
+
+        major_labels = np.array([0, 0, 1, 2, 3, 3])
+        minor_labels = np.array([0, 1, 0, 1, 0, 1])
+
+        index = MultiIndex(levels=[major_axis, minor_axis],
+                           labels=[major_labels, minor_labels])
+
+        result = index.truncate(before=1)
+        self.assert_('foo' not in result.levels[0])
         self.assert_(1 in result.levels[0])
 
-        result = self.index.truncate(after=1)
+        result = index.truncate(after=1)
         self.assert_(2 not in result.levels[0])
         self.assert_(1 in result.levels[0])
 
-        result = self.index.truncate(before=1, after=2)
+        result = index.truncate(before=1, after=2)
         self.assertEqual(len(result.levels[0]), 2)
 
     def test_getMajorBounds(self):
@@ -311,6 +440,7 @@ class TestFactor(unittest.TestCase):
 
 if __name__ == '__main__':
     import nose
-    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure',#]
+                         '--with-coverage', '--cover-package=pandas.core'],
                    exit=False)
 
diff --git a/test.sh b/test.sh
index b92e3fd54..9e2d06d3b 100755
--- a/test.sh
+++ b/test.sh
@@ -1,6 +1,7 @@
 #!/bin/sh
 coverage erase
-nosetests -w pandas --with-coverage --cover-package=pandas --pdb-failure --pdb
+nosetests pandas/tests/test_index.py --with-coverage --cover-package=pandas.core --pdb-failure --pdb #--cover-inclusive
+# nosetests -w pandas --with-coverage --cover-package=pandas --pdb-failure --pdb #--cover-inclusive
 # nosetests -w pandas/io --with-coverage --cover-package=pandas.io --pdb-failure --pdb
 # nosetests -w pandas/core --with-coverage --cover-package=pandas.core --pdb-failure --pdb
 # nosetests -w pandas/stats --with-coverage --cover-package=pandas.stats

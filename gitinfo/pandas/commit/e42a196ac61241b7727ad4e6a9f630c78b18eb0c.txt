commit e42a196ac61241b7727ad4e6a9f630c78b18eb0c
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Nov 23 08:04:46 2015 -0500

    BUG: Bug in rounding of negative Timedeltas

diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index 926e191c9..fb7abe38c 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -57,7 +57,7 @@ Backwards incompatible API changes
 Other API Changes
 ^^^^^^^^^^^^^^^^^
 
-
+- ``Timedelta.resolution`` will now return proper offset frequency strings
 
 
 
@@ -107,5 +107,5 @@ Bug Fixes
 ~~~~~~~~~
 
 
-
+- Bug in ``Timedelta.round`` with negative values (:issue:``)
 - Bug in ``.loc`` against ``CategoricalIndex`` may result in normal ``Index`` (:issue:`11586`)
diff --git a/pandas/tseries/tdi.py b/pandas/tseries/tdi.py
index 89229fc48..94f16f9ef 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/tseries/tdi.py
@@ -24,16 +24,6 @@ import pandas.index as _index
 
 Timedelta = tslib.Timedelta
 
-_resolution_map = {
-    'ns' : offsets.Nano,
-    'us' : offsets.Micro,
-    'ms' : offsets.Milli,
-    's'  : offsets.Second,
-    'm'  : offsets.Minute,
-    'h'  : offsets.Hour,
-    'D'  : offsets.Day,
-    }
-
 def _td_index_cmp(opname, nat_result=False):
     """
     Wrap comparison operations to convert timedelta-like to timedelta64
@@ -706,7 +696,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
             if side == 'left':
                 return lbound
             else:
-                return (lbound + _resolution_map[parsed.resolution]() -
+                return (lbound + to_offset(parsed.resolution) -
                         Timedelta(1, 'ns'))
         elif is_integer(label) or is_float(label):
             self._invalid_indexer('slice',label)
@@ -734,9 +724,8 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
 
         # figure out the resolution of the passed td
         # and round to it
-        reso = parsed.resolution
         t1 = parsed.round(reso)
-        t2 = t1 + _resolution_map[reso]() - Timedelta(1,'ns')
+        t2 = t1 + to_offset(parsed.resolution) - Timedelta(1,'ns')
 
         stamps = self.asi8
 
diff --git a/pandas/tseries/tests/test_timedeltas.py b/pandas/tseries/tests/test_timedeltas.py
index 45b98b0f8..642e01970 100644
--- a/pandas/tseries/tests/test_timedeltas.py
+++ b/pandas/tseries/tests/test_timedeltas.py
@@ -164,6 +164,23 @@ class TestTimedeltas(tm.TestCase):
         self.assertEqual(Timedelta(pd.offsets.Hour(2)),Timedelta('0 days, 02:00:00'))
         self.assertEqual(Timedelta(pd.offsets.Second(2)),Timedelta('0 days, 00:00:02'))
 
+    def test_round(self):
+
+        t1 = Timedelta('1 days 02:34:56.789123456')
+        t2 = Timedelta('-1 days 02:34:56.789123456')
+
+        for (reso, s1, s2) in [('N', t1, t2),
+                               ('U', Timedelta('1 days 02:34:56.789123000'),Timedelta('-1 days 02:34:56.789123000')),
+                               ('L', Timedelta('1 days 02:34:56.789000000'),Timedelta('-1 days 02:34:56.789000000')),
+                               ('S',  Timedelta('1 days 02:34:56'),Timedelta('-1 days 02:34:56')),
+                               ('T',  Timedelta('1 days 02:34:00'),Timedelta('-1 days 02:34:00')),
+                               ('H',  Timedelta('1 days 02:00:00'),Timedelta('-1 days 02:00:00')),
+                               ('d',  Timedelta('1 days'),Timedelta('-1 days'))]:
+            r1 = t1.round(reso)
+            self.assertEqual(r1, s1)
+            r2 = t2.round(reso)
+            self.assertEqual(r2, s2)
+
     def test_repr(self):
 
         self.assertEqual(repr(Timedelta(10,unit='d')),"Timedelta('10 days 00:00:00')")
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 713cf08bf..1de0eee77 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -2301,52 +2301,34 @@ class Timedelta(_Timedelta):
 
         self._ensure_components()
         if self._ns:
-           return "ns"
+           return "N"
         elif self._us:
-           return "us"
+           return "U"
         elif self._ms:
-           return "ms"
+           return "L"
         elif self._s:
-           return "s"
+           return "S"
         elif self._m:
-           return "m"
+           return "T"
         elif self._h:
-           return "h"
+           return "H"
         else:
            return "D"
 
-    def round(self, reso):
+    def round(self, freq):
         """
         return a new Timedelta rounded to this resolution
 
         Parameters
         ----------
-        reso : a string indicating the rouding resolution, accepting values
-           d,h,m,s,ms,us
-
+        freq : a freq string indicating the rouding resolution
         """
-        cdef int64_t frac, value = np.abs(self.value)
-
-        self._ensure_components()
-        frac = int(self._ms*1e6 + self._us*1e3+ self._ns)
-        if reso == 'us':
-           value -= self._ns
-        elif reso == 'ms':
-           value -= self._us*1000 + self._ns
-        elif reso == 's':
-           value -= frac
-        elif reso == 'm':
-           value -= int(self._s*1e9) + frac
-        elif reso == 'h':
-           value -= int((60*self._m + self._s)*1e9) + frac
-        elif reso == 'd' or reso == 'D':
-           value -= int((3600*self._h + 60*self._m + self._s)*1e9) + frac
-        else:
-           raise ValueError("invalid resolution")
+        cdef int64_t result, unit
 
-        if self._sign < 0:
-           value *= -1
-        return Timedelta(value,unit='ns')
+        from pandas.tseries.frequencies import to_offset
+        unit = to_offset(freq).nanos
+        result = unit*np.floor(self.value/unit)
+        return Timedelta(result,unit='ns')
 
     def _repr_base(self, format=None):
         """

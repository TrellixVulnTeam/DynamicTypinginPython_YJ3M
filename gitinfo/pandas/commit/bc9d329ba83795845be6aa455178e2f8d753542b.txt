commit bc9d329ba83795845be6aa455178e2f8d753542b
Author: Alex Kirko <alexander.kirko@gmail.com>
Date:   Wed Jan 15 19:32:36 2020 +0300

    BUG: Fix Timestamp constructor changes value on ambiguous DST (#30995)
    
    * BUG: fix Timestamp constructor value change on DST Timestamp
    
    * BUG: expand if check for Linux
    
    * CLN: switch from isinstance to treat_tz_asdateutil
    
    * CLN: add comment to solution and move to v1.1.0
    
    * DOC: reword bugfix comment

diff --git a/doc/source/whatsnew/v1.1.0.rst b/doc/source/whatsnew/v1.1.0.rst
index 721bcb075..b5a7b19f1 100644
--- a/doc/source/whatsnew/v1.1.0.rst
+++ b/doc/source/whatsnew/v1.1.0.rst
@@ -59,6 +59,7 @@ Categorical
 
 Datetimelike
 ^^^^^^^^^^^^
+- Bug in :class:`Timestamp` where constructing :class:`Timestamp` from ambiguous epoch time and calling constructor again changed :meth:`Timestamp.value` property (:issue:`24329`)
 -
 -
 
diff --git a/pandas/_libs/tslibs/conversion.pyx b/pandas/_libs/tslibs/conversion.pyx
index c8d354328..77f46016e 100644
--- a/pandas/_libs/tslibs/conversion.pyx
+++ b/pandas/_libs/tslibs/conversion.pyx
@@ -29,7 +29,7 @@ from pandas._libs.tslibs.util cimport (
 from pandas._libs.tslibs.timedeltas cimport cast_from_unit
 from pandas._libs.tslibs.timezones cimport (
     is_utc, is_tzlocal, is_fixed_offset, get_utcoffset, get_dst_info,
-    get_timezone, maybe_get_tz, tz_compare)
+    get_timezone, maybe_get_tz, tz_compare, treat_tz_as_dateutil)
 from pandas._libs.tslibs.timezones import UTC
 from pandas._libs.tslibs.parsing import parse_datetime_string
 
@@ -362,6 +362,14 @@ cdef _TSObject convert_datetime_to_tsobject(datetime ts, object tz,
             obj.tzinfo = tz
     else:
         obj.value = pydatetime_to_dt64(ts, &obj.dts)
+        # GH 24329 When datetime is ambiguous,
+        # pydatetime_to_dt64 doesn't take DST into account
+        # but with dateutil timezone, get_utcoffset does
+        # so we need to correct for it
+        if treat_tz_as_dateutil(ts.tzinfo):
+            if ts.tzinfo.is_ambiguous(ts):
+                dst_offset = ts.tzinfo.dst(ts)
+                obj.value += int(dst_offset.total_seconds() * 1e9)
         obj.tzinfo = ts.tzinfo
 
     if obj.tzinfo is not None and not is_utc(obj.tzinfo):
diff --git a/pandas/tests/indexes/datetimes/test_timezones.py b/pandas/tests/indexes/datetimes/test_timezones.py
index 1505ac1df..df6482077 100644
--- a/pandas/tests/indexes/datetimes/test_timezones.py
+++ b/pandas/tests/indexes/datetimes/test_timezones.py
@@ -573,13 +573,7 @@ class TestDatetimeIndexTimezones:
             "2013-10-26 23:00", "2013-10-27 01:00", freq="H", tz=tz, ambiguous="infer"
         )
         assert times[0] == Timestamp("2013-10-26 23:00", tz=tz, freq="H")
-
-        if str(tz).startswith("dateutil"):
-            # fixed ambiguous behavior
-            # see GH#14621
-            assert times[-1] == Timestamp("2013-10-27 01:00:00+0100", tz=tz, freq="H")
-        else:
-            assert times[-1] == Timestamp("2013-10-27 01:00:00+0000", tz=tz, freq="H")
+        assert times[-1] == Timestamp("2013-10-27 01:00:00+0000", tz=tz, freq="H")
 
     @pytest.mark.parametrize(
         "tz, option, expected",
diff --git a/pandas/tests/scalar/timestamp/test_timestamp.py b/pandas/tests/scalar/timestamp/test_timestamp.py
index f1fcf46a9..c60406fdb 100644
--- a/pandas/tests/scalar/timestamp/test_timestamp.py
+++ b/pandas/tests/scalar/timestamp/test_timestamp.py
@@ -1081,3 +1081,14 @@ def test_dt_subclass_add_timedelta(lh, rh):
     result = lh + rh
     expected = SubDatetime(2000, 1, 1, 1)
     assert result == expected
+
+
+def test_constructor_ambigous_dst():
+    # GH 24329
+    # Make sure that calling Timestamp constructor
+    # on Timestamp created from ambiguous time
+    # doesn't change Timestamp.value
+    ts = Timestamp(1382835600000000000, tz="dateutil/Europe/London")
+    expected = ts.value
+    result = Timestamp(ts).value
+    assert result == expected

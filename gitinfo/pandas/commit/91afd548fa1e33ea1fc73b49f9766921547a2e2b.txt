commit 91afd548fa1e33ea1fc73b49f9766921547a2e2b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jun 21 12:45:44 2012 -0400

    BUG: minimal out of bounds checking on future/past timestamps, gotcha docs, pre-1900 repr

diff --git a/doc/source/gotchas.rst b/doc/source/gotchas.rst
index 57d6471a8..f4c0eae4c 100644
--- a/doc/source/gotchas.rst
+++ b/doc/source/gotchas.rst
@@ -217,3 +217,27 @@ passed in the index, thus finding the integers ``0`` and ``1``. While it would
 be possible to insert some logic to check whether a passed sequence is all
 contained in the index, that logic would exact a very high cost in large data
 sets.
+
+Timestamp limitations
+---------------------
+
+Minimum and maximum timestamps
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Since pandas represents timestamps in nanosecond resolution, the timespan that
+can be represented using a 64-bit integer is limited to approximately 584 years:
+
+.. ipython:: python
+
+   begin = Timestamp(-9223285636854775809L)
+   begin
+   end = Timestamp(np.iinfo(np.int64).max)
+   end
+
+If you need to represent time series data outside the nanosecond timespan, use
+PeriodIndex:
+
+.. ipython:: python
+
+   span = period_range('1215-01-01', '1381-01-01', freq='D')
+   span
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index ec50275cc..38adf4628 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -65,6 +65,7 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None):
     return result
 
 
+
 # Python front end to C extension type _Timestamp
 # This serves as the box for datetime64
 class Timestamp(_Timestamp):
@@ -101,10 +102,27 @@ class Timestamp(_Timestamp):
         return ts_base
 
     def __repr__(self):
-        result = self.strftime('<Timestamp: %Y-%m-%d %H:%M:%S%z')
-        if self.tzinfo:
-            result += self.strftime(' %%Z, tz=%s' % self.tzinfo.zone)
-        return result + '>'
+        result = '%d-%.2d-%.2d %.2d:%.2d:%.2d' % (self.year, self.month,
+                                                  self.day, self.hour,
+                                                  self.minute, self.second)
+
+        if self.nanosecond != 0:
+            nanos = self.nanosecond + 1000 * self.microsecond
+            result += '.%.9d' % nanos
+        elif self.microsecond != 0:
+            result += '.%.6d' % self.microsecond
+
+        try:
+            result += self.strftime('%z')
+            if self.tzinfo:
+                result += self.strftime(' %%Z, tz=%s' % self.tzinfo.zone)
+        except ValueError:
+            year2000 = self.replace(year=2000)
+            result += year2000.strftime('%z')
+            if self.tzinfo:
+                result += year2000.strftime(' %%Z, tz=%s' % self.tzinfo.zone)
+
+        return '<Timestamp: %s>' % result
 
     @property
     def tz(self):
@@ -507,6 +525,7 @@ cpdef convert_to_tsobject(object ts, object tz=None):
             obj.tzinfo = ts.tzinfo
             if obj.tzinfo is not None:
                 obj.value -= _delta_to_nanoseconds(obj.tzinfo._utcoffset)
+        _check_dts_bounds(obj.value, &obj.dts)
         return obj
     elif PyDate_Check(ts):
         obj.value  = _date_to_datetime64(ts, &obj.dts)
@@ -514,6 +533,9 @@ cpdef convert_to_tsobject(object ts, object tz=None):
         raise ValueError("Could not construct Timestamp from argument %s" %
                          type(ts))
 
+    if obj.value != NPY_NAT:
+        _check_dts_bounds(obj.value, &obj.dts)
+
     if tz is not None:
         if tz is pytz.utc:
             obj.tzinfo = tz
@@ -530,6 +552,16 @@ cpdef convert_to_tsobject(object ts, object tz=None):
 
     return obj
 
+cdef int64_t _NS_LOWER_BOUND = -9223285636854775809LL
+cdef int64_t _NS_UPPER_BOUND = -9223372036854775807LL
+
+cdef inline _check_dts_bounds(int64_t value, pandas_datetimestruct *dts):
+    cdef pandas_datetimestruct dts2
+    if dts.year <= 1677 or dts.year >= 2262:
+        pandas_datetime_to_datetimestruct(value, PANDAS_FR_ns, &dts2)
+        if dts2.year != dts.year:
+            raise ValueError('Out of bounds timestamp in year: %s' % dts.year)
+
 # elif isinstance(ts, _Timestamp):
 #     tmp = ts
 #     obj.value = (<_Timestamp> ts).value
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 06fc71c2c..9c6542d4c 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -898,6 +898,20 @@ class TestTimeSeries(unittest.TestCase):
         self.assertEqual(idx.freq, Timestamp(idx[0], idx.freq).freq)
         self.assertEqual(idx.freqstr, Timestamp(idx[0], idx.freq).freqstr)
 
+    def test_timestamp_date_out_of_range(self):
+        self.assertRaises(ValueError, Timestamp, '1676-01-01')
+        self.assertRaises(ValueError, Timestamp, '2263-01-01')
+
+    def test_timestamp_repr(self):
+        # pre-1900
+        stamp = Timestamp('1850-01-01', tz='US/Eastern')
+        repr(stamp)
+
+        iso8601 = '1850-01-01 01:23:45.012345'
+        stamp = Timestamp(iso8601, tz='US/Eastern')
+        result = repr(stamp)
+        self.assert_(iso8601 in result)
+
     def test_datetimeindex_integers_shift(self):
         rng = date_range('1/1/2000', periods=20)
 
@@ -918,7 +932,6 @@ class TestTimeSeries(unittest.TestCase):
 
         self.assert_(np.array_equal(casted, exp_values))
 
-
     def test_catch_infinite_loop(self):
         offset = datetools.DateOffset(minute=5)
         # blow up, don't loop forever

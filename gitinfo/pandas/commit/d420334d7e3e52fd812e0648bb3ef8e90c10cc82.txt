commit d420334d7e3e52fd812e0648bb3ef8e90c10cc82
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jan 5 17:55:47 2012 -0500

    TST: test coverage and concat bugfix

diff --git a/RELEASE.rst b/RELEASE.rst
index 856837319..f431210c4 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -33,6 +33,8 @@ pandas 0.7.0
     relational-algebra operations. Refactored existing join methods to use the
     new infrastructure, resulting in substantial performance gains (GH #220,
     #249, #267)
+  - New ``concatenate`` function for concatenating DataFrame or Panel objects
+    along an axis. Can form union or intersection of the other axes
   - Handle differently-indexed output values in ``DataFrame.apply`` (GH #498)
   - Can pass list of dicts (e.g., a list of shallow JSON objects) to DataFrame
     constructor (GH #526)
@@ -49,6 +51,9 @@ pandas 0.7.0
   - Add attribute-based item access to ``Panel`` and add IPython completion (PR
     #554)
   - Add ``logy`` option to ``Series.plot`` for log-scaling on the Y axis
+  - Can pass multiple DataFrames to ``DataFrame.join`` to join on index (GH #115)
+  - Can pass multiple Panels to ``Panel.join`` (GH #115)
+  - Can pass multiple DataFrames to `DataFrame.append` to concatenate (stack)
 
 **API Changes**
 
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 47c4b679f..224e6473d 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -721,8 +721,6 @@ class Concatenator(object):
         all_values = []
         dtypes = set()
         for obj in self.objs:
-            if len(obj) == 0:
-                continue
             try:
                 values = obj._data.get(item)
                 dtypes.add(values.dtype)
@@ -785,17 +783,6 @@ class Concatenator(object):
 
         return new_axes
 
-    def _get_obj_constructor(self):
-        # SparseDataFrame causes us some headache here
-
-        # check that there's only one type present
-        obj_types = set(type(df) for df in self.objs)
-        if len(obj_types) > 1:
-            raise Exception('Can only concatenate like-typed objects, found %s'
-                            % obj_types)
-
-        return self.objs[0]._constructor
-
     def _maybe_check_integrity(self, concat_index):
         if self.verify_integrity:
             if not concat_index._verify_integrity():
@@ -803,9 +790,6 @@ class Concatenator(object):
                 raise Exception('Indexes have overlapping values: %s'
                                 % str(overlap))
 
-    @cache_readonly
-    def _all_indexes_same(self):
-        return _all_indexes_same([df.columns for df in self.objs])
 
 def _concat_frames_hierarchical(frames, keys, groupings, axis=0):
     names = [ping.name for ping in groupings]
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index adb3f4b2f..76e9aa3f8 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -6,7 +6,7 @@ import numpy as np
 import random
 
 from pandas import *
-from pandas.tools.merge import merge
+from pandas.tools.merge import merge, concat
 from pandas.util.testing import (assert_frame_equal, assert_series_equal,
                                  assert_almost_equal, rands)
 import pandas._tseries as lib
@@ -741,6 +741,40 @@ class TestConcatenate(unittest.TestCase):
         self.assert_(appended['A'].dtype == 'f8')
         self.assert_(appended['B'].dtype == 'O')
 
+    def test_crossed_dtypes_weird_corner(self):
+        columns = ['A', 'B', 'C', 'D']
+        df1 = DataFrame({'A' : np.array([1, 2, 3, 4], dtype='f8'),
+                         'B' : np.array([1, 2, 3, 4], dtype='i8'),
+                         'C' : np.array([1, 2, 3, 4], dtype='f8'),
+                         'D' : np.array([1, 2, 3, 4], dtype='i8')},
+                        columns=columns)
+
+        df2 = DataFrame({'A' : np.array([1, 2, 3, 4], dtype='i8'),
+                         'B' : np.array([1, 2, 3, 4], dtype='f8'),
+                         'C' : np.array([1, 2, 3, 4], dtype='i8'),
+                         'D' : np.array([1, 2, 3, 4], dtype='f8')},
+                        columns=columns)
+
+        appended = df1.append(df2, ignore_index=True)
+        expected = DataFrame(np.concatenate([df1.values, df2.values], axis=0),
+                             columns=columns)
+        tm.assert_frame_equal(appended, expected)
+
+    def test_handle_empty_objects(self):
+        df = DataFrame(np.random.randn(10, 4), columns=list('abcd'))
+
+        baz = df[:5]
+        baz['foo'] = 'bar'
+        empty = df[5:5]
+
+        frames = [baz, empty, empty, df[5:]]
+        concatted = concat(frames, axis=0)
+
+        expected = df.ix[:, ['a', 'b', 'c', 'd', 'foo']]
+        expected['foo'] = expected['foo'].astype('O')
+        expected['foo'][:5] = 'bar'
+
+        tm.assert_frame_equal(concatted, expected)
 
     def test_panel_join(self):
         panel = tm.makePanel()
@@ -800,10 +834,23 @@ class TestConcatenate(unittest.TestCase):
         joined = panels[0].join(panels[1:])
         tm.assert_panel_equal(joined, panel)
 
+        panels = [panel.ix[:2, :-5], panel.ix[2:6, 2:], panel.ix[6:, 5:-7]]
+
+        data_dict = {}
+        for p in panels:
+            data_dict.update(p.iterkv())
+
+        joined = panels[0].join(panels[1:], how='inner')
+        expected = Panel.from_dict(data_dict, intersect=True)
+        tm.assert_panel_equal(joined, expected)
+
+        joined = panels[0].join(panels[1:], how='outer')
+        expected = Panel.from_dict(data_dict, intersect=False)
+        tm.assert_panel_equal(joined, expected)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
 
 
-

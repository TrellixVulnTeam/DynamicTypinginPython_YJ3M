commit 510afa70bc3513e64848ad9cbd21c2acbc0f6459
Author: Tom Augspurger <TomAugspurger@users.noreply.github.com>
Date:   Sat Jan 5 06:35:10 2019 -0600

    CLN: Remove _eadata (#24625)
    
    * remove eadata

diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 082a314fa..5a8809f75 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -73,34 +73,30 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         DatetimeLikeArrayMixin._maybe_mask_results)
     __iter__ = ea_passthrough(DatetimeLikeArrayMixin.__iter__)
 
-    @property
-    def _eadata(self):
-        return self._data
-
     @property
     def freq(self):
         """
         Return the frequency object if it is set, otherwise None.
         """
-        return self._eadata.freq
+        return self._data.freq
 
     @freq.setter
     def freq(self, value):
-        # validation is handled by _eadata setter
-        self._eadata.freq = value
+        # validation is handled by _data setter
+        self._data.freq = value
 
     @property
     def freqstr(self):
         """
         Return the frequency object as a string if it is set, otherwise None.
         """
-        return self._eadata.freqstr
+        return self._data.freqstr
 
     def unique(self, level=None):
         if level is not None:
             self._validate_index_level(level)
 
-        result = self._eadata.unique()
+        result = self._data.unique()
 
         # Note: if `self` is already unique, then self.unique() should share
         #  a `freq` with self.  If not already unique, then self.freq must be
@@ -113,7 +109,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         Create a comparison method that dispatches to ``cls.values``.
         """
         def wrapper(self, other):
-            result = op(self._eadata, maybe_unwrap_index(other))
+            result = op(self._data, maybe_unwrap_index(other))
             return result
 
         wrapper.__doc__ = op.__doc__
@@ -122,7 +118,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
 
     @property
     def _ndarray_values(self):
-        return self._eadata._ndarray_values
+        return self._data._ndarray_values
 
     # ------------------------------------------------------------------------
     # Abstract data attributes
@@ -131,12 +127,12 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
     def values(self):
         # type: () -> np.ndarray
         # Note: PeriodArray overrides this to return an ndarray of objects.
-        return self._eadata._data
+        return self._data._data
 
     @property
     @Appender(DatetimeLikeArrayMixin.asi8.__doc__)
     def asi8(self):
-        return self._eadata.asi8
+        return self._data.asi8
 
     # ------------------------------------------------------------------------
 
@@ -485,7 +481,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
 
         def __add__(self, other):
             # dispatch to ExtensionArray implementation
-            result = self._eadata.__add__(maybe_unwrap_index(other))
+            result = self._data.__add__(maybe_unwrap_index(other))
             return wrap_arithmetic_op(self, other, result)
 
         cls.__add__ = __add__
@@ -497,13 +493,13 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
 
         def __sub__(self, other):
             # dispatch to ExtensionArray implementation
-            result = self._eadata.__sub__(maybe_unwrap_index(other))
+            result = self._data.__sub__(maybe_unwrap_index(other))
             return wrap_arithmetic_op(self, other, result)
 
         cls.__sub__ = __sub__
 
         def __rsub__(self, other):
-            result = self._eadata.__rsub__(maybe_unwrap_index(other))
+            result = self._data.__rsub__(maybe_unwrap_index(other))
             return wrap_arithmetic_op(self, other, result)
 
         cls.__rsub__ = __rsub__
@@ -534,7 +530,6 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         nv.validate_repeat(tuple(), dict(axis=axis))
         freq = self.freq if is_period_dtype(self) else None
         return self._shallow_copy(self.asi8.repeat(repeats), freq=freq)
-        # TODO: dispatch to _eadata
 
     @Appender(_index_shared_docs['where'] % _index_doc_kwargs)
     def where(self, cond, other=None):
@@ -599,10 +594,10 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
             # Ensure that self.astype(self.dtype) is self
             return self
 
-        new_values = self._eadata.astype(dtype, copy=copy)
+        new_values = self._data.astype(dtype, copy=copy)
 
         # pass copy=False because any copying will be done in the
-        #  _eadata.astype call above
+        #  _data.astype call above
         return Index(new_values,
                      dtype=new_values.dtype, name=self.name, copy=False)
 
@@ -637,7 +632,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         Index.shift : Shift values of Index.
         PeriodIndex.shift : Shift values of PeriodIndex.
         """
-        result = self._eadata._time_shift(periods, freq=freq)
+        result = self._data._time_shift(periods, freq=freq)
         return type(self)(result, name=self.name)
 
 
@@ -675,9 +670,6 @@ def maybe_unwrap_index(obj):
     unwrapped object
     """
     if isinstance(obj, ABCIndexClass):
-        if isinstance(obj, DatetimeIndexOpsMixin):
-            # i.e. PeriodIndex/DatetimeIndex/TimedeltaIndex
-            return obj._eadata
         return obj._data
     return obj
 
@@ -712,16 +704,16 @@ class DatetimelikeDelegateMixin(PandasDelegate):
         raise AbstractMethodError
 
     def _delegate_property_get(self, name, *args, **kwargs):
-        result = getattr(self._eadata, name)
+        result = getattr(self._data, name)
         if name not in self._raw_properties:
             result = Index(result, name=self.name)
         return result
 
     def _delegate_property_set(self, name, value, *args, **kwargs):
-        setattr(self._eadata, name, value)
+        setattr(self._data, name, value)
 
     def _delegate_method(self, name, *args, **kwargs):
-        result = operator.methodcaller(name, *args, **kwargs)(self._eadata)
+        result = operator.methodcaller(name, *args, **kwargs)(self._data)
         if name not in self._raw_methods:
             result = Index(result, name=self.name)
         return result
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index f396f0812..0201827d2 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -341,12 +341,12 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
 
     @property
     def dtype(self):
-        return self._eadata.dtype
+        return self._data.dtype
 
     @property
     def tz(self):
         # GH 18595
-        return self._eadata.tz
+        return self._data.tz
 
     @tz.setter
     def tz(self, value):
@@ -475,7 +475,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
             if isinstance(result, DatetimeIndex):
                 # TODO: we shouldn't be setting attributes like this;
                 #  in all the tests this equality already holds
-                result._eadata._dtype = this.dtype
+                result._data._dtype = this.dtype
                 if (result.freq is None and
                         (this.freq is not None or other.freq is not None)):
                     result.freq = to_offset(result.inferred_freq)
@@ -508,7 +508,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
                 if isinstance(this, DatetimeIndex):
                     # TODO: we shouldn't be setting attributes like this;
                     #  in all the tests this equality already holds
-                    this._eadata._dtype = dtype
+                    this._data._dtype = dtype
         return this
 
     def _can_fast_union(self, other):
@@ -643,7 +643,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
     def _get_time_micros(self):
         values = self.asi8
         if self.tz is not None and not timezones.is_utc(self.tz):
-            values = self._eadata._local_timestamps()
+            values = self._data._local_timestamps()
         return fields.get_time_micros(values)
 
     def to_series(self, keep_tz=None, index=None, name=None):
@@ -1139,7 +1139,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
         self.freq = value
 
     def __getitem__(self, key):
-        result = self._eadata.__getitem__(key)
+        result = self._data.__getitem__(key)
         if is_scalar(result):
             return result
         elif result.ndim > 1:
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 9301638d4..b9d6b8da2 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -36,7 +36,7 @@ def _make_wrapped_arith_op(opname):
     meth = getattr(TimedeltaArray, opname)
 
     def method(self, other):
-        result = meth(self._eadata, maybe_unwrap_index(other))
+        result = meth(self._data, maybe_unwrap_index(other))
         return wrap_arithmetic_op(self, other, result)
 
     method.__name__ = opname
@@ -307,7 +307,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, dtl.TimelikeOps, Int64Index,
         return lambda x: Timedelta(x, unit='ns')
 
     def __getitem__(self, key):
-        result = self._eadata.__getitem__(key)
+        result = self._data.__getitem__(key)
         if is_scalar(result):
             return result
         return type(self)(result, name=self.name)
@@ -321,7 +321,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, dtl.TimelikeOps, Int64Index,
             # Have to repeat the check for 'timedelta64' (not ns) dtype
             #  so that we can return a numeric index, since pandas will return
             #  a TimedeltaIndex when dtype='timedelta'
-            result = self._eadata.astype(dtype, copy=copy)
+            result = self._data.astype(dtype, copy=copy)
             if self.hasnans:
                 return Index(result, name=self.name)
             return Index(result.astype('i8'), name=self.name)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index de34227cd..b94bd80a7 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -477,10 +477,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         Return the internal repr of this data.
         """
-        result = self._data.internal_values()
-        if isinstance(result, DatetimeIndex):
-            result = result._eadata
-        return result
+        return self._data.internal_values()
 
     def _formatting_values(self):
         """
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index 4474b06b1..c31d7acad 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -1475,7 +1475,7 @@ class TestTimedeltaArraylikeMulDivOps(object):
 
         tdi = TimedeltaIndex(['1 Day'] * 10)
         expected = timedelta_range('1 days', '10 days')
-        expected._eadata.freq = None
+        expected._data.freq = None
 
         tdi = tm.box_expected(tdi, box)
         expected = tm.box_expected(expected, xbox)
diff --git a/pandas/tests/arrays/test_datetimes.py b/pandas/tests/arrays/test_datetimes.py
index 8890593b1..6ec3b97bb 100644
--- a/pandas/tests/arrays/test_datetimes.py
+++ b/pandas/tests/arrays/test_datetimes.py
@@ -21,7 +21,7 @@ class TestDatetimeArrayConstructor(object):
 
         result = DatetimeArray._from_sequence(arr, freq='infer')
 
-        expected = pd.date_range('1970-01-01', periods=5, freq='H')._eadata
+        expected = pd.date_range('1970-01-01', periods=5, freq='H')._data
         tm.assert_datetime_array_equal(result, expected)
 
     def test_mismatched_timezone_raises(self):
diff --git a/pandas/tests/indexes/datetimes/test_astype.py b/pandas/tests/indexes/datetimes/test_astype.py
index 562be4cf8..c03b8afbe 100644
--- a/pandas/tests/indexes/datetimes/test_astype.py
+++ b/pandas/tests/indexes/datetimes/test_astype.py
@@ -318,8 +318,7 @@ class TestToPeriod(object):
                                         pd.Timestamp('2000-01-02', tz=tz)])
         tm.assert_index_equal(result, expected)
 
-        # TODO: use \._data following composition changeover
-        result = obj._eadata.astype('category')
+        result = obj._data.astype('category')
         expected = expected.values
         tm.assert_categorical_equal(result, expected)
 
diff --git a/pandas/tests/indexes/timedeltas/test_astype.py b/pandas/tests/indexes/timedeltas/test_astype.py
index 3f5507612..23e96dbc3 100644
--- a/pandas/tests/indexes/timedeltas/test_astype.py
+++ b/pandas/tests/indexes/timedeltas/test_astype.py
@@ -95,8 +95,7 @@ class TestTimedeltaIndex(object):
                                         pd.Timedelta('2H')])
         tm.assert_index_equal(result, expected)
 
-        # TODO: Use \._data following composition changeover
-        result = obj._eadata.astype('category')
+        result = obj._data.astype('category')
         expected = expected.values
         tm.assert_categorical_equal(result, expected)
 

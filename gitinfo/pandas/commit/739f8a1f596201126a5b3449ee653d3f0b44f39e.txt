commit 739f8a1f596201126a5b3449ee653d3f0b44f39e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jun 9 14:18:03 2011 -0400

    picklability, column reordering issues, more refactoring

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 1a33513e2..3f0e5de84 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1729,7 +1729,7 @@ class DataFrame(PandasGeneric):
 
             return result
 
-        indexer, mask = tseries.getMergeVec(self[on], other.index.indexMap)
+        indexer, mask = other.index.get_indexer(self[on])
         notmask = -mask
         need_mask = notmask.any()
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 24faaa8e5..ddf687a83 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -6,12 +6,8 @@ import numpy as np
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.common import _ensure_index
 from pandas.core.series import Series
-from pandas.util.decorators import cache_readonly
 import pandas.core.common as common
 
-def make_block(values, columns):
-    pass
-
 class Block(object):
     """
     Canonical unit of homogeneous dtype contained in DataMatrix
@@ -20,14 +16,18 @@ class Block(object):
     """
     def __init__(self, values, columns):
         values = _convert_if_1d(values)
+        if issubclass(values.dtype.type, basestring):
+            values = np.array(values, dtype=object)
+
         self.values = values
         self.columns = _ensure_index(columns)
         assert(len(self.columns) == values.shape[1])
 
     def __repr__(self):
         x, y = self.shape
-        return 'Block: %s, %d x %d, dtype %s' % (self.columns, x, y,
-                                                 self.dtype)
+        name = type(self).__name__
+        return '%s: %s, %d x %d, dtype %s' % (name, self.columns,
+                                              x, y, self.dtype)
 
     def __contains__(self, col):
         return col in self.columns
@@ -35,6 +35,15 @@ class Block(object):
     def __len__(self):
         return len(self.values)
 
+    def __getstate__(self):
+        return (np.asarray(self.columns),
+                self.values)
+
+    def __setstate__(self, state):
+        columns, values = state
+        self.columns = _ensure_index(columns)
+        self.values = values
+
     @property
     def shape(self):
         return self.values.shape
@@ -44,7 +53,7 @@ class Block(object):
         return self.values.dtype
 
     def copy(self):
-        return Block(self.values.copy(), self.columns)
+        return make_block(self.values.copy(), self.columns)
 
     def merge(self, other):
         return _merge_blocks([self, other])
@@ -55,27 +64,40 @@ class Block(object):
         """
         new_values = self.values.take(indexer, axis=0)
         if needs_masking:
-            if issubclass(new_values.dtype.type, np.int_):
-                new_values = new_values.astype(float)
-            elif issubclass(new_values.dtype.type, np.bool_):
-                new_values = new_values.astype(object)
+            new_values = _cast_if_bool_int(new_values)
             common.null_out_axis(new_values, notmask, 0)
-        return Block(new_values, self.columns)
+        return make_block(new_values, self.columns)
 
     def reindex_columns(self, new_columns):
+        """
+
+        """
         indexer, mask = self.columns.get_indexer(new_columns)
         new_values = self.values.take(indexer, axis=1)
 
         notmask = -mask
         if len(mask) > 0 and notmask.any():
-            if issubclass(new_values.dtype.type, np.int_):
-                new_values = new_values.astype(float)
-            elif issubclass(new_values.dtype.type, np.bool_):
-                new_values = new_values.astype(object)
-
+            new_values = _cast_if_bool_int(new_values)
             common.null_out_axis(new_values, notmask, 1)
 
-        return Block(new_values, new_columns)
+        return make_block(new_values, new_columns)
+
+    def reindex_columns_from(self, columns):
+        """
+        Reindex to only those columns contained in the input set of columns
+
+        E.g. if you have ['a', 'b'], and the input columns is ['b', 'c', 'd'],
+        then the resulting columns will be ['b']
+
+        Returns
+        -------
+        reindexed : Block
+        """
+        indexer, mask = self.columns.get_indexer(columns)
+        masked_idx = indexer[mask]
+        new_values = self.values.take(masked_idx, axis=1)
+        new_columns = self.columns.take(masked_idx)
+        return make_block(new_values, new_columns)
 
     def insert(self, col, value, loc=None):
         """
@@ -91,7 +113,7 @@ class Block(object):
 
         new_columns = _insert_into_columns(self.columns, col, loc)
         new_values = _insert_into_values(self.values, value, loc)
-        return Block(new_values, new_columns)
+        return make_block(new_values, new_columns)
 
     def get(self, col):
         loc = self.columns.get_loc(col)
@@ -117,7 +139,20 @@ class Block(object):
         loc = self.columns.get_loc(col)
         new_columns = _delete_from_columns(self.columns, loc)
         new_values = _delete_from_values(self.values, loc)
-        return Block(new_values, new_columns)
+        return make_block(new_values, new_columns)
+
+    def fillna(self, value):
+        new_values = self.values.copy()
+        mask = common.isnull(new_values.ravel())
+        new_values.flat[mask] = value
+        return make_block(new_values, self.columns)
+
+def _cast_if_bool_int(values):
+    if issubclass(values.dtype.type, np.int_):
+        values = values.astype(float)
+    elif issubclass(values.dtype.type, np.bool_):
+        values = values.astype(object)
+    return values
 
 def _insert_into_columns(columns, col, loc):
     columns = np.asarray(columns)
@@ -156,6 +191,21 @@ class BoolBlock(Block):
 class ObjectBlock(Block):
     pass
 
+def make_block(values, columns):
+    dtype = values.dtype
+    vtype = dtype.type
+
+    if issubclass(vtype, np.floating):
+        klass = FloatBlock
+    elif issubclass(vtype, np.integer):
+        klass = IntBlock
+    elif dtype == np.bool_:
+        klass = BoolBlock
+    else:
+        klass = ObjectBlock
+
+    return klass(values, columns)
+
 # TODO: flexible with index=None and/or columns=None
 
 class BlockManager(object):
@@ -175,6 +225,17 @@ class BlockManager(object):
         if not skip_integrity_check:
             self._verify_integrity()
 
+    def __getstate__(self):
+        return (np.asarray(self.index),
+                np.asarray(self.columns),
+                self.blocks)
+
+    def __setstate__(self, state):
+        index, columns, blocks = state
+        self.index = _ensure_index(index)
+        self.columns = _ensure_index(columns)
+        self.blocks = blocks
+
     def __repr__(self):
         output = 'BlockManager'
         for block in self.blocks:
@@ -190,7 +251,7 @@ class BlockManager(object):
     def cast(self, dtype):
         new_blocks = []
         for block in self.blocks:
-            newb = Block(block.values.astype(dtype), block.columns)
+            newb = make_block(block.values.astype(dtype), block.columns)
             new_blocks.append(newb)
 
         new_mgr = BlockManager(new_blocks, self.index, self.columns)
@@ -246,12 +307,18 @@ class BlockManager(object):
         return _interleave(self.blocks, columns)
 
     def xs(self, i, copy=True):
+        # TODO: fix this awful mess
+
         if len(self.blocks) > 1:
             if not copy:
                 raise Exception('cannot get view of mixed-type DataFrame')
-            xs = np.concatenate([b.values[i] for b in self.blocks])
+            vals = np.concatenate([b.values[i] for b in self.blocks])
+            cols = np.concatenate([b.columns for b in self.blocks])
+            xs = Series(vals, index=cols).reindex(self.columns)
         else:
-            xs = self.blocks[0].values[i]
+            vals = self.blocks[0].values[i]
+            cols = self.blocks[0].columns
+            xs = Series(vals, cols)
             if copy:
                 xs = xs.copy()
         return xs
@@ -316,7 +383,7 @@ class BlockManager(object):
 
     def _add_new_block(self, col, value):
         # Do we care about dtype at the moment?
-        new_block = Block(value, [col])
+        new_block = make_block(value, [col])
         self._push_new_block(new_block)
 
     def _find_block(self, col):
@@ -356,39 +423,58 @@ class BlockManager(object):
 
         return BlockManager(new_blocks, new_index, self.columns)
 
+    def merge(self, other):
+        # TODO
+        assert(self.index.equals(other.index))
+        consolidated = _consolidate(self.blocks + other.blocks)
+        cons_columns = _union_block_columns(self.blocks)
+        return BlockManager(consolidated, self.index, cons_columns)
+
+    def join_on(self, other, on):
+        reindexed = other.reindex(on)
+        reindexed.index = self.index
+        return self.merge(reindexed)
+
     def reindex_columns(self, new_columns):
-        # assert(isinstance(new_columns, Index))
+        """
+
+        """
         new_columns = _ensure_index(new_columns)
         data = self
         if not data.is_consolidated():
             data = data.consolidate()
             return data.reindex_columns(new_columns)
 
-        # will put these in the float bucket
-        extra_columns = new_columns - self.columns
-
         new_blocks = []
         for block in self.blocks:
-            new_cols = block.columns.intersection(new_columns)
-            if len(extra_columns) > 0 and block.dtype == np.float64:
-                new_cols = new_cols.union(extra_columns)
+            newb = block.reindex_columns_from(new_columns)
+            if len(newb.columns) > 0:
+                new_blocks.append(newb)
 
-            if len(new_cols) == 0:
-                continue
+        # will put these in the float bucket
+        extra_columns = new_columns - self.columns
+        if len(extra_columns):
+            # create new block, then consolidate
+            indexer, mask = extra_columns.get_indexer(new_columns)
 
-            newb = block.reindex_columns(new_cols)
-            new_blocks.append(newb)
+            # reorder to match relative order of new columns
+            extra_columns = extra_columns.take(indexer[mask])
 
-        dtypes = [x.dtype for x in self.blocks]
-        if len(extra_columns) > 0 and np.float64 not in dtypes:
-            raise Exception('deal with this later')
+            values = _nan_array(self.index, extra_columns)
+            newb = make_block(values, extra_columns)
+            new_blocks.append(newb)
+            new_blocks = _consolidate(new_blocks)
 
         return BlockManager(new_blocks, self.index, new_columns)
 
+    def fillna(self, value):
+        new_blocks = [b.fillna(value) for b in self.blocks]
+        return BlockManager(new_blocks, self.index, self.columns)
+
 def _slice_blocks(blocks, slice_obj):
     new_blocks = []
     for block in blocks:
-        newb = Block(block.values[slice_obj], block.columns)
+        newb = make_block(block.values[slice_obj], block.columns)
         new_blocks.append(newb)
     return new_blocks
 
@@ -473,7 +559,7 @@ def _consolidate(blocks):
 def _merge_blocks(blocks):
     new_values = np.hstack([b.values for b in blocks])
     new_columns = np.concatenate([b.columns for b in blocks])
-    new_block = Block(new_values, new_columns)
+    new_block = make_block(new_values, new_columns)
     return new_block
 
 def _xs(blocks, i, copy=True):
@@ -499,7 +585,7 @@ def _union_block_columns(blocks):
 def _nan_manager_matching(index, columns):
     # what if one of these is empty?
     values = _nan_array(index, columns)
-    block = Block(values, columns)
+    block = make_block(values, columns)
     return BlockManager([block], columns)
 
 def _nan_array(index, columns, dtype=np.float64):
@@ -537,8 +623,8 @@ if __name__ == '__main__':
     index = np.arange(n)
     new_columns = Index(['a', 'c', 'e', 'b', 'd'])
 
-    fblock = Block(floats, float_cols)
-    oblock = Block(objects, object_cols)
+    fblock = make_block(floats, float_cols)
+    oblock = make_block(objects, object_cols)
 
     blocks = [fblock, oblock]
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index dd56a1de0..bce2e4d81 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -122,29 +122,8 @@ class DataMatrix(DataFrame):
         if on not in self:
             raise Exception('%s column not contained in this frame!' % on)
 
-        fillVec, mask = tseries.getMergeVec(self[on],
-                                            other.index.indexMap)
-        notmask = -mask
-
-        tmpMatrix = other.values.take(fillVec, axis=0)
-        tmpMatrix[notmask] = nan
-
-        seriesDict = dict((col, tmpMatrix[:, j])
-                           for j, col in enumerate(other.columns))
-
-        if getattr(other, 'objects'):
-            objects = other.objects
-
-            tmpMat = objects.values.take(fillVec, axis=0)
-            tmpMat[notmask] = nan
-            objDict = dict((col, tmpMat[:, j])
-                           for j, col in enumerate(objects.columns))
-
-            seriesDict.update(objDict)
-
-        filledFrame = DataFrame(data=seriesDict, index=self.index)
-
-        return self.join(filledFrame, how='left')
+        new_data = self.data.join_on(other.data, self[on])
+        return DataMatrix(new_data)
 
     def _reindex_index(self, new_index, method):
         if new_index is self.index:
@@ -161,22 +140,6 @@ class DataMatrix(DataFrame):
         new_data = self._data.reindex_columns(new_columns)
         return DataMatrix(new_data)
 
-        # indexer, mask = self.columns.get_indexer(columns)
-        # mat = self.values.take(indexer, axis=1)
-
-        # notmask = -mask
-        # if len(mask) > 0:
-        #     if notmask.any():
-        #         if issubclass(mat.dtype.type, np.int_):
-        #             mat = mat.astype(float)
-        #         elif issubclass(mat.dtype.type, np.bool_):
-        #             mat = mat.astype(float)
-
-        #         common.null_out_axis(mat, notmask, 1)
-
-        # return DataMatrix(mat, index=self.index, columns=columns,
-        #                   objects=objects)
-
     def _rename_columns_inplace(self, mapper):
         self.columns = [mapper(x) for x in self.columns]
 
@@ -257,77 +220,32 @@ class DataMatrix(DataFrame):
 # "Magic methods"
 
     def __getstate__(self):
-        if self.objects is not None:
-            objects = self.objects._matrix_state(pickle_index=False)
-        else:
-            objects = None
-
-        state = self._matrix_state()
-
-        return (state, objects)
-
-    def _matrix_state(self, pickle_index=True):
-        columns = _pickle_array(self.columns)
-
-        if pickle_index:
-            index = _pickle_array(self.index)
-        else:
-            index = None
-
-        return self.values, index, columns
+        return self._data
 
     def __setstate__(self, state):
-        (vals, idx, cols), object_state = state
-
-        self.values = vals
-        self.index = _unpickle_array(idx)
-        self.columns = _unpickle_array(cols)
-
-        if object_state:
-            ovals, _, ocols = object_state
-            self.objects = DataMatrix(ovals,
-                                      index=self.index,
-                                      columns=_unpickle_array(ocols))
-        else:
-            self.objects = None
-
-    """
-    def __getstate__(self):
-        if self.objects is not None:
-            objects = self.objects._matrix_state(pickle_index=False)
-        else:
-            objects = None
+        if len(state) == 2:
+            # old pickling format, for compatibility
+            self._unpickle_compat(state)
+            return
 
-        state = self._matrix_state()
+        self._data = state
 
-        return (state, objects)
-
-    def _matrix_state(self, pickle_index=True):
-        columns = _pickle_array(self.columns)
-
-        if pickle_index:
-            index = _pickle_array(self.index)
-        else:
-            index = None
-
-        return self.values, index, columns
-
-    def __setstate__(self, state):
+    def _unpickle_compat(self, state): # pragma: no cover
+        # old unpickling
         (vals, idx, cols), object_state = state
 
-        self.values = vals
-        self.index = _unpickle_array(idx)
-        self.columns = _unpickle_array(cols)
+        index = _unpickle_array(idx)
+        dm = DataMatrix(vals, index=index,
+                        columns=_unpickle_array(cols))
 
-        if object_state:
+        if object_state is not None:
             ovals, _, ocols = object_state
-            self.objects = DataMatrix(ovals,
-                                      index=self.index,
-                                      columns=_unpickle_array(ocols))
-        else:
-            self.objects = None
+            objects = DataMatrix(ovals, index=index,
+                                 columns=_unpickle_array(ocols))
 
-    """
+            dm = dm.join(objects)
+
+        self._data = dm._data
 
     def __getitem__(self, item):
         """
@@ -601,23 +519,14 @@ class DataMatrix(DataFrame):
             series = self._series
             for col, s in series.iteritems():
                 result[col] = s.fillna(method=method, value=value)
-
-            return DataMatrix(result, index=self.index, objects=self.objects)
+            return DataMatrix(result, index=self.index)
         else:
             # Float type values
             if len(self.columns) == 0:
                 return self
 
-            vals = self.values.copy()
-            vals.flat[common.isnull(vals.ravel())] = value
-
-            objects = None
-
-            if self.objects is not None:
-                objects = self.objects.copy()
-
-            return DataMatrix(vals, index=self.index, columns=self.columns,
-                              objects=objects)
+            new_data = self._data.fillna(value)
+            return DataMatrix(new_data)
 
     def xs(self, key, copy=True):
         """
@@ -635,10 +544,8 @@ class DataMatrix(DataFrame):
             raise Exception('No cross-section for %s' % key)
 
         self._consolidate_inplace()
-
         loc = self.index.get_loc(key)
-        xs = self._data.xs(loc, copy=copy)
-        return Series(xs, index=self.columns)
+        return self._data.xs(loc, copy=copy)
 
     @property
     def T(self):
@@ -672,31 +579,28 @@ class DataMatrix(DataFrame):
         if timeRule is not None and offset is None:
             offset = datetools.getOffset(timeRule)
 
-        if offset is None:
-            indexer = self._shift_indexer(periods)
-            new_values = self.values.take(indexer, axis=0)
-            new_index = self.index
-
+        def _shift_block(blk, indexer):
+            new_values = blk.values.take(indexer, axis=0)
+            # convert integer to float if necessary. need to do a lot more than
+            # that, handle boolean etc also
             new_values = common.ensure_float(new_values)
-
             if periods > 0:
                 new_values[:periods] = nan
             else:
                 new_values[periods:] = nan
-        else:
-            new_index = self.index.shift(periods, offset)
-            new_values = self.values.copy()
+            return Block(new_values, blk.columns)
 
-        if self.objects is not None:
-            shifted_objects = self.objects.shift(periods, offset=offset,
-                                                 timeRule=timeRule)
-
-            shifted_objects.index = new_index
+        if offset is None:
+            indexer = self._shift_indexer(periods)
+            new_blocks = [_shift_block(b, indexer) for b in self._data.blocks]
+            new_data = BlockManager(new_blocks, self.index, self.columns)
+            new_index = self.index
         else:
-            shifted_objects = None
+            new_index = self.index.shift(periods, offset)
+            new_data = self._data.copy()
 
-        return DataMatrix(data=new_values, index=new_index,
-                          columns=self.columns, objects=shifted_objects)
+        return DataMatrix(data=new_data, index=new_index,
+                          columns=self.columns)
 
 _data_types = [np.float_, np.int_]
 
@@ -768,6 +672,7 @@ def _form_blocks(data, index, columns):
 
     blocks = []
 
+    # TODO: find corner cases
     # oof, this sucks
     fcolumns = extra_columns.union(float_dict.keys())
     if len(fcolumns) > 0:
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index ffa5aa4dd..53b95b584 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -352,6 +352,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(frame.columns is idx)
         self.assertEqual(len(frame._series), 3)
 
+    def test_constructor_mixed(self):
+        self.assertEqual(self.mixed_frame['foo'].dtype, np.object_)
+
     def test_constructor_dict_cast(self):
         # cast float tests
         test_data = {
@@ -837,8 +840,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(isinstance(dm, DataMatrix))
 
     def test_info(self):
-        self.frame.info()
-        self.tsframe.info()
+        io = StringIO()
+        self.frame.info(buf=io)
+        self.tsframe.info(buf=io)
 
     def test_rows(self):
         self.assert_(self.tsframe.rows() is self.tsframe.index)
@@ -1601,7 +1605,6 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         source = self.klass({'MergedA' : data['A'], 'MergedD' : data['D']},
                             index=data['C'])
         merged = target.join(source, on='C')
-
         self.assert_(np.array_equal(merged['MergedA'], target['A']))
         self.assert_(np.array_equal(merged['MergedD'], target['D']))
 
@@ -1849,4 +1852,4 @@ if __name__ == '__main__':
     #                exit=False)
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-    frame = self.klass({'col1' : self.ts1, 'col2' : self.ts2}, columns=['col2', 'col3', 'col4'])
+
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 922f08853..76394bf9b 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -271,13 +271,10 @@ class TestDataMatrix(test_frame.TestDataFrame):
         self.mixed_frame['foo'][5:20] = np.NaN
         self.mixed_frame['A'][-10:] = np.NaN
 
-        obj_result = self.mixed_frame.objects.fillna(value=0)
-
+        filled = self.mixed_frame.fillna(value=0)
+        self.assert_((filled['foo'][5:20] == 0).all())
         del self.mixed_frame['foo']
 
-        # XXX
-        obj_result = self.mixed_frame.objects.fillna(value=0)
-
 	empty_float = self.frame.reindex(columns=[])
         result = empty_float.fillna(value=0)
 

commit b4be34968dd5fb14181b20a979302998a76b9378
Author: Adam Klein <adamklein@gmail.com>
Date:   Thu Mar 8 21:48:34 2012 -0500

    ENH: fleshed out more of IntervalIndex

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 87d7a9a62..e2d704151 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -69,23 +69,6 @@ def _from_string_array(arr):
     data = p_ufunc(arr)
     return np.array(data, dtype='M8[us]')
 
-def _iv_unbox(key, check=None):
-    '''
-    Interval-like => int64
-    '''
-    if not isinstance(key, Interval):
-        key = Interval(key, freq=check)
-    elif check is not None:
-        if key.freq != check:
-            raise ValueError("%s is wrong freq" % key)
-    return np.int64(key.ordinal)
-
-def _iv_unbox_array(arr, check=None):
-    if arr is None:
-        return arr
-    unboxer = np.frompyfunc(lambda x: _iv_unbox(x, check=check), 1, 1)
-    return unboxer(arr)
-
 class Ts(lib.Timestamp):
     """
     Convenience class to expose cython-based Timestamp to user. This is the
@@ -104,6 +87,46 @@ class Ts(lib.Timestamp):
 #-------
 # Interval sketching
 
+def _skts_unbox(key, check=None):
+    '''
+    Interval-like => int64
+    '''
+    if not isinstance(key, Interval):
+        key = Interval(key, freq=check)
+    elif check is not None:
+        if key.freq != check:
+            raise ValueError("%s is wrong freq" % key)
+    return np.int64(key.ordinal)
+
+def _skts_unbox_array(arr, check=None):
+    if arr is None:
+        return arr
+    unboxer = np.frompyfunc(lambda x: _skts_unbox(x, check=check), 1, 1)
+    return unboxer(arr)
+
+def _skts_box(val, freq):
+    return Interval(val, freq=freq)
+
+def _skts_box_array(arr, freq):
+    if arr is None:
+        return arr
+
+    if not isinstance(arr, np.ndarray):
+        return arr
+
+    boxfunc = lambda x: _skts_box(x, freq)
+    boxer = np.frompyfunc(boxfunc, 1, 1)
+    return boxer(arr)
+
+def dt64arr_to_sktsarr(data, freq):
+    if data is None:
+        return data
+
+    if isinstance(freq, basestring):
+        freq = _interval_freq_map[freq]
+
+    return lib.dt64arr_to_sktsarr(data.view('i8'), freq)
+
 # interval frequency constants corresponding to scikits timeseries
 # originals
 _interval_freq_map = {
@@ -270,8 +293,8 @@ class Interval:
         if isinstance(freq, basestring):
             freq = _interval_freq_map[freq]
 
-        new_ordinal = lib.interval_freq_conv(self.ordinal,
-                                             self.freq, freq, how)
+        new_ordinal = lib.skts_freq_conv(self.ordinal,
+                                         self.freq, freq, how)
 
         return Interval(new_ordinal, freq)
 
@@ -290,9 +313,14 @@ class Interval:
         return Interval(skts_ordinal, sfreq).asfreq(freq)
 
     def __repr__(self):
-        formatted = lib.skts_interval_to_string(self.ordinal, self.freq)
+        formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
         freqstr = _reverse_interval_map[self.freq]
-        return ("<%s : %s>" % (freqstr, formatted))
+        return ("Interval('%s', '%s')" % (formatted, freqstr))
+
+    def __str__(self):
+        formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
+        return ("%s" % formatted)
+
 
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 659dd414c..101e29d75 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -17,7 +17,7 @@ from pandas._tseries import Timestamp
 import pandas.core.datetools as datetools
 from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
                                    _dt_unbox_array, to_timestamp, Interval,
-                                   _iv_unbox_array)
+                                   _skts_unbox_array, _skts_box, to_interval)
 
 __all__ = ['Index']
 
@@ -1809,11 +1809,18 @@ class DatetimeIndex(Int64Index):
 
 class IntervalIndex(Int64Index):
     """
-    Immutable ndarray where values represent offsets in the associated
-    frequency, starting with the Gregorian proleptic date Jan 1, 1AD. This
-    representation is inherited from the scikits.timeseries project.
-
-    Index keys are boxed to Interval objects which carries its metadata (eg, 
+    Immutable ndarray holding ordinal values which represent intervals of a
+    particular frequency. A value of 1 represents the interval containing the
+    Gregorian proleptic date/time Jan 1, 0001 00:00:00. This representation
+    is borrowed from the scikits.timeseries project.
+
+    For instance,
+        # construct interval for day 1/1/1 and get the first second
+        i = Interval(year=1,month=1,day=1,freq='D').asfreq('S', 'S')
+        i.ordinal
+        ===> 1
+
+    Index keys are boxed to Interval objects which carries the metadata (eg,
     frequency information).
 
     Parameters
@@ -1845,8 +1852,8 @@ class IntervalIndex(Int64Index):
                              "supplied")
 
         if data is None:
-            start = datetools.to_interval(start, freq)
-            end = datetools.to_interval(end, freq)
+            start = to_interval(start, freq)
+            end = to_interval(end, freq)
 
             if (start is not None and not isinstance(start, Interval)):
                 raise ValueError('Failed to convert %s to interval' % start)
@@ -1854,7 +1861,11 @@ class IntervalIndex(Int64Index):
             if (end is not None and not isinstance(end, Interval)):
                 raise ValueError('Failed to convert %s to interval' % end)
 
-            data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
+            if periods is not None:
+                data = np.arange(start.ordinal, start.ordinal + periods,
+                                 dtype=np.int64)
+            else:
+                data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
 
             index = data.view(cls)
             index.name = name
@@ -1862,8 +1873,6 @@ class IntervalIndex(Int64Index):
 
             return index
 
-        # TODO: what if data in np.datetime64, special case that
-
         if not isinstance(data, np.ndarray):
             if np.isscalar(data):
                 raise ValueError('IntervalIndex() must be called with a '
@@ -1882,13 +1891,132 @@ class IntervalIndex(Int64Index):
             except:
                 data = np.array(data, dtype='O')
 
-            data = _iv_unbox_array(data, check=freq)
+            if freq is None:
+                raise ValueError('freq cannot be none')
+
+            data = _skts_unbox_array(data, check=freq)
+        else:
+            if isinstance(data, IntervalIndex):
+                if freq is None or freq == data.freq:
+                    freq = data.freq
+                    data = data.values
+                else:
+                    # TODO: need vectorized frequency conversion here
+                    raise NotImplementedError
+            else:
+                if freq is None:
+                    raise ValueError('freq cannot be none')
+
+                if data.dtype == np.datetime64:
+                    data = datetools.dt64arr_to_sktsarr(data, freq)
+                elif data.dtype == np.int64:
+                    pass
 
         subarr = data.view(cls)
         subarr.name = name
+        subarr.freq = freq
 
         return subarr
 
+    @property
+    def inferred_type(self):
+        # b/c data is represented as ints make sure we can't have ambiguous
+        # indexing
+        return 'interval'
+
+    def get_value(self, series, key):
+        """
+        Fast lookup of value from 1-dimensional ndarray. Only use this if you
+        know what you're doing
+        """
+        try:
+            return super(IntervalIndex, self).get_value(series, key)
+        except KeyError:
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                # TODO: add partial date slicing
+                key = to_interval(asdt, freq=self.freq).ordinal
+                return series[key]
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+            except IndexError:
+                ival = Interval(key, freq=self.freq)
+                raise IndexError("%s is out of bounds" % ival)
+
+            key = to_interval(key, self.freq).ordinal
+            return self._engine.get_value(series, key)
+
+    def get_loc(self, key):
+        """
+        Get integer location for requested label
+
+        Returns
+        -------
+        loc : int
+        """
+        try:
+            return self._engine.get_loc(key)
+        except KeyError:
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                key = asdt
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+
+            key = to_interval(key, self.freq).ordinal
+            return self._engine.get_loc(key)
+
+    def __getitem__(self, key):
+        """Override numpy.ndarray's __getitem__ method to work as desired"""
+        arr_idx = self.view(np.ndarray)
+        if np.isscalar(key):
+            val = arr_idx[key]
+            return _skts_box(val, freq=self.freq)
+        else:
+            if com._is_bool_indexer(key):
+                key = np.asarray(key)
+
+            result = arr_idx[key]
+            if result.ndim > 1:
+                return IntervalIndex(result, name=self.name, freq=self.freq)
+
+            return IntervalIndex(result, name=self.name, freq=self.freq)
+
+    def format(self, name=False):
+        """
+        Render a string representation of the Index
+        """
+        header = []
+
+        if name:
+            header.append(str(self.name) if self.name is not None else '')
+
+        return header + ['%s' % _skts_box(x, freq=self.freq) for x in self]
+
+    def _view_like(self, ndarray):
+        result = ndarray.view(type(self))
+        result.freq = self.freq
+        result.name = self.name
+        return result
+
+    def __array_finalize__(self, obj):
+        if self.ndim == 0: # pragma: no cover
+            return self.item()
+
+        self.freq = getattr(obj, 'freq', None)
+
+    def __repr__(self):
+        output = str(self.__class__) + '\n'
+        output += 'freq: ''%s''\n' % self.freq
+        if len(self) > 0:
+            output += '[%s, ..., %s]\n' % (self[0], self[-1])
+        output += 'length: %d' % len(self)
+        return output
+
 # --------------------------- end of datetime-specific code ---------------
 
 class Factor(np.ndarray):
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 0cc1f50da..200827f94 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1849,14 +1849,39 @@ cdef inline int64_t ts_dayofweek(_TSObject ts):
 # Interval logic
 # ------------------------------------------------------------------------------
 
-def interval_freq_conv(long dtordinal, int freq1, int freq2, object relation='E'):
+def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int freq):
+    """
+    Convert array of datetime64 values (passed in as 'i8' dtype) to a set of
+    intervals corresponding to desired frequency, per skts convention.
+    """
+    cdef:
+        ndarray[int64_t] out
+        Py_ssize_t i, l
+        npy_datetimestruct dts
+
+    l = len(dtarr)
+
+    out = np.empty(l, dtype='i8')
+
+    for i in range(l):
+        PyArray_DatetimeToDatetimeStruct(dtarr[i], NPY_FR_us, &dts)
+        out[i] = skts_ordinal(dts.year, dts.month, dts.day,
+                              dts.hour, dts.min, dts.sec, 
+                              freq)
+    return out
+
+def skts_freq_conv(long skts_ordinal, int freq1, int freq2,
+                  object relation='E'):
+    """
+    """
     cdef:
         long retval
 
     if not isinstance(relation, basestring) or len(relation) != 1:
         raise ValueError('relation argument must be one of S or E')
 
-    retval = frequency_conversion(dtordinal, freq1, freq2, (<char*>relation)[0])
+    retval = frequency_conversion(skts_ordinal, freq1, freq2,
+                                  (<char*>relation)[0])
 
     return retval
 
@@ -1876,6 +1901,5 @@ def skts_ordinal_to_dt(long skts_ordinal, int freq):
 
     return datetime.fromordinal(ordinal)
 
-
-def skts_interval_to_string(long value, int freq):
+def skts_ordinal_to_string(long value, int freq):
     return <object>interval_to_string(value, freq)
diff --git a/pandas/src/skts.h b/pandas/src/skts.h
index bf0bfd9e7..04d4a7483 100644
--- a/pandas/src/skts.h
+++ b/pandas/src/skts.h
@@ -23,8 +23,14 @@
 
 /*** FREQUENCY CONSTANTS ***/
 
-// datetime ordinal of unix epoch
-#define HIGHFREQ_ORIG 719163
+// HIGHFREQ_ORIG is the datetime ordinal from which to begin the second
+// frequency ordinal sequence
+
+// begins second ordinal at 1/1/1AD gregorian proleptic calendar
+#define HIGHFREQ_ORIG 1
+
+// begins second ordinal at 1/1/1970 unix epoch
+// #define HIGHFREQ_ORIG 719163
 
 #define FR_ANN  1000  /* Annual */
 #define FR_ANNDEC  FR_ANN  /* Annual - December year end*/

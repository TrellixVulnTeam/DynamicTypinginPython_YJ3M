commit 38dd8582bab2bd1d3c7294fe583a5ef7a4d6a6db
Author: Vaibhav Vishal <vaibhav.hrt@gmail.com>
Date:   Fri May 24 21:02:14 2019 +0530

    Fix type annotations in pandas.core.indexes.datetimes (#26404)

diff --git a/mypy.ini b/mypy.ini
index 584c747a2..3df8fd13a 100644
--- a/mypy.ini
+++ b/mypy.ini
@@ -8,11 +8,5 @@ ignore_errors=True
 [mypy-pandas.core.indexes.datetimelike]
 ignore_errors=True
 
-[mypy-pandas.core.indexes.datetimes]
-ignore_errors=True
-
 [mypy-pandas.core.indexes.period]
 ignore_errors=True
-
-[mypy-pandas.core.indexes.timedeltas]
-ignore_errors=True
\ No newline at end of file
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 7454b015c..092cec002 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -57,7 +57,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
     """
     common ops mixin to support a unified interface datetimelike Index
     """
-    _data = None  # type: DatetimeLikeArrayMixin
+    _data = None
 
     # DatetimeLikeArrayMixin assumes subclasses are mutable, so these are
     # properties there.  They can be made into cache_readonly for Index
@@ -220,9 +220,9 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
 
     # Try to run function on index first, and then on elements of index
     # Especially important for group-by functionality
-    def map(self, f):
+    def map(self, mapper, na_action=None):
         try:
-            result = f(self)
+            result = mapper(self)
 
             # Try to use this result if we can
             if isinstance(result, np.ndarray):
@@ -232,7 +232,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
                 raise TypeError('The map function must return an Index object')
             return result
         except Exception:
-            return self.astype(object).map(f)
+            return self.astype(object).map(mapper)
 
     def sort_values(self, return_indexer=False, ascending=True):
         """
@@ -430,8 +430,8 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
     # --------------------------------------------------------------------
     # Rendering Methods
 
-    def _format_with_header(self, header, **kwargs):
-        return header + list(self._format_native_types(**kwargs))
+    def _format_with_header(self, header, na_rep='NaT', **kwargs):
+        return header + list(self._format_native_types(na_rep, **kwargs))
 
     @property
     def _formatter_func(self):
@@ -509,7 +509,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
 
         cls.__rsub__ = __rsub__
 
-    def isin(self, values):
+    def isin(self, values, level=None):
         """
         Compute boolean array of whether each index value is found in the
         passed set of values.
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 7fd537fb9..e68431b79 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -4,8 +4,8 @@ import warnings
 
 import numpy as np
 
-from pandas._libs import (
-    Timestamp, index as libindex, join as libjoin, lib, tslib as libts)
+from pandas._libs import Timestamp, index as libindex, lib, tslib as libts
+import pandas._libs.join as libjoin
 from pandas._libs.tslibs import ccalendar, fields, parsing, timezones
 from pandas.util._decorators import Appender, Substitution, cache_readonly
 
@@ -1087,9 +1087,11 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
     _is_monotonic_decreasing = Index.is_monotonic_decreasing
     _is_unique = Index.is_unique
 
-    _timezone = cache_readonly(DatetimeArray._timezone.fget)
-    is_normalized = cache_readonly(DatetimeArray.is_normalized.fget)
-    _resolution = cache_readonly(DatetimeArray._resolution.fget)
+    _timezone = cache_readonly(DatetimeArray._timezone.fget)  # type: ignore
+    is_normalized = cache_readonly(
+        DatetimeArray.is_normalized.fget)  # type: ignore
+    _resolution = cache_readonly(
+        DatetimeArray._resolution.fget)  # type: ignore
 
     strftime = ea_passthrough(DatetimeArray.strftime)
     _has_same_tz = ea_passthrough(DatetimeArray._has_same_tz)

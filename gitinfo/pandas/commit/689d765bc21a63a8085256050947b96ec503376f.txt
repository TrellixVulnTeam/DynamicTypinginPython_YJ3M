commit 689d765bc21a63a8085256050947b96ec503376f
Author: bashtage <kevin.sheppard@economics.ox.ac.uk>
Date:   Wed Feb 12 19:15:00 2014 +0000

    BUG/API: Fix stata io to deal with wrong data types and missing values (GH6335)
    
    BUG: Changes types used in packing structs
    
    Corrected incorrect data type conversion between pandas and Stata
    
    Remove unnecessary, potentially precision degrading cast to Series when writing data
    Added function to cast columns from NumPy data types to Stata data types
    Corrected tests for correct Stata datatypes
    Fixed formatting in comparison after casting
    
    Added docstring for new function and warning class
    
    BUG: Fixes and tests for extreme values in all data types
    
    The extreme values of float and double (Stata, pandas eqiv: float 32 and
    float64) were not correct.  This resulted in incorrect truncation. The
    handling of missing values have been improved and code to convert missing
    values in any format has been added.  The improvement differentiated between
    valid ranges for data and missing values.
    
    Additional issues were found when handling missing Dates, where missing Dates
    (NaT) were converted to non-missing dates when written.
    
    A test has been added for extreme numeric values as well as missing values.
    
    Fixed legacy date issue with format 114 files
    Added test for 114 files
    
    Added format 114 (Stata 9/10/11) data file
    
    Add test for Stata data with file format 114
    
    Added additional data files for testing alternative Stata file formats
    
    Added expected result to test
    Renamed Stata data files to include file format
    
    Types used for integer conversion where always half the size they should be.
    Produced a bug when exporting data tables with long integer data (np.int64).
    
    Added test for integer conversion bug
    
    Added test for incorrect integer conversion from int16, int32 and int64
    
    Added additional data files for testing alternative Stata file formats
    
    Added expected result to test
    Renamed Stata data files to include file format
    
    Disabled the big endian skips

diff --git a/doc/source/release.rst b/doc/source/release.rst
index d84afc66b..f4f376026 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -201,6 +201,10 @@ Bug Fixes
 - ``.names`` attribute of MultiIndexes passed to ``set_index`` are now preserved (:issue:`6459`).
 - Bug in setitem with a duplicate index and an alignable rhs (:issue:`6541`)
 - Bug in setitem with loc on mixed integer Indexes (:issue:`6546`)
+- Bug in ``pd.read_stata`` which would use the wrong data types and missing values (:issue:`6327`)
+- Bug in ``DataFrame.to_stata`` that lead to data loss in certain cases, and could exported using the
+  wrong data types and missing values (:issue:`6335`)
+
 
 pandas 0.13.1
 -------------
diff --git a/doc/source/v0.14.0.txt b/doc/source/v0.14.0.txt
index 7bcd30301..310047545 100644
--- a/doc/source/v0.14.0.txt
+++ b/doc/source/v0.14.0.txt
@@ -291,6 +291,9 @@ Enhancements
   using ``DataFrame.to_csv`` (:issue:`5414`, :issue:`4528`)
 - Added a ``to_julian_date`` function to ``TimeStamp`` and ``DatetimeIndex``
   to convert to the Julian Date used primarily in astronomy. (:issue:`4041`)
+- ``DataFrame.to_stata`` will now check data for compatibility with Stata data types
+  and will upcast when needed.  When it isn't possibly to losslessly upcast, a warning
+  is raised (:issue:`6327`)
 
 Performance
 ~~~~~~~~~~~
diff --git a/pandas/io/stata.py b/pandas/io/stata.py
index 55bcbd76c..2ecdb22a5 100644
--- a/pandas/io/stata.py
+++ b/pandas/io/stata.py
@@ -23,7 +23,7 @@ from pandas import compat
 from pandas.compat import long, lrange, lmap, lzip
 from pandas import isnull
 from pandas.io.common import get_filepath_or_buffer
-
+from pandas.tslib import NaT
 
 def read_stata(filepath_or_buffer, convert_dates=True,
                convert_categoricals=True, encoding=None, index=None):
@@ -48,7 +48,7 @@ def read_stata(filepath_or_buffer, convert_dates=True,
 
     return reader.data(convert_dates, convert_categoricals, index)
 
-_date_formats = ["%tc", "%tC", "%td", "%tw", "%tm", "%tq", "%th", "%ty"]
+_date_formats = ["%tc", "%tC", "%td", "%d", "%tw", "%tm", "%tq", "%th", "%ty"]
 
 
 def _stata_elapsed_date_to_datetime(date, fmt):
@@ -97,6 +97,7 @@ def _stata_elapsed_date_to_datetime(date, fmt):
     # numpy types and numpy datetime isn't mature enough / we can't rely on
     # pandas version > 0.7.1
     #TODO: IIRC relative delta doesn't play well with np.datetime?
+    #TODO: When pandas supports more than datetime64[ns], this should be improved to use correct range, e.g. datetime[Y] for yearly
     if np.isnan(date):
         return np.datetime64('nat')
 
@@ -109,7 +110,7 @@ def _stata_elapsed_date_to_datetime(date, fmt):
         from warnings import warn
         warn("Encountered %tC format. Leaving in Stata Internal Format.")
         return date
-    elif fmt in ["%td", "td"]:
+    elif fmt in ["%td", "td", "%d", "d"]:
         return stata_epoch + datetime.timedelta(int(date))
     elif fmt in ["%tw", "tw"]:  # does not count leap days - 7 days is a week
         year = datetime.datetime(stata_epoch.year + date // 52, 1, 1)
@@ -150,6 +151,11 @@ def _datetime_to_stata_elapsed(date, fmt):
     if not isinstance(date, datetime.datetime):
         raise ValueError("date should be datetime.datetime format")
     stata_epoch = datetime.datetime(1960, 1, 1)
+    # Handle NaTs
+    if date is NaT:
+        # Missing value for dates ('.'), assumed always double
+        # TODO: Should be moved so a const somewhere, and consolidated
+        return struct.unpack('<d', b'\x00\x00\x00\x00\x00\x00\xe0\x7f')[0]
     if fmt in ["%tc", "tc"]:
         delta = date - stata_epoch
         return (delta.days * 86400000 + delta.seconds*1000 +
@@ -175,6 +181,62 @@ def _datetime_to_stata_elapsed(date, fmt):
         raise ValueError("fmt %s not understood" % fmt)
 
 
+class PossiblePrecisionLoss(Warning):
+    pass
+
+
+precision_loss_doc = """
+Column converted from %s to %s, and some data are outside of the lossless
+conversion range. This may result in a loss of precision in the saved data.
+"""
+
+
+def _cast_to_stata_types(data):
+    """Checks the dtypes of the columns of a pandas DataFrame for
+    compatibility with the data types and ranges supported by Stata, and
+    converts if necessary.
+
+    Parameters
+    ----------
+    data : DataFrame
+        The DataFrame to check and convert
+
+    Notes
+    -----
+    Numeric columns must be one of int8, int16, int32, float32 or float64, with
+    some additional value restrictions on the integer data types.  int8 and
+    int16 columns are checked for violations of the value restrictions and
+    upcast if needed.  int64 data is not usable in Stata, and so it is
+    downcast to int32 whenever the value are in the int32 range, and
+    sidecast to float64 when larger than this range.  If the int64 values
+    are outside of the range of those perfectly representable as float64 values,
+    a warning is raised.
+    """
+    ws = ''
+    for col in data:
+        dtype = data[col].dtype
+        if dtype == np.int8:
+            if data[col].max() > 100 or data[col].min() < -127:
+                data[col] = data[col].astype(np.int16)
+        elif dtype == np.int16:
+            if data[col].max() > 32740 or data[col].min() < -32767:
+                data[col] = data[col].astype(np.int32)
+        elif dtype == np.int64:
+            if data[col].max() <= 2147483620 and data[col].min() >= -2147483647:
+                data[col] = data[col].astype(np.int32)
+            else:
+                data[col] = data[col].astype(np.float64)
+                if data[col].max() <= 2 * 53 or data[col].min() >= -2 ** 53:
+                    ws = precision_loss_doc % ('int64', 'float64')
+
+    if ws:
+        import warnings
+
+        warnings.warn(ws, PossiblePrecisionLoss)
+
+    return data
+
+
 class StataMissingValue(StringMixin):
     """
     An observation's missing value.
@@ -193,14 +255,23 @@ class StataMissingValue(StringMixin):
     -----
     More information: <http://www.stata.com/help.cgi?missing>
     """
-
+    # TODO: Needs test
     def __init__(self, offset, value):
         self._value = value
-        if type(value) is int or type(value) is long:
-            self._str = value - offset is 1 and \
-                '.' or ('.' + chr(value - offset + 96))
+        value_type = type(value)
+        if value_type in int:
+            loc = value - offset
+        elif value_type in (float, np.float32, np.float64):
+            if value <= np.finfo(np.float32).max:  # float32
+                conv_str, byte_loc, scale = '<f', 1, 8
+            else:
+                conv_str, byte_loc, scale = '<d', 5, 1
+            value_bytes = struct.pack(conv_str, value)
+            loc = (struct.unpack('<b', value_bytes[byte_loc])[0] / scale) + 0
         else:
-            self._str = '.'
+            # Should never be hit
+            loc = 0
+        self._str = loc is 0 and '.' or ('.' + chr(loc + 96))
     string = property(lambda self: self._str,
                       doc="The Stata representation of the missing value: "
                           "'.', '.a'..'.z'")
@@ -240,9 +311,9 @@ class StataParser(object):
             dict(
                 lzip(range(1, 245), ['a' + str(i) for i in range(1, 245)]) +
                 [
-                    (251, np.int16),
-                    (252, np.int32),
-                    (253, np.int64),
+                    (251, np.int8),
+                    (252, np.int16),
+                    (253, np.int32),
                     (254, np.float32),
                     (255, np.float64)
                 ]
@@ -253,9 +324,9 @@ class StataParser(object):
                     (32768, np.string_),
                     (65526, np.float64),
                     (65527, np.float32),
-                    (65528, np.int64),
-                    (65529, np.int32),
-                    (65530, np.int16)
+                    (65528, np.int32),
+                    (65529, np.int16),
+                    (65530, np.int8)
                 ]
             )
         self.TYPE_MAP = lrange(251) + list('bhlfd')
@@ -272,13 +343,19 @@ class StataParser(object):
         #NOTE: technically, some of these are wrong. there are more numbers
         # that can be represented. it's the 27 ABOVE and BELOW the max listed
         # numeric data type in [U] 12.2.2 of the 11.2 manual
-        self.MISSING_VALUES = \
+        float32_min = b'\xff\xff\xff\xfe'
+        float32_max = b'\xff\xff\xff\x7e'
+        float64_min = b'\xff\xff\xff\xff\xff\xff\xef\xff'
+        float64_max = b'\xff\xff\xff\xff\xff\xff\xdf\x7f'
+        self.VALID_RANGE = \
             {
                 'b': (-127, 100),
                 'h': (-32767, 32740),
                 'l': (-2147483647, 2147483620),
-                'f': (-1.701e+38, +1.701e+38),
-                'd': (-1.798e+308, +8.988e+307)
+                'f': (np.float32(struct.unpack('<f', float32_min)[0]),
+                      np.float32(struct.unpack('<f', float32_max)[0])),
+                'd': (np.float64(struct.unpack('<d', float64_min)[0]),
+                      np.float64(struct.unpack('<d', float64_max)[0]))
             }
 
         self.OLD_TYPE_MAPPING = \
@@ -287,6 +364,16 @@ class StataParser(object):
                 'f': 254,
                 'b': 251
             }
+        # These missing values are the generic '.' in Stata, and are used
+        # to replace nans
+        self.MISSING_VALUES = \
+            {
+                'b': 101,
+                'h': 32741,
+                'l': 2147483621,
+                'f': np.float32(struct.unpack('<f', b'\x00\x00\x00\x7f')[0]),
+                'd': np.float64(struct.unpack('<d', b'\x00\x00\x00\x00\x00\x00\xe0\x7f')[0])
+            }
 
     def _decode_bytes(self, str, errors=None):
         if compat.PY3 or self._encoding is not None:
@@ -556,8 +643,8 @@ class StataReader(StataParser):
 
     def _unpack(self, fmt, byt):
         d = struct.unpack(self.byteorder + fmt, byt)[0]
-        if fmt[-1] in self.MISSING_VALUES:
-            nmin, nmax = self.MISSING_VALUES[fmt[-1]]
+        if fmt[-1] in self.VALID_RANGE:
+            nmin, nmax = self.VALID_RANGE[fmt[-1]]
             if d < nmin or d > nmax:
                 if self._missing_values:
                     return StataMissingValue(nmax, d)
@@ -855,11 +942,12 @@ def _dtype_to_stata_type(dtype):
     See TYPE_MAP and comments for an explanation. This is also explained in
     the dta spec.
     1 - 244 are strings of this length
-    251 - chr(251) - for int8 and int16, byte
-    252 - chr(252) - for int32, int
-    253 - chr(253) - for int64, long
-    254 - chr(254) - for float32, float
-    255 - chr(255) - double, double
+                         Pandas    Stata
+    251 - chr(251) - for int8      byte
+    252 - chr(252) - for int16     int
+    253 - chr(253) - for int32     long
+    254 - chr(254) - for float32   float
+    255 - chr(255) - for double    double
 
     If there are dates to convert, then dtype will already have the correct
     type inserted.
@@ -878,8 +966,10 @@ def _dtype_to_stata_type(dtype):
     elif dtype == np.int64:
         return chr(253)
     elif dtype == np.int32:
+        return chr(253)
+    elif dtype == np.int16:
         return chr(252)
-    elif dtype == np.int8 or dtype == np.int16:
+    elif dtype == np.int8:
         return chr(251)
     else:  # pragma : no cover
         raise ValueError("Data type %s not currently understood. "
@@ -970,7 +1060,7 @@ class StataWriter(StataParser):
         self._file = _open_file_binary_write(
             fname, self._encoding or self._default_encoding
         )
-        self.type_converters = {253: np.long, 252: int}
+        self.type_converters = {253: np.int32, 252: np.int16, 251: np.int8}
 
     def _write(self, to_write):
         """
@@ -990,11 +1080,14 @@ class StataWriter(StataParser):
                 self.data = data
 
             def __iter__(self):
-                for i, row in data.iterrows():
-                    yield row
+                for row in data.itertuples():
+                    # First element is index, so remove
+                    yield row[1:]
 
         if self._write_index:
             data = data.reset_index()
+        # Check columns for compatbaility with stata
+        data = _cast_to_stata_types(data)
         self.datarows = DataFrameRowIter(data)
         self.nobs, self.nvar = data.shape
         self.data = data
@@ -1181,7 +1274,7 @@ class StataWriter(StataParser):
                     self._write(var)
                 else:
                     if isnull(var):  # this only matters for floats
-                        var = MISSING_VALUES[typ]
+                        var = MISSING_VALUES[TYPE_MAP[typ]]
                     self._file.write(struct.pack(byteorder+TYPE_MAP[typ], var))
 
     def _null_terminate(self, s, as_string=False):
diff --git a/pandas/io/tests/data/stata1.dta b/pandas/io/tests/data/stata1_114.dta
similarity index 100%
rename from pandas/io/tests/data/stata1.dta
rename to pandas/io/tests/data/stata1_114.dta
diff --git a/pandas/io/tests/data/stata1_v13.dta b/pandas/io/tests/data/stata1_117.dta
similarity index 100%
rename from pandas/io/tests/data/stata1_v13.dta
rename to pandas/io/tests/data/stata1_117.dta
diff --git a/pandas/io/tests/data/stata2_113.dta b/pandas/io/tests/data/stata2_113.dta
new file mode 100644
index 000000000..09c90dca9
Binary files /dev/null and b/pandas/io/tests/data/stata2_113.dta differ
diff --git a/pandas/io/tests/data/stata2.dta b/pandas/io/tests/data/stata2_114.dta
similarity index 100%
rename from pandas/io/tests/data/stata2.dta
rename to pandas/io/tests/data/stata2_114.dta
diff --git a/pandas/io/tests/data/stata2_115.dta b/pandas/io/tests/data/stata2_115.dta
new file mode 100644
index 000000000..ad7dda3fd
Binary files /dev/null and b/pandas/io/tests/data/stata2_115.dta differ
diff --git a/pandas/io/tests/data/stata2_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats b/pandas/io/tests/data/stata2_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats
new file mode 100644
index 000000000..ad7dda3fd
Binary files /dev/null and b/pandas/io/tests/data/stata2_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats differ
diff --git a/pandas/io/tests/data/stata2_v13.dta b/pandas/io/tests/data/stata2_117.dta
similarity index 100%
rename from pandas/io/tests/data/stata2_v13.dta
rename to pandas/io/tests/data/stata2_117.dta
diff --git a/pandas/io/tests/data/stata3_113.dta b/pandas/io/tests/data/stata3_113.dta
new file mode 100644
index 000000000..f78150a2e
Binary files /dev/null and b/pandas/io/tests/data/stata3_113.dta differ
diff --git a/pandas/io/tests/data/stata3.dta b/pandas/io/tests/data/stata3_114.dta
similarity index 100%
rename from pandas/io/tests/data/stata3.dta
rename to pandas/io/tests/data/stata3_114.dta
diff --git a/pandas/io/tests/data/stata3_115.dta b/pandas/io/tests/data/stata3_115.dta
new file mode 100644
index 000000000..1c4ad0dae
Binary files /dev/null and b/pandas/io/tests/data/stata3_115.dta differ
diff --git a/pandas/io/tests/data/stata3_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats b/pandas/io/tests/data/stata3_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats
new file mode 100644
index 000000000..1c4ad0dae
Binary files /dev/null and b/pandas/io/tests/data/stata3_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats differ
diff --git a/pandas/io/tests/data/stata3_v13.dta b/pandas/io/tests/data/stata3_117.dta
similarity index 100%
rename from pandas/io/tests/data/stata3_v13.dta
rename to pandas/io/tests/data/stata3_117.dta
diff --git a/pandas/io/tests/data/stata4_113.dta b/pandas/io/tests/data/stata4_113.dta
new file mode 100644
index 000000000..9d7d5abb1
Binary files /dev/null and b/pandas/io/tests/data/stata4_113.dta differ
diff --git a/pandas/io/tests/data/stata4.dta b/pandas/io/tests/data/stata4_114.dta
similarity index 100%
rename from pandas/io/tests/data/stata4.dta
rename to pandas/io/tests/data/stata4_114.dta
diff --git a/pandas/io/tests/data/stata4_115.dta b/pandas/io/tests/data/stata4_115.dta
new file mode 100644
index 000000000..2c68cfb39
Binary files /dev/null and b/pandas/io/tests/data/stata4_115.dta differ
diff --git a/pandas/io/tests/data/stata4_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats b/pandas/io/tests/data/stata4_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats
new file mode 100644
index 000000000..2c68cfb39
Binary files /dev/null and b/pandas/io/tests/data/stata4_115.dta~1dc157c... Added additional data files for testing alternative Stata file formats differ
diff --git a/pandas/io/tests/data/stata4_v13.dta b/pandas/io/tests/data/stata4_117.dta
similarity index 100%
rename from pandas/io/tests/data/stata4_v13.dta
rename to pandas/io/tests/data/stata4_117.dta
diff --git a/pandas/io/tests/data/stata5.csv b/pandas/io/tests/data/stata5.csv
new file mode 100644
index 000000000..8eb0c2854
--- /dev/null
+++ b/pandas/io/tests/data/stata5.csv
@@ -0,0 +1,19 @@
+byte_,int_,long_,float_,double_,date_td,string_,string_1
+0,0,0,0,0,,"a","a"
+1,1,1,1,1,,"ab","b"
+-1,-1,-1,-1,-1,,"abc","c"
+100,32740,-2147483647,-1.70100000027769e+38,-2.0000000000000e+307,1970-01-01,"abcdefghijklmnop","d"
+-127,-32767,2147483620,1.70100000027769e+38,8.0000000000000e+307,1970-01-02,"abcdefghijklmnopqrstuvwxyz","e"
+,0,,,,2014-01-01,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","f"
+0,,,,,2114-01-01,"1234567890","1"
+,,0,,,2014-12-31,"This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted","2"
+.a,.a,.a,.a,.a,2012-02-29,"!","A"
+100,32740,-2.15e+09,-1.70e+38,-2.0e+307,01jan1970,"abcdefghijklmnop","d"
+-127,-32767,2.15e+09,1.70e+38,8.0e+307,02jan1970,"abcdefghijklmnopqrstuvwxyz","e"
+,0,,,,01jan2014,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","f"
+0,,,,,01jan2114,"1234567890","1"
+,,0,,,31dec2014,"This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted","2"
+.a,.a,.a,.a,.a,29feb2012,"!","A"
+.z,.z,.z,.z,.z,,"&","Z"
+,,,0,,,"1.23","!"
+,,,,0,,"10jan1970","."
diff --git a/pandas/io/tests/data/stata5_113.dta b/pandas/io/tests/data/stata5_113.dta
new file mode 100644
index 000000000..3615928d5
Binary files /dev/null and b/pandas/io/tests/data/stata5_113.dta differ
diff --git a/pandas/io/tests/data/stata5_114.dta b/pandas/io/tests/data/stata5_114.dta
new file mode 100644
index 000000000..bebc6a72c
Binary files /dev/null and b/pandas/io/tests/data/stata5_114.dta differ
diff --git a/pandas/io/tests/data/stata5_115.dta b/pandas/io/tests/data/stata5_115.dta
new file mode 100644
index 000000000..c54bd62c2
Binary files /dev/null and b/pandas/io/tests/data/stata5_115.dta differ
diff --git a/pandas/io/tests/data/stata6.csv b/pandas/io/tests/data/stata6.csv
new file mode 100644
index 000000000..27a1dc64f
--- /dev/null
+++ b/pandas/io/tests/data/stata6.csv
@@ -0,0 +1,6 @@
+byte_,int_,long_,float_,double_,date_td,string_,string_1
+0,0,0,0,0,1960-01-01,"a","a"
+1,1,1,1,1,3014-12-31,"ab","b"
+-1,-1,-1,-1,-1,2014-12-31,"abc","c"
+100,32740,-2147483647,-1.7010000002777e+38,-2.000000000000e+307,1970-01-01,"This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted by Stata. This string has 244 characters, so that ir is the maximum length permitted","d"
+-127,-32767,2147483620,1.7010000002777e+38,8.000000000000e+307,1970-01-02,"abcdefghijklmnopqrstuvwxyz","e"
diff --git a/pandas/io/tests/data/stata6_113.dta b/pandas/io/tests/data/stata6_113.dta
new file mode 100644
index 000000000..2e4795b16
Binary files /dev/null and b/pandas/io/tests/data/stata6_113.dta differ
diff --git a/pandas/io/tests/data/stata6_114.dta b/pandas/io/tests/data/stata6_114.dta
new file mode 100644
index 000000000..aa507e474
Binary files /dev/null and b/pandas/io/tests/data/stata6_114.dta differ
diff --git a/pandas/io/tests/data/stata6_115.dta b/pandas/io/tests/data/stata6_115.dta
new file mode 100644
index 000000000..c51346386
Binary files /dev/null and b/pandas/io/tests/data/stata6_115.dta differ
diff --git a/pandas/io/tests/test_stata.py b/pandas/io/tests/test_stata.py
index 1640bee7a..ac4b9662f 100644
--- a/pandas/io/tests/test_stata.py
+++ b/pandas/io/tests/test_stata.py
@@ -27,22 +27,46 @@ class TestStata(tm.TestCase):
         # Unit test datasets for dta7 - dta9 (old stata formats 104, 105 and 107) can be downloaded from:
         # http://stata-press.com/data/glmext.html
         self.dirpath = tm.get_data_path()
-        self.dta1 = os.path.join(self.dirpath, 'stata1.dta')
-        self.dta2 = os.path.join(self.dirpath, 'stata2.dta')
-        self.dta3 = os.path.join(self.dirpath, 'stata3.dta')
+        self.dta1_114 = os.path.join(self.dirpath, 'stata1_114.dta')
+        self.dta1_117 = os.path.join(self.dirpath, 'stata1_117.dta')
+
+        self.dta2_113 = os.path.join(self.dirpath, 'stata2_113.dta')
+        self.dta2_114 = os.path.join(self.dirpath, 'stata2_114.dta')
+        self.dta2_115 = os.path.join(self.dirpath, 'stata2_115.dta')
+        self.dta2_117 = os.path.join(self.dirpath, 'stata2_117.dta')
+
+        self.dta3_113 = os.path.join(self.dirpath, 'stata3_113.dta')
+        self.dta3_114 = os.path.join(self.dirpath, 'stata3_114.dta')
+        self.dta3_115 = os.path.join(self.dirpath, 'stata3_115.dta')
+        self.dta3_117 = os.path.join(self.dirpath, 'stata3_117.dta')
         self.csv3 = os.path.join(self.dirpath, 'stata3.csv')
-        self.dta4 = os.path.join(self.dirpath, 'stata4.dta')
+
+        self.dta4_113 = os.path.join(self.dirpath, 'stata4_113.dta')
+        self.dta4_114 = os.path.join(self.dirpath, 'stata4_114.dta')
+        self.dta4_115 = os.path.join(self.dirpath, 'stata4_115.dta')
+        self.dta4_117 = os.path.join(self.dirpath, 'stata4_117.dta')
+
         self.dta7 = os.path.join(self.dirpath, 'cancer.dta')
         self.csv7 = os.path.join(self.dirpath, 'cancer.csv')
+
         self.dta8 = os.path.join(self.dirpath, 'tbl19-3.dta')
+
         self.csv8 = os.path.join(self.dirpath, 'tbl19-3.csv')
+
         self.dta9 = os.path.join(self.dirpath, 'lbw.dta')
         self.csv9 = os.path.join(self.dirpath, 'lbw.csv')
+
         self.dta_encoding = os.path.join(self.dirpath, 'stata1_encoding.dta')
-        self.dta1_13 = os.path.join(self.dirpath, 'stata1_v13.dta')
-        self.dta2_13 = os.path.join(self.dirpath, 'stata2_v13.dta')
-        self.dta3_13 = os.path.join(self.dirpath, 'stata3_v13.dta')
-        self.dta4_13 = os.path.join(self.dirpath, 'stata4_v13.dta')
+
+        self.csv14 = os.path.join(self.dirpath, 'stata5.csv')
+        self.dta14_113 = os.path.join(self.dirpath, 'stata5_113.dta')
+        self.dta14_114 = os.path.join(self.dirpath, 'stata5_114.dta')
+        self.dta14_115 = os.path.join(self.dirpath, 'stata5_115.dta')
+
+        self.csv15 = os.path.join(self.dirpath, 'stata6.csv')
+        self.dta15_113 = os.path.join(self.dirpath, 'stata6_113.dta')
+        self.dta15_114 = os.path.join(self.dirpath, 'stata6_114.dta')
+        self.dta15_115 = os.path.join(self.dirpath, 'stata6_115.dta')
 
     def read_dta(self, file):
         return read_stata(file, convert_dates=True)
@@ -51,10 +75,10 @@ class TestStata(tm.TestCase):
         return read_csv(file, parse_dates=True)
 
     def test_read_dta1(self):
-        reader = StataReader(self.dta1)
-        parsed = reader.data()
-        reader_13 = StataReader(self.dta1_13)
-        parsed_13 = reader_13.data()
+        reader_114 = StataReader(self.dta1_114)
+        parsed_114 = reader_114.data()
+        reader_117 = StataReader(self.dta1_117)
+        parsed_117 = reader_117.data()
         # Pandas uses np.nan as missing value.
         # Thus, all columns will be of type float, regardless of their name.
         expected = DataFrame([(np.nan, np.nan, np.nan, np.nan, np.nan)],
@@ -65,8 +89,8 @@ class TestStata(tm.TestCase):
         # the casting doesn't fail so need to match stata here
         expected['float_miss'] = expected['float_miss'].astype(np.float32)
 
-        tm.assert_frame_equal(parsed, expected)
-        tm.assert_frame_equal(parsed_13, expected)
+        tm.assert_frame_equal(parsed_114, expected)
+        tm.assert_frame_equal(parsed_117, expected)
 
     def test_read_dta2(self):
         if LooseVersion(sys.version) < '2.7':
@@ -109,34 +133,48 @@ class TestStata(tm.TestCase):
                      'monthly_date', 'quarterly_date', 'half_yearly_date',
                      'yearly_date']
         )
+        expected['yearly_date'] = expected['yearly_date'].astype('O')
 
         with warnings.catch_warnings(record=True) as w:
-            parsed = self.read_dta(self.dta2)
-            parsed_13 = self.read_dta(self.dta2_13)
+            parsed_114 = self.read_dta(self.dta2_114)
+            parsed_115 = self.read_dta(self.dta2_115)
+            parsed_117 = self.read_dta(self.dta2_117)
+            # 113 is buggy due ot limits date format support in Stata
+            # parsed_113 = self.read_dta(self.dta2_113)
+
             np.testing.assert_equal(
                 len(w), 1)  # should get a warning for that format.
 
         # buggy test because of the NaT comparison on certain platforms
-        #
-        #tm.assert_frame_equal(parsed, expected)
-        #tm.assert_frame_equal(parsed_13, expected)
+        # Format 113 test fails since it does not support tc and tC formats
+        # tm.assert_frame_equal(parsed_113, expected)
+        tm.assert_frame_equal(parsed_114, expected)
+        tm.assert_frame_equal(parsed_115, expected)
+        tm.assert_frame_equal(parsed_117, expected)
 
     def test_read_dta3(self):
-        parsed = self.read_dta(self.dta3)
-        parsed_13 = self.read_dta(self.dta3_13)
+        parsed_113 = self.read_dta(self.dta3_113)
+        parsed_114 = self.read_dta(self.dta3_114)
+        parsed_115 = self.read_dta(self.dta3_115)
+        parsed_117 = self.read_dta(self.dta3_117)
 
         # match stata here
         expected = self.read_csv(self.csv3)
         expected = expected.astype(np.float32)
-        expected['year'] = expected['year'].astype(np.int32)
-        expected['quarter'] = expected['quarter'].astype(np.int16)
+        expected['year'] = expected['year'].astype(np.int16)
+        expected['quarter'] = expected['quarter'].astype(np.int8)
 
-        tm.assert_frame_equal(parsed, expected)
-        tm.assert_frame_equal(parsed_13, expected)
+        tm.assert_frame_equal(parsed_113, expected)
+        tm.assert_frame_equal(parsed_114, expected)
+        tm.assert_frame_equal(parsed_115, expected)
+        tm.assert_frame_equal(parsed_117, expected)
 
     def test_read_dta4(self):
-        parsed = self.read_dta(self.dta4)
-        parsed_13 = self.read_dta(self.dta4_13)
+        parsed_113 = self.read_dta(self.dta4_113)
+        parsed_114 = self.read_dta(self.dta4_114)
+        parsed_115 = self.read_dta(self.dta4_115)
+        parsed_117 = self.read_dta(self.dta4_117)
+
         expected = DataFrame.from_records(
             [
                 ["one", "ten", "one", "one", "one"],
@@ -153,11 +191,13 @@ class TestStata(tm.TestCase):
             columns=['fully_labeled', 'fully_labeled2', 'incompletely_labeled',
                      'labeled_with_missings', 'float_labelled'])
 
-        tm.assert_frame_equal(parsed, expected)
-        tm.assert_frame_equal(parsed_13, expected)
+        tm.assert_frame_equal(parsed_113, expected)
+        tm.assert_frame_equal(parsed_114, expected)
+        tm.assert_frame_equal(parsed_115, expected)
+        tm.assert_frame_equal(parsed_117, expected)
 
     def test_read_write_dta5(self):
-        skip_if_not_little_endian()
+        # skip_if_not_little_endian()
 
         original = DataFrame([(np.nan, np.nan, np.nan, np.nan, np.nan)],
                              columns=['float_miss', 'double_miss', 'byte_miss',
@@ -171,10 +211,13 @@ class TestStata(tm.TestCase):
                                   original)
 
     def test_write_dta6(self):
-        skip_if_not_little_endian()
+        # skip_if_not_little_endian()
 
         original = self.read_csv(self.csv3)
         original.index.name = 'index'
+        original.index = original.index.astype(np.int32)
+        original['year'] = original['year'].astype(np.int32)
+        original['quarter'] = original['quarter'].astype(np.int32)
 
         with tm.ensure_clean() as path:
             original.to_stata(path, None, False)
@@ -201,7 +244,7 @@ class TestStata(tm.TestCase):
         tm.assert_frame_equal(parsed, expected)
 
     def test_read_write_dta10(self):
-        skip_if_not_little_endian()
+        # skip_if_not_little_endian()
 
         original = DataFrame(data=[["string", "object", 1, 1.1,
                                     np.datetime64('2003-12-25')]],
@@ -209,6 +252,8 @@ class TestStata(tm.TestCase):
                                       'datetime'])
         original["object"] = Series(original["object"], dtype=object)
         original.index.name = 'index'
+        original.index = original.index.astype(np.int32)
+        original['integer'] = original['integer'].astype(np.int32)
 
         with tm.ensure_clean() as path:
             original.to_stata(path, {'datetime': 'tc'}, False)
@@ -238,13 +283,14 @@ class TestStata(tm.TestCase):
             self.assert_(isinstance(result, unicode))
 
     def test_read_write_dta11(self):
-        skip_if_not_little_endian()
+        # skip_if_not_little_endian()
 
         original = DataFrame([(1, 2, 3, 4)],
                              columns=['good', compat.u('b\u00E4d'), '8number', 'astringwithmorethan32characters______'])
         formatted = DataFrame([(1, 2, 3, 4)],
                               columns=['good', 'b_d', '_8number', 'astringwithmorethan32characters_'])
         formatted.index.name = 'index'
+        formatted = formatted.astype(np.int32)
 
         with tm.ensure_clean() as path:
             with warnings.catch_warnings(record=True) as w:
@@ -256,13 +302,14 @@ class TestStata(tm.TestCase):
             tm.assert_frame_equal(written_and_read_again.set_index('index'), formatted)
 
     def test_read_write_dta12(self):
-        skip_if_not_little_endian()
+        # skip_if_not_little_endian()
 
         original = DataFrame([(1, 2, 3, 4)],
                              columns=['astringwithmorethan32characters_1', 'astringwithmorethan32characters_2', '+', '-'])
         formatted = DataFrame([(1, 2, 3, 4)],
                               columns=['astringwithmorethan32characters_', '_0astringwithmorethan32character', '_', '_1_'])
         formatted.index.name = 'index'
+        formatted = formatted.astype(np.int32)
 
         with tm.ensure_clean() as path:
             with warnings.catch_warnings(record=True) as w:
@@ -272,6 +319,64 @@ class TestStata(tm.TestCase):
 
             written_and_read_again = self.read_dta(path)
             tm.assert_frame_equal(written_and_read_again.set_index('index'), formatted)
+            
+    def test_read_write_dta13(self):
+        s1 = Series(2**9,dtype=np.int16)
+        s2 = Series(2**17,dtype=np.int32)
+        s3 = Series(2**33,dtype=np.int64)
+        original = DataFrame({'int16':s1,'int32':s2,'int64':s3})
+        original.index.name = 'index'
+
+        formatted = original
+        formatted['int64'] = formatted['int64'].astype(np.float64)
+
+        with tm.ensure_clean() as path:
+            original.to_stata(path)
+            written_and_read_again = self.read_dta(path)
+            tm.assert_frame_equal(written_and_read_again.set_index('index'),
+                                  formatted)
+
+    def test_read_write_reread_dta14(self):
+        expected = self.read_csv(self.csv14)
+        cols = ['byte_', 'int_', 'long_', 'float_', 'double_']
+        for col in cols:
+            expected[col] = expected[col].convert_objects(convert_numeric=True)
+        expected['float_'] = expected['float_'].astype(np.float32)
+        expected['date_td'] = pd.to_datetime(expected['date_td'], coerce=True)
+
+        parsed_113 = self.read_dta(self.dta14_113)
+        parsed_113.index.name = 'index'
+        parsed_114 = self.read_dta(self.dta14_114)
+        parsed_114.index.name = 'index'
+        parsed_115 = self.read_dta(self.dta14_115)
+        parsed_115.index.name = 'index'
+
+        tm.assert_frame_equal(parsed_114, parsed_113)
+        tm.assert_frame_equal(parsed_114, parsed_115)
+
+        with tm.ensure_clean() as path:
+            parsed_114.to_stata(path, {'date_td': 'td'}, write_index=False)
+            written_and_read_again = self.read_dta(path)
+            tm.assert_frame_equal(written_and_read_again.set_index('index'), parsed_114)
+
+    def test_read_write_reread_dta15(self):
+        expected = self.read_csv(self.csv15)
+        expected['byte_'] = expected['byte_'].astype(np.int8)
+        expected['int_'] = expected['int_'].astype(np.int16)
+        expected['long_'] = expected['long_'].astype(np.int32)
+        expected['float_'] = expected['float_'].astype(np.float32)
+        expected['double_'] = expected['double_'].astype(np.float64)
+        expected['date_td'] = expected['date_td'].apply(datetime.strptime, args=('%Y-%m-%d',))
+
+        parsed_113 = self.read_dta(self.dta15_113)
+        parsed_114 = self.read_dta(self.dta15_114)
+        parsed_115 = self.read_dta(self.dta15_115)
+
+        tm.assert_frame_equal(expected, parsed_114)
+        tm.assert_frame_equal(parsed_113, parsed_114)
+        tm.assert_frame_equal(parsed_114, parsed_115)
+
+
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],

commit cfde7cddb693d912872654d71782f9c79a5e0f5b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Sep 25 16:51:54 2011 -0400

    ENH: tinkering with other join impl

diff --git a/RELEASE.rst b/RELEASE.rst
index 6978acff7..65e1bff87 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -36,6 +36,7 @@ improvements
   - Enable sortlevel to work by level name (PR #141)
   - `read_csv` can automatically "sniff" other kinds of delimiters using
     `csv.Sniffer` (PR #146)
+  - Improved speed of unit test suite by about 40%
 
 **Bug fixes**
 
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index 66c9570d8..731e49a18 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -455,27 +455,28 @@ def inner_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
     nleft = len(left)
     nright = len(right)
 
+    assert(left.flags.contiguous)
+    assert(right.flags.contiguous)
+
+    cdef int64_t *lptr = <int64_t*> left.data
+    cdef int64_t *rptr = <int64_t*> right.data
+
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
-            break
-
-        val = left[i]
-
-        while j < nright and right[j] < val:
+    while i < nleft:
+        while j < nright and rptr[j] < lptr[i]:
             j += 1
 
         if j == nright:
             break
 
-        if val == right[j]:
+        if lptr[i] == rptr[j]:
             count += 1
             i += 1
             j += 1
         else:
-            while left[i] < right[j]:
+            while lptr[i] < rptr[j]:
                 i += 1
 
     # do it again now that result size is known
@@ -484,30 +485,30 @@ def inner_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
     rindexer = np.empty(count, dtype=np.int32)
     result = np.empty(count, dtype=np.int64)
 
+    cdef int32_t *liptr = <int32_t*> lindexer.data
+    cdef int32_t *riptr = <int32_t*> rindexer.data
+    cdef int64_t *resptr = <int64_t*> result.data
+
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
-            break
-
-        val = left[i]
-
-        while j < nright and right[j] < val:
+    while i < nleft:
+        val = lptr[i]
+        while j < nright and rptr[j] < val:
             j += 1
 
         if j == nright:
             break
 
-        if val == right[j]:
-            lindexer[count] = i
-            rindexer[count] = j
-            result[count] = val
+        if val == rptr[j]:
+            liptr[count] = i
+            riptr[count] = j
+            resptr[count] = val
             count += 1
             i += 1
             j += 1
         else:
-            while left[i] < right[j]:
+            while lptr[i] < rptr[j]:
                 i += 1
 
     return result, lindexer, rindexer
@@ -637,6 +638,46 @@ def take_axis0(ndarray[float64_t, ndim=2] values,
             for j from 0 <= j < k:
                 outbuf[i, j] = values[idx, j]
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_join_contiguous(ndarray[float64_t, ndim=2] lvalues,
+                         ndarray[float64_t, ndim=2] rvalues,
+                         ndarray[int32_t] lindexer,
+                         ndarray[int32_t] rindexer,
+                         ndarray out):
+    cdef:
+        Py_ssize_t i, j, rk, lk, n, lidx, ridx
+        float64_t *outbuf
+
+    assert(out.flags.contiguous)
+
+    outbuf = <float64_t*> out.data
+
+    n = len(lindexer)
+    lk = lvalues.shape[1]
+    rk = rvalues.shape[1]
+
+    for i from 0 <= i < n:
+        lidx = lindexer[i]
+        ridx = rindexer[i]
+
+        if lidx == -1:
+            for j from 0 <= j < lk:
+                outbuf[0] = NaN
+                outbuf = outbuf + 1
+        else:
+            for j from 0 <= j < lk:
+                outbuf[0] = lvalues[lidx, j]
+                outbuf = outbuf + 1
+
+        if lidx == -1:
+            for j from 0 <= j < rk:
+                outbuf[0] = NaN
+                outbuf = outbuf + 1
+        else:
+            for j from 0 <= j < rk:
+                outbuf[0] = rvalues[ridx, j]
+                outbuf = outbuf + 1
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
diff --git a/scripts/bench_join.py b/scripts/bench_join.py
index c4dd6d776..4ab81067c 100644
--- a/scripts/bench_join.py
+++ b/scripts/bench_join.py
@@ -85,19 +85,22 @@ def do_outer_join_multi(a, b, av, bv):
     n, ak = av.shape
     _, bk = bv.shape
     result_index, rindexer, lindexer = lib.outer_join_indexer(a, b)
-    result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
-    lib.take_axis0(av, rindexer, out=result[:ak].T)
-    lib.take_axis0(bv, lindexer, out=result[ak:].T)
+    result = np.empty((len(result_index), ak + bk), dtype=np.float64)
+    lib.take_join_contiguous(av, bv, lindexer, rindexer, result)
+    # result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
+    # lib.take_axis0(av, rindexer, out=result[:ak].T)
+    # lib.take_axis0(bv, lindexer, out=result[ak:].T)
     return result_index, result
 
 def do_inner_join_multi(a, b, av, bv):
     n, ak = av.shape
     _, bk = bv.shape
     result_index, rindexer, lindexer = lib.inner_join_indexer(a, b)
-    result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
-
-    lib.take_axis0(av, rindexer, out=result[:ak].T)
-    lib.take_axis0(bv, lindexer, out=result[ak:].T)
+    result = np.empty((len(result_index), ak + bk), dtype=np.float64)
+    lib.take_join_contiguous(av, bv, lindexer, rindexer, result)
+    # result = np.empty((ak + bk, len(result_index)), dtype=np.float64)
+    # lib.take_axis0(av, rindexer, out=result[:ak].T)
+    # lib.take_axis0(bv, lindexer, out=result[ak:].T)
     return result_index, result
 
 def do_left_join_multi_v2(a, b, av, bv):

commit db96059254f8e8aaab1ef7efa925db6d7a54690e
Author: Adam Klein <adamklein@gmail.com>
Date:   Tue Jan 31 18:55:48 2012 -0500

    cannibalizing scikits timeries

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index ccb0d00ec..f731dac75 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -92,6 +92,18 @@ cdef extern from "np_datetime_strings.h":
 
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
 
+cdef extern from "timeseries/c_types.h":
+
+    ctypedef struct ts_metadata:
+        int unit
+        int timestep
+        int period_end_at
+        int64_t periods_per_day
+        int64_t secs_per_period
+        int convert_to_start
+
+    ctypedef int64_t ts_datetime
+
 cdef extern from "stdint.h":
     enum: INT64_MIN
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 0aa6083ec..4c8b93c84 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -220,48 +220,18 @@ cdef class Timestamp:
 
 
 cdef class Interval:
-    """
-    An absolute time span, from one timestamp to another. Normalized
-    to seconds, microseconds, and days.
+    """ 
+    This class replicates design of the Date object from scikits.timeseries,
+    where a frequency is attached. The internal integer value of represents the
+    offset, in the provided frequency, from the gregorian proleptic date of Jan
+    1, 1AD.
     """
     cdef:
-        Timestamp start
-        Timestamp end
-
-    def __init__(self, Timestamp start, Timestamp end):
-        self.start = start
-        self.end = end
-
-    property start:
-        def __get__(self):
-            return self.start
-
-    property end:
-        def __get__(self):
-            return self.end
+        ts_metadata obmeta  # recreating structure of DatetimeObject 
+        ts_datetime obval   # from sckits.timeseries
 
-    property length:
-        def __get__(self):
-            cdef int64_t diff = self.end.asint - self.start.asint
-            return diff
-
-    property microseconds:
-        def __get__(self):
-            cdef int64_t diff = self.end.asint - self.start.asint
-            return diff % 1000000
-
-    property seconds:
-        def __get__(self):
-            cdef int64_t diff = self.end.asint - self.start.asint
-            return (diff // 1000000) % 86400
-
-    property days:
-        def __get__(self):
-            cdef int64_t diff = self.end.asint - self.start.asint
-            return (diff // 1000000) // 86400
-
-    def __str__(self):
-        return "Interval(%s, %s)" % (str(self.start), str(self.end))
+    def __init__(self):
+        pass
 
 
 cdef class Duration:
diff --git a/pandas/src/timeseries/c_convert.c b/pandas/src/timeseries/c_convert.c
deleted file mode 100644
index e778f421a..000000000
--- a/pandas/src/timeseries/c_convert.c
+++ /dev/null
@@ -1,749 +0,0 @@
-#include "c_lib.h"
-#include "c_types.h"
-#include "c_freqs.h"
-#include "c_convert.h"
-
-#include <Python.h>
-// #include <datetime.h>
-#include <time.h>
-
-
-/* ---------------------------------------------------------------------------
- * Normalization utilities (from Python/datetime.c).
- */
-
-/* Compute Python divmod(x, y), returning the quotient and storing the
- * remainder into *r.  The quotient is the floor of x/y, and that's
- * the real point of this.  C will probably truncate instead (C99
- * requires truncation; C89 left it implementation-defined).
- * Simplification:  we *require* that y > 0 here.  That's appropriate
- * for all the uses made of it.  This simplifies the code and makes
- * the overflow case impossible (divmod(LONG_MIN, -1) is the only
- * overflow case).
- */
-static npy_int64
-divmod(npy_int64 x, npy_int64 y, npy_int64 *r)
-{
-    npy_int64 quo;
-
-    assert(y > 0);
-    quo = x / y;
-    *r = x - quo * y;
-    if (*r < 0) {
-        --quo;
-        *r += y;
-    }
-    assert(0 <= *r && *r < y);
-    return quo;
-}
-/* Modified in order to deal with negative seconds higher than -day
- */
-static void
-normalize_pair(npy_int64 *hi, npy_int64 *lo, int factor)
-{
-    assert(factor > 0);
-    assert(lo != hi);
-    if (*lo <= -factor || *lo >= factor) {
-        const npy_int64 num_hi = divmod(*lo, factor, lo);
-        const npy_int64 new_hi = *hi + num_hi;
-        assert(! SIGNED_ADD_OVERFLOWED(new_hi, *hi, num_hi));
-        *hi = new_hi;
-    }
-    assert(-factor < *lo && *lo < factor);
-}
-
-
-
-
-/* Return the number of high unit periods per day*/
-npy_int64 highunits_per_day(int freq){
-    switch(freq)
-    {
-        case FR_DAY:
-            return 1;
-        case FR_HR:
-            return 24;
-        case FR_MIN:
-            return 24*60;
-        case FR_SEC:
-            return 24*60*60;
-        default:
-            return 24*60*60 - 1;
-    };
-}
-
-npy_int64 secs_per_highunits(int freq, npy_int64 multiplier)
-{
-    switch(freq)
-    {
-    case FR_SEC:
-        return multiplier;
-    case FR_MIN:
-        return 60 * multiplier;
-    case FR_HR:
-        return 3600 * multiplier;
-    case FR_DAY:
-        return 86400 * multiplier;
-    default:
-        return 0;
-    }
-}
-
-npy_int64 seconds_per_period(int freq, npy_int64 multiplier)
-{
-    switch(freq)
-    {
-        case FR_DAY:
-            return multiplier * 86400;
-        case FR_HR:
-             return multiplier * 3600;
-        case FR_MIN:
-            return multiplier * 60;
-        case FR_SEC:
-             return multiplier;
-    };
-	return -1;
-}
-
-
-
-/* Returns the quarter */
-#define month_to_quarter(month) (((month)-1)/3 + 1)
-#define quarter_to_month(quarter) (((quarter)-1)*3 + 1)
-
-
-
-/*
-    Functions in the following section are borrowed from mx.DateTime version
-    2.0.6, and hence this code is subject to the terms of the egenix public
-    license version 1.0.0
-*/
-
-#define SECONDS_PER_DAY ((double) 86400.0)
-
-
-/* Table with day offsets for each month (0-based, without and with leap) */
-static int month_offset[2][13] = {
-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
-};
-
-/* Table of number of days in a month (0-based, without and with leap) */
-static int days_in_month[2][12] = {
-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
-};
-
-
-
-/* Return the day of the week for the given absolute date. */
-int day_of_week(npy_int64 absdate) {
-    int day_of_week;
-    if (absdate >= 1) {
-        day_of_week = (absdate - 1) % 7;
-    }
-    else {
-        day_of_week = 6 - ((-absdate) % 7);
-    }
-    return day_of_week;
-}
-
-/* Return the year offset, that is the absolute date of the day
-   31.12.(year-1) in the given calendar.
-
-   Note:
-   For the Julian calendar we shift the absdate (which is measured
-   using the Gregorian Epoch) value by two days because the Epoch
-   (0001-01-01) in the Julian calendar lies 2 days before the Epoch in
-   the Gregorian calendar. */
-npy_int64
-year_offset(npy_int64 year, int calendar)
-{
-    year--;
-    if (calendar == GREGORIAN_CALENDAR) {
-        if (year >= 0 || -1/4 == -1)
-            return year*365 + year/4 - year/100 + year/400;
-        else
-            return year*365 + (year-3)/4 - (year-99)/100 + (year-399)/400;
-    }
-    else if (calendar == JULIAN_CALENDAR) {
-        if (year >= 0 || -1/4 == -1)
-            return year*365 + year/4 - 2;
-        else
-            return year*365 + (year-3)/4 - 2;
-    }
-//    Py_Error(DateCalc_Error, "unknown calendar");
-// onError:
-    return -1;
-}
-
-
-
-/* Set the instance's value using the given date and time. calendar
-   may be set to the flags: GREGORIAN_CALENDAR,
-   JULIAN_CALENDAR to indicate the calendar to be used. */
-
-npy_int64
-days_from_ymdc(int year, int month, int day, int calendar)
-{
-    int leap;
-    npy_int64 yearoffset, absdate;
-
-    /* Range check */
-    Py_AssertWithArg(year > -(INT_MAX / 366) && year < (INT_MAX / 366),
-                     DateCalc_RangeError,
-                     "year out of range: %i",
-                     year);
-
-    /* Is it a leap year ? */
-    leap = is_leapyear(year);
-
-    /* Negative month values indicate months relative to the years end */
-    if (month < 0) month += 13;
-    Py_AssertWithArg(month >= 1 && month <= 12,
-                     DateCalc_RangeError,
-                     "month out of range (1-12): %i",
-                     month);
-
-    /* Negative values indicate days relative to the months end */
-    if (day < 0) day += days_in_month[leap][month - 1] + 1;
-    Py_AssertWithArg(day >= 1 && day <= days_in_month[leap][month - 1],
-                     DateCalc_RangeError,
-                     "day out of range: %i",
-                     day);
-
-    /* Nb of days between Dec. 31 (YYYY - 1) and Dec. 31 1969 */
-    yearoffset = year_offset(year,calendar);
-    if (PyErr_Occurred()) goto onError;
-
-    absdate = day + month_offset[leap][month - 1] + yearoffset;
-    return absdate;
-
- onError:
-    return -1;
-    /* return 0; That's what numpy uses */
-}
-
-#define days_from_ymd(year, month, day) (days_from_ymdc((year), (month), (day), GREGORIAN_CALENDAR))
-
-
-double
-secs_from_ranged_hms(int hour, int minute, double second)
-{
-    Py_AssertWithArg(hour >= 0 && hour <= 23,
-                     DateCalc_RangeError,
-                     "hour out of range (0-23): %i",
-                     hour);
-    Py_AssertWithArg(minute >= 0 && minute <= 59,
-                     DateCalc_RangeError,
-                     "minute out of range (0-59): %i",
-                     minute);
-    Py_AssertWithArg(second >= (double)0.0 &&
-                     (second < (double)60.0 ||
-                     (hour == 23 && minute == 59 && second < (double)61.0)),
-                     DateCalc_RangeError,
-                     "second out of range (0.0 - <60.0; <61.0 for 23:59): %f",
-                     second);
-    return secs_from_hms(hour, minute, second, 1);
-
- onError:
-    return -1;
-    /* return 0; (the numpy way) */
-}
-
-
-/* from numpy/datetime.c (reference: 1CE) */
-//static
-ymdstruct
-days_to_ymdstruct(npy_int64 absdate, int calendar)
-{
-    ymdstruct ymd;
-    npy_int64 year;
-    npy_int64 yearoffset;
-    int leap, dayoffset;
-    int month = 1, day = 1;
-    int *monthoffset;
-
-    /* Approximate year */
-    if (calendar == JULIAN_CALENDAR) {
-        year = absdate / 365.25;
-    } else {
-        year = absdate / 365.2425;
-    };
-    if (absdate > 0) year++;
-
-    /* Apply corrections to reach the correct year */
-    while (1) {
-        /* Calculate the year offset */
-        yearoffset = year_offset(year, calendar);
-        /*
-         * Backward correction: absdate must be greater than the
-         * yearoffset
-         */
-        if (yearoffset >= absdate) {
-            year--;
-            continue;
-        }
-        leap = is_leapyear(year);
-
-        dayoffset = absdate - yearoffset;
-        /* Forward correction: non leap years only have 365 days */
-        if (dayoffset > 365 && !leap) {
-            year++;
-            continue;
-        }
-        break;
-    }
-
-    /* Now iterate to find the month */
-    monthoffset = month_offset[leap];
-    for (month = 1; month < 13; month++) {
-        if (monthoffset[month] >= dayoffset)
-            break;
-    }
-    day = dayoffset - month_offset[leap][month-1];
-
-    ymd.year  = year;
-    ymd.month = month;
-    ymd.day   = day;
-    ymd.day_of_year = dayoffset;
-
-    return ymd;
-};
-
-
-static int
-isoweek_from_ymdc(int year, int month, int day, int calendar)
-{
-    int week;
-    npy_int64 yearoffset = year_offset(year, calendar);
-    npy_int64 absdate = days_from_ymdc(year, month, day, calendar);
-    npy_int64 dayofweek = day_of_week(absdate);
-
-    /* Estimate*/
-    week = (absdate - yearoffset - 1) - dayofweek + 3;
-    if (week >= 0)
-        week = week / 7 + 1;
-
-    /* Verify */
-    if (week < 0){
-        /* The day lies in last week of the previous year */
-        if ((week > -2) ||
-            (week == -2 && is_leapyear(year-1)))
-            week = 53;
-        else
-            week = 52;
-    }
-    else if (week == 53) {
-        /* Check if the week belongs to year or year+1 */
-        if (31 - day + dayofweek < 3)
-            week = 1;
-    }
-    return week;
-};
-
-int isoweek_from_datetimestruct(ts_datetimestruct *dinfo)
-{
-	return isoweek_from_ymdc(dinfo->year,
-                             dinfo->month,
-                             dinfo->day,
-                             GREGORIAN_CALENDAR);
-}
-
-
-
-hmsstruct
-seconds_to_hmsstruct(npy_int64 abstime)
-{
-    int hour, minute, second;
-    hmsstruct hms;
-
-    hour   = abstime / 3600;
-    minute = (abstime % 3600) / 60;
-    second = abstime - (hour*3600 + minute*60);
-
-    hms.hour   = hour;
-    hms.min = minute;
-    hms.sec = second;
-
-    return hms;
-};
-
-
-void set_datetimestruct_from_days(ts_datetimestruct *info, npy_int64 days)
-{
-    ymdstruct ymd = days_to_ymdstruct(days, GREGORIAN_CALENDAR);
-    info->year = ymd.year;
-    info->month = ymd.month;
-    info->day = ymd.day;
-    info->day_of_year = ymd.day_of_year;
-}
-
-void set_datetimestruct_from_secs(ts_datetimestruct *info, npy_int64 secs)
-{
-    hmsstruct hms = seconds_to_hmsstruct(secs);
-    info->hour = hms.hour;
-    info->min = hms.min;
-    info->sec = hms.sec;
-}
-
-void set_datetimestruct_from_days_and_secs(ts_datetimestruct *info,
-                                           npy_int64 days,
-                                           npy_int64 secs)
-{
-    set_datetimestruct_from_days(info, days);
-    set_datetimestruct_from_secs(info, secs);
-}
-
-
-
-
-
-/* Helpers for frequency conversion routines */
-#define _days_to_bus_weekday(days) ((((days)/ 7) * 5) + (absdate) % 7)
-
-static long _days_to_bus_weekend_to_monday(long absdate, int day_of_week) 
-{
-    if (day_of_week > 4) {
-        //change to Monday after weekend
-        absdate += (7 - day_of_week);
-    };
-    return _days_to_bus_weekday(absdate);
-};
-
-static long _days_to_bus_weekend_to_friday(long absdate, int day_of_week) 
-{
-    if (day_of_week > 4) {
-        //change to friday before weekend
-        absdate -= (day_of_week - 4);
-    };
-    return _days_to_bus_weekday(absdate);
-};
-
-
-/* --- Conversion routines                                                  */
-
-static npy_int64
-missing_convert(npy_int64 indate, ts_metadata *meta) { return -1;}
-
-static npy_int64
-no_convert(npy_int64 indate, ts_metadata *meta) { return indate;}
-
-
-/* From days to other units ................................................*/
-
-/* Returns the month ending the current annual/quarterly freq */
-int ending_month(ts_metadata *meta)
-{
-    int end = ((meta->unit < FR_MTH) * (meta->period_end_at)) % 12;
-    return (end == 0 ? 12: end);
-}
-/* Returns the day ending the current weekly freq */
-int ending_day(ts_metadata *meta) {
-    return (meta->unit == FR_WK) * (meta->period_end_at);
-}
-
-static npy_int64
-_days_to_years(npy_int64 indate, ts_metadata *meta)
-{
-    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
-    int end_month = ending_month(meta);
-    return (ymd.month > end_month ? ymd.year + 1: ymd.year);
-}
-
-static npy_int64
-_days_to_quarters(npy_int64 indate, ts_metadata *meta)
-{
-    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
-    int end_month = ending_month(meta);
-    int year = ymd.year;
-    int month = ymd.month;
-    if (end_month != 12){
-        month -= end_month;
-        if (month <= 0)
-            month += 12;
-        else
-            year += 1;
-    }
-    int quarter = month_to_quarter(month);
-    return (year - 1) * 4 + quarter;
-}
-
-static npy_int64
-_days_to_months(npy_int64 indate, ts_metadata *meta)
-{
-    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
-    return (ymd.year - 1) * 12 + ymd.month;
-}
-
-static npy_int64
-_days_to_weeks(npy_int64 indate, ts_metadata *meta)
-{
-//    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
-    int weekend = ending_day(meta);
-    return (indate - (1 + weekend))/7 + 1;
-}
-
-static npy_int64
-_days_to_bus(npy_int64 indate, ts_metadata *meta)
-{
-    int dayofweek = day_of_week(indate);
-    if (meta->convert_to_start)
-        return _days_to_bus_weekend_to_friday(indate, dayofweek);
-    else
-        return _days_to_bus_weekend_to_monday(indate, dayofweek);
-}
-
-static npy_int64
-_days_to_bus_batch(npy_int64 indate, ts_metadata *meta)
-{
-    int dayofweek = day_of_week(indate);
-    if (dayofweek > 4)
-        return -1;
-    else if (meta->convert_to_start)
-        return _days_to_bus_weekend_to_friday(indate, dayofweek);
-    else
-        return _days_to_bus_weekend_to_monday(indate, dayofweek);
-};
-
-
-static npy_int64
-_days_to_days(npy_int64 indate, ts_metadata *meta)
-{
-    return indate;
-}
-
-static npy_int64
-_days_to_highfreq(npy_int64 indate, ts_metadata *meta)
-{
-npy_int64 periods_per_day = meta->periods_per_day;
-    if (meta->convert_to_start)
-        return (indate - HIGHFREQ_ORIG) * periods_per_day;
-    else
-        return (indate - HIGHFREQ_ORIG + 1) * periods_per_day - 1;
-}
-
-conversion_function get_converter_from_days(int fromunit, int inbatch)
-{
-    int ubase = get_base_unit(fromunit);
-    
-    if (ubase == FR_ANN)
-        return &_days_to_years;
-    else if (ubase == FR_QTR)
-        return &_days_to_quarters;
-    else if (ubase == FR_MTH)
-        return &_days_to_months;
-    else if (ubase == FR_WK)
-        return &_days_to_weeks;
-    else if (ubase == FR_BUS)
-        if (inbatch)
-            return &_days_to_bus_batch;
-        else
-            return &_days_to_bus;
-    else if ((ubase == FR_DAY) || (ubase == FR_UND))
-        return &_days_to_days;
-    else if (ubase > FR_DAY)
-        return &_days_to_highfreq;
-    return &missing_convert;
-}
-
-
-
-
-static npy_int64
-_days_from_years(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 absdate, year;
-    int final_adj;
-    int end_month = ending_month(meta);
-    int month = end_month % 12;
-    month = (month == 0 ? 1 : month+1);
-
-    if (meta->convert_to_start){
-        year = (end_month == 12 ? indate: indate-1);
-        final_adj = 0;
-    }
-    else {
-        year = (end_month == 12 ? indate+1: indate);
-        final_adj = -1;
-    }
-    absdate = days_from_ymd(year, month, 1);
-    if (absdate  == INT_ERR_CODE)
-        return INT_ERR_CODE;
-    return absdate + final_adj;
-}
-
-static npy_int64
-_days_from_quarters(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 absdate;
-    int year, month, final_adj;
-    int end_month = ending_month(meta);
-
-    if (meta->convert_to_start) {
-        year = (indate - 1)/4 + 1;
-        month = (indate + 4)*3 - 12*year -2;
-        final_adj = 0;
-    }
-    else {
-        year = indate/4 + 1;
-        month = (indate + 5)*3 - 12*year -2;
-        final_adj = -1;
-    };
-    if (end_month != 12){
-        month += end_month;
-        if (month > 12)
-            month -= 12;
-        else
-            year -= 1;
-    }
-    absdate = days_from_ymd(year, month, 1);
-    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
-    return absdate + final_adj;
-}
-
-static npy_int64
-_days_from_months(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 absdate;
-    int year, month, final_adj;
-
-    if (meta->convert_to_start){
-        year = (indate - 1)/12 + 1;
-        month = indate - 12*year - 1;
-        final_adj = 0;
-    }
-    else {
-        year = indate/12 + 1;
-        month = indate - 12*year;
-        final_adj = -1;
-    }
-    absdate = days_from_ymd(year, month, 1);
-    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
-    return absdate + final_adj;
-}
-
-
-static npy_int64
-_days_from_weeks(npy_int64 indate, ts_metadata *meta)
-{
-    int weekend = meta->period_end_at;
-    if (meta->convert_to_start)
-        return indate*7 - 6 + weekend;
-    else
-        return indate*7 + weekend;
-}
-
-static npy_int64
-_days_from_busdays(npy_int64 indate, ts_metadata *meta)
-{
-    return ((indate-1)/5)*7 + (indate-1)%5 + 1;
-}
-
-npy_int64
-_days_from_highfreq(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 periods_per_day = meta->periods_per_day;
-    if (indate < 0)
-        return (indate + 1)/periods_per_day + HIGHFREQ_ORIG - 1;
-    else
-        return indate/periods_per_day + HIGHFREQ_ORIG;
-}
-
-conversion_function get_converter_to_days(int fromunit, int inbatch)
-{
-//    int ubase = get_base_unit(fromunit);
-    if (fromunit == FR_ANN)
-        return &_days_from_years;
-    else if (fromunit == FR_QTR)
-        return &_days_from_quarters;
-    else if (fromunit == FR_MTH)
-        return &_days_from_months;
-    else if (fromunit == FR_WK)
-        return &_days_from_weeks;
-    else if (fromunit == FR_BUS)
-        return &_days_from_busdays;
-    else if ((fromunit == FR_DAY) || (fromunit == FR_UND))
-        return &no_convert;
-    else if (fromunit > FR_DAY)
-        return &_days_from_highfreq;
-    return &missing_convert;
-}
-
-
-
-
-/* From seconds */
-
-npy_int64
-_secs_from_highfreq(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 secs_per_period = meta->secs_per_period;
-    if (meta->convert_to_start)
-        return indate*secs_per_period;
-    else
-        return (indate + 1)*secs_per_period - 1;
-}
-
-npy_int64
-_secs_from_midnight(npy_int64 indate, int unit)
-{
-    npy_int64 secs, secs_per_period;
-    unit = (unit/1000)*1000;
-    if (unit > FR_DAY)
-        secs_per_period = secs_per_highunits(unit, 1);
-    else
-        secs_per_period = 0;
-    secs=(indate * secs_per_period) % 86400;
-    if (secs < 0)
-        secs += 86400;
-    return secs;
-}
-
-npy_int64
-_secs_to_highfreq(npy_int64 indate, ts_metadata *meta)
-{
-    npy_int64 secs_per_period = meta->secs_per_period;
-    if (indate < 0)
-        return (indate + 1)/secs_per_period - 1;
-    else
-        return indate/secs_per_period;
-}
-
-
-
-conversion_function convert_to_mediator(int fromunit, int tounit, int inbatch)
-{
-    if ((fromunit > FR_DAY) && (tounit > FR_DAY))
-        return &_secs_from_highfreq;
-    else
-        return *get_converter_to_days(fromunit, inbatch);
-}
-
-conversion_function convert_from_mediator(int fromunit, int tounit, int inbatch)
-{
-    if ((tounit == FR_DAY) || (tounit == FR_UND))
-        return &no_convert;
-    else if (tounit > FR_DAY)
-        if (fromunit <= FR_DAY)
-            return *get_converter_from_days(tounit, 0);
-        else
-            return &_secs_to_highfreq;
-    else
-        return *get_converter_from_days(tounit, 0);
-}
-
-
-
-void normalize_days_secs(npy_int64 *d, npy_int64 *s)
-{
-    if (*s <= -86400 || *s >= 86400)
-        normalize_pair(d, s, 86400);
-}
-void normalize_years_months(npy_int64 *y, npy_int64 *m)
-{
-    normalize_pair(y, m, 12);
-    m += 1;
-}
-
-
diff --git a/pandas/src/timeseries/c_datearray.c b/pandas/src/timeseries/c_datearray.c
deleted file mode 100644
index e4cf50e92..000000000
--- a/pandas/src/timeseries/c_datearray.c
+++ /dev/null
@@ -1,1462 +0,0 @@
-#include "c_freqs.h"
-#include "c_convert.h"
-#include "c_dates.h"
-#include "c_datearray.h"
-#include <datetime.h>
-#include <time.h>
-
-#include "c_lib.h"
-
-
-static PyTypeObject DatetimeArray_Type;
-
-int PyArray_TS_DATETIME;
-
-#define TS_METADATA_DTSTR "timeunit"
-
-typedef struct {
-   PyObject_HEAD;
-   ts_datetime obval;
-   ts_metadata obmeta;
-} DatetimeScalarObject;
-
-//NPY_NO_EXPORT PyTypeObject DatetimeArrType_Type = {
-//#if defined(NPY_PY3K)
-//    PyVarObject_HEAD_INIT(NULL, 0)
-//#else
-//    PyObject_HEAD_INIT(NULL)
-//    0,                                          /* ob_size */
-//#endif
-////    "timeseries.datetime" _THIS_SIZE,                  /* tp_name*/
-//    "timeseries.datetime",                  /* tp_name*/
-//    sizeof(DatetimeScalarObject),               /* tp_basicsize*/
-//    0,                                          /* tp_itemsize */
-//    0,                                          /* tp_dealloc */
-//    0,                                          /* tp_print */
-//    0,                                          /* tp_getattr */
-//    0,                                          /* tp_setattr */
-//#if defined(NPY_PY3K)
-//    0,                                          /* tp_reserved */
-//#else
-//    0,                                          /* tp_compare */
-//#endif
-//    0,                                          /* tp_repr */
-//    0,                                          /* tp_as_number */
-//    0,                                          /* tp_as_sequence */
-//    0,                                          /* tp_as_mapping */
-//    0,                                          /* tp_hash */
-//    0,                                          /* tp_call */
-//    0,                                          /* tp_str */
-//    0,                                          /* tp_getattro */
-//    0,                                          /* tp_setattro */
-//    0,                                          /* tp_as_buffer */
-//    0,                                          /* tp_flags */
-//    0,                                          /* tp_doc */
-//    0,                                          /* tp_traverse */
-//    0,                                          /* tp_clear */
-//    0,                                          /* tp_richcompare */
-//    0,                                          /* tp_weaklistoffset */
-//    0,                                          /* tp_iter */
-//    0,                                          /* tp_iternext */
-//    0,                                          /* tp_methods */
-//    0,                                          /* tp_members */
-//    0,                                          /* tp_getset */
-//    0,                                          /* tp_base */
-//    0,                                          /* tp_dict */
-//    0,                                          /* tp_descr_get */
-//    0,                                          /* tp_descr_set */
-//    0,                                          /* tp_dictoffset */
-//    0,                                          /* tp_init */
-//    0,                                          /* tp_alloc */
-//    0,                                          /* tp_new */
-//    0,                                          /* tp_free */
-//    0,                                          /* tp_is_gc */
-//    0,                                          /* tp_bases */
-//    0,                                          /* tp_mro */
-//    0,                                          /* tp_cache */
-//    0,                                          /* tp_subclasses */
-//    0,                                          /* tp_weaklist */
-//    0,                                          /* tp_del */
-//#if PY_VERSION_HEX >= 0x02060000
-//    0,                                          /* tp_version_tag */
-//#endif
-//};
-//
-//#undef _THIS_SIZE
-///**/
-
-
-
-
-#if PY_VERSION_HEX >= 0x02070000
-#define get_metadata_from_descr(descr)  \
-    ((descr->metadata == NULL) ? \
-     NULL :                                       \
-    ((ts_metadata *)(PyCapsule_GetPointer(                   \
-                     PyDict_GetItemString(descr->metadata, TS_METADATA_DTSTR), \
-                     NULL))))
-#else
-#define get_metadata_from_descr(descr)  \
-    ((descr->metadata == NULL) ? \
-     NULL :                                       \
-     ((ts_metadata *)(PyCObject_AsVoidPtr(                    \
-                      PyDict_GetItemString(descr->metadata, TS_METADATA_DTSTR)))))
-#endif
-
-#define asarray(self) ( ((PyArrayObject *)self) )
-#define get_base(self) ( ((PyArrayObject *)self)->base )
-#define asndarray(self) ( asarray(get_base(self)) )
-#define get_descr(self) ( ((PyArrayObject *)self)->descr )
-#define get_metadata_from_array(self) (get_metadata_from_descr(get_descr(self)))
-//#define get_timestep(self) (get_metadata_from_array(self)->timestep)
-
-
-#define TS_METADATA_DTSTR "timeunit"
-
-//----------------------------------------------------------------------------
-/* from private/npy_3kcompat.h */
-#if PY_VERSION_HEX >= 0x02070000
-
-static NPY_INLINE PyObject *
-NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(PyObject *))
-{
-    PyObject *ret = PyCapsule_New(ptr, NULL, dtor);
-    if (ret == NULL) {
-        PyErr_Clear();
-    }
-    return ret;
-}
-
-static void
-simple_capsule_dtor(PyObject *cap)
-{
-    PyArray_free(PyCapsule_GetPointer(cap, NULL));
-}
-
-#else
-
-static NPY_INLINE PyObject *
-NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(void *))
-{
-    return PyCObject_FromVoidPtr(ptr, dtor);
-}
-
-static void
-simple_capsule_dtor(void *ptr)
-{
-    PyArray_free(ptr);
-}
-
-#endif
-/**/
-
-
-#include "numpy/noprefix.h"
-
-static void
-init_descr_metadata(PyArray_Descr *descr)
-{
-    ts_metadata *dt_data;
-    PyObject *cobj;
-
-    dt_data = _pya_malloc(sizeof(ts_metadata));
-    dt_data->unit = FR_UND;
-    dt_data->timestep = 1;
-    dt_data->period_end_at = 0;
-    dt_data->periods_per_day = -1;
-    dt_data->secs_per_period = -1;
-    dt_data->convert_to_start = 0;
-
-/* FIXME
- * There is no error check here and no way to indicate an error
- * until the metadata turns up NULL.
- */
-    cobj = NpyCapsule_FromVoidPtr((void *)dt_data, simple_capsule_dtor);
-    descr->metadata = PyDict_New();
-    PyDict_SetItemString(descr->metadata, TS_METADATA_DTSTR, cobj);
-    Py_DECREF(cobj);
-
-}
-
-static void
-update_descr_metadata(PyArray_Descr *descr, ts_metadata *meta) {
-    PyObject *cobj;
-    cobj = NpyCapsule_FromVoidPtr((void *)meta, simple_capsule_dtor);
-    descr->metadata = PyDict_New();
-    PyDict_SetItemString(descr->metadata, TS_METADATA_DTSTR, cobj);
-    Py_DECREF(cobj);
-}
-
-
-//-----------------------------------------------------------------------------
-
-static PyObject *
-DatetimeArray_new(PyTypeObject *cls, PyObject *args, PyObject *kw)
-{
-    static char *kwlist[] = {"object", "unit", "timestep", "freq", NULL};
-
-    PyObject *obj;
-    PyArrayObject *arr = NULL;
-    PyObject *unit = NULL, *freq=NULL;
-    int timestep = 1;
-    DatetimeArrayObject *self;
-    PyArray_Descr *descr;
-
-    if(!PyArg_ParseTupleAndKeywords(args, kw,"O|OiO",kwlist,
-                                    &obj,
-                                    &unit, &timestep, &freq))
-        return NULL;
-
-    arr = (PyArrayObject *)PyArray_FROM_O(obj);
-    if(arr == NULL)
-        return NULL;
-//    DEBUGPRINTF("We have an array...");
-
-    descr = PyArray_DescrNewFromType(PyArray_INT64);
-    if (descr == NULL)
-        return NULL;
-    Py_INCREF(descr);
-    init_descr_metadata(descr);
-
-    self = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
-                                                       descr,
-                                                       arr->nd, arr->dimensions,
-                                                       arr->strides,
-                                                       arr->data,
-                                                       arr->flags,
-                                                       (PyObject *)arr);
-    if(self == NULL)
-        return NULL;
-    Py_INCREF(arr);
-    PyArray_BASE(self) = (PyObject *)arr;
-
-    if (PyObject_SetAttrString((PyObject *)self, "dtype", (PyObject *)descr) < 0) {
-        goto fail;
-    }
-
-    ts_metadata *obmeta = get_metadata_from_descr(descr);
-
-    if (unit == NULL){
-        if (freq == NULL)
-            freq = PyInt_FromLong(FR_UND);
-        unit = freq;
-    }
-    int u = check_freq(unit);
-    if (u == -1)
-        goto fail;
-    init_metadata_from_unit(obmeta, u);
-
-    obmeta->timestep = timestep;
-
-    return (PyObject *)self;
-
- fail:
-    DEBUGPRINTF("Dropping it..");
-    Py_XDECREF(unit);
-    Py_XDECREF((PyObject*)self);
-    return NULL;
-}
-
-static DatetimeArrayObject *
-DatetimeArray_new_from_array_and_unit(PyArrayObject *data, int unit)
-{
-    DatetimeArrayObject *self;
-    PyArray_Descr *descr;
-    ts_metadata *obmeta;
-
-    descr = PyArray_DescrNewFromType(PyArray_INT64);
-    if (descr == NULL)
-        return NULL;
-    Py_INCREF(descr);
-    init_descr_metadata(descr);
-    obmeta = get_metadata_from_descr(descr);
-    init_metadata_from_unit(obmeta, unit);
-
-    self = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
-                                                       descr,
-                                                       data->nd,
-                                                       data->dimensions,
-                                                       data->strides,
-                                                       data->data,
-                                                       data->flags,
-                                                       (PyObject *)data);
-    Py_INCREF(data);
-    PyArray_BASE(self) = (PyObject *)data;
-    return self;
-}
-
-static void
-DatetimeArray_dealloc(DatetimeArrayObject *self)
-{
-//    DEBUGPRINTF("Dropping cache");
-//    Py_XDECREF(self->cached_vals);
-    DEBUGPRINTF("Dropping object");
-    self->base.ob_type->tp_free((PyObject*)self);
-}
-
-static PyObject*
-DatetimeArray_finalize(DatetimeArrayObject *self, PyObject *args)
-{
-    DatetimeArrayObject *context;
-    if(PyArg_ParseTuple(args, "O", &context))
-    {
-        if (DatetimeArray_Check(context)){
-            DEBUGPRINTF("in context from DTA");
-            PyArray_Descr *descr = get_descr(self);
-            Py_INCREF(descr);
-            ts_metadata *meta_context = get_metadata_from_array(context);
-            update_descr_metadata(descr, meta_context);
-        } else {
-            DEBUGPRINTF("in context from scratch");
-            init_descr_metadata(get_descr(self));
-        };
-        ts_timestatus default_status = {-1, -1, -1};
-        self->status = default_status;
-    }
-    PyErr_Clear();
-    DEBUGPRINTF("Returning w/ base unit %i...", get_metadata_from_array(self)->unit);
-    Py_RETURN_NONE;
-}
-
-
-
-static int
-_get_unit_from_descr(PyArray_Descr *descr) {
-    ts_metadata *meta = get_metadata_from_descr(descr);
-    return meta->unit + meta->period_end_at;
-}
-static int
-_get_unit_from_array(DatetimeArrayObject *self) {
-    ts_metadata *meta = get_metadata_from_descr(((PyArrayObject *)self)->descr);
-    return meta->unit + meta->period_end_at;
-}
-static PyObject *
-DatetimeArray_unit(DatetimeArrayObject *self){
-    int unit = _get_unit_from_array(self);
-    return PyInt_FromLong(unit);
-}
-static PyObject *
-DatetimeArray_timestep(DatetimeArrayObject *self){
-    ts_metadata *meta = get_metadata_from_descr(((PyArrayObject *)self)->descr);
-    return PyInt_FromLong(meta->timestep);
-}
-static PyObject *
-DatetimeArray_freqstr(DatetimeArrayObject *self) {
-    PyObject *key = DatetimeArray_unit(self);
-    PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
-    PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
-    Py_DECREF(key);
-    return main_alias;
-}
-
-static PyObject *
-DatetimeArray_steps(DatetimeArrayObject *self){
-    PyArrayObject *steps=NULL;
-    PyArrayIterObject *self_iter=NULL, *steps_iter=NULL;
-    npy_intp size = PyArray_SIZE(self) - 1;
-
-    steps = (PyArrayObject*)PyArray_ZEROS(1,
-                                          &size,
-                                          PyArray_INT64, 0);
-    if (steps == NULL)
-        goto fail;
-
-    steps_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)steps);
-    if (steps_iter == NULL)
-        goto fail;
-    self_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-    if (self_iter == NULL)
-        goto fail;
-
-    PyObject *val=NULL, *prev=NULL, *diff=NULL;
-    prev = PyArray_GETITEM(self, self_iter->dataptr);
-    PyArray_ITER_NEXT(self_iter);
-    while (steps_iter->index < steps_iter->size) {
-        val = PyArray_GETITEM(self, self_iter->dataptr);
-        diff = PyNumber_Subtract(val, prev);
-        PyArray_SETITEM(steps, steps_iter->dataptr, diff);
-        PyArray_ITER_NEXT(self_iter);
-        PyArray_ITER_NEXT(steps_iter);
-        prev = val;
-    };
-    Py_DECREF(self_iter);
-    Py_DECREF(steps_iter);
-    Py_XDECREF(prev);
-    Py_XDECREF(val);
-    Py_XDECREF(diff);
-    return (PyObject *)steps;
-
- fail:
-    DEBUGPRINTF("DatetimeArray.steps: Oops...");
-    Py_XDECREF(steps);
-    Py_XDECREF(steps_iter);
-    Py_XDECREF(self_iter);
-    return NULL;
-}
-
-
-
-static int
-DatetimeArray_check_status(DatetimeArrayObject *self)
-{
-    PyArrayIterObject *self_iter=NULL;
-    npy_int64 timestep, diff;
-    int is_chrono = 1, has_dups=0, has_missing=0;
-
-    timestep = get_metadata_from_array(self)->timestep;
-    self_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-    if (self_iter == NULL) {
-        Py_XDECREF(self_iter);
-        return -1;
-    }
-
-    PyObject *val=NULL, *prev=NULL, *odiff=NULL;
-    prev = PyArray_GETITEM(self, self_iter->dataptr);
-    PyArray_ITER_NEXT(self_iter);
-    while (self_iter->index < self_iter->size) {
-        val = PyArray_GETITEM(self, self_iter->dataptr);
-        odiff = PyNumber_Subtract(val, prev);
-        diff = PyInt_AsLong(odiff);
-        if (diff < 0)
-            is_chrono = 0;
-        else if (diff == 0)
-            has_dups = 1;
-        else if (diff > timestep)
-            has_missing = 1;
-        if (has_dups && has_missing)
-            break;
-        PyArray_ITER_NEXT(self_iter);
-        prev = val;
-    }
-    Py_XDECREF(self_iter);
-    Py_XDECREF(odiff);
-    Py_XDECREF(prev);
-    Py_XDECREF(val);
-    // Set the status
-//    self->status.has_dups = has_dups;
-//    self->status.has_missing = has_missing;
-//    self->status.is_chrono = is_chrono;
-    ts_timestatus status = {has_dups, has_missing, is_chrono};
-    self->status = status;
-    return 0;
-}
-static PyObject *
-DatetimeArray_has_dups(DatetimeArrayObject *self)
-{
-    if (self->status.has_dups == -1)
-        if (DatetimeArray_check_status(self) < 0)
-            return NULL;
-    if (self->status.has_dups == 0)
-        Py_RETURN_FALSE;
-    Py_RETURN_TRUE;
-}
-static PyObject *
-DatetimeArray_has_missing(DatetimeArrayObject *self)
-{
-    if (self->status.has_missing == -1)
-        if (DatetimeArray_check_status(self) < 0)
-            return NULL;
-    if (self->status.has_missing == 0)
-        Py_RETURN_FALSE;
-    Py_RETURN_TRUE;
-}
-static PyObject *
-DatetimeArray_is_chrono(DatetimeArrayObject *self)
-{
-    if (self->status.is_chrono == -1)
-        if (DatetimeArray_check_status(self) < 0)
-            return NULL;
-    if (self->status.is_chrono == 0)
-        Py_RETURN_FALSE;
-    Py_RETURN_TRUE;
-}
-static PyObject *
-DatetimeArray_is_full(DatetimeArrayObject *self)
-{
-    if (self->status.has_dups == -1)
-        if (DatetimeArray_check_status(self) < 0)
-            return NULL;
-    if (self->status.has_dups)
-        Py_RETURN_FALSE;
-    if (self->status.has_missing)
-        Py_RETURN_FALSE;
-    Py_RETURN_TRUE;
-}
-static PyObject *
-DatetimeArray_is_valid(DatetimeArrayObject *self)
-{
-    ts_timestatus status = self->status;
-    if (status.has_dups == -1)
-        if (DatetimeArray_check_status(self) < 0)
-            return NULL;
-    if (status.has_missing)
-        Py_RETURN_FALSE;
-    if (status.has_dups)
-        Py_RETURN_FALSE;
-    if (! status.is_chrono)
-        Py_RETURN_FALSE;
-    Py_RETURN_TRUE;
-}
-
-static PyMemberDef DatetimeArray_members[] = {
-//     {"cached_vals", T_OBJECT_EX, offsetof(DateTimeArray, cached_vals), 0,
-//      "cached_values"},
-    {NULL}  /* Sentinel */
-};
-
-
-static char *
-DEBUGGETTYPE(PyObject *obj){
-    char *type_str;
-    PyObject *type_repr, *obj_type;
-    obj_type = PyObject_Type(obj);
-    type_repr = PyObject_Repr(obj_type);
-    type_str = PyString_AsString(type_repr);
-//    DEBUGPRINTF("get_tsdatetime_from_object got %s [%i]", type_str, meta->unit);
-    Py_DECREF(obj_type);
-    Py_DECREF(type_repr);
-    return type_str;
-}
-
-
-static ts_datetime
-get_tsdatetime_from_object(ts_metadata *meta, PyObject *date){
-    ts_datetime value;
-    //
-    if (PyString_Check(date)) {
-        value = PyString_to_tsdatetime(meta, date);
-//        DEBUGPRINTF("get_tsdatetime_from_object.from string: %ld", value);
-    }
-    else if (PyDateTime_Check(date) || PyDate_Check(date)) {
-        value = PyDatetime_to_tsdatetime(meta, date);
-//        DEBUGPRINTF("get_tsdatetime_from_object.from datetime.datetime: %ld", value);
-    }
-    else if (DatetimeObject_Check(date)) {
-        value = ((DatetimeObject *)date)->obval;
-//        DEBUGPRINTF("get_tsdatetime_from_object.from tsdatetime: %ld", value);
-    }
-    else if (PyInt_Check(date) || PyLong_Check(date) || PyFloat_Check(date)) {
-        value = (ts_datetime)PyInt_AsLong(date);
-//        DEBUGPRINTF("get_tsdatetime_from_object.from number: %ld", value);
-    }
-    else {
-        value = -1;
-    }
-    return value;
-}
-
-
-
-static PyObject *
-DatetimeArray_single_date_to_index(DatetimeArrayObject *self, PyObject *date){
-    intp count=0, i, size;
-    int nd = ((PyArrayObject *)self)->nd, j, comparison;
-
-    PyArrayIterObject *itr = NULL;
-    PyObject *result = NULL, *item;
-    intp *dptr[MAX_DIMS];
-
-    itr = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-    if (itr == NULL)
-        return NULL;
-
-    ts_metadata *meta = get_metadata_from_array(self);
-    ts_datetime value = get_tsdatetime_from_object(meta, date);
-    if (value < 0) {
-        goto fail;
-    }
-
-    PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
-
-    /*Count the valid elements*/
-    size = itr->size;
-    for (i = 0; i < size; i++) {
-        comparison = cmprf(itr->dataptr, &value, self);
-        if (comparison == 0)
-            count++;
-        PyArray_ITER_NEXT(itr);
-    }
-
-    PyArray_ITER_RESET(itr);
-    result = PyTuple_New(nd);
-    if (result == NULL)
-        goto fail;
-    for (j = 0; j < nd; j++) {
-        item = PyArray_New(Py_TYPE(self), 1, &count,
-                           PyArray_INTP, NULL, NULL, 0, 0,
-                           (PyObject *)self);
-        if (item == NULL)
-            goto fail;
-        PyTuple_SET_ITEM(result, j, item);
-        dptr[j] = (intp *)PyArray_DATA(item);
-    }
-    if (nd == 1) {
-        for (i = 0; i < size; i++){
-            comparison = cmprf(itr->dataptr, &value, self);
-            if (comparison == 0)
-                *(dptr[0])++ = i;
-            PyArray_ITER_NEXT(itr);
-        }
-    }
-    else {
-        itr->contiguous = 0;
-        for (i = 0; i < size; i++){
-            comparison = cmprf(itr->dataptr, &value, self);
-            if (comparison == 0) {
-                for (j = 0; j < nd; j++)
-                    *(dptr[j])++ = itr->coordinates[j];
-            }
-            PyArray_ITER_NEXT(itr);
-        }
-    }
-    Py_DECREF(itr);
-    return result;
- fail:
-    Py_XDECREF(result);
-    Py_XDECREF(itr);
-    return NULL;
-}
-
-
-
-static PyObject *
-DatetimeArray_date_to_index(DatetimeArrayObject *self, PyObject *dateargs){
-    PyObject *result=NULL, *date=NULL;
-    ts_datetime value;
-    Py_ssize_t i;
-
-    /* Make sure we have at least 1 argument */
-    Py_ssize_t nbargs = PyObject_Length(dateargs);
-    if (nbargs < 1) {
-        PyErr_SetString(PyExc_ValueError, "there should be at least one argument");
-        goto fail;
-    }
-
-    ts_metadata *meta = get_metadata_from_array(self);
-//    ts_timestatus status = self->status;
-//    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
-
-    result = PyList_New(0);
-    if (result == NULL)
-        goto fail;
-
-    PyArrayIterObject *itr = NULL;
-    PyObject *indexlist = NULL;
-    int comparison, empty;
-
-    for (i=0; i < nbargs; i++){
-        date = PyTuple_GetItem(dateargs, i);
-        value = get_tsdatetime_from_object(meta, date);
-        if (value < 0) {
-            PyErr_SetString(PyExc_ValueError, "unable to retrieve date");
-            Py_XDECREF(itr);
-            Py_XDECREF(indexlist);
-            goto fail;
-        }
-
-        indexlist = PyList_New(0);
-        if (indexlist == NULL) {
-            Py_XDECREF(itr);
-            Py_XDECREF(indexlist);
-            goto fail;
-        }
-        itr = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-        if (itr == NULL) {
-            Py_XDECREF(itr);
-            Py_XDECREF(indexlist);
-            goto fail;
-        }
-        PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
-        while (itr->index < itr->size) {
-            comparison = cmprf(itr->dataptr, &value, self);
-            if (comparison == 0) {
-                PyObject *coords = PyObject_GetAttrString((PyObject *)itr, "coords");
-                PyList_Append(indexlist, coords);
-                empty = 0;
-            }
-            PyArray_ITER_NEXT(itr);
-        };
-        if (empty) {
-            indexlist = Py_None;
-        };
-        PyList_Append(result, indexlist);
-    };
-    Py_DECREF(itr);
-    Py_DECREF(indexlist);
-
-    if (nbargs == 1)
-        return PyList_GetItem(result, 0);
-    return result;
-
- fail:
-    Py_XDECREF(result);
-    Py_XDECREF(date);
-    return NULL;
-}
-
-
-
-
-
-static PyObject *
-DatetimeArray_getitem(DatetimeArrayObject *self, PyObject *op)
-{
-//    int reset_full=1, keep_chrono=0;
-//    DEBUGPRINTF("in __getitem__ w %s", DEBUGGETTYPE(op));
-    PyObject *idx;
-
-    if (DatetimeObject_Check(op) || PyString_Check(op) || PyDateTime_Check(op)) {
-        if (DatetimeObject_Check(op)) {
-            DEBUGPRINTF("index is Date");
-        }
-        else if (PyString_Check(op)) {
-            DEBUGPRINTF("index is string");
-        }
-        else if (PyDateTime_Check(op)) {
-            DEBUGPRINTF("index is datetime");
-        };
-        idx = DatetimeArray_single_date_to_index(self, op);
-        if (idx == NULL) {
-            PyErr_SetString(PyExc_IndexError, "date out of bounds");
-            return NULL;
-        }
-    }
-    else {
-        idx = op;
-    }
-
-    PyObject *r, *result;
-    r = ((PyArrayObject *)self)->ob_type->tp_base->tp_as_mapping->mp_subscript((PyObject *)self, idx);
-    if (r == NULL) {
-        return NULL;
-    }
-//    DEBUGPRINTF("r is %s", DEBUGGETTYPE(r));
-    ts_datetime obval;
-    if (PyArray_IsScalar(r, Integer)) {
-        int unit = _get_unit_from_descr(get_descr(self));
-
-        obval = (ts_datetime)(PyInt_AsLong(r));
-        result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, PyInt_AsLong(r));
-        Py_DECREF(r);
-    }
-    else {
-        result = r;
-        ((DatetimeArrayObject *)r)->status.is_chrono = self->status.is_chrono;
-    }
-    Py_DECREF(idx);
-    return result;
-}
-
-
-
-NPY_NO_EXPORT PyMappingMethods DatetimeArray_as_mapping = {
-    NULL,              /*mp_length*/
-    (binaryfunc)&DatetimeArray_getitem,        /*mp_subscript*/
-    NULL, /*mp_ass_subscript*/
-};
-
-
-
-
-
-/* Date & Time Information */
-PyObject *
-DatetimeArray_getdateinfo(DatetimeArrayObject *self, char *infochar)
-{
-    int skip_periods, counter=1, val_changed=0;
-
-    PyObject *prev_val=NULL;
-    PyArrayObject *output=NULL;
-    PyArrayIterObject *iterin=NULL, *iterout=NULL;
-
-
-    ts_metadata *meta = get_metadata_from_array(self);
-    int unit = meta->unit;
-    ts_timestatus status = self->status;
-    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
-
-    output = (PyArrayObject *)PyArray_SimpleNew(((PyArrayObject *)self)->nd,
-                                                 ((PyArrayObject *)self)->dimensions,
-                                                 NPY_INT);
-
-
-    conversion_function todays = get_converter_to_days(unit, 1);
-    init_metadata_from_unit(meta, unit);
-    meta->convert_to_start = 0;
-    ts_datetimestruct dinfo;
-
-
-    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
-
-    PyObject* (*getdateparam)(npy_int64, int,
-                              conversion_function, ts_metadata*,
-                              ts_datetimestruct*) = NULL;
-    switch(*infochar)
-    {
-        case 'Y': //year
-            getdateparam = &_loop_get_year;
-            skip_periods = __skip_periods_year(unit);
-            break;
-        case 'F': //"fiscal" year
-            if (unit == FR_QTR)
-                getdateparam = &_loop_get_qyear_from_qtr;
-            else
-                getdateparam = &_loop_get_qyear;
-            skip_periods = __skip_periods_year(unit);
-            break;
-        case 'Q': //quarter
-            if (unit == FR_QTR)
-                getdateparam = &_loop_get_quarter_from_qtr;
-            else
-                getdateparam = &_loop_get_quarter;
-            skip_periods = __skip_periods_quarter(unit);
-            break;
-        case 'M': //month
-            getdateparam = &_loop_get_month;
-            skip_periods = __skip_periods_month(unit);
-            break;
-        case 'D': //day
-            getdateparam = &_loop_get_day;
-            skip_periods = __skip_periods_day(unit);
-            break;
-        case 'R': //day of year
-            getdateparam = &_loop_get_day_of_year;
-            skip_periods = __skip_periods_day(unit);
-            break;
-        case 'W': //day of week
-            getdateparam = &_loop_get_day_of_week;
-            skip_periods = __skip_periods_day(unit);
-            break;
-        case 'I': //week of year
-            getdateparam = &_loop_get_week;
-            skip_periods = __skip_periods_week(unit);
-            break;
-        case 'H': //hour
-            getdateparam = &_loop_get_hour;
-            skip_periods = __skip_periods_hour(unit);
-            break;
-        case 'T': //minute
-            getdateparam = &_loop_get_minute;
-            skip_periods = __skip_periods_minute(unit);
-            break;
-        case 'S': //second
-            getdateparam = &_loop_get_second;
-            skip_periods = 1;
-            break;
-        case 'O': //toordinal
-            getdateparam = &_loop_get_ordinal;
-            skip_periods = __skip_periods_day(unit);
-            break;
-        default:
-            return NULL;
-    }
-
-    {
-    PyObject *val, *result=NULL;
-    while (iterin->index < iterin->size) {
-
-        if ((val_changed == 0) ||
-            (is_valid == 0) ||
-            (prev_val == NULL) ||
-            (counter >= skip_periods)) {
-
-               val = PyArray_GETITEM(self, iterin->dataptr);
-               result = getdateparam(PyInt_AsLong(val), unit,
-                                     todays, meta, &dinfo);
-
-               if ((prev_val != NULL) &&
-                   (PyLong_AsLong(prev_val) != PyLong_AsLong(result))) {
-                   val_changed = 1;
-                   counter = 0;
-               }
-               Py_DECREF(val);
-               if (prev_val != NULL) {
-                   Py_DECREF(prev_val);
-               }
-               prev_val = result;
-        }
-        PyArray_SETITEM(output, iterout->dataptr, result);
-
-        PyArray_ITER_NEXT(iterin);
-        PyArray_ITER_NEXT(iterout);
-        counter++;
-        }
-    }
-    if (prev_val != NULL) {
-        Py_DECREF(prev_val);
-    }
-    Py_DECREF(iterin);
-    Py_DECREF(iterout);
-    return (PyObject *) output;
-}
-PyObject *
-DatetimeArray_year(DatetimeArrayObject *self){
-    char infochar = 'Y';
-    return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_qyear(DatetimeArrayObject *self){
-     char infochar = 'F';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_quarter(DatetimeArrayObject *self){
-     char infochar = 'Q';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_month(DatetimeArrayObject *self){
-     char infochar = 'M';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_week(DatetimeArrayObject *self){
-     char infochar = 'I';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_day(DatetimeArrayObject *self){
-     char infochar = 'D';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_day_of_week(DatetimeArrayObject *self){
-     char infochar = 'W';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_day_of_year(DatetimeArrayObject *self){
-     char infochar = 'R';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_hour(DatetimeArrayObject *self){
-     char infochar = 'H';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_minute(DatetimeArrayObject *self){
-     char infochar = 'T';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_second(DatetimeArrayObject *self){
-     char infochar = 'S';
-     return DatetimeArray_getdateinfo(self, &infochar);
-}
-PyObject *
-DatetimeArray_ordinal(DatetimeArrayObject *self){
-    char infochar = 'O';
-    return DatetimeArray_getdateinfo(self, &infochar);
-}
-
-
-PyObject *
-DatetimeArray_datetime(DatetimeArrayObject *self)
-{
-    PyArrayObject *output=NULL;
-    PyArrayIterObject *iterin=NULL, *iterout=NULL;
-
-    ts_metadata *meta = get_metadata_from_array(self);
-    int unit = meta->unit;
-
-    output = (PyArrayObject *)PyArray_SimpleNew(((PyArrayObject *)self)->nd,
-                                                ((PyArrayObject *)self)->dimensions,
-                                                NPY_OBJECT);
-
-    conversion_function todays = get_converter_to_days(unit, 1);
-    meta->convert_to_start = 1;
-    ts_datetimestruct dinfo;
-
-    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
-
-    {
-    PyObject *val, *result=NULL;
-    while (iterin->index < iterin->size) {
-        val = PyArray_GETITEM(self, iterin->dataptr);
-        result = _loop_get_datetime(PyInt_AsLong(val), unit,
-                                    todays, meta, &dinfo);
-        PyArray_SETITEM(output, iterout->dataptr, result);
-        PyArray_ITER_NEXT(iterin);
-        PyArray_ITER_NEXT(iterout);
-        }
-    }
-    Py_DECREF(iterin);
-    Py_DECREF(iterout);
-    return (PyObject *) output;
-}
-
-static PyObject *
-DatetimeArray_start_date(DatetimeArrayObject *self) {
-    PyObject *minobj, *result=NULL;
-    minobj = PyArray_Min(asndarray(self), MAX_DIMS, NULL);
-    ts_datetime val = PyInt_AsLong(minobj);
-    int unit = _get_unit_from_descr(get_descr(self));
-    result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, val);
-    Py_DECREF(minobj);
-    return result;
-}
-static PyObject *
-DatetimeArray_end_date(DatetimeArrayObject *self) {
-    PyObject *maxobj, *result=NULL;
-    maxobj = PyArray_Max(asndarray(self), MAX_DIMS, NULL);
-    ts_datetime val = PyInt_AsLong(maxobj);
-    int unit = _get_unit_from_descr(get_descr(self));
-    result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, val);
-    Py_DECREF(maxobj);
-    return result;
-}
-
-
-static PyObject *
-DatetimeArray_tovalues(DatetimeArrayObject *self) {
-    return get_base(self);
-}
-static PyObject *
-DatetimeArray_toordinals(DatetimeArrayObject *self) {
-    char infochar = 'O';
-    return DatetimeArray_getdateinfo(self, &infochar);
-}
-static PyObject *
-DatetimeArray_tolist(DatetimeArrayObject *self)
-{
-    PyObject *dtarray=NULL, *output=NULL;
-    dtarray = DatetimeArray_datetime(self);
-    output = PyArray_ToList((PyArrayObject *)self);
-    Py_DECREF(dtarray);
-    return output;
-}
-
-
-/*
- * PROPERTIES
- */
-
-static int
-DatetimeArray_ReadOnlyErr(DatetimeArrayObject *self, PyObject *value, void *closure) {
-   PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
-   return -1;
-};
-
-static PyGetSetDef DatetimeArray_getseters[] = {
-    {"unit", (getter)DatetimeArray_unit, (setter)DatetimeArray_ReadOnlyErr,
-     "Returns the frequency.", NULL},
-    {"timestep", (getter)DatetimeArray_timestep, (setter)DatetimeArray_ReadOnlyErr,
-     "", NULL},
-    {"freqstr", (getter)DatetimeArray_freqstr, (setter)DatetimeArray_ReadOnlyErr,
-     "Returns the string representation of frequency.", NULL},
-    {"steps", (getter)DatetimeArray_steps, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"year", (getter)DatetimeArray_year, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"qyear", (getter)DatetimeArray_qyear, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"quarter", (getter)DatetimeArray_quarter, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"month", (getter)DatetimeArray_month, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"week", (getter)DatetimeArray_week, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"day", (getter)DatetimeArray_day, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"day_of_week", (getter)DatetimeArray_day_of_week, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"day_of_year", (getter)DatetimeArray_day_of_year, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"hour", (getter)DatetimeArray_hour, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"minute", (getter)DatetimeArray_minute, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"second", (getter)DatetimeArray_second, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-    {"datetime", (getter)DatetimeArray_datetime, (setter)DatetimeArray_ReadOnlyErr,
-     "time steps", NULL},
-     {"start_date", (getter)DatetimeArray_start_date, (setter)DatetimeArray_ReadOnlyErr,
-      "time steps", NULL},
-     {"end_date", (getter)DatetimeArray_end_date, (setter)DatetimeArray_ReadOnlyErr,
-      "time steps", NULL},
-    {NULL, NULL, NULL, NULL, NULL}  /* Sentinel */
-};
-
-/*
- * METHODS
- */
-
-
-
-static PyObject *
-DatetimeArray_convert(DatetimeArrayObject *self,
-                      PyObject *args, PyObject *kwds)
-{
-    DatetimeArrayObject *output=NULL;
-    PyObject *freq=NULL;
-    char *relation_raw=NULL, *relation_uc;
-    conversion_function converterfrom, converterto;
-    int fromfreq, tofreq;
-
-    PyArray_Descr *indescr, *outdescr;
-    ts_metadata *metafrom, *metato;
-
-    indescr = get_descr(self);
-    metafrom = get_metadata_from_descr(indescr);
-    fromfreq = _get_unit_from_descr(indescr);
-
-    /* Get the arguments */
-    static char *kwlist[] = {"freq", "relation", NULL};
-    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|s", kwlist,
-                                      &freq, &relation_raw))
-        return NULL;
-
-    /* Check the conversion frequency */
-    if ((tofreq = check_freq(freq)) == INT_ERR_CODE)
-        return NULL;
-
-
-    /* Initialize the output */
-    outdescr = PyArray_DescrNewFromType(PyArray_INT64);
-    if (outdescr == NULL)
-        return NULL;
-    Py_INCREF(outdescr);
-    output = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
-                                                         outdescr,
-                                                         asarray(self)->nd,
-                                                         asarray(self)->dimensions,
-                                                         NULL,
-                                                         NULL,
-                                                         asarray(self)->flags,
-                                                         NULL);
-    if (output == NULL)
-        return NULL;
-    metato = get_metadata_from_descr(outdescr);
-    init_metadata_from_unit(metato, tofreq);
-
-
-    /* Update the convert_to_start from the relational argument */
-    if(relation_raw) {
-        if (strlen(relation_raw) > 0) {
-            if ((relation_uc = str_uppercase(relation_raw)) == NULL)
-                return PyErr_NoMemory();
-            // 'BEFORE' and 'AFTER' values for this parameter are deprecated
-            if ((relation_uc[0] == 'E') || (relation_uc[0] == 'A'))
-                metafrom->convert_to_start = 0;
-            else if ((relation_uc[0] == 'S') || (relation_uc[0] == 'B'))
-                metafrom->convert_to_start = 1;
-            else {
-                PyErr_SetString(PyExc_ValueError,"Invalid relation specification");
-                free(relation_uc);
-                return NULL;
-            }
-            free(relation_uc);
-        }
-        else {
-            metafrom->convert_to_start = 0;
-        };
-    }
-    else {
-        metafrom->convert_to_start = 0;
-    }
-    metato->convert_to_start = metafrom->convert_to_start;
-    /* Correction for business days */
-    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
-        metato->convert_to_start = 1;
-
-
-    PyArrayIterObject *iterfrom, *iterto;
-    iterfrom = (PyArrayIterObject *)PyArray_IterNew((PyObject *)get_base(self));
-    iterto = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
-    if ((iterfrom == NULL) || (iterto == NULL)) {
-        Py_XDECREF(iterfrom);
-        Py_XDECREF(iterto);
-        Py_XDECREF(output);
-        return NULL;
-    }
-
-    PyObject *fromdateobj=NULL, *todateobj=NULL;
-    PyArray_GetItemFunc *getitem = indescr->f->getitem;
-
-    if (tofreq == fromfreq) {
-        while (iterfrom->index < iterfrom->size) {
-            fromdateobj = getitem(iterfrom->dataptr, self);
-            PyArray_SETITEM(output, iterto->dataptr, fromdateobj);
-            Py_DECREF(fromdateobj);
-            PyArray_ITER_NEXT(iterfrom);
-            PyArray_ITER_NEXT(iterto);
-        }
-    }
-    else {
-        ts_datetime fromdateval, todateval;
-        converterfrom = convert_to_mediator(metafrom->unit, metato->unit, 0);
-        converterto = convert_from_mediator(metafrom->unit, metato->unit, 0);
-        while (iterfrom->index < iterfrom->size) {
-            fromdateobj = getitem(iterfrom->dataptr, self);
-            fromdateval = PyInt_AsLong(fromdateobj);
-            todateval = converterto(converterfrom(fromdateval, metafrom), metato);
-            todateobj = PyInt_FromLong(todateval);
-
-            PyArray_SETITEM(output, iterto->dataptr, todateobj);
-            Py_DECREF(fromdateobj);
-            Py_DECREF(todateobj);
-
-            PyArray_ITER_NEXT(iterfrom);
-            PyArray_ITER_NEXT(iterto);
-        }
-    }
-    Py_DECREF(iterfrom);
-    Py_DECREF(iterto);
-    return (PyObject *)output;
-
-}
-
-
-static PyObject *
-DatetimeArray_fill_missing_dates(DatetimeArrayObject *self,
-                                 PyObject *args, PyObject *kwds)
-{
-    DatetimeArrayObject *output=NULL;
-    PyObject *base=NULL, *result=NULL;
-    PyArray_Descr *descr = get_descr(self);
-
-    int output_mask = 0;
-    static char *kwlist[] = {"output_mask", NULL};
-    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist,
-                                     &output_mask))
-        return NULL;
-
-    ts_metadata *meta = get_metadata_from_descr(descr);
-    ts_timestatus status = self->status;
-
-    if (status.has_dups) {
-        PyErr_SetString(PyExc_ValueError, "duplicated dates are not allowed");
-        goto fail;
-    }
-    if (! status.is_chrono) {
-        PyErr_SetString(PyExc_ValueError, "series must be in chronological order");
-        goto fail;
-    }
-    if (! status.has_missing) {
-        DEBUGPRINTF("fill_missing_dates : no missing");
-        base = PyArray_Copy(asndarray(self));
-    }
-    else {
-        DEBUGPRINTF("fill_missing_dates : w/ missing");
-        PyObject *start=NULL, *end=NULL;
-        start = PyArray_Min(asndarray(self), MAX_DIMS, NULL);
-        end = PyArray_Max(asndarray(self), MAX_DIMS, NULL);
-        if ((start == NULL) || (end == NULL)) {
-            Py_XDECREF(start);
-            Py_XDECREF(end);
-            goto fail;
-        }
-        PyObject *pystep = PyInt_FromLong(meta->timestep);
-        base = PyArray_ArangeObj(start, PyNumber_Add(end, pystep), pystep,
-                                 descr);
-        Py_DECREF(pystep);
-        Py_XDECREF(start);
-        Py_XDECREF(end);
-    }
-    DEBUGPRINTF("initializing the output");
-    output = (DatetimeArrayObject *)PyArray_View(asarray(base), descr, Py_TYPE(self));
-    if (output == NULL) {
-        goto fail;
-    }
-    update_descr_metadata(get_descr(output), meta);
-    ts_timestatus newstatus = {0, 0, 1};
-    output->status = newstatus;
-
-    if (output_mask) {
-        npy_intp size = PyArray_SIZE(output);
-        PyObject *mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
-        DEBUGPRINTF("mask initialized");
-        if (status.has_missing) {
-            PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
-            PyArrayIterObject *iself=NULL, *ifill=NULL, *imask=NULL;
-            iself = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-            ifill = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
-            imask = (PyArrayIterObject *)PyArray_IterNew((PyObject *)mask);
-            while (iself->index < iself->size) {
-                while (cmprf(iself->dataptr, ifill->dataptr, self) == 1) {
-                    PyArray_SETITEM(mask, imask->dataptr, PyInt_FromLong(1));
-                    PyArray_ITER_NEXT(ifill);
-                    PyArray_ITER_NEXT(imask);
-                }
-                PyArray_ITER_NEXT(iself);
-                PyArray_ITER_NEXT(ifill);
-                PyArray_ITER_NEXT(imask);
-            }
-            Py_XDECREF(iself);
-            Py_XDECREF(ifill);
-            Py_XDECREF(imask);
-        }
-        DEBUGPRINTF("all ok");
-        result = Py_BuildValue("(OO)", output, mask);
-    }
-    else
-        result = Py_BuildValue("O", output);
-
-    return result;
-
- fail:
-    Py_XDECREF(output);
-    Py_XDECREF(base);
-    return NULL;
-}
-
-static PyObject *
-DatetimeArray_get_missing_dates_mask(DatetimeArrayObject *self)
-{
-    PyObject *mask = NULL;
-
-    ts_timestatus status = self->status;
-    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
-
-    if (is_valid) {
-        npy_intp size = PyArray_SIZE(self);
-        mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
-        if (mask == NULL)
-            goto fail;
-    }
-    else {
-        PyObject *filled = DatetimeArray_fill_missing_dates(self, NULL, NULL);
-        if (filled == NULL) {
-            DEBUGPRINTF("FSCK");
-            Py_XDECREF(filled);
-            Py_XDECREF(mask);
-            return NULL;
-        }
-        npy_intp size = PyArray_SIZE(get_base(filled));
-        mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
-        if (mask == NULL)
-            goto fail;
-
-        DEBUGPRINTF("mask initialized");
-        PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
-        PyArrayIterObject *iself=NULL, *ifill=NULL, *imask=NULL;
-        iself = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
-        ifill = (PyArrayIterObject *)PyArray_IterNew((PyObject *)filled);
-        imask = (PyArrayIterObject *)PyArray_IterNew((PyObject *)mask);
-        int i=0;
-        while (iself->index < iself->size) {
-            DEBUGPRINTF("ini got %ld", PyInt_AsLong(PyArray_GETITEM(self,iself->dataptr)));
-            DEBUGPRINTF("fld got 1 at %ld", PyInt_AsLong(PyArray_GETITEM(self,ifill->dataptr)));
-            DEBUGPRINTF("[%i]", cmprf(iself->dataptr, ifill->dataptr, self));
-            while (cmprf(iself->dataptr, ifill->dataptr, self) == 1) {
-                i++;
-                DEBUGPRINTF("Add 1 at %i", i);
-//                DEBUGPRINTF("fld got 1 at %ld", PyInt_AsLong(PyArray_GETITEM(self,ifill->dataptr)));
-                PyArray_SETITEM(mask, imask->dataptr, PyInt_FromLong(1));
-                PyArray_ITER_NEXT(ifill);
-                PyArray_ITER_NEXT(imask);
-            }
-            PyArray_ITER_NEXT(iself);
-            PyArray_ITER_NEXT(ifill);
-            PyArray_ITER_NEXT(imask);
-        }
-        Py_XDECREF(iself);
-        Py_XDECREF(ifill);
-        Py_XDECREF(imask);
-        Py_DECREF(filled);
-    }
-    return (PyObject *)mask;
-
- fail:
-    DEBUGPRINTF("FSCK");
-    Py_XDECREF(mask);
-    return NULL;
-}
-
-
-static PyMethodDef DatetimeArray_methods[] = {
-    { "__array_finalize__", (PyCFunction)DatetimeArray_finalize, METH_VARARGS,
-      ""},
-//    {"__getitem__", (PyCFunction)DatetimeArray_getitem, METH_VARARGS, ""},
-    {"has_dups", (PyCFunction)DatetimeArray_has_dups, METH_VARARGS, ""},
-    {"has_missing", (PyCFunction)DatetimeArray_has_missing, METH_VARARGS, ""},
-    {"is_chrono", (PyCFunction)DatetimeArray_is_chrono, METH_VARARGS, ""},
-    {"is_full", (PyCFunction)DatetimeArray_is_full, METH_VARARGS, ""},
-    {"is_valid", (PyCFunction)DatetimeArray_is_valid, METH_VARARGS, ""},
-    {"date_to_index", (PyCFunction)DatetimeArray_date_to_index, METH_VARARGS, ""},
-    {"tovalues", (PyCFunction)DatetimeArray_tovalues, METH_VARARGS, ""},
-    {"toordinals", (PyCFunction)DatetimeArray_toordinals, METH_VARARGS, ""},
-    {"tolist", (PyCFunction)DatetimeArray_tolist, METH_VARARGS, ""},
-    {"fill_missing_dates", (PyCFunction)DatetimeArray_fill_missing_dates, METH_KEYWORDS, ""},
-    {"get_missing_dates_mask", (PyCFunction)DatetimeArray_get_missing_dates_mask, METH_VARARGS, ""},
-    {"convert", (PyCFunction)DatetimeArray_convert, METH_KEYWORDS, ""},
-    {0}
-};
-
-
-static PyTypeObject DatetimeArray_Type = {
-    PyObject_HEAD_INIT(NULL)
-    0,                                        /* ob_size */
-    "timeseries.DatetimeArray",                      /* tp_name */
-    sizeof(DatetimeArrayObject),              /* tp_basicsize */
-    0,                                        /* tp_itemsize */
-    (destructor)DatetimeArray_dealloc,          /* tp_dealloc */
-    0,                                        /* tp_print */
-    0,                                        /* tp_getattr */
-    0,                                        /* tp_setattr */
-    0,                                        /* tp_compare */
-    0,                                        /* tp_repr */
-    0,                                        /* tp_as_number */
-    0,                                        /* tp_as_sequence */
-    &DatetimeArray_as_mapping,                 /* tp_as_mapping */
-    0,                                        /* tp_hash */
-    0,                                        /* tp_call */
-    0,                                        /* tp_str */
-    0,                                        /* tp_getattro */
-    0,                                        /* tp_setattro */
-    0,                                        /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
-    "DatetimeArray",                          /* tp_doc */
-    0,                                        /* tp_traverse */
-    0,                                        /* tp_clear */
-    0,     /* tp_richcompare */
-    0,                                        /* tp_weaklistoffset */
-    0,                                        /* tp_iter */
-    0,                                        /* tp_iternext */
-    DatetimeArray_methods,                    /* tp_methods */
-    DatetimeArray_members,                    /* tp_members */
-    DatetimeArray_getseters,                  /* tp_getset */
-    0,                            /* tp_base */
-    0,                                        /* tp_dict */
-    0,                                        /* tp_descr_get */
-    0,                                        /* tp_descr_set */
-    0,                                        /* tp_dictoffset */
-    0,                                        /* tp_init */
-    0,                                        /* tp_alloc */
-    DatetimeArray_new,                        /* tp_new */
-};
-
-
-
-
-
-
-/*
- * */
-void import_c_datearray(PyObject *m)
-{
-    import_array();
-    PyDateTime_IMPORT;
-
-    DatetimeArray_Type.tp_base = &PyArray_Type;
-    if (PyType_Ready(&DatetimeArray_Type) < 0)
-        return;
-    Py_INCREF(&DatetimeArray_Type);
-    PyModule_AddObject(m, "DatetimeArray", (PyObject *)(&DatetimeArray_Type));
-    
-//    PyArray_TS_DATETIME = PyArray_RegisterDataType(&TS_DATETIME_Descr);
-//    if (PyArray_TS_DATETIME < 0) {
-//        DEBUGPRINTF("Could not import the TS_DATETIME description.");
-//        return;
-//    };
-//    TS_DATETIME_Descr.ob_type = &PyArrayDescr_Type;
-//    Py_INCREF(&TS_DATETIME_Descr);
-
-    // PyModule_AddObject(m, "Datetime", (PyObject *)(&TS_DATETIME_Descr));
-
-}
-
-
diff --git a/pandas/src/timeseries/c_dates.c b/pandas/src/timeseries/c_dates.c
index 49cdd424d..071a48fe6 100644
--- a/pandas/src/timeseries/c_dates.c
+++ b/pandas/src/timeseries/c_dates.c
@@ -1,15 +1,11 @@
 #include "c_dates.h"
-#include "c_freqs.h"
-#include "c_convert.h"
-#include "c_types.h"
-
 #include <datetime.h>
 #include <time.h>
 
 
+int get_freq_group(int freq) { return (freq/1000)*1000; }
 
-#define INIT_ERR(errortype, errmsg) PyErr_SetString(errortype,errmsg);return -1
-
+static asfreq_info NULL_AF_INFO;
 
 /*********************************************************
 ** Python callbacks. These functions must be called by  **
@@ -21,263 +17,1354 @@ PyObject *
 set_callback_DateFromString(PyObject *dummy, PyObject *args) {
     return set_callback(args, &DateFromString);
 }
+
 static PyObject *DateTimeFromString = NULL;
 PyObject *
 set_callback_DateTimeFromString(PyObject *dummy, PyObject *args) {
     return set_callback(args, &DateTimeFromString);
 }
 
+//DERIVED FROM mx.DateTime
+/*
+    Functions in the following section are borrowed from mx.DateTime version
+    2.0.6, and hence this code is subject to the terms of the egenix public
+    license version 1.0.0
+*/
 
+#define Py_AssertWithArg(x,errortype,errorstr,a1) {if (!(x)) {PyErr_Format(errortype,errorstr,a1);goto onError;}}
+#define Py_Error(errortype,errorstr) {PyErr_SetString(errortype,errorstr);goto onError;}
 
-/* Returns absolute seconds from an hour, minute, and second
- */
-#define secs_from_hms(hour, min, sec, multiplier) (\
-  ((hour)*3600 + (min)*60 + (sec)) * (npy_int64)(multiplier)\
-)
+ /* Error Exception objects */
+static PyObject *DateCalc_Error;
+static PyObject *DateCalc_RangeError;
 
-/* Returns the quarter */
-#define month_to_quarter(month) (((month)-1)/3 + 1)
-#define quarter_to_month(quarter) (((quarter)-1)*3 + 1)
+#define GREGORIAN_CALENDAR 0
+#define JULIAN_CALENDAR 1
 
+#define SECONDS_PER_DAY ((double) 86400.0)
 
+/* Table with day offsets for each month (0-based, without and with leap) */
+static int month_offset[2][13] = {
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
 
-/*
-====================================================
-== End of section borrowed from mx.DateTime       ==
-====================================================
-*/
+/* Table of number of days in a month (0-based, without and with leap) */
+static int days_in_month[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
 
-void
-init_metadata_from_unit(ts_metadata *meta, int unit) {
-    meta->unit = (unit/1000)*1000;
-    if (unit > FR_DAY) {
-        meta->periods_per_day = highunits_per_day(unit);
-        meta->secs_per_period = secs_per_highunits(unit, 1);
-        meta->period_end_at = -1;
-    }
-    else {
-        meta->periods_per_day = -1;
-        meta->secs_per_period = -1;
-        meta->period_end_at = unit - meta->unit;
+struct date_info {
+    long absdate;
+    double abstime;
+
+    double second;
+    int minute;
+    int hour;
+    int day;
+    int month;
+    int quarter;
+    int year;
+    int day_of_week;
+    int day_of_year;
+    int calendar;
+};
+
+
+/* Return 1/0 iff year points to a leap year in calendar. */
+static
+int dInfoCalc_Leapyear(register long year,
+            int calendar)
+{
+    if (calendar == GREGORIAN_CALENDAR) {
+        return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
+    } else {
+        return (year % 4 == 0);
     }
-    meta->convert_to_start = 0;
-    meta->timestep = 1;
 }
 
+static
+int dInfoCalc_ISOWeek(struct date_info *dinfo)
+{
+    int week;
+
+    /* Estimate */
+    week = (dinfo->day_of_year-1) - dinfo->day_of_week + 3;
+    if (week >= 0) week = week / 7 + 1;
+
+    /* Verify */
+    if (week < 0) {
+        /* The day lies in last week of the previous year */
+        if ((week > -2) ||
+            (week == -2 && dInfoCalc_Leapyear(dinfo->year-1, dinfo->calendar)))
+            week = 53;
+        else
+            week = 52;
+    } else if (week == 53) {
+    /* Check if the week belongs to year or year+1 */
+        if (31-dinfo->day + dinfo->day_of_week < 3) {
+            week = 1;
+        }
+    }
 
+    return week;
+}
 
-// NPY_NO_EXPORT
-ts_datetime
-datetimestruct_to_tsdatetime(ts_metadata *meta, ts_datetimestruct *d)
+
+/* Return the day of the week for the given absolute date. */
+static
+int dInfoCalc_DayOfWeek(register long absdate)
 {
-    ts_datetime val;
-    npy_int64 days=0;
+    int day_of_week;
 
-    int unit = meta->unit;
-    int period_end_at = meta->period_end_at;
+    if (absdate >= 1) {
+        day_of_week = (absdate - 1) % 7;
+    } else {
+        day_of_week = 6 - ((-absdate) % 7);
+    }
+    return day_of_week;
+}
 
-    if ((unit > FR_MTH) || (unit == FR_UND)) {
-        days = days_from_ymd(d->year, d->month, d->day);
-        if (unit >= FR_HR){
-            days -= HIGHFREQ_ORIG;
-        };
-    };
-    if (unit == FR_ANN) {
-        val = d->year;
+/* Return the year offset, that is the absolute date of the day
+   31.12.(year-1) in the given calendar.
+
+   Note:
+   For the Julian calendar we shift the absdate (which is measured
+   using the Gregorian Epoch) value by two days because the Epoch
+   (0001-01-01) in the Julian calendar lies 2 days before the Epoch in
+   the Gregorian calendar. */
+static
+int dInfoCalc_YearOffset(register long year,
+              int calendar)
+{
+    year--;
+    if (calendar == GREGORIAN_CALENDAR) {
+    if (year >= 0 || -1/4 == -1)
+        return year*365 + year/4 - year/100 + year/400;
+    else
+        return year*365 + (year-3)/4 - (year-99)/100 + (year-399)/400;
     }
-    else if (unit == FR_QTR) {
-        npy_int64 quarter = ((d->month - 1)/3) + 1;
-        if (period_end_at > 12) {
-            // quarterly frequency with year determined by ending period
-            val = d->year*4 + quarter;
-        }
-        else {
-            /* quarterly frequency with year determined by ending period
-                           or has December year end*/
-            val = (d->year - 1)*4 + quarter;
-        };
+    else if (calendar == JULIAN_CALENDAR) {
+    if (year >= 0 || -1/4 == -1)
+        return year*365 + year/4 - 2;
+    else
+        return year*365 + (year-3)/4 - 2;
     }
-    else if (unit == FR_MTH) {
-        val = (d->year-1)*12 + d->month;
+    Py_Error(DateCalc_Error, "unknown calendar");
+ onError:
+    return -1;
+}
+
+
+/* Set the instance's value using the given date and time. calendar
+   may be set to the flags: GREGORIAN_CALENDAR,
+   JULIAN_CALENDAR to indicate the calendar to be used. */
+
+static
+int dInfoCalc_SetFromDateAndTime(struct date_info *dinfo,
+                  int year,
+                  int month,
+                  int day,
+                  int hour,
+                  int minute,
+                  double second,
+                  int calendar)
+{
+
+    /* Calculate the absolute date */
+    {
+        int leap;
+        long yearoffset,absdate;
+
+        /* Range check */
+        Py_AssertWithArg(year > -(INT_MAX / 366) && year < (INT_MAX / 366),
+                 DateCalc_RangeError,
+                 "year out of range: %i",
+                 year);
+
+        /* Is it a leap year ? */
+        leap = dInfoCalc_Leapyear(year,calendar);
+
+        /* Negative month values indicate months relative to the years end */
+        if (month < 0) month += 13;
+        Py_AssertWithArg(month >= 1 && month <= 12,
+                 DateCalc_RangeError,
+                 "month out of range (1-12): %i",
+                 month);
+
+        /* Negative values indicate days relative to the months end */
+        if (day < 0) day += days_in_month[leap][month - 1] + 1;
+        Py_AssertWithArg(day >= 1 && day <= days_in_month[leap][month - 1],
+                 DateCalc_RangeError,
+                 "day out of range: %i",
+                 day);
+
+        yearoffset = dInfoCalc_YearOffset(year,calendar);
+        if (PyErr_Occurred()) goto onError;
+
+        absdate = day + month_offset[leap][month - 1] + yearoffset;
+
+        dinfo->absdate = absdate;
+
+        dinfo->year = year;
+        dinfo->month = month;
+        dinfo->quarter = ((month-1)/3)+1;
+        dinfo->day = day;
+
+        dinfo->day_of_week = dInfoCalc_DayOfWeek(absdate);
+        dinfo->day_of_year = (short)(absdate - yearoffset);
+
+        dinfo->calendar = calendar;
     }
-    else if (unit == FR_WK) {
-        ts_datetime end_week_day, adj_day;
-        end_week_day = (7 - period_end_at) % 7;
-        adj_day = days + ((7 - end_week_day) - days % 7) % 7;
-        val = adj_day / 7;
+
+    /* Calculate the absolute time */
+    {
+    Py_AssertWithArg(hour >= 0 && hour <= 23,
+             DateCalc_RangeError,
+             "hour out of range (0-23): %i",
+             hour);
+    Py_AssertWithArg(minute >= 0 && minute <= 59,
+             DateCalc_RangeError,
+             "minute out of range (0-59): %i",
+             minute);
+    Py_AssertWithArg(second >= (double)0.0 &&
+             (second < (double)60.0 ||
+              (hour == 23 && minute == 59 &&
+               second < (double)61.0)),
+             DateCalc_RangeError,
+             "second out of range (0.0 - <60.0; <61.0 for 23:59): %f",
+             second);
+
+    dinfo->abstime = (double)(hour*3600 + minute*60) + second;
+
+    dinfo->hour = hour;
+    dinfo->minute = minute;
+    dinfo->second = second;
     }
-    else if (unit == FR_BUS) {
-        npy_int64 weeks = days/7;
-        val = days - weeks * 2;
-        /*
-        int dotw = day_of_week(days);
-        if (dotw > 4){
-            // Invalid business day
-            val = 0;
+    return 0;
+ onError:
+    return -1;
+}
+
+static int monthToQuarter(int month) { return ((month-1)/3)+1; }
+
+/* Sets the date part of the date_info struct using the indicated
+   calendar.
+
+   XXX This could also be done using some integer arithmetics rather
+       than with this iterative approach... */
+static
+int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
+                  long absdate,
+                  int calendar)
+{
+    register long year;
+    long yearoffset;
+    int leap,dayoffset;
+    int *monthoffset;
+
+    /* Approximate year */
+    if (calendar == GREGORIAN_CALENDAR) {
+        year = (long)(((double)absdate) / 365.2425);
+    } else if (calendar == JULIAN_CALENDAR) {
+        year = (long)(((double)absdate) / 365.25);
+    } else {
+        Py_Error(DateCalc_Error, "unknown calendar");
+    }
+    if (absdate > 0) year++;
+
+    /* Apply corrections to reach the correct year */
+    while (1) {
+        /* Calculate the year offset */
+        yearoffset = dInfoCalc_YearOffset(year,calendar);
+        if (PyErr_Occurred())
+            goto onError;
+
+        /* Backward correction: absdate must be greater than the
+           yearoffset */
+        if (yearoffset >= absdate) {
+            year--;
+            continue;
+        }
+
+        dayoffset = absdate - yearoffset;
+        leap = dInfoCalc_Leapyear(year,calendar);
+
+        /* Forward correction: non leap years only have 365 days */
+        if (dayoffset > 365 && !leap) {
+            year++;
+            continue;
         }
-        else {
-            npy_int64 x = days -2;
-            val = 2 + (x/7)*5 + x%7;
+        break;
+    }
+
+    dinfo->year = year;
+    dinfo->calendar = calendar;
+
+    /* Now iterate to find the month */
+    monthoffset = month_offset[leap];
+    {
+        register int month;
+
+        for (month = 1; month < 13; month++) {
+            if (monthoffset[month] >= dayoffset)
+            break;
         }
-        */
+
+        dinfo->month = month;
+        dinfo->quarter = monthToQuarter(month);
+        dinfo->day = dayoffset - month_offset[leap][month-1];
     }
-    else if ((unit == FR_DAY) || (unit==FR_UND)){
-        val = days;
+
+
+    dinfo->day_of_week = dInfoCalc_DayOfWeek(absdate);
+    dinfo->day_of_year = dayoffset;
+    dinfo->absdate = absdate;
+
+    return 0;
+
+ onError:
+    return -1;
+}
+
+/* Sets the time part of the DateTime object. */
+static
+int dInfoCalc_SetFromAbsTime(struct date_info *dinfo,
+                  double abstime)
+{
+    int inttime;
+    int hour,minute;
+    double second;
+
+    inttime = (int)abstime;
+    hour = inttime / 3600;
+    minute = (inttime % 3600) / 60;
+    second = abstime - (double)(hour*3600 + minute*60);
+
+    dinfo->hour = hour;
+    dinfo->minute = minute;
+    dinfo->second = second;
+
+    dinfo->abstime = abstime;
+
+    return 0;
+}
+
+/* Set the instance's value using the given date and time. calendar
+   may be set to the flags: GREGORIAN_CALENDAR, JULIAN_CALENDAR to
+   indicate the calendar to be used. */
+static
+int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
+                  long absdate,
+                  double abstime,
+                  int calendar)
+{
+
+    /* Bounds check */
+    Py_AssertWithArg(abstime >= 0.0 && abstime <= SECONDS_PER_DAY,
+             DateCalc_Error,
+             "abstime out of range (0.0 - 86400.0): %f",
+             abstime);
+
+    /* Calculate the date */
+    if (dInfoCalc_SetFromAbsDate(dinfo,
+                  absdate,
+                  calendar))
+    goto onError;
+
+    /* Calculate the time */
+    if (dInfoCalc_SetFromAbsTime(dinfo,
+                  abstime))
+    goto onError;
+
+    return 0;
+ onError:
+    return -1;
+}
+
+/*
+====================================================
+== End of section borrowed from mx.DateTime       ==
+====================================================
+*/
+
+
+
+
+
+///////////////////////////////////////////////////////////////////////
+
+// helpers for frequency conversion routines //
+
+static long DtoB_weekday(long fromDate) { return (((fromDate) / 7) * 5) + (fromDate)%7; }
+
+static long DtoB_WeekendToMonday(long absdate, int day_of_week) {
+
+    if (day_of_week > 4) {
+        //change to Monday after weekend
+        absdate += (7 - day_of_week);
     }
-    else if (unit == FR_HR) {
-        val = days * 24 + d->hour;
+    return DtoB_weekday(absdate);
+}
+
+static long DtoB_WeekendToFriday(long absdate, int day_of_week) {
+
+    if (day_of_week > 4) {
+        //change to friday before weekend
+        absdate -= (day_of_week - 4);
     }
-    else if (unit == FR_MIN){
-        val = days * 1440 + d->hour * 60 + d->min;
+    return DtoB_weekday(absdate);
+}
+
+static long absdate_from_ymd(int y, int m, int d) {
+    struct date_info tempDate;
+    if (dInfoCalc_SetFromDateAndTime(&tempDate, y, m, d, 0, 0, 0, GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    return tempDate.absdate;
+}
+
+
+///////////////////////////////////////////////
+
+// frequency specifc conversion routines
+// each function must take an integer fromDate and a char relation ('S' or 'E' for 'START' or 'END')
+
+//************ FROM DAILY ***************
+
+static long asfreq_DtoA(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dinfo.month > af_info->to_a_year_end) { return (long)(dinfo.year + 1); }
+    else { return (long)(dinfo.year); }
+}
+
+static long DtoQ_yq(long fromDate, asfreq_info *af_info,
+                              int *year, int *quarter) {
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (af_info->to_q_year_end != 12) {
+        dinfo.month -= af_info->to_q_year_end;
+        if (dinfo.month <= 0) { dinfo.month += 12; }
+        else { dinfo.year += 1; }
+        dinfo.quarter = monthToQuarter(dinfo.month);
     }
-    else if (unit == FR_SEC){
-        val = days *  (npy_int64)(86400)
-            + secs_from_hms(d->hour, d->min, d->sec, 1);
+
+    *year = dinfo.year;
+    *quarter = dinfo.quarter;
+
+    return 0;
+}
+
+
+static long asfreq_DtoQ(long fromDate, char relation, asfreq_info *af_info) {
+
+    int year, quarter;
+
+    if (DtoQ_yq(fromDate, af_info, &year, &quarter) == INT_ERR_CODE)
+    { return INT_ERR_CODE; }
+
+    return (long)((year - 1) * 4 + quarter);
+}
+
+static long asfreq_DtoM(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    return (long)((dinfo.year - 1) * 12 + dinfo.month);
+}
+
+static long asfreq_DtoW(long fromDate, char relation, asfreq_info *af_info) {
+    return (fromDate - (1 + af_info->to_week_end))/7 + 1;
+}
+
+static long asfreq_DtoB(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (relation == 'S') {
+        return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week);
+    } else {
+        return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week);
     }
-    else {
-        /* Shouldn't get here */
-        PyErr_SetString(PyExc_ValueError, "invalid internal frequency");
-        val = -1;
+}
+
+static long asfreq_DtoB_forConvert(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (dinfo.day_of_week > 4) {
+        return -1;
+    } else {
+        return DtoB_weekday(fromDate);
     }
-    return val;
 }
 
+// needed for getDateInfo function
+static long asfreq_DtoD(long fromDate, char relation, asfreq_info *af_info) { return fromDate; }
+
+static long asfreq_DtoHIGHFREQ(long fromDate, char relation, long periodsPerDay) {
+    if (fromDate >= HIGHFREQ_ORIG) {
+        if (relation == 'S') { return (fromDate - HIGHFREQ_ORIG)*(periodsPerDay) + 1; }
+        else                 { return (fromDate - HIGHFREQ_ORIG + 1)*(periodsPerDay); }
+    } else { return -1; }
+}
+
+static long asfreq_DtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24); }
+static long asfreq_DtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24*60); }
+static long asfreq_DtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24*60*60); }
+
+//************ FROM SECONDLY ***************
+
+static long asfreq_StoD(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/(60*60*24) + HIGHFREQ_ORIG; }
+
+static long asfreq_StoA(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_StoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_StoM(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_StoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_StoB(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_StoB_forConvert(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_StoT(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/60 + 1; }
+static long asfreq_StoH(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/(60*60) + 1; }
+
+//************ FROM MINUTELY ***************
 
+static long asfreq_TtoD(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/(60*24) + HIGHFREQ_ORIG; }
 
-// NPY_NO_EXPORT
-ts_datetime
-PyDatetime_to_tsdatetime(ts_metadata *meta, PyObject *datetime)
-{
-    ts_datetimestruct dinfo;
-    ts_datetime val;
-
-    if (!PyDateTime_Check(datetime) && !PyDate_Check(datetime)){
-        PyObject *err_msg, *_type;
-        _type = PyObject_Type(datetime);
-        err_msg = PyString_FromString("Expected a datetime.date(time) object, received: ");
-        PyString_ConcatAndDel(&err_msg, PyObject_Str(_type));
-        PyErr_SetString(PyExc_TypeError, PyString_AsString(err_msg));
-        Py_DECREF(_type);
-        Py_DECREF(err_msg);
-        val = -1;
+static long asfreq_TtoA(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_TtoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_TtoM(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_TtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_TtoB(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_TtoB_forConvert(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_TtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/60 + 1; }
+static long asfreq_TtoS(long fromDate, char relation, asfreq_info *af_info) {
+    if (relation == 'S') {  return fromDate*60 - 59; }
+    else                 {  return fromDate*60;      }}
+
+//************ FROM HOURLY ***************
+
+static long asfreq_HtoD(long fromDate, char relation, asfreq_info *af_info)
+    { return (fromDate - 1)/24 + HIGHFREQ_ORIG; }
+static long asfreq_HtoA(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_HtoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_HtoM(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_HtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static long asfreq_HtoB(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_HtoB_forConvert(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+// calculation works out the same as TtoS, so we just call that function for HtoT
+static long asfreq_HtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_TtoS(fromDate, relation, &NULL_AF_INFO); }
+static long asfreq_HtoS(long fromDate, char relation, asfreq_info *af_info) {
+    if (relation == 'S') {  return fromDate*60*60 - 60*60 + 1; }
+    else                 {  return fromDate*60*60;             }}
+
+//************ FROM BUSINESS ***************
+
+static long asfreq_BtoD(long fromDate, char relation, asfreq_info *af_info)
+    { return ((fromDate-1)/5)*7 + (fromDate-1)%5 + 1; }
+
+static long asfreq_BtoA(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_BtoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_BtoM(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_BtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_BtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_BtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static long asfreq_BtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+//************ FROM WEEKLY ***************
+
+static long asfreq_WtoD(long fromDate, char relation, asfreq_info *af_info) {
+    if (relation == 'S') { return fromDate * 7 - 6 + af_info->from_week_end;}
+    else                 { return fromDate * 7 + af_info->from_week_end; }
+}
+
+static long asfreq_WtoA(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_WtoD(fromDate, 'E', af_info), relation, af_info); }
+static long asfreq_WtoQ(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoQ(asfreq_WtoD(fromDate, 'E', af_info), relation, af_info); }
+static long asfreq_WtoM(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoM(asfreq_WtoD(fromDate, 'E', af_info), relation, &NULL_AF_INFO); }
+
+static long asfreq_WtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_WtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_WtoB(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_WtoD(fromDate, relation, af_info),
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
+    else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
+}
+
+static long asfreq_WtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_WtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_WtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+
+//************ FROM MONTHLY ***************
+
+static void MtoD_ym(long fromDate, long *y, long *m) {
+    *y = (fromDate - 1) / 12 + 1;
+    *m = fromDate - 12 * (*y) - 1;
+}
+
+static long asfreq_MtoD(long fromDate, char relation, asfreq_info *af_info) {
+
+    long y, m, absdate;
+
+    if (relation == 'S') {
+        MtoD_ym(fromDate, &y, &m);
+        if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
+        return absdate;
+    } else {
+        MtoD_ym(fromDate+1, &y, &m);
+        if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
+        return absdate-1;
     }
-    else {
-        dinfo.year = (npy_int64)PyDateTime_GET_YEAR(datetime);
-        dinfo.month = PyDateTime_GET_MONTH(datetime);
-        dinfo.day = (int)PyDateTime_GET_DAY(datetime);
-        dinfo.hour = (int)PyDateTime_DATE_GET_HOUR(datetime);
-        dinfo.min = (int)PyDateTime_DATE_GET_MINUTE(datetime);
-        dinfo.sec = (int)PyDateTime_DATE_GET_SECOND(datetime);
-        //
-        val = datetimestruct_to_tsdatetime(meta, &dinfo);
+}
+
+static long asfreq_MtoA(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_MtoD(fromDate, 'E', &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_MtoQ(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoQ(asfreq_MtoD(fromDate, 'E', &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_MtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+
+static long asfreq_MtoB(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_MtoD(fromDate, relation, &NULL_AF_INFO),
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
+    else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
+}
+
+static long asfreq_MtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_MtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static long asfreq_MtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+//************ FROM QUARTERLY ***************
+
+static void QtoD_ym(long fromDate, long *y, long *m, asfreq_info *af_info) {
+
+    *y = (fromDate - 1) / 4 + 1;
+    *m = (fromDate + 4) * 3 - 12 * (*y) - 2;
+
+    if (af_info->from_q_year_end != 12) {
+        *m += af_info->from_q_year_end;
+        if (*m > 12) { *m -= 12; }
+        else { *y -= 1; }
     }
-    return val;
 }
 
+static long asfreq_QtoD(long fromDate, char relation, asfreq_info *af_info) {
 
+    long y, m, absdate;
 
-// NPY_NO_EXPORT
-ts_datetime
-PyString_to_tsdatetime(ts_metadata *meta, PyObject *string)
-{
-    ts_datetime val;
-    PyObject *pydatetime;
-    PyObject *string_arg = PyTuple_New(1);
-
-    PyTuple_SET_ITEM(string_arg, 0, string);
-    Py_INCREF(string);
-    if (meta->unit > FR_DAY) {
-        pydatetime = PyEval_CallObject(DateTimeFromString, string_arg);
+    if (relation == 'S') {
+        QtoD_ym(fromDate, &y, &m, af_info);
+        if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
+        return absdate;
     } else {
-        pydatetime = PyEval_CallObject(DateFromString, string_arg);
-    };
-    Py_DECREF(string_arg);
-    val = PyDatetime_to_tsdatetime(meta, pydatetime);
-    Py_DECREF(pydatetime);
-    return val;
+        QtoD_ym(fromDate+1, &y, &m, af_info);
+        if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
+        return absdate - 1;
+    }
 }
 
+static long asfreq_QtoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
 
+static long asfreq_QtoA(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
 
-PyObject *
-PyDateTime_FromFreqAndValue(ts_datetime val, ts_metadata *meta)
-{
-    PyObject *pydatetime;
-    npy_int64 absdate, abstime=0;
-    int hour=0, minute=0, second=0;
-    ts_datetimestruct dinfo;
+static long asfreq_QtoM(long fromDate, char relation, asfreq_info *af_info) {
+    return asfreq_DtoM(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+
+static long asfreq_QtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_QtoB(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_QtoD(fromDate, relation, af_info),
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
+    else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
+}
+
+
+static long asfreq_QtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_QtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_QtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+
+
+//************ FROM ANNUAL ***************
+
+static long asfreq_AtoD(long fromDate, char relation, asfreq_info *af_info) {
+    long absdate, year, final_adj;
+    int month = (af_info->from_a_year_end) % 12;
+
+    if (month == 0) { month = 1; }
+    else { month += 1; }
+
+    if (relation == 'S') {
+        if (af_info->from_a_year_end == 12) {year = fromDate;}
+        else {year = fromDate - 1;}
+        final_adj = 0;
+    } else {
+        if (af_info->from_a_year_end == 12) {year = fromDate+1;}
+        else {year = fromDate;}
+        final_adj = -1;
+    }
+    absdate = absdate_from_ymd(year, month, 1);
+    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
+    return absdate + final_adj;
+}
+
+static long asfreq_AtoA(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_AtoQ(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_AtoM(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_AtoW(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+
+static long asfreq_AtoB(long fromDate, char relation, asfreq_info *af_info) {
+
+    struct date_info dinfo;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_AtoD(fromDate, relation, af_info),
+                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+
+    if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
+    else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
+}
 
-    int unit = meta->unit;
+static long asfreq_AtoH(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_AtoT(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static long asfreq_AtoS(long fromDate, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
 
-    conversion_function todays = get_converter_to_days(unit, 0);
-    meta->convert_to_start = 0;
+static long nofunc(long fromDate, char relation, asfreq_info *af_info) { return -1; }
 
-    absdate = todays(val, meta);
-    if (unit > FR_DAY)
-        abstime = _secs_from_midnight(val, unit);
-    set_datetimestruct_from_days_and_secs(&dinfo, absdate, abstime);
+// end of frequency specific conversion routines
+
+// return a pointer to appropriate conversion function
+long (*get_asfreq_func(int fromFreq, int toFreq, int forConvert))(long, char, asfreq_info*) {
+
+    int fromGroup = get_freq_group(fromFreq);
+    int toGroup = get_freq_group(toFreq);
+
+    if (fromGroup == FR_UND) { fromGroup = FR_DAY; }
+
+    switch(fromGroup)
+    {
+        case FR_ANN:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_AtoA;
+                case FR_QTR: return &asfreq_AtoQ;
+                case FR_MTH: return &asfreq_AtoM;
+                case FR_WK: return &asfreq_AtoW;
+                case FR_BUS: return &asfreq_AtoB;
+                case FR_DAY: return &asfreq_AtoD;
+                case FR_HR: return &asfreq_AtoH;
+                case FR_MIN: return &asfreq_AtoT;
+                case FR_SEC: return &asfreq_AtoS;
+                default: return &nofunc;
+            }
+
+        case FR_QTR:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_QtoA;
+                case FR_QTR: return &asfreq_QtoQ;
+                case FR_MTH: return &asfreq_QtoM;
+                case FR_WK: return &asfreq_QtoW;
+                case FR_BUS: return &asfreq_QtoB;
+                case FR_DAY: return &asfreq_QtoD;
+                case FR_HR: return &asfreq_QtoH;
+                case FR_MIN: return &asfreq_QtoT;
+                case FR_SEC: return &asfreq_QtoS;
+                default: return &nofunc;
+            }
+
+        case FR_MTH:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_MtoA;
+                case FR_QTR: return &asfreq_MtoQ;
+                case FR_WK: return &asfreq_MtoW;
+                case FR_BUS: return &asfreq_MtoB;
+                case FR_DAY: return &asfreq_MtoD;
+                case FR_HR: return &asfreq_MtoH;
+                case FR_MIN: return &asfreq_MtoT;
+                case FR_SEC: return &asfreq_MtoS;
+                default: return &nofunc;
+            }
+
+        case FR_WK:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_WtoA;
+                case FR_QTR: return &asfreq_WtoQ;
+                case FR_MTH: return &asfreq_WtoM;
+                case FR_WK: return &asfreq_WtoW;
+                case FR_BUS: return &asfreq_WtoB;
+                case FR_DAY: return &asfreq_WtoD;
+                case FR_HR: return &asfreq_WtoH;
+                case FR_MIN: return &asfreq_WtoT;
+                case FR_SEC: return &asfreq_WtoS;
+                default: return &nofunc;
+            }
+
+        case FR_BUS:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_BtoA;
+                case FR_QTR: return &asfreq_BtoQ;
+                case FR_MTH: return &asfreq_BtoM;
+                case FR_WK: return &asfreq_BtoW;
+                case FR_DAY: return &asfreq_BtoD;
+                case FR_HR: return &asfreq_BtoH;
+                case FR_MIN: return &asfreq_BtoT;
+                case FR_SEC: return &asfreq_BtoS;
+                default: return &nofunc;
+            }
+
+        case FR_DAY:
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_DtoA;
+                case FR_QTR: return &asfreq_DtoQ;
+                case FR_MTH: return &asfreq_DtoM;
+                case FR_WK: return &asfreq_DtoW;
+                case FR_BUS:
+                    if (forConvert) { return &asfreq_DtoB_forConvert; }
+                    else            { return &asfreq_DtoB; }
+                case FR_DAY: return &asfreq_DtoD;
+                case FR_HR: return &asfreq_DtoH;
+                case FR_MIN: return &asfreq_DtoT;
+                case FR_SEC: return &asfreq_DtoS;
+                default: return &nofunc;
+            }
 
-    switch(unit) {
         case FR_HR:
-            hour = dinfo.hour;
-            break;
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_HtoA;
+                case FR_QTR: return &asfreq_HtoQ;
+                case FR_MTH: return &asfreq_HtoM;
+                case FR_WK: return &asfreq_HtoW;
+                case FR_BUS:
+                    if (forConvert) { return &asfreq_HtoB_forConvert; }
+                    else            { return &asfreq_HtoB; }
+                case FR_DAY: return &asfreq_HtoD;
+                case FR_MIN: return &asfreq_HtoT;
+                case FR_SEC: return &asfreq_HtoS;
+                default: return &nofunc;
+            }
+
         case FR_MIN:
-            hour = dinfo.hour;
-            minute = dinfo.min;
-            break;
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_TtoA;
+                case FR_QTR: return &asfreq_TtoQ;
+                case FR_MTH: return &asfreq_TtoM;
+                case FR_WK: return &asfreq_TtoW;
+                case FR_BUS:
+                    if (forConvert) { return &asfreq_TtoB_forConvert; }
+                    else            { return &asfreq_TtoB; }
+                case FR_DAY: return &asfreq_TtoD;
+                case FR_HR: return &asfreq_TtoH;
+                case FR_SEC: return &asfreq_TtoS;
+                default: return &nofunc;
+            }
+
         case FR_SEC:
-            hour = dinfo.hour;
-            minute = dinfo.min;
-            second = (int)dinfo.sec;
-            break;
+            switch(toGroup)
+            {
+                case FR_ANN: return &asfreq_StoA;
+                case FR_QTR: return &asfreq_StoQ;
+                case FR_MTH: return &asfreq_StoM;
+                case FR_WK: return &asfreq_StoW;
+                case FR_BUS:
+                    if (forConvert) { return &asfreq_StoB_forConvert; }
+                    else            { return &asfreq_StoB; }
+                case FR_DAY: return &asfreq_StoD;
+                case FR_HR: return &asfreq_StoH;
+                case FR_MIN: return &asfreq_StoT;
+                default: return &nofunc;
+            }
+        default: return &nofunc;
     }
-    pydatetime = PyDateTime_FromDateAndTime(dinfo.year, dinfo.month, dinfo.day,
-                                            hour, minute, second, 0);
-    return pydatetime;
 }
 
+static int calc_a_year_end(int freq, int group) {
+    int result = (freq - group) % 12;
+    if (result == 0) {return 12;}
+    else {return result;}
+}
+
+static int calc_week_end(int freq, int group) {
+    return freq - group;
+}
+
+void get_asfreq_info(int fromFreq, int toFreq, asfreq_info *af_info) {
 
+    int fromGroup = get_freq_group(fromFreq);
+    int toGroup = get_freq_group(toFreq);
 
+    switch(fromGroup)
+    {
+        case FR_WK: {
+            af_info->from_week_end = calc_week_end(fromFreq, fromGroup);
+        } break;
+        case FR_ANN: {
+            af_info->from_a_year_end = calc_a_year_end(fromFreq, fromGroup);
+        } break;
+        case FR_QTR: {
+            af_info->from_q_year_end = calc_a_year_end(fromFreq, fromGroup);
+        } break;
+
+    }
+
+    switch(toGroup)
+    {
+        case FR_WK: {
+            af_info->to_week_end = calc_week_end(toFreq, toGroup);
+        } break;
+        case FR_ANN: {
+            af_info->to_a_year_end = calc_a_year_end(toFreq, toGroup);
+        } break;
+        case FR_QTR: {
+            af_info->to_q_year_end = calc_a_year_end(toFreq, toGroup);
+        } break;
+    }
+
+}
+
+static double getAbsTime(int freq, long dailyDate, long originalDate) {
+
+    long startOfDay, periodsPerDay;
+
+    switch(freq)
+    {
+        case FR_HR:
+            periodsPerDay = 24;
+            break;
+        case FR_MIN:
+            periodsPerDay = 24*60;
+            break;
+        case FR_SEC:
+            periodsPerDay = 24*60*60;
+            break;
+        default:
+            return 24*60*60 - 1;
+    }
 
+    startOfDay = asfreq_DtoHIGHFREQ(dailyDate, 'S', periodsPerDay);
+    return (24*60*60)*((double)(originalDate - startOfDay))/((double)periodsPerDay);
+}
 
 /************************************************************
 ** Date type definition
 ************************************************************/
 
+typedef struct {
+    PyObject_HEAD
+    int freq; /* frequency of date */
+    long value; /* integer representation of date */
+    PyObject* cached_vals;
+} DateObject;
+
+/* Forward declarations */
+static PyTypeObject DateType;
+#define DateObject_Check(op) PyObject_TypeCheck(op, &DateType)
+
 static void
-DatetimeObject_dealloc(DatetimeObject* self) {
+DateObject_dealloc(DateObject* self) {
+    Py_XDECREF(self->cached_vals);
     self->ob_type->tp_free((PyObject*)self);
 }
 
 
+static PyObject *freq_dict, *freq_dict_rev, *freq_constants;
+
+#define DICT_SETINT_STRKEY(dict, key, val) \
+    {PyObject *pyval = PyInt_FromLong(val); \
+     PyDict_SetItemString(dict, key, pyval); \
+     Py_DECREF(pyval); }
+
+#define ADD_FREQ_CONSTANT(const_name, val) \
+    DICT_SETINT_STRKEY(freq_constants, const_name, val)
+
+#define INIT_FREQ(const_name, key, aliases) \
+    {PyObject *pykey = PyInt_FromLong(key); \
+     PyDict_SetItem(freq_dict, pykey, aliases); \
+     PyDict_SetItemString(freq_constants, const_name, pykey); \
+     Py_DECREF(pykey); \
+     Py_DECREF(aliases); }
+
+
+static int init_freq_group(int num_items, int num_roots, int base_const,
+                            char item_abbrevs[][2][10], char group_prefixes[][15],
+                            char item_const_names[][15]) {
+
+    int i;
+
+    for (i = 0; i < num_items; i++) {
+
+        PyObject *aliases;
+        int j, size, k;
+
+        if (i == 0) { k = 3; } else { k = 2; }
+
+        size = num_roots * k;
+
+        aliases = PyTuple_New(size);
+
+        for (j = 0; j < num_roots; j++) {
+            PyObject *alias_v1, *alias_v2;
+            char *root, *alt;
+
+            if ((root = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
+            if ((alt = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
+
+            strcpy(root, group_prefixes[j]);
+            strcpy(alt, group_prefixes[j]);
+
+            if (i == 0) {
+                PyObject *alias = PyString_FromString(root);
+                PyTuple_SET_ITEM(aliases, j*k + 2, alias);
+            }
+
+            strcat(root, "-");
+            strcat(root, item_abbrevs[i][0]);
+            strcat(alt, "-");
+            strcat(alt, item_abbrevs[i][1]);
+
+            alias_v1 = PyString_FromString(root);
+            alias_v2 = PyString_FromString(alt);
+
+            free(root);
+            free(alt);
+
+            PyTuple_SET_ITEM(aliases, j*k, alias_v1);
+            PyTuple_SET_ITEM(aliases, j*k + 1, alias_v2);
+        }
+
+        INIT_FREQ(item_const_names[i], base_const+i, aliases);
+    }
+
+    return 0;
+}
+
+/* take a dictionary with integer keys and tuples of strings for values,
+   and populate a dictionary with all the strings as keys and integers
+   for values */
+static int reverse_dict(PyObject *source, PyObject *dest) {
+
+    PyObject *key, *value;
+
+    Py_ssize_t pos = 0;
+
+    while (PyDict_Next(source, &pos, &key, &value)) {
+        PyObject *tuple_iter;
+        PyObject *item;
+
+        if((tuple_iter = PyObject_GetIter(value)) == NULL) return INT_ERR_CODE;
+
+        while ((item = PyIter_Next(tuple_iter)) != NULL) {
+            PyDict_SetItem(dest, item, key);
+            Py_DECREF(item);
+        }
+        Py_DECREF(tuple_iter);
+    }
+    return 0;
+}
+
+static int build_freq_dict(void) {
+
+    char ANN_prefixes[8][15] = { "A", "Y", "ANN", "ANNUAL", "ANNUALLY",
+                                 "YR", "YEAR", "YEARLY" };
+
+    char QTRE_prefixes[8][15] = { "Q", "QTR", "QUARTER", "QUARTERLY", "Q-E",
+                                  "QTR-E", "QUARTER-E", "QUARTERLY-E"};
+    char QTRS_prefixes[4][15] = { "Q-S", "QTR-S", "QUARTER-S", "QUARTERLY-S" };
+
+    char WK_prefixes[4][15] =  { "W", "WK", "WEEK", "WEEKLY" };
+
+    /* Note: order of this array must match up with how the Annual
+       frequency constants are lined up */
+    char month_names[12][2][10] = {
+        { "DEC", "DECEMBER" },
+        { "JAN", "JANUARY" },
+        { "FEB", "FEBRUARY" },
+        { "MAR", "MARCH" },
+        { "APR", "APRIL" },
+        { "MAY", "MAY" },
+        { "JUN", "JUNE" },
+        { "JUL", "JULY" },
+        { "AUG", "AUGUST" },
+        { "SEP", "SEPTEMBER" },
+        { "OCT", "OCTOBER" },
+        { "NOV", "NOVEMBER" }};
+
+    char day_names[7][2][10] = {
+        { "SUN", "SUNDAY" },
+        { "MON", "MONDAY" },
+        { "TUE", "TUESDAY" },
+        { "WED", "WEDNESDAY" },
+        { "THU", "THURSDAY" },
+        { "FRI", "FRIDAY" },
+        { "SAT", "SATURDAY" }};
+
+    char ANN_const_names[12][15] = {
+        "FR_ANNDEC",
+        "FR_ANNJAN",
+        "FR_ANNFEB",
+        "FR_ANNMAR",
+        "FR_ANNAPR",
+        "FR_ANNMAY",
+        "FR_ANNJUN",
+        "FR_ANNJUL",
+        "FR_ANNAUG",
+        "FR_ANNSEP",
+        "FR_ANNOCT",
+        "FR_ANNNOV"};
+
+    char QTRE_const_names[12][15] = {
+        "FR_QTREDEC",
+        "FR_QTREJAN",
+        "FR_QTREFEB",
+        "FR_QTREMAR",
+        "FR_QTREAPR",
+        "FR_QTREMAY",
+        "FR_QTREJUN",
+        "FR_QTREJUL",
+        "FR_QTREAUG",
+        "FR_QTRESEP",
+        "FR_QTREOCT",
+        "FR_QTRENOV"};
+
+    char QTRS_const_names[12][15] = {
+        "FR_QTRSDEC",
+        "FR_QTRSJAN",
+        "FR_QTRSFEB",
+        "FR_QTRSMAR",
+        "FR_QTRSAPR",
+        "FR_QTRSMAY",
+        "FR_QTRSJUN",
+        "FR_QTRSJUL",
+        "FR_QTRSAUG",
+        "FR_QTRSSEP",
+        "FR_QTRSOCT",
+        "FR_QTRSNOV"};
+
+    char WK_const_names[7][15] = {
+        "FR_WKSUN",
+        "FR_WKMON",
+        "FR_WKTUE",
+        "FR_WKWED",
+        "FR_WKTHU",
+        "FR_WKFRI",
+        "FR_WKSAT"};
+
+    PyObject *aliases;
+
+    freq_dict = PyDict_New();
+    freq_dict_rev = PyDict_New();
+    freq_constants = PyDict_New();
+
+    aliases = Py_BuildValue("(ssss)", "M", "MTH", "MONTH", "MONTHLY");
+    INIT_FREQ("FR_MTH", FR_MTH, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "B", "BUS", "BUSINESS", "BUSINESSLY");
+    INIT_FREQ("FR_BUS", FR_BUS, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "D", "DAY", "DLY", "DAILY");
+    INIT_FREQ("FR_DAY", FR_DAY, aliases);
+
+    aliases = Py_BuildValue("(sssss)", "H", "HR", "HOUR", "HRLY", "HOURLY");
+    INIT_FREQ("FR_HR", FR_HR, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "T", "MIN", "MINUTE", "MINUTELY");
+    INIT_FREQ("FR_MIN", FR_MIN, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "S", "SEC", "SECOND", "SECONDLY");
+    INIT_FREQ("FR_SEC", FR_SEC, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "U", "UND", "UNDEF", "UNDEFINED");
+    INIT_FREQ("FR_UND", FR_UND, aliases);
+
+    ADD_FREQ_CONSTANT("FR_ANN", FR_ANN);
+
+    if(init_freq_group(12, 8, FR_ANN,
+        month_names, ANN_prefixes, ANN_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    ADD_FREQ_CONSTANT("FR_QTR", FR_QTR);
+
+    if(init_freq_group(12, 8, FR_QTREDEC,
+        month_names, QTRE_prefixes, QTRE_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    if(init_freq_group(12, 4, FR_QTRSDEC,
+        month_names, QTRS_prefixes, QTRS_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    ADD_FREQ_CONSTANT("FR_WK", FR_WK);
+
+    if(init_freq_group(7, 4, FR_WK,
+                    day_names, WK_prefixes, WK_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    if(reverse_dict(freq_dict, freq_dict_rev) == INT_ERR_CODE) {
+        return INT_ERR_CODE;
+    }
+
+    return 0;
+}
+
+
+/* take user specified frequency and convert to int representation
+   of the frequency */
+int check_freq(PyObject *freq_spec) {
+
+    if (PyInt_Check(freq_spec)) {
+        return (int)PyInt_AsLong(freq_spec);
+    } else if (PyString_Check(freq_spec)) {
+        char *freq_str, *freq_str_uc;
+        PyObject *freq_val;
+
+        freq_str = PyString_AsString(freq_spec);
+        if((freq_str_uc = str_uppercase(freq_str)) == NULL) {return INT_ERR_CODE;}
+
+        freq_val = PyDict_GetItemString(freq_dict_rev, freq_str_uc);
+
+        free(freq_str_uc);
+
+        if (freq_val == NULL) {
+            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
+            return INT_ERR_CODE;
+        } else {
+            int ret_val = (int)PyInt_AsLong(freq_val);
+            return ret_val;
+        }
+    } else if (freq_spec == Py_None) {
+        return FR_UND;
+    } else {
+        int retval = (int)PyInt_AsLong(freq_spec);
+        if (PyErr_Occurred()) {
+            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
+            return INT_ERR_CODE;
+        } else { return retval; }
+    }
+
+}
+
 static PyObject *
-DatetimeObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
-    DatetimeObject *self;
-    self = (DatetimeObject*)type->tp_alloc(type, 0);
+DateObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
 
-    // Initialize the metadata
-    ts_metadata meta = {FR_UND, 1, 0, -1, -1, 0};
+    DateObject *self;
 
+    self = (DateObject*)type->tp_alloc(type, 0);
     if (self != NULL) {
         // initialize attributes that need initializing in here
-        self->obval = -1;
-        self->obmeta = meta;
+        self->freq = FR_UND;
+        self->value = -1;
     }
+
     return (PyObject *)self;
 }
 
-
 /* for use in C code */
-static DatetimeObject *
-DatetimeObject_New(void) {
-    PyObject *dummy=NULL;
-    return (DatetimeObject*)DatetimeObject_new(&DatetimeObject_Type, dummy, dummy);
+static DateObject *
+DateObject_New(void) {
+    PyObject *dummy;
+    return (DateObject*)DateObject_new(&DateType, dummy, dummy);
 }
 
-
+#define INIT_ERR(errortype, errmsg) PyErr_SetString(errortype,errmsg);return -1
 
 static int
-DatetimeObject_init(DatetimeObject *self, PyObject *args, PyObject *kwds) {
+DateObject_init(DateObject *self, PyObject *args, PyObject *kwds) {
 
     PyObject *freq=NULL, *value=NULL, *datetime=NULL, *string=NULL;
     char *INSUFFICIENT_MSG = "insufficient parameters to initialize Date";
@@ -286,7 +1373,8 @@ DatetimeObject_init(DatetimeObject *self, PyObject *args, PyObject *kwds) {
 
     int year=def_info, month=def_info, day=def_info, quarter=def_info,
         hour=def_info, minute=def_info, second=def_info;
-    int unit;
+
+    int free_dt=0;
 
     static char *kwlist[] = {"freq", "value", "string",
                              "year", "month", "day", "quarter",
@@ -298,315 +1386,195 @@ DatetimeObject_init(DatetimeObject *self, PyObject *args, PyObject *kwds) {
                                       &year, &month, &day, &quarter,
                                       &hour, &minute, &second,
                                       &datetime)) {
-        return -1;
-    }
-
-    if (PyObject_HasAttrString(freq, "unit")) {
-        PyObject *freq_attr = PyObject_GetAttrString(freq, "unit");
-        unit = PyInt_AS_LONG(freq_attr);
-        Py_DECREF(freq_attr);
-    } else {
-        if((unit = check_freq(freq)) == INT_ERR_CODE) return -1;
-    }
-    init_metadata_from_unit(&self->obmeta, unit);
-    unit = self->obmeta.unit;
-
-    // The input value is a date string...
-    if ((value && PyString_Check(value)) || string) {
-        if (!string)
-            string = value;
-        self->obval = PyString_to_tsdatetime(&(self->obmeta), string);
-    }
-    // The input is a datetime.date(time) object:
-    else if ((value && (PyDateTime_Check(value) || PyDate_Check(value))) ||
-             datetime) {
-        if (!datetime)
-            datetime = value;
-        self->obval = PyDatetime_to_tsdatetime(&(self->obmeta), datetime);
-    }
-    // The input is a value
-    else if (value) {
-        self->obval = PyInt_AsLong(value);
-    }
-    // The input is a list of arguments
-    else {
-        // We always must have a year defined
-        if (year == def_info) {
-            INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-        };
-        // For weekly to daily (undefined) units, we need month and day
-        if (unit == FR_BUS || unit == FR_DAY || unit == FR_WK || unit == FR_UND) {
-            if (month == def_info || day == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            };
-                // if FR_BUS, check for week day
-        }
-        // Need a month for monthly
-        else if (unit == FR_MTH) {
-            if (month == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-        }
-        else if (unit == FR_QTR) {
-            if (quarter == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-            month = (quarter-1) * 3 + 1;
-        }
-        else if (unit == FR_SEC) {
-            if (month == def_info || day == def_info || second == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-            if (hour == def_info) {
-                hour = second/3600;
-                minute = (second % 3600)/60;
-                second = second % 60;
-            }
-            else if (minute == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-        }
-        else if (unit == FR_MIN) {
-            if (month == def_info || day == def_info || minute == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-            if (hour == def_info) {
-                hour = minute/60;
-                minute = minute % 60;
-            }
-        }
-        else if (unit == FR_HR) {
-            if (month == def_info || day == def_info || hour == def_info) {
-                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
-            }
-        };
-        /*Fill the structure from the input, and get the corresponding datetime*/
-        ts_datetimestruct dinfo;
-        dinfo.year = year;
-        dinfo.month = month;
-        dinfo.day = day;
-        dinfo.hour = hour;
-        dinfo.min = minute;
-        dinfo.sec = second;
-        self->obval = datetimestruct_to_tsdatetime(&(self->obmeta), &dinfo);
-    }
-    return 0;
-}
-
-
-static PyMemberDef DatetimeObject_members[] = {
-    {"value", T_INT, offsetof(DatetimeObject, obval), 0,
-     "integer representation of the Date"},
-    {NULL}  /* Sentinel */
-};
+        return -1;
+    }
 
+    if (PyObject_HasAttrString(freq, "freq")) {
+        PyObject *freq_attr = PyObject_GetAttrString(freq, "freq");
+        self->freq = PyInt_AS_LONG(freq_attr);
+        Py_DECREF(freq_attr);
+    } else {
+        if((self->freq = check_freq(freq)) == INT_ERR_CODE) return -1;
+    }
 
+    if ((value && PyString_Check(value)) || string) {
 
-typedef struct {
-    PyObject_HEAD;
-    int unit; /* frequency of date */
-    int freq;
-    long years;
-    long months;
-    long days;
-    long seconds;
-//    PyObject* cached_vals;
-} TimeDeltaObject;
+        PyObject *string_arg = PyTuple_New(1);
+        int freq_group = get_freq_group(self->freq);
 
-/* Forward declarations */
-static PyTypeObject TimeDeltaType;
-#define TimeDelta_Check(op) PyObject_TypeCheck(op, &TimeDeltaType)
+        free_dt = 1;
 
-static void
-TimeDeltaObject_dealloc(TimeDeltaObject* self) {
-//    Py_XDECREF(self->cached_vals);
-    self->ob_type->tp_free((PyObject*)self);
-}
+        if (!string) {
+            string = value;
+        }
 
+        PyTuple_SET_ITEM(string_arg, 0, string);
+        Py_INCREF(string);
 
-static PyObject *
-TimeDeltaObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
-    TimeDeltaObject *self;
-    self = (TimeDeltaObject*)type->tp_alloc(type, 0);
-    if (self != NULL) {
-        // initialize attributes that need initializing in here
-        self->unit = FR_UND;
-        self->freq = self->unit;
-        self->months = 0;
-        self->days = 0;
-        self->seconds = 0;
-    }
-    return (PyObject *)self;
-}
+        if (freq_group == FR_HR ||
+            freq_group == FR_MIN ||
+            freq_group == FR_SEC)
+             { datetime = PyEval_CallObject(DateTimeFromString, string_arg); }
+        else { datetime = PyEval_CallObject(DateFromString, string_arg); }
 
+        Py_DECREF(string_arg);
 
-static TimeDeltaObject *
-TimeDeltaObject_New(void) {
-    PyObject *dummy=NULL;
-    return (TimeDeltaObject*)TimeDeltaObject_new(&TimeDeltaType, dummy, dummy);
-}
+        value = NULL;
+    }
 
+    if (value && (PyDateTime_Check(value) || PyDate_Check(value))) {
+        if (!datetime) {
+            datetime = value;
+        }
+        value = NULL;
+    } // datetime = (datetime||value), value = NULL
 
-#define INIT_ERR(errortype, errmsg) PyErr_SetString(errortype,errmsg);return -1
 
-#define get_timedelta_months(o)  (((TimeDeltaObject *)(o))->months)
-#define get_timedelta_days(o)    (((TimeDeltaObject *)(o))->days)
-#define get_timedelta_seconds(o) (((TimeDeltaObject *)(o))->seconds)
+    if (value) {
+        self->value = PyInt_AsLong(value);
+    } else {
 
+        int freq_group = get_freq_group(self->freq);
+
+        if (datetime) {
+            if (PyDateTime_Check(datetime) || PyDate_Check(datetime)) {
+                year=PyDateTime_GET_YEAR(datetime);
+                month=PyDateTime_GET_MONTH(datetime);
+                quarter=((month-1)/3)+1;
+                day=PyDateTime_GET_DAY(datetime);
+                hour=PyDateTime_DATE_GET_HOUR(datetime);
+                minute=PyDateTime_DATE_GET_MINUTE(datetime);
+                second=PyDateTime_DATE_GET_SECOND(datetime);
+            } else {
+                PyObject *err_msg, *_type;
+                _type = PyObject_Type(datetime);
+                err_msg = PyString_FromString("Expected datetime object, received: ");
+                PyString_ConcatAndDel(&err_msg, PyObject_Str(_type));
+                PyErr_SetString(PyExc_TypeError, PyString_AsString(err_msg));
+                Py_DECREF(_type);
+                Py_DECREF(err_msg);
+                return -1;
+            }
+        }
 
+        if (!datetime) {
 
-static int
-TimeDeltaObject_init(TimeDeltaObject *self, PyObject *args, PyObject *kwds) {
+            // First, some basic checks.....
+            if (year == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+            if (self->freq == FR_BUS ||
+               self->freq == FR_DAY ||
+               self->freq == FR_WK ||
+               self->freq == FR_UND) {
+                if (month == def_info || day == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
 
-    PyObject *unit=NULL, *freq=NULL, *value=NULL, *delta=NULL;
-    PyObject *py_years=NULL, *py_months=NULL, *py_days=NULL, *py_quarters=NULL;
-    PyObject *py_hours=NULL, *py_minutes=NULL, *py_seconds=NULL;
-    npy_int64 months=0, days=0, seconds=0;
+                // if FR_BUS, check for week day
 
-    int fr_group;
-    int free_dt=0;
+            } else if (self->freq == FR_MTH) {
+                if (month == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+            } else if (freq_group == FR_QTR) {
+                if (quarter == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+            } else if (self->freq == FR_SEC) {
+                if (month == def_info ||
+                    day == def_info ||
+                    second == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+                if (hour == def_info) {
+                    hour = second/3600;
+                    minute = (second % 3600)/60;
+                    second = second % 60;
+                } else if (minute == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+            } else if (self->freq == FR_MIN) {
+                if (month == def_info ||
+                    day == def_info ||
+                    minute == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+                if (hour == def_info) {
+                    hour = minute/60;
+                    minute = minute % 60;
+                }
+            } else if (self->freq == FR_HR) {
+                if (month == def_info ||
+                    day == def_info ||
+                    hour == def_info) {
+                    INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+                }
+            }
 
-    static char *kwlist[] = {"unit", "value",
-                             "years", "months", "days", "quarters",
-                             "hours", "minutes", "seconds",
-                             "timedelta", "freq", NULL};
-
-    // Check the parameters
-    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|OOOOOOOOO:__new__", kwlist,
-                                      &unit, &value,
-                                      &py_years, &py_months, &py_days, &py_quarters,
-                                      &py_hours, &py_minutes, &py_seconds,
-                                      &delta, &freq)) {
-        return -1;
-    }
+        }
 
-    // If `freq` is defined, then overwrite `unit`
-    if (freq){
-        value = unit;
-        unit = freq;
-        freq = NULL;
-    }
+        if (self->freq == FR_SEC) {
+            long absdays, delta;
+            absdays = absdate_from_ymd(year, month, day);
+            delta = (absdays - HIGHFREQ_ORIG);
+            self->value = (int)(delta*86400 + hour*3600 + minute*60 + second + 1);
+        } else if (self->freq == FR_MIN) {
+            long absdays, delta;
+            absdays = absdate_from_ymd(year, month, day);
+            delta = (absdays - HIGHFREQ_ORIG);
+            self->value = (int)(delta*1440 + hour*60 + minute + 1);
+        } else if (self->freq == FR_HR) {
+            long absdays, delta;
+            if((absdays = absdate_from_ymd(year, month, day)) == INT_ERR_CODE) return -1;
+            delta = (absdays - HIGHFREQ_ORIG);
+            self->value = (int)(delta*24 + hour + 1);
+        } else if (self->freq == FR_DAY) {
+            if((self->value = (int)absdate_from_ymd(year, month, day)) == INT_ERR_CODE) return -1;
+        } else if (self->freq == FR_UND) {
+            if((self->value = (int)absdate_from_ymd(year, month, day)) == INT_ERR_CODE) return -1;
+        } else if (self->freq == FR_BUS) {
+            long weeks, days;
+            if((days = absdate_from_ymd(year, month, day)) == INT_ERR_CODE) return -1;
+            weeks = days/7;
+            self->value = (int)(days - weeks*2);
+        } else if (freq_group == FR_WK) {
+            int adj_ordinal, ordinal, day_adj;
+            if((ordinal = (int)absdate_from_ymd(year, month, day)) == INT_ERR_CODE) return -1;
+            day_adj = (7 - (self->freq - FR_WK)) % 7;
+            adj_ordinal = ordinal + ((7 - day_adj) - ordinal % 7) % 7;
+            self->value = adj_ordinal/7;
+        } else if (self->freq == FR_MTH) {
+            self->value = (year-1)*12 + month;
+        } else if (freq_group == FR_QTR) {
+            if ((self->freq - freq_group) > 12) {
+                // quarterly frequency with year determined by ending period
+                self->value = year*4 + quarter;
+            } else {
+                /* quarterly frequency with year determined by ending period
+                   or has December year end*/
+                self->value = (year-1)*4 + quarter;
+            }
+        } else if (freq_group == FR_ANN) {
+            self->value = year;
+        }
 
-    // Process `unit`
-    if (PyObject_HasAttrString(unit, "unit")) {
-        PyObject *unit_attr = PyObject_GetAttrString(unit, "unit");
-        self->unit = PyInt_AS_LONG(unit_attr);
-        Py_DECREF(unit_attr);
     }
-    else if (PyObject_HasAttrString(unit, "freq")) {
-        PyObject *unit_attr = PyObject_GetAttrString(unit, "freq");
-        self->unit = PyInt_AS_LONG(unit_attr);
-        Py_DECREF(unit_attr);
-    }
-    else {
-        if ((self->unit = check_freq(unit)) == INT_ERR_CODE)
-            return -1;
-    };
-    self->freq = self->unit;
-    fr_group = get_base_unit(self->unit);
 
-    if (value && PyDelta_Check(value)) {
-        if (!delta) delta = value;
-        value = NULL;
-    }; // datetime = (datetime||value), value = NULL
+    if (free_dt) { Py_DECREF(datetime); }
 
-    if (value) {
-        if (fr_group == FR_ANN)
-            months = PyInt_AsLong(value) * 12;
-        else if (fr_group == FR_QTR)
-            months = PyInt_AsLong(value) * 3;
-        else if (fr_group == FR_MTH)
-            months = PyInt_AsLong(value);
-        else if (fr_group == FR_WK)
-            days = PyInt_AsLong(value) * 7;
-        else if ((fr_group == FR_BUS) || (fr_group == FR_DAY) || (fr_group == FR_UND))
-            days = PyInt_AsLong(value);
-        else if (fr_group == FR_HR)
-            seconds = PyInt_AsLong(value) * 3600;
-        else if (fr_group == FR_MIN)
-            seconds = PyInt_AsLong(value) * 60;
-        else if (fr_group == FR_SEC)
-            seconds = PyInt_AsLong(value);
-        else
-            days = PyInt_AsLong(value);
-        Py_DECREF(value);
-    };
-    if (delta) {
-        if (PyDelta_Check(delta)){
-            self->days = ((PyDateTime_Delta *)(delta))->days;
-            self->seconds = ((PyDateTime_Delta *)(delta))->seconds + \
-                            ((PyDateTime_Delta *)(delta))->microseconds/1000000;
-//            free_dt = 1;
-        }
-        else {
-            PyObject *err_msg, *_type;
-            _type = PyObject_Type(delta);
-            err_msg = PyString_FromString("Expected timedelta object, received: ");
-            PyString_ConcatAndDel(&err_msg, PyObject_Str(_type));
-            PyErr_SetString(PyExc_TypeError, PyString_AsString(err_msg));
-            Py_DECREF(_type);
-            Py_DECREF(err_msg);
-            return -1;
-        }
-    } else {
-        if (py_years){
-            months += PyInt_AsLong(py_years)*12;
-//            Py_DECREF(py_years);
-        };
-        if (py_quarters){
-            months += PyInt_AsLong(py_quarters)*3;
-//            Py_DECREF(py_quarters);
-        };
-        if (py_months){
-            months += PyInt_AsLong(py_months);
-//            Py_DECREF(py_months);
-        };
-        if (py_days){
-            days += PyInt_AsLong(py_days);
-//            Py_DECREF(py_days);
-        };
-        if (py_hours){
-            seconds += PyInt_AsLong(py_hours) * 3600;
-//            Py_DECREF(py_hours);
-        };
-        if (py_minutes){
-            seconds += PyInt_AsLong(py_minutes) * 60;
-//            Py_DECREF(py_minutes);
-        };
-        if (py_seconds){
-            seconds += PyInt_AsLong(py_seconds);
-//            Py_DECREF(py_seconds);
-        };
-        normalize_days_secs(&days, &seconds);
-
-        self->months = months;
-        self->days = days;
-        self->seconds = seconds;
-        };
-
-    if (free_dt) { Py_DECREF(delta); }
     return 0;
 }
 
-
-
-static PyMemberDef TimeDeltaObject_members[] = {
-    {"unit", T_INT, offsetof(TimeDeltaObject, unit), 0,
-     "frequency"},
-    {"freq", T_INT, offsetof(TimeDeltaObject, freq), 0,
+static PyMemberDef DateObject_members[] = {
+    {"freq", T_INT, offsetof(DateObject, freq), 0,
      "frequency"},
-    {"months", T_INT, offsetof(TimeDeltaObject, months), 0,
-     "months"},
-    {"days", T_INT, offsetof(TimeDeltaObject, days), 0,
-     "days"},
-    {"seconds", T_INT, offsetof(TimeDeltaObject, seconds), 0,
-     "seconds"},
+    {"value", T_INT, offsetof(DateObject, value), 0,
+     "integer representation of the Date"},
     {NULL}  /* Sentinel */
 };
 
-
-
-static char DatetimeObject_toordinal_doc[] =
+static char DateObject_toordinal_doc[] =
 "Returns the proleptic Gregorian ordinal of the date, as an integer.\n"
 "This corresponds to the number of days since Jan., 1st, 1AD.\n\n"
 "When the instance has a frequency less than daily, the proleptic date \n"
@@ -621,16 +1589,24 @@ static char DatetimeObject_toordinal_doc[] =
 "   >>> ts.Date('Y', '2001-01-01').toordinal()\n"
 "   730850\n"
 "   >>> # Note that 730850 = 730486 + 365 - 1\n";
+
 static PyObject *
-DatetimeObject_toordinal(DatetimeObject *self)
+DateObject_toordinal(DateObject* self)
 {
-    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
-    return PyInt_FromLong(todays(self->obval, &(self->obmeta)));
-};
+    if (self->freq == FR_DAY) {
+        return PyInt_FromLong(self->value);
+    } else {
+        long (*toDaily)(long, char, asfreq_info*) = NULL;
+        asfreq_info af_info;
 
+        toDaily = get_asfreq_func(self->freq, FR_DAY, 0);
+        get_asfreq_info(self->freq, FR_DAY, &af_info);
 
+        return PyInt_FromLong(toDaily(self->value, 'E', &af_info));
+    }
+}
 
-static char DatetimeObject_asfreq_doc[] =
+static char DateObject_asfreq_doc[] =
 "   asfreq(freq, relation='END')\n"
 "\n"
 "   Returns a :class:`Date` object converted to a specified frequency.\n"
@@ -665,27 +1641,32 @@ static char DatetimeObject_asfreq_doc[] =
 "         <D: 31-Dec-2007>\n"
 "\n";
 
-
-static PyObject*
-DatetimeObject_convert(DatetimeObject *self, PyObject *args, PyObject *kwds)
+static PyObject *
+DateObject_asfreq(DateObject *self, PyObject *args, PyObject *kwds)
 {
+
     PyObject *freq=NULL;
     char *relation_raw=NULL;
     char *relation_uc;
-    conversion_function tomediator, frommediator;
     char relation;
     int invalid_relation=0;
-    int tofreq;
+    int toFreq;
+    int result_val;
+    DateObject *result = DateObject_New();
 
     static char *kwlist[] = {"freq", "relation", NULL};
 
+    long (*asfreq_func)(long, char, asfreq_info*) = NULL;
+    asfreq_info af_info;
+
     if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|s", kwlist,
                                       &freq, &relation_raw)) return NULL;
 
     if(relation_raw) {
         if (strlen(relation_raw) > 0) {
-            if ((relation_uc = str_uppercase(relation_raw)) == NULL)
-                return PyErr_NoMemory();
+            if((relation_uc = str_uppercase(relation_raw)) == NULL)
+            {return PyErr_NoMemory();}
+
             // 'BEFORE' and 'AFTER' values for this parameter are deprecated
             if (strcmp(relation_uc, "END") == 0 ||
                 strcmp(relation_uc, "E") == 0 ||
@@ -695,15 +1676,17 @@ DatetimeObject_convert(DatetimeObject *self, PyObject *args, PyObject *kwds)
                 strcmp(relation_uc, "B") == 0 ||
                 strcmp(relation_uc, "AFTER") == 0 ||
                 strcmp(relation_uc, "A") == 0) {
-                 if (relation_uc[0] == 'E' || relation_uc[0] == 'A')
-                     relation = 'E';
-                 else
-                     relation = 'S';
+                 if(relation_uc[0] == 'E' || relation_uc[0] == 'A') { relation = 'E'; }
+                 else { relation = 'S'; }
+
             } else { invalid_relation=1; }
+
             free(relation_uc);
+
         } else {
             invalid_relation=1;
         }
+
         if (invalid_relation) {
             PyErr_SetString(PyExc_ValueError,"Invalid relation specification");
             return NULL;
@@ -712,41 +1695,32 @@ DatetimeObject_convert(DatetimeObject *self, PyObject *args, PyObject *kwds)
         relation = 'E';
     }
 
-    if (relation == 'S')
-        self->obmeta.convert_to_start = 1;
-    else
-        self->obmeta.convert_to_start = 0;
-
-    if ((tofreq = check_freq(freq)) == INT_ERR_CODE)
-        return NULL;
-
-    DatetimeObject *result = DatetimeObject_New();
-
-    init_metadata_from_unit(&result->obmeta, tofreq);
-    result->obmeta.convert_to_start = self->obmeta.convert_to_start;
+    if ((toFreq = check_freq(freq)) == INT_ERR_CODE) return NULL;
 
-    int fromfreq = self->obmeta.unit;
-    if (tofreq == fromfreq) {
-        result->obval = self->obval;
+    if (toFreq == self->freq) {
+        result->freq = self->freq;
+        result->value = self->value;
         return (PyObject*)result;
     }
 
-    /* Correction for business days */
-    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
-        result->obmeta.convert_to_start = 1;
+    get_asfreq_info(self->freq, toFreq, &af_info);
+    asfreq_func = get_asfreq_func(self->freq, toFreq, 0);
 
-    tomediator = convert_to_mediator(fromfreq, tofreq, 1);
-    frommediator = convert_from_mediator(fromfreq, tofreq, 1);
-    result->obval = frommediator(tomediator(self->obval, &(self->obmeta)), &(result->obmeta));
-    return (PyObject *)result;
-}
+    result_val = asfreq_func(self->value, relation, &af_info);
+
+    if (result_val == INT_ERR_CODE) return NULL;
 
+    result->freq = toFreq;
+    result->value = result_val;
+
+    return (PyObject*)result;
 
+}
 
-static char DatetimeObject_strfmt_doc[] =
+static char DateObject_strfmt_doc[] =
 "Deprecated alias for strftime method";
 
-static char DatetimeObject_strftime_doc[] =
+static char DateObject_strftime_doc[] =
 "\n"
 "   Returns the string representation of the :class:`Date`, \n"
 "   depending on the selected :keyword:`format`.\n"
@@ -884,52 +1858,54 @@ static char DatetimeObject_strftime_doc[] =
 "   >>> a.strftime('%b. %d, %Y was a %A')\n"
 "   'Jan. 01, 2001 was a Monday'\n";
 static PyObject *
-DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
+DateObject_strftime(DateObject *self, PyObject *args)
 {
+
     char *orig_fmt_str, *fmt_str;
     char *result;
 
     int num_extra_fmts = 3;
+
     char extra_fmts[3][2][10] = {{"%q", "^`AB`^"},
                                  {"%f", "^`CD`^"},
                                  {"%F", "^`EF`^"}};
+
     int extra_fmts_found[3] = {0,0,0};
     int extra_fmts_found_one = 0;
     struct tm c_date;
-    ymdstruct ymd;
-    hmsstruct hms;
-    npy_int64 absdate;
+    struct date_info tempDate;
+    long absdate;
     double abstime;
     int i, result_len;
     PyObject *py_result;
 
-    ts_metadata meta = self->obmeta;
+    long (*toDaily)(long, char, asfreq_info*) = NULL;
+    asfreq_info af_info;
 
-    if (!PyArg_ParseTuple(args, "s:strftime(fmt)", &orig_fmt_str))
-        return NULL;
+    if (!PyArg_ParseTuple(args, "s:strftime(fmt)", &orig_fmt_str)) return NULL;
+
+    toDaily = get_asfreq_func(self->freq, FR_DAY, 0);
+    get_asfreq_info(self->freq, FR_DAY, &af_info);
+
+    absdate = toDaily(self->value, 'E', &af_info);
+    abstime = getAbsTime(self->freq, absdate, self->value);
+
+    if(dInfoCalc_SetFromAbsDateTime(&tempDate, absdate, abstime,
+                                    GREGORIAN_CALENDAR)) return NULL;
 
-    conversion_function convert_to_days = get_converter_to_days(meta.unit, 0);
-    meta.convert_to_start = 0;
-
-    absdate = convert_to_days(self->obval, &meta);
-    ymd = days_to_ymdstruct(absdate, GREGORIAN_CALENDAR);
-    abstime = _secs_from_midnight(self->obval, meta.unit);
-    hms = seconds_to_hmsstruct(abstime);
-
-    /* Populate standard C date struct with info from our date_info struct */
-    c_date.tm_sec = hms.sec;
-    c_date.tm_min = hms.min;
-    c_date.tm_hour = hms.hour;
-    c_date.tm_mday = ymd.day;
-    c_date.tm_mon = ymd.month - 1;
-    c_date.tm_year = ymd.year - 1900;
-    // c_date.tm_wday = (tempDate.day_of_week + 1) % 7;
-    // c_date.tm_yday = tempDate.day_of_year - 1;
+    // populate standard C date struct with info from our date_info struct
+    c_date.tm_sec = (int)tempDate.second;
+    c_date.tm_min = tempDate.minute;
+    c_date.tm_hour = tempDate.hour;
+    c_date.tm_mday = tempDate.day;
+    c_date.tm_mon = tempDate.month - 1;
+    c_date.tm_year = tempDate.year - 1900;
+    c_date.tm_wday = (tempDate.day_of_week + 1) % 7;
+    c_date.tm_yday = tempDate.day_of_year - 1;
     c_date.tm_isdst = -1;
 
     result_len = strlen(orig_fmt_str) + 50;
-    if ((result = PyArray_malloc(result_len * sizeof(char))) == NULL)
-        return PyErr_NoMemory();
+    if ((result = PyArray_malloc(result_len * sizeof(char))) == NULL) {return PyErr_NoMemory();}
 
     fmt_str = orig_fmt_str;
 
@@ -942,11 +1918,9 @@ DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
                                            extra_fmts[i][1]);
             /* only free the previous loop value if this is not the first
                special format string found */
-            if (extra_fmts_found_one)
-                free(tmp_str);
+            if (extra_fmts_found_one) { free(tmp_str); }
 
-            if (fmt_str == NULL)
-                return NULL;
+            if (fmt_str == NULL) {return NULL;}
 
             extra_fmts_found[i] = 1;
             extra_fmts_found_one = 1;
@@ -954,8 +1928,7 @@ DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
     }
 
     strftime(result, result_len, fmt_str, &c_date);
-    if (extra_fmts_found_one)
-        free(fmt_str);
+    if (extra_fmts_found_one) { free(fmt_str); }
 
     // replace any place holders with the appropriate value
     for(i=0; i < num_extra_fmts; i++) {
@@ -967,22 +1940,16 @@ DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
                 strcmp(extra_fmts[i][0], "%f") == 0 ||
                 strcmp(extra_fmts[i][0], "%F") == 0) {
 
-                ts_metadata meta_qtr;
-                if (self->obmeta.unit == FR_QTR)
-                    meta_qtr = self->obmeta;
-                else
-                    init_metadata_from_unit(&meta_qtr, FR_QTR);
+                asfreq_info af_info;
+                int qtr_freq, year, quarter, year_len;
 
-                int year, quarter, qvals, year_len;
-                meta_qtr.convert_to_start = 0;
-//                conversion_info qtr_info;
-//                metadata_to_conversioninfo(&meta_qtr, &qtr_info);
-//                set_conversion_info(qtr_freq, 'E', &qtr_info);
+                if (get_freq_group(self->freq) == FR_QTR) {
+                    qtr_freq = self->freq;
+                } else { qtr_freq = FR_QTR; }
+                get_asfreq_info(FR_DAY, qtr_freq, &af_info);
 
-                qvals = (*get_converter_from_days(meta_qtr.unit, 0))(absdate, &meta_qtr);
-                quarter = qvals % 4;
-                quarter = (quarter == 0 ? 4 : quarter);
-                year = (qvals - quarter)/4 + 1;
+                if(DtoQ_yq(absdate, &af_info, &year, &quarter) == INT_ERR_CODE)
+                { return NULL; }
 
                 if(strcmp(extra_fmts[i][0], "%q") == 0) {
                     if ((extra_str = PyArray_malloc(2 * sizeof(char))) == NULL) {
@@ -991,28 +1958,24 @@ DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
                     }
                     sprintf(extra_str, "%i", quarter);
                 } else {
-                    if (meta_qtr.period_end_at > 12)
-                        year -= 1;
+                    if ((qtr_freq % 1000) > 12) { year -= 1; }
 
                     if (strcmp(extra_fmts[i][0], "%f") == 0) {
                         year_len = 2;
                         year = year % 100;
-                    }
-                    else
-                        year_len = 4;
+                    } else { year_len = 4; }
 
                     if ((extra_str = PyArray_malloc((year_len+1) * sizeof(char))) == NULL) {
                         free(tmp_str);
                         return PyErr_NoMemory();
                     }
 
-                    if (year_len == 2 && year < 10)
+                    if (year_len == 2 && year < 10) {
                         sprintf(extra_str, "0%i", year);
-                    else
-                        sprintf(extra_str, "%i", year);
+                    } else { sprintf(extra_str, "%i", year); }
                 }
-            }
-            else {
+
+            } else {
                 PyErr_SetString(PyExc_RuntimeError,"Unrecognized format string");
                 return NULL;
             }
@@ -1023,65 +1986,45 @@ DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
             if (result == NULL) { return NULL; }
         }
     }
+
     py_result = PyString_FromString(result);
     free(result);
+
     return py_result;
 }
 
-
 static PyObject *
-DatetimeObject___str__(DatetimeObject* self)
+DateObject___str__(DateObject* self)
 {
-    int unit = self->obmeta.unit;
+
+    int freq_group = get_freq_group(self->freq);
     PyObject *string_arg, *retval;
 
     string_arg = NULL;
-    if (unit == FR_UND) {
-        retval = PyString_FromFormat("%ld", (long)(self->obval));
-        return retval;
-        }
-    else if (unit == FR_ANN) { string_arg = Py_BuildValue("(s)", "%Y"); }
-    else if (unit == FR_QTR) { string_arg = Py_BuildValue("(s)", "%FQ%q"); }
-    else if (unit == FR_MTH) { string_arg = Py_BuildValue("(s)", "%b-%Y"); }
-    else if (unit == FR_DAY ||
-             unit == FR_BUS ||
-             unit == FR_WK) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y"); }
-    else if (unit == FR_HR) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:00"); }
-    else if (unit == FR_MIN) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M"); }
-    else if (unit == FR_SEC) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M:%S"); }
+    if (freq_group == FR_UND) {
+        retval = PyString_FromFormat("%ld", self->value);
+        return retval;}
+    else if (freq_group == FR_ANN) { string_arg = Py_BuildValue("(s)", "%Y"); }
+    else if (freq_group == FR_QTR) { string_arg = Py_BuildValue("(s)", "%FQ%q"); }
+    else if (freq_group == FR_MTH) { string_arg = Py_BuildValue("(s)", "%b-%Y"); }
+    else if (freq_group == FR_DAY ||
+             freq_group == FR_BUS ||
+             freq_group == FR_WK) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y"); }
+    else if (freq_group == FR_HR) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:00"); }
+    else if (freq_group == FR_MIN) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M"); }
+    else if (freq_group == FR_SEC) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M:%S"); }
 
     if (string_arg == NULL) { return NULL; }
-    retval = DatetimeObject_strftime(self, string_arg);
+
+    retval = DateObject_strftime(self, string_arg);
     Py_DECREF(string_arg);
-    return retval;
-}
-static PyObject *
-timedelta___str__(TimeDeltaObject* self)
-{
-    PyObject  *py_str;
-    long months=get_timedelta_months(self);
-    long days=get_timedelta_days(self);
-    long seconds=get_timedelta_seconds(self);
 
-    py_str = PyString_FromFormat("%ldm, %ldd, %lds",
-                                  months, days, seconds);
-    return py_str;
+    return retval;
 }
 
-
-
-static PyObject *
-DatetimeObject_freqstr(DatetimeObject *self, void *closure) {
-    PyObject *key = PyInt_FromLong(self->obmeta.unit);
-    PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
-    PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
-    Py_DECREF(key);
-    Py_INCREF(main_alias);
-    return main_alias;
-}
 static PyObject *
-timedelta_freqstr(TimeDeltaObject *self, void *closure) {
-    PyObject *key = PyInt_FromLong(self->unit);
+DateObject_freqstr(DateObject *self, void *closure) {
+    PyObject *key = PyInt_FromLong(self->freq);
     PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
     PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
     Py_DECREF(key);
@@ -1090,23 +2033,25 @@ timedelta_freqstr(TimeDeltaObject *self, void *closure) {
 }
 
 
-
 static PyObject *
-DatetimeObject___repr__(DatetimeObject* self)
+DateObject___repr__(DateObject* self)
 {
     PyObject *py_str_rep, *py_freqstr, *py_repr;
     char *str_rep, *freqstr, *repr;
     int repr_len;
 
-    py_str_rep = DatetimeObject___str__(self);
-    if (py_str_rep == NULL) return NULL;
-    str_rep = PyString_AsString(py_str_rep);
+    py_str_rep = DateObject___str__(self);
+    if (py_str_rep == NULL) { return NULL; }
 
-    py_freqstr = DatetimeObject_freqstr(self, NULL);
+    py_freqstr = DateObject_freqstr(self, NULL);
+
+    str_rep = PyString_AsString(py_str_rep);
     freqstr = PyString_AsString(py_freqstr);
 
     repr_len = strlen(str_rep) + strlen(freqstr) + 6;
-    MEM_CHECK((repr = PyArray_malloc((repr_len + 1) * sizeof(char))));
+
+    if((repr = PyArray_malloc((repr_len + 1) * sizeof(char))) == NULL)
+    { return PyErr_NoMemory(); }
 
     strcpy(repr, "<");
     strcat(repr, freqstr);
@@ -1115,42 +2060,12 @@ DatetimeObject___repr__(DatetimeObject* self)
     strcat(repr, ">");
 
     py_repr = PyString_FromString(repr);
+
     Py_DECREF(py_str_rep);
     Py_DECREF(py_freqstr);
-    free(repr);
-    return py_repr;
-}
 
-static PyObject *
-timedelta___repr__(TimeDeltaObject* self)
-{
-    PyObject *py_freqstr, *py_repr;
-    char *freqstr;
-    py_freqstr = timedelta_freqstr(self, NULL);
-    freqstr = PyString_AsString(py_freqstr);
+    free(repr);
 
-    if (get_timedelta_seconds(self) != 0){
-        py_repr = PyString_FromFormat("%s(%ld, %ld, %ld)[%s]",
-                                      self->ob_type->tp_name,
-                                      self->months,
-                                      self->days,
-                                      self->seconds,
-                                      freqstr);
-        }
-    else if (self->days != 0){
-        py_repr = PyString_FromFormat("%s(%ld, %ld)[%s]",
-                                      self->ob_type->tp_name,
-                                      self->months,
-                                      self->days,
-                                      freqstr);
-        }
-    else {
-        py_repr = PyString_FromFormat("%s(%ld)[%s]",
-                                      self->ob_type->tp_name,
-                                      self->months,
-                                      freqstr);
-    }
-    Py_DECREF(py_freqstr);
     return py_repr;
 }
 
@@ -1167,900 +2082,373 @@ isvalid(self):
 *******************************/
 
 
-DatetimeObject *
-DatetimeObject_FromFreqAndValue(int freq, npy_int64 value) {
-    DatetimeObject *result = DatetimeObject_New();
-    init_metadata_from_unit(&result->obmeta, freq);
-    result->obval = value;
-    return result;
-}
-
-
-static TimeDeltaObject *
-timedelta_fromMDS(int unit,
-                  npy_int64 months, npy_int64 days, npy_int64 seconds)
-{
-    TimeDeltaObject *result = TimeDeltaObject_New();
-    normalize_days_secs(&days, &seconds);
-    result->unit = unit;
-    result->months = months;
-    result->days = days;
-    result->seconds = seconds;
-    return result;
-}
-
-
-
-static PyObject *
-DatetimeObject_date_plus_int(PyObject *date, PyObject *pyint) {
-    DatetimeObject *dateobj = (DatetimeObject*)date;
-    if (!PyInt_Check(pyint) && !PyObject_HasAttrString(pyint, "__int__")) {
-        return Py_NotImplemented;
-    }
-    DatetimeObject *result = DatetimeObject_New();
-    result->obmeta = dateobj->obmeta;
-    result->obval = dateobj->obval + PyInt_AsLong(pyint);
-    return (PyObject*)result;
-}
-
-
-static PyObject *
-date_plus_timedelta(PyObject *datearg, PyObject *deltaarg){
-    DatetimeObject *date = (DatetimeObject*)datearg;
-    TimeDeltaObject *delta = (TimeDeltaObject*)deltaarg;
-    DatetimeObject *result;
-
-    ts_datetimestruct dtinfo;
-    npy_int64 seconds, days, months, years=0, absdate, abstime=0;
-    // Get the info from the delta
-    seconds = delta->seconds;
-    days = delta->days;
-    months = delta->months;
-
-    if (date->obmeta.unit > FR_DAY) {
-        abstime = _secs_from_midnight(date->obval, date->obmeta.unit);
-        // Update the days and secs from the seconds since midnight
-        seconds += abstime;
-    }
-    // Make sure the seconds are between -86400 and +86400
-    normalize_days_secs(&days, &seconds);
-    set_datetimestruct_from_secs(&dtinfo, seconds);
-
-    // Convert the current date to days and set the datetimestruct
-    conversion_function todays = get_converter_to_days(date->obmeta.unit, 0);
-    date->obmeta.convert_to_start = 1;
-    absdate = todays(date->obval, &(date->obmeta));
-    set_datetimestruct_from_days(&dtinfo, absdate + days);
-
-    // Update the datetime info with the months and normalize the months
-    years = dtinfo.year;
-    months += dtinfo.month;
-    normalize_years_months(&years, &months);
-
-    // Update the structure
-    dtinfo.year = years;
-    dtinfo.month = months;
-
-    // Convert to datetime
-    result = DatetimeObject_New();
-    result->obmeta = date->obmeta;
-    result->obval = datetimestruct_to_tsdatetime(&(date->obmeta), &dtinfo);
-    return (PyObject*)result;
-
-};
-
-static PyObject *
-date_plus_delta(PyObject *datearg, PyObject *deltaarg){
-    DatetimeObject *date = (DatetimeObject*)datearg;
-    PyDateTime_Delta *delta = (PyDateTime_Delta*)deltaarg;
-    PyObject *timedelta=NULL;
-    timedelta = (PyObject*)timedelta_fromMDS(date->obmeta.unit,
-                                             0, delta->days, delta->seconds);
-    PyObject *result=NULL;
-    result = (PyObject *)date_plus_timedelta(datearg, timedelta);
-    Py_DECREF(timedelta);
-    return result;
-}
-
+static DateObject *
+DateObject_FromFreqAndValue(int freq, int value) {
 
+    DateObject *result = DateObject_New();
 
-static PyObject *
-DatetimeObject___add__(PyObject *left, PyObject *right)
-{
-    if (DatetimeObject_Check(left) && DatetimeObject_Check(right)) {
-        PyErr_SetString(PyExc_TypeError, "Cannot add Date to Date");
-        return NULL;
-    }
-    PyObject *result = Py_NotImplemented;
+    PyObject *args = PyTuple_New(0);
+    PyObject *kw = PyDict_New();
+    PyObject *py_freq = PyInt_FromLong(freq);
+    PyObject *py_value = PyInt_FromLong(value);
 
-    if (DatetimeObject_Check(left)) {
-        if (TimeDelta_Check(right)){
-            result = date_plus_timedelta(left, right);
-        } else if (PyDelta_Check(right)) {
-            result = date_plus_delta(left,right);
-        } else {
-            result = DatetimeObject_date_plus_int(left, right);
-        };
-    } else {
-        if (TimeDelta_Check(left)){
-            result = date_plus_timedelta(right, left);
-        } else {
-            result = DatetimeObject_date_plus_int(right, left);
-        };
-    };
-    if (result == Py_NotImplemented)
-        Py_INCREF(result);
-    return result;
-};
+    PyDict_SetItemString(kw, "freq", py_freq);
+    PyDict_SetItemString(kw, "value", py_value);
 
+    Py_DECREF(py_freq);
+    Py_DECREF(py_value);
 
-static PyObject *
-DatetimeObject___subtract__(PyObject *left, PyObject *right)
-{
-    PyObject *result = Py_NotImplemented;
+    DateObject_init(result, args, kw);
 
-    DatetimeObject *dleft;
-    if (!DatetimeObject_Check(left)) {
-        PyErr_SetString(PyExc_ValueError, "Cannot subtract a Date from a non-Date object.");
-        return NULL;
-    }
-    dleft = (DatetimeObject*)left;
-    if (DatetimeObject_Check(right)) {
-        DatetimeObject *dright = (DatetimeObject*)right;
-        if (dleft->obmeta.unit != dright->obmeta.unit) {
-            PyErr_SetString(PyExc_ValueError, "Cannot subtract Date objects with different frequencies.");
-            result = NULL;
-        }
-        result = PyInt_FromLong(dleft->obval - dright->obval);
-    }
-    else if (PyDate_Check(right) || PyDateTime_Check(right)) {
-        DatetimeObject *dright=DatetimeObject_New();
-        PyObject *args = PyTuple_New(0);
-        PyObject *kw = PyDict_New();
-        PyObject *py_unit = PyInt_FromLong(dleft->obmeta.unit);
-        PyDict_SetItemString(kw, "freq", py_unit);
-        PyDict_SetItemString(kw, "datetime", right);
-        Py_DECREF(py_unit);
-        ///
-        DatetimeObject_init(dright, args, kw);
-        Py_DECREF(args);
-        Py_DECREF(kw);
-        result = PyInt_FromLong(dleft->obval - dright->obval);
-        Py_DECREF(dright);
-    }
-    else if (TimeDelta_Check(right)){
-        PyObject *minus_right = PyNumber_Negative(right);
-        if (minus_right){
-            result = date_plus_timedelta(left, minus_right);
-            Py_DECREF(minus_right);
-        } else {
-            result = NULL;
-        }
-    }
-    else {
-        DatetimeObject *dtresult = DatetimeObject_New();
-        dtresult->obmeta = dleft->obmeta;
-        dtresult->obval = dleft->obval - PyLong_AsLong(right);
-        result = (PyObject *)dtresult;
-    }
+    Py_DECREF(args);
+    Py_DECREF(kw);
 
-    if (result == Py_NotImplemented)
-        Py_INCREF(result);
     return result;
 }
 
 static PyObject *
-timedelta_negative(TimeDeltaObject *self){
-    TimeDeltaObject *result = TimeDeltaObject_New();
-    result->unit = self->unit;
-    result->months = -get_timedelta_months(self);
-    result->days = -get_timedelta_days(self);
-    result->seconds = -get_timedelta_seconds(self);
-    return (PyObject *)result;
-}
-
-
-static PyObject *
-timedelta_plus_timedelta(PyObject *tdaobj, PyObject *tdbobj) {
-    TimeDeltaObject *tda = (TimeDeltaObject*)tdaobj;
-    TimeDeltaObject *tdb = (TimeDeltaObject*)tdbobj;
-    npy_int64 months = get_timedelta_months(tda) + get_timedelta_months(tdb);
-    npy_int64 days = get_timedelta_days(tda) + get_timedelta_days(tdb);
-    npy_int64 seconds = get_timedelta_seconds(tda) + get_timedelta_seconds(tdb);
-    normalize_days_secs(&days, &seconds);
-    //
-    return (PyObject*)timedelta_fromMDS(tda->unit, months, days, seconds);
+DateObject_date_plus_int(PyObject *date, PyObject *pyint) {
+    DateObject *dateobj = (DateObject*)date;
 
-};
-
-
-static PyObject *
-timedelta_plus_int(PyObject *timedelta, PyObject *pyint) {
-    TimeDeltaObject *deltaobj = (TimeDeltaObject*)timedelta;
     if (!PyInt_Check(pyint) && !PyObject_HasAttrString(pyint, "__int__")) {
         // invalid type for addition
+
         char *err_str, *type_str;
         PyObject *type_repr, *obj_type;
+
         obj_type = PyObject_Type(pyint);
         type_repr = PyObject_Repr(obj_type);
         type_str = PyString_AsString(type_repr);
+
         if ((err_str = PyArray_malloc(255 * sizeof(char))) == NULL) {
             return PyErr_NoMemory();
         }
-        sprintf(err_str, "Cannot add TimeDelta and %s", type_str);
+        sprintf(err_str, "Cannot add Date and %s", type_str);
         Py_DECREF(obj_type);
         Py_DECREF(type_repr);
         PyErr_SetString(PyExc_TypeError, err_str);
         free(err_str);
         return NULL;
     }
-    int freq_group = get_base_unit(deltaobj->unit);
-    long years=0, months=0, days=0, seconds=0;
-    switch(freq_group){
-        case FR_ANN:
-            years = PyInt_AsLong(pyint);
-            break;
-        case FR_QTR:
-            months = PyInt_AsLong(pyint);
-            months *= 3;
-            break;
-        case FR_MTH:
-            months = PyInt_AsLong(pyint);
-            break;
-        case FR_WK:
-            days = PyInt_AsLong(pyint);
-            days *= 7;
-            break;
-        case FR_BUS:
-            days = PyInt_AsLong(pyint);
-            break;
-        case FR_DAY:
-            days = PyInt_AsLong(pyint);
-            break;
-        case FR_HR:
-            seconds = PyInt_AsLong(pyint);
-            seconds *= 3600;
-            break;
-        case FR_MIN:
-            seconds = PyInt_AsLong(pyint);
-            seconds *= 60;
-            break;
-        case FR_SEC:
-            seconds = PyInt_AsLong(pyint);
-            break;
-        default:
-            days = PyInt_AsLong(pyint);
-            break;
-    }
-    return (PyObject*)timedelta_fromMDS(deltaobj->unit,
-                                        deltaobj->months+months+12*years,
-                                        deltaobj->days+days,
-                                        deltaobj->seconds+seconds);
-};
 
-static PyObject *
-timedelta_plus_delta(PyObject *left, PyObject *right){
-    TimeDeltaObject *oleft = (TimeDeltaObject*)left;
-    PyDateTime_Delta *oright = (PyDateTime_Delta*)right;
-    PyObject *result=NULL;
-    npy_int64 days = oleft->days + oright->days;
-    npy_int64 seconds = oleft->seconds + oright->seconds;
-    normalize_days_secs(&days, &seconds);
-    result = (PyObject*)timedelta_fromMDS(oleft->unit,
-                                          oleft->months, days, seconds);
-    return result;
+    return (PyObject*)DateObject_FromFreqAndValue(
+        dateobj->freq, PyInt_AsLong(pyint) + dateobj->value);
 }
 
-
 static PyObject *
-timedelta_add(PyObject *left, PyObject *right)
+DateObject___add__(PyObject *left, PyObject *right)
 {
-    PyObject *result = Py_NotImplemented;
-
-    if (TimeDelta_Check(left)) {
-        if (TimeDelta_Check(right))
-            result = timedelta_plus_timedelta(left, right);
-        else if (PyDelta_Check(right))
-            result = timedelta_plus_delta(left, right);
-        else if (PyInt_Check(right) || PyLong_Check(right))
-            result = timedelta_plus_int(left, right);
-        }
-    else if (PyDelta_Check(left))
-        result = timedelta_plus_delta(right, left);
-    else if (PyInt_Check(left) || PyLong_Check(left))
-        result = timedelta_plus_int(right,left);
-
-    if (result == Py_NotImplemented)
-        Py_INCREF(result);
-    return result;
-};
-
-
-static PyObject *
-timedelta_subtract(PyObject *left, PyObject *right)
-{
-    PyObject *result = Py_NotImplemented;
-
-    if (!TimeDelta_Check(left))
-        PyErr_SetString(PyExc_ValueError, "Cannot subtract a TimeDelta from a non-TimeDelta object.");
-
-    if (TimeDelta_Check(right)) {
-        PyObject *minus_right = PyNumber_Negative(right);
-        result = timedelta_plus_timedelta(left, minus_right);
+    if (DateObject_Check(left) && DateObject_Check(right)) {
+        PyErr_SetString(PyExc_TypeError, "Cannot add Date to Date");
+        return NULL;
+    } else if (DateObject_Check(left)) {
+        return DateObject_date_plus_int(left, right);
+    } else {
+        return DateObject_date_plus_int(right, left);
     }
-    else {
-        PyObject *minus_right = PyNumber_Negative(right);
-        if (minus_right) {
-            if (PyDelta_Check(right))
-                result = timedelta_plus_delta(left, minus_right);
-            else if (TimeDelta_Check(right))
-                result = timedelta_plus_timedelta(left, minus_right);
-            else
-                result = timedelta_plus_int(left, minus_right);
-            Py_DECREF(minus_right);
-        }
-        else {
-            result = NULL;
-        };
-    };
-    if (result == Py_NotImplemented)
-        Py_INCREF(result);
-    return result;
 }
 
-
 static PyObject *
-timedelta_times_int(PyObject *delta, PyObject *py_int)
+DateObject___subtract__(PyObject *left, PyObject *right)
 {
-    TimeDeltaObject *deltaobj = (TimeDeltaObject*)delta;
-    TimeDeltaObject *result = TimeDeltaObject_New();
-    long factor = PyInt_AsLong(py_int);
-    result->unit = deltaobj->unit;
-    result->months = get_timedelta_months(deltaobj) * factor;
-    result->days = get_timedelta_days(deltaobj) * factor;
-    result->seconds = get_timedelta_seconds(deltaobj) * factor;
-    return (PyObject *)result;
-};
-
-
-#define NUM_CHECK(o) (PyInt_Check(o) || PyLong_Check(o) || PyFloat_Check(o))
-
+    int result;
+    DateObject *dleft;
+    if (!DateObject_Check(left)) {
+        PyErr_SetString(PyExc_ValueError, "Cannot subtract a Date from a non-Date object.");
+        return NULL;
+    }
 
-static PyObject *
-timedelta_multiply(PyObject *left, PyObject *right) {
-    PyObject *result = Py_NotImplemented;
+    dleft = (DateObject*)left;
 
-    if (TimeDelta_Check(left)) {
-        if (NUM_CHECK(right))
-            result = timedelta_times_int(left, right);
-    }
-    else if (NUM_CHECK(left)) {
-        result = timedelta_times_int(right, left);
-    };
-    if (result == Py_NotImplemented)
-        Py_INCREF(result);
-    return result;
+    if (DateObject_Check(right)) {
+        DateObject *dright = (DateObject*)right;
+        if (dleft->freq != dright->freq) {
+            PyErr_SetString(PyExc_ValueError, "Cannot subtract Date objects with different frequencies.");
+            return NULL;
+        }
+        result = dleft->value - dright->value;
+        return PyInt_FromLong(result);
+    } else {
+        result = dleft->value - PyInt_AsLong(right);
+        return (PyObject*)DateObject_FromFreqAndValue(dleft->freq, result);
+    }
 }
 
-
-
-
 static int
-DatetimeObject___compare__(DatetimeObject * obj1, DatetimeObject * obj2)
+DateObject___compare__(DateObject * obj1, DateObject * obj2)
 {
-    if (obj1->obmeta.unit != obj2->obmeta.unit) {
+    if (obj1->freq != obj2->freq) {
         PyErr_SetString(PyExc_ValueError,
                         "Cannot compare Date objects with different frequencies.");
         return -1;
     }
-    if (obj1->obval < obj2->obval) return -1;
-    if (obj1->obval > obj2->obval) return 1;
-    if (obj1->obval == obj2->obval) return 0;
-    return -1;
-}
 
-static int
-TimeDeltaObject___compare__(TimeDeltaObject * obj1, TimeDeltaObject * obj2)
-{
-//    if (obj1->unit != obj2->unit) {
-//        PyErr_SetString(PyExc_ValueError,
-//                        "Cannot compare Date objects with different frequencies.");
-//        return -1;
-//    }
-//    if (obj1->value < obj2->value) return -1;
-//    if (obj1->value > obj2->value) return 1;
-//    if (obj1->value == obj2->value) return 0;
-//    return -1;
+    if (obj1->value < obj2->value) return -1;
+    if (obj1->value > obj2->value) return 1;
+    if (obj1->value == obj2->value) return 0;
     return -1;
 }
 
-
-
 static long
-DatetimeObject___hash__(DatetimeObject *self)
+DateObject___hash__(DateObject *self)
 {
+    register int freq_group = get_freq_group(self->freq);
+
     /* within a given frequency, hash values are guaranteed to be unique
        for different dates. For different frequencies, we make a reasonable
        effort to ensure hash values will be unique, but it is not guaranteed */
-    if (self->obmeta.unit == FR_BUS) {
-        return self->obval + 10000000;
-    } else if (self->obmeta.unit == FR_WK) {
-        return self->obval + 100000000;
-    } else {
-        return self->obval;
-    };
-}
-static long
-TimeDeltaObject___hash__(TimeDeltaObject *self)
-{
-//    register int freq_group = get_base_unit(self->freq);
-//    /* within a given frequency, hash values are guaranteed to be unique
-//       for different dates. For different frequencies, we make a reasonable
-//       effort to ensure hash values will be unique, but it is not guaranteed */
-//    if (freq_group == FR_BUS) {
-//        return self->value + 10000000;
-//    } else if (freq_group == FR_WK) {
-//        return self->value + 100000000;
-//    } else {
-//        return self->value;
-//    };
-    return -1;
+    if (freq_group == FR_BUS) {
+        return self->value + 10000000;
+    } else if (freq_group == FR_WK) {
+        return self->value + 100000000;
+    } else { return self->value; }
 }
 
-
 static PyObject *
-DatetimeObject_toint(DatetimeObject *self) {
-    return PyInt_FromLong(self->obval);
+DateObject___int__(DateObject *self)
+{
+    return PyInt_FromLong(self->value);
 }
 
 static PyObject *
-DatetimeObject_tofloat(DatetimeObject *self) {
-    return PyFloat_FromDouble((double)(self->obval));
+DateObject___float__(DateObject *self)
+{
+    return PyFloat_FromDouble((double)(self->value));
 }
 
 static PyObject *
-DatetimeObject_tolong(DatetimeObject *self) {
-    return PyLong_FromLong(self->obval);
+DateObject___long__(DateObject *self)
+{
+    return PyLong_FromLong(self->value);
 }
 
 
-
 /***************************************************
            ====== Date Properties ======
 ****************************************************/
 
-static PyObject *
-DatetimeObject_unit(DatetimeObject *self) {
-    int unit = self->obmeta.unit;
-    int period_end_at = self->obmeta.period_end_at;
-    if (period_end_at > 0)
-        return PyInt_FromLong(unit + period_end_at);
-    return PyInt_FromLong(unit);
-}
-static PyObject *
-DatetimeObject_timestep(DatetimeObject *self) {
-    return PyInt_FromLong(self->obmeta.timestep);
-}
-
-
 // helper function for date property funcs
 static int
-DatetimeObject_set_datestruct(DatetimeObject *self, ts_datetimestruct *dinfo) {
-    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
-    self->obmeta.convert_to_start = 0;
-    npy_int64 days = todays(self->obval, &(self->obmeta));
-    set_datetimestruct_from_days(dinfo, days);
+DateObject_set_date_info(DateObject *self, struct date_info *dinfo) {
+    PyObject *daily_obj = DateObject_toordinal(self);
+    long absdate = PyInt_AsLong(daily_obj);
+
+    Py_DECREF(daily_obj);
+
+    if(dInfoCalc_SetFromAbsDate(dinfo, absdate,
+                                GREGORIAN_CALENDAR)) return -1;
+
     return 0;
 }
 
 // helper function for date property funcs
 static int
-DatetimeObject_set_datetimestruct(DatetimeObject *self, ts_datetimestruct *dinfo) {
-    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
-    self->obmeta.convert_to_start = 0;
-    npy_int64 absdate = todays(self->obval, &(self->obmeta));
-    npy_int64 abstime = _secs_from_midnight(self->obval, self->obmeta.unit);
-    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+DateObject_set_date_info_wtime(DateObject *self, struct date_info *dinfo) {
+    PyObject *daily_obj = DateObject_toordinal(self);
+    long absdate = PyInt_AsLong(daily_obj);
+    double abstime;
+
+    Py_DECREF(daily_obj);
+
+    abstime = getAbsTime(self->freq, absdate, self->value);
+
+    if(dInfoCalc_SetFromAbsDateTime(dinfo, absdate, abstime,
+                                    GREGORIAN_CALENDAR)) return -1;
+
     return 0;
 }
 
-
 static PyObject *
-DatetimeObject_year(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    DatetimeObject_set_datestruct(self, &dinfo);
+DateObject_year(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
     return PyInt_FromLong(dinfo.year);
 }
-PyObject *
-_loop_get_year(npy_int64 value, int unit,
-               conversion_function todays, ts_metadata *meta,
-               ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(dinfo->year);
-}
 
+static int _DateObject_quarter_year(DateObject *self, int *year, int *quarter) {
+
+    PyObject *daily_obj;
+    long absdate;
+
+    asfreq_info af_info;
+    int qtr_freq;
+
+    daily_obj = DateObject_toordinal(self);
+    absdate = PyInt_AsLong(daily_obj);
+    Py_DECREF(daily_obj);
+
+    if (get_freq_group(self->freq) == FR_QTR) {
+        qtr_freq = self->freq;
+    } else { qtr_freq = FR_QTR; }
+    get_asfreq_info(FR_DAY, qtr_freq, &af_info);
+
+    if(DtoQ_yq(absdate, &af_info, year, quarter) == INT_ERR_CODE)
+    { return INT_ERR_CODE; }
+
+    if ((qtr_freq % 1000) > 12) { *year -= 1; }
+
+    return 0;
+}
 
 static PyObject *
-DatetimeObject_qyear(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    DatetimeObject_set_datestruct(self, &dinfo);
-    int year = dinfo.year;
-
-    if (self->obmeta.unit == FR_QTR) {
-        int end_month = self->obmeta.period_end_at;
-        if (end_month == 0)
-            end_month = 12;
-        else if (end_month > 12) {
-            end_month -= 12;
-            year -= 1;
-        }
-        if (dinfo.month > end_month)
-            year += 1;
-    }
+DateObject_qyear(DateObject *self, void *closure) {
+    int year, quarter;
+    if(_DateObject_quarter_year(self,
+            &year, &quarter) == INT_ERR_CODE) { return NULL; }
     return PyInt_FromLong(year);
 }
-PyObject *
-_loop_get_qyear(npy_int64 value, int unit,
-                conversion_function todays, ts_metadata *meta,
-                ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(dinfo->year);
-}
-PyObject *
-_loop_get_qyear_from_qtr(npy_int64 value, int unit,
-                         conversion_function todays, ts_metadata *meta,
-                         ts_datetimestruct *dinfo)
-{
-    int ending_month = meta->period_end_at;
-    if (ending_month == 0)
-        ending_month = 12;
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    if (dinfo->month > ending_month)
-        return PyInt_FromLong(dinfo->year+1);
-    return PyInt_FromLong(dinfo->year);
-}
-
 
 static PyObject *
-DatetimeObject_quarter(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    DatetimeObject_set_datestruct(self, &dinfo);
-    int month = dinfo.month;
-    int end_month = ending_month(&(self->obmeta));
-
-    if (self->obmeta.unit == FR_QTR)
-        month = dinfo.month - end_month;
-        if (month <= 0)
-            month += 12;
-    return PyInt_FromLong(month_to_quarter(month));
-}
-PyObject *
-_loop_get_quarter(npy_int64 value, int unit,
-                  conversion_function todays, ts_metadata *meta,
-                  ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(month_to_quarter(dinfo->month));
-}
-PyObject *
-_loop_get_quarter_from_qtr(npy_int64 value, int unit,
-                           conversion_function todays, ts_metadata *meta,
-                           ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    int month = dinfo->month - ending_month(meta);
-    if (month <= 0)
-        month += 12;
-    return PyInt_FromLong(month_to_quarter(month));
+DateObject_quarter(DateObject *self, void *closure) {
+    int year, quarter;
+    if(_DateObject_quarter_year(self,
+            &year, &quarter) == INT_ERR_CODE) { return NULL; }
+    return PyInt_FromLong(quarter);
 }
 
-
 static PyObject *
-DatetimeObject_month(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datestruct(self, &dinfo) == -1) return NULL;
+DateObject_month(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
     return PyInt_FromLong(dinfo.month);
 }
-PyObject *
-_loop_get_month(npy_int64 value, int unit,
-                conversion_function todays, ts_metadata *meta,
-                ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(dinfo->month);
-}
 
 static PyObject *
-DatetimeObject_day(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datestruct(self, &dinfo) == -1) return NULL;
+DateObject_day(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
     return PyInt_FromLong(dinfo.day);
 }
-PyObject *
-_loop_get_day(npy_int64 value, int unit,
-              conversion_function todays, ts_metadata *meta,
-              ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(dinfo->day);
-}
-
 
 static PyObject *
-DatetimeObject_day_of_week(DatetimeObject *self, void *closure) {
-    PyObject *daily_obj;
-    daily_obj = DatetimeObject_toordinal(self);
-    npy_int64 absdate = PyInt_AsLong(daily_obj);
-    Py_DECREF(daily_obj);
-    return PyInt_FromLong(day_of_week(absdate));
+DateObject_weekday(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.day_of_week);
 }
+
 static PyObject *
-DatetimeObject_weekday(DatetimeObject *self, void *closure) {
-    return DatetimeObject_day_of_week(self, closure);
-}
-PyObject *
-_loop_get_day_of_week(npy_int64 value, int unit,
-                      conversion_function todays, ts_metadata *meta,
-                      ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    return PyInt_FromLong(day_of_week(absdate));
+DateObject_day_of_week(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.day_of_week);
 }
 
-
 static PyObject *
-DatetimeObject_day_of_year(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datestruct(self, &dinfo) == -1)
-        return NULL;
+DateObject_day_of_year(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
     return PyInt_FromLong(dinfo.day_of_year);
 }
-PyObject *
-_loop_get_day_of_year(npy_int64 value, int unit,
-                      conversion_function todays, ts_metadata *meta,
-                      ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(dinfo->day_of_year);
-}
-
 
 static PyObject *
-DatetimeObject_week(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datestruct(self, &dinfo) == -1)
-        return NULL;
-    return PyInt_FromLong(isoweek_from_datetimestruct(&dinfo));
-}
-PyObject *
-_loop_get_week(npy_int64 value, int unit,
-               conversion_function todays, ts_metadata *meta,
-               ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    set_datetimestruct_from_days(dinfo, absdate);
-    return PyInt_FromLong(isoweek_from_datetimestruct(dinfo));
+DateObject_week(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dInfoCalc_ISOWeek(&dinfo));
 }
 
-
 static PyObject *
-DatetimeObject_hour(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1)
-        return NULL;
+DateObject_hour(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info_wtime(self, &dinfo) == -1) return NULL;
     return PyInt_FromLong(dinfo.hour);
 }
-PyObject *
-_loop_get_hour(npy_int64 value, int unit,
-               conversion_function todays, ts_metadata *meta,
-               ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
-    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
-    return PyInt_FromLong(dinfo->hour);
-}
-
 
 static PyObject *
-DatetimeObject_minute(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1)
-        return NULL;
-    return PyInt_FromLong(dinfo.min);
-}
-PyObject *
-_loop_get_minute(npy_int64 value, int unit,
-                 conversion_function todays, ts_metadata *meta,
-                 ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
-    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
-    return PyInt_FromLong(dinfo->min);
+DateObject_minute(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info_wtime(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.minute);
 }
 
-
 static PyObject *
-DatetimeObject_second(DatetimeObject *self, void *closure) {
-    ts_datetimestruct dinfo;
-    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1) return NULL;
-    return PyInt_FromLong(dinfo.sec);
-}
-PyObject *
-_loop_get_second(npy_int64 value, int unit,
-                 conversion_function todays, ts_metadata *meta,
-                 ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
-    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
-    return PyInt_FromLong(dinfo->sec);
-}
-
-
-//static PyObject *
-//DatetimeObject_ordinal(DatetimeObject *self, void *closure){
-//    return PyInt_FromLong((long)DatetimeObject_toordinal(self));
-//}
-PyObject *
-_loop_get_ordinal(npy_int64 value, int unit,
-                  conversion_function todays, ts_metadata *meta,
-                  ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    return PyInt_FromLong(absdate);
+DateObject_second(DateObject *self, void *closure) {
+    struct date_info dinfo;
+    if(DateObject_set_date_info_wtime(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong((int)dinfo.second);
 }
 
-
 static PyObject *
-DatetimeObject_datetime(DatetimeObject *self, void *closure) {
+DateObject_datetime(DateObject *self, void *closure) {
     PyObject *datetime;
     int hour=0, minute=0, second=0;
-    int unit;
-    ts_datetimestruct dinfo;
+    int freq_group;
+    struct date_info dinfo;
 
-    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1) return NULL;
-    unit = self->obmeta.unit;
+    if(DateObject_set_date_info_wtime(self, &dinfo) == -1) return NULL;
+    freq_group = get_freq_group(self->freq);
 
-    switch(unit) {
+    switch(freq_group) {
         case FR_HR:
             hour = dinfo.hour;
             break;
         case FR_MIN:
             hour = dinfo.hour;
-            minute = dinfo.min;
+            minute = dinfo.minute;
             break;
         case FR_SEC:
             hour = dinfo.hour;
-            minute = dinfo.min;
-            second = (int)dinfo.sec;
+            minute = dinfo.minute;
+            second = (int)dinfo.second;
             break;
     }
+
     datetime = PyDateTime_FromDateAndTime(
                 dinfo.year, dinfo.month, dinfo.day, hour, minute, second, 0);
     return datetime;
 }
-PyObject *
-_loop_get_datetime(npy_int64 value, int unit,
-                   conversion_function todays, ts_metadata *meta,
-                   ts_datetimestruct *dinfo)
-{
-    npy_int64 absdate = (*todays)(value, meta);
-    npy_int64 abstime = 0;
-    if (unit > FR_DAY)
-        abstime = _secs_from_midnight(value, unit);
-    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
-    return PyDateTime_FromDateAndTime(dinfo->year, dinfo->month, dinfo->day,
-                                      dinfo->hour, dinfo->min, dinfo->sec, 0);
-}
-
-
-
-static PyObject *
-TimeDeltaObject_timedelta(TimeDeltaObject *self, void *closure) {
-    PyObject *timedelta;
-    npy_int64 days = 30.4375 * get_timedelta_months(self);
-    days += get_timedelta_days(self);
-    npy_int64 seconds=self->seconds;
-    timedelta = PyDelta_FromDSU(days, seconds, 0);
-    return timedelta;
-}
-
 
-
-static int
-DatetimeObject_ReadOnlyErr(DatetimeObject *self, PyObject *value, void *closure) {
-   PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
-   return -1;
-}
 static int
-TimeDeltaObject_ReadOnlyErr(TimeDeltaObject *self, PyObject *value, void *closure) {
+DateObject_ReadOnlyErr(DateObject *self, PyObject *value, void *closure) {
    PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
    return -1;
 }
 
-static PyGetSetDef DatetimeObject_getseters[] = {
-    {"unit", (getter)DatetimeObject_unit, (setter)DatetimeObject_ReadOnlyErr,
-            "Returns the unit.", NULL},
-    {"freq", (getter)DatetimeObject_unit, (setter)DatetimeObject_ReadOnlyErr,
-            "Returns the unit.", NULL},
-    {"timestep", (getter)DatetimeObject_timestep, (setter)DatetimeObject_ReadOnlyErr,
-            "Returns the timestep.", NULL},
-    {"year", (getter)DatetimeObject_year, (setter)DatetimeObject_ReadOnlyErr,
+static PyGetSetDef DateObject_getseters[] = {
+    {"year", (getter)DateObject_year, (setter)DateObject_ReadOnlyErr,
             "Returns the year.", NULL},
-    {"qyear", (getter)DatetimeObject_qyear, (setter)DatetimeObject_ReadOnlyErr,
+    {"qyear", (getter)DateObject_qyear, (setter)DateObject_ReadOnlyErr,
             "For quarterly frequency dates, returns the year corresponding to the\n"
             "year end (start) month. When using QTR or QTR-E based quarterly\n"
             "frequencies, this is the fiscal year in a financial context.\n\n"
             "For non-quarterly dates, this simply returns the year of the date.",
             NULL},
-    {"quarter", (getter)DatetimeObject_quarter, (setter)DatetimeObject_ReadOnlyErr,
+    {"quarter", (getter)DateObject_quarter, (setter)DateObject_ReadOnlyErr,
             "Returns the quarter.", NULL},
-    {"month", (getter)DatetimeObject_month, (setter)DatetimeObject_ReadOnlyErr,
+    {"month", (getter)DateObject_month, (setter)DateObject_ReadOnlyErr,
             "Returns the month.", NULL},
-    {"week", (getter)DatetimeObject_week, (setter)DatetimeObject_ReadOnlyErr,
+    {"week", (getter)DateObject_week, (setter)DateObject_ReadOnlyErr,
             "Returns the week.", NULL},
-    {"day", (getter)DatetimeObject_day, (setter)DatetimeObject_ReadOnlyErr,
+    {"day", (getter)DateObject_day, (setter)DateObject_ReadOnlyErr,
             "Returns the day of month.", NULL},
-    {"weekday", (getter)DatetimeObject_weekday, (setter)DatetimeObject_ReadOnlyErr,
+    {"weekday", (getter)DateObject_weekday, (setter)DateObject_ReadOnlyErr,
             "Returns the day of week.", NULL},
     // deprecated alias for weekday property
-    {"day_of_week", (getter)DatetimeObject_weekday, (setter)DatetimeObject_ReadOnlyErr,
+    {"day_of_week", (getter)DateObject_weekday, (setter)DateObject_ReadOnlyErr,
             "Returns the day of week.", NULL},
-    {"day_of_year", (getter)DatetimeObject_day_of_year, (setter)DatetimeObject_ReadOnlyErr,
+    {"day_of_year", (getter)DateObject_day_of_year, (setter)DateObject_ReadOnlyErr,
             "Returns the day of year.", NULL},
-    {"second", (getter)DatetimeObject_second, (setter)DatetimeObject_ReadOnlyErr,
+    {"second", (getter)DateObject_second, (setter)DateObject_ReadOnlyErr,
             "Returns the second.", NULL},
-    {"minute", (getter)DatetimeObject_minute, (setter)DatetimeObject_ReadOnlyErr,
+    {"minute", (getter)DateObject_minute, (setter)DateObject_ReadOnlyErr,
             "Returns the minute.", NULL},
-    {"hour", (getter)DatetimeObject_hour, (setter)DatetimeObject_ReadOnlyErr,
+    {"hour", (getter)DateObject_hour, (setter)DateObject_ReadOnlyErr,
             "Returns the hour.", NULL},
-    {"freqstr", (getter)DatetimeObject_freqstr, (setter)DatetimeObject_ReadOnlyErr,
+
+    {"freqstr", (getter)DateObject_freqstr, (setter)DateObject_ReadOnlyErr,
             "Returns the string representation of frequency.", NULL},
-    {"datetime", (getter)DatetimeObject_datetime, (setter)DatetimeObject_ReadOnlyErr,
+    {"datetime", (getter)DateObject_datetime, (setter)DateObject_ReadOnlyErr,
             "Returns the Date object converted to standard python datetime object",
             NULL},
+
     {NULL}  /* Sentinel */
 };
-static PyGetSetDef TimeDeltaObject_getseters[] = {
-//    {"year", (getter)DeltaObject_year, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the year.", NULL},
-//    {"quarter", (getter)DeltaObject_quarter, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the quarter.", NULL},
-//    {"month", (getter)DeltaObject_month, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the month.", NULL},
-//    {"week", (getter)DeltaObject_week, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the week.", NULL},
-//    // deprecated alias for weekday property
-//    {"minute", (getter)DeltaObject_minute, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the minute.", NULL},
-//    {"hour", (getter)DeltaObject_hour, (setter)DeltaObject_ReadOnlyErr,
-//            "Returns the hour.", NULL},
-    {"freqstr", (getter)timedelta_freqstr, (setter)TimeDeltaObject_ReadOnlyErr,
-            "Returns the string representation of frequency.", NULL},
-    {"timedelta", (getter)TimeDeltaObject_timedelta, (setter)TimeDeltaObject_ReadOnlyErr,
-            "Returns the Delta object converted to standard python timedelta object",
-            NULL},
-    {NULL}  /* Sentinel */
-};
-
 
 
-
-static PyNumberMethods DatetimeObject_as_number = {
-    (binaryfunc)DatetimeObject___add__,      /* nb_add */
-    (binaryfunc)DatetimeObject___subtract__, /* nb_subtract */
+static PyNumberMethods DateObject_as_number = {
+    (binaryfunc)DateObject___add__,      /* nb_add */
+    (binaryfunc)DateObject___subtract__, /* nb_subtract */
     0,                                   /* nb_multiply */
     0,                                   /* nb_divide */
     0,                                   /* nb_remainder */
@@ -2077,80 +2465,45 @@ static PyNumberMethods DatetimeObject_as_number = {
     0,                                   /* nb_xor */
     0,                                   /* nb_or */
     0,                                   /* nb_coerce */
-    (unaryfunc)DatetimeObject_toint,       /* nb_int */
-    (unaryfunc)DatetimeObject_tolong,      /* nb_long */
-    (unaryfunc)DatetimeObject_tofloat,     /* nb_float */
+    (unaryfunc)DateObject___int__,       /* nb_int */
+    (unaryfunc)DateObject___long__,      /* nb_long */
+    (unaryfunc)DateObject___float__,     /* nb_float */
     (unaryfunc)0,                        /* nb_oct */
     (unaryfunc)0,                        /* nb_hex */
 };
-static PyNumberMethods TimeDeltaObject_as_number = {
-    (binaryfunc)timedelta_add,       /* nb_add */
-    (binaryfunc)timedelta_subtract,  /* nb_subtract */
-    (binaryfunc)timedelta_multiply,  /* nb_multiply */
-    0,                               /* nb_divide */
-    0,                               /* nb_remainder */
-    0,                               /* nb_divmod */
-    0,                               /* nb_power */
-    (unaryfunc)timedelta_negative,   /* nb_negative */
-    0,                               /* nb_positive */
-    0,                               /* nb_absolute */
-    0,                               /* nb_nonzero */
-    0,                               /* nb_invert */
-    0,                               /* nb_lshift */
-    0,                               /* nb_rshift */
-    0,                               /* nb_and */
-    0,                               /* nb_xor */
-    0,                               /* nb_or */
-    0,                               /* nb_coerce */
-    0,                               /* nb_int */
-    0,                               /* nb_long */
-    0,                               /* nb_float */
-    (unaryfunc)0,                    /* nb_oct */
-    (unaryfunc)0,                    /* nb_hex */
-};
 
-
-
-static PyMethodDef DatetimeObject_methods[] = {
-    {"toordinal", (PyCFunction)DatetimeObject_toordinal, METH_NOARGS,
-     DatetimeObject_toordinal_doc},
-    {"strftime", (PyCFunction)DatetimeObject_strftime, METH_VARARGS,
-     DatetimeObject_strftime_doc},
+static PyMethodDef DateObject_methods[] = {
+    {"toordinal", (PyCFunction)DateObject_toordinal, METH_NOARGS,
+     DateObject_toordinal_doc},
+    {"strftime", (PyCFunction)DateObject_strftime, METH_VARARGS,
+     DateObject_strftime_doc},
     // deprecated alias for strftime
-    {"strfmt", (PyCFunction)DatetimeObject_strftime, METH_VARARGS,
-     DatetimeObject_strfmt_doc},
-    {"asfreq", (PyCFunction)DatetimeObject_convert, METH_VARARGS | METH_KEYWORDS,
-     DatetimeObject_asfreq_doc},
-    {"convert", (PyCFunction)DatetimeObject_convert, METH_VARARGS | METH_KEYWORDS,
-     DatetimeObject_asfreq_doc},
+    {"strfmt", (PyCFunction)DateObject_strftime, METH_VARARGS,
+     DateObject_strfmt_doc},
+    {"asfreq", (PyCFunction)DateObject_asfreq, METH_VARARGS | METH_KEYWORDS,
+     DateObject_asfreq_doc},
     {NULL}  /* Sentinel */
 };
-//static PyMethodDef TimeDeltaObject_methods[] = {
-////    {"toordinal", (PyCFunction)DeltaObject_toordinal, METH_NOARGS,
-////     DeltaObject_toordinal_doc},
-//    {NULL}  /* Sentinel */
-//};
 
 
-
-PyTypeObject DatetimeObject_Type = {
+static PyTypeObject DateType = {
     PyObject_HEAD_INIT(NULL)
     0,                               /* ob_size */
     "timeseries.Date",               /* tp_name */
-    sizeof(DatetimeObject),              /* tp_basicsize */
+    sizeof(DateObject),              /* tp_basicsize */
     0,                               /* tp_itemsize */
-    (destructor)DatetimeObject_dealloc,  /* tp_dealloc */
+    (destructor)DateObject_dealloc,  /* tp_dealloc */
     0,                               /* tp_print */
     0,                               /* tp_getattr */
     0,                               /* tp_setattr */
-    (cmpfunc)DatetimeObject___compare__, /* tp_compare */
-    (reprfunc)DatetimeObject___repr__,   /* tp_repr */
-    &DatetimeObject_as_number,           /* tp_as_number */
+    (cmpfunc)DateObject___compare__, /* tp_compare */
+    (reprfunc)DateObject___repr__,   /* tp_repr */
+    &DateObject_as_number,           /* tp_as_number */
     0,                               /* tp_as_sequence */
     0,                               /* tp_as_mapping */
-    (hashfunc)DatetimeObject___hash__,   /* tp_hash */
+    (hashfunc)DateObject___hash__,   /* tp_hash */
     0,                               /* tp_call*/
-    (reprfunc)DatetimeObject___str__,    /* tp_str */
+    (reprfunc)DateObject___str__,    /* tp_str */
     0,                               /* tp_getattro */
     0,                               /* tp_setattro */
     0,                               /* tp_as_buffer */
@@ -2175,88 +2528,77 @@ PyTypeObject DatetimeObject_Type = {
     0,                               /* tp_weaklistoffset */
     0,                               /* tp_iter */
     0,                               /* tp_iternext */
-    DatetimeObject_methods,              /* tp_methods */
-    DatetimeObject_members,              /* tp_members */
-    DatetimeObject_getseters,            /* tp_getset */
+    DateObject_methods,              /* tp_methods */
+    DateObject_members,              /* tp_members */
+    DateObject_getseters,            /* tp_getset */
     0,                               /* tp_base */
     0,                               /* tp_dict */
     0,                               /* tp_descr_get */
     0,                               /* tp_descr_set */
     0,                               /* tp_dictoffset */
-    (initproc)DatetimeObject_init,       /* tp_init */
+    (initproc)DateObject_init,       /* tp_init */
     0,                               /* tp_alloc */
-    DatetimeObject_new,                  /* tp_new */
+    DateObject_new,                  /* tp_new */
 };
 
-static PyTypeObject TimeDeltaType = {
-    PyObject_HEAD_INIT(NULL)
-    0,                                    /* ob_size */
-    "timeseries.TimeDelta",               /* tp_name */
-    sizeof(TimeDeltaObject),              /* tp_basicsize */
-    0,                                    /* tp_itemsize */
-    (destructor)TimeDeltaObject_dealloc,  /* tp_dealloc */
-    0,                                    /* tp_print */
-    0,                                    /* tp_getattr */
-    0,                                    /* tp_setattr */
-    (cmpfunc)TimeDeltaObject___compare__, /* tp_compare */
-    (reprfunc)timedelta___repr__,   /* tp_repr */
-    &TimeDeltaObject_as_number,           /* tp_as_number */
-    0,                                    /* tp_as_sequence */
-    0,                                    /* tp_as_mapping */
-    (hashfunc)TimeDeltaObject___hash__,   /* tp_hash */
-    0,                                    /* tp_call*/
-    (reprfunc)timedelta___str__,    /* tp_str */
-    0,                                    /* tp_getattro */
-    0,                                    /* tp_setattro */
-    0,                                    /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT |                  /* tp_flags */
-    Py_TPFLAGS_CHECKTYPES |
-    Py_TPFLAGS_BASETYPE,
-    "Defines a Delta object, as the combination of a date and a frequency.\n",  /* tp_doc */
-    0,                                /* tp_traverse */
-    0,                                /* tp_clear */
-    0,                                /* tp_richcompare */
-    0,                                /* tp_weaklistoffset */
-    0,                                /* tp_iter */
-    0,                                /* tp_iternext */
-    0,              /* tp_methods */
-//    DeltaObject_methods,              /* tp_methods */
-    TimeDeltaObject_members,              /* tp_members */
-    TimeDeltaObject_getseters,            /* tp_getset */
-    0,                                /* tp_base */
-    0,                                /* tp_dict */
-    0,                                /* tp_descr_get */
-    0,                                /* tp_descr_set */
-    0,                                /* tp_dictoffset */
-    (initproc)TimeDeltaObject_init,       /* tp_init */
-    0,                                    /* tp_alloc */
-    TimeDeltaObject_new,                  /* tp_new */
-};
 
+///////////////////////////////////////////////////////////////////////
+
+PyObject *
+c_dates_check_freq(PyObject *self, PyObject *args) {
 
+    PyObject *freq;
+    int freq_val;
 
-///////////////////////////////////////////////////////////////////////
-#define DICT_SETINT_STRKEY(dict, key, val) {\
-        PyObject *pyval = PyInt_FromLong(val); \
-        PyDict_SetItemString(dict, key, pyval); \
-        Py_DECREF(pyval); }
+    if (!PyArg_ParseTuple(args, "O:check_freq(freq)", &freq)) return NULL;
+    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) return NULL;
 
+    return PyInt_FromLong(freq_val);
+}
 
 PyObject *
-c_dates_now(PyObject *self, PyObject *args) {
+c_dates_check_freq_str(PyObject *self, PyObject *args) {
 
-    PyObject *freq; //, *init_args, *init_kwargs;
-    struct tm *timeinfo;
-    ts_datetimestruct dinfo;
+    PyObject *alias_tuple, *result, *freq_key;
+
+    if ((freq_key = c_dates_check_freq(self, args)) == NULL) return NULL;
+
+    alias_tuple = PyDict_GetItem(freq_dict, freq_key);
+    result = PyTuple_GET_ITEM(alias_tuple, 0);
+
+    Py_INCREF(result);
+
+    Py_DECREF(freq_key);
+
+    return result;
+}
+
+PyObject *
+c_dates_get_freq_group(PyObject *self, PyObject *args) {
+
+    PyObject *freq;
     int freq_val;
-    DatetimeObject *date;
 
+    if (!PyArg_ParseTuple(args, "O:get_freq_group(freq)", &freq)) return NULL;
+    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) return NULL;
+
+    return PyInt_FromLong(get_freq_group(freq_val));
+}
+
+PyObject *
+c_dates_now(PyObject *self, PyObject *args) {
+
+    PyObject *freq, *init_args, *init_kwargs;
 
 #ifdef WIN32
     __time64_t rawtime;
 #else
     time_t rawtime;
 #endif
+    struct tm *timeinfo;
+    int freq_val;
+
+    DateObject *secondly_date;
 
     if (!PyArg_ParseTuple(args, "O:now(freq)", &freq)) return NULL;
 
@@ -2274,20 +2616,45 @@ c_dates_now(PyObject *self, PyObject *args) {
     timeinfo = localtime(&rawtime);
 #endif
 
-    //
-    dinfo.year = timeinfo->tm_year + 1900;
-    dinfo.month = timeinfo->tm_mon + 1;
-    dinfo.day = timeinfo->tm_mday;
-    dinfo.hour = timeinfo->tm_hour;
-    dinfo.min = timeinfo->tm_min;
-    dinfo.sec = timeinfo->tm_sec;
+    init_args = PyTuple_New(0);
+    init_kwargs = PyDict_New();
 
-    date = DatetimeObject_New();
-    init_metadata_from_unit(&date->obmeta, freq_val);
-    date->obval = datetimestruct_to_tsdatetime(&(date->obmeta), &dinfo);
-    return (PyObject*)date;
-}
+    DICT_SETINT_STRKEY(init_kwargs, "freq", FR_SEC);
+    DICT_SETINT_STRKEY(init_kwargs, "year", timeinfo->tm_year+1900);
+    DICT_SETINT_STRKEY(init_kwargs, "month", timeinfo->tm_mon+1);
+    DICT_SETINT_STRKEY(init_kwargs, "day", timeinfo->tm_mday);
+    DICT_SETINT_STRKEY(init_kwargs, "hour", timeinfo->tm_hour);
+    DICT_SETINT_STRKEY(init_kwargs, "minute", timeinfo->tm_min);
+    DICT_SETINT_STRKEY(init_kwargs, "second", timeinfo->tm_sec);
+
+    secondly_date = DateObject_New();
+    DateObject_init(secondly_date, init_args, init_kwargs);
+
+    Py_DECREF(init_args);
+    Py_DECREF(init_kwargs);
+
+    if (freq_val != FR_SEC) {
+        DateObject *result = DateObject_New();
 
+        long (*asfreq_func)(long, char, asfreq_info*) = NULL;
+        asfreq_info af_info;
+
+        int date_val;
+
+        get_asfreq_info(FR_SEC, freq_val, &af_info);
+        asfreq_func = get_asfreq_func(FR_SEC, freq_val, 0);
+
+        date_val = asfreq_func(secondly_date->value, 'S', &af_info);
+
+        Py_DECREF(secondly_date);
+
+        result->freq = freq_val;
+        result->value = date_val;
+
+        return (PyObject*)result;
+
+    } else { return (PyObject*)secondly_date; }
+}
 
 
 PyObject *
@@ -2297,63 +2664,43 @@ DateArray_asfreq(PyObject *self, PyObject *args)
     PyArrayIterObject *iterFrom, *iterTo;
     PyObject *fromDateObj, *toDateObj;
     char *relation;
-    char relation_from, relation_to;
-    conversion_function converterfrom, converterto;
-//    conversion_info infofrom, infoto;
-    int fromfreq, tofreq;
-    npy_int64 fromDate, toDate, tmpDate;
-
-    ts_metadata input_meta, output_meta;
+    int fromFreq, toFreq;
+    long fromDate, toDate;
+    long (*asfreq_main)(long, char, asfreq_info*) = NULL;
+    asfreq_info af_info;
 
     if (!PyArg_ParseTuple(args,
                 "Oiis:asfreq(fromDates, fromfreq, tofreq, relation)",
-                &fromDates, &fromfreq, &tofreq, &relation)) return NULL;
+                &fromDates, &fromFreq, &toFreq, &relation)) return NULL;
 
-    relation_from = relation[0];
-    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
-        relation_to = 'S';
-    else
-        relation_to = relation_from;
+    get_asfreq_info(fromFreq, toFreq, &af_info);
+
+    asfreq_main = get_asfreq_func(fromFreq, toFreq, 0);
 
     toDates = (PyArrayObject *)PyArray_Copy(fromDates);
 
     iterFrom = (PyArrayIterObject *)PyArray_IterNew((PyObject *)fromDates);
-    if (iterFrom == NULL)
-        return NULL;
+    if (iterFrom == NULL) return NULL;
 
     iterTo = (PyArrayIterObject *)PyArray_IterNew((PyObject *)toDates);
-    if (iterTo == NULL)
-        return NULL;
-
-    init_metadata_from_unit(&input_meta, fromfreq);
-    if (relation_from == 'S')
-        input_meta.convert_to_start = 1;
-    fromfreq = input_meta.unit;
-    converterfrom = convert_to_mediator(fromfreq, tofreq, 0);
-
-    init_metadata_from_unit(&output_meta, tofreq);
-    if (relation_to == 'S')
-        output_meta.convert_to_start = 1;
-    tofreq = output_meta.unit;
-    converterto = convert_from_mediator(fromfreq, tofreq, 0);
-
+    if (iterTo == NULL) return NULL;
 
     while (iterFrom->index < iterFrom->size) {
 
         fromDateObj = PyArray_GETITEM(fromDates, iterFrom->dataptr);
         fromDate = PyInt_AsLong(fromDateObj);
-        tmpDate = converterfrom(fromDate, &input_meta);
-        toDate = converterto(tmpDate, &output_meta);
-        // ERR_CHECK(toDate = asfreq_main(fromDate, relation[0], &af_info));
+        CHECK_ASFREQ(toDate = asfreq_main(fromDate, relation[0], &af_info));
         toDateObj = PyInt_FromLong(toDate);
 
         PyArray_SETITEM(toDates, iterTo->dataptr, toDateObj);
+
         Py_DECREF(fromDateObj);
         Py_DECREF(toDateObj);
 
         PyArray_ITER_NEXT(iterFrom);
         PyArray_ITER_NEXT(iterTo);
     }
+
     Py_DECREF(iterFrom);
     Py_DECREF(iterTo);
 
@@ -2368,8 +2715,10 @@ DateArray_asfreq(PyObject *self, PyObject *args)
 **************************************************************/
 
 // also used for qyear
-int __skip_periods_year(int freq) {
-    int freq_group = get_base_unit(freq);
+static int __skip_periods_year(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
     switch(freq_group)
     {
         case FR_QTR:
@@ -2392,8 +2741,11 @@ int __skip_periods_year(int freq) {
             return 1;
     }
 }
-int __skip_periods_quarter(int freq) {
-    int freq_group = get_base_unit(freq);
+
+static int __skip_periods_quarter(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
     switch(freq_group)
     {
         case FR_MTH:
@@ -2414,8 +2766,11 @@ int __skip_periods_quarter(int freq) {
             return 1;
     }
 }
-int __skip_periods_month(int freq) {
-    int freq_group = get_base_unit(freq);
+
+static int __skip_periods_month(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
     switch(freq_group)
     {
         case FR_WK:
@@ -2434,9 +2789,13 @@ int __skip_periods_month(int freq) {
             return 1;
     }
 }
+
 // also used for day_of_year, day_of_week
-int __skip_periods_day(int freq) {
-    switch(freq)
+static int __skip_periods_day(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
+    switch(freq_group)
     {
         case FR_HR:
             return 24;
@@ -2448,8 +2807,12 @@ int __skip_periods_day(int freq) {
             return 1;
     }
 }
-int __skip_periods_week(int freq) {
-    switch(freq)
+
+static int __skip_periods_week(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
+    switch(freq_group)
     {
         case FR_BUS:
             return 5;
@@ -2465,8 +2828,12 @@ int __skip_periods_week(int freq) {
             return 1;
     }
 }
-int __skip_periods_hour(int freq) {
-    switch(freq)
+
+static int __skip_periods_hour(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
+    switch(freq_group)
     {
         case FR_MIN:
             return 60;
@@ -2476,8 +2843,12 @@ int __skip_periods_hour(int freq) {
             return 1;
     }
 }
-int __skip_periods_minute(int freq) {
-    switch(freq)
+
+static int __skip_periods_minute(int freq) {
+
+    int freq_group = get_freq_group(freq);
+
+    switch(freq_group)
     {
         case FR_SEC:
             return 60;
@@ -2486,204 +2857,152 @@ int __skip_periods_minute(int freq) {
     }
 }
 
-
 PyObject *
-DateArray_getdateinfo(PyObject *self, PyObject *args)
+DateArray_getDateInfo(PyObject *self, PyObject *args)
 {
     int freq, is_full, skip_periods, counter=1, val_changed=0;
-    char *infochar;
-
-    ts_metadata meta;
+    char *info;
 
     PyObject *prev_val=NULL;
-    PyArrayObject *input, *output;
-    PyArrayIterObject *iterin, *iterout;
-
-//    PyObject* (*getdateparam)(DatetimeObject*, void*) = NULL;
-    PyObject* (*getdateparam)(npy_int64, int,
-                              conversion_function, ts_metadata*,
-                              ts_datetimestruct*) = NULL;
+    PyArrayObject *array, *newArray;
+    PyArrayIterObject *iterSource, *iterResult;
 
-    if (!PyArg_ParseTuple(args,
-                          "Oisi:getDateInfo(array, freq, info, is_full)",
-                          &input, &freq, &infochar, &is_full))
-        return NULL;
-    if (*infochar == 'P') {
-        output = (PyArrayObject *)PyArray_SimpleNew(input->nd, input->dimensions, NPY_OBJECT);
-    }
-    else {
-        output = (PyArrayObject *)PyArray_Copy(input);
-    };
+    PyObject* (*getDateInfo)(DateObject*, void*) = NULL;
 
-    conversion_function todays = get_converter_to_days(freq, 1);
-    init_metadata_from_unit(&meta, freq);
-    meta.convert_to_start = 0;
-    ts_datetimestruct dinfo;
+    if (!PyArg_ParseTuple(args, "Oisi:getDateInfo(array, freq, info, is_full)",
+                                &array, &freq, &info, &is_full)) return NULL;
+    newArray = (PyArrayObject *)PyArray_Copy(array);
 
+    iterSource = (PyArrayIterObject *)PyArray_IterNew((PyObject *)array);
+    iterResult = (PyArrayIterObject *)PyArray_IterNew((PyObject *)newArray);
 
-    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)input);
-    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
 
-    switch(*infochar)
+    switch(*info)
     {
         case 'Y': //year
-            getdateparam = &_loop_get_year;
+            getDateInfo = &DateObject_year;
             skip_periods = __skip_periods_year(freq);
             break;
         case 'F': //"fiscal" year
-            if (get_base_unit(freq) == FR_QTR)
-                getdateparam = &_loop_get_qyear_from_qtr;
-            else
-                getdateparam = &_loop_get_qyear;
+            getDateInfo = &DateObject_qyear;
             skip_periods = __skip_periods_year(freq);
             break;
         case 'Q': //quarter
-            if (get_base_unit(freq) == FR_QTR)
-                getdateparam = &_loop_get_quarter_from_qtr;
-            else
-                getdateparam = &_loop_get_quarter;
+            getDateInfo = &DateObject_quarter;
             skip_periods = __skip_periods_quarter(freq);
             break;
         case 'M': //month
-            getdateparam = &_loop_get_month;
+            getDateInfo = &DateObject_month;
             skip_periods = __skip_periods_month(freq);
             break;
         case 'D': //day
-            getdateparam = &_loop_get_day;
+            getDateInfo = &DateObject_day;
             skip_periods = __skip_periods_day(freq);
             break;
         case 'R': //day of year
-            getdateparam = &_loop_get_day_of_year;
+            getDateInfo = &DateObject_day_of_year;
             skip_periods = __skip_periods_day(freq);
             break;
         case 'W': //day of week
-            getdateparam = &_loop_get_day_of_week;
+            getDateInfo = &DateObject_day_of_week;
             skip_periods = __skip_periods_day(freq);
             break;
         case 'I': //week of year
-            getdateparam = &_loop_get_week;
+            getDateInfo = &DateObject_week;
             skip_periods = __skip_periods_week(freq);
             break;
         case 'H': //hour
-            getdateparam = &_loop_get_hour;
+            getDateInfo = &DateObject_hour;
             skip_periods = __skip_periods_hour(freq);
             break;
         case 'T': //minute
-            getdateparam = &_loop_get_minute;
+            getDateInfo = &DateObject_minute;
             skip_periods = __skip_periods_minute(freq);
             break;
         case 'S': //second
-            getdateparam = &_loop_get_second;
+            getDateInfo = &DateObject_second;
             skip_periods = 1;
             break;
-        case 'O': //toordinal
-            getdateparam = &_loop_get_ordinal;
-            skip_periods = __skip_periods_day(freq);
-            break;
         default:
             return NULL;
     }
 
     {
-        PyObject *val, *result=NULL;
-        while (iterin->index < iterin->size) {
+        DateObject *curr_date;
+        PyObject *val, *dInfo;
+
+        while (iterSource->index < iterSource->size) {
 
             if ((val_changed == 0) ||
                 (is_full == 0) ||
                 (prev_val == NULL) ||
                 (counter >= skip_periods)) {
 
-                   val = PyArray_GETITEM(input, iterin->dataptr);
-                   result = getdateparam(PyInt_AsLong(val), freq,
-                                         todays, &meta, &dinfo);
+                   val = PyArray_GETITEM(array, iterSource->dataptr);
+                   curr_date = DateObject_FromFreqAndValue(freq, PyInt_AsLong(val));
+                   dInfo = getDateInfo(curr_date, NULL);
 
                    if ((prev_val != NULL) &&
-                       (PyLong_AsLong(prev_val) != PyLong_AsLong(result))) {
+                       (PyInt_AsLong(prev_val) != PyInt_AsLong(dInfo))) {
                        val_changed = 1;
                        counter = 0;
                    }
+
                    Py_DECREF(val);
-//                   Py_DECREF(curr_date);
+                   Py_DECREF(curr_date);
+
                    if (prev_val != NULL) {
                        Py_DECREF(prev_val);
                    }
-                   prev_val = result;
+
+                   prev_val = dInfo;
             }
 
-            PyArray_SETITEM(output, iterout->dataptr, result);
+            PyArray_SETITEM(newArray, iterResult->dataptr, dInfo);
 
-            PyArray_ITER_NEXT(iterin);
-            PyArray_ITER_NEXT(iterout);
+            PyArray_ITER_NEXT(iterSource);
+            PyArray_ITER_NEXT(iterResult);
 
             counter += 1;
         }
     }
+
     if (prev_val != NULL) {
         Py_DECREF(prev_val);
     }
-    Py_DECREF(iterin);
-    Py_DECREF(iterout);
-    return (PyObject *) output;
-}
-
-
-PyObject *
-DateArray_getdatetime(PyObject *self, PyObject *args)
-{
-    int freq;
-
-    PyArrayObject *input, *output;
-    PyArrayIterObject *iterin, *iterout;
-
-    if (!PyArg_ParseTuple(args,
-                          "Oi:getdatetime(array, freq)", &input, &freq))
-        return NULL;
-    output = (PyArrayObject *)PyArray_SimpleNew(input->nd, input->dimensions, NPY_OBJECT);
-
-    conversion_function todays = get_converter_to_days(freq, 1);
-    ts_metadata meta = ((DatetimeObject *)self)->obmeta;
-    meta.convert_to_start = 1;
-    ts_datetimestruct dinfo;
-
-    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)input);
-    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+    Py_DECREF(iterSource);
+    Py_DECREF(iterResult);
 
-    {
-    PyObject *val, *result=NULL;
-    while (iterin->index < iterin->size) {
-        val = PyArray_GETITEM(input, iterin->dataptr);
-        result = _loop_get_datetime(PyInt_AsLong(val), freq,
-                                    todays, &meta, &dinfo);
-        PyArray_SETITEM(output, iterout->dataptr, result);
-        PyArray_ITER_NEXT(iterin);
-        PyArray_ITER_NEXT(iterout);
-        }
-    }
-    Py_DECREF(iterin);
-    Py_DECREF(iterout);
-    return (PyObject *) output;
+    return (PyObject *) newArray;
 }
 
 
-
-
 void import_c_dates(PyObject *m)
 {
 
-    if (PyType_Ready(&DatetimeObject_Type) < 0) return;
-    if (PyType_Ready(&TimeDeltaType) < 0) return;
+    if (PyType_Ready(&DateType) < 0) return;
 
-    DateCalc_Error = PyErr_NewException("c_dates.DateCalc_Error", NULL, NULL);
-    DateCalc_RangeError = PyErr_NewException("c_dates.DateCalc_RangeError",
-                                             NULL, NULL);
+    DateCalc_Error =
+        PyErr_NewException("c_dates.DateCalc_Error", NULL, NULL);
+    DateCalc_RangeError =
+        PyErr_NewException("c_dates.DateCalc_RangeError", NULL, NULL);
 
     import_array();
     PyDateTime_IMPORT;
 
-    Py_INCREF(&DatetimeObject_Type);
-    PyModule_AddObject(m, "Date", (PyObject *)(&DatetimeObject_Type));
-    Py_INCREF(&TimeDeltaType);
-    PyModule_AddObject(m, "TimeDelta", (PyObject *)(&TimeDeltaType));
+    Py_INCREF(&DateType);
+    PyModule_AddObject(m, "Date", (PyObject *)(&DateType));
+
+    if(build_freq_dict() == INT_ERR_CODE) {
+        PyErr_SetString(                    \
+            PyExc_ImportError,              \
+            "initialization of module timeseries.c_dates failed");
+        return;
+    };
+
+    PyModule_AddObject(m, "freq_dict", freq_dict);
+    PyModule_AddObject(m, "freq_dict_rev", freq_dict_rev);
+    PyModule_AddObject(m, "freq_constants", freq_constants);
 
     PyModule_AddObject(m, "DateCalc_Error", DateCalc_Error);
     PyModule_AddObject(m, "DateCalc_RangeError", DateCalc_RangeError);
diff --git a/pandas/src/timeseries/c_freqs.c b/pandas/src/timeseries/c_freqs.c
deleted file mode 100644
index ebe61292b..000000000
--- a/pandas/src/timeseries/c_freqs.c
+++ /dev/null
@@ -1,343 +0,0 @@
-#include "c_freqs.h"
-
-
-
-//static PyObject *freq_dict, *freq_dict_rev, *freq_constants;
-
-#define DICT_SETINT_STRKEY(dict, key, val) {\
-        PyObject *pyval = PyInt_FromLong(val); \
-        PyDict_SetItemString(dict, key, pyval); \
-        Py_DECREF(pyval); }
-
-#define ADD_FREQ_CONSTANT(const_name, val) \
-    DICT_SETINT_STRKEY(freq_constants, const_name, val)
-
-#define INIT_FREQ(const_name, key, aliases) \
-    {PyObject *pykey = PyInt_FromLong(key); \
-     PyDict_SetItem(freq_dict, pykey, aliases); \
-     PyDict_SetItemString(freq_constants, const_name, pykey); \
-     Py_DECREF(pykey); \
-     Py_DECREF(aliases); }
-
-
-
-
-static int init_freq_group(int num_items, int num_roots, int base_const,
-                           char item_abbrevs[][2][10], char group_prefixes[][15],
-                           char item_const_names[][15]) {
-    int i;
-
-    for (i = 0; i < num_items; i++) {
-
-        PyObject *aliases;
-        int j, size, k;
-
-        if (i == 0) { k = 3; } else { k = 2; }
-
-        size = num_roots * k;
-
-        aliases = PyTuple_New(size);
-
-        for (j = 0; j < num_roots; j++) {
-            PyObject *alias_v1, *alias_v2;
-            char *root, *alt;
-
-            if ((root = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
-            if ((alt = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
-
-            strcpy(root, group_prefixes[j]);
-            strcpy(alt, group_prefixes[j]);
-
-            if (i == 0) {
-                PyObject *alias = PyString_FromString(root);
-                PyTuple_SET_ITEM(aliases, j*k + 2, alias);
-            }
-
-            strcat(root, "-");
-            strcat(root, item_abbrevs[i][0]);
-            strcat(alt, "-");
-            strcat(alt, item_abbrevs[i][1]);
-
-            alias_v1 = PyString_FromString(root);
-            alias_v2 = PyString_FromString(alt);
-
-            free(root);
-            free(alt);
-
-            PyTuple_SET_ITEM(aliases, j*k, alias_v1);
-            PyTuple_SET_ITEM(aliases, j*k + 1, alias_v2);
-        }
-
-        INIT_FREQ(item_const_names[i], base_const+i, aliases);
-    }
-
-    return 0;
-}
-
-/* take a dictionary with integer keys and tuples of strings for values,
-   and populate a dictionary with all the strings as keys and integers
-   for values */
-static int reverse_dict(PyObject *source, PyObject *dest) {
-    PyObject *key, *value;
-    Py_ssize_t pos = 0;
-
-    while (PyDict_Next(source, &pos, &key, &value)) {
-        PyObject *tuple_iter;
-        PyObject *item;
-
-        if((tuple_iter = PyObject_GetIter(value)) == NULL) return INT_ERR_CODE;
-
-        while ((item = PyIter_Next(tuple_iter)) != NULL) {
-            PyDict_SetItem(dest, item, key);
-            Py_DECREF(item);
-        }
-        Py_DECREF(tuple_iter);
-    }
-    return 0;
-}
-
-
-
-static int build_freq_dict(void) {
-
-    char ANN_prefixes[8][15] = { "A", "Y", "ANN", "ANNUAL", "ANNUALLY",
-                                 "YR", "YEAR", "YEARLY" };
-
-    char QTRE_prefixes[8][15] = { "Q", "QTR", "QUARTER", "QUARTERLY", "Q-E",
-                                  "QTR-E", "QUARTER-E", "QUARTERLY-E"};
-    char QTRS_prefixes[4][15] = { "Q-S", "QTR-S", "QUARTER-S", "QUARTERLY-S" };
-
-    char WK_prefixes[4][15] =  { "W", "WK", "WEEK", "WEEKLY" };
-
-    /* Note: order of this array must match up with how the Annual
-       frequency constants are lined up */
-    char month_names[12][2][10] = {
-        { "DEC", "DECEMBER" },
-        { "JAN", "JANUARY" },
-        { "FEB", "FEBRUARY" },
-        { "MAR", "MARCH" },
-        { "APR", "APRIL" },
-        { "MAY", "MAY" },
-        { "JUN", "JUNE" },
-        { "JUL", "JULY" },
-        { "AUG", "AUGUST" },
-        { "SEP", "SEPTEMBER" },
-        { "OCT", "OCTOBER" },
-        { "NOV", "NOVEMBER" }};
-
-    char day_names[7][2][10] = {
-        { "SUN", "SUNDAY" },
-        { "MON", "MONDAY" },
-        { "TUE", "TUESDAY" },
-        { "WED", "WEDNESDAY" },
-        { "THU", "THURSDAY" },
-        { "FRI", "FRIDAY" },
-        { "SAT", "SATURDAY" }};
-
-    char ANN_const_names[12][15] = {
-        "FR_ANNDEC",
-        "FR_ANNJAN",
-        "FR_ANNFEB",
-        "FR_ANNMAR",
-        "FR_ANNAPR",
-        "FR_ANNMAY",
-        "FR_ANNJUN",
-        "FR_ANNJUL",
-        "FR_ANNAUG",
-        "FR_ANNSEP",
-        "FR_ANNOCT",
-        "FR_ANNNOV"};
-
-    char QTRE_const_names[12][15] = {
-        "FR_QTREDEC",
-        "FR_QTREJAN",
-        "FR_QTREFEB",
-        "FR_QTREMAR",
-        "FR_QTREAPR",
-        "FR_QTREMAY",
-        "FR_QTREJUN",
-        "FR_QTREJUL",
-        "FR_QTREAUG",
-        "FR_QTRESEP",
-        "FR_QTREOCT",
-        "FR_QTRENOV"};
-
-    char QTRS_const_names[12][15] = {
-        "FR_QTRSDEC",
-        "FR_QTRSJAN",
-        "FR_QTRSFEB",
-        "FR_QTRSMAR",
-        "FR_QTRSAPR",
-        "FR_QTRSMAY",
-        "FR_QTRSJUN",
-        "FR_QTRSJUL",
-        "FR_QTRSAUG",
-        "FR_QTRSSEP",
-        "FR_QTRSOCT",
-        "FR_QTRSNOV"};
-
-    char WK_const_names[7][15] = {
-        "FR_WKSUN",
-        "FR_WKMON",
-        "FR_WKTUE",
-        "FR_WKWED",
-        "FR_WKTHU",
-        "FR_WKFRI",
-        "FR_WKSAT"};
-
-    PyObject *aliases;
-
-    freq_dict = PyDict_New();
-    freq_dict_rev = PyDict_New();
-    freq_constants = PyDict_New();
-
-    aliases = Py_BuildValue("(ssss)", "M", "MTH", "MONTH", "MONTHLY");
-    INIT_FREQ("FR_MTH", FR_MTH, aliases);
-
-    aliases = Py_BuildValue("(ssss)", "B", "BUS", "BUSINESS", "BUSINESSLY");
-    INIT_FREQ("FR_BUS", FR_BUS, aliases);
-
-    aliases = Py_BuildValue("(ssss)", "D", "DAY", "DLY", "DAILY");
-    INIT_FREQ("FR_DAY", FR_DAY, aliases);
-
-    aliases = Py_BuildValue("(sssss)", "H", "HR", "HOUR", "HRLY", "HOURLY");
-    INIT_FREQ("FR_HR", FR_HR, aliases);
-
-    aliases = Py_BuildValue("(ssss)", "T", "MIN", "MINUTE", "MINUTELY");
-    INIT_FREQ("FR_MIN", FR_MIN, aliases);
-
-    aliases = Py_BuildValue("(ssss)", "S", "SEC", "SECOND", "SECONDLY");
-    INIT_FREQ("FR_SEC", FR_SEC, aliases);
-
-    aliases = Py_BuildValue("(ssss)", "U", "UND", "UNDEF", "UNDEFINED");
-    INIT_FREQ("FR_UND", FR_UND, aliases);
-
-    ADD_FREQ_CONSTANT("FR_ANN", FR_ANN);
-
-    if(init_freq_group(12, 8, FR_ANN,
-        month_names, ANN_prefixes, ANN_const_names) == INT_ERR_CODE) {
-            return INT_ERR_CODE;
-    }
-
-    ADD_FREQ_CONSTANT("FR_QTR", FR_QTR);
-
-    if(init_freq_group(12, 8, FR_QTREDEC,
-        month_names, QTRE_prefixes, QTRE_const_names) == INT_ERR_CODE) {
-            return INT_ERR_CODE;
-    }
-
-    if(init_freq_group(12, 4, FR_QTRSDEC,
-        month_names, QTRS_prefixes, QTRS_const_names) == INT_ERR_CODE) {
-            return INT_ERR_CODE;
-    }
-
-    ADD_FREQ_CONSTANT("FR_WK", FR_WK);
-
-    if(init_freq_group(7, 4, FR_WK,
-                    day_names, WK_prefixes, WK_const_names) == INT_ERR_CODE) {
-            return INT_ERR_CODE;
-    }
-
-    if(reverse_dict(freq_dict, freq_dict_rev) == INT_ERR_CODE) {
-        return INT_ERR_CODE;
-    }
-
-    return 0;
-}
-
-
-/* take user specified frequency and convert to int representation
-   of the frequency */
-int check_freq(PyObject *freq_spec) {
-
-    if (PyInt_Check(freq_spec)) {
-        return (int)PyInt_AsLong(freq_spec);
-    } else if (PyString_Check(freq_spec)) {
-        char *freq_str, *freq_str_uc;
-        PyObject *freq_val;
-
-        freq_str = PyString_AsString(freq_spec);
-        if((freq_str_uc = str_uppercase(freq_str)) == NULL) {return INT_ERR_CODE;}
-
-        freq_val = PyDict_GetItemString(freq_dict_rev, freq_str_uc);
-
-        free(freq_str_uc);
-
-        if (freq_val == NULL) {
-            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
-            return INT_ERR_CODE;
-        } else {
-            int ret_val = (int)PyInt_AsLong(freq_val);
-            return ret_val;
-        }
-    } else if (freq_spec == Py_None) {
-        return FR_UND;
-    } else {
-        int retval = (int)PyInt_AsLong(freq_spec);
-        if (PyErr_Occurred()) {
-            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
-            return INT_ERR_CODE;
-        } else {
-            return retval; }
-    }
-
-}
-
-
-
-
-PyObject *
-c_freqs_check_freq(PyObject *self, PyObject *args) {
-    PyObject *freq;
-    int freq_val;
-
-    if (!PyArg_ParseTuple(args, "O:check_freq(freq)", &freq)) 
-        return NULL;
-    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) 
-        return NULL;
-    return PyInt_FromLong(freq_val);
-}
-
-
-PyObject *
-c_freqs_check_freq_str(PyObject *self, PyObject *args) {
-    PyObject *alias_tuple, *result, *freq_key;
-
-    if ((freq_key = c_freqs_check_freq(self, args)) == NULL) 
-        return NULL;
-
-    alias_tuple = PyDict_GetItem(freq_dict, freq_key);
-    result = PyTuple_GET_ITEM(alias_tuple, 0);
-
-    Py_INCREF(result);
-    Py_DECREF(freq_key);
-
-    return result;
-}
-
-PyObject *
-c_freqs_get_freq_group(PyObject *self, PyObject *args) {
-    PyObject *freq;
-    int freq_val;
-    if (!PyArg_ParseTuple(args, "O:get_freq_group(freq)", &freq)) 
-        return NULL;
-    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) 
-        return NULL;
-    return PyInt_FromLong(get_base_unit(freq_val));
-}
-
-
-void import_c_freqs(PyObject *m)
-{
-    if(build_freq_dict() == INT_ERR_CODE) {
-        PyErr_SetString(PyExc_ImportError,              \
-                        "initialization of module timeseries.c_dates failed");
-        return;
-    };
-
-    PyModule_AddObject(m, "freq_dict", freq_dict);
-    PyModule_AddObject(m, "freq_dict_rev", freq_dict_rev);
-    PyModule_AddObject(m, "freq_constants", freq_constants);
-
-}
-
diff --git a/pandas/src/timeseries/c_lib.c b/pandas/src/timeseries/c_lib.c
index dc631d92c..043220bfd 100644
--- a/pandas/src/timeseries/c_lib.c
+++ b/pandas/src/timeseries/c_lib.c
@@ -20,8 +20,6 @@ np_add(PyObject *left_val, PyObject *right_val) {
     return result;
 }
 
-
-
 PyObject*
 np_subtract(PyObject *left_val, PyObject *right_val) {
 
@@ -34,8 +32,6 @@ np_subtract(PyObject *left_val, PyObject *right_val) {
     return result;
 }
 
-
-
 PyObject*
 np_multiply(PyObject *left_val, PyObject *right_val) {
 
@@ -48,15 +44,11 @@ np_multiply(PyObject *left_val, PyObject *right_val) {
     return result;
 }
 
-
-
 PyObject*
 np_sqrt(PyObject *val) {
     return PyObject_CallFunction(NP_SQRT, "(O)", val);
 }
 
-
-
 int np_greater(PyObject *left_val, PyObject *right_val) {
 
     PyObject *temp;
@@ -72,8 +64,6 @@ int np_greater(PyObject *left_val, PyObject *right_val) {
     return result;
 }
 
-
-
 int np_greater_equal(PyObject *left_val, PyObject *right_val) {
 
     PyObject *temp;
@@ -89,8 +79,6 @@ int np_greater_equal(PyObject *left_val, PyObject *right_val) {
     return result;
 }
 
-
-
 char *str_uppercase(char *str) {
     if (str) {
         int i, len=strlen(str);
@@ -136,8 +124,6 @@ char *str_uppercase(char *str) {
     } else { return NULL; }
 }
 
-
-
 char *str_replace(const char *s, const char *old, const char *new) {
     char *ret;
     int i, count = 0;
@@ -170,7 +156,6 @@ char *str_replace(const char *s, const char *old, const char *new) {
 }
 
 
-
 PyObject *
 set_callback(PyObject *args, PyObject **callback)
 {
@@ -194,8 +179,6 @@ set_callback(PyObject *args, PyObject **callback)
     return result;
 }
 
-
-
 void import_c_lib(PyObject *m) {
     PyObject *ops_dict;
 
diff --git a/pandas/src/timeseries/c_tseries.c b/pandas/src/timeseries/c_tseries.c
index befea75e3..46816cbd3 100644
--- a/pandas/src/timeseries/c_tseries.c
+++ b/pandas/src/timeseries/c_tseries.c
@@ -1,26 +1,27 @@
-#include "c_freqs.h"
-#include "c_convert.h"
 #include "c_dates.h"
 #include "c_tseries.h"
 
 /* Helper function for TimeSeries_convert:
     determine the size of the second dimension for the resulting
     converted array */
-static long get_width(int fromFreq, int toFreq) {
+static long get_height(int fromFreq, int toFreq) {
 
-    int maxBusDaysPerYear = 262;
-    int maxBusDaysPerQuarter = 66;
-    int maxBusDaysPerMonth = 23;
+    int maxBusDaysPerYear, maxBusDaysPerQuarter, maxBusDaysPerMonth;
+    int maxDaysPerYear, maxDaysPerQuarter, maxDaysPerMonth;
 
-    int maxDaysPerYear = 366;
-    int maxDaysPerQuarter = 92;
-    int maxDaysPerMonth = 31;
-
-    int fromGroup = get_base_unit(fromFreq);
-    int toGroup = get_base_unit(toFreq);
+    int fromGroup = get_freq_group(fromFreq);
+    int toGroup = get_freq_group(toFreq);
 
     if (fromGroup == FR_UND) { fromGroup = FR_DAY; }
 
+    maxBusDaysPerYear = 262;
+    maxBusDaysPerQuarter = 66;
+    maxBusDaysPerMonth = 23;
+
+    maxDaysPerYear = 366;
+    maxDaysPerQuarter = 92;
+    maxDaysPerMonth = 31;
+
     switch(fromGroup)
     {
         case FR_ANN: return 1;
@@ -89,7 +90,7 @@ static long get_width(int fromFreq, int toFreq) {
         case FR_SEC: //minutely
             switch(toGroup)
             {
-                case FR_ANN: return 24 * 60 * 60 * maxDaysPerYear;
+                case FR_ANN: return 24 * 60 * 60 * maxDaysPerYear;;
                 case FR_QTR: return 24 * 60 * 60 * maxDaysPerQuarter;
                 case FR_MTH: return 24 * 60 * 60 * maxDaysPerMonth;
                 case FR_WK: return 24 * 60 * 60 * 7;
@@ -113,42 +114,39 @@ TimeSeries_convert(PyObject *self, PyObject *args)
     PyObject *returnVal = NULL;
     PyObject *start_index_retval;
 
-    long period;
-    long startIndex, endIndex;
-    npy_int64 newStart, newStartTemp;
-    npy_int64 newEnd, newEndTemp;
-    long newLen, newWidth;
+    long startIndex;
+    long newStart, newStartTemp;
+    long newEnd, newEndTemp;
+    long newLen, newHeight;
     long currIndex, prevIndex;
     long nd;
     npy_intp *dim, *newIdx;
-    long currPerLen=0;
+    long currPerLen;
     char *position;
     PyObject *fromFreq_arg, *toFreq_arg;
     int fromFreq, toFreq;
-    char relation_from, relation_to;
+    char relation;
+    asfreq_info af_info;
     int i;
-    conversion_function totmp, fromtmp;
-    ts_metadata metato, metafrom;
 
     PyObject *val, *valMask;
 
-    // long (*asfreq_main)(long, char, asfreq_info*) = NULL;
-    // long (*asfreq_endpoints)(long, char, asfreq_info*) = NULL;
-    // long (*asfreq_reverse)(long, char, asfreq_info*) = NULL;
+    long (*asfreq_main)(long, char, asfreq_info*) = NULL;
+    long (*asfreq_endpoints)(long, char, asfreq_info*) = NULL;
+    long (*asfreq_reverse)(long, char, asfreq_info*) = NULL;
 
     returnVal = PyDict_New();
 
     if (!PyArg_ParseTuple(args,
-        "OOlOslO:convert(array, fromfreq, period, tofreq, position, startindex, mask)",
-        &array, &fromFreq_arg, &period, &toFreq_arg,
+        "OOOslO:convert(array, fromfreq, tofreq, position, startIndex, mask)",
+        &array, &fromFreq_arg, &toFreq_arg,
         &position, &startIndex, &mask)) return NULL;
 
-    if((fromFreq = check_freq(fromFreq_arg)) == INT_ERR_CODE)
-        return NULL;
-    if((toFreq = check_freq(toFreq_arg)) == INT_ERR_CODE)
-        return NULL;
+    if((fromFreq = check_freq(fromFreq_arg)) == INT_ERR_CODE) return NULL;
+    if((toFreq = check_freq(toFreq_arg)) == INT_ERR_CODE) return NULL;
 
-    if (toFreq == fromFreq) {
+    if (toFreq == fromFreq)
+    {
         PyObject *sidx;
         newArray = (PyArrayObject *)PyArray_Copy(array);
         newMask = (PyArrayObject *)PyArray_Copy(mask);
@@ -169,96 +167,58 @@ TimeSeries_convert(PyObject *self, PyObject *args)
     {
         case 'S':
             // start -> before
-            relation_to = 'S';
+            relation = 'S';
             break;
         case 'E':
             // end -> after
-            relation_to = 'E';
+            relation = 'E';
             break;
         default:
             return NULL;
             break;
     }
-    if ((toFreq == FR_BUS) && (fromFreq < FR_DAY))
-        relation_from = 'S';
-    else
-        relation_from = relation_to;
-
-    totmp = convert_to_mediator(fromFreq, toFreq, 1);
-    init_metadata_from_unit(&metato, fromFreq);
-    metato.convert_to_start = 1;
-//    set_conversion_info(fromFreq, 'S', &infoto);
-    fromtmp = convert_from_mediator(fromFreq, toFreq, 1);
-    init_metadata_from_unit(&metafrom, toFreq);
-    metafrom.convert_to_start = 1;
-//    set_conversion_info(toFreq, 'S', &infofrom);
-
 
+    get_asfreq_info(fromFreq, toFreq, &af_info);
 
-    // get_asfreq_info(fromFreq, toFreq, &af_info);
-
-    // asfreq_main = get_asfreq_func(fromFreq, toFreq, 1);
-    // asfreq_endpoints = get_asfreq_func(fromFreq, toFreq, 0);
+    asfreq_main = get_asfreq_func(fromFreq, toFreq, 1);
+    asfreq_endpoints = get_asfreq_func(fromFreq, toFreq, 0);
 
     //convert start index to new frequency
-    ERR_CHECK(newStartTemp = fromtmp(totmp(startIndex, &metato), &metafrom));
-// asfreq_main(startIndex, 'S', &af_info));
-    newStart = newStartTemp;
-//    if (newStartTemp < 1) {
-//        ERR_CHECK(newStart = asfreq_endpoints(startIndex, 'E', &af_info));
-//    } else {
-//        newStart = newStartTemp;
-//    };
-//    if (newStart < 1) {
-//        PyErr_SetString(PyExc_ValueError,
-//                        "start_date outside allowable range for destination frequency");
-//        return NULL;
-//    };
+    CHECK_ASFREQ(newStartTemp = asfreq_main(startIndex, 'S', &af_info));
+    if (newStartTemp < 1) {
+        CHECK_ASFREQ(newStart = asfreq_endpoints(startIndex, 'E', &af_info));
+    }
+    else { newStart = newStartTemp; }
 
     //convert end index to new frequency
-    endIndex = startIndex + (array->dimensions[0] - 1)*period;
-
-    metato.convert_to_start = (int)0;
-    metafrom.convert_to_start = (int)0;
-    ERR_CHECK(newEndTemp = fromtmp(totmp(endIndex, &metato), &metafrom));
-    // ERR_CHECK(newEndTemp = asfreq_main(endIndex, 'E', &af_info));
-//    if (newEndTemp < 1) {
-//        ERR_CHECK(newEnd = asfreq_endpoints(endIndex, 'S', &af_info));
-//    } else { newEnd = newEndTemp; }
-    newEnd = newEndTemp;
-    newLen = newEnd - newStart + 1;
-    newWidth = get_width(fromFreq, toFreq);
-    if (newWidth % period > 0){
-        newWidth = newWidth / period + 1;
-    } else {
-        newWidth /= period;
+    CHECK_ASFREQ(newEndTemp = asfreq_main(startIndex+array->dimensions[0]-1, 'E', &af_info));
+    if (newEndTemp < 1) {
+        CHECK_ASFREQ(newEnd = asfreq_endpoints(startIndex+array->dimensions[0]-1, 'S', &af_info));
+    }
+    else { newEnd = newEndTemp; }
+
+    if (newStart < 1) {
+        PyErr_SetString(PyExc_ValueError, "start_date outside allowable range for destination frequency");
+        return NULL;
     }
 
-    if (newWidth > 1) {
+    newLen = newEnd - newStart + 1;
+    newHeight = get_height(fromFreq, toFreq);
+
+    if (newHeight > 1) {
         long tempval;
-        conversion_function totmprev, fromtmprev;
-        ts_metadata metatorev, metafromrev;
-
-
-        // get_asfreq_info(toFreq, fromFreq, &af_info_rev);
-        // asfreq_reverse = get_asfreq_func(toFreq, fromFreq, 0);
-        totmprev = convert_to_mediator(toFreq, fromFreq, 0);
-        init_metadata_from_unit(&metatorev, toFreq);
-        metatorev.convert_to_start = 1;
-//        set_conversion_info(toFreq, 'S', &metatorev);
-        fromtmprev = convert_from_mediator(toFreq, fromFreq, 0);
-//        set_conversion_info(fromFreq, 'S', &infofromrev);
-        init_metadata_from_unit(&metafromrev, fromFreq);
-        metafromrev.convert_to_start = 1;
-
-        // ERR_CHECK(tempval = asfreq_reverse(newStart, 'S', &af_info_rev));
-        ERR_CHECK(tempval = fromtmprev(totmprev(newStart, &metatorev), &metafromrev));
+        asfreq_info af_info_rev;
+
+        get_asfreq_info(toFreq, fromFreq, &af_info_rev);
+        asfreq_reverse = get_asfreq_func(toFreq, fromFreq, 0);
+
+        CHECK_ASFREQ(tempval = asfreq_reverse(newStart, 'S', &af_info_rev));
         currPerLen = startIndex - tempval;
 
         nd = 2;
         dim = PyDimMem_NEW(nd);
         dim[0] = (npy_intp)newLen;
-        dim[1] = (npy_intp)newWidth;
+        dim[1] = (npy_intp)newHeight;
     } else {
         nd = 1;
         dim = PyDimMem_NEW(nd);
@@ -278,12 +238,7 @@ TimeSeries_convert(PyObject *self, PyObject *args)
 
     prevIndex = newStart;
 
-    metafrom.convert_to_start = (relation_from == 'S');
-    metato.convert_to_start = (relation_to == 'S');
-
-
     //set values in the new array
-
     for (i = 0; i < array->dimensions[0]; i++) {
 
         npy_intp idx = (npy_intp)i;
@@ -291,19 +246,21 @@ TimeSeries_convert(PyObject *self, PyObject *args)
         val = PyArray_GETITEM(array, PyArray_GetPtr(array, &idx));
         valMask = PyArray_GETITEM(mask, PyArray_GetPtr(mask, &idx));
 
-        // ERR_CHECK(currIndex = asfreq_main(startIndex + i*period, relation, &af_info));
-        ERR_CHECK(currIndex = fromtmp(totmp(startIndex + i*period, &metato), &metafrom));
+        CHECK_ASFREQ(currIndex = asfreq_main(startIndex + i, relation, &af_info));
 
         newIdx[0] = (npy_intp)(currIndex-newStart);
 
-        if (newWidth > 1) {
-            if (currIndex != prevIndex) {
-                //reset period length
-                currPerLen = 0;
-                prevIndex = currIndex;
-            }
-            newIdx[1] = (npy_intp)currPerLen;
-            currPerLen++;
+        if (newHeight > 1) {
+
+                if (currIndex != prevIndex)
+                {
+                    //reset period length
+                    currPerLen = 0;
+                    prevIndex = currIndex;
+                }
+
+                newIdx[1] = (npy_intp)currPerLen;
+                currPerLen++;
         }
 
         if (newIdx[0] > -1) {
@@ -401,7 +358,7 @@ check_mov_args(
     if (span < min_win_size) {
         char *error_str;
         error_str = PyArray_malloc(60 * sizeof(char));
-        MEM_CHECK(error_str);
+        MEM_CHECK(error_str)
         sprintf(error_str,
                 "span must be greater than or equal to %i",
                 min_win_size);
@@ -411,7 +368,7 @@ check_mov_args(
     }
 
     raw_result_mask = PyArray_malloc((*orig_ndarray_tmp)->dimensions[0] * sizeof(int));
-    MEM_CHECK(raw_result_mask);
+    MEM_CHECK(raw_result_mask)
 
     {
         PyArrayObject *orig_mask_tmp;
@@ -446,7 +403,7 @@ check_mov_args(
     *result_mask = PyArray_SimpleNewFromData(
                              1, (*orig_ndarray_tmp)->dimensions,
                              PyArray_INT32, raw_result_mask);
-    MEM_CHECK(*result_mask);
+    MEM_CHECK(*result_mask)
     result_mask_tmp = (PyArrayObject**)result_mask;
     (*result_mask_tmp)->flags = ((*result_mask_tmp)->flags) | NPY_OWNDATA;
     return 0;
@@ -483,7 +440,7 @@ calc_mov_sum(
                                        orig_ndarray->nd,
                                        orig_ndarray->dimensions,
                                        rtype, 0);
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     for (i=0; i<orig_ndarray->dimensions[0]; i++) {
 
@@ -516,7 +473,7 @@ calc_mov_sum(
                                    PyArray_GetPtr(result_ndarray, &idx));
             mov_sum_val = np_add(val, mov_sum_prevval);
             Py_DECREF(mov_sum_prevval);
-            NULL_CHECK(mov_sum_val);
+            ERR_CHECK(mov_sum_val)
 
             if (non_masked > span) {
                 PyObject *temp_val, *rem_val;
@@ -531,7 +488,7 @@ calc_mov_sum(
                                        PyArray_GetPtr(orig_ndarray, &idx));
 
                     mov_sum_val = np_subtract(temp_val, rem_val);
-                    NULL_CHECK(mov_sum_val);
+                    ERR_CHECK(mov_sum_val)
 
                     Py_DECREF(temp_val);
                     Py_DECREF(rem_val);
@@ -587,10 +544,10 @@ MaskedArray_mov_sum(PyObject *self, PyObject *args, PyObject *kwds)
         (PyArrayObject*)orig_ndarray, (PyArrayObject*)orig_mask,
         span, rtype
     );
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     result_dict = PyDict_New();
-    MEM_CHECK(result_dict);
+    MEM_CHECK(result_dict)
     PyDict_SetItemString(result_dict, "array", result_ndarray);
     PyDict_SetItemString(result_dict, "mask", result_mask);
 
@@ -616,17 +573,17 @@ calc_mov_ranked(PyArrayObject *orig_ndarray, int span, int rtype, char rank_type
                                        orig_ndarray->nd,
                                        orig_ndarray->dimensions,
                                        rtype, 0);
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     if (arr_size >= span) {
         result_array = calloc(arr_size, sizeof(PyObject*));
-        MEM_CHECK(result_array);
+        MEM_CHECK(result_array)
 
         /* this array will be used for quick access to the data in the original
            array (so PyArray_GETITEM doesn't have to be used over and over in the
            main loop) */
         ref_array = PyArray_malloc(arr_size * sizeof(PyObject*));
-        MEM_CHECK(ref_array);
+        MEM_CHECK(ref_array)
 
         for (i=0; i<arr_size; i++) {
             idx = (npy_intp)i;
@@ -636,7 +593,7 @@ calc_mov_ranked(PyArrayObject *orig_ndarray, int span, int rtype, char rank_type
         /* this array wll be used for keeping track of the "ranks" of the values
            in the current window */
         r = PyArray_malloc(span * sizeof(int));
-        MEM_CHECK(r);
+        MEM_CHECK(r)
 
         for (i=0; i < span; i++) {
             r[i] = 1;
@@ -645,25 +602,25 @@ calc_mov_ranked(PyArrayObject *orig_ndarray, int span, int rtype, char rank_type
         if (rank_type == 'E' && ((span % 2) == 0)) {
             // array to store two median values when span is an even #
             even_array = calloc(2, sizeof(PyObject*));
-            MEM_CHECK(even_array);
+            MEM_CHECK(even_array)
         }
 
-        switch(rank_type) {
-            case 'E': // median
-                R = (span + 1)/2;
-                break;
-            case 'I': // min
-                R = 1;
-                break;
-            case 'A': // max
-                R = span;
-                break;
-            default:
-            {
-                PyErr_SetString(PyExc_RuntimeError, "unexpected rank type");
-                return NULL;
-            }
-        }
+		switch(rank_type) {
+			case 'E': // median
+				R = (span + 1)/2;
+				break;
+			case 'I': // min
+				R = 1;
+				break;
+			case 'A': // max
+				R = span;
+				break;
+			default:
+			{
+				PyErr_SetString(PyExc_RuntimeError, "unexpected rank type");
+		        return NULL;
+			}
+		}
 
         one_half = PyFloat_FromDouble(0.5);
 
@@ -807,10 +764,10 @@ MaskedArray_mov_median(PyObject *self, PyObject *args, PyObject *kwds)
 
     result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
                                      span, rtype, 'E');
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     result_dict = PyDict_New();
-    MEM_CHECK(result_dict);
+    MEM_CHECK(result_dict)
     PyDict_SetItemString(result_dict, "array", result_ndarray);
     PyDict_SetItemString(result_dict, "mask", result_mask);
 
@@ -842,10 +799,10 @@ MaskedArray_mov_min(PyObject *self, PyObject *args, PyObject *kwds)
 
     result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
                                      span, rtype, 'I');
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     result_dict = PyDict_New();
-    MEM_CHECK(result_dict);
+    MEM_CHECK(result_dict)
     PyDict_SetItemString(result_dict, "array", result_ndarray);
     PyDict_SetItemString(result_dict, "mask", result_mask);
 
@@ -877,10 +834,10 @@ MaskedArray_mov_max(PyObject *self, PyObject *args, PyObject *kwds)
 
     result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
                                      span, rtype, 'A');
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     result_dict = PyDict_New();
-    MEM_CHECK(result_dict);
+    MEM_CHECK(result_dict)
     PyDict_SetItemString(result_dict, "array", result_ndarray);
     PyDict_SetItemString(result_dict, "mask", result_mask);
 
@@ -903,7 +860,7 @@ calc_mov_average_expw(
                                        orig_ndarray->nd,
                                        orig_ndarray->dimensions,
                                        rtype, 0);
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     decay_factor = PyFloat_FromDouble(2.0/((double)(span + 1)));
 
@@ -937,7 +894,7 @@ calc_mov_average_expw(
                 Py_DECREF(mov_avg_prevval);
                 Py_DECREF(temp_val_a);
                 Py_DECREF(temp_val_b);
-                NULL_CHECK(mov_avg_val);
+                ERR_CHECK(mov_avg_val);
             } else {
                 mov_avg_val = mov_avg_prevval;
             }
@@ -985,10 +942,10 @@ MaskedArray_mov_average_expw(PyObject *self, PyObject *args, PyObject *kwds)
         (PyArrayObject*)orig_ndarray, (PyArrayObject*)orig_mask,
         span, rtype
     );
-    NULL_CHECK(result_ndarray);
+    ERR_CHECK(result_ndarray)
 
     result_dict = PyDict_New();
-    MEM_CHECK(result_dict);
+    MEM_CHECK(result_dict)
     PyDict_SetItemString(result_dict, "array", result_ndarray);
 
     Py_DECREF(result_ndarray);
diff --git a/pandas/src/timeseries/cseries.c b/pandas/src/timeseries/cseries.c
index 1205d34c6..561acbd62 100644
--- a/pandas/src/timeseries/cseries.c
+++ b/pandas/src/timeseries/cseries.c
@@ -1,9 +1,5 @@
 #include "c_lib.h"
-#include "c_types.h"
-#include "c_freqs.h"
-#include "c_convert.h"
 #include "c_dates.h"
-#include "c_datearray.h"
 #include "c_tseries.h"
 
 static PyMethodDef cseries_methods[] = {
@@ -22,11 +18,9 @@ static PyMethodDef cseries_methods[] = {
     {"TS_convert", (PyCFunction)TimeSeries_convert,
      METH_VARARGS, ""},
 
-    {"DateArray_asfreq", (PyCFunction)DateArray_asfreq,
+    {"DA_asfreq", (PyCFunction)DateArray_asfreq,
      METH_VARARGS, ""},
-    {"DateArray_getdateinfo", (PyCFunction)DateArray_getdateinfo,
-     METH_VARARGS, ""},
-    {"DateArray_getdatetime", (PyCFunction)DateArray_getdatetime,
+    {"DA_getDateInfo", (PyCFunction)DateArray_getDateInfo,
      METH_VARARGS, ""},
 
 
@@ -42,15 +36,15 @@ static PyMethodDef cseries_methods[] = {
         "   Frequency to convert the Date to. Accepts any valid frequency\n"
         "   specification (string or integer)\n"},
 
-    {"check_freq", (PyCFunction)c_freqs_check_freq,
+    {"check_freq", (PyCFunction)c_dates_check_freq,
      METH_VARARGS,
         "Translates a user specified frequency into the corresponding frequency constant"},
 
-    {"check_freq_str", (PyCFunction)c_freqs_check_freq_str,
+    {"check_freq_str", (PyCFunction)c_dates_check_freq_str,
      METH_VARARGS,
         "Translates a user specified frequency into standard string representation"},
 
-    {"get_freq_group", (PyCFunction)c_freqs_get_freq_group,
+    {"get_freq_group", (PyCFunction)c_dates_get_freq_group,
      METH_VARARGS,
         "translate user specified frequency into frequency group constant"},
 
@@ -73,9 +67,7 @@ initcseries(void)
       return;
 
     import_c_lib(m);
-    import_c_freqs(m);
     import_c_dates(m);
-    import_c_datearray(m);
     import_c_tseries(m);
 
 }
diff --git a/setup.py b/setup.py
index d974e9fcd..e59602e7e 100755
--- a/setup.py
+++ b/setup.py
@@ -211,10 +211,7 @@ class CleanCommand(Command):
                                'np_datetime_strings.c',
                                # scikits.timeseries code
                                'cseries.c',
-                               'c_convert.c',
-                               'c_datearray.c',
                                'c_dates.c',
-                               'c_freqs.c',
                                'c_lib.c',
                                'c_tseries.c']
 
@@ -370,23 +367,24 @@ sandbox_ext = Extension('pandas._sandbox',
 datetime_ext = Extension('pandas._datetime',
                          sources=[srcpath('datetime', suffix=suffix),
                                           'pandas/src/np_datetime.c',
-                                          'pandas/src/np_datetime_strings.c',
-                                           # scikits.timeseries code
-                                          'pandas/src/timeseries/cseries.c',
-                                          'pandas/src/timeseries/c_convert.c',
-                                          'pandas/src/timeseries/c_datearray.c',
-                                          'pandas/src/timeseries/c_dates.c',
-                                          'pandas/src/timeseries/c_freqs.c',
-                                          'pandas/src/timeseries/c_lib.c',
-                                          'pandas/src/timeseries/c_tseries.c'],
-                         include_dirs=[np.get_include()])
+                                          'pandas/src/np_datetime_strings.c'],
+                         include_dirs=[np.get_include(),
+                                       'pandas/src/timeseries'])
+skts_ext = Extension('pandas._skts',
+                     sources= [os.path.join('pandas/src/timeseries', x)
+                               for x in ('c_lib.c',
+                                         'c_dates.c',
+                                         'c_tseries.c',
+                                         'cseries.c')],
+                      include_dirs=[np.get_include(),
+                                    'pandas/src/timeseries'])
 
 cppsandbox_ext = Extension('pandas._cppsandbox',
                            language='c++',
                            sources=[srcpath('cppsandbox', suffix=suffix)],
                            include_dirs=[np.get_include()])
 
-extensions = [tseries_ext, engines_ext, sparse_ext, datetime_ext]
+extensions = [tseries_ext, engines_ext, sparse_ext, datetime_ext, skts_ext]
 
 if not ISRELEASED:
     extensions.extend([sandbox_ext])

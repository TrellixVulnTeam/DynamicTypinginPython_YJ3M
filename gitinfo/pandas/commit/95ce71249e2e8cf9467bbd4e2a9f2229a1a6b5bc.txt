commit 95ce71249e2e8cf9467bbd4e2a9f2229a1a6b5bc
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Sat Feb 1 16:15:46 2014 -0500

    ENH: backport Python 3.3 ChainMap
    
    ChainMap implements a list of mappings that effectively functions as a single
    dictionary. This class is very useful for implementing scope. This commit also
    adds a DeepChainMap subclass of ChainMap for writing and deleting keys.

diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
index 8ec3adcdf..5459f7dfb 100644
--- a/pandas/compat/__init__.py
+++ b/pandas/compat/__init__.py
@@ -54,6 +54,8 @@ except ImportError:
     import pickle as cPickle
     import http.client as httplib
 
+from chainmap import DeepChainMap
+
 
 if PY3:
     def isidentifier(s):
diff --git a/pandas/compat/chainmap.py b/pandas/compat/chainmap.py
new file mode 100644
index 000000000..d61d04415
--- /dev/null
+++ b/pandas/compat/chainmap.py
@@ -0,0 +1,20 @@
+try:
+    from collections import ChainMap
+except ImportError:
+    from chainmap_impl import ChainMap
+
+
+class DeepChainMap(ChainMap):
+    def __setitem__(self, key, value):
+        for mapping in self.maps:
+            if key in mapping:
+                mapping[key] = value
+                return
+        self.maps[0][key] = value
+
+    def __delitem__(self, key):
+        for mapping in self.maps:
+            if key in mapping:
+                del mapping[key]
+                return
+        raise KeyError(key)
diff --git a/pandas/compat/chainmap_impl.py b/pandas/compat/chainmap_impl.py
new file mode 100644
index 000000000..1110831d5
--- /dev/null
+++ b/pandas/compat/chainmap_impl.py
@@ -0,0 +1,132 @@
+from collections import MutableMapping
+from thread import get_ident
+
+
+def recursive_repr(fillvalue='...'):
+    'Decorator to make a repr function return fillvalue for a recursive call'
+
+    def decorating_function(user_function):
+        repr_running = set()
+
+        def wrapper(self):
+            key = id(self), get_ident()
+            if key in repr_running:
+                return fillvalue
+            repr_running.add(key)
+            try:
+                result = user_function(self)
+            finally:
+                repr_running.discard(key)
+            return result
+
+        # Can't use functools.wraps() here because of bootstrap issues
+        wrapper.__module__ = getattr(user_function, '__module__')
+        wrapper.__doc__ = getattr(user_function, '__doc__')
+        wrapper.__name__ = getattr(user_function, '__name__')
+        return wrapper
+
+    return decorating_function
+
+
+class ChainMap(MutableMapping):
+    ''' A ChainMap groups multiple dicts (or other mappings) together
+    to create a single, updateable view.
+
+    The underlying mappings are stored in a list.  That list is public and can
+    accessed or updated using the *maps* attribute.  There is no other state.
+
+    Lookups search the underlying mappings successively until a key is found.
+    In contrast, writes, updates, and deletions only operate on the first
+    mapping.
+
+    '''
+
+    def __init__(self, *maps):
+        '''Initialize a ChainMap by setting *maps* to the given mappings.
+        If no mappings are provided, a single empty dictionary is used.
+
+        '''
+        self.maps = list(maps) or [{}]          # always at least one map
+
+    def __missing__(self, key):
+        raise KeyError(key)
+
+    def __getitem__(self, key):
+        for mapping in self.maps:
+            try:
+                return mapping[key]             # can't use 'key in mapping' with defaultdict
+            except KeyError:
+                pass
+        return self.__missing__(key)            # support subclasses that define __missing__
+
+    def get(self, key, default=None):
+        return self[key] if key in self else default
+
+    def __len__(self):
+        return len(set().union(*self.maps))     # reuses stored hash values if possible
+
+    def __iter__(self):
+        return iter(set().union(*self.maps))
+
+    def __contains__(self, key):
+        return any(key in m for m in self.maps)
+
+    def __bool__(self):
+        return any(self.maps)
+
+    @recursive_repr()
+    def __repr__(self):
+        return '{0.__class__.__name__}({1})'.format(
+            self, ', '.join(repr(m) for m in self.maps))
+
+    @classmethod
+    def fromkeys(cls, iterable, *args):
+        'Create a ChainMap with a single dict created from the iterable.'
+        return cls(dict.fromkeys(iterable, *args))
+
+    def copy(self):
+        'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
+        return self.__class__(self.maps[0].copy(), *self.maps[1:])
+
+    __copy__ = copy
+
+    def new_child(self, m=None):                # like Django's Context.push()
+        '''
+        New ChainMap with a new map followed by all previous maps. If no
+        map is provided, an empty dict is used.
+        '''
+        if m is None:
+            m = {}
+        return self.__class__(m, *self.maps)
+
+    @property
+    def parents(self):                          # like Django's Context.pop()
+        'New ChainMap from maps[1:].'
+        return self.__class__(*self.maps[1:])
+
+    def __setitem__(self, key, value):
+        self.maps[0][key] = value
+
+    def __delitem__(self, key):
+        try:
+            del self.maps[0][key]
+        except KeyError:
+            raise KeyError('Key not found in the first mapping: {!r}'.format(key))
+
+    def popitem(self):
+        'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
+        try:
+            return self.maps[0].popitem()
+        except KeyError:
+            raise KeyError('No keys found in the first mapping.')
+
+    def pop(self, key, *args):
+        'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
+        try:
+            return self.maps[0].pop(key, *args)
+        except KeyError:
+            raise KeyError('Key not found in the first mapping: {!r}'.format(key))
+
+    def clear(self):
+        'Clear maps[0], leaving maps[1:] intact.'
+        self.maps[0].clear()
diff --git a/pandas/computation/engines.py b/pandas/computation/engines.py
index 9738cac58..936f8313c 100644
--- a/pandas/computation/engines.py
+++ b/pandas/computation/engines.py
@@ -4,6 +4,7 @@
 import abc
 
 from pandas import compat
+from pandas.compat import DeepChainMap
 from pandas.core import common as com
 from pandas.computation.align import _align, _reconstruct_object
 from pandas.computation.ops import UndefinedVariableError
@@ -29,9 +30,6 @@ class AbstractEngine(object):
         """
         return com.pprint_thing(self.expr)
 
-    def pre_evaluate(self):
-        self.expr.check_name_clashes()
-
     def evaluate(self):
         """Run the engine on the expression
 
@@ -47,7 +45,6 @@ class AbstractEngine(object):
             self.result_type, self.aligned_axes = _align(self.expr.terms)
 
         # make sure no names in resolvers and locals/globals clash
-        self.pre_evaluate()
         res = self._evaluate()
         return _reconstruct_object(self.result_type, res, self.aligned_axes,
                                    self.expr.terms.return_type)
@@ -87,16 +84,14 @@ class NumExprEngine(AbstractEngine):
     def _evaluate(self):
         import numexpr as ne
 
-        # add the resolvers to locals
-        self.expr.add_resolvers_to_locals()
-
         # convert the expression to a valid numexpr expression
         s = self.convert()
 
         try:
-            return ne.evaluate(s, local_dict=self.expr.env.locals,
-                               global_dict=self.expr.env.globals,
-                               truediv=self.expr.truediv)
+            env = self.expr.env
+            full_scope = DeepChainMap(*(env.resolvers.maps + env.scope.maps))
+            return ne.evaluate(s, local_dict=full_scope,
+                               truediv=env.scope['truediv'])
         except KeyError as e:
             # python 3 compat kludge
             try:
@@ -118,7 +113,6 @@ class PythonEngine(AbstractEngine):
         super(PythonEngine, self).__init__(expr)
 
     def evaluate(self):
-        self.pre_evaluate()
         return self.expr()
 
     def _evaluate(self):
diff --git a/pandas/computation/expr.py b/pandas/computation/expr.py
index 71501d507..d87628654 100644
--- a/pandas/computation/expr.py
+++ b/pandas/computation/expr.py
@@ -631,7 +631,7 @@ class BaseExprVisitor(ast.NodeVisitor):
 
         try:
             assigner = self.visit(node.targets[0], **kwargs)
-        except UndefinedVariableError:
+        except (UndefinedVariableError, KeyError):
             assigner = node.targets[0].id
 
         self.assigner = getattr(assigner, 'name', assigner)
@@ -639,6 +639,7 @@ class BaseExprVisitor(ast.NodeVisitor):
             raise SyntaxError('left hand side of an assignment must be a '
                               'single resolvable name')
 
+        import ipdb; ipdb.set_trace()
         return self.visit(node.value, **kwargs)
 
     def visit_Attribute(self, node, **kwargs):
diff --git a/pandas/computation/scope.py b/pandas/computation/scope.py
new file mode 100644
index 000000000..9f0c69319
--- /dev/null
+++ b/pandas/computation/scope.py
@@ -0,0 +1,240 @@
+"""Module for scope operations
+"""
+
+import sys
+import operator
+import struct
+import inspect
+import datetime
+import itertools
+import pprint
+
+import pandas as pd
+from pandas.compat import DeepChainMap, map
+from pandas.core import common as com
+from pandas.core.base import StringMixin
+from pandas.computation.ops import UndefinedVariableError
+
+
+def _ensure_scope(level, global_dict=None, local_dict=None, resolvers=(),
+                  target=None, **kwargs):
+    """Ensure that we are grabbing the correct scope."""
+    return Scope(level + 1, gbls=global_dict, lcls=local_dict,
+                 resolvers=resolvers, target=target)
+
+
+def _replacer(x, pad_size):
+    """Replace a number with its padded hexadecimal representation. Used to tag
+    temporary variables with their calling scope's id.
+    """
+    # get the hex repr of the binary char and remove 0x and pad by pad_size
+    # zeros
+    try:
+        hexin = ord(x)
+    except TypeError:
+        # bytes literals masquerade as ints when iterating in py3
+        hexin = x
+
+    return hex(hexin).replace('0x', '').rjust(pad_size, '0')
+
+
+def _raw_hex_id(obj, pad_size=2):
+    """Return the padded hexadecimal id of ``obj``."""
+    # interpret as a pointer since that's what really what id returns
+    packed = struct.pack('@P', id(obj))
+    return ''.join(_replacer(x, pad_size) for x in packed)
+
+
+
+_DEFAULT_GLOBALS = {
+    'Timestamp': pd.lib.Timestamp,
+    'datetime': datetime.datetime,
+    'True': True,
+    'False': False,
+    'list': list,
+    'tuple': tuple
+}
+
+
+def _is_resolver(x):
+    return isinstance(x, Resolver)
+
+
+def _get_pretty_string(obj):
+    sio = StringIO()
+    pprint.pprint(obj, stream=sio)
+    return sio.getvalue()
+
+
+class Scope(StringMixin):
+
+    """Object to hold scope, with a few bells to deal with some custom syntax
+    added by pandas.
+
+    Parameters
+    ----------
+    gbls : dict or None, optional, default None
+    lcls : dict or Scope or None, optional, default None
+    level : int, optional, default 1
+    resolvers : list-like or None, optional, default None
+
+    Attributes
+    ----------
+    globals : dict
+    locals : dict
+    level : int
+    resolvers : tuple
+    resolver_keys : frozenset
+    """
+    __slots__ = 'level', 'scope', 'target', 'ntemps'
+
+    def __init__(self, level, gbls=None, lcls=None, resolvers=(), target=None):
+        self.level = level + 1
+
+        # shallow copy because we don't want to keep filling this up with what
+        # was there before if there are multiple calls to Scope/_ensure_scope
+        self.scope = DeepChainMap(_DEFAULT_GLOBALS.copy())
+        self.target = target
+        self.ntemps = 0  # number of temporary variables in this scope
+
+        if isinstance(lcls, Scope):
+            self.scope.update(lcls.scope)
+            if lcls.target is not None:
+                self.target = lcls.target
+            self.update(lcls.level)
+
+        frame = sys._getframe(self.level)
+
+        try:
+            # shallow copy here because we don't want to replace what's in
+            # scope when we align terms (alignment accesses the underlying
+            # numpy array of pandas objects)
+            if not isinstance(lcls, Scope):
+                self.scope = self.scope.new_child((lcls or frame.f_locals).copy())
+            self.scope = self.scope.new_child((gbls or frame.f_globals).copy())
+        finally:
+            del frame
+
+        # assumes that resolvers are going from outermost scope to inner
+        if isinstance(lcls, Scope):
+            resolvers += tuple(lcls.resolvers.maps)
+        self.resolvers = DeepChainMap(*resolvers)
+
+    def __unicode__(self):
+        scope_keys = _get_pretty_string(self.scope.keys())
+        res_keys = _get_pretty_string(self.resolvers.keys())
+        return 'Scope(scope=%s, resolvers=%s)' % (scope_keys, res_keys)
+
+    @property
+    def has_resolvers(self):
+        return bool(self.nresolvers)
+
+    @property
+    def nresolvers(self):
+        return len(self.resolvers)
+
+    def resolve(self, key, is_local):
+        """Resolve a variable name in a possibly local context
+
+        Parameters
+        ----------
+        key : text_type
+            A variable name
+        is_local : bool
+            Flag indicating whether the variable is local or not (prefixed with
+            the '@' symbol)
+
+        Returns
+        -------
+        value : object
+            The value of a particular variable
+        """
+        try:
+            # only look for locals in outer scope
+            if is_local:
+                return self.scope[key]
+
+            # not a local variable so check in resolvers if we have them
+            if self.has_resolvers:
+                return self.resolvers[key]
+
+            # if we're here that means that we have no locals and we also have
+            # no resolvers
+            assert not is_local and not self.has_resolvers
+            return self.scope[key]
+        except KeyError:
+            raise UndefinedVariableError(key)
+
+    def swapkey(self, old_key, new_key, new_value=None):
+        if self.has_resolvers:
+            maps = self.resolvers.maps + self.scope.maps
+        else:
+            maps = self.scope.maps
+
+        for mapping in maps:
+            if old_key in mapping:
+                if new_value is None:
+                    mapping[new_key] = mapping.pop(old_key)
+                else:
+                    mapping[new_key] = new_value
+                return
+        raise KeyError(old_key)
+
+    def _get_vars(self, stack, scopes):
+        variables = itertools.product(scopes, stack)
+        for scope, (frame, _, _, _, _, _) in variables:
+            try:
+                d = getattr(frame, 'f_' + scope)
+                self.scope = self.scope.new_child(d)
+            finally:
+                # won't remove it, but DECREF it
+                # in Py3 this probably isn't necessary since frame won't be
+                # scope after the loop
+                del frame
+
+    def update(self, level):
+        """Update the current scope by going back `level` levels.
+
+        Parameters
+        ----------
+        level : int or None, optional, default None
+        """
+        sl = level + 1
+
+        # add sl frames to the scope starting with the
+        # most distant and overwriting with more current
+        # makes sure that we can capture variable scope
+        stack = inspect.stack()
+
+        try:
+            self._get_vars(stack[:sl], scopes=['locals'])
+        finally:
+            del stack[:], stack
+
+    def add_tmp(self, value):
+        """Add a temporary variable to the scope.
+
+        Parameters
+        ----------
+        value : object
+            An arbitrary object to be assigned to a temporary variable.
+
+        Returns
+        -------
+        name : basestring
+            The name of the temporary variable created.
+        """
+        name = 'tmp_var_{0}_{1}_{2}'.format(type(value).__name__, self.ntemps,
+                                            _raw_hex_id(self))
+
+        # add to inner most scope
+        assert name not in self.scope.maps[0]
+        self.scope.maps[0][name] = value
+
+        # only increment if the variable gets put in the scope
+        self.ntemps += 1
+        return name
+
+    def remove_tmp(self, name):
+        del self.scope[name]
+        self.ntemps -= 1
diff --git a/pandas/computation/tests/test_eval.py b/pandas/computation/tests/test_eval.py
index bb700c0d5..d0318083f 100644
--- a/pandas/computation/tests/test_eval.py
+++ b/pandas/computation/tests/test_eval.py
@@ -23,7 +23,6 @@ from pandas.computation.expr import PythonExprVisitor, PandasExprVisitor
 from pandas.computation.ops import (_binary_ops_dict,
                                     _special_case_arith_ops_syms,
                                     _arith_ops_syms, _bool_ops_syms)
-from pandas.computation.common import NameResolutionError
 
 import pandas.computation.expr as expr
 import pandas.util.testing as tm
@@ -1043,6 +1042,7 @@ class TestOperationsNumExprPandas(tm.TestCase):
     def eval(self, *args, **kwargs):
         kwargs['engine'] = self.engine
         kwargs['parser'] = self.parser
+        kwargs['level'] = kwargs.pop('level', 0) + 1
         return pd.eval(*args, **kwargs)
 
     def test_simple_arith_ops(self):
@@ -1114,10 +1114,10 @@ class TestOperationsNumExprPandas(tm.TestCase):
         d = {'s': s}
 
         if PY3:
-            res = self.eval(ex, truediv=False, local_dict=d)
+            res = self.eval(ex, truediv=False)
             assert_array_equal(res, np.array([1.0]))
 
-            res = self.eval(ex, truediv=True, local_dict=d)
+            res = self.eval(ex, truediv=True)
             assert_array_equal(res, np.array([1.0]))
 
             res = self.eval('1 / 2', truediv=True)
@@ -1128,18 +1128,18 @@ class TestOperationsNumExprPandas(tm.TestCase):
             expec = 0.5
             self.assertEqual(res, expec)
 
-            res = self.eval('s / 2', truediv=False, local_dict={'s': s})
+            res = self.eval('s / 2', truediv=False)
             expec = 0.5
             self.assertEqual(res, expec)
 
-            res = self.eval('s / 2', truediv=True, local_dict={'s': s})
+            res = self.eval('s / 2', truediv=True)
             expec = 0.5
             self.assertEqual(res, expec)
         else:
-            res = self.eval(ex, truediv=False, local_dict=d)
+            res = self.eval(ex, truediv=False)
             assert_array_equal(res, np.array([1]))
 
-            res = self.eval(ex, truediv=True, local_dict=d)
+            res = self.eval(ex, truediv=True)
             assert_array_equal(res, np.array([1.0]))
 
             res = self.eval('1 / 2', truediv=True)
@@ -1150,18 +1150,18 @@ class TestOperationsNumExprPandas(tm.TestCase):
             expec = 0
             self.assertEqual(res, expec)
 
-            res = self.eval('s / 2', truediv=False, local_dict={'s': s})
+            res = self.eval('s / 2', truediv=False)
             expec = 0
             self.assertEqual(res, expec)
 
-            res = self.eval('s / 2', truediv=True, local_dict={'s': s})
+            res = self.eval('s / 2', truediv=True)
             expec = 0.5
             self.assertEqual(res, expec)
 
     def test_failing_subscript_with_name_error(self):
         df = DataFrame(np.random.randn(5, 3))
-        self.assertRaises(NameError, self.eval, 'df[x > 2] > 2',
-                          local_dict={'df': df})
+        with tm.assertRaises(NameError):
+            self.eval('df[x > 2] > 2')
 
     def test_lhs_expression_subscript(self):
         df = DataFrame(np.random.randn(5, 3))
@@ -1232,8 +1232,9 @@ class TestOperationsNumExprPandas(tm.TestCase):
 
         def f():
             a = 1
-            df.eval('a=a+b')
-        self.assertRaises(NameResolutionError, f)
+            old_a = df.a.copy()
+            df.eval('a = a + b')
+            assert_frame_equal(old_a + df.b, df.a)
 
         # multiple assignment
         df = orig_df.copy()
@@ -1486,34 +1487,6 @@ def test_invalid_parser():
                        parser='asdf')
 
 
-def check_is_expr_syntax(engine):
-    tm.skip_if_no_ne(engine)
-    s = 1
-    valid1 = 's + 1'
-    valid2 = '__y + _xx'
-    assert_true(expr.isexpr(valid1, check_names=False))
-    assert_true(expr.isexpr(valid2, check_names=False))
-
-
-def check_is_expr_names(engine):
-    tm.skip_if_no_ne(engine)
-    r, s = 1, 2
-    valid = 's + r'
-    invalid = '__y + __x'
-    assert_true(expr.isexpr(valid, check_names=True))
-    assert_false(expr.isexpr(invalid, check_names=True))
-
-
-def test_is_expr_syntax():
-    for engine in _engines:
-        yield check_is_expr_syntax, engine
-
-
-def test_is_expr_names():
-    for engine in _engines:
-        yield check_is_expr_names, engine
-
-
 _parsers = {'python': PythonExprVisitor, 'pytables': pytables.ExprVisitor,
             'pandas': PandasExprVisitor}
 
@@ -1547,7 +1520,8 @@ def test_syntax_error_exprs():
 def check_name_error_exprs(engine, parser):
     tm.skip_if_no_ne(engine)
     e = 's + t'
-    assert_raises(NameError, pd.eval, e, engine=engine, parser=parser)
+    with tm.assertRaises(NameError):
+        pd.eval(e, engine=engine, parser=parser)
 
 
 def test_name_error_exprs():
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index bf682f7c5..3251e59e5 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -350,7 +350,7 @@ class NDFrame(PandasObject):
         d[axis] = dindex
         return d
 
-    def _get_resolvers(self):
+    def _get_index_resolvers(self):
         d = {}
         for axis_name in self._AXIS_ORDERS:
             d.update(self._get_axis_resolvers(axis_name))

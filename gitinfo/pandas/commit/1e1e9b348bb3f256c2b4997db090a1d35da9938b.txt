commit 1e1e9b348bb3f256c2b4997db090a1d35da9938b
Author: sinhrks <sinhrks@gmail.com>
Date:   Mon Jul 18 21:28:01 2016 -0400

    DEPR: Remove legacy offsets
    
    Follow-up of #10951.
    Remove legacy offsets deprecated in 0.17.0.
    
    Author: sinhrks <sinhrks@gmail.com>
    
    Closes #13590 from sinhrks/depr_legacy_offset and squashes the following commits:
    
    2593b1f [sinhrks] DEPR: Remove legacy offsets

diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 7e832af14..f6a1e169a 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -752,7 +752,7 @@ calculate significantly slower and will raise a ``PerformanceWarning``
    rng + BQuarterEnd()
 
 
-.. _timeseries.alias:
+.. _timeseries.custombusinessdays:
 
 Custom Business Days (Experimental)
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -953,6 +953,8 @@ You can use keyword arguments suported by either ``BusinessHour`` and ``CustomBu
     # Monday is skipped because it's a holiday, business hour starts from 10:00
     dt + bhour_mon * 2
 
+.. _timeseries.alias:
+
 Offset Aliases
 ~~~~~~~~~~~~~~
 
@@ -1103,48 +1105,6 @@ it is rolled forward to the next anchor point.
    pd.Timestamp('2014-01-01') + MonthBegin(n=0)
    pd.Timestamp('2014-01-31') + MonthEnd(n=0)
 
-.. _timeseries.legacyaliases:
-
-Legacy Aliases
-~~~~~~~~~~~~~~
-Note that prior to v0.8.0, time rules had a slightly different look. These are
-deprecated in v0.17.0, and removed in future version.
-
-.. csv-table::
-    :header: "Legacy Time Rule", "Offset Alias"
-    :widths: 15, 65
-
-    "WEEKDAY", "B"
-    "EOM", "BM"
-    "W\@MON", "W\-MON"
-    "W\@TUE", "W\-TUE"
-    "W\@WED", "W\-WED"
-    "W\@THU", "W\-THU"
-    "W\@FRI", "W\-FRI"
-    "W\@SAT", "W\-SAT"
-    "W\@SUN", "W\-SUN"
-    "Q\@JAN", "BQ\-JAN"
-    "Q\@FEB", "BQ\-FEB"
-    "Q\@MAR", "BQ\-MAR"
-    "A\@JAN", "BA\-JAN"
-    "A\@FEB", "BA\-FEB"
-    "A\@MAR", "BA\-MAR"
-    "A\@APR", "BA\-APR"
-    "A\@MAY", "BA\-MAY"
-    "A\@JUN", "BA\-JUN"
-    "A\@JUL", "BA\-JUL"
-    "A\@AUG", "BA\-AUG"
-    "A\@SEP", "BA\-SEP"
-    "A\@OCT", "BA\-OCT"
-    "A\@NOV", "BA\-NOV"
-    "A\@DEC", "BA\-DEC"
-
-
-As you can see, legacy quarterly and annual frequencies are business quarters
-and business year ends. Please also note the legacy time rule for milliseconds
-``ms`` versus the new offset alias for month start ``MS``. This means that
-offset alias parsing is case sensitive.
-
 .. _timeseries.holiday:
 
 Holidays / Holiday Calendars
diff --git a/doc/source/whatsnew/v0.19.0.txt b/doc/source/whatsnew/v0.19.0.txt
index 0107bdea5..5a1b5041c 100644
--- a/doc/source/whatsnew/v0.19.0.txt
+++ b/doc/source/whatsnew/v0.19.0.txt
@@ -510,6 +510,17 @@ Removal of prior version deprecations/changes
 - ``DataFrame.to_dict()`` has dropped the ``outtype`` parameter in favor of ``orient`` (:issue:`13627`, :issue:`8486`)
 - ``pd.Categorical`` has dropped the ``levels`` attribute in favour of ``categories`` (:issue:`8376`)
 
+- Removal of the legacy time rules (offset aliases), deprecated since 0.17.0 (this has been alias since 0.8.0) (:issue:`13590`)
+
+  Previous Behavior:
+
+  .. code-block:: ipython
+
+     In [2]: pd.date_range('2016-07-01', freq='W@MON', periods=3)
+     pandas/tseries/frequencies.py:465: FutureWarning: Freq "W@MON" is deprecated, use "W-MON" as alternative.
+     Out[2]: DatetimeIndex(['2016-07-04', '2016-07-11', '2016-07-18'], dtype='datetime64[ns]', freq='W-MON')
+
+  Now legacy time rules raises ``ValueError``. For the list of currently supported offsets, see :ref:`here <timeseries.alias>`
 
 .. _whatsnew_0190.performance:
 
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index e2132deb9..8b3785d78 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -1,5 +1,5 @@
 from datetime import timedelta
-from pandas.compat import range, long, zip
+from pandas.compat import long, zip
 from pandas import compat
 import re
 import warnings
@@ -356,34 +356,6 @@ def get_period_alias(offset_str):
     """ alias to closest period strings BQ->Q etc"""
     return _offset_to_period_map.get(offset_str, None)
 
-_rule_aliases = {
-    # Legacy rules that will continue to map to their original values
-    # essentially for the rest of time
-    'WEEKDAY': 'B',
-    'EOM': 'BM',
-    'W@MON': 'W-MON',
-    'W@TUE': 'W-TUE',
-    'W@WED': 'W-WED',
-    'W@THU': 'W-THU',
-    'W@FRI': 'W-FRI',
-    'W@SAT': 'W-SAT',
-    'W@SUN': 'W-SUN',
-    'Q@JAN': 'BQ-JAN',
-    'Q@FEB': 'BQ-FEB',
-    'Q@MAR': 'BQ-MAR',
-    'A@JAN': 'BA-JAN',
-    'A@FEB': 'BA-FEB',
-    'A@MAR': 'BA-MAR',
-    'A@APR': 'BA-APR',
-    'A@MAY': 'BA-MAY',
-    'A@JUN': 'BA-JUN',
-    'A@JUL': 'BA-JUL',
-    'A@AUG': 'BA-AUG',
-    'A@SEP': 'BA-SEP',
-    'A@OCT': 'BA-OCT',
-    'A@NOV': 'BA-NOV',
-    'A@DEC': 'BA-DEC',
-}
 
 _lite_rule_alias = {
     'W': 'W-SUN',
@@ -401,17 +373,6 @@ _lite_rule_alias = {
     'ns': 'N'
 }
 
-# TODO: Can this be killed?
-for _i, _weekday in enumerate(['MON', 'TUE', 'WED', 'THU', 'FRI']):
-    for _iweek in range(4):
-        _name = 'WOM-%d%s' % (_iweek + 1, _weekday)
-        _rule_aliases[_name.replace('-', '@')] = _name
-
-# Note that _rule_aliases is not 1:1 (d[BA]==d[A@DEC]), and so traversal
-# order matters when constructing an inverse. we pick one. #2331
-# Used in get_legacy_offset_name
-_legacy_reverse_map = dict((v, k) for k, v in
-                           reversed(sorted(compat.iteritems(_rule_aliases))))
 
 _name_to_offset_map = {'days': Day(1),
                        'hours': Hour(1),
@@ -422,6 +383,9 @@ _name_to_offset_map = {'days': Day(1),
                        'nanoseconds': Nano(1)}
 
 
+_INVALID_FREQ_ERROR = "Invalid frequency: {0}"
+
+
 def to_offset(freqstr):
     """
     Return DateOffset object from string representation or
@@ -460,7 +424,7 @@ def to_offset(freqstr):
                     else:
                         delta = delta + offset
         except Exception:
-            raise ValueError("Could not evaluate %s" % freqstr)
+            raise ValueError(_INVALID_FREQ_ERROR.format(freqstr))
 
     else:
         delta = None
@@ -479,10 +443,10 @@ def to_offset(freqstr):
                 else:
                     delta = delta + offset
         except Exception:
-            raise ValueError("Could not evaluate %s" % freqstr)
+            raise ValueError(_INVALID_FREQ_ERROR.format(freqstr))
 
     if delta is None:
-        raise ValueError('Unable to understand %s as a frequency' % freqstr)
+        raise ValueError(_INVALID_FREQ_ERROR.format(freqstr))
 
     return delta
 
@@ -526,9 +490,6 @@ def get_base_alias(freqstr):
 _dont_uppercase = set(('MS', 'ms'))
 
 
-_LEGACY_FREQ_WARNING = 'Freq "{0}" is deprecated, use "{1}" as alternative.'
-
-
 def get_offset(name):
     """
     Return DateOffset object associated with rule name
@@ -539,27 +500,9 @@ def get_offset(name):
     """
     if name not in _dont_uppercase:
         name = name.upper()
-
-        if name in _rule_aliases:
-            new = _rule_aliases[name]
-            warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning, stacklevel=2)
-            name = new
-        elif name.lower() in _rule_aliases:
-            new = _rule_aliases[name.lower()]
-            warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning, stacklevel=2)
-            name = new
-
         name = _lite_rule_alias.get(name, name)
         name = _lite_rule_alias.get(name.lower(), name)
-
     else:
-        if name in _rule_aliases:
-            new = _rule_aliases[name]
-            warnings.warn(_LEGACY_FREQ_WARNING.format(name, new),
-                          FutureWarning, stacklevel=2)
-            name = new
         name = _lite_rule_alias.get(name, name)
 
     if name not in _offset_map:
@@ -571,7 +514,7 @@ def get_offset(name):
             offset = klass._from_name(*split[1:])
         except (ValueError, TypeError, KeyError):
             # bad prefix or suffix
-            raise ValueError('Bad rule name requested: %s.' % name)
+            raise ValueError(_INVALID_FREQ_ERROR.format(name))
         # cache
         _offset_map[name] = offset
     # do not return cache because it's mutable
@@ -595,17 +538,6 @@ def get_offset_name(offset):
     return offset.freqstr
 
 
-def get_legacy_offset_name(offset):
-    """
-    Return the pre pandas 0.8.0 name for the date offset
-    """
-
-    # This only used in test_timeseries_legacy.py
-
-    name = offset.name
-    return _legacy_reverse_map.get(name, name)
-
-
 def get_standard_freq(freq):
     """
     Return the standardized frequency string
@@ -796,36 +728,18 @@ _period_alias_dict = _period_alias_dictionary()
 
 
 def _period_str_to_code(freqstr):
-    # hack
-    if freqstr in _rule_aliases:
-        new = _rule_aliases[freqstr]
-        warnings.warn(_LEGACY_FREQ_WARNING.format(freqstr, new),
-                      FutureWarning, stacklevel=3)
-        freqstr = new
     freqstr = _lite_rule_alias.get(freqstr, freqstr)
 
     if freqstr not in _dont_uppercase:
         lower = freqstr.lower()
-        if lower in _rule_aliases:
-            new = _rule_aliases[lower]
-            warnings.warn(_LEGACY_FREQ_WARNING.format(lower, new),
-                          FutureWarning, stacklevel=3)
-            freqstr = new
         freqstr = _lite_rule_alias.get(lower, freqstr)
 
+    if freqstr not in _dont_uppercase:
+        freqstr = freqstr.upper()
     try:
-        if freqstr not in _dont_uppercase:
-            freqstr = freqstr.upper()
         return _period_code_map[freqstr]
     except KeyError:
-        try:
-            alias = _period_alias_dict[freqstr]
-            warnings.warn(_LEGACY_FREQ_WARNING.format(freqstr, alias),
-                          FutureWarning, stacklevel=3)
-        except KeyError:
-            raise ValueError("Unknown freqstr: %s" % freqstr)
-
-        return _period_code_map[alias]
+        raise ValueError(_INVALID_FREQ_ERROR.format(freqstr))
 
 
 def infer_freq(index, warn=True):
diff --git a/pandas/tseries/tests/test_base.py b/pandas/tseries/tests/test_base.py
index 958a10c32..6c9962853 100644
--- a/pandas/tseries/tests/test_base.py
+++ b/pandas/tseries/tests/test_base.py
@@ -160,9 +160,11 @@ class TestDatetimeIndexOps(Ops):
             tm.assert_index_equal(rng.round(freq='H'), expected_rng)
             self.assertEqual(elt.round(freq='H'), expected_elt)
 
-            msg = "Could not evaluate foo"
-            tm.assertRaisesRegexp(ValueError, msg, rng.round, freq='foo')
-            tm.assertRaisesRegexp(ValueError, msg, elt.round, freq='foo')
+            msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+            with tm.assertRaisesRegexp(ValueError, msg):
+                rng.round(freq='foo')
+            with tm.assertRaisesRegexp(ValueError, msg):
+                elt.round(freq='foo')
 
             msg = "<MonthEnd> is a non-fixed frequency"
             tm.assertRaisesRegexp(ValueError, msg, rng.round, freq='M')
@@ -847,9 +849,11 @@ class TestTimedeltaIndexOps(Ops):
         tm.assert_index_equal(td.round(freq='H'), expected_rng)
         self.assertEqual(elt.round(freq='H'), expected_elt)
 
-        msg = "Could not evaluate foo"
-        tm.assertRaisesRegexp(ValueError, msg, td.round, freq='foo')
-        tm.assertRaisesRegexp(ValueError, msg, elt.round, freq='foo')
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            td.round(freq='foo')
+        with tm.assertRaisesRegexp(ValueError, msg):
+            elt.round(freq='foo')
 
         msg = "<MonthEnd> is a non-fixed frequency"
         tm.assertRaisesRegexp(ValueError, msg, td.round, freq='M')
diff --git a/pandas/tseries/tests/test_frequencies.py b/pandas/tseries/tests/test_frequencies.py
index 1f06b7ad4..268933fad 100644
--- a/pandas/tseries/tests/test_frequencies.py
+++ b/pandas/tseries/tests/test_frequencies.py
@@ -245,10 +245,10 @@ def test_period_str_to_code():
         assert isinstance(aliases, list)
         assert (frequencies._period_str_to_code(freq) == expected)
 
+        msg = frequencies._INVALID_FREQ_ERROR
         for alias in aliases:
-            with tm.assert_produces_warning(FutureWarning,
-                                            check_stacklevel=False):
-                assert (frequencies._period_str_to_code(alias) == expected)
+            with tm.assertRaisesRegexp(ValueError, msg):
+                frequencies._period_str_to_code(alias)
 
     _assert_depr("M", 3000, ["MTH", "MONTH", "MONTHLY"])
 
@@ -699,8 +699,9 @@ class TestFrequencyInference(tm.TestCase):
             s = Series(period_range('2013', periods=10, freq=freq))
             self.assertRaises(TypeError, lambda: frequencies.infer_freq(s))
         for freq in ['Y']:
-            with tm.assert_produces_warning(FutureWarning,
-                                            check_stacklevel=False):
+
+            msg = frequencies._INVALID_FREQ_ERROR
+            with tm.assertRaisesRegexp(ValueError, msg):
                 s = Series(period_range('2013', periods=10, freq=freq))
             self.assertRaises(TypeError, lambda: frequencies.infer_freq(s))
 
@@ -715,17 +716,23 @@ class TestFrequencyInference(tm.TestCase):
         self.assertEqual(inferred, 'D')
 
     def test_legacy_offset_warnings(self):
-        for k, v in compat.iteritems(frequencies._rule_aliases):
-            with tm.assert_produces_warning(FutureWarning):
-                result = frequencies.get_offset(k)
-            exp = frequencies.get_offset(v)
-            self.assertEqual(result, exp)
-
-            with tm.assert_produces_warning(FutureWarning,
-                                            check_stacklevel=False):
-                idx = date_range('2011-01-01', periods=5, freq=k)
-            exp = date_range('2011-01-01', periods=5, freq=v)
-            self.assert_index_equal(idx, exp)
+        freqs = ['WEEKDAY', 'EOM', 'W@MON', 'W@TUE', 'W@WED', 'W@THU',
+                 'W@FRI', 'W@SAT', 'W@SUN', 'Q@JAN', 'Q@FEB', 'Q@MAR',
+                 'A@JAN', 'A@FEB', 'A@MAR', 'A@APR', 'A@MAY', 'A@JUN',
+                 'A@JUL', 'A@AUG', 'A@SEP', 'A@OCT', 'A@NOV', 'A@DEC',
+                 'WOM@1MON', 'WOM@2MON', 'WOM@3MON', 'WOM@4MON',
+                 'WOM@1TUE', 'WOM@2TUE', 'WOM@3TUE', 'WOM@4TUE',
+                 'WOM@1WED', 'WOM@2WED', 'WOM@3WED', 'WOM@4WED',
+                 'WOM@1THU', 'WOM@2THU', 'WOM@3THU', 'WOM@4THU'
+                 'WOM@1FRI', 'WOM@2FRI', 'WOM@3FRI', 'WOM@4FRI']
+
+        msg = frequencies._INVALID_FREQ_ERROR
+        for freq in freqs:
+            with tm.assertRaisesRegexp(ValueError, msg):
+                frequencies.get_offset(freq)
+
+            with tm.assertRaisesRegexp(ValueError, msg):
+                date_range('2011-01-01', periods=5, freq=freq)
 
 
 MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT',
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index 5965a6616..b31e4d54c 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -23,7 +23,7 @@ from pandas.core.datetools import (bday, BDay, CDay, BQuarterEnd, BMonthEnd,
 
 from pandas.core.series import Series
 from pandas.tseries.frequencies import (_offset_map, get_freq_code,
-                                        _get_freq_str)
+                                        _get_freq_str, _INVALID_FREQ_ERROR)
 from pandas.tseries.index import _to_m8, DatetimeIndex, _daterange_cache
 from pandas.tseries.tools import parse_time_string, DateParseError
 import pandas.tseries.offsets as offsets
@@ -4531,8 +4531,11 @@ class TestOffsetNames(tm.TestCase):
 
 
 def test_get_offset():
-    assertRaisesRegexp(ValueError, "rule.*GIBBERISH", get_offset, 'gibberish')
-    assertRaisesRegexp(ValueError, "rule.*QS-JAN-B", get_offset, 'QS-JAN-B')
+    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+        get_offset('gibberish')
+    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+        get_offset('QS-JAN-B')
+
     pairs = [
         ('B', BDay()), ('b', BDay()), ('bm', BMonthEnd()),
         ('Bm', BMonthEnd()), ('W-MON', Week(weekday=0)),
@@ -4558,10 +4561,8 @@ def test_get_offset():
 def test_get_offset_legacy():
     pairs = [('w@Sat', Week(weekday=5))]
     for name, expected in pairs:
-        with tm.assert_produces_warning(FutureWarning):
-            offset = get_offset(name)
-        assert offset == expected, ("Expected %r to yield %r (actual: %r)" %
-                                    (name, expected, offset))
+        with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+            get_offset(name)
 
 
 class TestParseTimeString(tm.TestCase):
@@ -4595,16 +4596,14 @@ def test_get_standard_freq():
     assert fstr == get_standard_freq('1w')
     assert fstr == get_standard_freq(('W', 1))
 
-    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-        result = get_standard_freq('WeEk')
-    assert fstr == result
+    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+        get_standard_freq('WeEk')
 
     fstr = get_standard_freq('5Q')
     assert fstr == get_standard_freq('5q')
 
-    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-        result = get_standard_freq('5QuarTer')
-    assert fstr == result
+    with tm.assertRaisesRegexp(ValueError, _INVALID_FREQ_ERROR):
+        get_standard_freq('5QuarTer')
 
     assert fstr == get_standard_freq(('q', 5))
 
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 8d217ff07..c90cbbf80 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -451,13 +451,16 @@ class TestPeriodProperties(tm.TestCase):
                  "L": ["MILLISECOND", "MILLISECONDLY", "millisecond"],
                  "U": ["MICROSECOND", "MICROSECONDLY", "microsecond"],
                  "N": ["NANOSECOND", "NANOSECONDLY", "nanosecond"]}
+
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
         for exp, freqs in iteritems(cases):
             for freq in freqs:
+                with self.assertRaisesRegexp(ValueError, msg):
+                    Period('2016-03-01 09:00', freq=freq)
 
-                with tm.assert_produces_warning(FutureWarning,
-                                                check_stacklevel=False):
-                    res = pd.Period('2016-03-01 09:00', freq=freq)
-                self.assertEqual(res, Period('2016-03-01 09:00', freq=exp))
+                # check supported freq-aliases still works
+                p = Period('2016-03-01 09:00', freq=exp)
+                tm.assertIsInstance(p, Period)
 
     def test_repr(self):
         p = Period('Jan-2000')
@@ -659,19 +662,21 @@ class TestPeriodProperties(tm.TestCase):
 
     def test_properties_weekly_legacy(self):
         # Test properties on Periods with daily frequency.
-        with tm.assert_produces_warning(FutureWarning):
-            w_date = Period(freq='WK', year=2007, month=1, day=7)
-        #
+        w_date = Period(freq='W', year=2007, month=1, day=7)
         self.assertEqual(w_date.year, 2007)
         self.assertEqual(w_date.quarter, 1)
         self.assertEqual(w_date.month, 1)
         self.assertEqual(w_date.week, 1)
         self.assertEqual((w_date - 1).week, 52)
         self.assertEqual(w_date.days_in_month, 31)
-        with tm.assert_produces_warning(FutureWarning):
-            exp = Period(freq='WK', year=2012, month=2, day=1)
+
+        exp = Period(freq='W', year=2012, month=2, day=1)
         self.assertEqual(exp.days_in_month, 29)
 
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK', year=2007, month=1, day=7)
+
     def test_properties_daily(self):
         # Test properties on Periods with daily frequency.
         b_date = Period(freq='B', year=2007, month=1, day=1)
@@ -819,10 +824,11 @@ class TestPeriodProperties(tm.TestCase):
         self.assertEqual(initial.asfreq(freq="M", how="S"),
                          Period('2013-01', 'M'))
 
-        with self.assertRaisesRegexp(ValueError, "Unknown freqstr"):
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
             initial.asfreq(freq="MS", how="S")
 
-        with tm.assertRaisesRegexp(ValueError, "Unknown freqstr: MS"):
+        with tm.assertRaisesRegexp(ValueError, msg):
             pd.Period('2013-01', 'MS')
 
         self.assertTrue(_period_code_map.get("MS") is None)
@@ -1122,123 +1128,28 @@ class TestFreqConversion(tm.TestCase):
 
         self.assertEqual(ival_W.asfreq('W'), ival_W)
 
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            ival_W.asfreq('WK')
+
     def test_conv_weekly_legacy(self):
         # frequency conversion tests: from Weekly Frequency
-
-        with tm.assert_produces_warning(FutureWarning):
-            ival_W = Period(freq='WK', year=2007, month=1, day=1)
-
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WSUN = Period(freq='WK', year=2007, month=1, day=7)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WSAT = Period(freq='WK-SAT', year=2007, month=1, day=6)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WFRI = Period(freq='WK-FRI', year=2007, month=1, day=5)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WTHU = Period(freq='WK-THU', year=2007, month=1, day=4)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WWED = Period(freq='WK-WED', year=2007, month=1, day=3)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WTUE = Period(freq='WK-TUE', year=2007, month=1, day=2)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_WMON = Period(freq='WK-MON', year=2007, month=1, day=1)
-
-        ival_WSUN_to_D_start = Period(freq='D', year=2007, month=1, day=1)
-        ival_WSUN_to_D_end = Period(freq='D', year=2007, month=1, day=7)
-        ival_WSAT_to_D_start = Period(freq='D', year=2006, month=12, day=31)
-        ival_WSAT_to_D_end = Period(freq='D', year=2007, month=1, day=6)
-        ival_WFRI_to_D_start = Period(freq='D', year=2006, month=12, day=30)
-        ival_WFRI_to_D_end = Period(freq='D', year=2007, month=1, day=5)
-        ival_WTHU_to_D_start = Period(freq='D', year=2006, month=12, day=29)
-        ival_WTHU_to_D_end = Period(freq='D', year=2007, month=1, day=4)
-        ival_WWED_to_D_start = Period(freq='D', year=2006, month=12, day=28)
-        ival_WWED_to_D_end = Period(freq='D', year=2007, month=1, day=3)
-        ival_WTUE_to_D_start = Period(freq='D', year=2006, month=12, day=27)
-        ival_WTUE_to_D_end = Period(freq='D', year=2007, month=1, day=2)
-        ival_WMON_to_D_start = Period(freq='D', year=2006, month=12, day=26)
-        ival_WMON_to_D_end = Period(freq='D', year=2007, month=1, day=1)
-
-        with tm.assert_produces_warning(FutureWarning):
-            ival_W_end_of_year = Period(freq='WK', year=2007, month=12, day=31)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_W_end_of_quarter = Period(freq='WK', year=2007, month=3,
-                                           day=31)
-        with tm.assert_produces_warning(FutureWarning):
-            ival_W_end_of_month = Period(freq='WK', year=2007, month=1, day=31)
-        ival_W_to_A = Period(freq='A', year=2007)
-        ival_W_to_Q = Period(freq='Q', year=2007, quarter=1)
-        ival_W_to_M = Period(freq='M', year=2007, month=1)
-
-        if Period(freq='D', year=2007, month=12, day=31).weekday == 6:
-            ival_W_to_A_end_of_year = Period(freq='A', year=2007)
-        else:
-            ival_W_to_A_end_of_year = Period(freq='A', year=2008)
-
-        if Period(freq='D', year=2007, month=3, day=31).weekday == 6:
-            ival_W_to_Q_end_of_quarter = Period(freq='Q', year=2007, quarter=1)
-        else:
-            ival_W_to_Q_end_of_quarter = Period(freq='Q', year=2007, quarter=2)
-
-        if Period(freq='D', year=2007, month=1, day=31).weekday == 6:
-            ival_W_to_M_end_of_month = Period(freq='M', year=2007, month=1)
-        else:
-            ival_W_to_M_end_of_month = Period(freq='M', year=2007, month=2)
-
-        ival_W_to_B_start = Period(freq='B', year=2007, month=1, day=1)
-        ival_W_to_B_end = Period(freq='B', year=2007, month=1, day=5)
-        ival_W_to_D_start = Period(freq='D', year=2007, month=1, day=1)
-        ival_W_to_D_end = Period(freq='D', year=2007, month=1, day=7)
-        ival_W_to_H_start = Period(freq='H', year=2007, month=1, day=1, hour=0)
-        ival_W_to_H_end = Period(freq='H', year=2007, month=1, day=7, hour=23)
-        ival_W_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
-                                   hour=0, minute=0)
-        ival_W_to_T_end = Period(freq='Min', year=2007, month=1, day=7,
-                                 hour=23, minute=59)
-        ival_W_to_S_start = Period(freq='S', year=2007, month=1, day=1, hour=0,
-                                   minute=0, second=0)
-        ival_W_to_S_end = Period(freq='S', year=2007, month=1, day=7, hour=23,
-                                 minute=59, second=59)
-
-        self.assertEqual(ival_W.asfreq('A'), ival_W_to_A)
-        self.assertEqual(ival_W_end_of_year.asfreq('A'),
-                         ival_W_to_A_end_of_year)
-        self.assertEqual(ival_W.asfreq('Q'), ival_W_to_Q)
-        self.assertEqual(ival_W_end_of_quarter.asfreq('Q'),
-                         ival_W_to_Q_end_of_quarter)
-        self.assertEqual(ival_W.asfreq('M'), ival_W_to_M)
-        self.assertEqual(ival_W_end_of_month.asfreq('M'),
-                         ival_W_to_M_end_of_month)
-
-        self.assertEqual(ival_W.asfreq('B', 'S'), ival_W_to_B_start)
-        self.assertEqual(ival_W.asfreq('B', 'E'), ival_W_to_B_end)
-
-        self.assertEqual(ival_W.asfreq('D', 'S'), ival_W_to_D_start)
-        self.assertEqual(ival_W.asfreq('D', 'E'), ival_W_to_D_end)
-
-        self.assertEqual(ival_WSUN.asfreq('D', 'S'), ival_WSUN_to_D_start)
-        self.assertEqual(ival_WSUN.asfreq('D', 'E'), ival_WSUN_to_D_end)
-        self.assertEqual(ival_WSAT.asfreq('D', 'S'), ival_WSAT_to_D_start)
-        self.assertEqual(ival_WSAT.asfreq('D', 'E'), ival_WSAT_to_D_end)
-        self.assertEqual(ival_WFRI.asfreq('D', 'S'), ival_WFRI_to_D_start)
-        self.assertEqual(ival_WFRI.asfreq('D', 'E'), ival_WFRI_to_D_end)
-        self.assertEqual(ival_WTHU.asfreq('D', 'S'), ival_WTHU_to_D_start)
-        self.assertEqual(ival_WTHU.asfreq('D', 'E'), ival_WTHU_to_D_end)
-        self.assertEqual(ival_WWED.asfreq('D', 'S'), ival_WWED_to_D_start)
-        self.assertEqual(ival_WWED.asfreq('D', 'E'), ival_WWED_to_D_end)
-        self.assertEqual(ival_WTUE.asfreq('D', 'S'), ival_WTUE_to_D_start)
-        self.assertEqual(ival_WTUE.asfreq('D', 'E'), ival_WTUE_to_D_end)
-        self.assertEqual(ival_WMON.asfreq('D', 'S'), ival_WMON_to_D_start)
-        self.assertEqual(ival_WMON.asfreq('D', 'E'), ival_WMON_to_D_end)
-
-        self.assertEqual(ival_W.asfreq('H', 'S'), ival_W_to_H_start)
-        self.assertEqual(ival_W.asfreq('H', 'E'), ival_W_to_H_end)
-        self.assertEqual(ival_W.asfreq('Min', 'S'), ival_W_to_T_start)
-        self.assertEqual(ival_W.asfreq('Min', 'E'), ival_W_to_T_end)
-        self.assertEqual(ival_W.asfreq('S', 'S'), ival_W_to_S_start)
-        self.assertEqual(ival_W.asfreq('S', 'E'), ival_W_to_S_end)
-
-        with tm.assert_produces_warning(FutureWarning):
-            self.assertEqual(ival_W.asfreq('WK'), ival_W)
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK', year=2007, month=1, day=1)
+
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-SAT', year=2007, month=1, day=6)
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-FRI', year=2007, month=1, day=5)
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-THU', year=2007, month=1, day=4)
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-WED', year=2007, month=1, day=3)
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-TUE', year=2007, month=1, day=2)
+        with self.assertRaisesRegexp(ValueError, msg):
+            Period(freq='WK-MON', year=2007, month=1, day=1)
 
     def test_conv_business(self):
         # frequency conversion tests: from Business Frequency"
@@ -2894,11 +2805,14 @@ class TestPeriodIndex(tm.TestCase):
             prng = rng.to_period()
             self.assertEqual(prng.freq, 'M')
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            rng = date_range('01-Jan-2012', periods=8, freq='EOM')
+        rng = date_range('01-Jan-2012', periods=8, freq='M')
         prng = rng.to_period()
         self.assertEqual(prng.freq, 'M')
 
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            date_range('01-Jan-2012', periods=8, freq='EOM')
+
     def test_multiples(self):
         result1 = Period('1989', freq='2A')
         result2 = Period('1989', freq='A')
diff --git a/pandas/tseries/tests/test_tslib.py b/pandas/tseries/tests/test_tslib.py
index 6696c03a0..f30f01e66 100644
--- a/pandas/tseries/tests/test_tslib.py
+++ b/pandas/tseries/tests/test_tslib.py
@@ -1422,16 +1422,14 @@ class TestTslib(tm.TestCase):
             result = stamp.round(freq=freq)
             self.assertEqual(result, expected)
 
-        for freq, expected in [
-            ('D', Timestamp('2000-01-05 00:00:00')),
-            ('H', Timestamp('2000-01-05 05:00:00')),
-            ('S', Timestamp('2000-01-05 05:09:15'))
-        ]:
+        for freq, expected in [('D', Timestamp('2000-01-05 00:00:00')),
+                               ('H', Timestamp('2000-01-05 05:00:00')),
+                               ('S', Timestamp('2000-01-05 05:09:15'))]:
             _check_round(freq, expected)
 
-        msg = "Could not evaluate"
-        tm.assertRaisesRegexp(ValueError, msg,
-                              stamp.round, 'foo')
+        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            stamp.round('foo')
 
 
 class TestTimestampOps(tm.TestCase):

commit af77e0e4a107493774212387fdd2edb8562d28a9
Author: jreback <jeff@reback.net>
Date:   Mon Jun 3 12:08:26 2013 -0400

    BUG: ensure float into function of series transform when item-by-item
    
         downcast result if needed

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 2032f2303..64606a6e6 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1534,6 +1534,7 @@ class SeriesGroupBy(GroupBy):
         result = self.obj.copy()
         if hasattr(result,'values'):
             result = result.values
+        dtype = result.dtype
 
         if isinstance(func, basestring):
             wrapper = lambda x: getattr(x, func)(*args, **kwargs)
@@ -1541,6 +1542,8 @@ class SeriesGroupBy(GroupBy):
             wrapper = lambda x: func(x, *args, **kwargs)
 
         for name, group in self:
+
+            group = com.ensure_float(group)
             object.__setattr__(group, 'name', name)
             res = wrapper(group)
             indexer = self.obj.index.get_indexer(group.index)
@@ -1551,6 +1554,8 @@ class SeriesGroupBy(GroupBy):
             # this needs to be an ndarray
             result,_ = com._maybe_upcast_indexer(result, indexer, res)
 
+        # downcast if we can (and need)
+        result = _possibly_downcast_to_dtype(result, dtype)
         return self.obj.__class__(result,index=self.obj.index,name=self.obj.name)
 
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 852f01090..cf62b16a9 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -620,11 +620,35 @@ class TestGroupBy(unittest.TestCase):
 
         # GH 3740, make sure that we might upcast on item-by-item transform
 
+        # floats
+        df = DataFrame(dict(A = [1,1,1,2,2,2], B = Series(1,dtype='float64'), C = Series([1,2,3,1,2,3],dtype='float64'), D = 'foo'))
+        result = df.groupby('A').transform(lambda x: (x-x.mean())/x.std())
+        expected = DataFrame(dict(B = np.nan, C = Series([-1,0,1,-1,0,1],dtype='float64')))
+        assert_frame_equal(result,expected)
+
+        # int case
         df = DataFrame(dict(A = [1,1,1,2,2,2], B = 1, C = [1,2,3,1,2,3], D = 'foo'))
         result = df.groupby('A').transform(lambda x: (x-x.mean())/x.std())
         expected = DataFrame(dict(B = np.nan, C = [-1,0,1,-1,0,1]))
         assert_frame_equal(result,expected)
 
+        # int that needs float conversion
+        s = Series([2,3,4,10,5,-1])
+        df = DataFrame(dict(A = [1,1,1,2,2,2], B = 1, C = s, D = 'foo'))
+        result = df.groupby('A').transform(lambda x: (x-x.mean())/x.std())
+
+        s1 = s.iloc[0:3]
+        s1 = (s1-s1.mean())/s1.std()
+        s2 = s.iloc[3:6]
+        s2 = (s2-s2.mean())/s2.std()
+        expected = DataFrame(dict(B = np.nan, C = concat([s1,s2])))
+        assert_frame_equal(result,expected)
+
+        # int downcasting
+        result = df.groupby('A').transform(lambda x: x*2/2)
+        expected = DataFrame(dict(B = 1, C = [2,3,4,10,5,-1]))
+        assert_frame_equal(result,expected)
+
     def test_indices_concatenation_order(self):
 
         # GH 2808

commit 0b4fdf988e3125f7c55aaf6e08a2dfa7d9e2e8a0
Author: Brian McFee <brian.mcfee@nyu.edu>
Date:   Mon Feb 20 14:12:28 2017 -0500

    ENH: Add __copy__ and __deepcopy__ to NDFrame
    
    closes #15370
    
    Author: Brian McFee <brian.mcfee@nyu.edu>
    Author: Jeff Reback <jeff@reback.net>
    
    Closes #15444 from bmcfee/deepcopy-ndframe and squashes the following commits:
    
    bf36f35 [Jeff Reback] TST: skip the panel4d deepcopy tests
    d58b1f6 [Brian McFee] added tests for copy and deepcopy
    35f3e0f [Brian McFee] relocated Index.__deepcopy__ to live near __copy__
    1aea940 [Brian McFee] switched deepcopy test to using generic comparator
    7e67e7d [Brian McFee] ndframe and index __copy__ are now proper methods
    820664c [Brian McFee] moved deepcopy test to generic.py
    9721041 [Brian McFee] added copy/deepcopy to ndframe, fixes #15370

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 9e71b9a11..40b068547 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -433,6 +433,7 @@ Other API Changes
 - ``DataFrame.asof()`` will return a null filled ``Series`` instead the scalar ``NaN`` if a match is not found (:issue:`15118`)
 - The :func:`pd.read_gbq` method now stores ``INTEGER`` columns as ``dtype=object`` if they contain ``NULL`` values. Otherwise they are stored as ``int64``. This prevents precision lost for integers greather than 2**53. Furthermore ``FLOAT`` columns with values above 10**4 are no longer casted to ``int64`` which also caused precision loss (:issue:`14064`, :issue:`14305`).
 - Reorganization of timeseries development tests (:issue:`14854`)
+- Specific support for ``copy.copy()`` and ``copy.deepcopy()`` functions on NDFrame objects (:issue:`15444`)
 
 .. _whatsnew_0200.deprecations:
 
@@ -500,7 +501,7 @@ Bug Fixes
 - Bug in ``pd.read_csv()`` in which a file containing a row with many columns followed by rows with fewer columns would cause a crash (:issue:`14125`)
 - Bug in ``pd.tools.hashing.hash_pandas_object()`` in which hashing of categoricals depended on the ordering of categories, instead of just their values. (:issue:`15143`)
 - Bug in ``.groupby(..).resample()`` when passed the ``on=`` kwarg. (:issue:`15021`)
-
+- Bug in using ``__deepcopy__`` on empty NDFrame objects (:issue:`15370`)
 - Bug in ``DataFrame.loc`` with indexing a ``MultiIndex`` with a ``Series`` indexer (:issue:`14730`, :issue:`15424`)
 - Bug in ``DataFrame.loc`` with indexing a ``MultiIndex`` with a numpy array (:issue:`15434`)
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 26b9a880d..76fbb9884 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -3161,6 +3161,14 @@ class NDFrame(PandasObject):
         data = self._data.copy(deep=deep)
         return self._constructor(data).__finalize__(self)
 
+    def __copy__(self, deep=True):
+        return self.copy(deep=deep)
+
+    def __deepcopy__(self, memo=None):
+        if memo is None:
+            memo = {}
+        return self.copy(deep=True)
+
     def _convert(self, datetime=False, numeric=False, timedelta=False,
                  coerce=False, copy=True):
         """
diff --git a/pandas/indexes/base.py b/pandas/indexes/base.py
index e51824e72..f1f37622b 100644
--- a/pandas/indexes/base.py
+++ b/pandas/indexes/base.py
@@ -724,7 +724,13 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
             new_index = new_index.astype(dtype)
         return new_index
 
-    __copy__ = copy
+    def __copy__(self, **kwargs):
+        return self.copy(**kwargs)
+
+    def __deepcopy__(self, memo=None):
+        if memo is None:
+            memo = {}
+        return self.copy(deep=True)
 
     def _validate_names(self, name=None, names=None, deep=False):
         """
@@ -1480,11 +1486,6 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
 
     _unpickle_compat = __setstate__
 
-    def __deepcopy__(self, memo=None):
-        if memo is None:
-            memo = {}
-        return self.copy(deep=True)
-
     def __nonzero__(self):
         raise ValueError("The truth value of a {0} is ambiguous. "
                          "Use a.empty, a.bool(), a.item(), a.any() or a.all()."
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index b087ca21d..40cdbe083 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -2,6 +2,7 @@
 # pylint: disable-msg=E1101,W0612
 
 from operator import methodcaller
+from copy import copy, deepcopy
 import pytest
 import numpy as np
 from numpy import nan
@@ -675,6 +676,18 @@ class Generic(object):
             with self.assertRaises(ValueError):
                 super(DataFrame, df).mask(cond=df.a > 2, inplace=value)
 
+    def test_copy_and_deepcopy(self):
+        # GH 15444
+        for shape in [0, 1, 2]:
+            obj = self._construct(shape)
+            for func in [copy,
+                         deepcopy,
+                         lambda x: x.copy(deep=False),
+                         lambda x: x.copy(deep=True)]:
+                obj_copy = func(obj)
+                self.assertIsNot(obj_copy, obj)
+                self._compare(obj_copy, obj)
+
 
 class TestSeries(tm.TestCase, Generic):
     _typ = Series
@@ -1539,6 +1552,14 @@ class TestDataFrame(tm.TestCase, Generic):
                            expected,
                            check_index_type=False)
 
+    def test_deepcopy_empty(self):
+        # This test covers empty frame copying with non-empty column sets
+        # as reported in issue GH15370
+        empty_frame = DataFrame(data=[], index=[], columns=['A'])
+        empty_frame_copy = deepcopy(empty_frame)
+
+        self._compare(empty_frame_copy, empty_frame)
+
 
 class TestPanel(tm.TestCase, Generic):
     _typ = Panel
@@ -1569,6 +1590,9 @@ class TestPanel4D(tm.TestCase, Generic):
     def test_sample(self):
         pytest.skip("sample on Panel4D")
 
+    def test_copy_and_deepcopy(self):
+        pytest.skip("copy_and_deepcopy on Panel4D")
+
     def test_to_xarray(self):
 
         tm._skip_if_no_xarray()

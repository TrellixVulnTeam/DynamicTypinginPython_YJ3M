commit 098ce7344ea1755e965855c5c44633ff39195a9c
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Jan 23 16:28:54 2012 -0500

    ENH: added additional datetime support, backporting some numpy 1.7 code

diff --git a/.gitignore b/.gitignore
index 0b2aa6586..84bcf6f93 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,7 +5,8 @@ build
 dist
 MANIFEST
 *.c
-!datetime_helper.c
+!np_datetime.c
+!np_datetime_strings.c
 *.cpp
 *.so
 *.pyd
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index a4d6f09a2..ead30f30a 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -4,6 +4,7 @@ from datetime import datetime, timedelta
 import sys
 import numpy as np
 import pandas._tseries as lib
+import pandas._datetime as dtlib
 
 try:
     import dateutil
@@ -24,28 +25,26 @@ import calendar
 #-------------------------------------------------------------------------------
 # Boxing and unboxing
 
-# TODO: fix to use new Date boxing logic
-
 _unbox_cache = dict()
 def _dt_unbox(key):
     '''
-    Unbox datetime to datetime64
+    Unbox python datetime to datetime64
     '''
     try:
         return _unbox_cache[key]
     except KeyError:
-        _unbox_cache[key] = np.datetime64(key)
+        _unbox_cache[key] = np.datetime64(dtlib.pydt_to_i8(key))
         return _unbox_cache[key]
 
 _box_cache = dict()
 def _dt_box(key):
     '''
-    Box datetime64 to datetime
+    Box datetime64 to python datetime
     '''
     try:
         return _box_cache[key]
     except KeyError:
-        _box_cache[key] = key.astype('O')
+        _box_cache[key] = dtlib.i8_to_pydt(key.view('i8'))
         return _box_cache[key]
 
 #-------------------------------------------------------------------------------
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 5245778c1..6173bdbc6 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -22,6 +22,8 @@ cdef extern from "datetime.h":
     int PyDateTime_TIME_GET_MICROSECOND(datetime o)
     bint PyDateTime_Check(object o)
     void PyDateTime_IMPORT()
+    PyObject *PyDateTime_FromDateAndTime(int year, int month, int day, int hour,
+                                         int minute, int second, int us)
 
 cdef extern from "numpy/ndarrayobject.h":
 
@@ -55,8 +57,10 @@ cdef extern from "numpy/ndarrayobject.h":
                                           NPY_DATETIMEUNIT fr,
                                           npy_datetimestruct *result)
 
-cdef extern from "datetime_helper.h":
+cdef extern from "np_datetime.h":
 
     int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
                                              NPY_DATETIMEUNIT *out_bestunit,
                                              int apply_tzinfo)
+
+    int is_leapyear(int64_t year)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 807d96e17..fde944e97 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1,9 +1,8 @@
 cimport numpy as np
-cimport cython
-cimport cpython
 import numpy as np
 
 from numpy cimport int32_t, int64_t, import_array, ndarray
+from cpython cimport *
 
 # this is our datetime.pxd
 from datetime cimport *
@@ -14,33 +13,43 @@ PyDateTime_IMPORT
 # initialize numpy
 import_array()
 
-# in numpy 1.7, will prop need this
+# in numpy 1.7, will prob need this
 # numpy_pydatetime_import
 
-cdef class Date:
+# Objects to support date/time arithmetic, inspired by the architecture of the
+# lubridate R package, to eventually replace most of pandas/core/datetools.py
+# --------------------------------------------------------------------------------
+
+cdef class Instant:
     '''
-    This is the custom pandas Date box for the numpy datetime64 dtype.
+    A timestamp (absolute moment in time) to microsecond resolution, in UTC.
     '''
     cdef:
         int64_t timestamp
-        object freq
-        object tzinfo
         npy_datetimestruct dts
 
-    def __init__(self, int64_t ts, object freq = None, object tzinfo = None):
+    def __init__(self, int64_t ts):
         self.timestamp = ts
-        self.freq = freq
-        self.tzinfo = tzinfo
 
-        # datetime64 decomposition to components
-        PyArray_DatetimeToDatetimeStruct(self.timestamp, NPY_FR_us, &self.dts)
+        # decompose datetime64 to components
+        PyArray_DatetimeToDatetimeStruct(ts, NPY_FR_us, &self.dts)
+
+    def __sub__(self, object other):
+        if isinstance(other, Instant):
+            if other.timestamp > self.timestamp:
+                return Interval(self.timestamp, other.timestamp)
+            else:
+                return Interval(other.timestamp, self.timestamp)
 
-    # TODO: we'll probably need factory methods to construct this box from:
-    #       -- datetime64 scalar python object
-    #       -- datetime python object
-    #       -- int64_t
+    def __add__(self, object other):
+        if isinstance(other, Interval):
+            return Instant(self.timestamp + other.dur.length)
+        elif isinstance(other, Duration):
+            return Instant(self.timestamp + other.length)
 
-    # --- the following properties to make it compatible with datetime
+    property timestamp:
+        def __get__(self):
+            return self.timestamp
 
     property year:
         def __get__(self):
@@ -58,30 +67,234 @@ cdef class Date:
         def __get__(self):
             return self.dts.hour
 
-    property minute:
+    property min:
         def __get__(self):
             return self.dts.min
 
-    property second:
+    property sec:
         def __get__(self):
             return self.dts.sec
 
-    property microsecond:
+    property ms:
+        def __get__(self):
+            return self.dts.us / 1000.
+
+    property us:
         def __get__(self):
             return self.dts.us
 
-cdef:
-    npy_datetimestruct g_dts
-    NPY_DATETIMEUNIT g_out_bestunit
+cdef class Interval:
+    '''
+    An absolute time span, from one instant to another
+    '''
+    cdef:
+        int64_t start
+        int64_t end
+
+    def __init__(self, int64_t start, int64_t end):
+        self.start = start
+        self.end = end
+
+    property start:
+        def __get__(self):
+            return self.start
+
+    property end:
+        def __get__(self):
+            return self.end
+
+    property dur:
+        def __get__(self):
+            return Duration(self.end - self.start)
+
+cdef class Duration:
+    '''
+    Absolute length of time, in microseconds
+    '''
+    cdef int64_t length
+
+    def __init__(self, int64_t length = 1):
+        self.length = length
+
+    def __str__(self):
+        return "Duration (%d)" % self.length
+
+    property us:
+        def __get__(self):
+            return self.length
+
+    property ms:
+        def __get__(self):
+            return self.length / 1000.
+
+    property secs:
+        def __get__(self):
+            return self.length / 1000000.
+
+cdef class Period:
+    '''
+    Relative length of time
+    '''
+    cdef:
+        npy_datetimestruct dts
+        int isbiz
+
+    def __init__(self, int years = 0, int months = 0, int days = 0,
+                       int hours = 0, int mins = 0, int secs = 0):
+        self.dts.year = years
+        self.dts.month = months
+        self.dts.day = days
+        self.dts.hour = hours
+        self.dts.min = mins
+        self.dts.sec = secs
+
+    def __add__(self, other):
+        if issubclass(other, Period):
+            return Period(years = self.years + other.years,
+                          months = self.months + other.months,
+                          days = self.days + other.days,
+                          hours = self.hours + other.hours,
+                          mins = self.mins + other.mins,
+                          secs = self.secs + other.secs)
+        raise ValueError("Could not add operand to Period")
+
+    def __str__(self):
+        strbuf = ""
+        if self.dts.year > 0:
+            strbuf += "%d " % self.dts.year
+            strbuf += "year"
+            if self.dts.year > 1:
+                strbuf += "s"
+        if self.dts.month > 0:
+            if len(strbuf):
+                strbuf += ", "
+            strbuf += "%d " % self.dts.month
+            strbuf += "month"
+            if self.dts.month > 1:
+                strbuf += "s"
+        if self.dts.day > 0:
+            if len(strbuf):
+                strbuf += ", "
+            strbuf += "%d " % self.dts.day
+            strbuf += "day"
+            if self.dts.day > 1:
+                strbuf += "s"
+        if self.dts.hour > 0:
+            if len(strbuf):
+                strbuf += ", "
+            strbuf += "%d " % self.dts.hour
+            strbuf += "hour"
+            if self.dts.hour > 1:
+                strbuf += "s"
+        if self.dts.min > 0:
+            if len(strbuf):
+                strbuf += ", "
+            strbuf += "%d " % self.dts.min
+            strbuf += "min"
+            if self.dts.min > 1:
+                strbuf += "s"
+        if self.dts.sec > 0:
+            if len(strbuf):
+                strbuf += ", "
+            strbuf += "%d " % self.dts.sec
+            strbuf += "sec"
+            if self.dts.sec > 1:
+                strbuf += "s"
+
+        return "Period: %s" % strbuf
+
+    property years:
+        def __get__(self):
+            return self.dts.year
+    property months:
+        def __get__(self):
+            return self.dts.month
+    property days:
+        def __get__(self):
+            return self.dts.day
+    property hours:
+        def __get__(self):
+            return self.dts.hour
+    property mins:
+        def __get__(self):
+            return self.dts.min
+    property secs:
+        def __get__(self):
+            return self.dts.sec
+
+def seconds(int count):
+    return Period(secs = count)
+
+def minutes(int count):
+    return Period(mins = count)
+
+def hours(int count):
+    return Period(hours = count)
+
+def days(int count):
+    return Period(days = count)
+
+# TODO: fixme
+def bdays(int count):
+    return Period(days = count)
+
+def weeks(int count):
+    return Period(days = 7 * count)
+
+def months(int count):
+    return Period(months = count)
+
+def quarters(int count):
+    return Period(months = 3 * count)
+
+def years(int count):
+    return Period(years = count)
+
+# Conversion routines
+# ------------------------------------------------------------------------------
+
+def pydt_to_i8(object pydt):
+    '''
+    Convert from python datetime object to int64 representation compatible with
+    numpy datetime64; converts to UTC
+    '''
+    cdef:
+        npy_datetimestruct dts
+        NPY_DATETIMEUNIT out_bestunit
 
-def pydt_to_dt64(object pydt):
     if PyDateTime_Check(pydt):
-        convert_pydatetime_to_datetimestruct(<PyObject *>pydt, &g_dts, &g_out_bestunit, 1)
-        return PyArray_DatetimeStructToDatetime(g_out_bestunit, &g_dts)
+        # TODO: this function can prob be optimized
+        convert_pydatetime_to_datetimestruct(<PyObject *>pydt, &dts,
+                                             &out_bestunit, 1)
+
+        return PyArray_DatetimeStructToDatetime(out_bestunit, &dts)
 
     raise ValueError("Expected a datetime, received a %s" % type(pydt))
 
+def i8_to_pydt(int64_t i8, object tzinfo = None):
+    '''
+    Inverse of pydt_to_i8
+    '''
+    cdef:
+        npy_datetimestruct dts
+        object result
+
+    PyArray_DatetimeToDatetimeStruct(i8, NPY_FR_us, &dts)
+
+    result = <object>PyDateTime_FromDateAndTime(dts.year, dts.month, dts.day,
+                                                dts.hour, dts.min, dts.sec, dts.us)
+
+    return result
+
+
+# Accessors
+# ------------------------------------------------------------------------------
+
 def fast_field_accessor(ndarray[int64_t] dtindex, object field):
+    '''
+    Given a int64-based datetime index, extract the year, month, etc.,
+    field and return an array of these values.
+    '''
     cdef:
         npy_datetimestruct dts
         Py_ssize_t i, count = 0
@@ -97,16 +310,46 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
         return out
 
     elif field == 'M':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.month
+        return out
+
     elif field == 'D':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.day
+        return out
+
     elif field == 'h':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.hour
+        return out
+
     elif field == 'm':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.min
+        return out
+
     elif field == 's':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.sec
+        return out
+
     elif field == 'us':
-        pass
+        for i in range(count):
+            PyArray_DatetimeToDatetimeStruct(dtindex[i], NPY_FR_us, &dts)
+            out[i] = dts.us
+        return out
+
     else:
-        raise ValueError("Field %s not supported, must be Y,M,D,h,m,s,us" % field)
+        raise ValueError("Field %s not supported; not in (Y,M,D,h,m,s,us)" % field)
+
+# Some general helper functions we need
+# ------------------------------------------------------------------------------
+
+def isleapyear(int64_t year):
+    return is_leapyear(year)
diff --git a/pandas/src/datetime_helper.c b/pandas/src/datetime_helper.c
deleted file mode 100644
index baacf838a..000000000
--- a/pandas/src/datetime_helper.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * NB: This is derived from numpy 1.7 datetime.c, just enough code to
- * do what we need in numpy 1.6.
- */
-
-#include <Python.h>
-#include <datetime.h>
-
-#include <time.h>
-
-#include <numpy/arrayobject.h>
-#include "numpy/npy_3kcompat.h"
-
-#include "numpy/arrayscalars.h"
-#include "datetime_helper.h"
-
-/* Days per month, regular year and leap year */
-NPY_NO_EXPORT int _days_per_month_table[2][12] = {
-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
-};
-
-/*
- * Returns 1 if the given year is a leap year, 0 otherwise.
- */
-NPY_NO_EXPORT int
-is_leapyear(npy_int64 year)
-{
-    return (year & 0x3) == 0 && /* year % 4 == 0 */
-           ((year % 100) != 0 ||
-            (year % 400) == 0);
-}
-
-/*
- * Adjusts a datetimestruct based on a minutes offset. Assumes
- * the current values are valid.
- */
-NPY_NO_EXPORT void
-add_minutes_to_datetimestruct(npy_datetimestruct *dts, int minutes)
-{
-    int isleap;
-
-    /* MINUTES */
-    dts->min += minutes;
-    while (dts->min < 0) {
-        dts->min += 60;
-        dts->hour--;
-    }
-    while (dts->min >= 60) {
-        dts->min -= 60;
-        dts->hour++;
-    }
-
-    /* HOURS */
-    while (dts->hour < 0) {
-        dts->hour += 24;
-        dts->day--;
-    }
-    while (dts->hour >= 24) {
-        dts->hour -= 24;
-        dts->day++;
-    }
-
-    /* DAYS */
-    if (dts->day < 1) {
-        dts->month--;
-        if (dts->month < 1) {
-            dts->year--;
-            dts->month = 12;
-        }
-        isleap = is_leapyear(dts->year);
-        dts->day += _days_per_month_table[isleap][dts->month-1];
-    }
-    else if (dts->day > 28) {
-        isleap = is_leapyear(dts->year);
-        if (dts->day > _days_per_month_table[isleap][dts->month-1]) {
-            dts->day -= _days_per_month_table[isleap][dts->month-1];
-            dts->month++;
-            if (dts->month > 12) {
-                dts->year++;
-                dts->month = 1;
-            }
-        }
-    }
-}
-
-/*
- *
- * Tests for and converts a Python datetime.datetime or datetime.date
- * object into a NumPy npy_datetimestruct.
- *
- * While the C API has PyDate_* and PyDateTime_* functions, the following
- * implementation just asks for attributes, and thus supports
- * datetime duck typing. The tzinfo time zone conversion would require
- * this style of access anyway.
- *
- * 'out_bestunit' gives a suggested unit based on whether the object
- *      was a datetime.date or datetime.datetime object.
- *
- * If 'apply_tzinfo' is 1, this function uses the tzinfo to convert
- * to UTC time, otherwise it returns the struct with the local time.
- *
- * Returns -1 on error, 0 on success, and 1 (with no error set)
- * if obj doesn't have the neeeded date or datetime attributes.
- */
-int
-convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
-                                     NPY_DATETIMEUNIT *out_bestunit,
-                                     int apply_tzinfo)
-{
-    PyObject *tmp;
-    int isleap;
-
-    /* Initialize the output to all zeros */
-    memset(out, 0, sizeof(npy_datetimestruct));
-    out->month = 1;
-    out->day = 1;
-
-    /* Need at least year/month/day attributes */
-    if (!PyObject_HasAttrString(obj, "year") ||
-            !PyObject_HasAttrString(obj, "month") ||
-            !PyObject_HasAttrString(obj, "day")) {
-        return 1;
-    }
-
-    /* Get the year */
-    tmp = PyObject_GetAttrString(obj, "year");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->year = PyInt_AsLong(tmp);
-    if (out->year == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Get the month */
-    tmp = PyObject_GetAttrString(obj, "month");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->month = PyInt_AsLong(tmp);
-    if (out->month == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Get the day */
-    tmp = PyObject_GetAttrString(obj, "day");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->day = PyInt_AsLong(tmp);
-    if (out->day == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Validate that the month and day are valid for the year */
-    if (out->month < 1 || out->month > 12) {
-        goto invalid_date;
-    }
-    isleap = is_leapyear(out->year);
-    if (out->day < 1 ||
-                out->day > _days_per_month_table[isleap][out->month-1]) {
-        goto invalid_date;
-    }
-
-    /* Check for time attributes (if not there, return success as a date) */
-    if (!PyObject_HasAttrString(obj, "hour") ||
-            !PyObject_HasAttrString(obj, "minute") ||
-            !PyObject_HasAttrString(obj, "second") ||
-            !PyObject_HasAttrString(obj, "microsecond")) {
-        /* The best unit for date is 'D' */
-        if (out_bestunit != NULL) {
-            *out_bestunit = NPY_FR_D;
-        }
-        return 0;
-    }
-
-    /* Get the hour */
-    tmp = PyObject_GetAttrString(obj, "hour");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->hour = PyInt_AsLong(tmp);
-    if (out->hour == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Get the minute */
-    tmp = PyObject_GetAttrString(obj, "minute");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->min = PyInt_AsLong(tmp);
-    if (out->min == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Get the second */
-    tmp = PyObject_GetAttrString(obj, "second");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->sec = PyInt_AsLong(tmp);
-    if (out->sec == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    /* Get the microsecond */
-    tmp = PyObject_GetAttrString(obj, "microsecond");
-    if (tmp == NULL) {
-        return -1;
-    }
-    out->us = PyInt_AsLong(tmp);
-    if (out->us == -1 && PyErr_Occurred()) {
-        Py_DECREF(tmp);
-        return -1;
-    }
-    Py_DECREF(tmp);
-
-    if (out->hour < 0 || out->hour >= 24 ||
-            out->min < 0 || out->min >= 60 ||
-            out->sec < 0 || out->sec >= 60 ||
-            out->us < 0 || out->us >= 1000000) {
-        goto invalid_time;
-    }
-
-    /* Apply the time zone offset if it exists */
-    if (apply_tzinfo && PyObject_HasAttrString(obj, "tzinfo")) {
-        tmp = PyObject_GetAttrString(obj, "tzinfo");
-        if (tmp == NULL) {
-            return -1;
-        }
-        if (tmp == Py_None) {
-            Py_DECREF(tmp);
-        }
-        else {
-            PyObject *offset;
-            int seconds_offset, minutes_offset;
-
-            /* The utcoffset function should return a timedelta */
-            offset = PyObject_CallMethod(tmp, "utcoffset", "O", obj);
-            if (offset == NULL) {
-                Py_DECREF(tmp);
-                return -1;
-            }
-            Py_DECREF(tmp);
-
-            /*
-             * The timedelta should have a function "total_seconds"
-             * which contains the value we want.
-             */
-            tmp = PyObject_CallMethod(offset, "total_seconds", "");
-            if (tmp == NULL) {
-                return -1;
-            }
-            seconds_offset = PyInt_AsLong(tmp);
-            if (seconds_offset == -1 && PyErr_Occurred()) {
-                Py_DECREF(tmp);
-                return -1;
-            }
-            Py_DECREF(tmp);
-
-            /* Convert to a minutes offset and apply it */
-            minutes_offset = seconds_offset / 60;
-
-            add_minutes_to_datetimestruct(out, -minutes_offset);
-        }
-    }
-
-    /* The resolution of Python's datetime is 'us' */
-    if (out_bestunit != NULL) {
-        *out_bestunit = NPY_FR_us;
-    }
-
-    return 0;
-
-invalid_date:
-    PyErr_Format(PyExc_ValueError,
-            "Invalid date (%d,%d,%d) when converting to NumPy datetime",
-            (int)out->year, (int)out->month, (int)out->day);
-    return -1;
-
-invalid_time:
-    PyErr_Format(PyExc_ValueError,
-            "Invalid time (%d,%d,%d,%d) when converting "
-            "to NumPy datetime",
-            (int)out->hour, (int)out->min, (int)out->sec, (int)out->us);
-    return -1;
-}
diff --git a/pandas/src/datetime_helper.h b/pandas/src/datetime_helper.h
deleted file mode 100644
index f00b1ed05..000000000
--- a/pandas/src/datetime_helper.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
- * NB: This is derived from numpy 1.7 datetime.c, just enough code to
- * do some conversions. Copyrights from that file apply.
- */
-
-#ifndef _PANDAS_DATETIME_H_
-#define _PANDAS_DATETIME_H_
-
-int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
-                                         NPY_DATETIMEUNIT *out_bestunit,
-                                         int apply_tzinfo);
-
-#endif
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
new file mode 100644
index 000000000..ed1e81277
--- /dev/null
+++ b/pandas/src/np_datetime.c
@@ -0,0 +1,910 @@
+/*
+ * This is derived from Numpy 1.7
+ *
+ * See NP_LICENSE.txt
+ */
+
+#include <Python.h>
+#include <datetime.h>
+
+#include <time.h>
+
+#include <numpy/arrayobject.h>
+//#include "numpy/npy_3kcompat.h"
+
+#include "numpy/arrayscalars.h"
+#include "np_datetime.h"
+
+/* Days per month, regular year and leap year */
+int _days_per_month_table[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
+
+/* Exported as DATETIMEUNITS in multiarraymodule.c */
+char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
+    NPY_STR_Y,
+    NPY_STR_M,
+    NPY_STR_W,
+    NPY_STR_D,
+    NPY_STR_h,
+    NPY_STR_m,
+    NPY_STR_s,
+    NPY_STR_ms,
+    NPY_STR_us,
+    NPY_STR_ns,
+    NPY_STR_ps,
+    NPY_STR_fs,
+    NPY_STR_as,
+    "generic"
+};
+
+/*
+ * Returns 1 if the given year is a leap year, 0 otherwise.
+ */
+int is_leapyear(npy_int64 year)
+{
+    return (year & 0x3) == 0 && /* year % 4 == 0 */
+           ((year % 100) != 0 ||
+            (year % 400) == 0);
+}
+
+/*
+ * Modifies '*days_' to be the day offset within the year,
+ * and returns the year.
+ */
+static npy_int64
+days_to_yearsdays(npy_int64 *days_)
+{
+    const npy_int64 days_per_400years = (400*365 + 100 - 4 + 1);
+    /* Adjust so it's relative to the year 2000 (divisible by 400) */
+    npy_int64 days = (*days_) - (365*30 + 7);
+    npy_int64 year;
+
+    /* Break down the 400 year cycle to get the year and day within the year */
+    if (days >= 0) {
+        year = 400 * (days / days_per_400years);
+        days = days % days_per_400years;
+    }
+    else {
+        year = 400 * ((days - (days_per_400years - 1)) / days_per_400years);
+        days = days % days_per_400years;
+        if (days < 0) {
+            days += days_per_400years;
+        }
+    }
+
+    /* Work out the year/day within the 400 year cycle */
+    if (days >= 366) {
+        year += 100 * ((days-1) / (100*365 + 25 - 1));
+        days = (days-1) % (100*365 + 25 - 1);
+        if (days >= 365) {
+            year += 4 * ((days+1) / (4*365 + 1));
+            days = (days+1) % (4*365 + 1);
+            if (days >= 366) {
+                year += (days-1) / 365;
+                days = (days-1) % 365;
+            }
+        }
+    }
+
+    *days_ = days;
+    return year + 2000;
+}
+
+/*
+ * Adjusts a datetimestruct based on a seconds offset. Assumes
+ * the current values are valid.
+ */
+NPY_NO_EXPORT void
+add_seconds_to_datetimestruct(npy_datetimestruct *dts, int seconds)
+{
+    int minutes;
+
+    dts->sec += seconds;
+    if (dts->sec < 0) {
+        minutes = dts->sec / 60;
+        dts->sec = dts->sec % 60;
+        if (dts->sec < 0) {
+            --minutes;
+            dts->sec += 60;
+        }
+        add_minutes_to_datetimestruct(dts, minutes);
+    }
+    else if (dts->sec >= 60) {
+        minutes = dts->sec / 60;
+        dts->sec = dts->sec % 60;
+        add_minutes_to_datetimestruct(dts, minutes);
+    }
+}
+
+/*
+ * Fills in the year, month, day in 'dts' based on the days
+ * offset from 1970.
+ */
+static void
+set_datetimestruct_days(npy_int64 days, npy_datetimestruct *dts)
+{
+    int *month_lengths, i;
+
+    dts->year = days_to_yearsdays(&days);
+    month_lengths = _days_per_month_table[is_leapyear(dts->year)];
+
+    for (i = 0; i < 12; ++i) {
+        if (days < month_lengths[i]) {
+            dts->month = i + 1;
+            dts->day = days + 1;
+            return;
+        }
+        else {
+            days -= month_lengths[i];
+        }
+    }
+}
+
+/*
+ * Adjusts a datetimestruct based on a minutes offset. Assumes
+ * the current values are valid.
+ */
+void
+add_minutes_to_datetimestruct(npy_datetimestruct *dts, int minutes)
+{
+    int isleap;
+
+    /* MINUTES */
+    dts->min += minutes;
+    while (dts->min < 0) {
+        dts->min += 60;
+        dts->hour--;
+    }
+    while (dts->min >= 60) {
+        dts->min -= 60;
+        dts->hour++;
+    }
+
+    /* HOURS */
+    while (dts->hour < 0) {
+        dts->hour += 24;
+        dts->day--;
+    }
+    while (dts->hour >= 24) {
+        dts->hour -= 24;
+        dts->day++;
+    }
+
+    /* DAYS */
+    if (dts->day < 1) {
+        dts->month--;
+        if (dts->month < 1) {
+            dts->year--;
+            dts->month = 12;
+        }
+        isleap = is_leapyear(dts->year);
+        dts->day += _days_per_month_table[isleap][dts->month-1];
+    }
+    else if (dts->day > 28) {
+        isleap = is_leapyear(dts->year);
+        if (dts->day > _days_per_month_table[isleap][dts->month-1]) {
+            dts->day -= _days_per_month_table[isleap][dts->month-1];
+            dts->month++;
+            if (dts->month > 12) {
+                dts->year++;
+                dts->month = 1;
+            }
+        }
+    }
+}
+
+/*
+ *
+ * Tests for and converts a Python datetime.datetime or datetime.date
+ * object into a NumPy npy_datetimestruct.
+ *
+ * While the C API has PyDate_* and PyDateTime_* functions, the following
+ * implementation just asks for attributes, and thus supports
+ * datetime duck typing. The tzinfo time zone conversion would require
+ * this style of access anyway.
+ *
+ * 'out_bestunit' gives a suggested unit based on whether the object
+ *      was a datetime.date or datetime.datetime object.
+ *
+ * If 'apply_tzinfo' is 1, this function uses the tzinfo to convert
+ * to UTC time, otherwise it returns the struct with the local time.
+ *
+ * Returns -1 on error, 0 on success, and 1 (with no error set)
+ * if obj doesn't have the neeeded date or datetime attributes.
+ */
+int
+convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
+                                     NPY_DATETIMEUNIT *out_bestunit,
+                                     int apply_tzinfo)
+{
+    PyObject *tmp;
+    int isleap;
+
+    /* Initialize the output to all zeros */
+    memset(out, 0, sizeof(npy_datetimestruct));
+    out->month = 1;
+    out->day = 1;
+
+    /* Need at least year/month/day attributes */
+    if (!PyObject_HasAttrString(obj, "year") ||
+            !PyObject_HasAttrString(obj, "month") ||
+            !PyObject_HasAttrString(obj, "day")) {
+        return 1;
+    }
+
+    /* Get the year */
+    tmp = PyObject_GetAttrString(obj, "year");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->year = PyInt_AsLong(tmp);
+    if (out->year == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Get the month */
+    tmp = PyObject_GetAttrString(obj, "month");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->month = PyInt_AsLong(tmp);
+    if (out->month == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Get the day */
+    tmp = PyObject_GetAttrString(obj, "day");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->day = PyInt_AsLong(tmp);
+    if (out->day == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Validate that the month and day are valid for the year */
+    if (out->month < 1 || out->month > 12) {
+        goto invalid_date;
+    }
+    isleap = is_leapyear(out->year);
+    if (out->day < 1 ||
+                out->day > _days_per_month_table[isleap][out->month-1]) {
+        goto invalid_date;
+    }
+
+    /* Check for time attributes (if not there, return success as a date) */
+    if (!PyObject_HasAttrString(obj, "hour") ||
+            !PyObject_HasAttrString(obj, "minute") ||
+            !PyObject_HasAttrString(obj, "second") ||
+            !PyObject_HasAttrString(obj, "microsecond")) {
+        /* The best unit for date is 'D' */
+        if (out_bestunit != NULL) {
+            *out_bestunit = NPY_FR_D;
+        }
+        return 0;
+    }
+
+    /* Get the hour */
+    tmp = PyObject_GetAttrString(obj, "hour");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->hour = PyInt_AsLong(tmp);
+    if (out->hour == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Get the minute */
+    tmp = PyObject_GetAttrString(obj, "minute");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->min = PyInt_AsLong(tmp);
+    if (out->min == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Get the second */
+    tmp = PyObject_GetAttrString(obj, "second");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->sec = PyInt_AsLong(tmp);
+    if (out->sec == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    /* Get the microsecond */
+    tmp = PyObject_GetAttrString(obj, "microsecond");
+    if (tmp == NULL) {
+        return -1;
+    }
+    out->us = PyInt_AsLong(tmp);
+    if (out->us == -1 && PyErr_Occurred()) {
+        Py_DECREF(tmp);
+        return -1;
+    }
+    Py_DECREF(tmp);
+
+    if (out->hour < 0 || out->hour >= 24 ||
+            out->min < 0 || out->min >= 60 ||
+            out->sec < 0 || out->sec >= 60 ||
+            out->us < 0 || out->us >= 1000000) {
+        goto invalid_time;
+    }
+
+    /* Apply the time zone offset if it exists */
+    if (apply_tzinfo && PyObject_HasAttrString(obj, "tzinfo")) {
+        tmp = PyObject_GetAttrString(obj, "tzinfo");
+        if (tmp == NULL) {
+            return -1;
+        }
+        if (tmp == Py_None) {
+            Py_DECREF(tmp);
+        }
+        else {
+            PyObject *offset;
+            int seconds_offset, minutes_offset;
+
+            /* The utcoffset function should return a timedelta */
+            offset = PyObject_CallMethod(tmp, "utcoffset", "O", obj);
+            if (offset == NULL) {
+                Py_DECREF(tmp);
+                return -1;
+            }
+            Py_DECREF(tmp);
+
+            /*
+             * The timedelta should have a function "total_seconds"
+             * which contains the value we want.
+             */
+            tmp = PyObject_CallMethod(offset, "total_seconds", "");
+            if (tmp == NULL) {
+                return -1;
+            }
+            seconds_offset = PyInt_AsLong(tmp);
+            if (seconds_offset == -1 && PyErr_Occurred()) {
+                Py_DECREF(tmp);
+                return -1;
+            }
+            Py_DECREF(tmp);
+
+            /* Convert to a minutes offset and apply it */
+            minutes_offset = seconds_offset / 60;
+
+            add_minutes_to_datetimestruct(out, -minutes_offset);
+        }
+    }
+
+    /* The resolution of Python's datetime is 'us' */
+    if (out_bestunit != NULL) {
+        *out_bestunit = NPY_FR_us;
+    }
+
+    return 0;
+
+invalid_date:
+    PyErr_Format(PyExc_ValueError,
+            "Invalid date (%d,%d,%d) when converting to NumPy datetime",
+            (int)out->year, (int)out->month, (int)out->day);
+    return -1;
+
+invalid_time:
+    PyErr_Format(PyExc_ValueError,
+            "Invalid time (%d,%d,%d,%d) when converting "
+            "to NumPy datetime",
+            (int)out->hour, (int)out->min, (int)out->sec, (int)out->us);
+    return -1;
+}
+
+/*
+ * Converts a datetime from a datetimestruct to a datetime based
+ * on some metadata. The date is assumed to be valid.
+ *
+ * TODO: If meta->num is really big, there could be overflow
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+int
+convert_datetimestruct_to_datetime(PyArray_DatetimeMetaData *meta,
+                                    const npy_datetimestruct *dts,
+                                    npy_datetime *out)
+{
+    npy_datetime ret;
+    NPY_DATETIMEUNIT base = meta->base;
+
+    if (base == NPY_FR_Y) {
+        /* Truncate to the year */
+        ret = dts->year - 1970;
+    }
+    else if (base == NPY_FR_M) {
+        /* Truncate to the month */
+        ret = 12 * (dts->year - 1970) + (dts->month - 1);
+    }
+    else {
+        /* Otherwise calculate the number of days to start */
+        npy_int64 days = get_datetimestruct_days(dts);
+
+        switch (base) {
+            case NPY_FR_W:
+                /* Truncate to weeks */
+                if (days >= 0) {
+                    ret = days / 7;
+                }
+                else {
+                    ret = (days - 6) / 7;
+                }
+                break;
+            case NPY_FR_D:
+                ret = days;
+                break;
+            case NPY_FR_h:
+                ret = days * 24 +
+                      dts->hour;
+                break;
+            case NPY_FR_m:
+                ret = (days * 24 +
+                      dts->hour) * 60 +
+                      dts->min;
+                break;
+            case NPY_FR_s:
+                ret = ((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec;
+                break;
+            case NPY_FR_ms:
+                ret = (((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000 +
+                      dts->us / 1000;
+                break;
+            case NPY_FR_us:
+                ret = (((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000000 +
+                      dts->us;
+                break;
+            case NPY_FR_ns:
+                ret = ((((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000000 +
+                      dts->us) * 1000 +
+                      dts->ps / 1000;
+                break;
+            case NPY_FR_ps:
+                ret = ((((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000000 +
+                      dts->us) * 1000000 +
+                      dts->ps;
+                break;
+            case NPY_FR_fs:
+                /* only 2.6 hours */
+                ret = (((((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000000 +
+                      dts->us) * 1000000 +
+                      dts->ps) * 1000 +
+                      dts->as / 1000;
+                break;
+            case NPY_FR_as:
+                /* only 9.2 secs */
+                ret = (((((days * 24 +
+                      dts->hour) * 60 +
+                      dts->min) * 60 +
+                      dts->sec) * 1000000 +
+                      dts->us) * 1000000 +
+                      dts->ps) * 1000000 +
+                      dts->as;
+                break;
+            default:
+                /* Something got corrupted */
+                PyErr_SetString(PyExc_ValueError,
+                        "NumPy datetime metadata with corrupt unit value");
+                return -1;
+        }
+    }
+
+    /* Divide by the multiplier */
+    if (meta->num > 1) {
+        if (ret >= 0) {
+            ret /= meta->num;
+        }
+        else {
+            ret = (ret - meta->num + 1) / meta->num;
+        }
+    }
+
+    *out = ret;
+
+    return 0;
+}
+
+/*
+ * Calculates the days offset from the 1970 epoch.
+ */
+npy_int64
+get_datetimestruct_days(const npy_datetimestruct *dts)
+{
+    int i, month;
+    npy_int64 year, days = 0;
+    int *month_lengths;
+
+    year = dts->year - 1970;
+    days = year * 365;
+
+    /* Adjust for leap years */
+    if (days >= 0) {
+        /*
+         * 1968 is the closest leap year before 1970.
+         * Exclude the current year, so add 1.
+         */
+        year += 1;
+        /* Add one day for each 4 years */
+        days += year / 4;
+        /* 1900 is the closest previous year divisible by 100 */
+        year += 68;
+        /* Subtract one day for each 100 years */
+        days -= year / 100;
+        /* 1600 is the closest previous year divisible by 400 */
+        year += 300;
+        /* Add one day for each 400 years */
+        days += year / 400;
+    }
+    else {
+        /*
+         * 1972 is the closest later year after 1970.
+         * Include the current year, so subtract 2.
+         */
+        year -= 2;
+        /* Subtract one day for each 4 years */
+        days += year / 4;
+        /* 2000 is the closest later year divisible by 100 */
+        year -= 28;
+        /* Add one day for each 100 years */
+        days -= year / 100;
+        /* 2000 is also the closest later year divisible by 400 */
+        /* Subtract one day for each 400 years */
+        days += year / 400;
+    }
+
+    month_lengths = _days_per_month_table[is_leapyear(dts->year)];
+    month = dts->month - 1;
+
+    /* Add the months */
+    for (i = 0; i < month; ++i) {
+        days += month_lengths[i];
+    }
+
+    /* Add the days */
+    days += dts->day - 1;
+
+    return days;
+}
+
+/*
+ * This provides the casting rules for the TIMEDELTA data type units.
+ *
+ * Notably, there is a barrier between the nonlinear years and
+ * months units, and all the other units.
+ */
+npy_bool
+can_cast_timedelta64_units(NPY_DATETIMEUNIT src_unit,
+                          NPY_DATETIMEUNIT dst_unit,
+                          NPY_CASTING casting)
+{
+    switch (casting) {
+        /* Allow anything with unsafe casting */
+        case NPY_UNSAFE_CASTING:
+            return 1;
+
+        /*
+         * Only enforce the 'date units' vs 'time units' barrier with
+         * 'same_kind' casting.
+         */
+        case NPY_SAME_KIND_CASTING:
+            return (src_unit <= NPY_FR_M && dst_unit <= NPY_FR_M) ||
+                    (src_unit > NPY_FR_M && dst_unit > NPY_FR_M);
+
+        /*
+         * Enforce the 'date units' vs 'time units' barrier and that
+         * casting is only allowed towards more precise units with
+         * 'safe' casting.
+         */
+        case NPY_SAFE_CASTING:
+            return (src_unit <= dst_unit) &&
+                    ((src_unit <= NPY_FR_M && dst_unit <= NPY_FR_M) ||
+                    (src_unit > NPY_FR_M && dst_unit > NPY_FR_M));
+
+        /* Enforce equality with 'no' or 'equiv' casting */
+        default:
+            return src_unit == dst_unit;
+    }
+}
+
+/*
+ * This provides the casting rules for the DATETIME data type units.
+ *
+ * Notably, there is a barrier between 'date units' and 'time units'
+ * for all but 'unsafe' casting.
+ */
+npy_bool
+can_cast_datetime64_units(NPY_DATETIMEUNIT src_unit,
+                          NPY_DATETIMEUNIT dst_unit,
+                          NPY_CASTING casting)
+{
+    switch (casting) {
+        /* Allow anything with unsafe casting */
+        case NPY_UNSAFE_CASTING:
+            return 1;
+
+        /*
+         * Only enforce the 'date units' vs 'time units' barrier with
+         * 'same_kind' casting.
+         */
+        case NPY_SAME_KIND_CASTING:
+            return (src_unit <= NPY_FR_D && dst_unit <= NPY_FR_D) ||
+                    (src_unit > NPY_FR_D && dst_unit > NPY_FR_D);
+
+        /*
+         * Enforce the 'date units' vs 'time units' barrier and that
+         * casting is only allowed towards more precise units with
+         * 'safe' casting.
+         */
+        case NPY_SAFE_CASTING:
+            return (src_unit <= dst_unit) &&
+                    ((src_unit <= NPY_FR_D && dst_unit <= NPY_FR_D) ||
+                    (src_unit > NPY_FR_D && dst_unit > NPY_FR_D));
+
+        /* Enforce equality with 'no' or 'equiv' casting */
+        default:
+            return src_unit == dst_unit;
+    }
+}
+
+/*
+ * Converts a datetime based on the given metadata into a datetimestruct
+ */
+int
+convert_datetime_to_datetimestruct(PyArray_DatetimeMetaData *meta,
+                                    npy_datetime dt,
+                                    npy_datetimestruct *out)
+{
+    npy_int64 perday;
+
+    /* Initialize the output to all zeros */
+    memset(out, 0, sizeof(npy_datetimestruct));
+    out->year = 1970;
+    out->month = 1;
+    out->day = 1;
+
+    /* TODO: Change to a mechanism that avoids the potential overflow */
+    dt *= meta->num;
+
+    /*
+     * Note that care must be taken with the / and % operators
+     * for negative values.
+     */
+    switch (meta->base) {
+        case NPY_FR_Y:
+            out->year = 1970 + dt;
+            break;
+
+        case NPY_FR_M:
+            if (dt >= 0) {
+                out->year  = 1970 + dt / 12;
+                out->month = dt % 12 + 1;
+            }
+            else {
+                out->year  = 1969 + (dt + 1) / 12;
+                out->month = 12 + (dt + 1)% 12;
+            }
+            break;
+
+        case NPY_FR_W:
+            /* A week is 7 days */
+            set_datetimestruct_days(dt * 7, out);
+            break;
+
+        case NPY_FR_D:
+            set_datetimestruct_days(dt, out);
+            break;
+
+        case NPY_FR_h:
+            perday = 24LL;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt;
+            break;
+
+        case NPY_FR_m:
+            perday = 24LL * 60;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / 60;
+            out->min = dt % 60;
+            break;
+
+        case NPY_FR_s:
+            perday = 24LL * 60 * 60;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / (60*60);
+            out->min = (dt / 60) % 60;
+            out->sec = dt % 60;
+            break;
+
+        case NPY_FR_ms:
+            perday = 24LL * 60 * 60 * 1000;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / (60*60*1000LL);
+            out->min = (dt / (60*1000LL)) % 60;
+            out->sec = (dt / 1000LL) % 60;
+            out->us = (dt % 1000LL) * 1000;
+            break;
+
+        case NPY_FR_us:
+            perday = 24LL * 60LL * 60LL * 1000LL * 1000LL;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / (60*60*1000000LL);
+            out->min = (dt / (60*1000000LL)) % 60;
+            out->sec = (dt / 1000000LL) % 60;
+            out->us = dt % 1000000LL;
+            break;
+
+        case NPY_FR_ns:
+            perday = 24LL * 60LL * 60LL * 1000LL * 1000LL * 1000LL;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / (60*60*1000000000LL);
+            out->min = (dt / (60*1000000000LL)) % 60;
+            out->sec = (dt / 1000000000LL) % 60;
+            out->us = (dt / 1000LL) % 1000000LL;
+            out->ps = (dt % 1000LL) * 1000;
+            break;
+
+        case NPY_FR_ps:
+            perday = 24LL * 60 * 60 * 1000 * 1000 * 1000 * 1000;
+
+            if (dt >= 0) {
+                set_datetimestruct_days(dt / perday, out);
+                dt  = dt % perday;
+            }
+            else {
+                set_datetimestruct_days((dt - (perday-1)) / perday, out);
+                dt = (perday-1) + (dt + 1) % perday;
+            }
+            out->hour = dt / (60*60*1000000000000LL);
+            out->min = (dt / (60*1000000000000LL)) % 60;
+            out->sec = (dt / 1000000000000LL) % 60;
+            out->us = (dt / 1000000LL) % 1000000LL;
+            out->ps = dt % 1000000LL;
+            break;
+
+        case NPY_FR_fs:
+            /* entire range is only +- 2.6 hours */
+            if (dt >= 0) {
+                out->hour = dt / (60*60*1000000000000000LL);
+                out->min = (dt / (60*1000000000000000LL)) % 60;
+                out->sec = (dt / 1000000000000000LL) % 60;
+                out->us = (dt / 1000000000LL) % 1000000LL;
+                out->ps = (dt / 1000LL) % 1000000LL;
+                out->as = (dt % 1000LL) * 1000;
+            }
+            else {
+                npy_datetime minutes;
+
+                minutes = dt / (60*1000000000000000LL);
+                dt = dt % (60*1000000000000000LL);
+                if (dt < 0) {
+                    dt += (60*1000000000000000LL);
+                    --minutes;
+                }
+                /* Offset the negative minutes */
+                add_minutes_to_datetimestruct(out, minutes);
+                out->sec = (dt / 1000000000000000LL) % 60;
+                out->us = (dt / 1000000000LL) % 1000000LL;
+                out->ps = (dt / 1000LL) % 1000000LL;
+                out->as = (dt % 1000LL) * 1000;
+            }
+            break;
+
+        case NPY_FR_as:
+            /* entire range is only +- 9.2 seconds */
+            if (dt >= 0) {
+                out->sec = (dt / 1000000000000000000LL) % 60;
+                out->us = (dt / 1000000000000LL) % 1000000LL;
+                out->ps = (dt / 1000000LL) % 1000000LL;
+                out->as = dt % 1000000LL;
+            }
+            else {
+                npy_datetime seconds;
+
+                seconds = dt / 1000000000000000000LL;
+                dt = dt % 1000000000000000000LL;
+                if (dt < 0) {
+                    dt += 1000000000000000000LL;
+                    --seconds;
+                }
+                /* Offset the negative seconds */
+                add_seconds_to_datetimestruct(out, seconds);
+                out->us = (dt / 1000000000000LL) % 1000000LL;
+                out->ps = (dt / 1000000LL) % 1000000LL;
+                out->as = dt % 1000000LL;
+            }
+            break;
+
+        default:
+            PyErr_SetString(PyExc_RuntimeError,
+                        "NumPy datetime metadata is corrupted with invalid "
+                        "base unit");
+            return -1;
+    }
+
+    return 0;
+}
+
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
new file mode 100644
index 000000000..49a225ff5
--- /dev/null
+++ b/pandas/src/np_datetime.h
@@ -0,0 +1,75 @@
+/*
+ * This is derived from numpy 1.7  
+ * See NP_LICENSE.TXT
+ */
+
+#ifndef _PANDAS_DATETIME_H_
+#define _PANDAS_DATETIME_H_
+
+#define NPY_DATETIME_MAX_ISO8601_STRLEN (21+3*5+1+3*6+6+1)  
+
+// stuff pandas needs
+// ----------------------------------------------------------------------------
+
+int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
+                                         NPY_DATETIMEUNIT *out_bestunit,
+                                         int apply_tzinfo);
+
+int is_leapyear(npy_int64 year);
+
+// stuff numpy needs
+// ----------------------------------------------------------------------------
+
+char *_datetime_strings[NPY_DATETIME_NUMUNITS];
+
+int _days_per_month_table[2][12];
+
+/*
+ * Converts a datetime from a datetimestruct to a datetime based
+ * on some metadata. The date is assumed to be valid.
+ *
+ * TODO: If meta->num is really big, there could be overflow
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+int
+convert_datetimestruct_to_datetime(PyArray_DatetimeMetaData *meta,
+                                    const npy_datetimestruct *dts,
+                                    npy_datetime *out);
+
+/*
+ * Calculates the days offset from the 1970 epoch.
+ */
+npy_int64
+get_datetimestruct_days(const npy_datetimestruct *dts);
+
+/*
+ * Adjusts a datetimestruct based on a minutes offset. Assumes
+ * the current values are valid.
+ */
+void
+add_minutes_to_datetimestruct(npy_datetimestruct *dts, int minutes);
+
+/*
+ * This provides the casting rules for the TIMEDELTA data type units.
+ *
+ * Notably, there is a barrier between the nonlinear years and
+ * months units, and all the other units.
+ */
+//npy_bool
+//can_cast_timedelta64_units(NPY_DATETIMEUNIT src_unit,
+//                          NPY_DATETIMEUNIT dst_unit,
+//                          NPY_CASTING casting);
+
+npy_bool
+can_cast_datetime64_units(NPY_DATETIMEUNIT src_unit,
+                          NPY_DATETIMEUNIT dst_unit,
+                          NPY_CASTING casting);
+
+
+int
+convert_datetime_to_datetimestruct(PyArray_DatetimeMetaData *meta,
+                                    npy_datetime dt,
+                                    npy_datetimestruct *out);
+
+#endif
diff --git a/pandas/src/np_datetime_strings.c b/pandas/src/np_datetime_strings.c
new file mode 100644
index 000000000..7722f29e1
--- /dev/null
+++ b/pandas/src/np_datetime_strings.c
@@ -0,0 +1,1390 @@
+/*
+ * This file implements string parsing and creation for NumPy datetime.
+ *
+ * Written by Mark Wiebe (mwwiebe@gmail.com)
+ * Copyright (c) 2011 by Enthought, Inc.
+ *
+ * See NP_LICENSE.txt for the license.
+ */
+
+#define PY_SSIZE_T_CLEAN
+#include <Python.h>
+
+#include <time.h>
+
+#include <numpy/arrayobject.h>
+
+//#include "numpy/npy_3kcompat.h"
+
+#include "numpy/arrayscalars.h"
+
+#include "np_datetime.h"
+#include "np_datetime_strings.h"
+
+NPY_NO_EXPORT const char *
+npy_casting_to_string(NPY_CASTING casting)
+{
+    switch (casting) {
+        case NPY_NO_CASTING:
+            return "'no'";
+        case NPY_EQUIV_CASTING:
+            return "'equiv'";
+        case NPY_SAFE_CASTING:
+            return "'safe'";
+        case NPY_SAME_KIND_CASTING:
+            return "'same_kind'";
+        case NPY_UNSAFE_CASTING:
+            return "'unsafe'";
+        default:
+            return "<unknown>";
+    }
+}
+
+/* Platform-specific time_t typedef */
+typedef time_t NPY_TIME_T;
+
+/*
+ * Wraps `localtime` functionality for multiple platforms. This
+ * converts a time value to a time structure in the local timezone.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+static int
+get_localtime(NPY_TIME_T *ts, struct tm *tms)
+{
+    char *func_name = "<unknown>";
+#if defined(_WIN32)
+ #if defined(_MSC_VER) && (_MSC_VER >= 1400)
+    if (localtime_s(tms, ts) != 0) {
+        func_name = "localtime_s";
+        goto fail;
+    }
+ #elif defined(__GNUC__) && defined(NPY_MINGW_USE_CUSTOM_MSVCR)
+    if (_localtime64_s(tms, ts) != 0) {
+        func_name = "_localtime64_s";
+        goto fail;
+    }
+ #else
+    struct tm *tms_tmp;
+    tms_tmp = localtime(ts);
+    if (tms_tmp == NULL) {
+        func_name = "localtime";
+        goto fail;
+    }
+    memcpy(tms, tms_tmp, sizeof(struct tm));
+ #endif
+#else
+    if (localtime_r(ts, tms) == NULL) {
+        func_name = "localtime_r";
+        goto fail;
+    }
+#endif
+
+    return 0;
+
+fail:
+    PyErr_Format(PyExc_OSError, "Failed to use '%s' to convert "
+                                "to a local time", func_name);
+    return -1;
+}
+
+/*
+ * Wraps `gmtime` functionality for multiple platforms. This
+ * converts a time value to a time structure in UTC.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+static int
+get_gmtime(NPY_TIME_T *ts, struct tm *tms)
+{
+    char *func_name = "<unknown>";
+#if defined(_WIN32)
+ #if defined(_MSC_VER) && (_MSC_VER >= 1400)
+    if (gmtime_s(tms, ts) != 0) {
+        func_name = "gmtime_s";
+        goto fail;
+    }
+ #elif defined(__GNUC__) && defined(NPY_MINGW_USE_CUSTOM_MSVCR)
+    if (_gmtime64_s(tms, ts) != 0) {
+        func_name = "_gmtime64_s";
+        goto fail;
+    }
+ #else
+    struct tm *tms_tmp;
+    tms_tmp = gmtime(ts);
+    if (tms_tmp == NULL) {
+        func_name = "gmtime";
+        goto fail;
+    }
+    memcpy(tms, tms_tmp, sizeof(struct tm));
+ #endif
+#else
+    if (gmtime_r(ts, tms) == NULL) {
+        func_name = "gmtime_r";
+        goto fail;
+    }
+#endif
+
+    return 0;
+
+fail:
+    PyErr_Format(PyExc_OSError, "Failed to use '%s' to convert "
+                                "to a UTC time", func_name);
+    return -1;
+}
+
+/*
+ * Converts a datetimestruct in UTC to a datetimestruct in local time,
+ * also returning the timezone offset applied.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+static int
+convert_datetimestruct_utc_to_local(npy_datetimestruct *out_dts_local,
+                const npy_datetimestruct *dts_utc, int *out_timezone_offset)
+{
+    NPY_TIME_T rawtime = 0, localrawtime;
+    struct tm tm_;
+    npy_int64 year_correction = 0;
+
+    /* Make a copy of the input 'dts' to modify */
+    *out_dts_local = *dts_utc;
+
+    /* HACK: Use a year < 2038 for later years for small time_t */
+    if (sizeof(NPY_TIME_T) == 4 && out_dts_local->year >= 2038) {
+        if (is_leapyear(out_dts_local->year)) {
+            /* 2036 is a leap year */
+            year_correction = out_dts_local->year - 2036;
+            out_dts_local->year -= year_correction;
+        }
+        else {
+            /* 2037 is not a leap year */
+            year_correction = out_dts_local->year - 2037;
+            out_dts_local->year -= year_correction;
+        }
+    }
+
+    /*
+     * Convert everything in 'dts' to a time_t, to minutes precision.
+     * This is POSIX time, which skips leap-seconds, but because
+     * we drop the seconds value from the npy_datetimestruct, everything
+     * is ok for this operation.
+     */
+    rawtime = (time_t)get_datetimestruct_days(out_dts_local) * 24 * 60 * 60;
+    rawtime += dts_utc->hour * 60 * 60;
+    rawtime += dts_utc->min * 60;
+
+    /* localtime converts a 'time_t' into a local 'struct tm' */
+    if (get_localtime(&rawtime, &tm_) < 0) {
+        return -1;
+    }
+
+    /* Copy back all the values except seconds */
+    out_dts_local->min = tm_.tm_min;
+    out_dts_local->hour = tm_.tm_hour;
+    out_dts_local->day = tm_.tm_mday;
+    out_dts_local->month = tm_.tm_mon + 1;
+    out_dts_local->year = tm_.tm_year + 1900;
+
+    /* Extract the timezone offset that was applied */
+    rawtime /= 60;
+    localrawtime = (time_t)get_datetimestruct_days(out_dts_local) * 24 * 60;
+    localrawtime += out_dts_local->hour * 60;
+    localrawtime += out_dts_local->min;
+
+    *out_timezone_offset = localrawtime - rawtime;
+
+    /* Reapply the year 2038 year correction HACK */
+    out_dts_local->year += year_correction;
+
+    return 0;
+}
+
+/*
+ * Converts a datetimestruct in local time to a datetimestruct in UTC.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+static int
+convert_datetimestruct_local_to_utc(npy_datetimestruct *out_dts_utc,
+                const npy_datetimestruct *dts_local)
+{
+    npy_int64 year_correction = 0;
+
+    /* Make a copy of the input 'dts' to modify */
+    *out_dts_utc = *dts_local;
+
+    /* HACK: Use a year < 2038 for later years for small time_t */
+    if (sizeof(NPY_TIME_T) == 4 && out_dts_utc->year >= 2038) {
+        if (is_leapyear(out_dts_utc->year)) {
+            /* 2036 is a leap year */
+            year_correction = out_dts_utc->year - 2036;
+            out_dts_utc->year -= year_correction;
+        }
+        else {
+            /* 2037 is not a leap year */
+            year_correction = out_dts_utc->year - 2037;
+            out_dts_utc->year -= year_correction;
+        }
+    }
+
+    /*
+     * ISO 8601 states to treat date-times without a timezone offset
+     * or 'Z' for UTC as local time. The C standard libary functions
+     * mktime and gmtime allow us to do this conversion.
+     *
+     * Only do this timezone adjustment for recent and future years.
+     * In this case, "recent" is defined to be 1970 and later, because
+     * on MS Windows, mktime raises an error when given an earlier date.
+     */
+    if (out_dts_utc->year >= 1970) {
+        NPY_TIME_T rawtime = 0;
+        struct tm tm_;
+
+        tm_.tm_sec = out_dts_utc->sec;
+        tm_.tm_min = out_dts_utc->min;
+        tm_.tm_hour = out_dts_utc->hour;
+        tm_.tm_mday = out_dts_utc->day;
+        tm_.tm_mon = out_dts_utc->month - 1;
+        tm_.tm_year = out_dts_utc->year - 1900;
+        tm_.tm_isdst = -1;
+
+        /* mktime converts a local 'struct tm' into a time_t */
+        rawtime = mktime(&tm_);
+        if (rawtime == -1) {
+            PyErr_SetString(PyExc_OSError, "Failed to use mktime to "
+                                        "convert local time to UTC");
+            return -1;
+        }
+
+        /* gmtime converts a 'time_t' into a UTC 'struct tm' */
+        if (get_gmtime(&rawtime, &tm_) < 0) {
+            return -1;
+        }
+        out_dts_utc->sec = tm_.tm_sec;
+        out_dts_utc->min = tm_.tm_min;
+        out_dts_utc->hour = tm_.tm_hour;
+        out_dts_utc->day = tm_.tm_mday;
+        out_dts_utc->month = tm_.tm_mon + 1;
+        out_dts_utc->year = tm_.tm_year + 1900;
+    }
+
+    /* Reapply the year 2038 year correction HACK */
+    out_dts_utc->year += year_correction;
+
+    return 0;
+}
+
+/*
+ * Parses (almost) standard ISO 8601 date strings. The differences are:
+ *
+ * + The date "20100312" is parsed as the year 20100312, not as
+ *   equivalent to "2010-03-12". The '-' in the dates are not optional.
+ * + Only seconds may have a decimal point, with up to 18 digits after it
+ *   (maximum attoseconds precision).
+ * + Either a 'T' as in ISO 8601 or a ' ' may be used to separate
+ *   the date and the time. Both are treated equivalently.
+ * + Doesn't (yet) handle the "YYYY-DDD" or "YYYY-Www" formats.
+ * + Doesn't handle leap seconds (seconds value has 60 in these cases).
+ * + Doesn't handle 24:00:00 as synonym for midnight (00:00:00) tomorrow
+ * + Accepts special values "NaT" (not a time), "Today", (current
+ *   day according to local time) and "Now" (current time in UTC).
+ *
+ * 'str' must be a NULL-terminated string, and 'len' must be its length.
+ * 'unit' should contain -1 if the unit is unknown, or the unit
+ *      which will be used if it is.
+ * 'casting' controls how the detected unit from the string is allowed
+ *           to be cast to the 'unit' parameter.
+ *
+ * 'out' gets filled with the parsed date-time.
+ * 'out_local' gets set to 1 if the parsed time was in local time,
+ *      to 0 otherwise. The values 'now' and 'today' don't get counted
+ *      as local, and neither do UTC +/-#### timezone offsets, because
+ *      they aren't using the computer's local timezone offset.
+ * 'out_bestunit' gives a suggested unit based on the amount of
+ *      resolution provided in the string, or -1 for NaT.
+ * 'out_special' gets set to 1 if the parsed time was 'today',
+ *      'now', or ''/'NaT'. For 'today', the unit recommended is
+ *      'D', for 'now', the unit recommended is 's', and for 'NaT'
+ *      the unit recommended is 'Y'.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+int
+parse_iso_8601_datetime(char *str, int len,
+                    NPY_DATETIMEUNIT unit,
+                    NPY_CASTING casting,
+                    npy_datetimestruct *out,
+                    npy_bool *out_local,
+                    NPY_DATETIMEUNIT *out_bestunit,
+                    npy_bool *out_special)
+{
+    int year_leap = 0;
+    int i, numdigits;
+    char *substr, sublen;
+    NPY_DATETIMEUNIT bestunit;
+
+    /* Initialize the output to all zeros */
+    memset(out, 0, sizeof(npy_datetimestruct));
+    out->month = 1;
+    out->day = 1;
+
+
+    /*
+     * The string "today" means take today's date in local time, and
+     * convert it to a date representation. This date representation, if
+     * forced into a time unit, will be at midnight UTC.
+     * This is perhaps a little weird, but done so that the
+     * 'datetime64[D]' type produces the date you expect, rather than
+     * switching to an adjacent day depending on the current time and your
+     * timezone.
+     */
+    if (len == 5 && tolower(str[0]) == 't' &&
+                    tolower(str[1]) == 'o' &&
+                    tolower(str[2]) == 'd' &&
+                    tolower(str[3]) == 'a' &&
+                    tolower(str[4]) == 'y') {
+        NPY_TIME_T rawtime = 0;
+        struct tm tm_;
+
+        time(&rawtime);
+        if (get_localtime(&rawtime, &tm_) < 0) {
+            return -1;
+        }
+        out->year = tm_.tm_year + 1900;
+        out->month = tm_.tm_mon + 1;
+        out->day = tm_.tm_mday;
+
+        bestunit = NPY_FR_D;
+
+        /*
+         * Indicate that this was a special value, and
+         * is a date (unit 'D').
+         */
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+        if (out_bestunit != NULL) {
+            *out_bestunit = bestunit;
+        }
+        if (out_special != NULL) {
+            *out_special = 1;
+        }
+
+        /* Check the casting rule */
+        if (unit != -1 && !can_cast_datetime64_units(bestunit, unit,
+                                                     casting)) {
+            PyErr_Format(PyExc_TypeError, "Cannot parse \"%s\" as unit "
+                         "'%s' using casting rule %s",
+                         str, _datetime_strings[unit],
+                         npy_casting_to_string(casting));
+            return -1;
+        }
+
+        return 0;
+    }
+
+    /* The string "now" resolves to the current UTC time */
+    if (len == 3 && tolower(str[0]) == 'n' &&
+                    tolower(str[1]) == 'o' &&
+                    tolower(str[2]) == 'w') {
+        NPY_TIME_T rawtime = 0;
+        PyArray_DatetimeMetaData meta;
+
+        time(&rawtime);
+
+        /* Set up a dummy metadata for the conversion */
+        meta.base = NPY_FR_s;
+        meta.num = 1;
+
+        bestunit = NPY_FR_s;
+
+        /*
+         * Indicate that this was a special value, and
+         * use 's' because the time() function has resolution
+         * seconds.
+         */
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+        if (out_bestunit != NULL) {
+            *out_bestunit = bestunit;
+        }
+        if (out_special != NULL) {
+            *out_special = 1;
+        }
+
+        /* Check the casting rule */
+        if (unit != -1 && !can_cast_datetime64_units(bestunit, unit,
+                                                     casting)) {
+            PyErr_Format(PyExc_TypeError, "Cannot parse \"%s\" as unit "
+                         "'%s' using casting rule %s",
+                         str, _datetime_strings[unit],
+                         npy_casting_to_string(casting));
+            return -1;
+        }
+
+        return convert_datetime_to_datetimestruct(&meta, rawtime, out);
+    }
+
+    /* Anything else isn't a special value */
+    if (out_special != NULL) {
+        *out_special = 0;
+    }
+
+    substr = str;
+    sublen = len;
+
+    /* Skip leading whitespace */
+    while (sublen > 0 && isspace(*substr)) {
+        ++substr;
+        --sublen;
+    }
+
+    /* Leading '-' sign for negative year */
+    if (*substr == '-') {
+        ++substr;
+        --sublen;
+    }
+
+    if (sublen == 0) {
+        goto parse_error;
+    }
+
+    /* PARSE THE YEAR (digits until the '-' character) */
+    out->year = 0;
+    while (sublen > 0 && isdigit(*substr)) {
+        out->year = 10 * out->year + (*substr - '0');
+        ++substr;
+        --sublen;
+    }
+
+    /* Negate the year if necessary */
+    if (str[0] == '-') {
+        out->year = -out->year;
+    }
+    /* Check whether it's a leap-year */
+    year_leap = is_leapyear(out->year);
+
+    /* Next character must be a '-' or the end of the string */
+    if (sublen == 0) {
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+        bestunit = NPY_FR_Y;
+        goto finish;
+    }
+    else if (*substr == '-') {
+        ++substr;
+        --sublen;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Can't have a trailing '-' */
+    if (sublen == 0) {
+        goto parse_error;
+    }
+
+    /* PARSE THE MONTH (2 digits) */
+    if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+        out->month = 10 * (substr[0] - '0') + (substr[1] - '0');
+
+        if (out->month < 1 || out->month > 12) {
+            PyErr_Format(PyExc_ValueError,
+                        "Month out of range in datetime string \"%s\"", str);
+            goto error;
+        }
+        substr += 2;
+        sublen -= 2;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Next character must be a '-' or the end of the string */
+    if (sublen == 0) {
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+        bestunit = NPY_FR_M;
+        goto finish;
+    }
+    else if (*substr == '-') {
+        ++substr;
+        --sublen;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Can't have a trailing '-' */
+    if (sublen == 0) {
+        goto parse_error;
+    }
+
+    /* PARSE THE DAY (2 digits) */
+    if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+        out->day = 10 * (substr[0] - '0') + (substr[1] - '0');
+
+        if (out->day < 1 ||
+                    out->day > _days_per_month_table[year_leap][out->month-1]) {
+            PyErr_Format(PyExc_ValueError,
+                        "Day out of range in datetime string \"%s\"", str);
+            goto error;
+        }
+        substr += 2;
+        sublen -= 2;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Next character must be a 'T', ' ', or end of string */
+    if (sublen == 0) {
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+        bestunit = NPY_FR_D;
+        goto finish;
+    }
+    else if (*substr != 'T' && *substr != ' ') {
+        goto parse_error;
+    }
+    else {
+        ++substr;
+        --sublen;
+    }
+
+    /* PARSE THE HOURS (2 digits) */
+    if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+        out->hour = 10 * (substr[0] - '0') + (substr[1] - '0');
+
+        if (out->hour < 0 || out->hour >= 24) {
+            PyErr_Format(PyExc_ValueError,
+                        "Hours out of range in datetime string \"%s\"", str);
+            goto error;
+        }
+        substr += 2;
+        sublen -= 2;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Next character must be a ':' or the end of the string */
+    if (sublen > 0 && *substr == ':') {
+        ++substr;
+        --sublen;
+    }
+    else {
+        bestunit = NPY_FR_h;
+        goto parse_timezone;
+    }
+
+    /* Can't have a trailing ':' */
+    if (sublen == 0) {
+        goto parse_error;
+    }
+
+    /* PARSE THE MINUTES (2 digits) */
+    if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+        out->min = 10 * (substr[0] - '0') + (substr[1] - '0');
+
+        if (out->hour < 0 || out->min >= 60) {
+            PyErr_Format(PyExc_ValueError,
+                        "Minutes out of range in datetime string \"%s\"", str);
+            goto error;
+        }
+        substr += 2;
+        sublen -= 2;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Next character must be a ':' or the end of the string */
+    if (sublen > 0 && *substr == ':') {
+        ++substr;
+        --sublen;
+    }
+    else {
+        bestunit = NPY_FR_m;
+        goto parse_timezone;
+    }
+
+    /* Can't have a trailing ':' */
+    if (sublen == 0) {
+        goto parse_error;
+    }
+
+    /* PARSE THE SECONDS (2 digits) */
+    if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+        out->sec = 10 * (substr[0] - '0') + (substr[1] - '0');
+
+        if (out->sec < 0 || out->sec >= 60) {
+            PyErr_Format(PyExc_ValueError,
+                        "Seconds out of range in datetime string \"%s\"", str);
+            goto error;
+        }
+        substr += 2;
+        sublen -= 2;
+    }
+    else {
+        goto parse_error;
+    }
+
+    /* Next character may be a '.' indicating fractional seconds */
+    if (sublen > 0 && *substr == '.') {
+        ++substr;
+        --sublen;
+    }
+    else {
+        bestunit = NPY_FR_s;
+        goto parse_timezone;
+    }
+
+    /* PARSE THE MICROSECONDS (0 to 6 digits) */
+    numdigits = 0;
+    for (i = 0; i < 6; ++i) {
+        out->us *= 10;
+        if (sublen > 0  && isdigit(*substr)) {
+            out->us += (*substr - '0');
+            ++substr;
+            --sublen;
+            ++numdigits;
+        }
+    }
+
+    if (sublen == 0 || !isdigit(*substr)) {
+        if (numdigits > 3) {
+            bestunit = NPY_FR_us;
+        }
+        else {
+            bestunit = NPY_FR_ms;
+        }
+        goto parse_timezone;
+    }
+
+    /* PARSE THE PICOSECONDS (0 to 6 digits) */
+    numdigits = 0;
+    for (i = 0; i < 6; ++i) {
+        out->ps *= 10;
+        if (sublen > 0 && isdigit(*substr)) {
+            out->ps += (*substr - '0');
+            ++substr;
+            --sublen;
+            ++numdigits;
+        }
+    }
+
+    if (sublen == 0 || !isdigit(*substr)) {
+        if (numdigits > 3) {
+            bestunit = NPY_FR_ps;
+        }
+        else {
+            bestunit = NPY_FR_ns;
+        }
+        goto parse_timezone;
+    }
+
+    /* PARSE THE ATTOSECONDS (0 to 6 digits) */
+    numdigits = 0;
+    for (i = 0; i < 6; ++i) {
+        out->as *= 10;
+        if (sublen > 0 && isdigit(*substr)) {
+            out->as += (*substr - '0');
+            ++substr;
+            --sublen;
+            ++numdigits;
+        }
+    }
+
+    if (numdigits > 3) {
+        bestunit = NPY_FR_as;
+    }
+    else {
+        bestunit = NPY_FR_fs;
+    }
+
+parse_timezone:
+    if (sublen == 0) {
+        if (convert_datetimestruct_local_to_utc(out, out) < 0) {
+            goto error;
+        }
+
+        /* Since neither "Z" nor a time-zone was specified, it's local */
+        if (out_local != NULL) {
+            *out_local = 1;
+        }
+
+        goto finish;
+    }
+
+    /* UTC specifier */
+    if (*substr == 'Z') {
+        /* "Z" means not local */
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+
+        if (sublen == 1) {
+            goto finish;
+        }
+        else {
+            ++substr;
+            --sublen;
+        }
+    }
+    /* Time zone offset */
+    else if (*substr == '-' || *substr == '+') {
+        int offset_neg = 0, offset_hour = 0, offset_minute = 0;
+
+        /*
+         * Since "local" means local with respect to the current
+         * machine, we say this is non-local.
+         */
+        if (out_local != NULL) {
+            *out_local = 0;
+        }
+
+        if (*substr == '-') {
+            offset_neg = 1;
+        }
+        ++substr;
+        --sublen;
+
+        /* The hours offset */
+        if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+            offset_hour = 10 * (substr[0] - '0') + (substr[1] - '0');
+            substr += 2;
+            sublen -= 2;
+            if (offset_hour >= 24) {
+                PyErr_Format(PyExc_ValueError,
+                            "Timezone hours offset out of range "
+                            "in datetime string \"%s\"", str);
+                goto error;
+            }
+        }
+        else {
+            goto parse_error;
+        }
+
+        /* The minutes offset is optional */
+        if (sublen > 0) {
+            /* Optional ':' */
+            if (*substr == ':') {
+                ++substr;
+                --sublen;
+            }
+
+            /* The minutes offset (at the end of the string) */
+            if (sublen >= 2 && isdigit(substr[0]) && isdigit(substr[1])) {
+                offset_minute = 10 * (substr[0] - '0') + (substr[1] - '0');
+                substr += 2;
+                sublen -= 2;
+                if (offset_minute >= 60) {
+                    PyErr_Format(PyExc_ValueError,
+                                "Timezone minutes offset out of range "
+                                "in datetime string \"%s\"", str);
+                    goto error;
+                }
+            }
+            else {
+                goto parse_error;
+            }
+        }
+
+        /* Apply the time zone offset */
+        if (offset_neg) {
+            offset_hour = -offset_hour;
+            offset_minute = -offset_minute;
+        }
+        add_minutes_to_datetimestruct(out, -60 * offset_hour - offset_minute);
+    }
+
+    /* Skip trailing whitespace */
+    while (sublen > 0 && isspace(*substr)) {
+        ++substr;
+        --sublen;
+    }
+
+    if (sublen != 0) {
+        goto parse_error;
+    }
+
+finish:
+    if (out_bestunit != NULL) {
+        *out_bestunit = bestunit;
+    }
+
+    /* Check the casting rule */
+    if (unit != -1 && !can_cast_datetime64_units(bestunit, unit,
+                                                 casting)) {
+        PyErr_Format(PyExc_TypeError, "Cannot parse \"%s\" as unit "
+                     "'%s' using casting rule %s",
+                     str, _datetime_strings[unit],
+                     npy_casting_to_string(casting));
+        return -1;
+    }
+
+    return 0;
+
+parse_error:
+    PyErr_Format(PyExc_ValueError,
+            "Error parsing datetime string \"%s\" at position %d",
+            str, (int)(substr-str));
+    return -1;
+
+error:
+    return -1;
+}
+
+/*
+ * Provides a string length to use for converting datetime
+ * objects with the given local and unit settings.
+ */
+int
+get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
+{
+    int len = 0;
+
+    /* If no unit is provided, return the maximum length */
+    if (base == -1) {
+        return NPY_DATETIME_MAX_ISO8601_STRLEN;
+    }
+
+    switch (base) {
+        /* Generic units can only be used to represent NaT */
+        /*case NPY_FR_GENERIC:*/
+        /*    return 4;*/
+        case NPY_FR_as:
+            len += 3;  /* "###" */
+        case NPY_FR_fs:
+            len += 3;  /* "###" */
+        case NPY_FR_ps:
+            len += 3;  /* "###" */
+        case NPY_FR_ns:
+            len += 3;  /* "###" */
+        case NPY_FR_us:
+            len += 3;  /* "###" */
+        case NPY_FR_ms:
+            len += 4;  /* ".###" */
+        case NPY_FR_s:
+            len += 3;  /* ":##" */
+        case NPY_FR_m:
+            len += 3;  /* ":##" */
+        case NPY_FR_h:
+            len += 3;  /* "T##" */
+        case NPY_FR_D:
+        case NPY_FR_B:
+        case NPY_FR_W:
+            len += 3;  /* "-##" */
+        case NPY_FR_M:
+            len += 3;  /* "-##" */
+        case NPY_FR_Y:
+            len += 21; /* 64-bit year */
+            break;
+    }
+
+    if (base >= NPY_FR_h) {
+        if (local) {
+            len += 5;  /* "+####" or "-####" */
+        }
+        else {
+            len += 1;  /* "Z" */
+        }
+    }
+
+    len += 1; /* NULL terminator */
+
+    return len;
+}
+
+/*
+ * Finds the largest unit whose value is nonzero, and for which
+ * the remainder for the rest of the units is zero.
+ */
+static NPY_DATETIMEUNIT
+lossless_unit_from_datetimestruct(npy_datetimestruct *dts)
+{
+    if (dts->as % 1000 != 0) {
+        return NPY_FR_as;
+    }
+    else if (dts->as != 0) {
+        return NPY_FR_fs;
+    }
+    else if (dts->ps % 1000 != 0) {
+        return NPY_FR_ps;
+    }
+    else if (dts->ps != 0) {
+        return NPY_FR_ns;
+    }
+    else if (dts->us % 1000 != 0) {
+        return NPY_FR_us;
+    }
+    else if (dts->us != 0) {
+        return NPY_FR_ms;
+    }
+    else if (dts->sec != 0) {
+        return NPY_FR_s;
+    }
+    else if (dts->min != 0) {
+        return NPY_FR_m;
+    }
+    else if (dts->hour != 0) {
+        return NPY_FR_h;
+    }
+    else if (dts->day != 1) {
+        return NPY_FR_D;
+    }
+    else if (dts->month != 1) {
+        return NPY_FR_M;
+    }
+    else {
+        return NPY_FR_Y;
+    }
+}
+
+/*
+ * Converts an npy_datetimestruct to an (almost) ISO 8601
+ * NULL-terminated string. If the string fits in the space exactly,
+ * it leaves out the NULL terminator and returns success.
+ *
+ * The differences from ISO 8601 are the 'NaT' string, and
+ * the number of year digits is >= 4 instead of strictly 4.
+ *
+ * If 'local' is non-zero, it produces a string in local time with
+ * a +-#### timezone offset, otherwise it uses timezone Z (UTC).
+ *
+ * 'base' restricts the output to that unit. Set 'base' to
+ * -1 to auto-detect a base after which all the values are zero.
+ *
+ *  'tzoffset' is used if 'local' is enabled, and 'tzoffset' is
+ *  set to a value other than -1. This is a manual override for
+ *  the local time zone to use, as an offset in minutes.
+ *
+ *  'casting' controls whether data loss is allowed by truncating
+ *  the data to a coarser unit. This interacts with 'local', slightly,
+ *  in order to form a date unit string as a local time, the casting
+ *  must be unsafe.
+ *
+ *  Returns 0 on success, -1 on failure (for example if the output
+ *  string was too short).
+ */
+int
+make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, int outlen,
+                    int local, NPY_DATETIMEUNIT base, int tzoffset,
+                    NPY_CASTING casting)
+{
+    npy_datetimestruct dts_local;
+    int timezone_offset = 0;
+
+    char *substr = outstr, sublen = outlen;
+    int tmplen;
+
+    /* Only do local time within a reasonable year range */
+    if ((dts->year <= 1800 || dts->year >= 10000) && tzoffset == -1) {
+        local = 0;
+    }
+
+    /* Automatically detect a good unit */
+    if (base == -1) {
+        base = lossless_unit_from_datetimestruct(dts);
+        /*
+         * If there's a timezone, use at least minutes precision,
+         * and never split up hours and minutes by default
+         */
+        if ((base < NPY_FR_m && local) || base == NPY_FR_h) {
+            base = NPY_FR_m;
+        }
+        /* Don't split up dates by default */
+        else if (base < NPY_FR_D) {
+            base = NPY_FR_D;
+        }
+    }
+    /*
+     * Print weeks with the same precision as days.
+     *
+     * TODO: Could print weeks with YYYY-Www format if the week
+     *       epoch is a Monday.
+     */
+    else if (base == NPY_FR_W) {
+        base = NPY_FR_D;
+    }
+
+    /* Use the C API to convert from UTC to local time */
+    if (local && tzoffset == -1) {
+        if (convert_datetimestruct_utc_to_local(&dts_local, dts,
+                                                &timezone_offset) < 0) {
+            return -1;
+        }
+
+        /* Set dts to point to our local time instead of the UTC time */
+        dts = &dts_local;
+    }
+    /* Use the manually provided tzoffset */
+    else if (local) {
+        /* Make a copy of the npy_datetimestruct we can modify */
+        dts_local = *dts;
+        dts = &dts_local;
+
+        /* Set and apply the required timezone offset */
+        timezone_offset = tzoffset;
+        add_minutes_to_datetimestruct(dts, timezone_offset);
+    }
+
+    /*
+     * Now the datetimestruct data is in the final form for
+     * the string representation, so ensure that the data
+     * is being cast according to the casting rule.
+     */
+    if (casting != NPY_UNSAFE_CASTING) {
+        /* Producing a date as a local time is always 'unsafe' */
+        if (base <= NPY_FR_D && local) {
+            PyErr_SetString(PyExc_TypeError, "Cannot create a local "
+                        "timezone-based date string from a NumPy "
+                        "datetime without forcing 'unsafe' casting");
+            return -1;
+        }
+        /* Only 'unsafe' and 'same_kind' allow data loss */
+        else {
+            NPY_DATETIMEUNIT unitprec;
+
+            unitprec = lossless_unit_from_datetimestruct(dts);
+            if (casting != NPY_SAME_KIND_CASTING && unitprec > base) {
+                PyErr_Format(PyExc_TypeError, "Cannot create a "
+                            "string with unit precision '%s' "
+                            "from the NumPy datetime, which has data at "
+                            "unit precision '%s', "
+                            "requires 'unsafe' or 'same_kind' casting",
+                             _datetime_strings[base],
+                             _datetime_strings[unitprec]);
+                return -1;
+            }
+        }
+    }
+
+    /* YEAR */
+    /*
+     * Can't use PyOS_snprintf, because it always produces a '\0'
+     * character at the end, and NumPy string types are permitted
+     * to have data all the way to the end of the buffer.
+     */
+#ifdef _WIN32
+    tmplen = _snprintf(substr, sublen, "%04" NPY_INT64_FMT, dts->year);
+#else
+    tmplen = snprintf(substr, sublen, "%04" NPY_INT64_FMT, (long int)dts->year);
+#endif
+    /* If it ran out of space or there isn't space for the NULL terminator */
+    if (tmplen < 0 || tmplen > sublen) {
+        goto string_too_short;
+    }
+    substr += tmplen;
+    sublen -= tmplen;
+
+    /* Stop if the unit is years */
+    if (base == NPY_FR_Y) {
+        if (sublen > 0) {
+            *substr = '\0';
+        }
+        return 0;
+    }
+
+    /* MONTH */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = '-';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->month / 10) + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->month % 10) + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is months */
+    if (base == NPY_FR_M) {
+        if (sublen > 0) {
+            *substr = '\0';
+        }
+        return 0;
+    }
+
+    /* DAY */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = '-';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->day / 10) + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->day % 10) + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is days */
+    if (base == NPY_FR_D) {
+        if (sublen > 0) {
+            *substr = '\0';
+        }
+        return 0;
+    }
+
+    /* HOUR */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = 'T';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->hour / 10) + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->hour % 10) + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is hours */
+    if (base == NPY_FR_h) {
+        goto add_time_zone;
+    }
+
+    /* MINUTE */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = ':';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->min / 10) + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->min % 10) + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is minutes */
+    if (base == NPY_FR_m) {
+        goto add_time_zone;
+    }
+
+    /* SECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = ':';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->sec / 10) + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->sec % 10) + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is seconds */
+    if (base == NPY_FR_s) {
+        goto add_time_zone;
+    }
+
+    /* MILLISECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = '.';
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->us / 100000) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->us / 10000) % 10 + '0');
+    if (sublen < 4 ) {
+        goto string_too_short;
+    }
+    substr[3] = (char)((dts->us / 1000) % 10 + '0');
+    substr += 4;
+    sublen -= 4;
+
+    /* Stop if the unit is milliseconds */
+    if (base == NPY_FR_ms) {
+        goto add_time_zone;
+    }
+
+    /* MICROSECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = (char)((dts->us / 100) % 10 + '0');
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->us / 10) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)(dts->us % 10 + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is microseconds */
+    if (base == NPY_FR_us) {
+        goto add_time_zone;
+    }
+
+    /* NANOSECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = (char)((dts->ps / 100000) % 10 + '0');
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->ps / 10000) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->ps / 1000) % 10 + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is nanoseconds */
+    if (base == NPY_FR_ns) {
+        goto add_time_zone;
+    }
+
+    /* PICOSECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = (char)((dts->ps / 100) % 10 + '0');
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->ps / 10) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)(dts->ps % 10 + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is picoseconds */
+    if (base == NPY_FR_ps) {
+        goto add_time_zone;
+    }
+
+    /* FEMTOSECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = (char)((dts->as / 100000) % 10 + '0');
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->as / 10000) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)((dts->as / 1000) % 10 + '0');
+    substr += 3;
+    sublen -= 3;
+
+    /* Stop if the unit is femtoseconds */
+    if (base == NPY_FR_fs) {
+        goto add_time_zone;
+    }
+
+    /* ATTOSECOND */
+    if (sublen < 1 ) {
+        goto string_too_short;
+    }
+    substr[0] = (char)((dts->as / 100) % 10 + '0');
+    if (sublen < 2 ) {
+        goto string_too_short;
+    }
+    substr[1] = (char)((dts->as / 10) % 10 + '0');
+    if (sublen < 3 ) {
+        goto string_too_short;
+    }
+    substr[2] = (char)(dts->as % 10 + '0');
+    substr += 3;
+    sublen -= 3;
+
+add_time_zone:
+    if (local) {
+        /* Add the +/- sign */
+        if (sublen < 1) {
+            goto string_too_short;
+        }
+        if (timezone_offset < 0) {
+            substr[0] = '-';
+            timezone_offset = -timezone_offset;
+        }
+        else {
+            substr[0] = '+';
+        }
+        substr += 1;
+        sublen -= 1;
+
+        /* Add the timezone offset */
+        if (sublen < 1 ) {
+            goto string_too_short;
+        }
+        substr[0] = (char)((timezone_offset / (10*60)) % 10 + '0');
+        if (sublen < 2 ) {
+            goto string_too_short;
+        }
+        substr[1] = (char)((timezone_offset / 60) % 10 + '0');
+        if (sublen < 3 ) {
+            goto string_too_short;
+        }
+        substr[2] = (char)(((timezone_offset % 60) / 10) % 10 + '0');
+        if (sublen < 4 ) {
+            goto string_too_short;
+        }
+        substr[3] = (char)((timezone_offset % 60) % 10 + '0');
+        substr += 4;
+        sublen -= 4;
+    }
+    /* UTC "Zulu" time */
+    else {
+        if (sublen < 1) {
+            goto string_too_short;
+        }
+        substr[0] = 'Z';
+        substr += 1;
+        sublen -= 1;
+    }
+
+    /* Add a NULL terminator, and return */
+    if (sublen > 0) {
+        substr[0] = '\0';
+    }
+
+    return 0;
+
+string_too_short:
+    PyErr_Format(PyExc_RuntimeError,
+                "The string provided for NumPy ISO datetime formatting "
+                "was too short, with length %d",
+                outlen);
+    return -1;
+}
diff --git a/pandas/src/np_datetime_strings.h b/pandas/src/np_datetime_strings.h
new file mode 100644
index 000000000..0226d0aac
--- /dev/null
+++ b/pandas/src/np_datetime_strings.h
@@ -0,0 +1,86 @@
+/*
+ * This is derived from numpy 1.7. See NP_LICENSE.txt
+ */
+
+#ifndef _NPY_PRIVATE__DATETIME_STRINGS_H_
+#define _NPY_PRIVATE__DATETIME_STRINGS_H_
+
+/*
+ * Parses (almost) standard ISO 8601 date strings. The differences are:
+ *
+ * + The date "20100312" is parsed as the year 20100312, not as
+ *   equivalent to "2010-03-12". The '-' in the dates are not optional.
+ * + Only seconds may have a decimal point, with up to 18 digits after it
+ *   (maximum attoseconds precision).
+ * + Either a 'T' as in ISO 8601 or a ' ' may be used to separate
+ *   the date and the time. Both are treated equivalently.
+ * + Doesn't (yet) handle the "YYYY-DDD" or "YYYY-Www" formats.
+ * + Doesn't handle leap seconds (seconds value has 60 in these cases).
+ * + Doesn't handle 24:00:00 as synonym for midnight (00:00:00) tomorrow
+ * + Accepts special values "NaT" (not a time), "Today", (current
+ *   day according to local time) and "Now" (current time in UTC).
+ *
+ * 'str' must be a NULL-terminated string, and 'len' must be its length.
+ * 'unit' should contain -1 if the unit is unknown, or the unit
+ *      which will be used if it is.
+ * 'casting' controls how the detected unit from the string is allowed
+ *           to be cast to the 'unit' parameter.
+ *
+ * 'out' gets filled with the parsed date-time.
+ * 'out_local' gets set to 1 if the parsed time was in local time,
+ *      to 0 otherwise. The values 'now' and 'today' don't get counted
+ *      as local, and neither do UTC +/-#### timezone offsets, because
+ *      they aren't using the computer's local timezone offset.
+ * 'out_bestunit' gives a suggested unit based on the amount of
+ *      resolution provided in the string, or -1 for NaT.
+ * 'out_special' gets set to 1 if the parsed time was 'today',
+ *      'now', or ''/'NaT'. For 'today', the unit recommended is
+ *      'D', for 'now', the unit recommended is 's', and for 'NaT'
+ *      the unit recommended is 'Y'.
+ *
+ * Returns 0 on success, -1 on failure.
+ */
+int
+parse_iso_8601_datetime(char *str, int len,
+                    NPY_DATETIMEUNIT unit,
+                    NPY_CASTING casting,
+                    npy_datetimestruct *out,
+                    npy_bool *out_local,
+                    NPY_DATETIMEUNIT *out_bestunit,
+                    npy_bool *out_special);
+
+/*
+ * Provides a string length to use for converting datetime
+ * objects with the given local and unit settings.
+ */
+int
+get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base);
+
+/*
+ * Converts an npy_datetimestruct to an (almost) ISO 8601
+ * NULL-terminated string.
+ *
+ * If 'local' is non-zero, it produces a string in local time with
+ * a +-#### timezone offset, otherwise it uses timezone Z (UTC).
+ *
+ * 'base' restricts the output to that unit. Set 'base' to
+ * -1 to auto-detect a base after which all the values are zero.
+ *
+ *  'tzoffset' is used if 'local' is enabled, and 'tzoffset' is
+ *  set to a value other than -1. This is a manual override for
+ *  the local time zone to use, as an offset in minutes.
+ *
+ *  'casting' controls whether data loss is allowed by truncating
+ *  the data to a coarser unit. This interacts with 'local', slightly,
+ *  in order to form a date unit string as a local time, the casting
+ *  must be unsafe.
+ *
+ *  Returns 0 on success, -1 on failure (for example if the output
+ *  string was too short).
+ */
+int
+make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, int outlen,
+                    int local, NPY_DATETIMEUNIT base, int tzoffset,
+                    NPY_CASTING casting);
+
+#endif
diff --git a/setup.py b/setup.py
index 47d9a21d9..a80c9b0a7 100755
--- a/setup.py
+++ b/setup.py
@@ -207,8 +207,12 @@ class CleanCommand(Command):
         self.all = True
         self._clean_me = []
         self._clean_trees = []
+        self._clean_exclude = ['np_datetime.c', 'np_datetime_strings.c']
+
         for root, dirs, files in list(os.walk('pandas')):
             for f in files:
+                if f in self._clean_exclude:
+                    continue
                 if os.path.splitext(f)[-1] in ('.pyc', '.so', '.o',
                                                '.pyd', '.c'):
                     self._clean_me.append(pjoin(root, f))
@@ -356,7 +360,8 @@ sandbox_ext = Extension('pandas._sandbox',
 
 datetime_ext = Extension('pandas._datetime',
                          sources=[srcpath('datetime', suffix=suffix),
-                                          'pandas/src/datetime_helper.c'],
+                                          'pandas/src/np_datetime.c',
+                                          'pandas/src/np_datetime_strings.c'],
                          include_dirs=[np.get_include()])
 
 cppsandbox_ext = Extension('pandas._cppsandbox',

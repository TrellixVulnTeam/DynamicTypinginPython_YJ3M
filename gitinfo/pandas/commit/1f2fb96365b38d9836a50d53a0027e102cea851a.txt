commit 1f2fb96365b38d9836a50d53a0027e102cea851a
Author: Chang She <chang@lambdafoundry.com>
Date:   Thu May 10 17:31:55 2012 -0400

    ENH: finishing up DataFrame.replace need to revisit

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f813e22bc..0599814b0 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2655,6 +2655,10 @@ class DataFrame(NDFrame):
             method = com._clean_fill_method(method)
 
             if isinstance(to_replace, dict):
+                if axis == 1:
+                    return self.T.replace(to_replace, method=method,
+                                          limit=limit).T
+
                 rs = self if inplace else self.copy()
                 for k, v in to_replace.iteritems():
                     if k in rs:
@@ -2670,6 +2674,13 @@ class DataFrame(NDFrame):
                                              missing=to_replace)
                     new_blocks.append(newb)
                 new_data = BlockManager(new_blocks, self._data.axes)
+
+                if inplace:
+                    self._data = new_data
+                    return self
+                else:
+                    return self._constructor(new_data)
+
         else:
             # Float type values
             if len(self.columns) == 0:
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 1bd644e9d..574ed8dfc 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -208,11 +208,41 @@ class Block(object):
         return left_block, right_block
 
     def fillna(self, value, inplace=False):
-        return self.replace(np.nan, value, inplace)
+        new_values = self.values if inplace else self.values.copy()
+
+        mask = com.isnull(new_values)
+        np.putmask(new_values, mask, value)
+
+        if inplace:
+            return self
+        else:
+            return make_block(new_values, self.items, self.ref_items)
+
+    def _can_hold_element(self, value):
+        raise NotImplementedError()
+
+    def _try_cast(self, value):
+        raise NotImplementedError()
 
     def replace(self, to_replace, value, inplace=False):
         new_values = self.values if inplace else self.values.copy()
-        lib.replace(new_values, to_replace, value)
+        if self._can_hold_element(value):
+            value = self._try_cast(value)
+
+        if np.isscalar(to_replace):
+            if self._can_hold_element(to_replace):
+                to_replace = self._try_cast(to_replace)
+                lib.replace(new_values, to_replace, value)
+        else:
+            try:
+                to_replace = np.array(to_replace, dtype=self.dtype)
+                lib.replace(new_values, to_replace, value)
+            except:
+                to_replace = np.array(to_replace, dtype=object)
+                for r in to_replace:
+                    if self._can_hold_element(r):
+                        r = self._try_cast(r)
+                        lib.replace(new_values, r, value)
         if inplace:
             return self
         else:
@@ -230,7 +260,7 @@ class Block(object):
         if missing is None:
             mask = None
         else: # todo create faster fill func without masking
-            mask = _mask_missing(values, missing)
+            mask = _mask_missing(transf(values), missing)
 
         if method == 'pad':
             com.pad_2d(transf(values), limit=limit, mask=mask)
@@ -247,10 +277,14 @@ class Block(object):
         return make_block(new_values, self.items, self.ref_items)
 
 def _mask_missing(array, missing_values):
-    missing_values = np.array(list(missing_values), dtype=object)
+    if np.isscalar(missing_values):
+        missing_values = [missing_values]
+
+    missing_values = np.array(missing_values, dtype=object)
     if com.isnull(missing_values).any():
         mask = com.isnull(array)
         missing_values = missing_values[com.notnull(missing_values)]
+
     for v in missing_values:
         if mask is None:
             mask = array == missing_values
@@ -264,6 +298,15 @@ def _mask_missing(array, missing_values):
 class FloatBlock(Block):
     _can_hold_na = True
 
+    def _can_hold_element(self, element):
+        return isinstance(element, (float, int))
+
+    def _try_cast(self, element):
+        try:
+            return float(element)
+        except:
+            return element
+
     def should_store(self, value):
         # when inserting a column should not coerce integers to floats
         # unnecessarily
@@ -278,18 +321,42 @@ class ComplexBlock(Block):
 class IntBlock(Block):
     _can_hold_na = False
 
+    def _can_hold_element(self, element):
+        return isinstance(element, int)
+
+    def _try_cast(self, element):
+        try:
+            return int(element)
+        except:
+            return element
+
     def should_store(self, value):
         return issubclass(value.dtype.type, np.integer)
 
 class BoolBlock(Block):
     _can_hold_na = False
 
+    def _can_hold_element(self, element):
+        return isinstance(element, (int, bool))
+
+    def _try_cast(self, element):
+        try:
+            return bool(element)
+        except:
+            return element
+
     def should_store(self, value):
         return issubclass(value.dtype.type, np.bool_)
 
 class ObjectBlock(Block):
     _can_hold_na = True
 
+    def _can_hold_element(self, element):
+        return True
+
+    def _try_cast(self, element):
+        return element
+
     def should_store(self, value):
         return not issubclass(value.dtype.type,
                               (np.integer, np.floating, np.complexfloating,
@@ -968,7 +1035,12 @@ class BlockManager(object):
         return self.rename_items(f)
 
     def fillna(self, value, inplace=False):
-        return self.replace(np.nan, value, inplace)
+        new_blocks = [b.fillna(value, inplace=inplace)
+                      if b._can_hold_na else b
+                      for b in self.blocks]
+        if inplace:
+            return self
+        return BlockManager(new_blocks, self.axes)
 
     def replace(self, to_replace, value, inplace=False):
         new_blocks = [b.replace(to_replace, value, inplace=inplace)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 434230a52..6b176f328 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2069,10 +2069,9 @@ copy : boolean, default False
         -------
         filled : Series
         """
-        mask = isnull(self.values)
-
         if value is not None:
             result = self.copy() if not inplace else self
+            mask = isnull(self.values)
             np.putmask(result, mask, value)
         else:
             if method is None:  # pragma: no cover
@@ -2130,9 +2129,11 @@ copy : boolean, default False
         replaced : Series
         """
         result = self.copy() if not inplace else self
-        single_val = False
 
         def _rep_one(s, to_rep, v): # replace single value
+            if isinstance(to_rep, (list, np.ndarray)):
+                to_rep = lib.maybe_convert_objects(np.array(to_rep,
+                                                            dtype=object))
             lib.replace(s.values, to_rep, v)
             return s
 
@@ -2145,6 +2146,9 @@ copy : boolean, default False
                 rs = _rep_one(rs, sset, d)
             return rs
 
+        if np.isscalar(to_replace):
+            to_replace = [to_replace]
+
         if isinstance(to_replace, dict):
             return _rep_dict(result, to_replace)
 
diff --git a/pandas/src/codegen_replace.py b/pandas/src/codegen_replace.py
index 12593d8d3..46ac0242d 100644
--- a/pandas/src/codegen_replace.py
+++ b/pandas/src/codegen_replace.py
@@ -144,7 +144,7 @@ def replace(arr, old, new):
         return func(arr, old, new)
     else:
         for o in old:
-            arr = func(arr, o, new)
+            func(arr, o, new)
         return arr
 
 def replace_selector(arr):
diff --git a/pandas/src/replace.pyx b/pandas/src/replace.pyx
index c785518e9..4547d3680 100644
--- a/pandas/src/replace.pyx
+++ b/pandas/src/replace.pyx
@@ -24,7 +24,7 @@ def replace(arr, old, new):
         return func(arr, old, new)
     else:
         for o in old:
-            arr = func(arr, o, new)
+            func(arr, o, new)
         return arr
 
 def replace_selector(arr):
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 50eb07d62..03644d809 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -1,5 +1,6 @@
 cimport numpy as np
 cimport cython
+import numpy as np
 
 from numpy cimport *
 from numpy cimport NPY_INT32 as NPY_int32
@@ -7,6 +8,26 @@ from numpy cimport NPY_INT64 as NPY_int64
 from numpy cimport NPY_FLOAT32 as NPY_float32
 from numpy cimport NPY_FLOAT64 as NPY_float64
 
+int32 = np.dtype(np.int32)
+int64 = np.dtype(np.int64)
+float32 = np.dtype(np.float32)
+float64 = np.dtype(np.float64)
+
+cdef np.int32_t MINint32 = np.iinfo(np.int32).min
+cdef np.int64_t MINint64 = np.iinfo(np.int64).min
+cdef np.float32_t MINfloat32 = np.NINF
+cdef np.float64_t MINfloat64 = np.NINF
+
+cdef np.int32_t MAXint32 = np.iinfo(np.int32).max
+cdef np.int64_t MAXint64 = np.iinfo(np.int64).max
+cdef np.float32_t MAXfloat32 = np.inf
+cdef np.float64_t MAXfloat64 = np.inf
+
+
+cdef extern from "numpy/arrayobject.h":
+    cdef enum NPY_TYPES:
+        NPY_intp "NPY_INTP"
+
 from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
                       PyDict_Contains, PyDict_Keys,
                       Py_INCREF, PyTuple_SET_ITEM,
@@ -15,10 +36,10 @@ from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
 from cpython cimport PyFloat_Check
 cimport cpython
 
-import numpy as np
 isnan = np.isnan
 cdef double NaN = <double> np.NaN
 cdef double nan = NaN
+cdef double NAN = nan
 
 from datetime import datetime as pydatetime
 
@@ -671,7 +692,7 @@ def value_count_int64(ndarray[int64_t] values):
 
 def array_isnull(arr):
     if np.isscalar(arr) or arr is None:
-        return checknull(arr)
+        return _checknull(arr)
     if arr.dtype.kind in ('O', 'S'):
         # Working around NumPy ticket 1542
         shape = arr.shape
@@ -685,19 +706,50 @@ def array_isnull(arr):
         result = -np.isfinite(arr)
     return result
 
+def typed_null_check(obj, arr):
+    if np.isscalar(arr) or arr is None:
+        return _checknull(obj)
+    if arr.dtype.kind in ('O', 'S'):
+        # Working around NumPy ticket 1542
+        if np.isscalar(obj):
+            result = isnullobj(np.array([obj], dtype=object))
+        else:
+            result = isnullobj(np.array(obj, dtype=object))
+    elif arr.dtype == np.datetime64:
+        # this is the NaT pattern
+        result = obj == NaT
+    else:
+        result = -np.isfinite(obj)
+    return result
+
 def slow_replace(arr, old, new):
     "Slow replace (inplace) used for unaccelerated ndim/dtype combinations."
-    if type(arr) is not np.ndarray:
+    if not isinstance(arr, np.ndarray):
         raise TypeError("`arr` must be a numpy array.")
-    if not issubclass(arr.dtype.type, np.inexact):
-        if int(old) != old:
-            raise ValueError("Cannot safely cast `old` to int.")
-        if int(new) != new:
-            raise ValueError("Cannot safely cast `new` to int.")
-    if array_isnull(old):
-        mask = array_isnull(arr)
+
+    if np.isscalar(old) or old is None:
+        if typed_null_check(old, arr):
+            mask = array_isnull(arr)
+        else:
+            if arr.dtype == np.datetime64:
+                mask = np.array(arr).view('i8') == old
+            else:
+                mask = arr == old
     else:
-        mask = arr == old
+        mask = None
+        old_null = typed_null_check(old, arr)
+        others = old[-old_null]
+        if len(others) > 1:
+            mask = ismember(arr, set(others))
+        elif len(others) == 1:
+            if arr.dtype == np.datetime64:
+                mask = np.array(arr).view('i8') == others[0]
+            else:
+                mask = arr == others[0]
+        if old_null.any():
+            null_mask = array_isnull(arr)
+            mask = null_mask if mask is None else (null_mask | mask)
+
     np.putmask(arr, mask, new)
 
 include "hashtable.pyx"
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 5b24f157d..0b353ea8e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3372,23 +3372,116 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expected = df.astype(float).fillna(axis=1)
         assert_frame_equal(result, expected)
 
+    def test_replace_inplace(self):
+        self.tsframe['A'][:5] = nan
+        self.tsframe['A'][-5:] = nan
+
+        tsframe = self.tsframe.copy()
+        tsframe.replace(nan, 0, inplace=True)
+        assert_frame_equal(tsframe, self.tsframe.fillna(0))
+
+        tsframe = self.tsframe.copy()
+        tsframe.replace(nan, method='pad', inplace=True)
+        assert_frame_equal(tsframe, self.tsframe.fillna(method='pad'))
+
+        # mixed type
+        self.mixed_frame['foo'][5:20] = nan
+        self.mixed_frame['A'][-10:] = nan
+
+        result = self.mixed_frame.replace(np.nan, 0)
+        expected = self.mixed_frame.fillna(value=0)
+        assert_frame_equal(result, expected)
+
     def test_replace(self):
-        pass
+        self.tsframe['A'][:5] = nan
+        self.tsframe['A'][-5:] = nan
 
-    def test_replace_inplace(self):
-        pass
+        zero_filled = self.tsframe.replace(nan, -1e8)
+        assert_frame_equal(zero_filled, self.tsframe.fillna(-1e8))
 
-    def test_replace_method(self):
-        pass
+        assert_frame_equal(zero_filled.replace(-1e8, nan), self.tsframe)
 
-    def test_replace_col_dict(self):
-        pass
+        padded = self.tsframe.replace(nan, method='pad')
+        assert_frame_equal(padded, self.tsframe.fillna(method='pad'))
+
+        # mixed type
+        self.mixed_frame['foo'][5:20] = nan
+        self.mixed_frame['A'][-10:] = nan
+
+        result = self.mixed_frame.replace(np.nan, -1e8)
+        expected = self.mixed_frame.fillna(value=-1e8)
+        assert_frame_equal(result, expected)
+        assert_frame_equal(result.replace(-1e8, nan), self.mixed_frame)
+
+    def test_replace_input_formats(self):
+        to_rep = {'A' : np.nan, 'B' : 0, 'C' : ''}
+        values = {'A' : 0, 'B' : -1, 'C' : 'missing'}
+        df = DataFrame({'A' : [np.nan, 0, np.inf], 'B' : [0, 2, 5],
+                        'C' : ['', 'asdf', 'fd']})
+        filled = df.replace(to_rep, values)
+        expected = {}
+        for k, v in df.iteritems():
+            expected[k] = v.replace(to_rep[k], values[k])
+        assert_frame_equal(filled, DataFrame(expected))
+
+        values = {'A' : 0, 'B' : -1, 'C' : 'missing'}
+        df = DataFrame({'A' : [np.nan, 0, np.nan], 'B' : [0, 2, 5],
+                        'C' : ['', 'asdf', 'fd']})
+        filled = df.replace(np.nan, values)
+        expected = {}
+        for k, v in df.iteritems():
+            expected[k] = v.replace(np.nan, values[k])
+        assert_frame_equal(filled, DataFrame(expected))
+
+        to_rep = [np.nan, 0, '']
+        values = [-2, -1, 'missing']
+        result = df.replace(to_rep, values)
+        expected = df.copy()
+        for i in range(len(to_rep)):
+            expected.replace(to_rep[i], values[i], inplace=True)
+        assert_frame_equal(result, expected)
+
+        to_rep = [np.nan, 0, '']
+        result = df.replace(to_rep, -1)
+        expected = df.copy()
+        for i in range(len(to_rep)):
+            expected.replace(to_rep[i], -1, inplace=True)
+        assert_frame_equal(result, expected)
 
     def test_replace_axis(self):
-        pass
+        self.tsframe['A'][:5] = nan
+        self.tsframe['A'][-5:] = nan
+
+        zero_filled = self.tsframe.replace(nan, 0, axis=1)
+        assert_frame_equal(zero_filled, self.tsframe.fillna(0, axis=1))
+
+        padded = self.tsframe.replace(nan, method='pad', axis=1)
+        assert_frame_equal(padded, self.tsframe.fillna(method='pad', axis=1))
+
+        # mixed type
+        self.mixed_frame['foo'][5:20] = nan
+        self.mixed_frame['A'][-10:] = nan
+
+        result = self.mixed_frame.replace(np.nan, -1e8, axis=1)
+        expected = self.mixed_frame.fillna(value=-1e8, axis=1)
+        assert_frame_equal(result, expected)
 
     def test_replace_limit(self):
-        pass
+        padded = self.tsframe.replace(nan, method='pad', limit=2)
+        assert_frame_equal(padded, self.tsframe.fillna(method='pad',
+                                                       limit=2))
+
+        bfilled = self.tsframe.replace(nan, method='bfill', limit=2)
+        assert_frame_equal(padded, self.tsframe.fillna(method='bfill',
+                                                       limit=2))
+
+        padded = self.tsframe.replace(nan, method='pad', axis=1, limit=2)
+        assert_frame_equal(padded, self.tsframe.fillna(method='pad',
+                                                       axis=1, limit=2))
+
+        bfill = self.tsframe.replace(nan, method='bfill', axis=1, limit=2)
+        assert_frame_equal(padded, self.tsframe.fillna(method='bfill',
+                                                       axis=1, limit=2))
 
     def test_truncate(self):
         offset = datetools.bday
@@ -5459,31 +5552,6 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         df = DataFrame([1, 2, 3])
         self.failUnlessRaises(ValueError, lambda: bool(df))
 
-    def test_replace(self):
-        N = 100
-        df = DataFrame(np.fabs(np.random.randn(len(N), 5)),
-                       index=tm.makeDataIndex(N))
-        df.ix[:5, 0] = np.nan
-        df[6:10, 1] = 'foo'
-        df[20:30, 2] = 'bar'
-
-        rs = df.replace([np.nan, 'foo', 'bar'], -1)
-        self.assert_((rs.ix[:5, 0] == -1).all())
-        self.assert_((rs.ix[6:10, 1] == -1).all())
-        self.assert_((rs.ix[20:30, 2] == -1).all())
-        self.assert_((df >= 0).all())
-
-        rs = df.replace({np.nan : -1, 'foo' : -2, 'bar' : -3})
-        self.assert_((rs.ix[:5, 0] == -1).all())
-        self.assert_((rs.ix[6:10, 1] == -2).all())
-        self.assert_((rs.ix[20:30, 2] == -3).all())
-        self.assert_((df >= 0).all())
-
-        df.replace([np.nan, 'foo', 'bar'], -1, inplace=True)
-        self.assert_((df.ix[:5, 0] == -1).all())
-        self.assert_((df.ix[6:10, 1] == -1).all())
-        self.assert_((df.ix[20:30, 2] == -1).all())
-
 if __name__ == '__main__':
     # unittest.main()
     import nose
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 8a2652f75..e1441e9d7 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -1294,43 +1294,6 @@ class TestLongPanel(unittest.TestCase):
         # corner case, empty
         df = pivot(np.array([]), np.array([]), np.array([]))
 
-    def test_replace(self):
-        N = 100
-        df1 = DataFrame(np.fabs(np.random.randn(len(N), 5)),
-                        index=tm.makeDataIndex(N))
-        df1.ix[:5, 0] = np.nan
-        df1[6:10, 1] = 'foo'
-        df1[20:30, 2] = 'bar'
-
-        df2 = DataFrame(np.fabs(np.random.randn(len(N), 5)),
-                       index=tm.makeDataIndex(N))
-        df2.ix[:5, 0] = 'bar'
-        df2[6:10, 1] = np.nan
-        df2[20:30, 2] = 'foo'
-
-        panel = Panel({'x' : df1, 'y' : df2})
-        rs = panel.replace([np.nan, 'foo', 'bar'], -1)
-        self.assert_((rs.ix[:, :5, 0] == -1).all())
-        self.assert_((rs.ix[:, 6:10, 1] == -1).all())
-        self.assert_((rs.ix[:, 20:30, 2] == -1).all())
-        self.assert_((panel >= 0).all())
-
-        rs = panel.replace({np.nan : -1, 'foo' : -2, 'bar' : -3})
-        self.assert_((rs.ix[0, :5, 0] == -1).all())
-        self.assert_((rs.ix[0, 6:10, 1] == -2).all())
-        self.assert_((rs.ix[0, 20:30, 2] == -3).all())
-
-        self.assert_((rs.ix[1, :5, 0] == -3).all())
-        self.assert_((rs.ix[1, 6:10, 1] == -1).all())
-        self.assert_((rs.ix[1, 20:30, 2] == -2).all())
-
-        self.assert_((panel >= 0).all())
-
-        panel.replace([np.nan, 'foo', 'bar'], -1, inplace=True)
-        self.assert_((panel.ix[:5, 0] == -1).all())
-        self.assert_((panel.ix[6:10, 1] == -1).all())
-        self.assert_((panel.ix[20:30, 2] == -1).all())
-
 def test_monotonic():
     pos = np.array([1, 2, 3, 5])
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 7adda04cc..bfcee71a9 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -15,6 +15,7 @@ from pandas import (Index, Series, TimeSeries, DataFrame, isnull, notnull,
                     bdate_range, date_range)
 from pandas.core.index import MultiIndex
 from pandas.tseries.index import Timestamp, DatetimeIndex
+import pandas._tseries as lib
 
 import pandas.core.datetools as datetools
 import pandas.core.nanops as nanops
@@ -2472,6 +2473,72 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         expected = x.fillna(value=0)
         assert_series_equal(y2, expected)
 
+    def test_replace(self):
+        N = 100
+        ser = Series(np.random.randn(N))
+        ser[0:4] = np.nan
+        ser[6:10] = 0
+
+        # replace list with a single value
+        rs = ser.replace([np.nan], -1, inplace=True)
+        exp = ser.fillna(-1)
+        assert_series_equal(rs, exp)
+
+        rs = ser.replace(0., np.nan)
+        ser[ser == 0.] = np.nan
+        assert_series_equal(rs, ser)
+
+        ser = Series(np.fabs(np.random.randn(N)), tm.makeDateIndex(N),
+                     dtype=object)
+        ser[:5] = np.nan
+        ser[6:10] = 'foo'
+        ser[20:30] = 'bar'
+
+        # replace list with a single value
+        rs = ser.replace([np.nan, 'foo', 'bar'], -1)
+
+        self.assert_((rs[:5] == -1).all())
+        self.assert_((rs[6:10] == -1).all())
+        self.assert_((rs[20:30] == -1).all())
+        self.assert_((isnull(ser[:5])).all())
+
+        # replace with different values
+        rs = ser.replace({np.nan : -1, 'foo' : -2, 'bar' : -3})
+
+        self.assert_((rs[:5] == -1).all())
+        self.assert_((rs[6:10] == -2).all())
+        self.assert_((rs[20:30] == -3).all())
+        self.assert_((isnull(ser[:5])).all())
+
+        # replace with different values with 2 lists
+        rs2 = ser.replace([np.nan, 'foo', 'bar'], [-1, -2, -3])
+        assert_series_equal(rs, rs2)
+
+        # replace with forward fill not considering np.nan missing
+        s2 = ser.copy()
+        s2[5] = np.nan
+        rs3 = s2.replace(['foo', 'bar'])
+        self.assert_(isnull(rs3[6]))
+
+        # replace with back fill considering np.nan as missing
+        rs4 = ser.replace([np.nan, 'foo', 'bar'], method='bfill')
+        assert_almost_equal(rs4[4], ser[5])
+
+        # replace inplace
+        ser.replace([np.nan, 'foo', 'bar'], -1, inplace=True)
+        self.assert_((ser[:5] == -1).all())
+        self.assert_((ser[6:10] == -1).all())
+        self.assert_((ser[20:30] == -1).all())
+
+        ser = Series([np.nan, 0, 'foo', 'bar', np.inf, None, lib.NaT])
+        assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
+        filled = ser.copy()
+        filled[4] = 0
+        assert_series_equal(ser.replace(np.inf, 0), filled)
+
+        ser = Series(self.ts.index)
+        assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
+
     def test_asfreq(self):
         ts = Series([0., 1., 2.], index=[datetime(2009, 10, 30),
                                          datetime(2009, 11, 30),
diff --git a/vb_suite/replace.py b/vb_suite/replace.py
new file mode 100644
index 000000000..bc5397df2
--- /dev/null
+++ b/vb_suite/replace.py
@@ -0,0 +1,24 @@
+from vbench.api import Benchmark
+
+common_setup = """from pandas_vb_common import *
+from datetime import timedelta
+import pandas._tseries as lib
+N = 1000000
+
+try:
+    rng = date_range('1/1/2000', periods=N, freq='min')
+except NameError:
+    rng = DateRange('1/1/2000', periods=N, offset=datetools.Minute())
+    date_range = DateRange
+
+ts = Series(np.random.randn(N), index=rng)
+
+def replace_slow(ser, old, new):
+    lib.slow_replace(ser.values, old, new)
+    return ser
+"""
+
+replace_fillna = Benchmark('ts.fillna(0., inplace=True)', common_setup)
+replace_replacena = Benchmark('ts.replace(np.nan, 0., inplace=True)',
+                              common_setup)
+replace_putmask = Benchmark('replace_slow(ts, np.nan, 0.)', common_setup)

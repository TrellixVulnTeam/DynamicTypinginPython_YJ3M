commit df3224ffa05791179d6e3c546e1f917a9a2a81f0
Author: jreback <jeff@reback.net>
Date:   Fri Sep 26 10:32:39 2014 -0400

    FIX: categorical fixups

diff --git a/doc/source/categorical.rst b/doc/source/categorical.rst
index a5b00bbc4..a4e97a6e8 100644
--- a/doc/source/categorical.rst
+++ b/doc/source/categorical.rst
@@ -41,7 +41,7 @@ operations (additions, divisions, ...) are not possible.
 
 All values of categorical data are either in `categories` or `np.nan`. Order is defined by
 the order of `categories`, not lexical order of the values. Internally, the data structure
-consists of a `categories` array and an integer array of `codes` which point to the real value in 
+consists of a `categories` array and an integer array of `codes` which point to the real value in
 the `categories` array.
 
 The categorical data type is useful in the following cases:
@@ -769,9 +769,3 @@ Use ``copy=True`` to prevent such a behaviour or simply don't reuse `Categorical
     using an int array (e.g. ``np.array([1,2,3,4])``) will exhibit the same behaviour, while using
     a string array (e.g. ``np.array(["a","b","c","a"])``) will not.
 
-
-Future compatibility
-~~~~~~~~~~~~~~~~~~~~
-
-As `Categorical` is not a native `numpy` dtype, the implementation details of
-`Series.cat` can change if such a `numpy` dtype is implemented.
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 9ee001850..ef14897cd 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -643,10 +643,11 @@ class Categorical(PandasObject):
         """
         if not com.is_list_like(removals):
             removals = [removals]
-        not_included = set(removals) - set(self._categories)
+        removals = set(list(removals))
+        not_included = removals - set(self._categories)
         if len(not_included) != 0:
             raise ValueError("removals must all be in old categories: %s" % str(not_included))
-        new_categories = set(self._categories) - set(removals)
+        new_categories = [ c for c in self._categories if c not in removals ]
         return self.set_categories(new_categories, ordered=self.ordered, rename=False,
                                    inplace=inplace)
 

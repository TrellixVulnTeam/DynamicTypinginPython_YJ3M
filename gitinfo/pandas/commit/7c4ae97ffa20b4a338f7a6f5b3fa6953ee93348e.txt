commit 7c4ae97ffa20b4a338f7a6f5b3fa6953ee93348e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 4 13:10:20 2012 -0400

    BUG: port skts_strftime to Cython, hopefully fix mingw32 issues #1360

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 1658383ef..067c662e4 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -112,60 +112,3 @@ cdef extern from "datetime/np_datetime_strings.h":
     int get_datetime_iso_8601_strlen(int local, PANDAS_DATETIMEUNIT base)
 
     # int parse_python_string(object obj, pandas_datetimestruct *out) except -1
-
-cdef extern from "period.h":
-    ctypedef struct date_info:
-        int64_t absdate
-        double abstime
-        double second
-        int minute
-        int hour
-        int day
-        int month
-        int quarter
-        int year
-        int day_of_week
-        int day_of_year
-        int calendar
-
-    ctypedef struct asfreq_info:
-        int from_week_end
-        int to_week_end
-
-        int from_a_year_end
-        int to_a_year_end
-
-        int from_q_year_end
-        int to_q_year_end
-
-    ctypedef int64_t (*freq_conv_func)(int64_t, char, asfreq_info*)
-
-    int64_t asfreq(int64_t dtordinal, int freq1, int freq2, char relation) except INT32_MIN
-    freq_conv_func get_asfreq_func(int fromFreq, int toFreq)
-    void get_asfreq_info(int fromFreq, int toFreq, asfreq_info *af_info)
-
-    int64_t get_period_ordinal(int year, int month, int day,
-                          int hour, int minute, int second,
-                          int freq) except INT32_MIN
-
-    int64_t get_python_ordinal(int64_t period_ordinal, int freq) except INT32_MIN
-
-    char *skts_strftime(int64_t value, int freq, PyObject *args)
-    char *period_to_string(int64_t value, int freq)
-    char *period_to_string2(int64_t value, int freq, char *fmt)
-
-    int get_date_info(int64_t ordinal, int freq, date_info *dinfo) except INT32_MIN
-    double getAbsTime(int, int64_t, int64_t)
-
-    int pyear(int64_t ordinal, int freq) except INT32_MIN
-    int pqyear(int64_t ordinal, int freq) except INT32_MIN
-    int pquarter(int64_t ordinal, int freq) except INT32_MIN
-    int pmonth(int64_t ordinal, int freq) except INT32_MIN
-    int pday(int64_t ordinal, int freq) except INT32_MIN
-    int pweekday(int64_t ordinal, int freq) except INT32_MIN
-    int pday_of_week(int64_t ordinal, int freq) except INT32_MIN
-    int pday_of_year(int64_t ordinal, int freq) except INT32_MIN
-    int pweek(int64_t ordinal, int freq) except INT32_MIN
-    int phour(int64_t ordinal, int freq) except INT32_MIN
-    int pminute(int64_t ordinal, int freq) except INT32_MIN
-    int psecond(int64_t ordinal, int freq) except INT32_MIN
diff --git a/pandas/src/numpy_helper.h b/pandas/src/numpy_helper.h
index e2f772ad4..053cd8aea 100644
--- a/pandas/src/numpy_helper.h
+++ b/pandas/src/numpy_helper.h
@@ -116,6 +116,15 @@ get_c_string(PyObject* obj) {
 #endif
 }
 
+PANDAS_INLINE PyObject*
+char_to_string(char* data) {
+#if PY_VERSION_HEX >= 0x03000000
+    return PyUnicode_FromString(data);
+#else
+    return PyString_FromString(data);
+#endif
+}
+
 // PANDAS_INLINE int
 // is_string(PyObject* obj) {
 // #if PY_VERSION_HEX >= 0x03000000
diff --git a/pandas/src/period.c b/pandas/src/period.c
index d46fdde86..5745f02e5 100644
--- a/pandas/src/period.c
+++ b/pandas/src/period.c
@@ -1162,190 +1162,54 @@ char *str_replace(const char *s, const char *old, const char *new) {
 // function to generate a nice string representation of the period
 // object, originally from DateObject_strftime
 
-char *skts_strftime(npy_int64 ordinal, int freq, PyObject *args)
-{
-    char *orig_fmt_str, *fmt_str;
-    char *result;
+char* c_strftime(struct date_info *tmp, char *fmt) {
+    struct tm c_date;
+    char* result;
+    struct date_info dinfo = *tmp;
+    int result_len = strlen(fmt) + 50;
+
+    c_date.tm_sec = (int)dinfo.second;
+    c_date.tm_min = dinfo.minute;
+    c_date.tm_hour = dinfo.hour;
+    c_date.tm_mday = dinfo.day;
+    c_date.tm_mon = dinfo.month - 1;
+    c_date.tm_year = dinfo.year - 1900;
+    c_date.tm_wday = (dinfo.day_of_week + 1) % 7;
+    c_date.tm_yday = dinfo.day_of_year - 1;
+    c_date.tm_isdst = -1;
 
-    int num_extra_fmts = 3;
+    result = malloc(result_len * sizeof(char));
 
-    char extra_fmts[3][2][10] = {{"%q", "^`AB`^"},
-                                 {"%f", "^`CD`^"},
-                                 {"%F", "^`EF`^"}};
+    strftime(result, result_len, fmt, &c_date);
 
-    int extra_fmts_found[3] = {0,0,0};
-    int extra_fmts_found_one = 0;
-    struct tm c_date;
-    struct date_info tempDate;
-    npy_int64 absdate, daily_ord;
-    double abstime;
-    int i, result_len;
-    PyObject *py_result;
+    return result;
+}
 
-    npy_int64 (*toDaily)(npy_int64, char, asfreq_info*) = NULL;
+int get_yq(npy_int64 ordinal, int freq, int *quarter, int *year) {
     asfreq_info af_info;
-
-    if (!PyArg_ParseTuple(args, "s:strftime(fmt)", &orig_fmt_str))
-        return NULL;
+    int qtr_freq;
+    npy_int64 daily_ord;
+    npy_int64 (*toDaily)(npy_int64, char, asfreq_info*) = NULL;
 
     toDaily = get_asfreq_func(freq, FR_DAY);
     get_asfreq_info(freq, FR_DAY, &af_info);
 
     daily_ord = toDaily(ordinal, 'E', &af_info);
-    abstime = get_abs_time(freq, daily_ord, ordinal);
-
-	if (abstime < 0) {
-		abstime += 86400;
-		daily_ord -= 1;
-	}
-
-	/* printf("daily_ord: %d, abstime: %f \n", (int) daily_ord, abstime); */
-
-    if(dInfoCalc_SetFromAbsDateTime(&tempDate, daily_ord + ORD_OFFSET, abstime,
-                                    GREGORIAN_CALENDAR)) return NULL;
-
-    // populate standard C date struct with info from our date_info struct
-    c_date.tm_sec = (int)tempDate.second;
-    c_date.tm_min = tempDate.minute;
-    c_date.tm_hour = tempDate.hour;
-    c_date.tm_mday = tempDate.day;
-    c_date.tm_mon = tempDate.month - 1;
-    c_date.tm_year = tempDate.year - 1900;
-    c_date.tm_wday = (tempDate.day_of_week + 1) % 7;
-    c_date.tm_yday = tempDate.day_of_year - 1;
-    c_date.tm_isdst = -1;
-
-    result_len = strlen(orig_fmt_str) + 50;
-    if ((result = PyArray_malloc(result_len * sizeof(char))) == NULL) {
-        return (char*)PyErr_NoMemory();
-    }
-
-    fmt_str = orig_fmt_str;
-
-    // replace any special format characters with their place holder
-    for(i=0; i < num_extra_fmts; i++) {
-        char *special_loc;
-        if ((special_loc = strstr(fmt_str,extra_fmts[i][0])) != NULL) {
-            char *tmp_str = fmt_str;
-            fmt_str = str_replace(fmt_str, extra_fmts[i][0],
-                                           extra_fmts[i][1]);
-            /* only free the previous loop value if this is not the first
-               special format string found */
-            if (extra_fmts_found_one) { free(tmp_str); }
 
-            if (fmt_str == NULL) {return NULL;}
+    if (get_freq_group(freq) == FR_QTR) {
+        qtr_freq = freq;
+    } else { qtr_freq = FR_QTR; }
+    get_asfreq_info(FR_DAY, qtr_freq, &af_info);
 
-            extra_fmts_found[i] = 1;
-            extra_fmts_found_one = 1;
-        }
-    }
+    if(DtoQ_yq(daily_ord, &af_info, year, quarter) == INT_ERR_CODE)
+        return -1;
 
-    strftime(result, result_len, fmt_str, &c_date);
-    if (extra_fmts_found_one) { free(fmt_str); }
-
-    // replace any place holders with the appropriate value
-    for(i=0; i < num_extra_fmts; i++) {
-        if (extra_fmts_found[i]) {
-            char *tmp_str = result;
-            char *extra_str;
-
-            if (strcmp(extra_fmts[i][0], "%q") == 0 ||
-                strcmp(extra_fmts[i][0], "%f") == 0 ||
-                strcmp(extra_fmts[i][0], "%F") == 0) {
-
-                asfreq_info af_info;
-                int qtr_freq, year, quarter, year_len;
-
-                if (get_freq_group(freq) == FR_QTR) {
-                    qtr_freq = freq;
-                } else { qtr_freq = FR_QTR; }
-                get_asfreq_info(FR_DAY, qtr_freq, &af_info);
-
-                if(DtoQ_yq(daily_ord, &af_info, &year, &quarter) == INT_ERR_CODE)
-                { return NULL; }
-
-                if(strcmp(extra_fmts[i][0], "%q") == 0) {
-                    if ((extra_str = PyArray_malloc(2 * sizeof(char))) == NULL) {
-                        free(tmp_str);
-                        return (char *)PyErr_NoMemory();
-                    }
-                    sprintf(extra_str, "%i", quarter);
-                } else {
-                    if ((qtr_freq % 1000) > 12) { year -= 1; }
-
-                    if (strcmp(extra_fmts[i][0], "%f") == 0) {
-                        year_len = 2;
-                        year = year % 100;
-                    } else { year_len = 4; }
-
-                    if ((extra_str = PyArray_malloc((year_len+1) * sizeof(char))) == NULL) {
-                        free(tmp_str);
-                        return (char *)PyErr_NoMemory();
-                    }
-
-                    if (year_len == 2 && year < 10) {
-                        sprintf(extra_str, "0%i", year);
-                    } else { sprintf(extra_str, "%i", year); }
-                }
-
-            } else {
-                PyErr_SetString(PyExc_RuntimeError,"Unrecognized format string");
-                return NULL;
-            }
+    return 0;
+}
 
-            result = str_replace(result, extra_fmts[i][1], extra_str);
-            free(tmp_str);
-            free(extra_str);
-            if (result == NULL) { return NULL; }
-        }
-    }
 
-    return result;
-}
 
-char *period_to_string(npy_int64 value, int freq)
-{
-    int freq_group = get_freq_group(freq);
-    PyObject *string_arg;
-    char *retval;
-
-    string_arg = NULL;
-    if (freq_group == FR_UND) {
-        int digits = log10(value) + 1;
-        if ((retval = PyArray_malloc(digits * sizeof(char))) == NULL) {
-            return (char *)PyErr_NoMemory();
-        }
-        sprintf(retval, "%ld", (long int) value);
-        return retval;
-    }
-    else if (freq_group == FR_ANN) { string_arg = Py_BuildValue("(s)", "%Y"); }
-    else if (freq_group == FR_QTR) { string_arg = Py_BuildValue("(s)", "%FQ%q"); }
-    else if (freq_group == FR_MTH) { string_arg = Py_BuildValue("(s)", "%b-%Y"); }
-    else if (freq_group == FR_DAY ||
-             freq_group == FR_BUS ||
-             freq_group == FR_WK) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y"); }
-    else if (freq_group == FR_HR) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:00"); }
-    else if (freq_group == FR_MIN) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M"); }
-    else if (freq_group == FR_SEC) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M:%S"); }
-
-    if (string_arg == NULL) { return (char *)NULL; }
-
-    retval = skts_strftime(value, freq, string_arg);
-    Py_DECREF(string_arg);
-
-    return retval;
-}
 
-char *period_to_string2(npy_int64 value, int freq, char *fmt)
-{
-    PyObject *string_arg;
-    char *retval;
-    string_arg = Py_BuildValue("(s)", fmt);
-    if (string_arg == NULL) { return (char *)NULL; }
-    retval = skts_strftime(value, freq, string_arg);
-    Py_DECREF(string_arg);
-    return retval;
-}
 
 static int _quarter_year(npy_int64 ordinal, int freq, int *year, int *quarter) {
     asfreq_info af_info;
diff --git a/pandas/src/period.h b/pandas/src/period.h
index 1ece756b8..6febcfd23 100644
--- a/pandas/src/period.h
+++ b/pandas/src/period.h
@@ -135,10 +135,6 @@ npy_int64 get_period_ordinal(int year, int month, int day,
 
 npy_int64 get_python_ordinal(npy_int64 period_ordinal, int freq);
 
-char *skts_strftime(npy_int64 value, int freq, PyObject *args);
-char *period_to_string(npy_int64 value, int freq);
-char *period_to_string2(npy_int64 value, int freq, char *fmt);
-
 int get_date_info(npy_int64 ordinal, int freq, struct date_info *dinfo);
 freq_conv_func get_asfreq_func(int fromFreq, int toFreq);
 void get_asfreq_info(int fromFreq, int toFreq, asfreq_info *af_info);
@@ -155,6 +151,9 @@ int pweek(npy_int64 ordinal, int freq);
 int phour(npy_int64 ordinal, int freq);
 int pminute(npy_int64 ordinal, int freq);
 int psecond(npy_int64 ordinal, int freq);
+
 double getAbsTime(int freq, npy_int64 dailyDate, npy_int64 originalDate);
+char *c_strftime(struct date_info *dinfo, char *fmt);
+int get_yq(int64_t ordinal, int freq, int *quarter, int *year);
 
 #endif
diff --git a/pandas/src/plib.pyx b/pandas/src/plib.pyx
index f41fa0dba..c7317ceb0 100644
--- a/pandas/src/plib.pyx
+++ b/pandas/src/plib.pyx
@@ -1,10 +1,13 @@
 # cython: profile=False
+
 cimport numpy as np
 import numpy as np
 
 from numpy cimport int32_t, int64_t, import_array, ndarray
 from cpython cimport *
 
+from libc.stdlib cimport free
+
 # this is our datetime.pxd
 from datetime cimport *
 from util cimport is_integer_object, is_datetime64_object
@@ -21,6 +24,62 @@ import_array()
 # import datetime C API
 PyDateTime_IMPORT
 
+
+cdef extern from "period.h":
+    ctypedef struct date_info:
+        int64_t absdate
+        double abstime
+        double second
+        int minute
+        int hour
+        int day
+        int month
+        int quarter
+        int year
+        int day_of_week
+        int day_of_year
+        int calendar
+
+    ctypedef struct asfreq_info:
+        int from_week_end
+        int to_week_end
+
+        int from_a_year_end
+        int to_a_year_end
+
+        int from_q_year_end
+        int to_q_year_end
+
+    ctypedef int64_t (*freq_conv_func)(int64_t, char, asfreq_info*)
+
+    int64_t asfreq(int64_t dtordinal, int freq1, int freq2, char relation) except INT32_MIN
+    freq_conv_func get_asfreq_func(int fromFreq, int toFreq)
+    void get_asfreq_info(int fromFreq, int toFreq, asfreq_info *af_info)
+
+    int64_t get_period_ordinal(int year, int month, int day,
+                          int hour, int minute, int second,
+                          int freq) except INT32_MIN
+
+    int64_t get_python_ordinal(int64_t period_ordinal, int freq) except INT32_MIN
+
+    int get_date_info(int64_t ordinal, int freq, date_info *dinfo) except INT32_MIN
+    double getAbsTime(int, int64_t, int64_t)
+
+    int pyear(int64_t ordinal, int freq) except INT32_MIN
+    int pqyear(int64_t ordinal, int freq) except INT32_MIN
+    int pquarter(int64_t ordinal, int freq) except INT32_MIN
+    int pmonth(int64_t ordinal, int freq) except INT32_MIN
+    int pday(int64_t ordinal, int freq) except INT32_MIN
+    int pweekday(int64_t ordinal, int freq) except INT32_MIN
+    int pday_of_week(int64_t ordinal, int freq) except INT32_MIN
+    int pday_of_year(int64_t ordinal, int freq) except INT32_MIN
+    int pweek(int64_t ordinal, int freq) except INT32_MIN
+    int phour(int64_t ordinal, int freq) except INT32_MIN
+    int pminute(int64_t ordinal, int freq) except INT32_MIN
+    int psecond(int64_t ordinal, int freq) except INT32_MIN
+    char *c_strftime(date_info *dinfo, char *fmt)
+    int get_yq(int64_t ordinal, int freq, int *quarter, int *year)
+
 # Period logic
 #----------------------------------------------------------------------
 
@@ -160,27 +219,84 @@ cpdef int64_t period_ordinal_to_dt64(int64_t ordinal, int freq):
 
     return pandas_datetimestruct_to_datetime(PANDAS_FR_ns, &dts)
 
-def period_ordinal_to_string(int64_t value, int freq):
+def period_format(int64_t value, int freq, object fmt=None):
+    cdef:
+        int freq_group
+
+    if fmt is None:
+        freq_group = (freq // 1000) * 1000
+        if freq_group == 1000: # FR_ANN
+            fmt = b'%Y'
+        elif freq_group == 2000: # FR_QTR
+            fmt = b'%FQ%q'
+        elif freq_group == 3000: # FR_MTH
+            fmt = b'%b-Y'
+        elif (freq_group == 4000 # WK
+              or freq_group == 5000 # BUS
+              or freq_group == 6000): # DAY
+            fmt = b'%d-%b-%Y'
+        elif freq_group == 7000: # HR
+            fmt = b'%d-%b-%Y %H:00'
+        elif freq_group == 8000: # MIN
+            fmt = b'%d-%b-%Y %H:%M'
+        elif freq_group == 9000: # SEC
+            fmt = b'%d-%b-%Y %H:%M:%S'
+        else:
+            raise ValueError('Unknown freq: %d' % freq)
+
+    return _period_strftime(value, freq, fmt)
+
+
+cdef list extra_fmts = [(b"%q", b"^`AB`^"),
+                        (b"%f", b"^`CD`^"),
+                        (b"%F", b"^`EF`^")]
+
+cdef list str_extra_fmts = ["^`AB`^", "^`CD`^", "^`EF`^"]
+
+cdef _period_strftime(int64_t value, int freq, object fmt):
     cdef:
-        char *ptr
+        Py_ssize_t i
+        date_info dinfo
+        char *formatted
+        object pat, repl, result
+        list found_pat = [False] * len(extra_fmts)
+        int year, quarter
 
-    ptr = period_to_string(value, freq)
+    if PyUnicode_Check(fmt):
+        fmt = fmt.encode('utf-8')
 
-    if ptr == NULL:
-        raise ValueError("Could not create string from ordinal '%s'" % value)
+    get_date_info(value, freq, &dinfo)
+    for i in range(len(extra_fmts)):
+        pat = extra_fmts[i][0]
+        repl = extra_fmts[i][1]
+        if pat in fmt:
+            fmt = fmt.replace(pat, repl)
+            found_pat[i] = True
 
-    return <object> ptr
+    formatted = c_strftime(&dinfo, <char*> fmt)
 
-def period_strftime(int64_t value, int freq, object fmt):
-    cdef:
-        char *ptr
+    result = util.char_to_string(formatted)
+    free(formatted)
+
+    for i in range(len(extra_fmts)):
+        if found_pat[i]:
+            if get_yq(value, freq, &quarter, &year) < 0:
+                raise ValueError('Unable to get quarter and year')
 
-    ptr = period_to_string2(value, freq, <char*>fmt)
+            if i == 0:
+                repl = '%d' % quarter
+            elif i == 1:  # %f, 2-digit year
+                repl = '%.2d' % (year % 100)
+            elif i == 2:
+                repl = '%d' % year
 
-    if ptr == NULL:
-        raise ValueError("Could not create string with fmt '%s'" % fmt)
+            result = result.replace(str_extra_fmts[i], repl)
 
-    return <object> ptr
+    # Py3?
+    if not PyString_Check(result):
+        result = str(result)
+
+    return result
 
 # period accessors
 
diff --git a/pandas/src/util.pxd b/pandas/src/util.pxd
index 3ebd72cc8..694fd9202 100644
--- a/pandas/src/util.pxd
+++ b/pandas/src/util.pxd
@@ -13,6 +13,7 @@ cdef extern from "numpy_helper.h":
     inline object get_value_1d(ndarray, Py_ssize_t)
     inline char *get_c_string(object)
     inline object floatify(object)
+    inline object char_to_string(char*)
 
 cdef inline object get_value_at(ndarray arr, object loc):
     cdef:
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 23a164ec3..622f26d9d 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -255,13 +255,13 @@ class Period(object):
 
     def __repr__(self):
         base, mult = _gfc(self.freq)
-        formatted = plib.period_ordinal_to_string(self.ordinal, base)
+        formatted = plib.period_format(self.ordinal, base)
         freqstr = _freq_mod._reverse_period_code_map[base]
         return "Period('%s', '%s')" % (formatted, freqstr)
 
     def __str__(self):
         base, mult = _gfc(self.freq)
-        formatted = plib.period_ordinal_to_string(self.ordinal, base)
+        formatted = plib.period_format(self.ordinal, base)
         return ("%s" % formatted)
 
     def strftime(self, fmt):
@@ -402,10 +402,7 @@ class Period(object):
             'Jan. 01, 2001 was a Monday'
         """
         base, mult = _gfc(self.freq)
-        if fmt is not None:
-            return plib.period_strftime(self.ordinal, base, fmt)
-        else:
-            return plib.period_ordinal_to_string(self.ordinal, base)
+        plib.period_format(self.ordinal, base, fmt)
 
 
 def _get_date_and_freq(value, freq):
diff --git a/setup.py b/setup.py
index f35921d1f..4d5bb96ae 100755
--- a/setup.py
+++ b/setup.py
@@ -345,6 +345,8 @@ tseries_depends = ['reindex', 'groupby', 'skiplist', 'moments',
                    'reduce', 'stats', 'datetime',
                    'hashtable', 'inference', 'properties', 'join', 'engines']
 
+plib_depends = ['period']
+
 def srcpath(name=None, suffix='.pyx', subdir='src'):
     return pjoin('pandas', subdir, name+suffix)
 
@@ -352,8 +354,12 @@ if suffix == '.pyx':
     tseries_depends = [srcpath(f, suffix='.pyx')
                        for f in tseries_depends]
     tseries_depends.append('pandas/src/util.pxd')
+    plib_depends = [srcpath(f, suffix='.pyx')
+                    for f in plib_depends]
+    plib_depends.append('pandas/src/util.pxd')
 else:
     tseries_depends = []
+    plib_depends = []
 
 algos_ext = Extension('pandas._algos',
                       sources=[srcpath('generated', suffix=suffix)],
@@ -371,7 +377,7 @@ lib_ext = Extension('pandas.lib',
                     )
 
 period_ext = Extension('pandas._period',
-                       depends=tseries_depends + ['pandas/src/numpy_helper.h'],
+                       depends=plib_depends + ['pandas/src/numpy_helper.h'],
                        sources=[srcpath('plib', suffix=suffix),
                                 'pandas/src/datetime/np_datetime.c',
                                 'pandas/src/period.c'],

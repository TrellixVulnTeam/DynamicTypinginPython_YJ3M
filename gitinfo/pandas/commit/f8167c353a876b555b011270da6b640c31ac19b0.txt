commit f8167c353a876b555b011270da6b640c31ac19b0
Author: Chang She <chang@lambdafoundry.com>
Date:   Thu May 31 13:21:26 2012 -0400

    ENH: add dialect keyword to parsers to expose quoting specifications #1363

diff --git a/doc/source/io.rst b/doc/source/io.rst
index e9ffd7a76..b7bc7a7d0 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -5,16 +5,20 @@
 .. ipython:: python
    :suppress:
 
-   import numpy as np
    import os
-   np.random.seed(123456)
-   from pandas import *
+   import csv
    from StringIO import StringIO
-   import pandas.util.testing as tm
+
+   import numpy as np
+   np.random.seed(123456)
    randn = np.random.randn
    np.set_printoptions(precision=4, suppress=True)
+
    import matplotlib.pyplot as plt
    plt.close('all')
+
+   from pandas import *
+   import pandas.util.testing as tm
    clipdf = DataFrame({'A':[1,2,3],'B':[4,5,6],'C':['p','q','r']},
                       index=['x','y','z'])
 
@@ -66,6 +70,8 @@ data into a DataFrame object. They can take a number of arguments:
     cases by "sniffing." The separator may be specified as a regular
     expression; for instance you may use '\s*' to indicate arbitrary
     whitespace.
+  - ``dialect``: string or csv.Dialect instance to expose more ways to specify
+    the file format
   - ``header``: row number to use as the column names, and the start of the data.
     Defaults to 0 (first row); specify None if there is no header row.
   - ``skiprows``: A collection of numbers for rows in the file to skip. Can
@@ -152,6 +158,35 @@ You can also use a list of columns to create a hierarchical index:
 
    read_csv('foo.csv', index_col=[0, 'A'])
 
+The ``dialect`` keyword gives greater flexibility in specifying the file format.
+By default it uses the Excel dialect but you can specify either the dialect name
+or a `csv.Dialect <docs.python.org/library/csv.html#csv.Dialect>`_ instance.
+
+.. ipython:: python
+   :suppress:
+
+   data = ('label1,label2,label3\n'
+           'index1,"a,c,e\n'
+           'index2,b,d,f')
+
+Suppose you had data with unenclosed quotes:
+
+.. ipython:: python
+
+   print data
+
+By default, ``read_csv`` uses the Excel dialect and treats the double quote as
+the quote character, which causes it to fail when it finds a newline before it
+finds the closing double quote.
+
+We can get around this using ``dialect``
+
+.. ipython:: python
+
+   dia = csv.excel()
+   dia.quoting = csv.QUOTE_NONE
+   read_csv(StringIO(data), dialect=dia)
+
 The parsers make every attempt to "do the right thing" and not be very
 fragile. Type inference is a pretty big deal. So if a column can be coerced to
 integer dtype without altering the contents, it will do so. Any non-numeric
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 0942b9800..8b565e10c 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -38,6 +38,9 @@ filepath_or_buffer : string or file handle / StringIO. The string could be
     is expected. For instance, a local file could be
     file ://localhost/path/to/table.csv
 %s
+dialect : string or csv.Dialect instance, default None
+    If None defaults to Excel dialect. Ignored if sep longer than 1 char
+    See csv.Dialect documentation for more details
 header : int, default 0
     Row to use for the column labels of the parsed DataFrame
 skiprows : list-like or integer
@@ -95,7 +98,8 @@ result : DataFrame or TextParser
 
 _csv_sep = """sep : string, default ','
     Delimiter to use. If sep is None, will try to automatically determine
-    this"""
+    this
+"""
 
 _table_sep = """sep : string, default \\t (tab-stop)
     Delimiter to use"""
@@ -189,6 +193,7 @@ def _read(cls, filepath_or_buffer, kwds):
 @Appender(_read_csv_doc)
 def read_csv(filepath_or_buffer,
              sep=',',
+             dialect=None,
              header=0,
              index_col=None,
              names=None,
@@ -221,6 +226,7 @@ def read_csv(filepath_or_buffer,
 @Appender(_read_table_doc)
 def read_table(filepath_or_buffer,
                sep='\t',
+               dialect=None,
                header=0,
                index_col=None,
                names=None,
@@ -356,6 +362,8 @@ class TextParser(object):
     ----------
     data : file-like object or list
     delimiter : separator character to use
+    dialect : str or csv.Dialect instance, default None
+        Ignored if delimiter is longer than 1 character
     names : sequence, default
     header : int, default 0
         Row to use to parse column labels. Defaults to the first row. Prior
@@ -381,7 +389,7 @@ class TextParser(object):
         returns Series if only one column
     """
 
-    def __init__(self, f, delimiter=None, names=None, header=0,
+    def __init__(self, f, delimiter=None, dialect=None, names=None, header=0,
                  index_col=None, na_values=None, thousands=None,
                  comment=None, parse_dates=False, keep_date_col=False,
                  date_parser=None, dayfirst=False,
@@ -413,6 +421,7 @@ class TextParser(object):
 
         self.skip_footer = skip_footer
         self.delimiter = delimiter
+        self.dialect = dialect
         self.verbose = verbose
 
         if converters is not None:
@@ -463,7 +472,13 @@ class TextParser(object):
         if sep is None or len(sep) == 1:
             sniff_sep = True
             # default dialect
-            dia = csv.excel()
+            if self.dialect is None:
+                dia = csv.excel()
+            elif isinstance(self.dialect, basestring):
+                dia = csv.get_dialect(self.dialect)
+            else:
+                dia = self.dialect
+
             if sep is not None:
                 sniff_sep = False
                 dia.delimiter = sep
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 092b7b198..67472b347 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -55,6 +55,26 @@ KORD,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
     def test_read_csv(self):
         pass
 
+    def test_dialect(self):
+        data = """\
+label1,label2,label3
+index1,"a,c,e
+index2,b,d,f
+"""
+
+        dia = csv.excel()
+        dia.quoting = csv.QUOTE_NONE
+        df = read_csv(StringIO(data), dialect=dia)
+
+        data = '''\
+label1,label2,label3
+index1,a,c,e
+index2,b,d,f
+'''
+        exp = read_csv(StringIO(data))
+        exp.replace('a', '"a', inplace=True)
+        assert_frame_equal(df, exp)
+
     def test_1000_sep(self):
         data = """A|B|C
 1|2,334.0|5

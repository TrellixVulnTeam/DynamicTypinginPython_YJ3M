commit 9f94e6a04564e8269b43c5b4e83854d277ea30bd
Author: Sinhrks <sinhrks@gmail.com>
Date:   Fri Jul 22 21:09:11 2016 +0900

    TST: Move plotting related tests to tests/plotting (#13621)
    
    related to #13579

diff --git a/pandas/tests/plotting/__init__.py b/pandas/tests/plotting/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/plotting/common.py b/pandas/tests/plotting/common.py
new file mode 100644
index 000000000..d80eb891c
--- /dev/null
+++ b/pandas/tests/plotting/common.py
@@ -0,0 +1,552 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+import os
+import warnings
+
+from pandas import DataFrame
+from pandas.compat import zip, iteritems, OrderedDict
+from pandas.util.decorators import cache_readonly
+import pandas.core.common as com
+import pandas.util.testing as tm
+from pandas.util.testing import (ensure_clean,
+                                 assert_is_valid_plot_return_object)
+
+import numpy as np
+from numpy import random
+
+import pandas.tools.plotting as plotting
+
+
+"""
+This is a common base class used for various plotting tests
+"""
+
+
+def _skip_if_no_scipy_gaussian_kde():
+    try:
+        from scipy.stats import gaussian_kde  # noqa
+    except ImportError:
+        raise nose.SkipTest("scipy version doesn't support gaussian_kde")
+
+
+def _ok_for_gaussian_kde(kind):
+    if kind in ['kde', 'density']:
+        try:
+            from scipy.stats import gaussian_kde  # noqa
+        except ImportError:
+            return False
+    return True
+
+
+@tm.mplskip
+class TestPlotBase(tm.TestCase):
+
+    def setUp(self):
+
+        import matplotlib as mpl
+        mpl.rcdefaults()
+
+        self.mpl_le_1_2_1 = plotting._mpl_le_1_2_1()
+        self.mpl_ge_1_3_1 = plotting._mpl_ge_1_3_1()
+        self.mpl_ge_1_4_0 = plotting._mpl_ge_1_4_0()
+        self.mpl_ge_1_5_0 = plotting._mpl_ge_1_5_0()
+
+        if self.mpl_ge_1_4_0:
+            self.bp_n_objects = 7
+        else:
+            self.bp_n_objects = 8
+        if self.mpl_ge_1_5_0:
+            # 1.5 added PolyCollections to legend handler
+            # so we have twice as many items.
+            self.polycollection_factor = 2
+        else:
+            self.polycollection_factor = 1
+
+        # common test data
+        from pandas import read_csv
+        path = os.path.join(os.path.dirname(curpath()), 'data', 'iris.csv')
+        self.iris = read_csv(path)
+
+        n = 100
+        with tm.RNGContext(42):
+            gender = np.random.choice(['Male', 'Female'], size=n)
+            classroom = np.random.choice(['A', 'B', 'C'], size=n)
+
+            self.hist_df = DataFrame({'gender': gender,
+                                      'classroom': classroom,
+                                      'height': random.normal(66, 4, size=n),
+                                      'weight': random.normal(161, 32, size=n),
+                                      'category': random.randint(4, size=n)})
+
+        self.tdf = tm.makeTimeDataFrame()
+        self.hexbin_df = DataFrame({"A": np.random.uniform(size=20),
+                                    "B": np.random.uniform(size=20),
+                                    "C": np.arange(20) + np.random.uniform(
+                                        size=20)})
+
+    def tearDown(self):
+        tm.close()
+
+    @cache_readonly
+    def plt(self):
+        import matplotlib.pyplot as plt
+        return plt
+
+    @cache_readonly
+    def colorconverter(self):
+        import matplotlib.colors as colors
+        return colors.colorConverter
+
+    def _check_legend_labels(self, axes, labels=None, visible=True):
+        """
+        Check each axes has expected legend labels
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+        labels : list-like
+            expected legend labels
+        visible : bool
+            expected legend visibility. labels are checked only when visible is
+            True
+        """
+
+        if visible and (labels is None):
+            raise ValueError('labels must be specified when visible is True')
+        axes = self._flatten_visible(axes)
+        for ax in axes:
+            if visible:
+                self.assertTrue(ax.get_legend() is not None)
+                self._check_text_labels(ax.get_legend().get_texts(), labels)
+            else:
+                self.assertTrue(ax.get_legend() is None)
+
+    def _check_data(self, xp, rs):
+        """
+        Check each axes has identical lines
+
+        Parameters
+        ----------
+        xp : matplotlib Axes object
+        rs : matplotlib Axes object
+        """
+        xp_lines = xp.get_lines()
+        rs_lines = rs.get_lines()
+
+        def check_line(xpl, rsl):
+            xpdata = xpl.get_xydata()
+            rsdata = rsl.get_xydata()
+            tm.assert_almost_equal(xpdata, rsdata)
+
+        self.assertEqual(len(xp_lines), len(rs_lines))
+        [check_line(xpl, rsl) for xpl, rsl in zip(xp_lines, rs_lines)]
+        tm.close()
+
+    def _check_visible(self, collections, visible=True):
+        """
+        Check each artist is visible or not
+
+        Parameters
+        ----------
+        collections : matplotlib Artist or its list-like
+            target Artist or its list or collection
+        visible : bool
+            expected visibility
+        """
+        from matplotlib.collections import Collection
+        if not isinstance(collections,
+                          Collection) and not com.is_list_like(collections):
+            collections = [collections]
+
+        for patch in collections:
+            self.assertEqual(patch.get_visible(), visible)
+
+    def _get_colors_mapped(self, series, colors):
+        unique = series.unique()
+        # unique and colors length can be differed
+        # depending on slice value
+        mapped = dict(zip(unique, colors))
+        return [mapped[v] for v in series.values]
+
+    def _check_colors(self, collections, linecolors=None, facecolors=None,
+                      mapping=None):
+        """
+        Check each artist has expected line colors and face colors
+
+        Parameters
+        ----------
+        collections : list-like
+            list or collection of target artist
+        linecolors : list-like which has the same length as collections
+            list of expected line colors
+        facecolors : list-like which has the same length as collections
+            list of expected face colors
+        mapping : Series
+            Series used for color grouping key
+            used for andrew_curves, parallel_coordinates, radviz test
+        """
+
+        from matplotlib.lines import Line2D
+        from matplotlib.collections import Collection, PolyCollection
+        conv = self.colorconverter
+        if linecolors is not None:
+
+            if mapping is not None:
+                linecolors = self._get_colors_mapped(mapping, linecolors)
+                linecolors = linecolors[:len(collections)]
+
+            self.assertEqual(len(collections), len(linecolors))
+            for patch, color in zip(collections, linecolors):
+                if isinstance(patch, Line2D):
+                    result = patch.get_color()
+                    # Line2D may contains string color expression
+                    result = conv.to_rgba(result)
+                elif isinstance(patch, PolyCollection):
+                    result = tuple(patch.get_edgecolor()[0])
+                else:
+                    result = patch.get_edgecolor()
+
+                expected = conv.to_rgba(color)
+                self.assertEqual(result, expected)
+
+        if facecolors is not None:
+
+            if mapping is not None:
+                facecolors = self._get_colors_mapped(mapping, facecolors)
+                facecolors = facecolors[:len(collections)]
+
+            self.assertEqual(len(collections), len(facecolors))
+            for patch, color in zip(collections, facecolors):
+                if isinstance(patch, Collection):
+                    # returned as list of np.array
+                    result = patch.get_facecolor()[0]
+                else:
+                    result = patch.get_facecolor()
+
+                if isinstance(result, np.ndarray):
+                    result = tuple(result)
+
+                expected = conv.to_rgba(color)
+                self.assertEqual(result, expected)
+
+    def _check_text_labels(self, texts, expected):
+        """
+        Check each text has expected labels
+
+        Parameters
+        ----------
+        texts : matplotlib Text object, or its list-like
+            target text, or its list
+        expected : str or list-like which has the same length as texts
+            expected text label, or its list
+        """
+        if not com.is_list_like(texts):
+            self.assertEqual(texts.get_text(), expected)
+        else:
+            labels = [t.get_text() for t in texts]
+            self.assertEqual(len(labels), len(expected))
+            for l, e in zip(labels, expected):
+                self.assertEqual(l, e)
+
+    def _check_ticks_props(self, axes, xlabelsize=None, xrot=None,
+                           ylabelsize=None, yrot=None):
+        """
+        Check each axes has expected tick properties
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+        xlabelsize : number
+            expected xticks font size
+        xrot : number
+            expected xticks rotation
+        ylabelsize : number
+            expected yticks font size
+        yrot : number
+            expected yticks rotation
+        """
+        from matplotlib.ticker import NullFormatter
+        axes = self._flatten_visible(axes)
+        for ax in axes:
+            if xlabelsize or xrot:
+                if isinstance(ax.xaxis.get_minor_formatter(), NullFormatter):
+                    # If minor ticks has NullFormatter, rot / fontsize are not
+                    # retained
+                    labels = ax.get_xticklabels()
+                else:
+                    labels = ax.get_xticklabels() + ax.get_xticklabels(
+                        minor=True)
+
+                for label in labels:
+                    if xlabelsize is not None:
+                        self.assertAlmostEqual(label.get_fontsize(),
+                                               xlabelsize)
+                    if xrot is not None:
+                        self.assertAlmostEqual(label.get_rotation(), xrot)
+
+            if ylabelsize or yrot:
+                if isinstance(ax.yaxis.get_minor_formatter(), NullFormatter):
+                    labels = ax.get_yticklabels()
+                else:
+                    labels = ax.get_yticklabels() + ax.get_yticklabels(
+                        minor=True)
+
+                for label in labels:
+                    if ylabelsize is not None:
+                        self.assertAlmostEqual(label.get_fontsize(),
+                                               ylabelsize)
+                    if yrot is not None:
+                        self.assertAlmostEqual(label.get_rotation(), yrot)
+
+    def _check_ax_scales(self, axes, xaxis='linear', yaxis='linear'):
+        """
+        Check each axes has expected scales
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+        xaxis : {'linear', 'log'}
+            expected xaxis scale
+        yaxis :  {'linear', 'log'}
+            expected yaxis scale
+        """
+        axes = self._flatten_visible(axes)
+        for ax in axes:
+            self.assertEqual(ax.xaxis.get_scale(), xaxis)
+            self.assertEqual(ax.yaxis.get_scale(), yaxis)
+
+    def _check_axes_shape(self, axes, axes_num=None, layout=None,
+                          figsize=(8.0, 6.0)):
+        """
+        Check expected number of axes is drawn in expected layout
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+        axes_num : number
+            expected number of axes. Unnecessary axes should be set to
+            invisible.
+        layout :  tuple
+            expected layout, (expected number of rows , columns)
+        figsize : tuple
+            expected figsize. default is matplotlib default
+        """
+        visible_axes = self._flatten_visible(axes)
+
+        if axes_num is not None:
+            self.assertEqual(len(visible_axes), axes_num)
+            for ax in visible_axes:
+                # check something drawn on visible axes
+                self.assertTrue(len(ax.get_children()) > 0)
+
+        if layout is not None:
+            result = self._get_axes_layout(plotting._flatten(axes))
+            self.assertEqual(result, layout)
+
+        self.assert_numpy_array_equal(
+            np.round(visible_axes[0].figure.get_size_inches()),
+            np.array(figsize, dtype=np.float64))
+
+    def _get_axes_layout(self, axes):
+        x_set = set()
+        y_set = set()
+        for ax in axes:
+            # check axes coordinates to estimate layout
+            points = ax.get_position().get_points()
+            x_set.add(points[0][0])
+            y_set.add(points[0][1])
+        return (len(y_set), len(x_set))
+
+    def _flatten_visible(self, axes):
+        """
+        Flatten axes, and filter only visible
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+
+        """
+        axes = plotting._flatten(axes)
+        axes = [ax for ax in axes if ax.get_visible()]
+        return axes
+
+    def _check_has_errorbars(self, axes, xerr=0, yerr=0):
+        """
+        Check axes has expected number of errorbars
+
+        Parameters
+        ----------
+        axes : matplotlib Axes object, or its list-like
+        xerr : number
+            expected number of x errorbar
+        yerr : number
+            expected number of y errorbar
+        """
+        axes = self._flatten_visible(axes)
+        for ax in axes:
+            containers = ax.containers
+            xerr_count = 0
+            yerr_count = 0
+            for c in containers:
+                has_xerr = getattr(c, 'has_xerr', False)
+                has_yerr = getattr(c, 'has_yerr', False)
+                if has_xerr:
+                    xerr_count += 1
+                if has_yerr:
+                    yerr_count += 1
+            self.assertEqual(xerr, xerr_count)
+            self.assertEqual(yerr, yerr_count)
+
+    def _check_box_return_type(self, returned, return_type, expected_keys=None,
+                               check_ax_title=True):
+        """
+        Check box returned type is correct
+
+        Parameters
+        ----------
+        returned : object to be tested, returned from boxplot
+        return_type : str
+            return_type passed to boxplot
+        expected_keys : list-like, optional
+            group labels in subplot case. If not passed,
+            the function checks assuming boxplot uses single ax
+        check_ax_title : bool
+            Whether to check the ax.title is the same as expected_key
+            Intended to be checked by calling from ``boxplot``.
+            Normal ``plot`` doesn't attach ``ax.title``, it must be disabled.
+        """
+        from matplotlib.axes import Axes
+        types = {'dict': dict, 'axes': Axes, 'both': tuple}
+        if expected_keys is None:
+            # should be fixed when the returning default is changed
+            if return_type is None:
+                return_type = 'dict'
+
+            self.assertTrue(isinstance(returned, types[return_type]))
+            if return_type == 'both':
+                self.assertIsInstance(returned.ax, Axes)
+                self.assertIsInstance(returned.lines, dict)
+        else:
+            # should be fixed when the returning default is changed
+            if return_type is None:
+                for r in self._flatten_visible(returned):
+                    self.assertIsInstance(r, Axes)
+                return
+
+            self.assertTrue(isinstance(returned, OrderedDict))
+            self.assertEqual(sorted(returned.keys()), sorted(expected_keys))
+            for key, value in iteritems(returned):
+                self.assertTrue(isinstance(value, types[return_type]))
+                # check returned dict has correct mapping
+                if return_type == 'axes':
+                    if check_ax_title:
+                        self.assertEqual(value.get_title(), key)
+                elif return_type == 'both':
+                    if check_ax_title:
+                        self.assertEqual(value.ax.get_title(), key)
+                    self.assertIsInstance(value.ax, Axes)
+                    self.assertIsInstance(value.lines, dict)
+                elif return_type == 'dict':
+                    line = value['medians'][0]
+                    axes = line.axes if self.mpl_ge_1_5_0 else line.get_axes()
+                    if check_ax_title:
+                        self.assertEqual(axes.get_title(), key)
+                else:
+                    raise AssertionError
+
+    def _check_grid_settings(self, obj, kinds, kws={}):
+        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
+
+        import matplotlib as mpl
+
+        def is_grid_on():
+            xoff = all(not g.gridOn
+                       for g in self.plt.gca().xaxis.get_major_ticks())
+            yoff = all(not g.gridOn
+                       for g in self.plt.gca().yaxis.get_major_ticks())
+            return not (xoff and yoff)
+
+        spndx = 1
+        for kind in kinds:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+
+            self.plt.subplot(1, 4 * len(kinds), spndx)
+            spndx += 1
+            mpl.rc('axes', grid=False)
+            obj.plot(kind=kind, **kws)
+            self.assertFalse(is_grid_on())
+
+            self.plt.subplot(1, 4 * len(kinds), spndx)
+            spndx += 1
+            mpl.rc('axes', grid=True)
+            obj.plot(kind=kind, grid=False, **kws)
+            self.assertFalse(is_grid_on())
+
+            if kind != 'pie':
+                self.plt.subplot(1, 4 * len(kinds), spndx)
+                spndx += 1
+                mpl.rc('axes', grid=True)
+                obj.plot(kind=kind, **kws)
+                self.assertTrue(is_grid_on())
+
+                self.plt.subplot(1, 4 * len(kinds), spndx)
+                spndx += 1
+                mpl.rc('axes', grid=False)
+                obj.plot(kind=kind, grid=True, **kws)
+                self.assertTrue(is_grid_on())
+
+    def _maybe_unpack_cycler(self, rcParams, field='color'):
+        """
+        Compat layer for MPL 1.5 change to color cycle
+
+        Before: plt.rcParams['axes.color_cycle'] -> ['b', 'g', 'r'...]
+        After : plt.rcParams['axes.prop_cycle'] -> cycler(...)
+        """
+        if self.mpl_ge_1_5_0:
+            cyl = rcParams['axes.prop_cycle']
+            colors = [v[field] for v in cyl]
+        else:
+            colors = rcParams['axes.color_cycle']
+        return colors
+
+
+def _check_plot_works(f, filterwarnings='always', **kwargs):
+    import matplotlib.pyplot as plt
+    ret = None
+    with warnings.catch_warnings():
+        warnings.simplefilter(filterwarnings)
+        try:
+            try:
+                fig = kwargs['figure']
+            except KeyError:
+                fig = plt.gcf()
+
+            plt.clf()
+
+            ax = kwargs.get('ax', fig.add_subplot(211))  # noqa
+            ret = f(**kwargs)
+
+            assert_is_valid_plot_return_object(ret)
+
+            try:
+                kwargs['ax'] = fig.add_subplot(212)
+                ret = f(**kwargs)
+            except Exception:
+                pass
+            else:
+                assert_is_valid_plot_return_object(ret)
+
+            with ensure_clean(return_filelike=True) as path:
+                plt.savefig(path)
+        finally:
+            tm.close(fig)
+
+        return ret
+
+
+def curpath():
+    pth, _ = os.path.split(os.path.abspath(__file__))
+    return pth
diff --git a/pandas/tests/plotting/test_boxplot_method.py b/pandas/tests/plotting/test_boxplot_method.py
new file mode 100644
index 000000000..d49954082
--- /dev/null
+++ b/pandas/tests/plotting/test_boxplot_method.py
@@ -0,0 +1,374 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+import itertools
+import string
+from distutils.version import LooseVersion
+
+from pandas import Series, DataFrame, MultiIndex
+from pandas.compat import range, lzip
+import pandas.util.testing as tm
+from pandas.util.testing import slow
+
+import numpy as np
+from numpy import random
+from numpy.random import randn
+
+import pandas.tools.plotting as plotting
+
+from pandas.tests.plotting.common import (TestPlotBase, _check_plot_works)
+
+
+""" Test cases for .boxplot method """
+
+
+def _skip_if_mpl_14_or_dev_boxplot():
+    # GH 8382
+    # Boxplot failures on 1.4 and 1.4.1
+    # Don't need try / except since that's done at class level
+    import matplotlib
+    if str(matplotlib.__version__) >= LooseVersion('1.4'):
+        raise nose.SkipTest("Matplotlib Regression in 1.4 and current dev.")
+
+
+@tm.mplskip
+class TestDataFramePlots(TestPlotBase):
+
+    @slow
+    def test_boxplot_legacy(self):
+        df = DataFrame(randn(6, 4),
+                       index=list(string.ascii_letters[:6]),
+                       columns=['one', 'two', 'three', 'four'])
+        df['indic'] = ['foo', 'bar'] * 3
+        df['indic2'] = ['foo', 'bar', 'foo'] * 2
+
+        _check_plot_works(df.boxplot, return_type='dict')
+        _check_plot_works(df.boxplot, column=[
+                          'one', 'two'], return_type='dict')
+        # _check_plot_works adds an ax so catch warning. see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.boxplot, column=['one', 'two'],
+                              by='indic')
+        _check_plot_works(df.boxplot, column='one', by=['indic', 'indic2'])
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.boxplot, by='indic')
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.boxplot, by=['indic', 'indic2'])
+        _check_plot_works(plotting.boxplot, data=df['one'], return_type='dict')
+        _check_plot_works(df.boxplot, notch=1, return_type='dict')
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.boxplot, by='indic', notch=1)
+
+        df = DataFrame(np.random.rand(10, 2), columns=['Col1', 'Col2'])
+        df['X'] = Series(['A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'B'])
+        df['Y'] = Series(['A'] * 10)
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.boxplot, by='X')
+
+        # When ax is supplied and required number of axes is 1,
+        # passed ax should be used:
+        fig, ax = self.plt.subplots()
+        axes = df.boxplot('Col1', by='X', ax=ax)
+        ax_axes = ax.axes if self.mpl_ge_1_5_0 else ax.get_axes()
+        self.assertIs(ax_axes, axes)
+
+        fig, ax = self.plt.subplots()
+        axes = df.groupby('Y').boxplot(ax=ax, return_type='axes')
+        ax_axes = ax.axes if self.mpl_ge_1_5_0 else ax.get_axes()
+        self.assertIs(ax_axes, axes['A'])
+
+        # Multiple columns with an ax argument should use same figure
+        fig, ax = self.plt.subplots()
+        with tm.assert_produces_warning(UserWarning):
+            axes = df.boxplot(column=['Col1', 'Col2'],
+                              by='X', ax=ax, return_type='axes')
+        self.assertIs(axes['Col1'].get_figure(), fig)
+
+        # When by is None, check that all relevant lines are present in the
+        # dict
+        fig, ax = self.plt.subplots()
+        d = df.boxplot(ax=ax, return_type='dict')
+        lines = list(itertools.chain.from_iterable(d.values()))
+        self.assertEqual(len(ax.get_lines()), len(lines))
+
+    @slow
+    def test_boxplot_return_type_legacy(self):
+        # API change in https://github.com/pydata/pandas/pull/7096
+        import matplotlib as mpl  # noqa
+
+        df = DataFrame(randn(6, 4),
+                       index=list(string.ascii_letters[:6]),
+                       columns=['one', 'two', 'three', 'four'])
+        with tm.assertRaises(ValueError):
+            df.boxplot(return_type='NOTATYPE')
+
+        with tm.assert_produces_warning(FutureWarning):
+            result = df.boxplot()
+        # change to Axes in future
+        self._check_box_return_type(result, 'dict')
+
+        with tm.assert_produces_warning(False):
+            result = df.boxplot(return_type='dict')
+        self._check_box_return_type(result, 'dict')
+
+        with tm.assert_produces_warning(False):
+            result = df.boxplot(return_type='axes')
+        self._check_box_return_type(result, 'axes')
+
+        with tm.assert_produces_warning(False):
+            result = df.boxplot(return_type='both')
+        self._check_box_return_type(result, 'both')
+
+    @slow
+    def test_boxplot_axis_limits(self):
+
+        def _check_ax_limits(col, ax):
+            y_min, y_max = ax.get_ylim()
+            self.assertTrue(y_min <= col.min())
+            self.assertTrue(y_max >= col.max())
+
+        df = self.hist_df.copy()
+        df['age'] = np.random.randint(1, 20, df.shape[0])
+        # One full row
+        height_ax, weight_ax = df.boxplot(['height', 'weight'], by='category')
+        _check_ax_limits(df['height'], height_ax)
+        _check_ax_limits(df['weight'], weight_ax)
+        self.assertEqual(weight_ax._sharey, height_ax)
+
+        # Two rows, one partial
+        p = df.boxplot(['height', 'weight', 'age'], by='category')
+        height_ax, weight_ax, age_ax = p[0, 0], p[0, 1], p[1, 0]
+        dummy_ax = p[1, 1]
+        _check_ax_limits(df['height'], height_ax)
+        _check_ax_limits(df['weight'], weight_ax)
+        _check_ax_limits(df['age'], age_ax)
+        self.assertEqual(weight_ax._sharey, height_ax)
+        self.assertEqual(age_ax._sharey, height_ax)
+        self.assertIsNone(dummy_ax._sharey)
+
+    @slow
+    def test_boxplot_empty_column(self):
+        _skip_if_mpl_14_or_dev_boxplot()
+        df = DataFrame(np.random.randn(20, 4))
+        df.loc[:, 0] = np.nan
+        _check_plot_works(df.boxplot, return_type='axes')
+
+
+@tm.mplskip
+class TestDataFrameGroupByPlots(TestPlotBase):
+
+    @slow
+    def test_boxplot_legacy(self):
+        grouped = self.hist_df.groupby(by='gender')
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(grouped.boxplot, return_type='axes')
+        self._check_axes_shape(list(axes.values()), axes_num=2, layout=(1, 2))
+
+        axes = _check_plot_works(grouped.boxplot, subplots=False,
+                                 return_type='axes')
+        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
+        tuples = lzip(string.ascii_letters[:10], range(10))
+        df = DataFrame(np.random.rand(10, 3),
+                       index=MultiIndex.from_tuples(tuples))
+
+        grouped = df.groupby(level=1)
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(grouped.boxplot, return_type='axes')
+        self._check_axes_shape(list(axes.values()), axes_num=10, layout=(4, 3))
+
+        axes = _check_plot_works(grouped.boxplot, subplots=False,
+                                 return_type='axes')
+        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
+
+        grouped = df.unstack(level=1).groupby(level=0, axis=1)
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(grouped.boxplot, return_type='axes')
+        self._check_axes_shape(list(axes.values()), axes_num=3, layout=(2, 2))
+
+        axes = _check_plot_works(grouped.boxplot, subplots=False,
+                                 return_type='axes')
+        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
+
+    @slow
+    def test_grouped_plot_fignums(self):
+        n = 10
+        weight = Series(np.random.normal(166, 20, size=n))
+        height = Series(np.random.normal(60, 10, size=n))
+        with tm.RNGContext(42):
+            gender = np.random.choice(['male', 'female'], size=n)
+        df = DataFrame({'height': height, 'weight': weight, 'gender': gender})
+        gb = df.groupby('gender')
+
+        res = gb.plot()
+        self.assertEqual(len(self.plt.get_fignums()), 2)
+        self.assertEqual(len(res), 2)
+        tm.close()
+
+        res = gb.boxplot(return_type='axes')
+        self.assertEqual(len(self.plt.get_fignums()), 1)
+        self.assertEqual(len(res), 2)
+        tm.close()
+
+        # now works with GH 5610 as gender is excluded
+        res = df.groupby('gender').hist()
+        tm.close()
+
+    @slow
+    def test_grouped_box_return_type(self):
+        df = self.hist_df
+
+        # old style: return_type=None
+        result = df.boxplot(by='gender')
+        self.assertIsInstance(result, np.ndarray)
+        self._check_box_return_type(
+            result, None,
+            expected_keys=['height', 'weight', 'category'])
+
+        # now for groupby
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = df.groupby('gender').boxplot()
+        self._check_box_return_type(
+            result, 'dict', expected_keys=['Male', 'Female'])
+
+        columns2 = 'X B C D A G Y N Q O'.split()
+        df2 = DataFrame(random.randn(50, 10), columns=columns2)
+        categories2 = 'A B C D E F G H I J'.split()
+        df2['category'] = categories2 * 5
+
+        for t in ['dict', 'axes', 'both']:
+            returned = df.groupby('classroom').boxplot(return_type=t)
+            self._check_box_return_type(
+                returned, t, expected_keys=['A', 'B', 'C'])
+
+            returned = df.boxplot(by='classroom', return_type=t)
+            self._check_box_return_type(
+                returned, t,
+                expected_keys=['height', 'weight', 'category'])
+
+            returned = df2.groupby('category').boxplot(return_type=t)
+            self._check_box_return_type(returned, t, expected_keys=categories2)
+
+            returned = df2.boxplot(by='category', return_type=t)
+            self._check_box_return_type(returned, t, expected_keys=columns2)
+
+    @slow
+    def test_grouped_box_layout(self):
+        df = self.hist_df
+
+        self.assertRaises(ValueError, df.boxplot, column=['weight', 'height'],
+                          by=df.gender, layout=(1, 1))
+        self.assertRaises(ValueError, df.boxplot,
+                          column=['height', 'weight', 'category'],
+                          layout=(2, 1), return_type='dict')
+        self.assertRaises(ValueError, df.boxplot, column=['weight', 'height'],
+                          by=df.gender, layout=(-1, -1))
+
+        # _check_plot_works adds an ax so catch warning. see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            box = _check_plot_works(df.groupby('gender').boxplot,
+                                    column='height', return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=2, layout=(1, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            box = _check_plot_works(df.groupby('category').boxplot,
+                                    column='height',
+                                    return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(2, 2))
+
+        # GH 6769
+        with tm.assert_produces_warning(UserWarning):
+            box = _check_plot_works(df.groupby('classroom').boxplot,
+                                    column='height', return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
+
+        # GH 5897
+        axes = df.boxplot(column=['height', 'weight', 'category'], by='gender',
+                          return_type='axes')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
+        for ax in [axes['height']]:
+            self._check_visible(ax.get_xticklabels(), visible=False)
+            self._check_visible([ax.xaxis.get_label()], visible=False)
+        for ax in [axes['weight'], axes['category']]:
+            self._check_visible(ax.get_xticklabels())
+            self._check_visible([ax.xaxis.get_label()])
+
+        box = df.groupby('classroom').boxplot(
+            column=['height', 'weight', 'category'], return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            box = _check_plot_works(df.groupby('category').boxplot,
+                                    column='height',
+                                    layout=(3, 2), return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(3, 2))
+        with tm.assert_produces_warning(UserWarning):
+            box = _check_plot_works(df.groupby('category').boxplot,
+                                    column='height',
+                                    layout=(3, -1), return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(3, 2))
+
+        box = df.boxplot(column=['height', 'weight', 'category'], by='gender',
+                         layout=(4, 1))
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(4, 1))
+
+        box = df.boxplot(column=['height', 'weight', 'category'], by='gender',
+                         layout=(-1, 1))
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(3, 1))
+
+        box = df.groupby('classroom').boxplot(
+            column=['height', 'weight', 'category'], layout=(1, 4),
+            return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(1, 4))
+
+        box = df.groupby('classroom').boxplot(  # noqa
+            column=['height', 'weight', 'category'], layout=(1, -1),
+            return_type='dict')
+        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(1, 3))
+
+    @slow
+    def test_grouped_box_multiple_axes(self):
+        # GH 6970, GH 7069
+        df = self.hist_df
+
+        # check warning to ignore sharex / sharey
+        # this check should be done in the first function which
+        # passes multiple axes to plot, hist or boxplot
+        # location should be changed if other test is added
+        # which has earlier alphabetical order
+        with tm.assert_produces_warning(UserWarning):
+            fig, axes = self.plt.subplots(2, 2)
+            df.groupby('category').boxplot(
+                column='height', return_type='axes', ax=axes)
+            self._check_axes_shape(self.plt.gcf().axes,
+                                   axes_num=4, layout=(2, 2))
+
+        fig, axes = self.plt.subplots(2, 3)
+        with tm.assert_produces_warning(UserWarning):
+            returned = df.boxplot(column=['height', 'weight', 'category'],
+                                  by='gender', return_type='axes', ax=axes[0])
+        returned = np.array(list(returned.values()))
+        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
+        self.assert_numpy_array_equal(returned, axes[0])
+        self.assertIs(returned[0].figure, fig)
+
+        # draw on second row
+        with tm.assert_produces_warning(UserWarning):
+            returned = df.groupby('classroom').boxplot(
+                column=['height', 'weight', 'category'],
+                return_type='axes', ax=axes[1])
+        returned = np.array(list(returned.values()))
+        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
+        self.assert_numpy_array_equal(returned, axes[1])
+        self.assertIs(returned[0].figure, fig)
+
+        with tm.assertRaises(ValueError):
+            fig, axes = self.plt.subplots(2, 3)
+            # pass different number of axes from required
+            with tm.assert_produces_warning(UserWarning):
+                axes = df.groupby('classroom').boxplot(ax=axes)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tests/plotting/test_datetimelike.py
similarity index 99%
rename from pandas/tseries/tests/test_plotting.py
rename to pandas/tests/plotting/test_datetimelike.py
index 2255f9fae..3f0931791 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tests/plotting/test_datetimelike.py
@@ -14,12 +14,18 @@ from pandas.tseries.resample import DatetimeIndex
 from pandas.util.testing import assert_series_equal, ensure_clean, slow
 import pandas.util.testing as tm
 
-from pandas.tests.test_graphics import _skip_if_no_scipy_gaussian_kde
+from pandas.tests.plotting.common import (TestPlotBase,
+                                          _skip_if_no_scipy_gaussian_kde)
+
+
+""" Test cases for time series specific (freq conversion, etc) """
 
 
 @tm.mplskip
-class TestTSPlot(tm.TestCase):
+class TestTSPlot(TestPlotBase):
+
     def setUp(self):
+        TestPlotBase.setUp(self)
         freq = ['S', 'T', 'H', 'D', 'W', 'M', 'Q', 'A']
         idx = [period_range('12/31/1999', freq=x, periods=100) for x in freq]
         self.period_ser = [Series(np.random.randn(len(x)), x) for x in idx]
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/plotting/test_frame.py
similarity index 68%
rename from pandas/tests/test_graphics.py
rename to pandas/tests/plotting/test_frame.py
index 5493eb37c..311da4a92 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/plotting/test_frame.py
@@ -2,1293 +2,31 @@
 # coding: utf-8
 
 import nose
-import itertools
-import os
 import string
 import warnings
 
 from datetime import datetime, date
 
-from pandas.types.common import is_list_like
 import pandas as pd
 from pandas import (Series, DataFrame, MultiIndex, PeriodIndex, date_range,
                     bdate_range)
-from pandas.compat import (range, lrange, StringIO, lmap, lzip, u, zip,
-                           iteritems, OrderedDict, PY3)
-from pandas.util.decorators import cache_readonly
+from pandas.compat import (range, lrange, StringIO, lmap, lzip, u, zip, PY3)
 from pandas.formats.printing import pprint_thing
 import pandas.util.testing as tm
-from pandas.util.testing import (ensure_clean,
-                                 assert_is_valid_plot_return_object, slow)
+from pandas.util.testing import slow
 
 from pandas.core.config import set_option
 
 import numpy as np
-from numpy import random
 from numpy.random import rand, randn
 
 import pandas.tools.plotting as plotting
-"""
-These tests are for ``Dataframe.plot`` and ``Series.plot``.
-Other plot methods such as ``.hist``, ``.boxplot`` and other miscellaneous
-are tested in test_graphics_others.py
-"""
+from pandas.tests.plotting.common import (TestPlotBase, _check_plot_works,
+                                          _skip_if_no_scipy_gaussian_kde,
+                                          _ok_for_gaussian_kde)
 
 
-def _skip_if_no_scipy_gaussian_kde():
-    try:
-        from scipy.stats import gaussian_kde  # noqa
-    except ImportError:
-        raise nose.SkipTest("scipy version doesn't support gaussian_kde")
-
-
-def _ok_for_gaussian_kde(kind):
-    if kind in ['kde', 'density']:
-        try:
-            from scipy.stats import gaussian_kde  # noqa
-        except ImportError:
-            return False
-    return True
-
-
-@tm.mplskip
-class TestPlotBase(tm.TestCase):
-
-    def setUp(self):
-
-        import matplotlib as mpl
-        mpl.rcdefaults()
-
-        n = 100
-        with tm.RNGContext(42):
-            gender = np.random.choice(['Male', 'Female'], size=n)
-            classroom = np.random.choice(['A', 'B', 'C'], size=n)
-
-            self.hist_df = DataFrame({'gender': gender,
-                                      'classroom': classroom,
-                                      'height': random.normal(66, 4, size=n),
-                                      'weight': random.normal(161, 32, size=n),
-                                      'category': random.randint(4, size=n)})
-
-        self.mpl_le_1_2_1 = plotting._mpl_le_1_2_1()
-        self.mpl_ge_1_3_1 = plotting._mpl_ge_1_3_1()
-        self.mpl_ge_1_4_0 = plotting._mpl_ge_1_4_0()
-        self.mpl_ge_1_5_0 = plotting._mpl_ge_1_5_0()
-
-        if self.mpl_ge_1_4_0:
-            self.bp_n_objects = 7
-        else:
-            self.bp_n_objects = 8
-        if self.mpl_ge_1_5_0:
-            # 1.5 added PolyCollections to legend handler
-            # so we have twice as many items.
-            self.polycollection_factor = 2
-        else:
-            self.polycollection_factor = 1
-
-    def tearDown(self):
-        tm.close()
-
-    @cache_readonly
-    def plt(self):
-        import matplotlib.pyplot as plt
-        return plt
-
-    @cache_readonly
-    def colorconverter(self):
-        import matplotlib.colors as colors
-        return colors.colorConverter
-
-    def _check_legend_labels(self, axes, labels=None, visible=True):
-        """
-        Check each axes has expected legend labels
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-        labels : list-like
-            expected legend labels
-        visible : bool
-            expected legend visibility. labels are checked only when visible is
-            True
-        """
-
-        if visible and (labels is None):
-            raise ValueError('labels must be specified when visible is True')
-        axes = self._flatten_visible(axes)
-        for ax in axes:
-            if visible:
-                self.assertTrue(ax.get_legend() is not None)
-                self._check_text_labels(ax.get_legend().get_texts(), labels)
-            else:
-                self.assertTrue(ax.get_legend() is None)
-
-    def _check_data(self, xp, rs):
-        """
-        Check each axes has identical lines
-
-        Parameters
-        ----------
-        xp : matplotlib Axes object
-        rs : matplotlib Axes object
-        """
-        xp_lines = xp.get_lines()
-        rs_lines = rs.get_lines()
-
-        def check_line(xpl, rsl):
-            xpdata = xpl.get_xydata()
-            rsdata = rsl.get_xydata()
-            tm.assert_almost_equal(xpdata, rsdata)
-
-        self.assertEqual(len(xp_lines), len(rs_lines))
-        [check_line(xpl, rsl) for xpl, rsl in zip(xp_lines, rs_lines)]
-        tm.close()
-
-    def _check_visible(self, collections, visible=True):
-        """
-        Check each artist is visible or not
-
-        Parameters
-        ----------
-        collections : matplotlib Artist or its list-like
-            target Artist or its list or collection
-        visible : bool
-            expected visibility
-        """
-        from matplotlib.collections import Collection
-        if not isinstance(collections,
-                          Collection) and not is_list_like(collections):
-            collections = [collections]
-
-        for patch in collections:
-            self.assertEqual(patch.get_visible(), visible)
-
-    def _get_colors_mapped(self, series, colors):
-        unique = series.unique()
-        # unique and colors length can be differed
-        # depending on slice value
-        mapped = dict(zip(unique, colors))
-        return [mapped[v] for v in series.values]
-
-    def _check_colors(self, collections, linecolors=None, facecolors=None,
-                      mapping=None):
-        """
-        Check each artist has expected line colors and face colors
-
-        Parameters
-        ----------
-        collections : list-like
-            list or collection of target artist
-        linecolors : list-like which has the same length as collections
-            list of expected line colors
-        facecolors : list-like which has the same length as collections
-            list of expected face colors
-        mapping : Series
-            Series used for color grouping key
-            used for andrew_curves, parallel_coordinates, radviz test
-        """
-
-        from matplotlib.lines import Line2D
-        from matplotlib.collections import Collection, PolyCollection
-        conv = self.colorconverter
-        if linecolors is not None:
-
-            if mapping is not None:
-                linecolors = self._get_colors_mapped(mapping, linecolors)
-                linecolors = linecolors[:len(collections)]
-
-            self.assertEqual(len(collections), len(linecolors))
-            for patch, color in zip(collections, linecolors):
-                if isinstance(patch, Line2D):
-                    result = patch.get_color()
-                    # Line2D may contains string color expression
-                    result = conv.to_rgba(result)
-                elif isinstance(patch, PolyCollection):
-                    result = tuple(patch.get_edgecolor()[0])
-                else:
-                    result = patch.get_edgecolor()
-
-                expected = conv.to_rgba(color)
-                self.assertEqual(result, expected)
-
-        if facecolors is not None:
-
-            if mapping is not None:
-                facecolors = self._get_colors_mapped(mapping, facecolors)
-                facecolors = facecolors[:len(collections)]
-
-            self.assertEqual(len(collections), len(facecolors))
-            for patch, color in zip(collections, facecolors):
-                if isinstance(patch, Collection):
-                    # returned as list of np.array
-                    result = patch.get_facecolor()[0]
-                else:
-                    result = patch.get_facecolor()
-
-                if isinstance(result, np.ndarray):
-                    result = tuple(result)
-
-                expected = conv.to_rgba(color)
-                self.assertEqual(result, expected)
-
-    def _check_text_labels(self, texts, expected):
-        """
-        Check each text has expected labels
-
-        Parameters
-        ----------
-        texts : matplotlib Text object, or its list-like
-            target text, or its list
-        expected : str or list-like which has the same length as texts
-            expected text label, or its list
-        """
-        if not is_list_like(texts):
-            self.assertEqual(texts.get_text(), expected)
-        else:
-            labels = [t.get_text() for t in texts]
-            self.assertEqual(len(labels), len(expected))
-            for l, e in zip(labels, expected):
-                self.assertEqual(l, e)
-
-    def _check_ticks_props(self, axes, xlabelsize=None, xrot=None,
-                           ylabelsize=None, yrot=None):
-        """
-        Check each axes has expected tick properties
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-        xlabelsize : number
-            expected xticks font size
-        xrot : number
-            expected xticks rotation
-        ylabelsize : number
-            expected yticks font size
-        yrot : number
-            expected yticks rotation
-        """
-        from matplotlib.ticker import NullFormatter
-        axes = self._flatten_visible(axes)
-        for ax in axes:
-            if xlabelsize or xrot:
-                if isinstance(ax.xaxis.get_minor_formatter(), NullFormatter):
-                    # If minor ticks has NullFormatter, rot / fontsize are not
-                    # retained
-                    labels = ax.get_xticklabels()
-                else:
-                    labels = ax.get_xticklabels() + ax.get_xticklabels(
-                        minor=True)
-
-                for label in labels:
-                    if xlabelsize is not None:
-                        self.assertAlmostEqual(label.get_fontsize(),
-                                               xlabelsize)
-                    if xrot is not None:
-                        self.assertAlmostEqual(label.get_rotation(), xrot)
-
-            if ylabelsize or yrot:
-                if isinstance(ax.yaxis.get_minor_formatter(), NullFormatter):
-                    labels = ax.get_yticklabels()
-                else:
-                    labels = ax.get_yticklabels() + ax.get_yticklabels(
-                        minor=True)
-
-                for label in labels:
-                    if ylabelsize is not None:
-                        self.assertAlmostEqual(label.get_fontsize(),
-                                               ylabelsize)
-                    if yrot is not None:
-                        self.assertAlmostEqual(label.get_rotation(), yrot)
-
-    def _check_ax_scales(self, axes, xaxis='linear', yaxis='linear'):
-        """
-        Check each axes has expected scales
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-        xaxis : {'linear', 'log'}
-            expected xaxis scale
-        yaxis :  {'linear', 'log'}
-            expected yaxis scale
-        """
-        axes = self._flatten_visible(axes)
-        for ax in axes:
-            self.assertEqual(ax.xaxis.get_scale(), xaxis)
-            self.assertEqual(ax.yaxis.get_scale(), yaxis)
-
-    def _check_axes_shape(self, axes, axes_num=None, layout=None,
-                          figsize=(8.0, 6.0)):
-        """
-        Check expected number of axes is drawn in expected layout
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-        axes_num : number
-            expected number of axes. Unnecessary axes should be set to
-            invisible.
-        layout :  tuple
-            expected layout, (expected number of rows , columns)
-        figsize : tuple
-            expected figsize. default is matplotlib default
-        """
-        visible_axes = self._flatten_visible(axes)
-
-        if axes_num is not None:
-            self.assertEqual(len(visible_axes), axes_num)
-            for ax in visible_axes:
-                # check something drawn on visible axes
-                self.assertTrue(len(ax.get_children()) > 0)
-
-        if layout is not None:
-            result = self._get_axes_layout(plotting._flatten(axes))
-            self.assertEqual(result, layout)
-
-        self.assert_numpy_array_equal(
-            np.round(visible_axes[0].figure.get_size_inches()),
-            np.array(figsize, dtype=np.float64))
-
-    def _get_axes_layout(self, axes):
-        x_set = set()
-        y_set = set()
-        for ax in axes:
-            # check axes coordinates to estimate layout
-            points = ax.get_position().get_points()
-            x_set.add(points[0][0])
-            y_set.add(points[0][1])
-        return (len(y_set), len(x_set))
-
-    def _flatten_visible(self, axes):
-        """
-        Flatten axes, and filter only visible
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-
-        """
-        axes = plotting._flatten(axes)
-        axes = [ax for ax in axes if ax.get_visible()]
-        return axes
-
-    def _check_has_errorbars(self, axes, xerr=0, yerr=0):
-        """
-        Check axes has expected number of errorbars
-
-        Parameters
-        ----------
-        axes : matplotlib Axes object, or its list-like
-        xerr : number
-            expected number of x errorbar
-        yerr : number
-            expected number of y errorbar
-        """
-        axes = self._flatten_visible(axes)
-        for ax in axes:
-            containers = ax.containers
-            xerr_count = 0
-            yerr_count = 0
-            for c in containers:
-                has_xerr = getattr(c, 'has_xerr', False)
-                has_yerr = getattr(c, 'has_yerr', False)
-                if has_xerr:
-                    xerr_count += 1
-                if has_yerr:
-                    yerr_count += 1
-            self.assertEqual(xerr, xerr_count)
-            self.assertEqual(yerr, yerr_count)
-
-    def _check_box_return_type(self, returned, return_type, expected_keys=None,
-                               check_ax_title=True):
-        """
-        Check box returned type is correct
-
-        Parameters
-        ----------
-        returned : object to be tested, returned from boxplot
-        return_type : str
-            return_type passed to boxplot
-        expected_keys : list-like, optional
-            group labels in subplot case. If not passed,
-            the function checks assuming boxplot uses single ax
-        check_ax_title : bool
-            Whether to check the ax.title is the same as expected_key
-            Intended to be checked by calling from ``boxplot``.
-            Normal ``plot`` doesn't attach ``ax.title``, it must be disabled.
-        """
-        from matplotlib.axes import Axes
-        types = {'dict': dict, 'axes': Axes, 'both': tuple}
-        if expected_keys is None:
-            # should be fixed when the returning default is changed
-            if return_type is None:
-                return_type = 'dict'
-
-            self.assertTrue(isinstance(returned, types[return_type]))
-            if return_type == 'both':
-                self.assertIsInstance(returned.ax, Axes)
-                self.assertIsInstance(returned.lines, dict)
-        else:
-            # should be fixed when the returning default is changed
-            if return_type is None:
-                for r in self._flatten_visible(returned):
-                    self.assertIsInstance(r, Axes)
-                return
-
-            self.assertTrue(isinstance(returned, OrderedDict))
-            self.assertEqual(sorted(returned.keys()), sorted(expected_keys))
-            for key, value in iteritems(returned):
-                self.assertTrue(isinstance(value, types[return_type]))
-                # check returned dict has correct mapping
-                if return_type == 'axes':
-                    if check_ax_title:
-                        self.assertEqual(value.get_title(), key)
-                elif return_type == 'both':
-                    if check_ax_title:
-                        self.assertEqual(value.ax.get_title(), key)
-                    self.assertIsInstance(value.ax, Axes)
-                    self.assertIsInstance(value.lines, dict)
-                elif return_type == 'dict':
-                    line = value['medians'][0]
-                    axes = line.axes if self.mpl_ge_1_5_0 else line.get_axes()
-                    if check_ax_title:
-                        self.assertEqual(axes.get_title(), key)
-                else:
-                    raise AssertionError
-
-    def _check_grid_settings(self, obj, kinds, kws={}):
-        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
-
-        import matplotlib as mpl
-
-        def is_grid_on():
-            xoff = all(not g.gridOn
-                       for g in self.plt.gca().xaxis.get_major_ticks())
-            yoff = all(not g.gridOn
-                       for g in self.plt.gca().yaxis.get_major_ticks())
-            return not (xoff and yoff)
-
-        spndx = 1
-        for kind in kinds:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-
-            self.plt.subplot(1, 4 * len(kinds), spndx)
-            spndx += 1
-            mpl.rc('axes', grid=False)
-            obj.plot(kind=kind, **kws)
-            self.assertFalse(is_grid_on())
-
-            self.plt.subplot(1, 4 * len(kinds), spndx)
-            spndx += 1
-            mpl.rc('axes', grid=True)
-            obj.plot(kind=kind, grid=False, **kws)
-            self.assertFalse(is_grid_on())
-
-            if kind != 'pie':
-                self.plt.subplot(1, 4 * len(kinds), spndx)
-                spndx += 1
-                mpl.rc('axes', grid=True)
-                obj.plot(kind=kind, **kws)
-                self.assertTrue(is_grid_on())
-
-                self.plt.subplot(1, 4 * len(kinds), spndx)
-                spndx += 1
-                mpl.rc('axes', grid=False)
-                obj.plot(kind=kind, grid=True, **kws)
-                self.assertTrue(is_grid_on())
-
-    def _maybe_unpack_cycler(self, rcParams, field='color'):
-        """
-        Compat layer for MPL 1.5 change to color cycle
-
-        Before: plt.rcParams['axes.color_cycle'] -> ['b', 'g', 'r'...]
-        After : plt.rcParams['axes.prop_cycle'] -> cycler(...)
-        """
-        if self.mpl_ge_1_5_0:
-            cyl = rcParams['axes.prop_cycle']
-            colors = [v[field] for v in cyl]
-        else:
-            colors = rcParams['axes.color_cycle']
-        return colors
-
-
-@tm.mplskip
-class TestSeriesPlots(TestPlotBase):
-
-    def setUp(self):
-        TestPlotBase.setUp(self)
-        import matplotlib as mpl
-        mpl.rcdefaults()
-
-        self.ts = tm.makeTimeSeries()
-        self.ts.name = 'ts'
-
-        self.series = tm.makeStringSeries()
-        self.series.name = 'series'
-
-        self.iseries = tm.makePeriodSeries()
-        self.iseries.name = 'iseries'
-
-    @slow
-    def test_plot(self):
-        _check_plot_works(self.ts.plot, label='foo')
-        _check_plot_works(self.ts.plot, use_index=False)
-        axes = _check_plot_works(self.ts.plot, rot=0)
-        self._check_ticks_props(axes, xrot=0)
-
-        ax = _check_plot_works(self.ts.plot, style='.', logy=True)
-        self._check_ax_scales(ax, yaxis='log')
-
-        ax = _check_plot_works(self.ts.plot, style='.', logx=True)
-        self._check_ax_scales(ax, xaxis='log')
-
-        ax = _check_plot_works(self.ts.plot, style='.', loglog=True)
-        self._check_ax_scales(ax, xaxis='log', yaxis='log')
-
-        _check_plot_works(self.ts[:10].plot.bar)
-        _check_plot_works(self.ts.plot.area, stacked=False)
-        _check_plot_works(self.iseries.plot)
-
-        for kind in ['line', 'bar', 'barh', 'kde', 'hist', 'box']:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-            _check_plot_works(self.series[:5].plot, kind=kind)
-
-        _check_plot_works(self.series[:10].plot.barh)
-        ax = _check_plot_works(Series(randn(10)).plot.bar, color='black')
-        self._check_colors([ax.patches[0]], facecolors=['black'])
-
-        # GH 6951
-        ax = _check_plot_works(self.ts.plot, subplots=True)
-        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
-
-        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(-1, 1))
-        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
-        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(1, -1))
-        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
-
-    @slow
-    def test_plot_figsize_and_title(self):
-        # figsize and title
-        ax = self.series.plot(title='Test', figsize=(16, 8))
-        self._check_text_labels(ax.title, 'Test')
-        self._check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16, 8))
-
-    def test_dont_modify_rcParams(self):
-        # GH 8242
-        if self.mpl_ge_1_5_0:
-            key = 'axes.prop_cycle'
-        else:
-            key = 'axes.color_cycle'
-        colors = self.plt.rcParams[key]
-        Series([1, 2, 3]).plot()
-        self.assertEqual(colors, self.plt.rcParams[key])
-
-    def test_ts_line_lim(self):
-        ax = self.ts.plot()
-        xmin, xmax = ax.get_xlim()
-        lines = ax.get_lines()
-        self.assertEqual(xmin, lines[0].get_data(orig=False)[0][0])
-        self.assertEqual(xmax, lines[0].get_data(orig=False)[0][-1])
-        tm.close()
-
-        ax = self.ts.plot(secondary_y=True)
-        xmin, xmax = ax.get_xlim()
-        lines = ax.get_lines()
-        self.assertEqual(xmin, lines[0].get_data(orig=False)[0][0])
-        self.assertEqual(xmax, lines[0].get_data(orig=False)[0][-1])
-
-    def test_ts_area_lim(self):
-        ax = self.ts.plot.area(stacked=False)
-        xmin, xmax = ax.get_xlim()
-        line = ax.get_lines()[0].get_data(orig=False)[0]
-        self.assertEqual(xmin, line[0])
-        self.assertEqual(xmax, line[-1])
-        tm.close()
-
-        # GH 7471
-        ax = self.ts.plot.area(stacked=False, x_compat=True)
-        xmin, xmax = ax.get_xlim()
-        line = ax.get_lines()[0].get_data(orig=False)[0]
-        self.assertEqual(xmin, line[0])
-        self.assertEqual(xmax, line[-1])
-        tm.close()
-
-        tz_ts = self.ts.copy()
-        tz_ts.index = tz_ts.tz_localize('GMT').tz_convert('CET')
-        ax = tz_ts.plot.area(stacked=False, x_compat=True)
-        xmin, xmax = ax.get_xlim()
-        line = ax.get_lines()[0].get_data(orig=False)[0]
-        self.assertEqual(xmin, line[0])
-        self.assertEqual(xmax, line[-1])
-        tm.close()
-
-        ax = tz_ts.plot.area(stacked=False, secondary_y=True)
-        xmin, xmax = ax.get_xlim()
-        line = ax.get_lines()[0].get_data(orig=False)[0]
-        self.assertEqual(xmin, line[0])
-        self.assertEqual(xmax, line[-1])
-
-    def test_label(self):
-        s = Series([1, 2])
-        ax = s.plot(label='LABEL', legend=True)
-        self._check_legend_labels(ax, labels=['LABEL'])
-        self.plt.close()
-        ax = s.plot(legend=True)
-        self._check_legend_labels(ax, labels=['None'])
-        self.plt.close()
-        # get name from index
-        s.name = 'NAME'
-        ax = s.plot(legend=True)
-        self._check_legend_labels(ax, labels=['NAME'])
-        self.plt.close()
-        # override the default
-        ax = s.plot(legend=True, label='LABEL')
-        self._check_legend_labels(ax, labels=['LABEL'])
-        self.plt.close()
-        # Add lebel info, but don't draw
-        ax = s.plot(legend=False, label='LABEL')
-        self.assertEqual(ax.get_legend(), None)  # Hasn't been drawn
-        ax.legend()  # draw it
-        self._check_legend_labels(ax, labels=['LABEL'])
-
-    def test_line_area_nan_series(self):
-        values = [1, 2, np.nan, 3]
-        s = Series(values)
-        ts = Series(values, index=tm.makeDateIndex(k=4))
-
-        for d in [s, ts]:
-            ax = _check_plot_works(d.plot)
-            masked = ax.lines[0].get_ydata()
-            # remove nan for comparison purpose
-            exp = np.array([1, 2, 3], dtype=np.float64)
-            self.assert_numpy_array_equal(np.delete(masked.data, 2), exp)
-            self.assert_numpy_array_equal(
-                masked.mask, np.array([False, False, True, False]))
-
-            expected = np.array([1, 2, 0, 3], dtype=np.float64)
-            ax = _check_plot_works(d.plot, stacked=True)
-            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
-            ax = _check_plot_works(d.plot.area)
-            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
-            ax = _check_plot_works(d.plot.area, stacked=False)
-            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
-
-    def test_line_use_index_false(self):
-        s = Series([1, 2, 3], index=['a', 'b', 'c'])
-        s.index.name = 'The Index'
-        ax = s.plot(use_index=False)
-        label = ax.get_xlabel()
-        self.assertEqual(label, '')
-        ax2 = s.plot.bar(use_index=False)
-        label2 = ax2.get_xlabel()
-        self.assertEqual(label2, '')
-
-    @slow
-    def test_bar_log(self):
-        expected = np.array([1., 10., 100., 1000.])
-
-        if not self.mpl_le_1_2_1:
-            expected = np.hstack((.1, expected, 1e4))
-
-        ax = Series([200, 500]).plot.bar(log=True)
-        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)
-        tm.close()
-
-        ax = Series([200, 500]).plot.barh(log=True)
-        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)
-        tm.close()
-
-        # GH 9905
-        expected = np.array([1.0e-03, 1.0e-02, 1.0e-01, 1.0e+00])
-
-        if not self.mpl_le_1_2_1:
-            expected = np.hstack((1.0e-04, expected, 1.0e+01))
-
-        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='bar')
-        self.assertEqual(ax.get_ylim(), (0.001, 0.10000000000000001))
-        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)
-        tm.close()
-
-        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='barh')
-        self.assertEqual(ax.get_xlim(), (0.001, 0.10000000000000001))
-        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)
-
-    @slow
-    def test_bar_ignore_index(self):
-        df = Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
-        ax = df.plot.bar(use_index=False)
-        self._check_text_labels(ax.get_xticklabels(), ['0', '1', '2', '3'])
-
-    def test_rotation(self):
-        df = DataFrame(randn(5, 5))
-        # Default rot 0
-        axes = df.plot()
-        self._check_ticks_props(axes, xrot=0)
-
-        axes = df.plot(rot=30)
-        self._check_ticks_props(axes, xrot=30)
-
-    def test_irregular_datetime(self):
-        rng = date_range('1/1/2000', '3/1/2000')
-        rng = rng[[0, 1, 2, 3, 5, 9, 10, 11, 12]]
-        ser = Series(randn(len(rng)), rng)
-        ax = ser.plot()
-        xp = datetime(1999, 1, 1).toordinal()
-        ax.set_xlim('1/1/1999', '1/1/2001')
-        self.assertEqual(xp, ax.get_xlim()[0])
-
-    @slow
-    def test_pie_series(self):
-        # if sum of values is less than 1.0, pie handle them as rate and draw
-        # semicircle.
-        series = Series(np.random.randint(1, 5),
-                        index=['a', 'b', 'c', 'd', 'e'], name='YLABEL')
-        ax = _check_plot_works(series.plot.pie)
-        self._check_text_labels(ax.texts, series.index)
-        self.assertEqual(ax.get_ylabel(), 'YLABEL')
-
-        # without wedge labels
-        ax = _check_plot_works(series.plot.pie, labels=None)
-        self._check_text_labels(ax.texts, [''] * 5)
-
-        # with less colors than elements
-        color_args = ['r', 'g', 'b']
-        ax = _check_plot_works(series.plot.pie, colors=color_args)
-
-        color_expected = ['r', 'g', 'b', 'r', 'g']
-        self._check_colors(ax.patches, facecolors=color_expected)
-
-        # with labels and colors
-        labels = ['A', 'B', 'C', 'D', 'E']
-        color_args = ['r', 'g', 'b', 'c', 'm']
-        ax = _check_plot_works(series.plot.pie, labels=labels,
-                               colors=color_args)
-        self._check_text_labels(ax.texts, labels)
-        self._check_colors(ax.patches, facecolors=color_args)
-
-        # with autopct and fontsize
-        ax = _check_plot_works(series.plot.pie, colors=color_args,
-                               autopct='%.2f', fontsize=7)
-        pcts = ['{0:.2f}'.format(s * 100)
-                for s in series.values / float(series.sum())]
-        iters = [iter(series.index), iter(pcts)]
-        expected_texts = list(next(it) for it in itertools.cycle(iters))
-        self._check_text_labels(ax.texts, expected_texts)
-        for t in ax.texts:
-            self.assertEqual(t.get_fontsize(), 7)
-
-        # includes negative value
-        with tm.assertRaises(ValueError):
-            series = Series([1, 2, 0, 4, -1], index=['a', 'b', 'c', 'd', 'e'])
-            series.plot.pie()
-
-        # includes nan
-        series = Series([1, 2, np.nan, 4], index=['a', 'b', 'c', 'd'],
-                        name='YLABEL')
-        ax = _check_plot_works(series.plot.pie)
-        self._check_text_labels(ax.texts, ['a', 'b', '', 'd'])
-
-    def test_pie_nan(self):
-        s = Series([1, np.nan, 1, 1])
-        ax = s.plot.pie(legend=True)
-        expected = ['0', '', '2', '3']
-        result = [x.get_text() for x in ax.texts]
-        self.assertEqual(result, expected)
-
-    @slow
-    def test_hist_df_kwargs(self):
-        df = DataFrame(np.random.randn(10, 2))
-        ax = df.plot.hist(bins=5)
-        self.assertEqual(len(ax.patches), 10)
-
-    @slow
-    def test_hist_df_with_nonnumerics(self):
-        # GH 9853
-        with tm.RNGContext(1):
-            df = DataFrame(
-                np.random.randn(10, 4), columns=['A', 'B', 'C', 'D'])
-        df['E'] = ['x', 'y'] * 5
-        ax = df.plot.hist(bins=5)
-        self.assertEqual(len(ax.patches), 20)
-
-        ax = df.plot.hist()  # bins=10
-        self.assertEqual(len(ax.patches), 40)
-
-    @slow
-    def test_hist_legacy(self):
-        _check_plot_works(self.ts.hist)
-        _check_plot_works(self.ts.hist, grid=False)
-        _check_plot_works(self.ts.hist, figsize=(8, 10))
-        # _check_plot_works adds an ax so catch warning. see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(self.ts.hist,
-                              by=self.ts.index.month)
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(self.ts.hist,
-                              by=self.ts.index.month, bins=5)
-
-        fig, ax = self.plt.subplots(1, 1)
-        _check_plot_works(self.ts.hist, ax=ax)
-        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
-        _check_plot_works(self.ts.hist, figure=fig)
-        tm.close()
-
-        fig, (ax1, ax2) = self.plt.subplots(1, 2)
-        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
-        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)
-
-        with tm.assertRaises(ValueError):
-            self.ts.hist(by=self.ts.index, figure=fig)
-
-    @slow
-    def test_hist_bins_legacy(self):
-        df = DataFrame(np.random.randn(10, 2))
-        ax = df.hist(bins=2)[0][0]
-        self.assertEqual(len(ax.patches), 2)
-
-    @slow
-    def test_hist_layout(self):
-        df = self.hist_df
-        with tm.assertRaises(ValueError):
-            df.height.hist(layout=(1, 1))
-
-        with tm.assertRaises(ValueError):
-            df.height.hist(layout=[1, 1])
-
-    @slow
-    def test_hist_layout_with_by(self):
-        df = self.hist_df
-
-        # _check_plot_works adds an ax so catch warning. see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.gender, layout=(2, 1))
-        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.gender, layout=(3, -1))
-        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.category, layout=(4, 1))
-        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.category, layout=(2, -1))
-        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.category, layout=(3, -1))
-        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.category, layout=(-1, 4))
-        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist,
-                                     by=df.classroom, layout=(2, 2))
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-
-        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))
-        self._check_axes_shape(axes, axes_num=4, layout=(4, 2),
-                               figsize=(12, 7))
-
-    @slow
-    def test_hist_no_overlap(self):
-        from matplotlib.pyplot import subplot, gcf
-        x = Series(randn(2))
-        y = Series(randn(2))
-        subplot(121)
-        x.hist()
-        subplot(122)
-        y.hist()
-        fig = gcf()
-        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
-        self.assertEqual(len(axes), 2)
-
-    @slow
-    def test_hist_secondary_legend(self):
-        # GH 9610
-        df = DataFrame(np.random.randn(30, 4), columns=list('abcd'))
-
-        # primary -> secondary
-        ax = df['a'].plot.hist(legend=True)
-        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left and right axis must be visible
-        self._check_legend_labels(ax, labels=['a', 'b (right)'])
-        self.assertTrue(ax.get_yaxis().get_visible())
-        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
-        tm.close()
-
-        # secondary -> secondary
-        ax = df['a'].plot.hist(legend=True, secondary_y=True)
-        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)
-        # both legends are draw on left ax
-        # left axis must be invisible, right axis must be visible
-        self._check_legend_labels(ax.left_ax,
-                                  labels=['a (right)', 'b (right)'])
-        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
-        self.assertTrue(ax.get_yaxis().get_visible())
-        tm.close()
-
-        # secondary -> primary
-        ax = df['a'].plot.hist(legend=True, secondary_y=True)
-        # right axes is returned
-        df['b'].plot.hist(ax=ax, legend=True)
-        # both legends are draw on left ax
-        # left and right axis must be visible
-        self._check_legend_labels(ax.left_ax, labels=['a (right)', 'b'])
-        self.assertTrue(ax.left_ax.get_yaxis().get_visible())
-        self.assertTrue(ax.get_yaxis().get_visible())
-        tm.close()
-
-    @slow
-    def test_df_series_secondary_legend(self):
-        # GH 9779
-        df = DataFrame(np.random.randn(30, 3), columns=list('abc'))
-        s = Series(np.random.randn(30), name='x')
-
-        # primary -> secondary (without passing ax)
-        ax = df.plot()
-        s.plot(legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left and right axis must be visible
-        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])
-        self.assertTrue(ax.get_yaxis().get_visible())
-        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
-        tm.close()
-
-        # primary -> secondary (with passing ax)
-        ax = df.plot()
-        s.plot(ax=ax, legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left and right axis must be visible
-        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])
-        self.assertTrue(ax.get_yaxis().get_visible())
-        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
-        tm.close()
-
-        # seconcary -> secondary (without passing ax)
-        ax = df.plot(secondary_y=True)
-        s.plot(legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left axis must be invisible and right axis must be visible
-        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']
-        self._check_legend_labels(ax.left_ax, labels=expected)
-        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
-        self.assertTrue(ax.get_yaxis().get_visible())
-        tm.close()
-
-        # secondary -> secondary (with passing ax)
-        ax = df.plot(secondary_y=True)
-        s.plot(ax=ax, legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left axis must be invisible and right axis must be visible
-        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']
-        self._check_legend_labels(ax.left_ax, expected)
-        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
-        self.assertTrue(ax.get_yaxis().get_visible())
-        tm.close()
-
-        # secondary -> secondary (with passing ax)
-        ax = df.plot(secondary_y=True, mark_right=False)
-        s.plot(ax=ax, legend=True, secondary_y=True)
-        # both legends are dran on left ax
-        # left axis must be invisible and right axis must be visible
-        expected = ['a', 'b', 'c', 'x (right)']
-        self._check_legend_labels(ax.left_ax, expected)
-        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
-        self.assertTrue(ax.get_yaxis().get_visible())
-        tm.close()
-
-    @slow
-    def test_plot_fails_with_dupe_color_and_style(self):
-        x = Series(randn(2))
-        with tm.assertRaises(ValueError):
-            x.plot(style='k--', color='k')
-
-    @slow
-    def test_hist_kde(self):
-        ax = self.ts.plot.hist(logy=True)
-        self._check_ax_scales(ax, yaxis='log')
-        xlabels = ax.get_xticklabels()
-        # ticks are values, thus ticklabels are blank
-        self._check_text_labels(xlabels, [''] * len(xlabels))
-        ylabels = ax.get_yticklabels()
-        self._check_text_labels(ylabels, [''] * len(ylabels))
-
-        tm._skip_if_no_scipy()
-        _skip_if_no_scipy_gaussian_kde()
-        _check_plot_works(self.ts.plot.kde)
-        _check_plot_works(self.ts.plot.density)
-        ax = self.ts.plot.kde(logy=True)
-        self._check_ax_scales(ax, yaxis='log')
-        xlabels = ax.get_xticklabels()
-        self._check_text_labels(xlabels, [''] * len(xlabels))
-        ylabels = ax.get_yticklabels()
-        self._check_text_labels(ylabels, [''] * len(ylabels))
-
-    @slow
-    def test_kde_kwargs(self):
-        tm._skip_if_no_scipy()
-        _skip_if_no_scipy_gaussian_kde()
-        from numpy import linspace
-        _check_plot_works(self.ts.plot.kde, bw_method=.5,
-                          ind=linspace(-100, 100, 20))
-        _check_plot_works(self.ts.plot.density, bw_method=.5,
-                          ind=linspace(-100, 100, 20))
-        ax = self.ts.plot.kde(logy=True, bw_method=.5,
-                              ind=linspace(-100, 100, 20))
-        self._check_ax_scales(ax, yaxis='log')
-        self._check_text_labels(ax.yaxis.get_label(), 'Density')
-
-    @slow
-    def test_kde_missing_vals(self):
-        tm._skip_if_no_scipy()
-        _skip_if_no_scipy_gaussian_kde()
-        s = Series(np.random.uniform(size=50))
-        s[0] = np.nan
-        _check_plot_works(s.plot.kde)
-
-    @slow
-    def test_hist_kwargs(self):
-        ax = self.ts.plot.hist(bins=5)
-        self.assertEqual(len(ax.patches), 5)
-        self._check_text_labels(ax.yaxis.get_label(), 'Frequency')
-        tm.close()
-
-        if self.mpl_ge_1_3_1:
-            ax = self.ts.plot.hist(orientation='horizontal')
-            self._check_text_labels(ax.xaxis.get_label(), 'Frequency')
-            tm.close()
-
-            ax = self.ts.plot.hist(align='left', stacked=True)
-            tm.close()
-
-    @slow
-    def test_hist_kde_color(self):
-        ax = self.ts.plot.hist(logy=True, bins=10, color='b')
-        self._check_ax_scales(ax, yaxis='log')
-        self.assertEqual(len(ax.patches), 10)
-        self._check_colors(ax.patches, facecolors=['b'] * 10)
-
-        tm._skip_if_no_scipy()
-        _skip_if_no_scipy_gaussian_kde()
-        ax = self.ts.plot.kde(logy=True, color='r')
-        self._check_ax_scales(ax, yaxis='log')
-        lines = ax.get_lines()
-        self.assertEqual(len(lines), 1)
-        self._check_colors(lines, ['r'])
-
-    @slow
-    def test_boxplot_series(self):
-        ax = self.ts.plot.box(logy=True)
-        self._check_ax_scales(ax, yaxis='log')
-        xlabels = ax.get_xticklabels()
-        self._check_text_labels(xlabels, [self.ts.name])
-        ylabels = ax.get_yticklabels()
-        self._check_text_labels(ylabels, [''] * len(ylabels))
-
-    @slow
-    def test_kind_both_ways(self):
-        s = Series(range(3))
-        for kind in plotting._common_kinds + plotting._series_kinds:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-            s.plot(kind=kind)
-            getattr(s.plot, kind)()
-
-    @slow
-    def test_invalid_plot_data(self):
-        s = Series(list('abcd'))
-        for kind in plotting._common_kinds:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-            with tm.assertRaises(TypeError):
-                s.plot(kind=kind)
-
-    @slow
-    def test_valid_object_plot(self):
-        s = Series(lrange(10), dtype=object)
-        for kind in plotting._common_kinds:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-            _check_plot_works(s.plot, kind=kind)
-
-    def test_partially_invalid_plot_data(self):
-        s = Series(['a', 'b', 1.0, 2])
-        for kind in plotting._common_kinds:
-            if not _ok_for_gaussian_kde(kind):
-                continue
-            with tm.assertRaises(TypeError):
-                s.plot(kind=kind)
-
-    def test_invalid_kind(self):
-        s = Series([1, 2])
-        with tm.assertRaises(ValueError):
-            s.plot(kind='aasdf')
-
-    @slow
-    def test_dup_datetime_index_plot(self):
-        dr1 = date_range('1/1/2009', periods=4)
-        dr2 = date_range('1/2/2009', periods=4)
-        index = dr1.append(dr2)
-        values = randn(index.size)
-        s = Series(values, index=index)
-        _check_plot_works(s.plot)
-
-    @slow
-    def test_errorbar_plot(self):
-
-        s = Series(np.arange(10), name='x')
-        s_err = np.random.randn(10)
-        d_err = DataFrame(randn(10, 2), index=s.index, columns=['x', 'y'])
-        # test line and bar plots
-        kinds = ['line', 'bar']
-        for kind in kinds:
-            ax = _check_plot_works(s.plot, yerr=Series(s_err), kind=kind)
-            self._check_has_errorbars(ax, xerr=0, yerr=1)
-            ax = _check_plot_works(s.plot, yerr=s_err, kind=kind)
-            self._check_has_errorbars(ax, xerr=0, yerr=1)
-            ax = _check_plot_works(s.plot, yerr=s_err.tolist(), kind=kind)
-            self._check_has_errorbars(ax, xerr=0, yerr=1)
-            ax = _check_plot_works(s.plot, yerr=d_err, kind=kind)
-            self._check_has_errorbars(ax, xerr=0, yerr=1)
-            ax = _check_plot_works(s.plot, xerr=0.2, yerr=0.2, kind=kind)
-            self._check_has_errorbars(ax, xerr=1, yerr=1)
-
-        ax = _check_plot_works(s.plot, xerr=s_err)
-        self._check_has_errorbars(ax, xerr=1, yerr=0)
-
-        # test time series plotting
-        ix = date_range('1/1/2000', '1/1/2001', freq='M')
-        ts = Series(np.arange(12), index=ix, name='x')
-        ts_err = Series(np.random.randn(12), index=ix)
-        td_err = DataFrame(randn(12, 2), index=ix, columns=['x', 'y'])
-
-        ax = _check_plot_works(ts.plot, yerr=ts_err)
-        self._check_has_errorbars(ax, xerr=0, yerr=1)
-        ax = _check_plot_works(ts.plot, yerr=td_err)
-        self._check_has_errorbars(ax, xerr=0, yerr=1)
-
-        # check incorrect lengths and types
-        with tm.assertRaises(ValueError):
-            s.plot(yerr=np.arange(11))
-
-        s_err = ['zzz'] * 10
-        # in mpl 1.5+ this is a TypeError
-        with tm.assertRaises((ValueError, TypeError)):
-            s.plot(yerr=s_err)
-
-    def test_table(self):
-        _check_plot_works(self.series.plot, table=True)
-        _check_plot_works(self.series.plot, table=self.series)
-
-    @slow
-    def test_series_grid_settings(self):
-        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
-        self._check_grid_settings(Series([1, 2, 3]),
-                                  plotting._series_kinds +
-                                  plotting._common_kinds)
-
-    @slow
-    def test_standard_colors(self):
-        for c in ['r', 'red', 'green', '#FF0000']:
-            result = plotting._get_standard_colors(1, color=c)
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(1, color=[c])
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(3, color=c)
-            self.assertEqual(result, [c] * 3)
-
-            result = plotting._get_standard_colors(3, color=[c])
-            self.assertEqual(result, [c] * 3)
-
-    @slow
-    def test_standard_colors_all(self):
-        import matplotlib.colors as colors
-
-        # multiple colors like mediumaquamarine
-        for c in colors.cnames:
-            result = plotting._get_standard_colors(num_colors=1, color=c)
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(num_colors=1, color=[c])
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(num_colors=3, color=c)
-            self.assertEqual(result, [c] * 3)
-
-            result = plotting._get_standard_colors(num_colors=3, color=[c])
-            self.assertEqual(result, [c] * 3)
-
-        # single letter colors like k
-        for c in colors.ColorConverter.colors:
-            result = plotting._get_standard_colors(num_colors=1, color=c)
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(num_colors=1, color=[c])
-            self.assertEqual(result, [c])
-
-            result = plotting._get_standard_colors(num_colors=3, color=c)
-            self.assertEqual(result, [c] * 3)
-
-            result = plotting._get_standard_colors(num_colors=3, color=[c])
-            self.assertEqual(result, [c] * 3)
-
-    def test_series_plot_color_kwargs(self):
-        # GH1890
-        ax = Series(np.arange(12) + 1).plot(color='green')
-        self._check_colors(ax.get_lines(), linecolors=['green'])
-
-    def test_time_series_plot_color_kwargs(self):
-        # #1890
-        ax = Series(np.arange(12) + 1, index=date_range(
-            '1/1/2000', periods=12)).plot(color='green')
-        self._check_colors(ax.get_lines(), linecolors=['green'])
-
-    def test_time_series_plot_color_with_empty_kwargs(self):
-        import matplotlib as mpl
-
-        if self.mpl_ge_1_5_0:
-            def_colors = self._maybe_unpack_cycler(mpl.rcParams)
-        else:
-            def_colors = mpl.rcParams['axes.color_cycle']
-        index = date_range('1/1/2000', periods=12)
-        s = Series(np.arange(1, 13), index=index)
-
-        ncolors = 3
-
-        for i in range(ncolors):
-            ax = s.plot()
-        self._check_colors(ax.get_lines(), linecolors=def_colors[:ncolors])
-
-    def test_xticklabels(self):
-        # GH11529
-        s = Series(np.arange(10), index=['P%02d' % i for i in range(10)])
-        ax = s.plot(xticks=[0, 3, 5, 9])
-        exp = ['P%02d' % i for i in [0, 3, 5, 9]]
-        self._check_text_labels(ax.get_xticklabels(), exp)
-
-    def test_custom_business_day_freq(self):
-        # GH7222
-        from pandas.tseries.offsets import CustomBusinessDay
-        s = Series(range(100, 121), index=pd.bdate_range(
-            start='2014-05-01', end='2014-06-01',
-            freq=CustomBusinessDay(holidays=['2014-05-26'])))
-
-        _check_plot_works(s.plot)
+""" Test cases for DataFrame.plot """
 
 
 @tm.mplskip
@@ -1305,10 +43,6 @@ class TestDataFramePlots(TestPlotBase):
                                     "C": np.arange(20) + np.random.uniform(
                                         size=20)})
 
-        from pandas import read_csv
-        path = os.path.join(curpath(), 'data', 'iris.csv')
-        self.iris = read_csv(path)
-
     @slow
     def test_plot(self):
         df = self.tdf
@@ -3939,103 +2673,6 @@ class TestDataFramePlots(TestPlotBase):
                                         for c in barplot.patches])
 
 
-@tm.mplskip
-class TestDataFrameGroupByPlots(TestPlotBase):
-
-    def test_series_groupby_plotting_nominally_works(self):
-        n = 10
-        weight = Series(np.random.normal(166, 20, size=n))
-        height = Series(np.random.normal(60, 10, size=n))
-        with tm.RNGContext(42):
-            gender = np.random.choice(['male', 'female'], size=n)
-
-        weight.groupby(gender).plot()
-        tm.close()
-        height.groupby(gender).hist()
-        tm.close()
-        # Regression test for GH8733
-        height.groupby(gender).plot(alpha=0.5)
-        tm.close()
-
-    def test_plotting_with_float_index_works(self):
-        # GH 7025
-        df = DataFrame({'def': [1, 1, 1, 2, 2, 2, 3, 3, 3],
-                        'val': np.random.randn(9)},
-                       index=[1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0])
-
-        df.groupby('def')['val'].plot()
-        tm.close()
-        df.groupby('def')['val'].apply(lambda x: x.plot())
-        tm.close()
-
-    def test_hist_single_row(self):
-        # GH10214
-        bins = np.arange(80, 100 + 2, 1)
-        df = DataFrame({"Name": ["AAA", "BBB"],
-                        "ByCol": [1, 2],
-                        "Mark": [85, 89]})
-        df["Mark"].hist(by=df["ByCol"], bins=bins)
-        df = DataFrame({"Name": ["AAA"], "ByCol": [1], "Mark": [85]})
-        df["Mark"].hist(by=df["ByCol"], bins=bins)
-
-    def test_plot_submethod_works(self):
-        df = DataFrame({'x': [1, 2, 3, 4, 5],
-                        'y': [1, 2, 3, 2, 1],
-                        'z': list('ababa')})
-        df.groupby('z').plot.scatter('x', 'y')
-        tm.close()
-        df.groupby('z')['x'].plot.line()
-        tm.close()
-
-    def test_plot_kwargs(self):
-
-        df = DataFrame({'x': [1, 2, 3, 4, 5],
-                        'y': [1, 2, 3, 2, 1],
-                        'z': list('ababa')})
-
-        res = df.groupby('z').plot(kind='scatter', x='x', y='y')
-        # check that a scatter plot is effectively plotted: the axes should
-        # contain a PathCollection from the scatter plot (GH11805)
-        self.assertEqual(len(res['a'].collections), 1)
-
-        res = df.groupby('z').plot.scatter(x='x', y='y')
-        self.assertEqual(len(res['a'].collections), 1)
-
-
-def _check_plot_works(f, filterwarnings='always', **kwargs):
-    import matplotlib.pyplot as plt
-    ret = None
-    with warnings.catch_warnings():
-        warnings.simplefilter(filterwarnings)
-        try:
-            try:
-                fig = kwargs['figure']
-            except KeyError:
-                fig = plt.gcf()
-
-            plt.clf()
-
-            ax = kwargs.get('ax', fig.add_subplot(211))  # noqa
-            ret = f(**kwargs)
-
-            assert_is_valid_plot_return_object(ret)
-
-            try:
-                kwargs['ax'] = fig.add_subplot(212)
-                ret = f(**kwargs)
-            except Exception:
-                pass
-            else:
-                assert_is_valid_plot_return_object(ret)
-
-            with ensure_clean(return_filelike=True) as path:
-                plt.savefig(path)
-        finally:
-            tm.close(fig)
-
-        return ret
-
-
 def _generate_4_axes_via_gridspec():
     import matplotlib.pyplot as plt
     import matplotlib as mpl
@@ -4050,11 +2687,6 @@ def _generate_4_axes_via_gridspec():
     return gs, [ax_tl, ax_ll, ax_tr, ax_lr]
 
 
-def curpath():
-    pth, _ = os.path.split(os.path.abspath(__file__))
-    return pth
-
-
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tests/plotting/test_groupby.py b/pandas/tests/plotting/test_groupby.py
new file mode 100644
index 000000000..101a6556c
--- /dev/null
+++ b/pandas/tests/plotting/test_groupby.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+
+from pandas import Series, DataFrame
+import pandas.util.testing as tm
+
+import numpy as np
+
+from pandas.tests.plotting.common import TestPlotBase
+
+
+""" Test cases for GroupBy.plot """
+
+
+@tm.mplskip
+class TestDataFrameGroupByPlots(TestPlotBase):
+
+    def test_series_groupby_plotting_nominally_works(self):
+        n = 10
+        weight = Series(np.random.normal(166, 20, size=n))
+        height = Series(np.random.normal(60, 10, size=n))
+        with tm.RNGContext(42):
+            gender = np.random.choice(['male', 'female'], size=n)
+
+        weight.groupby(gender).plot()
+        tm.close()
+        height.groupby(gender).hist()
+        tm.close()
+        # Regression test for GH8733
+        height.groupby(gender).plot(alpha=0.5)
+        tm.close()
+
+    def test_plotting_with_float_index_works(self):
+        # GH 7025
+        df = DataFrame({'def': [1, 1, 1, 2, 2, 2, 3, 3, 3],
+                        'val': np.random.randn(9)},
+                       index=[1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0])
+
+        df.groupby('def')['val'].plot()
+        tm.close()
+        df.groupby('def')['val'].apply(lambda x: x.plot())
+        tm.close()
+
+    def test_hist_single_row(self):
+        # GH10214
+        bins = np.arange(80, 100 + 2, 1)
+        df = DataFrame({"Name": ["AAA", "BBB"],
+                        "ByCol": [1, 2],
+                        "Mark": [85, 89]})
+        df["Mark"].hist(by=df["ByCol"], bins=bins)
+        df = DataFrame({"Name": ["AAA"], "ByCol": [1], "Mark": [85]})
+        df["Mark"].hist(by=df["ByCol"], bins=bins)
+
+    def test_plot_submethod_works(self):
+        df = DataFrame({'x': [1, 2, 3, 4, 5],
+                        'y': [1, 2, 3, 2, 1],
+                        'z': list('ababa')})
+        df.groupby('z').plot.scatter('x', 'y')
+        tm.close()
+        df.groupby('z')['x'].plot.line()
+        tm.close()
+
+    def test_plot_kwargs(self):
+
+        df = DataFrame({'x': [1, 2, 3, 4, 5],
+                        'y': [1, 2, 3, 2, 1],
+                        'z': list('ababa')})
+
+        res = df.groupby('z').plot(kind='scatter', x='x', y='y')
+        # check that a scatter plot is effectively plotted: the axes should
+        # contain a PathCollection from the scatter plot (GH11805)
+        self.assertEqual(len(res['a'].collections), 1)
+
+        res = df.groupby('z').plot.scatter(x='x', y='y')
+        self.assertEqual(len(res['a'].collections), 1)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tests/plotting/test_hist_method.py b/pandas/tests/plotting/test_hist_method.py
new file mode 100644
index 000000000..c7bff5a31
--- /dev/null
+++ b/pandas/tests/plotting/test_hist_method.py
@@ -0,0 +1,426 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+
+from pandas import Series, DataFrame
+import pandas.util.testing as tm
+from pandas.util.testing import slow
+
+import numpy as np
+from numpy.random import randn
+
+import pandas.tools.plotting as plotting
+from pandas.tests.plotting.common import (TestPlotBase, _check_plot_works)
+
+
+""" Test cases for .hist method """
+
+
+@tm.mplskip
+class TestSeriesPlots(TestPlotBase):
+
+    def setUp(self):
+        TestPlotBase.setUp(self)
+        import matplotlib as mpl
+        mpl.rcdefaults()
+
+        self.ts = tm.makeTimeSeries()
+        self.ts.name = 'ts'
+
+    @slow
+    def test_hist_legacy(self):
+        _check_plot_works(self.ts.hist)
+        _check_plot_works(self.ts.hist, grid=False)
+        _check_plot_works(self.ts.hist, figsize=(8, 10))
+        # _check_plot_works adds an ax so catch warning. see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(self.ts.hist, by=self.ts.index.month)
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(self.ts.hist, by=self.ts.index.month, bins=5)
+
+        fig, ax = self.plt.subplots(1, 1)
+        _check_plot_works(self.ts.hist, ax=ax)
+        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
+        _check_plot_works(self.ts.hist, figure=fig)
+        tm.close()
+
+        fig, (ax1, ax2) = self.plt.subplots(1, 2)
+        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
+        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)
+
+        with tm.assertRaises(ValueError):
+            self.ts.hist(by=self.ts.index, figure=fig)
+
+    @slow
+    def test_hist_bins_legacy(self):
+        df = DataFrame(np.random.randn(10, 2))
+        ax = df.hist(bins=2)[0][0]
+        self.assertEqual(len(ax.patches), 2)
+
+    @slow
+    def test_hist_layout(self):
+        df = self.hist_df
+        with tm.assertRaises(ValueError):
+            df.height.hist(layout=(1, 1))
+
+        with tm.assertRaises(ValueError):
+            df.height.hist(layout=[1, 1])
+
+    @slow
+    def test_hist_layout_with_by(self):
+        df = self.hist_df
+
+        # _check_plot_works adds an `ax` kwarg to the method call
+        # so we get a warning about an axis being cleared, even
+        # though we don't explicing pass one, see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist, by=df.gender,
+                                     layout=(2, 1))
+        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist, by=df.gender,
+                                     layout=(3, -1))
+        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist, by=df.category,
+                                     layout=(4, 1))
+        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(
+                df.height.hist, by=df.category, layout=(2, -1))
+        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(
+                df.height.hist, by=df.category, layout=(3, -1))
+        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(
+                df.height.hist, by=df.category, layout=(-1, 4))
+        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(
+                df.height.hist, by=df.classroom, layout=(2, 2))
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+
+        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))
+        self._check_axes_shape(
+            axes, axes_num=4, layout=(4, 2), figsize=(12, 7))
+
+    @slow
+    def test_hist_no_overlap(self):
+        from matplotlib.pyplot import subplot, gcf
+        x = Series(randn(2))
+        y = Series(randn(2))
+        subplot(121)
+        x.hist()
+        subplot(122)
+        y.hist()
+        fig = gcf()
+        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
+        self.assertEqual(len(axes), 2)
+
+    @slow
+    def test_hist_by_no_extra_plots(self):
+        df = self.hist_df
+        axes = df.height.hist(by=df.gender)  # noqa
+        self.assertEqual(len(self.plt.get_fignums()), 1)
+
+    @slow
+    def test_plot_fails_when_ax_differs_from_figure(self):
+        from pylab import figure
+        fig1 = figure()
+        fig2 = figure()
+        ax1 = fig1.add_subplot(111)
+        with tm.assertRaises(AssertionError):
+            self.ts.hist(ax=ax1, figure=fig2)
+
+
+@tm.mplskip
+class TestDataFramePlots(TestPlotBase):
+
+    @slow
+    def test_hist_df_legacy(self):
+        from matplotlib.patches import Rectangle
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(self.hist_df.hist)
+
+        # make sure layout is handled
+        df = DataFrame(randn(100, 3))
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.hist, grid=False)
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+        self.assertFalse(axes[1, 1].get_visible())
+
+        df = DataFrame(randn(100, 1))
+        _check_plot_works(df.hist)
+
+        # make sure layout is handled
+        df = DataFrame(randn(100, 6))
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.hist, layout=(4, 2))
+        self._check_axes_shape(axes, axes_num=6, layout=(4, 2))
+
+        # make sure sharex, sharey is handled
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.hist, sharex=True, sharey=True)
+
+        # handle figsize arg
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.hist, figsize=(8, 10))
+
+        # check bins argument
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(df.hist, bins=5)
+
+        # make sure xlabelsize and xrot are handled
+        ser = df[0]
+        xf, yf = 20, 18
+        xrot, yrot = 30, 40
+        axes = ser.hist(xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
+        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
+                                ylabelsize=yf, yrot=yrot)
+
+        xf, yf = 20, 18
+        xrot, yrot = 30, 40
+        axes = df.hist(xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
+        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
+                                ylabelsize=yf, yrot=yrot)
+
+        tm.close()
+        # make sure kwargs to hist are handled
+        ax = ser.hist(normed=True, cumulative=True, bins=4)
+        # height of last bin (index 5) must be 1.0
+        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
+        self.assertAlmostEqual(rects[-1].get_height(), 1.0)
+
+        tm.close()
+        ax = ser.hist(log=True)
+        # scale of y must be 'log'
+        self._check_ax_scales(ax, yaxis='log')
+
+        tm.close()
+
+        # propagate attr exception from matplotlib.Axes.hist
+        with tm.assertRaises(AttributeError):
+            ser.hist(foo='bar')
+
+    @slow
+    def test_hist_layout(self):
+        df = DataFrame(randn(100, 3))
+
+        layout_to_expected_size = (
+            {'layout': None, 'expected_size': (2, 2)},  # default is 2x2
+            {'layout': (2, 2), 'expected_size': (2, 2)},
+            {'layout': (4, 1), 'expected_size': (4, 1)},
+            {'layout': (1, 4), 'expected_size': (1, 4)},
+            {'layout': (3, 3), 'expected_size': (3, 3)},
+            {'layout': (-1, 4), 'expected_size': (1, 4)},
+            {'layout': (4, -1), 'expected_size': (4, 1)},
+            {'layout': (-1, 2), 'expected_size': (2, 2)},
+            {'layout': (2, -1), 'expected_size': (2, 2)}
+        )
+
+        for layout_test in layout_to_expected_size:
+            axes = df.hist(layout=layout_test['layout'])
+            expected = layout_test['expected_size']
+            self._check_axes_shape(axes, axes_num=3, layout=expected)
+
+        # layout too small for all 4 plots
+        with tm.assertRaises(ValueError):
+            df.hist(layout=(1, 1))
+
+        # invalid format for layout
+        with tm.assertRaises(ValueError):
+            df.hist(layout=(1,))
+        with tm.assertRaises(ValueError):
+            df.hist(layout=(-1, -1))
+
+
+@tm.mplskip
+class TestDataFrameGroupByPlots(TestPlotBase):
+
+    @slow
+    def test_grouped_hist_legacy(self):
+        from matplotlib.patches import Rectangle
+
+        df = DataFrame(randn(500, 2), columns=['A', 'B'])
+        df['C'] = np.random.randint(0, 4, 500)
+        df['D'] = ['X'] * 500
+
+        axes = plotting.grouped_hist(df.A, by=df.C)
+        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
+
+        tm.close()
+        axes = df.hist(by=df.C)
+        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
+
+        tm.close()
+        # group by a key with single value
+        axes = df.hist(by='D', rot=30)
+        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
+        self._check_ticks_props(axes, xrot=30)
+
+        tm.close()
+        # make sure kwargs to hist are handled
+        xf, yf = 20, 18
+        xrot, yrot = 30, 40
+        axes = plotting.grouped_hist(df.A, by=df.C, normed=True,
+                                     cumulative=True, bins=4,
+                                     xlabelsize=xf, xrot=xrot,
+                                     ylabelsize=yf, yrot=yrot)
+        # height of last bin (index 5) must be 1.0
+        for ax in axes.ravel():
+            rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
+            height = rects[-1].get_height()
+            self.assertAlmostEqual(height, 1.0)
+        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
+                                ylabelsize=yf, yrot=yrot)
+
+        tm.close()
+        axes = plotting.grouped_hist(df.A, by=df.C, log=True)
+        # scale of y must be 'log'
+        self._check_ax_scales(axes, yaxis='log')
+
+        tm.close()
+        # propagate attr exception from matplotlib.Axes.hist
+        with tm.assertRaises(AttributeError):
+            plotting.grouped_hist(df.A, by=df.C, foo='bar')
+
+        with tm.assert_produces_warning(FutureWarning):
+            df.hist(by='C', figsize='default')
+
+    @slow
+    def test_grouped_hist_legacy2(self):
+        n = 10
+        weight = Series(np.random.normal(166, 20, size=n))
+        height = Series(np.random.normal(60, 10, size=n))
+        with tm.RNGContext(42):
+            gender_int = np.random.choice([0, 1], size=n)
+        df_int = DataFrame({'height': height, 'weight': weight,
+                            'gender': gender_int})
+        gb = df_int.groupby('gender')
+        axes = gb.hist()
+        self.assertEqual(len(axes), 2)
+        self.assertEqual(len(self.plt.get_fignums()), 2)
+        tm.close()
+
+    @slow
+    def test_grouped_hist_layout(self):
+        df = self.hist_df
+        self.assertRaises(ValueError, df.hist, column='weight', by=df.gender,
+                          layout=(1, 1))
+        self.assertRaises(ValueError, df.hist, column='height', by=df.category,
+                          layout=(1, 3))
+        self.assertRaises(ValueError, df.hist, column='height', by=df.category,
+                          layout=(-1, -1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.hist, column='height', by=df.gender,
+                                     layout=(2, 1))
+        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.hist, column='height', by=df.gender,
+                                     layout=(2, -1))
+        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
+
+        axes = df.hist(column='height', by=df.category, layout=(4, 1))
+        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
+
+        axes = df.hist(column='height', by=df.category, layout=(-1, 1))
+        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
+
+        axes = df.hist(column='height', by=df.category,
+                       layout=(4, 2), figsize=(12, 8))
+        self._check_axes_shape(
+            axes, axes_num=4, layout=(4, 2), figsize=(12, 8))
+        tm.close()
+
+        # GH 6769
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(
+                df.hist, column='height', by='classroom', layout=(2, 2))
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+
+        # without column
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.hist, by='classroom')
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+
+        axes = df.hist(by='gender', layout=(3, 5))
+        self._check_axes_shape(axes, axes_num=2, layout=(3, 5))
+
+        axes = df.hist(column=['height', 'weight', 'category'])
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+
+    @slow
+    def test_grouped_hist_multiple_axes(self):
+        # GH 6970, GH 7069
+        df = self.hist_df
+
+        fig, axes = self.plt.subplots(2, 3)
+        returned = df.hist(column=['height', 'weight', 'category'], ax=axes[0])
+        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
+        self.assert_numpy_array_equal(returned, axes[0])
+        self.assertIs(returned[0].figure, fig)
+        returned = df.hist(by='classroom', ax=axes[1])
+        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
+        self.assert_numpy_array_equal(returned, axes[1])
+        self.assertIs(returned[0].figure, fig)
+
+        with tm.assertRaises(ValueError):
+            fig, axes = self.plt.subplots(2, 3)
+            # pass different number of axes from required
+            axes = df.hist(column='height', ax=axes)
+
+    @slow
+    def test_axis_share_x(self):
+        df = self.hist_df
+        # GH4089
+        ax1, ax2 = df.hist(column='height', by=df.gender, sharex=True)
+
+        # share x
+        self.assertTrue(ax1._shared_x_axes.joined(ax1, ax2))
+        self.assertTrue(ax2._shared_x_axes.joined(ax1, ax2))
+
+        # don't share y
+        self.assertFalse(ax1._shared_y_axes.joined(ax1, ax2))
+        self.assertFalse(ax2._shared_y_axes.joined(ax1, ax2))
+
+    @slow
+    def test_axis_share_y(self):
+        df = self.hist_df
+        ax1, ax2 = df.hist(column='height', by=df.gender, sharey=True)
+
+        # share y
+        self.assertTrue(ax1._shared_y_axes.joined(ax1, ax2))
+        self.assertTrue(ax2._shared_y_axes.joined(ax1, ax2))
+
+        # don't share x
+        self.assertFalse(ax1._shared_x_axes.joined(ax1, ax2))
+        self.assertFalse(ax2._shared_x_axes.joined(ax1, ax2))
+
+    @slow
+    def test_axis_share_xy(self):
+        df = self.hist_df
+        ax1, ax2 = df.hist(column='height', by=df.gender, sharex=True,
+                           sharey=True)
+
+        # share both x and y
+        self.assertTrue(ax1._shared_x_axes.joined(ax1, ax2))
+        self.assertTrue(ax2._shared_x_axes.joined(ax1, ax2))
+
+        self.assertTrue(ax1._shared_y_axes.joined(ax1, ax2))
+        self.assertTrue(ax2._shared_y_axes.joined(ax1, ax2))
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tests/plotting/test_misc.py b/pandas/tests/plotting/test_misc.py
new file mode 100644
index 000000000..8b9a4fe05
--- /dev/null
+++ b/pandas/tests/plotting/test_misc.py
@@ -0,0 +1,277 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+
+from pandas import Series, DataFrame
+from pandas.compat import lmap
+import pandas.util.testing as tm
+from pandas.util.testing import slow
+
+import numpy as np
+from numpy import random
+from numpy.random import randn
+
+import pandas.tools.plotting as plotting
+from pandas.tests.plotting.common import (TestPlotBase, _check_plot_works,
+                                          _ok_for_gaussian_kde)
+
+
+""" Test cases for misc plot functions """
+
+
+@tm.mplskip
+class TestSeriesPlots(TestPlotBase):
+
+    def setUp(self):
+        TestPlotBase.setUp(self)
+        import matplotlib as mpl
+        mpl.rcdefaults()
+
+        self.ts = tm.makeTimeSeries()
+        self.ts.name = 'ts'
+
+    @slow
+    def test_autocorrelation_plot(self):
+        from pandas.tools.plotting import autocorrelation_plot
+        _check_plot_works(autocorrelation_plot, series=self.ts)
+        _check_plot_works(autocorrelation_plot, series=self.ts.values)
+
+        ax = autocorrelation_plot(self.ts, label='Test')
+        self._check_legend_labels(ax, labels=['Test'])
+
+    @slow
+    def test_lag_plot(self):
+        from pandas.tools.plotting import lag_plot
+        _check_plot_works(lag_plot, series=self.ts)
+        _check_plot_works(lag_plot, series=self.ts, lag=5)
+
+    @slow
+    def test_bootstrap_plot(self):
+        from pandas.tools.plotting import bootstrap_plot
+        _check_plot_works(bootstrap_plot, series=self.ts, size=10)
+
+
+@tm.mplskip
+class TestDataFramePlots(TestPlotBase):
+
+    @slow
+    def test_scatter_plot_legacy(self):
+        tm._skip_if_no_scipy()
+
+        df = DataFrame(randn(100, 2))
+
+        def scat(**kwds):
+            return plotting.scatter_matrix(df, **kwds)
+
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat)
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat, marker='+')
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat, vmin=0)
+        if _ok_for_gaussian_kde('kde'):
+            with tm.assert_produces_warning(UserWarning):
+                _check_plot_works(scat, diagonal='kde')
+        if _ok_for_gaussian_kde('density'):
+            with tm.assert_produces_warning(UserWarning):
+                _check_plot_works(scat, diagonal='density')
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat, diagonal='hist')
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat, range_padding=.1)
+
+        def scat2(x, y, by=None, ax=None, figsize=None):
+            return plotting.scatter_plot(df, x, y, by, ax, figsize=None)
+
+        _check_plot_works(scat2, x=0, y=1)
+        grouper = Series(np.repeat([1, 2, 3, 4, 5], 20), df.index)
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(scat2, x=0, y=1, by=grouper)
+
+    def test_scatter_matrix_axis(self):
+        tm._skip_if_no_scipy()
+        scatter_matrix = plotting.scatter_matrix
+
+        with tm.RNGContext(42):
+            df = DataFrame(randn(100, 3))
+
+        # we are plotting multiples on a sub-plot
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(scatter_matrix, filterwarnings='always',
+                                     frame=df, range_padding=.1)
+        axes0_labels = axes[0][0].yaxis.get_majorticklabels()
+
+        # GH 5662
+        expected = ['-2', '-1', '0', '1', '2']
+        self._check_text_labels(axes0_labels, expected)
+        self._check_ticks_props(
+            axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
+
+        df[0] = ((df[0] - 2) / 3)
+
+        # we are plotting multiples on a sub-plot
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(scatter_matrix, filterwarnings='always',
+                                     frame=df, range_padding=.1)
+        axes0_labels = axes[0][0].yaxis.get_majorticklabels()
+        expected = ['-1.2', '-1.0', '-0.8', '-0.6', '-0.4', '-0.2', '0.0']
+        self._check_text_labels(axes0_labels, expected)
+        self._check_ticks_props(
+            axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
+
+    @slow
+    def test_andrews_curves(self):
+        from pandas.tools.plotting import andrews_curves
+        from matplotlib import cm
+
+        df = self.iris
+
+        _check_plot_works(andrews_curves, frame=df, class_column='Name')
+
+        rgba = ('#556270', '#4ECDC4', '#C7F464')
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', color=rgba)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
+
+        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', color=cnames)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
+
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', colormap=cm.jet)
+        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
+
+        length = 10
+        df = DataFrame({"A": random.rand(length),
+                        "B": random.rand(length),
+                        "C": random.rand(length),
+                        "Name": ["A"] * length})
+
+        _check_plot_works(andrews_curves, frame=df, class_column='Name')
+
+        rgba = ('#556270', '#4ECDC4', '#C7F464')
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', color=rgba)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
+
+        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', color=cnames)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
+
+        ax = _check_plot_works(andrews_curves, frame=df,
+                               class_column='Name', colormap=cm.jet)
+        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
+
+        colors = ['b', 'g', 'r']
+        df = DataFrame({"A": [1, 2, 3],
+                        "B": [1, 2, 3],
+                        "C": [1, 2, 3],
+                        "Name": colors})
+        ax = andrews_curves(df, 'Name', color=colors)
+        handles, labels = ax.get_legend_handles_labels()
+        self._check_colors(handles, linecolors=colors)
+
+        with tm.assert_produces_warning(FutureWarning):
+            andrews_curves(data=df, class_column='Name')
+
+    @slow
+    def test_parallel_coordinates(self):
+        from pandas.tools.plotting import parallel_coordinates
+        from matplotlib import cm
+
+        df = self.iris
+
+        ax = _check_plot_works(parallel_coordinates,
+                               frame=df, class_column='Name')
+        nlines = len(ax.get_lines())
+        nxticks = len(ax.xaxis.get_ticklabels())
+
+        rgba = ('#556270', '#4ECDC4', '#C7F464')
+        ax = _check_plot_works(parallel_coordinates,
+                               frame=df, class_column='Name', color=rgba)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
+
+        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
+        ax = _check_plot_works(parallel_coordinates,
+                               frame=df, class_column='Name', color=cnames)
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
+
+        ax = _check_plot_works(parallel_coordinates,
+                               frame=df, class_column='Name', colormap=cm.jet)
+        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
+        self._check_colors(
+            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
+
+        ax = _check_plot_works(parallel_coordinates,
+                               frame=df, class_column='Name', axvlines=False)
+        assert len(ax.get_lines()) == (nlines - nxticks)
+
+        colors = ['b', 'g', 'r']
+        df = DataFrame({"A": [1, 2, 3],
+                        "B": [1, 2, 3],
+                        "C": [1, 2, 3],
+                        "Name": colors})
+        ax = parallel_coordinates(df, 'Name', color=colors)
+        handles, labels = ax.get_legend_handles_labels()
+        self._check_colors(handles, linecolors=colors)
+
+        with tm.assert_produces_warning(FutureWarning):
+            parallel_coordinates(data=df, class_column='Name')
+        with tm.assert_produces_warning(FutureWarning):
+            parallel_coordinates(df, 'Name', colors=colors)
+
+    @slow
+    def test_radviz(self):
+        from pandas.tools.plotting import radviz
+        from matplotlib import cm
+
+        df = self.iris
+        _check_plot_works(radviz, frame=df, class_column='Name')
+
+        rgba = ('#556270', '#4ECDC4', '#C7F464')
+        ax = _check_plot_works(
+            radviz, frame=df, class_column='Name', color=rgba)
+        # skip Circle drawn as ticks
+        patches = [p for p in ax.patches[:20] if p.get_label() != '']
+        self._check_colors(
+            patches[:10], facecolors=rgba, mapping=df['Name'][:10])
+
+        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
+        _check_plot_works(radviz, frame=df, class_column='Name', color=cnames)
+        patches = [p for p in ax.patches[:20] if p.get_label() != '']
+        self._check_colors(patches, facecolors=cnames, mapping=df['Name'][:10])
+
+        _check_plot_works(radviz, frame=df,
+                          class_column='Name', colormap=cm.jet)
+        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
+        patches = [p for p in ax.patches[:20] if p.get_label() != '']
+        self._check_colors(patches, facecolors=cmaps, mapping=df['Name'][:10])
+
+        colors = [[0., 0., 1., 1.],
+                  [0., 0.5, 1., 1.],
+                  [1., 0., 0., 1.]]
+        df = DataFrame({"A": [1, 2, 3],
+                        "B": [2, 1, 3],
+                        "C": [3, 2, 1],
+                        "Name": ['b', 'g', 'r']})
+        ax = radviz(df, 'Name', color=colors)
+        handles, labels = ax.get_legend_handles_labels()
+        self._check_colors(handles, facecolors=colors)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tests/plotting/test_series.py b/pandas/tests/plotting/test_series.py
new file mode 100644
index 000000000..2bd2f8255
--- /dev/null
+++ b/pandas/tests/plotting/test_series.py
@@ -0,0 +1,807 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import nose
+import itertools
+
+from datetime import datetime
+
+import pandas as pd
+from pandas import Series, DataFrame, date_range
+from pandas.compat import range, lrange
+import pandas.util.testing as tm
+from pandas.util.testing import slow
+
+import numpy as np
+from numpy.random import randn
+
+import pandas.tools.plotting as plotting
+from pandas.tests.plotting.common import (TestPlotBase, _check_plot_works,
+                                          _skip_if_no_scipy_gaussian_kde,
+                                          _ok_for_gaussian_kde)
+
+
+""" Test cases for Series.plot """
+
+
+@tm.mplskip
+class TestSeriesPlots(TestPlotBase):
+
+    def setUp(self):
+        TestPlotBase.setUp(self)
+        import matplotlib as mpl
+        mpl.rcdefaults()
+
+        self.ts = tm.makeTimeSeries()
+        self.ts.name = 'ts'
+
+        self.series = tm.makeStringSeries()
+        self.series.name = 'series'
+
+        self.iseries = tm.makePeriodSeries()
+        self.iseries.name = 'iseries'
+
+    @slow
+    def test_plot(self):
+        _check_plot_works(self.ts.plot, label='foo')
+        _check_plot_works(self.ts.plot, use_index=False)
+        axes = _check_plot_works(self.ts.plot, rot=0)
+        self._check_ticks_props(axes, xrot=0)
+
+        ax = _check_plot_works(self.ts.plot, style='.', logy=True)
+        self._check_ax_scales(ax, yaxis='log')
+
+        ax = _check_plot_works(self.ts.plot, style='.', logx=True)
+        self._check_ax_scales(ax, xaxis='log')
+
+        ax = _check_plot_works(self.ts.plot, style='.', loglog=True)
+        self._check_ax_scales(ax, xaxis='log', yaxis='log')
+
+        _check_plot_works(self.ts[:10].plot.bar)
+        _check_plot_works(self.ts.plot.area, stacked=False)
+        _check_plot_works(self.iseries.plot)
+
+        for kind in ['line', 'bar', 'barh', 'kde', 'hist', 'box']:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+            _check_plot_works(self.series[:5].plot, kind=kind)
+
+        _check_plot_works(self.series[:10].plot.barh)
+        ax = _check_plot_works(Series(randn(10)).plot.bar, color='black')
+        self._check_colors([ax.patches[0]], facecolors=['black'])
+
+        # GH 6951
+        ax = _check_plot_works(self.ts.plot, subplots=True)
+        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
+
+        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(-1, 1))
+        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
+        ax = _check_plot_works(self.ts.plot, subplots=True, layout=(1, -1))
+        self._check_axes_shape(ax, axes_num=1, layout=(1, 1))
+
+    @slow
+    def test_plot_figsize_and_title(self):
+        # figsize and title
+        ax = self.series.plot(title='Test', figsize=(16, 8))
+        self._check_text_labels(ax.title, 'Test')
+        self._check_axes_shape(ax, axes_num=1, layout=(1, 1), figsize=(16, 8))
+
+    def test_dont_modify_rcParams(self):
+        # GH 8242
+        if self.mpl_ge_1_5_0:
+            key = 'axes.prop_cycle'
+        else:
+            key = 'axes.color_cycle'
+        colors = self.plt.rcParams[key]
+        Series([1, 2, 3]).plot()
+        self.assertEqual(colors, self.plt.rcParams[key])
+
+    def test_ts_line_lim(self):
+        ax = self.ts.plot()
+        xmin, xmax = ax.get_xlim()
+        lines = ax.get_lines()
+        self.assertEqual(xmin, lines[0].get_data(orig=False)[0][0])
+        self.assertEqual(xmax, lines[0].get_data(orig=False)[0][-1])
+        tm.close()
+
+        ax = self.ts.plot(secondary_y=True)
+        xmin, xmax = ax.get_xlim()
+        lines = ax.get_lines()
+        self.assertEqual(xmin, lines[0].get_data(orig=False)[0][0])
+        self.assertEqual(xmax, lines[0].get_data(orig=False)[0][-1])
+
+    def test_ts_area_lim(self):
+        ax = self.ts.plot.area(stacked=False)
+        xmin, xmax = ax.get_xlim()
+        line = ax.get_lines()[0].get_data(orig=False)[0]
+        self.assertEqual(xmin, line[0])
+        self.assertEqual(xmax, line[-1])
+        tm.close()
+
+        # GH 7471
+        ax = self.ts.plot.area(stacked=False, x_compat=True)
+        xmin, xmax = ax.get_xlim()
+        line = ax.get_lines()[0].get_data(orig=False)[0]
+        self.assertEqual(xmin, line[0])
+        self.assertEqual(xmax, line[-1])
+        tm.close()
+
+        tz_ts = self.ts.copy()
+        tz_ts.index = tz_ts.tz_localize('GMT').tz_convert('CET')
+        ax = tz_ts.plot.area(stacked=False, x_compat=True)
+        xmin, xmax = ax.get_xlim()
+        line = ax.get_lines()[0].get_data(orig=False)[0]
+        self.assertEqual(xmin, line[0])
+        self.assertEqual(xmax, line[-1])
+        tm.close()
+
+        ax = tz_ts.plot.area(stacked=False, secondary_y=True)
+        xmin, xmax = ax.get_xlim()
+        line = ax.get_lines()[0].get_data(orig=False)[0]
+        self.assertEqual(xmin, line[0])
+        self.assertEqual(xmax, line[-1])
+
+    def test_label(self):
+        s = Series([1, 2])
+        ax = s.plot(label='LABEL', legend=True)
+        self._check_legend_labels(ax, labels=['LABEL'])
+        self.plt.close()
+        ax = s.plot(legend=True)
+        self._check_legend_labels(ax, labels=['None'])
+        self.plt.close()
+        # get name from index
+        s.name = 'NAME'
+        ax = s.plot(legend=True)
+        self._check_legend_labels(ax, labels=['NAME'])
+        self.plt.close()
+        # override the default
+        ax = s.plot(legend=True, label='LABEL')
+        self._check_legend_labels(ax, labels=['LABEL'])
+        self.plt.close()
+        # Add lebel info, but don't draw
+        ax = s.plot(legend=False, label='LABEL')
+        self.assertEqual(ax.get_legend(), None)  # Hasn't been drawn
+        ax.legend()  # draw it
+        self._check_legend_labels(ax, labels=['LABEL'])
+
+    def test_line_area_nan_series(self):
+        values = [1, 2, np.nan, 3]
+        s = Series(values)
+        ts = Series(values, index=tm.makeDateIndex(k=4))
+
+        for d in [s, ts]:
+            ax = _check_plot_works(d.plot)
+            masked = ax.lines[0].get_ydata()
+            # remove nan for comparison purpose
+            exp = np.array([1, 2, 3], dtype=np.float64)
+            self.assert_numpy_array_equal(np.delete(masked.data, 2), exp)
+            self.assert_numpy_array_equal(
+                masked.mask, np.array([False, False, True, False]))
+
+            expected = np.array([1, 2, 0, 3], dtype=np.float64)
+            ax = _check_plot_works(d.plot, stacked=True)
+            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
+            ax = _check_plot_works(d.plot.area)
+            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
+            ax = _check_plot_works(d.plot.area, stacked=False)
+            self.assert_numpy_array_equal(ax.lines[0].get_ydata(), expected)
+
+    def test_line_use_index_false(self):
+        s = Series([1, 2, 3], index=['a', 'b', 'c'])
+        s.index.name = 'The Index'
+        ax = s.plot(use_index=False)
+        label = ax.get_xlabel()
+        self.assertEqual(label, '')
+        ax2 = s.plot.bar(use_index=False)
+        label2 = ax2.get_xlabel()
+        self.assertEqual(label2, '')
+
+    @slow
+    def test_bar_log(self):
+        expected = np.array([1., 10., 100., 1000.])
+
+        if not self.mpl_le_1_2_1:
+            expected = np.hstack((.1, expected, 1e4))
+
+        ax = Series([200, 500]).plot.bar(log=True)
+        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)
+        tm.close()
+
+        ax = Series([200, 500]).plot.barh(log=True)
+        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)
+        tm.close()
+
+        # GH 9905
+        expected = np.array([1.0e-03, 1.0e-02, 1.0e-01, 1.0e+00])
+
+        if not self.mpl_le_1_2_1:
+            expected = np.hstack((1.0e-04, expected, 1.0e+01))
+
+        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='bar')
+        self.assertEqual(ax.get_ylim(), (0.001, 0.10000000000000001))
+        tm.assert_numpy_array_equal(ax.yaxis.get_ticklocs(), expected)
+        tm.close()
+
+        ax = Series([0.1, 0.01, 0.001]).plot(log=True, kind='barh')
+        self.assertEqual(ax.get_xlim(), (0.001, 0.10000000000000001))
+        tm.assert_numpy_array_equal(ax.xaxis.get_ticklocs(), expected)
+
+    @slow
+    def test_bar_ignore_index(self):
+        df = Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
+        ax = df.plot.bar(use_index=False)
+        self._check_text_labels(ax.get_xticklabels(), ['0', '1', '2', '3'])
+
+    def test_rotation(self):
+        df = DataFrame(randn(5, 5))
+        # Default rot 0
+        axes = df.plot()
+        self._check_ticks_props(axes, xrot=0)
+
+        axes = df.plot(rot=30)
+        self._check_ticks_props(axes, xrot=30)
+
+    def test_irregular_datetime(self):
+        rng = date_range('1/1/2000', '3/1/2000')
+        rng = rng[[0, 1, 2, 3, 5, 9, 10, 11, 12]]
+        ser = Series(randn(len(rng)), rng)
+        ax = ser.plot()
+        xp = datetime(1999, 1, 1).toordinal()
+        ax.set_xlim('1/1/1999', '1/1/2001')
+        self.assertEqual(xp, ax.get_xlim()[0])
+
+    @slow
+    def test_pie_series(self):
+        # if sum of values is less than 1.0, pie handle them as rate and draw
+        # semicircle.
+        series = Series(np.random.randint(1, 5),
+                        index=['a', 'b', 'c', 'd', 'e'], name='YLABEL')
+        ax = _check_plot_works(series.plot.pie)
+        self._check_text_labels(ax.texts, series.index)
+        self.assertEqual(ax.get_ylabel(), 'YLABEL')
+
+        # without wedge labels
+        ax = _check_plot_works(series.plot.pie, labels=None)
+        self._check_text_labels(ax.texts, [''] * 5)
+
+        # with less colors than elements
+        color_args = ['r', 'g', 'b']
+        ax = _check_plot_works(series.plot.pie, colors=color_args)
+
+        color_expected = ['r', 'g', 'b', 'r', 'g']
+        self._check_colors(ax.patches, facecolors=color_expected)
+
+        # with labels and colors
+        labels = ['A', 'B', 'C', 'D', 'E']
+        color_args = ['r', 'g', 'b', 'c', 'm']
+        ax = _check_plot_works(series.plot.pie, labels=labels,
+                               colors=color_args)
+        self._check_text_labels(ax.texts, labels)
+        self._check_colors(ax.patches, facecolors=color_args)
+
+        # with autopct and fontsize
+        ax = _check_plot_works(series.plot.pie, colors=color_args,
+                               autopct='%.2f', fontsize=7)
+        pcts = ['{0:.2f}'.format(s * 100)
+                for s in series.values / float(series.sum())]
+        iters = [iter(series.index), iter(pcts)]
+        expected_texts = list(next(it) for it in itertools.cycle(iters))
+        self._check_text_labels(ax.texts, expected_texts)
+        for t in ax.texts:
+            self.assertEqual(t.get_fontsize(), 7)
+
+        # includes negative value
+        with tm.assertRaises(ValueError):
+            series = Series([1, 2, 0, 4, -1], index=['a', 'b', 'c', 'd', 'e'])
+            series.plot.pie()
+
+        # includes nan
+        series = Series([1, 2, np.nan, 4], index=['a', 'b', 'c', 'd'],
+                        name='YLABEL')
+        ax = _check_plot_works(series.plot.pie)
+        self._check_text_labels(ax.texts, ['a', 'b', '', 'd'])
+
+    def test_pie_nan(self):
+        s = Series([1, np.nan, 1, 1])
+        ax = s.plot.pie(legend=True)
+        expected = ['0', '', '2', '3']
+        result = [x.get_text() for x in ax.texts]
+        self.assertEqual(result, expected)
+
+    @slow
+    def test_hist_df_kwargs(self):
+        df = DataFrame(np.random.randn(10, 2))
+        ax = df.plot.hist(bins=5)
+        self.assertEqual(len(ax.patches), 10)
+
+    @slow
+    def test_hist_df_with_nonnumerics(self):
+        # GH 9853
+        with tm.RNGContext(1):
+            df = DataFrame(
+                np.random.randn(10, 4), columns=['A', 'B', 'C', 'D'])
+        df['E'] = ['x', 'y'] * 5
+        ax = df.plot.hist(bins=5)
+        self.assertEqual(len(ax.patches), 20)
+
+        ax = df.plot.hist()  # bins=10
+        self.assertEqual(len(ax.patches), 40)
+
+    @slow
+    def test_hist_legacy(self):
+        _check_plot_works(self.ts.hist)
+        _check_plot_works(self.ts.hist, grid=False)
+        _check_plot_works(self.ts.hist, figsize=(8, 10))
+        # _check_plot_works adds an ax so catch warning. see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(self.ts.hist,
+                              by=self.ts.index.month)
+        with tm.assert_produces_warning(UserWarning):
+            _check_plot_works(self.ts.hist,
+                              by=self.ts.index.month, bins=5)
+
+        fig, ax = self.plt.subplots(1, 1)
+        _check_plot_works(self.ts.hist, ax=ax)
+        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
+        _check_plot_works(self.ts.hist, figure=fig)
+        tm.close()
+
+        fig, (ax1, ax2) = self.plt.subplots(1, 2)
+        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
+        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)
+
+        with tm.assertRaises(ValueError):
+            self.ts.hist(by=self.ts.index, figure=fig)
+
+    @slow
+    def test_hist_bins_legacy(self):
+        df = DataFrame(np.random.randn(10, 2))
+        ax = df.hist(bins=2)[0][0]
+        self.assertEqual(len(ax.patches), 2)
+
+    @slow
+    def test_hist_layout(self):
+        df = self.hist_df
+        with tm.assertRaises(ValueError):
+            df.height.hist(layout=(1, 1))
+
+        with tm.assertRaises(ValueError):
+            df.height.hist(layout=[1, 1])
+
+    @slow
+    def test_hist_layout_with_by(self):
+        df = self.hist_df
+
+        # _check_plot_works adds an ax so catch warning. see GH #13188
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.gender, layout=(2, 1))
+        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.gender, layout=(3, -1))
+        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.category, layout=(4, 1))
+        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.category, layout=(2, -1))
+        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.category, layout=(3, -1))
+        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.category, layout=(-1, 4))
+        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))
+
+        with tm.assert_produces_warning(UserWarning):
+            axes = _check_plot_works(df.height.hist,
+                                     by=df.classroom, layout=(2, 2))
+        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
+
+        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))
+        self._check_axes_shape(axes, axes_num=4, layout=(4, 2),
+                               figsize=(12, 7))
+
+    @slow
+    def test_hist_no_overlap(self):
+        from matplotlib.pyplot import subplot, gcf
+        x = Series(randn(2))
+        y = Series(randn(2))
+        subplot(121)
+        x.hist()
+        subplot(122)
+        y.hist()
+        fig = gcf()
+        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
+        self.assertEqual(len(axes), 2)
+
+    @slow
+    def test_hist_secondary_legend(self):
+        # GH 9610
+        df = DataFrame(np.random.randn(30, 4), columns=list('abcd'))
+
+        # primary -> secondary
+        ax = df['a'].plot.hist(legend=True)
+        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left and right axis must be visible
+        self._check_legend_labels(ax, labels=['a', 'b (right)'])
+        self.assertTrue(ax.get_yaxis().get_visible())
+        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
+        tm.close()
+
+        # secondary -> secondary
+        ax = df['a'].plot.hist(legend=True, secondary_y=True)
+        df['b'].plot.hist(ax=ax, legend=True, secondary_y=True)
+        # both legends are draw on left ax
+        # left axis must be invisible, right axis must be visible
+        self._check_legend_labels(ax.left_ax,
+                                  labels=['a (right)', 'b (right)'])
+        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
+        self.assertTrue(ax.get_yaxis().get_visible())
+        tm.close()
+
+        # secondary -> primary
+        ax = df['a'].plot.hist(legend=True, secondary_y=True)
+        # right axes is returned
+        df['b'].plot.hist(ax=ax, legend=True)
+        # both legends are draw on left ax
+        # left and right axis must be visible
+        self._check_legend_labels(ax.left_ax, labels=['a (right)', 'b'])
+        self.assertTrue(ax.left_ax.get_yaxis().get_visible())
+        self.assertTrue(ax.get_yaxis().get_visible())
+        tm.close()
+
+    @slow
+    def test_df_series_secondary_legend(self):
+        # GH 9779
+        df = DataFrame(np.random.randn(30, 3), columns=list('abc'))
+        s = Series(np.random.randn(30), name='x')
+
+        # primary -> secondary (without passing ax)
+        ax = df.plot()
+        s.plot(legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left and right axis must be visible
+        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])
+        self.assertTrue(ax.get_yaxis().get_visible())
+        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
+        tm.close()
+
+        # primary -> secondary (with passing ax)
+        ax = df.plot()
+        s.plot(ax=ax, legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left and right axis must be visible
+        self._check_legend_labels(ax, labels=['a', 'b', 'c', 'x (right)'])
+        self.assertTrue(ax.get_yaxis().get_visible())
+        self.assertTrue(ax.right_ax.get_yaxis().get_visible())
+        tm.close()
+
+        # seconcary -> secondary (without passing ax)
+        ax = df.plot(secondary_y=True)
+        s.plot(legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left axis must be invisible and right axis must be visible
+        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']
+        self._check_legend_labels(ax.left_ax, labels=expected)
+        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
+        self.assertTrue(ax.get_yaxis().get_visible())
+        tm.close()
+
+        # secondary -> secondary (with passing ax)
+        ax = df.plot(secondary_y=True)
+        s.plot(ax=ax, legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left axis must be invisible and right axis must be visible
+        expected = ['a (right)', 'b (right)', 'c (right)', 'x (right)']
+        self._check_legend_labels(ax.left_ax, expected)
+        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
+        self.assertTrue(ax.get_yaxis().get_visible())
+        tm.close()
+
+        # secondary -> secondary (with passing ax)
+        ax = df.plot(secondary_y=True, mark_right=False)
+        s.plot(ax=ax, legend=True, secondary_y=True)
+        # both legends are dran on left ax
+        # left axis must be invisible and right axis must be visible
+        expected = ['a', 'b', 'c', 'x (right)']
+        self._check_legend_labels(ax.left_ax, expected)
+        self.assertFalse(ax.left_ax.get_yaxis().get_visible())
+        self.assertTrue(ax.get_yaxis().get_visible())
+        tm.close()
+
+    @slow
+    def test_plot_fails_with_dupe_color_and_style(self):
+        x = Series(randn(2))
+        with tm.assertRaises(ValueError):
+            x.plot(style='k--', color='k')
+
+    @slow
+    def test_hist_kde(self):
+        ax = self.ts.plot.hist(logy=True)
+        self._check_ax_scales(ax, yaxis='log')
+        xlabels = ax.get_xticklabels()
+        # ticks are values, thus ticklabels are blank
+        self._check_text_labels(xlabels, [''] * len(xlabels))
+        ylabels = ax.get_yticklabels()
+        self._check_text_labels(ylabels, [''] * len(ylabels))
+
+        tm._skip_if_no_scipy()
+        _skip_if_no_scipy_gaussian_kde()
+        _check_plot_works(self.ts.plot.kde)
+        _check_plot_works(self.ts.plot.density)
+        ax = self.ts.plot.kde(logy=True)
+        self._check_ax_scales(ax, yaxis='log')
+        xlabels = ax.get_xticklabels()
+        self._check_text_labels(xlabels, [''] * len(xlabels))
+        ylabels = ax.get_yticklabels()
+        self._check_text_labels(ylabels, [''] * len(ylabels))
+
+    @slow
+    def test_kde_kwargs(self):
+        tm._skip_if_no_scipy()
+        _skip_if_no_scipy_gaussian_kde()
+        from numpy import linspace
+        _check_plot_works(self.ts.plot.kde, bw_method=.5,
+                          ind=linspace(-100, 100, 20))
+        _check_plot_works(self.ts.plot.density, bw_method=.5,
+                          ind=linspace(-100, 100, 20))
+        ax = self.ts.plot.kde(logy=True, bw_method=.5,
+                              ind=linspace(-100, 100, 20))
+        self._check_ax_scales(ax, yaxis='log')
+        self._check_text_labels(ax.yaxis.get_label(), 'Density')
+
+    @slow
+    def test_kde_missing_vals(self):
+        tm._skip_if_no_scipy()
+        _skip_if_no_scipy_gaussian_kde()
+        s = Series(np.random.uniform(size=50))
+        s[0] = np.nan
+        _check_plot_works(s.plot.kde)
+
+    @slow
+    def test_hist_kwargs(self):
+        ax = self.ts.plot.hist(bins=5)
+        self.assertEqual(len(ax.patches), 5)
+        self._check_text_labels(ax.yaxis.get_label(), 'Frequency')
+        tm.close()
+
+        if self.mpl_ge_1_3_1:
+            ax = self.ts.plot.hist(orientation='horizontal')
+            self._check_text_labels(ax.xaxis.get_label(), 'Frequency')
+            tm.close()
+
+            ax = self.ts.plot.hist(align='left', stacked=True)
+            tm.close()
+
+    @slow
+    def test_hist_kde_color(self):
+        ax = self.ts.plot.hist(logy=True, bins=10, color='b')
+        self._check_ax_scales(ax, yaxis='log')
+        self.assertEqual(len(ax.patches), 10)
+        self._check_colors(ax.patches, facecolors=['b'] * 10)
+
+        tm._skip_if_no_scipy()
+        _skip_if_no_scipy_gaussian_kde()
+        ax = self.ts.plot.kde(logy=True, color='r')
+        self._check_ax_scales(ax, yaxis='log')
+        lines = ax.get_lines()
+        self.assertEqual(len(lines), 1)
+        self._check_colors(lines, ['r'])
+
+    @slow
+    def test_boxplot_series(self):
+        ax = self.ts.plot.box(logy=True)
+        self._check_ax_scales(ax, yaxis='log')
+        xlabels = ax.get_xticklabels()
+        self._check_text_labels(xlabels, [self.ts.name])
+        ylabels = ax.get_yticklabels()
+        self._check_text_labels(ylabels, [''] * len(ylabels))
+
+    @slow
+    def test_kind_both_ways(self):
+        s = Series(range(3))
+        for kind in plotting._common_kinds + plotting._series_kinds:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+            s.plot(kind=kind)
+            getattr(s.plot, kind)()
+
+    @slow
+    def test_invalid_plot_data(self):
+        s = Series(list('abcd'))
+        for kind in plotting._common_kinds:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+            with tm.assertRaises(TypeError):
+                s.plot(kind=kind)
+
+    @slow
+    def test_valid_object_plot(self):
+        s = Series(lrange(10), dtype=object)
+        for kind in plotting._common_kinds:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+            _check_plot_works(s.plot, kind=kind)
+
+    def test_partially_invalid_plot_data(self):
+        s = Series(['a', 'b', 1.0, 2])
+        for kind in plotting._common_kinds:
+            if not _ok_for_gaussian_kde(kind):
+                continue
+            with tm.assertRaises(TypeError):
+                s.plot(kind=kind)
+
+    def test_invalid_kind(self):
+        s = Series([1, 2])
+        with tm.assertRaises(ValueError):
+            s.plot(kind='aasdf')
+
+    @slow
+    def test_dup_datetime_index_plot(self):
+        dr1 = date_range('1/1/2009', periods=4)
+        dr2 = date_range('1/2/2009', periods=4)
+        index = dr1.append(dr2)
+        values = randn(index.size)
+        s = Series(values, index=index)
+        _check_plot_works(s.plot)
+
+    @slow
+    def test_errorbar_plot(self):
+
+        s = Series(np.arange(10), name='x')
+        s_err = np.random.randn(10)
+        d_err = DataFrame(randn(10, 2), index=s.index, columns=['x', 'y'])
+        # test line and bar plots
+        kinds = ['line', 'bar']
+        for kind in kinds:
+            ax = _check_plot_works(s.plot, yerr=Series(s_err), kind=kind)
+            self._check_has_errorbars(ax, xerr=0, yerr=1)
+            ax = _check_plot_works(s.plot, yerr=s_err, kind=kind)
+            self._check_has_errorbars(ax, xerr=0, yerr=1)
+            ax = _check_plot_works(s.plot, yerr=s_err.tolist(), kind=kind)
+            self._check_has_errorbars(ax, xerr=0, yerr=1)
+            ax = _check_plot_works(s.plot, yerr=d_err, kind=kind)
+            self._check_has_errorbars(ax, xerr=0, yerr=1)
+            ax = _check_plot_works(s.plot, xerr=0.2, yerr=0.2, kind=kind)
+            self._check_has_errorbars(ax, xerr=1, yerr=1)
+
+        ax = _check_plot_works(s.plot, xerr=s_err)
+        self._check_has_errorbars(ax, xerr=1, yerr=0)
+
+        # test time series plotting
+        ix = date_range('1/1/2000', '1/1/2001', freq='M')
+        ts = Series(np.arange(12), index=ix, name='x')
+        ts_err = Series(np.random.randn(12), index=ix)
+        td_err = DataFrame(randn(12, 2), index=ix, columns=['x', 'y'])
+
+        ax = _check_plot_works(ts.plot, yerr=ts_err)
+        self._check_has_errorbars(ax, xerr=0, yerr=1)
+        ax = _check_plot_works(ts.plot, yerr=td_err)
+        self._check_has_errorbars(ax, xerr=0, yerr=1)
+
+        # check incorrect lengths and types
+        with tm.assertRaises(ValueError):
+            s.plot(yerr=np.arange(11))
+
+        s_err = ['zzz'] * 10
+        # in mpl 1.5+ this is a TypeError
+        with tm.assertRaises((ValueError, TypeError)):
+            s.plot(yerr=s_err)
+
+    def test_table(self):
+        _check_plot_works(self.series.plot, table=True)
+        _check_plot_works(self.series.plot, table=self.series)
+
+    @slow
+    def test_series_grid_settings(self):
+        # Make sure plot defaults to rcParams['axes.grid'] setting, GH 9792
+        self._check_grid_settings(Series([1, 2, 3]),
+                                  plotting._series_kinds +
+                                  plotting._common_kinds)
+
+    @slow
+    def test_standard_colors(self):
+        for c in ['r', 'red', 'green', '#FF0000']:
+            result = plotting._get_standard_colors(1, color=c)
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(1, color=[c])
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(3, color=c)
+            self.assertEqual(result, [c] * 3)
+
+            result = plotting._get_standard_colors(3, color=[c])
+            self.assertEqual(result, [c] * 3)
+
+    @slow
+    def test_standard_colors_all(self):
+        import matplotlib.colors as colors
+
+        # multiple colors like mediumaquamarine
+        for c in colors.cnames:
+            result = plotting._get_standard_colors(num_colors=1, color=c)
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(num_colors=1, color=[c])
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(num_colors=3, color=c)
+            self.assertEqual(result, [c] * 3)
+
+            result = plotting._get_standard_colors(num_colors=3, color=[c])
+            self.assertEqual(result, [c] * 3)
+
+        # single letter colors like k
+        for c in colors.ColorConverter.colors:
+            result = plotting._get_standard_colors(num_colors=1, color=c)
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(num_colors=1, color=[c])
+            self.assertEqual(result, [c])
+
+            result = plotting._get_standard_colors(num_colors=3, color=c)
+            self.assertEqual(result, [c] * 3)
+
+            result = plotting._get_standard_colors(num_colors=3, color=[c])
+            self.assertEqual(result, [c] * 3)
+
+    def test_series_plot_color_kwargs(self):
+        # GH1890
+        ax = Series(np.arange(12) + 1).plot(color='green')
+        self._check_colors(ax.get_lines(), linecolors=['green'])
+
+    def test_time_series_plot_color_kwargs(self):
+        # #1890
+        ax = Series(np.arange(12) + 1, index=date_range(
+            '1/1/2000', periods=12)).plot(color='green')
+        self._check_colors(ax.get_lines(), linecolors=['green'])
+
+    def test_time_series_plot_color_with_empty_kwargs(self):
+        import matplotlib as mpl
+
+        if self.mpl_ge_1_5_0:
+            def_colors = self._maybe_unpack_cycler(mpl.rcParams)
+        else:
+            def_colors = mpl.rcParams['axes.color_cycle']
+        index = date_range('1/1/2000', periods=12)
+        s = Series(np.arange(1, 13), index=index)
+
+        ncolors = 3
+
+        for i in range(ncolors):
+            ax = s.plot()
+        self._check_colors(ax.get_lines(), linecolors=def_colors[:ncolors])
+
+    def test_xticklabels(self):
+        # GH11529
+        s = Series(np.arange(10), index=['P%02d' % i for i in range(10)])
+        ax = s.plot(xticks=[0, 3, 5, 9])
+        exp = ['P%02d' % i for i in [0, 3, 5, 9]]
+        self._check_text_labels(ax.get_xticklabels(), exp)
+
+    def test_custom_business_day_freq(self):
+        # GH7222
+        from pandas.tseries.offsets import CustomBusinessDay
+        s = Series(range(100, 121), index=pd.bdate_range(
+            start='2014-05-01', end='2014-06-01',
+            freq=CustomBusinessDay(holidays=['2014-05-26'])))
+
+        _check_plot_works(s.plot)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tests/test_graphics_others.py b/pandas/tests/test_graphics_others.py
deleted file mode 100644
index f9a210a49..000000000
--- a/pandas/tests/test_graphics_others.py
+++ /dev/null
@@ -1,1033 +0,0 @@
-#!/usr/bin/env python
-# coding: utf-8
-
-import nose
-import itertools
-import os
-import string
-from distutils.version import LooseVersion
-
-from pandas import Series, DataFrame, MultiIndex
-from pandas.compat import range, lmap, lzip
-import pandas.util.testing as tm
-from pandas.util.testing import slow
-
-import numpy as np
-from numpy import random
-from numpy.random import randn
-
-import pandas.tools.plotting as plotting
-
-from pandas.tests.test_graphics import (TestPlotBase, _check_plot_works,
-                                        curpath, _ok_for_gaussian_kde)
-
-
-"""
-These tests are for ``DataFrame.hist``, ``DataFrame.boxplot`` and
-other miscellaneous plots.
-`Dataframe.plot`` and ``Series.plot`` are tested in test_graphics.py
-"""
-
-
-def _skip_if_mpl_14_or_dev_boxplot():
-    # GH 8382
-    # Boxplot failures on 1.4 and 1.4.1
-    # Don't need try / except since that's done at class level
-    import matplotlib
-    if str(matplotlib.__version__) >= LooseVersion('1.4'):
-        raise nose.SkipTest("Matplotlib Regression in 1.4 and current dev.")
-
-
-@tm.mplskip
-class TestSeriesPlots(TestPlotBase):
-
-    def setUp(self):
-        TestPlotBase.setUp(self)
-        import matplotlib as mpl
-        mpl.rcdefaults()
-
-        self.ts = tm.makeTimeSeries()
-        self.ts.name = 'ts'
-
-        self.series = tm.makeStringSeries()
-        self.series.name = 'series'
-
-        self.iseries = tm.makePeriodSeries()
-        self.iseries.name = 'iseries'
-
-    @slow
-    def test_hist_legacy(self):
-        _check_plot_works(self.ts.hist)
-        _check_plot_works(self.ts.hist, grid=False)
-        _check_plot_works(self.ts.hist, figsize=(8, 10))
-        # _check_plot_works adds an ax so catch warning. see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(self.ts.hist, by=self.ts.index.month)
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(self.ts.hist, by=self.ts.index.month, bins=5)
-
-        fig, ax = self.plt.subplots(1, 1)
-        _check_plot_works(self.ts.hist, ax=ax)
-        _check_plot_works(self.ts.hist, ax=ax, figure=fig)
-        _check_plot_works(self.ts.hist, figure=fig)
-        tm.close()
-
-        fig, (ax1, ax2) = self.plt.subplots(1, 2)
-        _check_plot_works(self.ts.hist, figure=fig, ax=ax1)
-        _check_plot_works(self.ts.hist, figure=fig, ax=ax2)
-
-        with tm.assertRaises(ValueError):
-            self.ts.hist(by=self.ts.index, figure=fig)
-
-    @slow
-    def test_hist_bins_legacy(self):
-        df = DataFrame(np.random.randn(10, 2))
-        ax = df.hist(bins=2)[0][0]
-        self.assertEqual(len(ax.patches), 2)
-
-    @slow
-    def test_hist_layout(self):
-        df = self.hist_df
-        with tm.assertRaises(ValueError):
-            df.height.hist(layout=(1, 1))
-
-        with tm.assertRaises(ValueError):
-            df.height.hist(layout=[1, 1])
-
-    @slow
-    def test_hist_layout_with_by(self):
-        df = self.hist_df
-
-        # _check_plot_works adds an `ax` kwarg to the method call
-        # so we get a warning about an axis being cleared, even
-        # though we don't explicing pass one, see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist, by=df.gender,
-                                     layout=(2, 1))
-        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist, by=df.gender,
-                                     layout=(3, -1))
-        self._check_axes_shape(axes, axes_num=2, layout=(3, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.height.hist, by=df.category,
-                                     layout=(4, 1))
-        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(
-                df.height.hist, by=df.category, layout=(2, -1))
-        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(
-                df.height.hist, by=df.category, layout=(3, -1))
-        self._check_axes_shape(axes, axes_num=4, layout=(3, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(
-                df.height.hist, by=df.category, layout=(-1, 4))
-        self._check_axes_shape(axes, axes_num=4, layout=(1, 4))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(
-                df.height.hist, by=df.classroom, layout=(2, 2))
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-
-        axes = df.height.hist(by=df.category, layout=(4, 2), figsize=(12, 7))
-        self._check_axes_shape(
-            axes, axes_num=4, layout=(4, 2), figsize=(12, 7))
-
-    @slow
-    def test_hist_no_overlap(self):
-        from matplotlib.pyplot import subplot, gcf
-        x = Series(randn(2))
-        y = Series(randn(2))
-        subplot(121)
-        x.hist()
-        subplot(122)
-        y.hist()
-        fig = gcf()
-        axes = fig.axes if self.mpl_ge_1_5_0 else fig.get_axes()
-        self.assertEqual(len(axes), 2)
-
-    @slow
-    def test_hist_by_no_extra_plots(self):
-        df = self.hist_df
-        axes = df.height.hist(by=df.gender)  # noqa
-        self.assertEqual(len(self.plt.get_fignums()), 1)
-
-    @slow
-    def test_plot_fails_when_ax_differs_from_figure(self):
-        from pylab import figure
-        fig1 = figure()
-        fig2 = figure()
-        ax1 = fig1.add_subplot(111)
-        with tm.assertRaises(AssertionError):
-            self.ts.hist(ax=ax1, figure=fig2)
-
-    @slow
-    def test_autocorrelation_plot(self):
-        from pandas.tools.plotting import autocorrelation_plot
-        _check_plot_works(autocorrelation_plot, series=self.ts)
-        _check_plot_works(autocorrelation_plot, series=self.ts.values)
-
-        ax = autocorrelation_plot(self.ts, label='Test')
-        self._check_legend_labels(ax, labels=['Test'])
-
-    @slow
-    def test_lag_plot(self):
-        from pandas.tools.plotting import lag_plot
-        _check_plot_works(lag_plot, series=self.ts)
-        _check_plot_works(lag_plot, series=self.ts, lag=5)
-
-    @slow
-    def test_bootstrap_plot(self):
-        from pandas.tools.plotting import bootstrap_plot
-        _check_plot_works(bootstrap_plot, series=self.ts, size=10)
-
-
-@tm.mplskip
-class TestDataFramePlots(TestPlotBase):
-
-    def setUp(self):
-        TestPlotBase.setUp(self)
-        import matplotlib as mpl
-        mpl.rcdefaults()
-
-        self.tdf = tm.makeTimeDataFrame()
-        self.hexbin_df = DataFrame({
-            "A": np.random.uniform(size=20),
-            "B": np.random.uniform(size=20),
-            "C": np.arange(20) + np.random.uniform(size=20)})
-
-        from pandas import read_csv
-        path = os.path.join(curpath(), 'data', 'iris.csv')
-        self.iris = read_csv(path)
-
-    @slow
-    def test_boxplot_legacy(self):
-        df = DataFrame(randn(6, 4),
-                       index=list(string.ascii_letters[:6]),
-                       columns=['one', 'two', 'three', 'four'])
-        df['indic'] = ['foo', 'bar'] * 3
-        df['indic2'] = ['foo', 'bar', 'foo'] * 2
-
-        _check_plot_works(df.boxplot, return_type='dict')
-        _check_plot_works(df.boxplot, column=[
-                          'one', 'two'], return_type='dict')
-        # _check_plot_works adds an ax so catch warning. see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.boxplot, column=['one', 'two'],
-                              by='indic')
-        _check_plot_works(df.boxplot, column='one', by=['indic', 'indic2'])
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.boxplot, by='indic')
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.boxplot, by=['indic', 'indic2'])
-        _check_plot_works(plotting.boxplot, data=df['one'], return_type='dict')
-        _check_plot_works(df.boxplot, notch=1, return_type='dict')
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.boxplot, by='indic', notch=1)
-
-        df = DataFrame(np.random.rand(10, 2), columns=['Col1', 'Col2'])
-        df['X'] = Series(['A', 'A', 'A', 'A', 'A', 'B', 'B', 'B', 'B', 'B'])
-        df['Y'] = Series(['A'] * 10)
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.boxplot, by='X')
-
-        # When ax is supplied and required number of axes is 1,
-        # passed ax should be used:
-        fig, ax = self.plt.subplots()
-        axes = df.boxplot('Col1', by='X', ax=ax)
-        ax_axes = ax.axes if self.mpl_ge_1_5_0 else ax.get_axes()
-        self.assertIs(ax_axes, axes)
-
-        fig, ax = self.plt.subplots()
-        axes = df.groupby('Y').boxplot(ax=ax, return_type='axes')
-        ax_axes = ax.axes if self.mpl_ge_1_5_0 else ax.get_axes()
-        self.assertIs(ax_axes, axes['A'])
-
-        # Multiple columns with an ax argument should use same figure
-        fig, ax = self.plt.subplots()
-        with tm.assert_produces_warning(UserWarning):
-            axes = df.boxplot(column=['Col1', 'Col2'],
-                              by='X', ax=ax, return_type='axes')
-        self.assertIs(axes['Col1'].get_figure(), fig)
-
-        # When by is None, check that all relevant lines are present in the
-        # dict
-        fig, ax = self.plt.subplots()
-        d = df.boxplot(ax=ax, return_type='dict')
-        lines = list(itertools.chain.from_iterable(d.values()))
-        self.assertEqual(len(ax.get_lines()), len(lines))
-
-    @slow
-    def test_boxplot_return_type_legacy(self):
-        # API change in https://github.com/pydata/pandas/pull/7096
-        import matplotlib as mpl  # noqa
-
-        df = DataFrame(randn(6, 4),
-                       index=list(string.ascii_letters[:6]),
-                       columns=['one', 'two', 'three', 'four'])
-        with tm.assertRaises(ValueError):
-            df.boxplot(return_type='NOTATYPE')
-
-        with tm.assert_produces_warning(FutureWarning):
-            result = df.boxplot()
-        # change to Axes in future
-        self._check_box_return_type(result, 'dict')
-
-        with tm.assert_produces_warning(False):
-            result = df.boxplot(return_type='dict')
-        self._check_box_return_type(result, 'dict')
-
-        with tm.assert_produces_warning(False):
-            result = df.boxplot(return_type='axes')
-        self._check_box_return_type(result, 'axes')
-
-        with tm.assert_produces_warning(False):
-            result = df.boxplot(return_type='both')
-        self._check_box_return_type(result, 'both')
-
-    @slow
-    def test_boxplot_axis_limits(self):
-
-        def _check_ax_limits(col, ax):
-            y_min, y_max = ax.get_ylim()
-            self.assertTrue(y_min <= col.min())
-            self.assertTrue(y_max >= col.max())
-
-        df = self.hist_df.copy()
-        df['age'] = np.random.randint(1, 20, df.shape[0])
-        # One full row
-        height_ax, weight_ax = df.boxplot(['height', 'weight'], by='category')
-        _check_ax_limits(df['height'], height_ax)
-        _check_ax_limits(df['weight'], weight_ax)
-        self.assertEqual(weight_ax._sharey, height_ax)
-
-        # Two rows, one partial
-        p = df.boxplot(['height', 'weight', 'age'], by='category')
-        height_ax, weight_ax, age_ax = p[0, 0], p[0, 1], p[1, 0]
-        dummy_ax = p[1, 1]
-        _check_ax_limits(df['height'], height_ax)
-        _check_ax_limits(df['weight'], weight_ax)
-        _check_ax_limits(df['age'], age_ax)
-        self.assertEqual(weight_ax._sharey, height_ax)
-        self.assertEqual(age_ax._sharey, height_ax)
-        self.assertIsNone(dummy_ax._sharey)
-
-    @slow
-    def test_boxplot_empty_column(self):
-        _skip_if_mpl_14_or_dev_boxplot()
-        df = DataFrame(np.random.randn(20, 4))
-        df.loc[:, 0] = np.nan
-        _check_plot_works(df.boxplot, return_type='axes')
-
-    @slow
-    def test_hist_df_legacy(self):
-        from matplotlib.patches import Rectangle
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(self.hist_df.hist)
-
-        # make sure layout is handled
-        df = DataFrame(randn(100, 3))
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.hist, grid=False)
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-        self.assertFalse(axes[1, 1].get_visible())
-
-        df = DataFrame(randn(100, 1))
-        _check_plot_works(df.hist)
-
-        # make sure layout is handled
-        df = DataFrame(randn(100, 6))
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.hist, layout=(4, 2))
-        self._check_axes_shape(axes, axes_num=6, layout=(4, 2))
-
-        # make sure sharex, sharey is handled
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.hist, sharex=True, sharey=True)
-
-        # handle figsize arg
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.hist, figsize=(8, 10))
-
-        # check bins argument
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(df.hist, bins=5)
-
-        # make sure xlabelsize and xrot are handled
-        ser = df[0]
-        xf, yf = 20, 18
-        xrot, yrot = 30, 40
-        axes = ser.hist(xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
-        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
-                                ylabelsize=yf, yrot=yrot)
-
-        xf, yf = 20, 18
-        xrot, yrot = 30, 40
-        axes = df.hist(xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
-        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
-                                ylabelsize=yf, yrot=yrot)
-
-        tm.close()
-        # make sure kwargs to hist are handled
-        ax = ser.hist(normed=True, cumulative=True, bins=4)
-        # height of last bin (index 5) must be 1.0
-        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
-        self.assertAlmostEqual(rects[-1].get_height(), 1.0)
-
-        tm.close()
-        ax = ser.hist(log=True)
-        # scale of y must be 'log'
-        self._check_ax_scales(ax, yaxis='log')
-
-        tm.close()
-
-        # propagate attr exception from matplotlib.Axes.hist
-        with tm.assertRaises(AttributeError):
-            ser.hist(foo='bar')
-
-    @slow
-    def test_hist_layout(self):
-        df = DataFrame(randn(100, 3))
-
-        layout_to_expected_size = (
-            {'layout': None, 'expected_size': (2, 2)},  # default is 2x2
-            {'layout': (2, 2), 'expected_size': (2, 2)},
-            {'layout': (4, 1), 'expected_size': (4, 1)},
-            {'layout': (1, 4), 'expected_size': (1, 4)},
-            {'layout': (3, 3), 'expected_size': (3, 3)},
-            {'layout': (-1, 4), 'expected_size': (1, 4)},
-            {'layout': (4, -1), 'expected_size': (4, 1)},
-            {'layout': (-1, 2), 'expected_size': (2, 2)},
-            {'layout': (2, -1), 'expected_size': (2, 2)}
-        )
-
-        for layout_test in layout_to_expected_size:
-            axes = df.hist(layout=layout_test['layout'])
-            expected = layout_test['expected_size']
-            self._check_axes_shape(axes, axes_num=3, layout=expected)
-
-        # layout too small for all 4 plots
-        with tm.assertRaises(ValueError):
-            df.hist(layout=(1, 1))
-
-        # invalid format for layout
-        with tm.assertRaises(ValueError):
-            df.hist(layout=(1,))
-        with tm.assertRaises(ValueError):
-            df.hist(layout=(-1, -1))
-
-    @slow
-    def test_scatter_plot_legacy(self):
-        tm._skip_if_no_scipy()
-
-        df = DataFrame(randn(100, 2))
-
-        def scat(**kwds):
-            return plotting.scatter_matrix(df, **kwds)
-
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat)
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat, marker='+')
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat, vmin=0)
-        if _ok_for_gaussian_kde('kde'):
-            with tm.assert_produces_warning(UserWarning):
-                _check_plot_works(scat, diagonal='kde')
-        if _ok_for_gaussian_kde('density'):
-            with tm.assert_produces_warning(UserWarning):
-                _check_plot_works(scat, diagonal='density')
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat, diagonal='hist')
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat, range_padding=.1)
-
-        def scat2(x, y, by=None, ax=None, figsize=None):
-            return plotting.scatter_plot(df, x, y, by, ax, figsize=None)
-
-        _check_plot_works(scat2, x=0, y=1)
-        grouper = Series(np.repeat([1, 2, 3, 4, 5], 20), df.index)
-        with tm.assert_produces_warning(UserWarning):
-            _check_plot_works(scat2, x=0, y=1, by=grouper)
-
-    def test_scatter_matrix_axis(self):
-        tm._skip_if_no_scipy()
-        scatter_matrix = plotting.scatter_matrix
-
-        with tm.RNGContext(42):
-            df = DataFrame(randn(100, 3))
-
-        # we are plotting multiples on a sub-plot
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(scatter_matrix, filterwarnings='always',
-                                     frame=df, range_padding=.1)
-        axes0_labels = axes[0][0].yaxis.get_majorticklabels()
-
-        # GH 5662
-        expected = ['-2', '-1', '0', '1', '2']
-        self._check_text_labels(axes0_labels, expected)
-        self._check_ticks_props(
-            axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
-
-        df[0] = ((df[0] - 2) / 3)
-
-        # we are plotting multiples on a sub-plot
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(scatter_matrix, filterwarnings='always',
-                                     frame=df, range_padding=.1)
-        axes0_labels = axes[0][0].yaxis.get_majorticklabels()
-        expected = ['-1.2', '-1.0', '-0.8', '-0.6', '-0.4', '-0.2', '0.0']
-        self._check_text_labels(axes0_labels, expected)
-        self._check_ticks_props(
-            axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
-
-    @slow
-    def test_andrews_curves(self):
-        from pandas.tools.plotting import andrews_curves
-        from matplotlib import cm
-
-        df = self.iris
-
-        _check_plot_works(andrews_curves, frame=df, class_column='Name')
-
-        rgba = ('#556270', '#4ECDC4', '#C7F464')
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', color=rgba)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
-
-        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', color=cnames)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
-
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', colormap=cm.jet)
-        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
-
-        length = 10
-        df = DataFrame({"A": random.rand(length),
-                        "B": random.rand(length),
-                        "C": random.rand(length),
-                        "Name": ["A"] * length})
-
-        _check_plot_works(andrews_curves, frame=df, class_column='Name')
-
-        rgba = ('#556270', '#4ECDC4', '#C7F464')
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', color=rgba)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
-
-        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', color=cnames)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
-
-        ax = _check_plot_works(andrews_curves, frame=df,
-                               class_column='Name', colormap=cm.jet)
-        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
-
-        colors = ['b', 'g', 'r']
-        df = DataFrame({"A": [1, 2, 3],
-                        "B": [1, 2, 3],
-                        "C": [1, 2, 3],
-                        "Name": colors})
-        ax = andrews_curves(df, 'Name', color=colors)
-        handles, labels = ax.get_legend_handles_labels()
-        self._check_colors(handles, linecolors=colors)
-
-        with tm.assert_produces_warning(FutureWarning):
-            andrews_curves(data=df, class_column='Name')
-
-    @slow
-    def test_parallel_coordinates(self):
-        from pandas.tools.plotting import parallel_coordinates
-        from matplotlib import cm
-
-        df = self.iris
-
-        ax = _check_plot_works(parallel_coordinates,
-                               frame=df, class_column='Name')
-        nlines = len(ax.get_lines())
-        nxticks = len(ax.xaxis.get_ticklabels())
-
-        rgba = ('#556270', '#4ECDC4', '#C7F464')
-        ax = _check_plot_works(parallel_coordinates,
-                               frame=df, class_column='Name', color=rgba)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=rgba, mapping=df['Name'][:10])
-
-        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
-        ax = _check_plot_works(parallel_coordinates,
-                               frame=df, class_column='Name', color=cnames)
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cnames, mapping=df['Name'][:10])
-
-        ax = _check_plot_works(parallel_coordinates,
-                               frame=df, class_column='Name', colormap=cm.jet)
-        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
-        self._check_colors(
-            ax.get_lines()[:10], linecolors=cmaps, mapping=df['Name'][:10])
-
-        ax = _check_plot_works(parallel_coordinates,
-                               frame=df, class_column='Name', axvlines=False)
-        assert len(ax.get_lines()) == (nlines - nxticks)
-
-        colors = ['b', 'g', 'r']
-        df = DataFrame({"A": [1, 2, 3],
-                        "B": [1, 2, 3],
-                        "C": [1, 2, 3],
-                        "Name": colors})
-        ax = parallel_coordinates(df, 'Name', color=colors)
-        handles, labels = ax.get_legend_handles_labels()
-        self._check_colors(handles, linecolors=colors)
-
-        with tm.assert_produces_warning(FutureWarning):
-            parallel_coordinates(data=df, class_column='Name')
-        with tm.assert_produces_warning(FutureWarning):
-            parallel_coordinates(df, 'Name', colors=colors)
-
-    @slow
-    def test_radviz(self):
-        from pandas.tools.plotting import radviz
-        from matplotlib import cm
-
-        df = self.iris
-        _check_plot_works(radviz, frame=df, class_column='Name')
-
-        rgba = ('#556270', '#4ECDC4', '#C7F464')
-        ax = _check_plot_works(
-            radviz, frame=df, class_column='Name', color=rgba)
-        # skip Circle drawn as ticks
-        patches = [p for p in ax.patches[:20] if p.get_label() != '']
-        self._check_colors(
-            patches[:10], facecolors=rgba, mapping=df['Name'][:10])
-
-        cnames = ['dodgerblue', 'aquamarine', 'seagreen']
-        _check_plot_works(radviz, frame=df, class_column='Name', color=cnames)
-        patches = [p for p in ax.patches[:20] if p.get_label() != '']
-        self._check_colors(patches, facecolors=cnames, mapping=df['Name'][:10])
-
-        _check_plot_works(radviz, frame=df,
-                          class_column='Name', colormap=cm.jet)
-        cmaps = lmap(cm.jet, np.linspace(0, 1, df['Name'].nunique()))
-        patches = [p for p in ax.patches[:20] if p.get_label() != '']
-        self._check_colors(patches, facecolors=cmaps, mapping=df['Name'][:10])
-
-        colors = [[0., 0., 1., 1.],
-                  [0., 0.5, 1., 1.],
-                  [1., 0., 0., 1.]]
-        df = DataFrame({"A": [1, 2, 3],
-                        "B": [2, 1, 3],
-                        "C": [3, 2, 1],
-                        "Name": ['b', 'g', 'r']})
-        ax = radviz(df, 'Name', color=colors)
-        handles, labels = ax.get_legend_handles_labels()
-        self._check_colors(handles, facecolors=colors)
-
-
-@tm.mplskip
-class TestDataFrameGroupByPlots(TestPlotBase):
-
-    @slow
-    def test_boxplot_legacy(self):
-        grouped = self.hist_df.groupby(by='gender')
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(grouped.boxplot, return_type='axes')
-        self._check_axes_shape(list(axes.values()), axes_num=2, layout=(1, 2))
-
-        axes = _check_plot_works(grouped.boxplot, subplots=False,
-                                 return_type='axes')
-        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
-        tuples = lzip(string.ascii_letters[:10], range(10))
-        df = DataFrame(np.random.rand(10, 3),
-                       index=MultiIndex.from_tuples(tuples))
-
-        grouped = df.groupby(level=1)
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(grouped.boxplot, return_type='axes')
-        self._check_axes_shape(list(axes.values()), axes_num=10, layout=(4, 3))
-
-        axes = _check_plot_works(grouped.boxplot, subplots=False,
-                                 return_type='axes')
-        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
-
-        grouped = df.unstack(level=1).groupby(level=0, axis=1)
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(grouped.boxplot, return_type='axes')
-        self._check_axes_shape(list(axes.values()), axes_num=3, layout=(2, 2))
-
-        axes = _check_plot_works(grouped.boxplot, subplots=False,
-                                 return_type='axes')
-        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
-
-    @slow
-    def test_grouped_plot_fignums(self):
-        n = 10
-        weight = Series(np.random.normal(166, 20, size=n))
-        height = Series(np.random.normal(60, 10, size=n))
-        with tm.RNGContext(42):
-            gender = np.random.choice(['male', 'female'], size=n)
-        df = DataFrame({'height': height, 'weight': weight, 'gender': gender})
-        gb = df.groupby('gender')
-
-        res = gb.plot()
-        self.assertEqual(len(self.plt.get_fignums()), 2)
-        self.assertEqual(len(res), 2)
-        tm.close()
-
-        res = gb.boxplot(return_type='axes')
-        self.assertEqual(len(self.plt.get_fignums()), 1)
-        self.assertEqual(len(res), 2)
-        tm.close()
-
-        # now works with GH 5610 as gender is excluded
-        res = df.groupby('gender').hist()
-        tm.close()
-
-    @slow
-    def test_grouped_hist_legacy(self):
-        from matplotlib.patches import Rectangle
-
-        df = DataFrame(randn(500, 2), columns=['A', 'B'])
-        df['C'] = np.random.randint(0, 4, 500)
-        df['D'] = ['X'] * 500
-
-        axes = plotting.grouped_hist(df.A, by=df.C)
-        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
-
-        tm.close()
-        axes = df.hist(by=df.C)
-        self._check_axes_shape(axes, axes_num=4, layout=(2, 2))
-
-        tm.close()
-        # group by a key with single value
-        axes = df.hist(by='D', rot=30)
-        self._check_axes_shape(axes, axes_num=1, layout=(1, 1))
-        self._check_ticks_props(axes, xrot=30)
-
-        tm.close()
-        # make sure kwargs to hist are handled
-        xf, yf = 20, 18
-        xrot, yrot = 30, 40
-        axes = plotting.grouped_hist(df.A, by=df.C, normed=True,
-                                     cumulative=True, bins=4,
-                                     xlabelsize=xf, xrot=xrot,
-                                     ylabelsize=yf, yrot=yrot)
-        # height of last bin (index 5) must be 1.0
-        for ax in axes.ravel():
-            rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
-            height = rects[-1].get_height()
-            self.assertAlmostEqual(height, 1.0)
-        self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
-                                ylabelsize=yf, yrot=yrot)
-
-        tm.close()
-        axes = plotting.grouped_hist(df.A, by=df.C, log=True)
-        # scale of y must be 'log'
-        self._check_ax_scales(axes, yaxis='log')
-
-        tm.close()
-        # propagate attr exception from matplotlib.Axes.hist
-        with tm.assertRaises(AttributeError):
-            plotting.grouped_hist(df.A, by=df.C, foo='bar')
-
-        with tm.assert_produces_warning(FutureWarning):
-            df.hist(by='C', figsize='default')
-
-    @slow
-    def test_grouped_hist_legacy2(self):
-        n = 10
-        weight = Series(np.random.normal(166, 20, size=n))
-        height = Series(np.random.normal(60, 10, size=n))
-        with tm.RNGContext(42):
-            gender_int = np.random.choice([0, 1], size=n)
-        df_int = DataFrame({'height': height, 'weight': weight,
-                            'gender': gender_int})
-        gb = df_int.groupby('gender')
-        axes = gb.hist()
-        self.assertEqual(len(axes), 2)
-        self.assertEqual(len(self.plt.get_fignums()), 2)
-        tm.close()
-
-    @slow
-    def test_grouped_box_return_type(self):
-        df = self.hist_df
-
-        # old style: return_type=None
-        result = df.boxplot(by='gender')
-        self.assertIsInstance(result, np.ndarray)
-        self._check_box_return_type(
-            result, None,
-            expected_keys=['height', 'weight', 'category'])
-
-        # now for groupby
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = df.groupby('gender').boxplot()
-        self._check_box_return_type(
-            result, 'dict', expected_keys=['Male', 'Female'])
-
-        columns2 = 'X B C D A G Y N Q O'.split()
-        df2 = DataFrame(random.randn(50, 10), columns=columns2)
-        categories2 = 'A B C D E F G H I J'.split()
-        df2['category'] = categories2 * 5
-
-        for t in ['dict', 'axes', 'both']:
-            returned = df.groupby('classroom').boxplot(return_type=t)
-            self._check_box_return_type(
-                returned, t, expected_keys=['A', 'B', 'C'])
-
-            returned = df.boxplot(by='classroom', return_type=t)
-            self._check_box_return_type(
-                returned, t,
-                expected_keys=['height', 'weight', 'category'])
-
-            returned = df2.groupby('category').boxplot(return_type=t)
-            self._check_box_return_type(returned, t, expected_keys=categories2)
-
-            returned = df2.boxplot(by='category', return_type=t)
-            self._check_box_return_type(returned, t, expected_keys=columns2)
-
-    @slow
-    def test_grouped_box_layout(self):
-        df = self.hist_df
-
-        self.assertRaises(ValueError, df.boxplot, column=['weight', 'height'],
-                          by=df.gender, layout=(1, 1))
-        self.assertRaises(ValueError, df.boxplot,
-                          column=['height', 'weight', 'category'],
-                          layout=(2, 1), return_type='dict')
-        self.assertRaises(ValueError, df.boxplot, column=['weight', 'height'],
-                          by=df.gender, layout=(-1, -1))
-
-        # _check_plot_works adds an ax so catch warning. see GH #13188
-        with tm.assert_produces_warning(UserWarning):
-            box = _check_plot_works(df.groupby('gender').boxplot,
-                                    column='height', return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=2, layout=(1, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            box = _check_plot_works(df.groupby('category').boxplot,
-                                    column='height',
-                                    return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(2, 2))
-
-        # GH 6769
-        with tm.assert_produces_warning(UserWarning):
-            box = _check_plot_works(df.groupby('classroom').boxplot,
-                                    column='height', return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
-
-        # GH 5897
-        axes = df.boxplot(column=['height', 'weight', 'category'], by='gender',
-                          return_type='axes')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
-        for ax in [axes['height']]:
-            self._check_visible(ax.get_xticklabels(), visible=False)
-            self._check_visible([ax.xaxis.get_label()], visible=False)
-        for ax in [axes['weight'], axes['category']]:
-            self._check_visible(ax.get_xticklabels())
-            self._check_visible([ax.xaxis.get_label()])
-
-        box = df.groupby('classroom').boxplot(
-            column=['height', 'weight', 'category'], return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(2, 2))
-
-        with tm.assert_produces_warning(UserWarning):
-            box = _check_plot_works(df.groupby('category').boxplot,
-                                    column='height',
-                                    layout=(3, 2), return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(3, 2))
-        with tm.assert_produces_warning(UserWarning):
-            box = _check_plot_works(df.groupby('category').boxplot,
-                                    column='height',
-                                    layout=(3, -1), return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=4, layout=(3, 2))
-
-        box = df.boxplot(column=['height', 'weight', 'category'], by='gender',
-                         layout=(4, 1))
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(4, 1))
-
-        box = df.boxplot(column=['height', 'weight', 'category'], by='gender',
-                         layout=(-1, 1))
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(3, 1))
-
-        box = df.groupby('classroom').boxplot(
-            column=['height', 'weight', 'category'], layout=(1, 4),
-            return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(1, 4))
-
-        box = df.groupby('classroom').boxplot(  # noqa
-            column=['height', 'weight', 'category'], layout=(1, -1),
-            return_type='dict')
-        self._check_axes_shape(self.plt.gcf().axes, axes_num=3, layout=(1, 3))
-
-    @slow
-    def test_grouped_box_multiple_axes(self):
-        # GH 6970, GH 7069
-        df = self.hist_df
-
-        # check warning to ignore sharex / sharey
-        # this check should be done in the first function which
-        # passes multiple axes to plot, hist or boxplot
-        # location should be changed if other test is added
-        # which has earlier alphabetical order
-        with tm.assert_produces_warning(UserWarning):
-            fig, axes = self.plt.subplots(2, 2)
-            df.groupby('category').boxplot(
-                column='height', return_type='axes', ax=axes)
-            self._check_axes_shape(self.plt.gcf().axes,
-                                   axes_num=4, layout=(2, 2))
-
-        fig, axes = self.plt.subplots(2, 3)
-        with tm.assert_produces_warning(UserWarning):
-            returned = df.boxplot(column=['height', 'weight', 'category'],
-                                  by='gender', return_type='axes', ax=axes[0])
-        returned = np.array(list(returned.values()))
-        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
-        self.assert_numpy_array_equal(returned, axes[0])
-        self.assertIs(returned[0].figure, fig)
-
-        # draw on second row
-        with tm.assert_produces_warning(UserWarning):
-            returned = df.groupby('classroom').boxplot(
-                column=['height', 'weight', 'category'],
-                return_type='axes', ax=axes[1])
-        returned = np.array(list(returned.values()))
-        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
-        self.assert_numpy_array_equal(returned, axes[1])
-        self.assertIs(returned[0].figure, fig)
-
-        with tm.assertRaises(ValueError):
-            fig, axes = self.plt.subplots(2, 3)
-            # pass different number of axes from required
-            with tm.assert_produces_warning(UserWarning):
-                axes = df.groupby('classroom').boxplot(ax=axes)
-
-    @slow
-    def test_grouped_hist_layout(self):
-        df = self.hist_df
-        self.assertRaises(ValueError, df.hist, column='weight', by=df.gender,
-                          layout=(1, 1))
-        self.assertRaises(ValueError, df.hist, column='height', by=df.category,
-                          layout=(1, 3))
-        self.assertRaises(ValueError, df.hist, column='height', by=df.category,
-                          layout=(-1, -1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.hist, column='height', by=df.gender,
-                                     layout=(2, 1))
-        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
-
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.hist, column='height', by=df.gender,
-                                     layout=(2, -1))
-        self._check_axes_shape(axes, axes_num=2, layout=(2, 1))
-
-        axes = df.hist(column='height', by=df.category, layout=(4, 1))
-        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
-
-        axes = df.hist(column='height', by=df.category, layout=(-1, 1))
-        self._check_axes_shape(axes, axes_num=4, layout=(4, 1))
-
-        axes = df.hist(column='height', by=df.category,
-                       layout=(4, 2), figsize=(12, 8))
-        self._check_axes_shape(
-            axes, axes_num=4, layout=(4, 2), figsize=(12, 8))
-        tm.close()
-
-        # GH 6769
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(
-                df.hist, column='height', by='classroom', layout=(2, 2))
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-
-        # without column
-        with tm.assert_produces_warning(UserWarning):
-            axes = _check_plot_works(df.hist, by='classroom')
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-
-        axes = df.hist(by='gender', layout=(3, 5))
-        self._check_axes_shape(axes, axes_num=2, layout=(3, 5))
-
-        axes = df.hist(column=['height', 'weight', 'category'])
-        self._check_axes_shape(axes, axes_num=3, layout=(2, 2))
-
-    @slow
-    def test_grouped_hist_multiple_axes(self):
-        # GH 6970, GH 7069
-        df = self.hist_df
-
-        fig, axes = self.plt.subplots(2, 3)
-        returned = df.hist(column=['height', 'weight', 'category'], ax=axes[0])
-        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
-        self.assert_numpy_array_equal(returned, axes[0])
-        self.assertIs(returned[0].figure, fig)
-        returned = df.hist(by='classroom', ax=axes[1])
-        self._check_axes_shape(returned, axes_num=3, layout=(1, 3))
-        self.assert_numpy_array_equal(returned, axes[1])
-        self.assertIs(returned[0].figure, fig)
-
-        with tm.assertRaises(ValueError):
-            fig, axes = self.plt.subplots(2, 3)
-            # pass different number of axes from required
-            axes = df.hist(column='height', ax=axes)
-
-    @slow
-    def test_axis_share_x(self):
-        df = self.hist_df
-        # GH4089
-        ax1, ax2 = df.hist(column='height', by=df.gender, sharex=True)
-
-        # share x
-        self.assertTrue(ax1._shared_x_axes.joined(ax1, ax2))
-        self.assertTrue(ax2._shared_x_axes.joined(ax1, ax2))
-
-        # don't share y
-        self.assertFalse(ax1._shared_y_axes.joined(ax1, ax2))
-        self.assertFalse(ax2._shared_y_axes.joined(ax1, ax2))
-
-    @slow
-    def test_axis_share_y(self):
-        df = self.hist_df
-        ax1, ax2 = df.hist(column='height', by=df.gender, sharey=True)
-
-        # share y
-        self.assertTrue(ax1._shared_y_axes.joined(ax1, ax2))
-        self.assertTrue(ax2._shared_y_axes.joined(ax1, ax2))
-
-        # don't share x
-        self.assertFalse(ax1._shared_x_axes.joined(ax1, ax2))
-        self.assertFalse(ax2._shared_x_axes.joined(ax1, ax2))
-
-    @slow
-    def test_axis_share_xy(self):
-        df = self.hist_df
-        ax1, ax2 = df.hist(column='height', by=df.gender, sharex=True,
-                           sharey=True)
-
-        # share both x and y
-        self.assertTrue(ax1._shared_x_axes.joined(ax1, ax2))
-        self.assertTrue(ax2._shared_x_axes.joined(ax1, ax2))
-
-        self.assertTrue(ax1._shared_y_axes.joined(ax1, ax2))
-        self.assertTrue(ax2._shared_y_axes.joined(ax1, ax2))
-
-
-if __name__ == '__main__':
-    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
-                   exit=False)
diff --git a/setup.py b/setup.py
index 58965fe9a..937b3509c 100755
--- a/setup.py
+++ b/setup.py
@@ -571,6 +571,7 @@ setup(name=DISTNAME,
                 'pandas.tests.formats',
                 'pandas.tests.types',
                 'pandas.tests.test_msgpack',
+                'pandas.tests.plotting',
                 'pandas.tools',
                 'pandas.tools.tests',
                 'pandas.tseries',

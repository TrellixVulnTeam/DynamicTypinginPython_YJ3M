commit 96033e0c9cc684033feeda4e455837e642c86336
Author: unutbu <unutbu@gmail.com>
Date:   Tue Oct 1 21:38:12 2013 -0400

    EHN: Allow load_data to load the "Titanic" and other problematic R datasets
    TST: Move tests from rpy/common.py to rpy/tests/test_common.py
    TST: Add tests to demonstrate the enhancements made to rpy/common.py.
    DOC: Add explanation to doc/source/release.rst and doc/source/v0.13.0.txt

diff --git a/doc/source/r_interface.rst b/doc/source/r_interface.rst
index 79a87cb49..4f5c5a03a 100644
--- a/doc/source/r_interface.rst
+++ b/doc/source/r_interface.rst
@@ -20,7 +20,7 @@ its release 2.3, while the current interface is
 designed for the 2.2.x series. We recommend to use 2.2.x over other series 
 unless you are prepared to fix parts of the code, yet the rpy2-2.3.0
 introduces improvements such as a better R-Python bridge memory management
-layer so I might be a good idea to bite the bullet and submit patches for
+layer so it might be a good idea to bite the bullet and submit patches for
 the few minor differences that need to be fixed.
 
 
diff --git a/doc/source/release.rst b/doc/source/release.rst
index 058ea1651..0894c8480 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -160,6 +160,10 @@ Improvements to existing features
     :issue:`4998`)
   - ``to_dict`` now takes ``records`` as a possible outtype.  Returns an array
     of column-keyed dictionaries. (:issue:`4936`)
+  - Improve support for converting R datasets to pandas objects (more
+    informative index for timeseries and numeric, support for factors, dist, and
+    high-dimensional arrays).
+
 
 API Changes
 ~~~~~~~~~~~
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 90d2989de..3f6919e3b 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -480,6 +480,12 @@ Enhancements
          dfi[mask.any(1)]
 
       :ref:`See the docs<indexing.basics.indexing_isin>` for more.
+  - All R datasets listed here http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html can now be loaded into Pandas objects
+
+    .. code-block:: python
+
+       import pandas.rpy.common as com
+       com.load_data('Titanic')
 
 .. _whatsnew_0130.experimental:
 
diff --git a/pandas/rpy/common.py b/pandas/rpy/common.py
index a640b43ab..5747285de 100644
--- a/pandas/rpy/common.py
+++ b/pandas/rpy/common.py
@@ -15,6 +15,9 @@ from rpy2.robjects.packages import importr
 from rpy2.robjects import r
 import rpy2.robjects as robj
 
+import itertools as IT
+
+
 __all__ = ['convert_robj', 'load_data', 'convert_to_r_dataframe',
            'convert_to_r_matrix']
 
@@ -46,38 +49,44 @@ def _is_null(obj):
 
 def _convert_list(obj):
     """
-    Convert named Vector to dict
+    Convert named Vector to dict, factors to list
     """
-    values = [convert_robj(x) for x in obj]
-    return dict(zip(obj.names, values))
+    try:
+        values = [convert_robj(x) for x in obj]
+        keys = r['names'](obj)
+        return dict(zip(keys, values))
+    except TypeError:
+        # For state.division and state.region
+        factors = list(r['factor'](obj))
+        level = list(r['levels'](obj))
+        result = [level[index-1] for index in factors]
+        return result
 
 
 def _convert_array(obj):
     """
-    Convert Array to ndarray
+    Convert Array to DataFrame
     """
-    # this royally sucks. "Matrices" (arrays) with dimension > 3 in R aren't
-    # really matrices-- things come out Fortran order in the first two
-    # dimensions. Maybe I'm wrong?
-
+    def _list(item):
+        try:
+            return list(item)
+        except TypeError:
+            return []
+        
+    # For iris3, HairEyeColor, UCBAdmissions, Titanic
     dim = list(obj.dim)
     values = np.array(list(obj))
-
-    if len(dim) == 3:
-        arr = values.reshape(dim[-1:] + dim[:-1]).swapaxes(1, 2)
-
-    if obj.names is not None:
-        name_list = [list(x) for x in obj.names]
-        if len(dim) == 2:
-            return pd.DataFrame(arr, index=name_list[0], columns=name_list[1])
-        elif len(dim) == 3:
-            return pd.Panel(arr, items=name_list[2],
-                            major_axis=name_list[0],
-                            minor_axis=name_list[1])
-        else:
-            print('Cannot handle dim=%d' % len(dim))
-    else:
-        return arr
+    names = r['dimnames'](obj)
+    try:
+        columns = list(r['names'](names))[::-1]
+    except TypeError:
+        columns = ['X{:d}'.format(i) for i in range(len(names))][::-1]
+    columns.append('value')
+    name_list = [(_list(x) or range(d)) for x, d in zip(names, dim)][::-1]
+    arr = np.array(list(IT.product(*name_list)))
+    arr = np.column_stack([arr,values])
+    df = pd.DataFrame(arr, columns=columns)
+    return df
 
 
 def _convert_vector(obj):
@@ -85,8 +94,24 @@ def _convert_vector(obj):
         return _convert_int_vector(obj)
     elif isinstance(obj, robj.StrVector):
         return _convert_str_vector(obj)
-
-    return list(obj)
+    # Check if the vector has extra information attached to it that can be used
+    # as an index
+    try:
+        attributes = set(r['attributes'](obj).names)
+    except AttributeError:
+        return list(obj)
+    if 'names' in attributes:
+        return pd.Series(list(obj), index=r['names'](obj)) 
+    elif 'tsp' in attributes:
+        return pd.Series(list(obj), index=r['time'](obj)) 
+    elif 'labels' in attributes:
+        return pd.Series(list(obj), index=r['labels'](obj))
+    if _rclass(obj) == 'dist':
+        # For 'eurodist'. WARNING: This results in a DataFrame, not a Series or list.
+        matrix = r['as.matrix'](obj)
+        return convert_robj(matrix)
+    else:
+        return list(obj)
 
 NA_INTEGER = -2147483648
 
@@ -141,8 +166,7 @@ def _convert_Matrix(mat):
     rows = mat.rownames
 
     columns = None if _is_null(columns) else list(columns)
-    index = None if _is_null(rows) else list(rows)
-
+    index = r['time'](mat) if _is_null(rows) else list(rows)
     return pd.DataFrame(np.array(mat), index=_check_int(index),
                         columns=columns)
 
@@ -197,7 +221,7 @@ def convert_robj(obj, use_pandas=True):
         if isinstance(obj, rpy_type):
             return converter(obj)
 
-    raise Exception('Do not know what to do with %s object' % type(obj))
+    raise TypeError('Do not know what to do with %s object' % type(obj))
 
 
 def convert_to_r_posixct(obj):
@@ -329,117 +353,5 @@ def convert_to_r_matrix(df, strings_as_factors=False):
 
     return r_matrix
 
-
-def test_convert_list():
-    obj = r('list(a=1, b=2, c=3)')
-
-    converted = convert_robj(obj)
-    expected = {'a': [1], 'b': [2], 'c': [3]}
-
-    _test.assert_dict_equal(converted, expected)
-
-
-def test_convert_nested_list():
-    obj = r('list(a=list(foo=1, bar=2))')
-
-    converted = convert_robj(obj)
-    expected = {'a': {'foo': [1], 'bar': [2]}}
-
-    _test.assert_dict_equal(converted, expected)
-
-
-def test_convert_frame():
-    # built-in dataset
-    df = r['faithful']
-
-    converted = convert_robj(df)
-
-    assert np.array_equal(converted.columns, ['eruptions', 'waiting'])
-    assert np.array_equal(converted.index, np.arange(1, 273))
-
-
-def _test_matrix():
-    r('mat <- matrix(rnorm(9), ncol=3)')
-    r('colnames(mat) <- c("one", "two", "three")')
-    r('rownames(mat) <- c("a", "b", "c")')
-
-    return r['mat']
-
-
-def test_convert_matrix():
-    mat = _test_matrix()
-
-    converted = convert_robj(mat)
-
-    assert np.array_equal(converted.index, ['a', 'b', 'c'])
-    assert np.array_equal(converted.columns, ['one', 'two', 'three'])
-
-
-def test_convert_r_dataframe():
-
-    is_na = robj.baseenv.get("is.na")
-
-    seriesd = _test.getSeriesData()
-    frame = pd.DataFrame(seriesd, columns=['D', 'C', 'B', 'A'])
-
-    # Null data
-    frame["E"] = [np.nan for item in frame["A"]]
-    # Some mixed type data
-    frame["F"] = ["text" if item % 2 == 0 else np.nan for item in range(30)]
-
-    r_dataframe = convert_to_r_dataframe(frame)
-
-    assert np.array_equal(convert_robj(r_dataframe.rownames), frame.index)
-    assert np.array_equal(convert_robj(r_dataframe.colnames), frame.columns)
-    assert all(is_na(item) for item in r_dataframe.rx2("E"))
-
-    for column in frame[["A", "B", "C", "D"]]:
-        coldata = r_dataframe.rx2(column)
-        original_data = frame[column]
-        assert np.array_equal(convert_robj(coldata), original_data)
-
-    for column in frame[["D", "E"]]:
-        for original, converted in zip(frame[column],
-                                       r_dataframe.rx2(column)):
-
-            if pd.isnull(original):
-                assert is_na(converted)
-            else:
-                assert original == converted
-
-
-def test_convert_r_matrix():
-
-    is_na = robj.baseenv.get("is.na")
-
-    seriesd = _test.getSeriesData()
-    frame = pd.DataFrame(seriesd, columns=['D', 'C', 'B', 'A'])
-    # Null data
-    frame["E"] = [np.nan for item in frame["A"]]
-
-    r_dataframe = convert_to_r_matrix(frame)
-
-    assert np.array_equal(convert_robj(r_dataframe.rownames), frame.index)
-    assert np.array_equal(convert_robj(r_dataframe.colnames), frame.columns)
-    assert all(is_na(item) for item in r_dataframe.rx(True, "E"))
-
-    for column in frame[["A", "B", "C", "D"]]:
-        coldata = r_dataframe.rx(True, column)
-        original_data = frame[column]
-        assert np.array_equal(convert_robj(coldata),
-                              original_data)
-
-    # Pandas bug 1282
-    frame["F"] = ["text" if item % 2 == 0 else np.nan for item in range(30)]
-
-    # FIXME: Ugly, this whole module needs to be ported to nose/unittest
-    try:
-        wrong_matrix = convert_to_r_matrix(frame)
-    except TypeError:
-        pass
-    except Exception:
-        raise
-
-
 if __name__ == '__main__':
     pass
diff --git a/pandas/rpy/tests/__init__.py b/pandas/rpy/tests/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/rpy/tests/test_common.py b/pandas/rpy/tests/test_common.py
new file mode 100644
index 000000000..a2e6d08d0
--- /dev/null
+++ b/pandas/rpy/tests/test_common.py
@@ -0,0 +1,213 @@
+"""
+Testing that functions from rpy work as expected
+"""
+
+import pandas as pd
+import numpy as np
+import unittest
+import nose
+import pandas.util.testing as tm
+
+try:
+    import pandas.rpy.common as com
+    from rpy2.robjects import r
+    import rpy2.robjects as robj
+except ImportError:
+    raise nose.SkipTest('R not installed')
+
+
+class TestCommon(unittest.TestCase):
+    def test_convert_list(self):
+        obj = r('list(a=1, b=2, c=3)')
+
+        converted = com.convert_robj(obj)
+        expected = {'a': [1], 'b': [2], 'c': [3]}
+
+        tm.assert_dict_equal(converted, expected)
+
+    def test_convert_nested_list(self):
+        obj = r('list(a=list(foo=1, bar=2))')
+
+        converted = com.convert_robj(obj)
+        expected = {'a': {'foo': [1], 'bar': [2]}}
+
+        tm.assert_dict_equal(converted, expected)
+
+    def test_convert_frame(self):
+        # built-in dataset
+        df = r['faithful']
+
+        converted = com.convert_robj(df)
+
+        assert np.array_equal(converted.columns, ['eruptions', 'waiting'])
+        assert np.array_equal(converted.index, np.arange(1, 273))
+
+    def _test_matrix(self):
+        r('mat <- matrix(rnorm(9), ncol=3)')
+        r('colnames(mat) <- c("one", "two", "three")')
+        r('rownames(mat) <- c("a", "b", "c")')
+
+        return r['mat']
+
+    def test_convert_matrix(self):
+        mat = self._test_matrix()
+
+        converted = com.convert_robj(mat)
+
+        assert np.array_equal(converted.index, ['a', 'b', 'c'])
+        assert np.array_equal(converted.columns, ['one', 'two', 'three'])
+
+    def test_convert_r_dataframe(self):
+
+        is_na = robj.baseenv.get("is.na")
+
+        seriesd = tm.getSeriesData()
+        frame = pd.DataFrame(seriesd, columns=['D', 'C', 'B', 'A'])
+
+        # Null data
+        frame["E"] = [np.nan for item in frame["A"]]
+        # Some mixed type data
+        frame["F"] = ["text" if item %
+                      2 == 0 else np.nan for item in range(30)]
+
+        r_dataframe = com.convert_to_r_dataframe(frame)
+
+        assert np.array_equal(
+            com.convert_robj(r_dataframe.rownames), frame.index)
+        assert np.array_equal(
+            com.convert_robj(r_dataframe.colnames), frame.columns)
+        assert all(is_na(item) for item in r_dataframe.rx2("E"))
+
+        for column in frame[["A", "B", "C", "D"]]:
+            coldata = r_dataframe.rx2(column)
+            original_data = frame[column]
+            assert np.array_equal(com.convert_robj(coldata), original_data)
+
+        for column in frame[["D", "E"]]:
+            for original, converted in zip(frame[column],
+                                           r_dataframe.rx2(column)):
+
+                if pd.isnull(original):
+                    assert is_na(converted)
+                else:
+                    assert original == converted
+
+    def test_convert_r_matrix(self):
+
+        is_na = robj.baseenv.get("is.na")
+
+        seriesd = tm.getSeriesData()
+        frame = pd.DataFrame(seriesd, columns=['D', 'C', 'B', 'A'])
+        # Null data
+        frame["E"] = [np.nan for item in frame["A"]]
+
+        r_dataframe = com.convert_to_r_matrix(frame)
+
+        assert np.array_equal(
+            com.convert_robj(r_dataframe.rownames), frame.index)
+        assert np.array_equal(
+            com.convert_robj(r_dataframe.colnames), frame.columns)
+        assert all(is_na(item) for item in r_dataframe.rx(True, "E"))
+
+        for column in frame[["A", "B", "C", "D"]]:
+            coldata = r_dataframe.rx(True, column)
+            original_data = frame[column]
+            assert np.array_equal(com.convert_robj(coldata),
+                                  original_data)
+
+        # Pandas bug 1282
+        frame["F"] = ["text" if item %
+                      2 == 0 else np.nan for item in range(30)]
+
+        try:
+            wrong_matrix = com.convert_to_r_matrix(frame)
+        except TypeError:
+            pass
+        except Exception:
+            raise
+
+    def test_dist(self):
+        for name in ('eurodist',):
+            df = com.load_data(name)
+            dist = r[name]
+            labels = r['labels'](dist)
+            assert np.array_equal(df.index, labels)
+            assert np.array_equal(df.columns, labels)
+
+    def test_timeseries(self):
+        """
+        Test that the series has an informative index.
+        Unfortunately the code currently does not build a DateTimeIndex
+        """
+        for name in (
+            'austres', 'co2', 'fdeaths', 'freeny.y', 'JohnsonJohnson',
+            'ldeaths', 'mdeaths', 'nottem', 'presidents', 'sunspot.month', 'sunspots',
+            'UKDriverDeaths', 'UKgas', 'USAccDeaths',
+            'airmiles', 'discoveries', 'EuStockMarkets',
+            'LakeHuron', 'lh', 'lynx', 'nhtemp', 'Nile',
+                'Seatbelts', 'sunspot.year', 'treering', 'uspop'):
+            series = com.load_data(name)
+            ts = r[name]
+            assert np.array_equal(series.index, r['time'](ts))
+
+    def test_numeric(self):
+        for name in ('euro', 'islands', 'precip'):
+            series = com.load_data(name)
+            numeric = r[name]
+            names = numeric.names
+            assert np.array_equal(series.index, names)
+
+    def test_table(self):
+        iris3 = pd.DataFrame({'X0': {0: '0', 1: '1', 2: '2', 3: '3', 4: '4'},
+                              'X1': {0: 'Sepal L.',
+                                     1: 'Sepal L.',
+                                     2: 'Sepal L.',
+                                     3: 'Sepal L.',
+                                     4: 'Sepal L.'},
+                              'X2': {0: 'Setosa',
+                                     1: 'Setosa',
+                                     2: 'Setosa',
+                                     3: 'Setosa',
+                                     4: 'Setosa'},
+                              'value': {0: '5.1', 1: '4.9', 2: '4.7', 3: '4.6', 4: '5.0'}})
+        hec = pd.DataFrame(
+            {
+                'Eye': {0: 'Brown', 1: 'Brown', 2: 'Brown', 3: 'Brown', 4: 'Blue'},
+                'Hair': {0: 'Black', 1: 'Brown', 2: 'Red', 3: 'Blond', 4: 'Black'},
+                'Sex': {0: 'Male', 1: 'Male', 2: 'Male', 3: 'Male', 4: 'Male'},
+                'value': {0: '32.0', 1: '53.0', 2: '10.0', 3: '3.0', 4: '11.0'}})
+        titanic = pd.DataFrame(
+            {
+                'Age': {0: 'Child', 1: 'Child', 2: 'Child', 3: 'Child', 4: 'Child'},
+                'Class': {0: '1st', 1: '2nd', 2: '3rd', 3: 'Crew', 4: '1st'},
+                'Sex': {0: 'Male', 1: 'Male', 2: 'Male', 3: 'Male', 4: 'Female'},
+                'Survived': {0: 'No', 1: 'No', 2: 'No', 3: 'No', 4: 'No'},
+                'value': {0: '0.0', 1: '0.0', 2: '35.0', 3: '0.0', 4: '0.0'}})
+        for name, expected in zip(('HairEyeColor', 'Titanic', 'iris3'),
+                                 (hec, titanic, iris3)):
+            df = com.load_data(name)
+            table = r[name]
+            names = r['dimnames'](table)
+            try:
+                columns = list(r['names'](names))[::-1]
+            except TypeError:
+                columns = ['X{:d}'.format(i) for i in range(len(names))][::-1]
+            columns.append('value')
+            assert np.array_equal(df.columns, columns)
+            result = df.head()
+            cond = ((result.sort(axis=1) == expected.sort(axis=1))).values
+            assert np.all(cond)
+
+    def test_factor(self):
+        for name in ('state.division', 'state.region'):
+            vector = r[name]
+            factors = list(r['factor'](vector))
+            level = list(r['levels'](vector))
+            factors = [level[index - 1] for index in factors]
+            result = com.load_data(name)
+            assert np.equal(result, factors)
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   # '--with-coverage', '--cover-package=pandas.core'],
+                   exit=False)

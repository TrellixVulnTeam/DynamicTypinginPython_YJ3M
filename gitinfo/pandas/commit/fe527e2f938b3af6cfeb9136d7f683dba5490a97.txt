commit fe527e2f938b3af6cfeb9136d7f683dba5490a97
Author: Adam Klein <adamklein@gmail.com>
Date:   Sat Feb 18 16:46:59 2012 -0500

    ENH: added offset attribute to DatetimeIndex

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index e1c8fcdec..2994ec887 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -98,12 +98,16 @@ class DateRange(DatetimeIndex):
         if tzinfo is not None:
             index = [d.replace(tzinfo=tzinfo) for d in index]
 
-        index = DatetimeIndex(data=index, name=name, freq=time_rule)
-        
+        index = np.array(_dt_unbox_array(index), dtype='M8[us]', copy=False)
+        index = index.view(cls)
         index.name = name
         index.offset = offset
         index.tzinfo = tzinfo
 
+        index.freq = time_rule
+        index.regular = True
+        index.first = index._cache_loc(index.values[0])
+
         return index
 
     def __reduce__(self):
@@ -260,6 +264,31 @@ class DateRange(DatetimeIndex):
 
     __str__ = __repr__
 
+    def shift(self, n, offset=None):
+        """
+        Specialized shift which produces a DateRange
+
+        Parameters
+        ----------
+        n : int
+            Periods to shift by
+        offset : DateOffset or timedelta-like, optional
+
+        Returns
+        -------
+        shifted : DateRange
+        """
+        if offset is not None and offset != self.offset:
+            return DatetimeIndex.shift(self, n, offset)
+
+        if n == 0:
+            # immutable so OK
+            return self
+
+        start = self[0] + n * self.offset
+        end = self[-1] + n * self.offset
+        return DateRange(start, end, offset=self.offset, name=self.name)
+
     def union(self, other):
         """
         Specialized union for DateRange objects. If combine
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 6550aa68f..2ab76ad6d 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1170,6 +1170,7 @@ class DatetimeIndex(Int64Index):
         subarr = subarr.view(cls)
         subarr.freq = None
         subarr.name = name
+        subarr.offset = None
 
         if freq is not None:
             failure, regular = lib.conformity_check(subarr.asi8, freq)
@@ -1179,6 +1180,7 @@ class DatetimeIndex(Int64Index):
             subarr.regular = regular
             subarr.freq = freq
             subarr.first = tcache.lookup(subarr.values[0])
+            subarr.offset = _offsetMap[freq]
 
         return subarr
 
@@ -1202,6 +1204,8 @@ class DatetimeIndex(Int64Index):
         newdti.last = last
         newdti.regular = True
 
+        newdti.offset = _offsetMap[freq]
+
         return newdti
 
     @classmethod
@@ -1210,6 +1214,7 @@ class DatetimeIndex(Int64Index):
         newdti.name = name
         newdti.freq = freq
         newdti.first = first
+        newdti.offset = _offsetMap[freq]
         if regular is None:
             newdti.regular = False
         else:
@@ -1253,7 +1258,7 @@ class DatetimeIndex(Int64Index):
         if n == 0:
             return self
 
-        if self.freq is not None:
+        if hasattr(self, 'freq') and self.freq is not None:
             if offset is None or offset == _offsetMap[self.freq]:
                 return self.fshift(n)
 
@@ -1297,6 +1302,16 @@ class DatetimeIndex(Int64Index):
 
             return DatetimeIndex(result, name=self.name)
 
+    def _cache_loc(self, key):
+        """
+        Get location of key in associated tcache
+        """
+        if isinstance(key,datetime):
+            key = _dt_unbox(key)
+        if hasattr(self, 'freq') and self.freq is not None:
+            tcache = lib.get_tcache(self.freq)
+            return tcache.lookup(key)
+
     # Try to run function on index first, and then on elements of index
     # Especially important for group-by functionality
     def map(self, func_to_map):
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index 5eaa40289..006d70974 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -220,7 +220,7 @@ class TestDateRange(unittest.TestCase):
         the_int = rng1.intersection(rng2)
         expected = rng[10:25]
         self.assert_(the_int.equals(expected))
-        self.assert_(isinstance(the_int, DateRange))
+        self.assert_(isinstance(the_int, DatetimeIndex))
         self.assert_(the_int.offset == rng.offset)
 
         the_int = rng1.intersection(rng2.view(DatetimeIndex))

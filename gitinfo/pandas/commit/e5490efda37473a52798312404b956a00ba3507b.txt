commit e5490efda37473a52798312404b956a00ba3507b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 7 13:45:58 2012 -0400

    BUG: enable .ix to better handle indexes with duplicates, close #1201

diff --git a/RELEASE.rst b/RELEASE.rst
index 5e05dc91b..62c6a9eeb 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -35,6 +35,8 @@ pandas 0.8.0
     (#864)
   - Add limit argument for forward/backward filling to reindex, fillna,
     etc. (#825 and others)
+  - Add support for indexes (dates or otherwise) with duplicates and common
+    sense indexing/selection functionality
 
 **Improvements to existing features**
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 5691bf65a..33b157694 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1469,8 +1469,11 @@ class DataFrame(NDFrame):
                 raise ValueError('Item wrong length %d instead of %d!' %
                                  (len(key), len(self.index)))
 
-            new_index = self.index[key]
-            return self.reindex(new_index)
+            inds, = key.nonzero()
+            return self.take(inds)
+
+            # new_index = self.index[key]
+            # return self.reindex(new_index)
         else:
             indexer = self.columns.get_indexer(key)
             mask = indexer == -1
@@ -1698,12 +1701,21 @@ class DataFrame(NDFrame):
         index = self.index
         if isinstance(index, MultiIndex):
             loc, new_index = self.index.get_loc_level(key)
-        elif isinstance(index, DatetimeIndex):
+        else:
             loc = self.index.get_loc(key)
+
+            if isinstance(loc, np.ndarray):
+                if loc.dtype == np.bool_:
+                    inds, = loc.nonzero()
+                    if len(inds) == 1:
+                        loc = inds[0]
+                    else:
+                        return self.take(inds, axis=axis)
+                else:
+                    return self.take(loc, axis=axis)
+
             if not np.isscalar(loc):
                 new_index = self.index[loc]
-        else:
-            loc = self.index.get_loc(key)
 
         if np.isscalar(loc):
             new_values = self._data.fast_2d_xs(loc, copy=copy)
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index da24a07d3..48a29a8ed 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -212,8 +212,9 @@ class _NDFrameIndexer(object):
             else:
                 # asarray can be unsafe, NumPy strings are weird
                 keyarr = _asarray_tuplesafe(key)
+
             if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
-                keyarr = labels.take(keyarr)
+                return self.obj.take(keyarr, axis=axis)
 
             # this is not the most robust, but...
             if (isinstance(labels, MultiIndex) and
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index a6adc0c6b..b03e2a864 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -877,6 +877,23 @@ class CheckIndexing(object):
     def test_setitem_boolean_missing(self):
         pass
 
+    def test_getitem_setitem_ix_duplicates(self):
+        # #1201
+        df = DataFrame(np.random.randn(5, 3),
+                       index=['foo', 'foo', 'bar', 'baz', 'bar'])
+
+        result = df.ix['foo']
+        expected = df[:2]
+        assert_frame_equal(result, expected)
+
+        result = df.ix['bar']
+        expected = df.ix[[2, 4]]
+        assert_frame_equal(result, expected)
+
+        result = df.ix['baz']
+        expected = df.ix[3]
+        assert_series_equal(result, expected)
+
     def test_get_value(self):
         for idx in self.frame.index:
             for col in self.frame.columns:
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 8eb4475f5..3c1d5c06e 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -565,6 +565,11 @@ class TestTimeSeries(unittest.TestCase):
         assert_series_equal(result, expected)
         tm.assert_frame_equal(result_df, exp_df)
 
+        chunk = df.ix['1/4/2000':]
+        result = chunk.ix[time(9, 30)]
+        expected = result_df[-1:]
+        tm.assert_frame_equal(result, expected)
+
     def test_dti_constructor_preserve_dti_freq(self):
         rng = date_range('1/1/2000', '1/2/2000', freq='5min')
 
diff --git a/vb_suite/frame_methods.py b/vb_suite/frame_methods.py
index 6a78b7d59..cf6967e32 100644
--- a/vb_suite/frame_methods.py
+++ b/vb_suite/frame_methods.py
@@ -50,3 +50,15 @@ cols = cols[0:99]
 
 frame_multiaxis_reindex = Benchmark('df.reindex(index=idx, columns=cols)',
                                     setup, start_date=datetime(2012, 5, 6))
+
+#----------------------------------------------------------------------
+# boolean indexing
+
+setup = common_setup + """
+df = DataFrame(randn(10000, 100))
+bool_arr = np.zeros(10000, dtype=bool)
+bool_arr[:1000] = True
+"""
+
+frame_boolean_row_select = Benchmark('df[bool_arr]', setup,
+                                     start_date=datetime(2011, 1, 1))

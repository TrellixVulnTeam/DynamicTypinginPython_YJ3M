commit 2783c27e0027cbae9a3d97a04d33a7ef843fcd72
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Wed Nov 7 20:21:22 2018 +0000

    Fix convert-adjust (#531)
    
    * Add dimensions to alignments + refactor
    
    * Add frame_dims + funcs to DetectFaces. Add alignments lib
    
    * Convert Adjust working
    
    * Refactor and tidy up

diff --git a/lib/aligner.py b/lib/aligner.py
index d946be2..882e42f 100644
--- a/lib/aligner.py
+++ b/lib/aligner.py
@@ -1,32 +1,136 @@
-import numpy
+#!/usr/bin/env python3
+""" Aligner for faceswap.py """
 
-from lib.umeyama import umeyama
-from lib.align_eyes import align_eyes
-from numpy.linalg import inv
 import cv2
+import numpy as np
+
+from lib.umeyama import umeyama
+from lib.align_eyes import align_eyes as func_align_eyes, FACIAL_LANDMARKS_IDXS
+
+MEAN_FACE_X = np.array([
+    0.000213256, 0.0752622, 0.18113, 0.29077, 0.393397, 0.586856, 0.689483,
+    0.799124, 0.904991, 0.98004, 0.490127, 0.490127, 0.490127, 0.490127,
+    0.36688, 0.426036, 0.490127, 0.554217, 0.613373, 0.121737, 0.187122,
+    0.265825, 0.334606, 0.260918, 0.182743, 0.645647, 0.714428, 0.793132,
+    0.858516, 0.79751, 0.719335, 0.254149, 0.340985, 0.428858, 0.490127,
+    .551395, 0.639268, 0.726104, 0.642159, 0.556721, 0.490127, 0.423532,
+    0.338094, 0.290379, 0.428096, 0.490127, 0.552157, 0.689874, 0.553364,
+    0.490127, 0.42689])
+
+MEAN_FACE_Y = np.array([
+    0.106454, 0.038915, 0.0187482, 0.0344891, 0.0773906, 0.0773906, 0.0344891,
+    0.0187482, 0.038915, 0.106454, 0.203352, 0.307009, 0.409805, 0.515625,
+    0.587326, 0.609345, 0.628106, 0.609345, 0.587326, 0.216423, 0.178758,
+    0.179852, 0.231733, 0.245099, 0.244077, 0.231733, 0.179852, 0.178758,
+    0.216423, 0.244077, 0.245099, 0.780233, 0.745405, 0.727388, 0.742578,
+    0.727388, 0.745405, 0.780233, 0.864805, 0.902192, 0.909281, 0.902192,
+    0.864805, 0.784792, 0.778746, 0.785343, 0.778746, 0.784792, 0.824182,
+    0.831803, 0.824182])
+
+LANDMARKS_2D = np.stack([MEAN_FACE_X, MEAN_FACE_Y], axis=1)
+
+
+class Extract():
+    """ Based on the original https://www.reddit.com/r/deepfakes/
+        code sample + contribs """
+
+    def extract(self, image, face, size, align_eyes):
+        """ Extract a face from an image """
+        alignment = get_align_mat(face, size, align_eyes)
+        extracted = self.transform(image, alignment, size, 48)
+        return extracted, alignment
+
+    @staticmethod
+    def transform_matrix(mat, size, padding):
+        """ Transform the matrix for current size and padding """
+        matrix = mat * (size - 2 * padding)
+        matrix[:, 2] += padding
+        return matrix
+
+    def transform(self, image, mat, size, padding=0):
+        """ Transform Image """
+        matrix = self.transform_matrix(mat, size, padding)
+        return cv2.warpAffine(  # pylint: disable=no-member
+            image, matrix, (size, size))
+
+    def transform_points(self, points, mat, size, padding=0):
+        """ Transform points along matrix """
+        matrix = self.transform_matrix(mat, size, padding)
+        points = np.expand_dims(points, axis=1)
+        points = cv2.transform(  # pylint: disable=no-member
+            points, matrix, points.shape)
+        return np.squeeze(points)
+
+    def get_original_roi(self, mat, size, padding=0):
+        """ Return the square aligned box location on the original
+            image """
+        matrix = self.transform_matrix(mat, size, padding)
+        points = np.array([[0, 0],
+                           [0, size - 1],
+                           [size - 1, size - 1],
+                           [size - 1, 0]], np.int32)
+        points = points.reshape((-1, 1, 2))
+        matrix = cv2.invertAffineTransform(matrix)  # pylint: disable=no-member
+        return cv2.transform(points, matrix)  # pylint: disable=no-member
+
+    @staticmethod
+    def get_feature_mask(aligned_landmarks_68, size,
+                         padding=0, dilation=30):
+        """ Return the face feature mask """
+        # pylint: disable=no-member
+        scale = size - 2*padding
+        translation = padding
+        pad_mat = np.matrix([[scale, 0.0, translation],
+                             [0.0, scale, translation]])
+        aligned_landmarks_68 = np.expand_dims(aligned_landmarks_68, axis=1)
+        aligned_landmarks_68 = cv2.transform(aligned_landmarks_68,
+                                             pad_mat,
+                                             aligned_landmarks_68.shape)
+        aligned_landmarks_68 = np.squeeze(aligned_landmarks_68)
+
+        (l_start, l_end) = FACIAL_LANDMARKS_IDXS["left_eye"]
+        (r_start, r_end) = FACIAL_LANDMARKS_IDXS["right_eye"]
+        (m_start, m_end) = FACIAL_LANDMARKS_IDXS["mouth"]
+        (n_start, n_end) = FACIAL_LANDMARKS_IDXS["nose"]
+        (lb_start, lb_end) = FACIAL_LANDMARKS_IDXS["left_eyebrow"]
+        (rb_start, rb_end) = FACIAL_LANDMARKS_IDXS["right_eyebrow"]
+        (c_start, c_end) = FACIAL_LANDMARKS_IDXS["chin"]
+
+        l_eye_points = aligned_landmarks_68[l_start:l_end].tolist()
+        l_brow_points = aligned_landmarks_68[lb_start:lb_end].tolist()
+        r_eye_points = aligned_landmarks_68[r_start:r_end].tolist()
+        r_brow_points = aligned_landmarks_68[rb_start:rb_end].tolist()
+        nose_points = aligned_landmarks_68[n_start:n_end].tolist()
+        chin_points = aligned_landmarks_68[c_start:c_end].tolist()
+        mouth_points = aligned_landmarks_68[m_start:m_end].tolist()
+        l_eye_points = l_eye_points + l_brow_points
+        r_eye_points = r_eye_points + r_brow_points
+        mouth_points = mouth_points + nose_points + chin_points
+
+        l_eye_hull = cv2.convexHull(np.array(l_eye_points).reshape(
+            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
+        r_eye_hull = cv2.convexHull(np.array(r_eye_points).reshape(
+            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
+        mouth_hull = cv2.convexHull(np.array(mouth_points).reshape(
+            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
+
+        mask = np.zeros((size, size, 3), dtype=float)
+        cv2.fillConvexPoly(mask, l_eye_hull, (1, 1, 1))
+        cv2.fillConvexPoly(mask, r_eye_hull, (1, 1, 1))
+        cv2.fillConvexPoly(mask, mouth_hull, (1, 1, 1))
+
+        if dilation > 0:
+            kernel = np.ones((dilation, dilation), np.uint8)
+            mask = cv2.dilate(mask, kernel, iterations=1)
+
+        return mask
 
-mean_face_x = numpy.array([
-0.000213256, 0.0752622, 0.18113, 0.29077, 0.393397, 0.586856, 0.689483, 0.799124,
-0.904991, 0.98004, 0.490127, 0.490127, 0.490127, 0.490127, 0.36688, 0.426036,
-0.490127, 0.554217, 0.613373, 0.121737, 0.187122, 0.265825, 0.334606, 0.260918,
-0.182743, 0.645647, 0.714428, 0.793132, 0.858516, 0.79751, 0.719335, 0.254149,
-0.340985, 0.428858, 0.490127, 0.551395, 0.639268, 0.726104, 0.642159, 0.556721,
-0.490127, 0.423532, 0.338094, 0.290379, 0.428096, 0.490127, 0.552157, 0.689874,
-0.553364, 0.490127, 0.42689 ])
-
-mean_face_y = numpy.array([
-0.106454, 0.038915, 0.0187482, 0.0344891, 0.0773906, 0.0773906, 0.0344891,
-0.0187482, 0.038915, 0.106454, 0.203352, 0.307009, 0.409805, 0.515625, 0.587326,
-0.609345, 0.628106, 0.609345, 0.587326, 0.216423, 0.178758, 0.179852, 0.231733,
-0.245099, 0.244077, 0.231733, 0.179852, 0.178758, 0.216423, 0.244077, 0.245099,
-0.780233, 0.745405, 0.727388, 0.742578, 0.727388, 0.745405, 0.780233, 0.864805,
-0.902192, 0.909281, 0.902192, 0.864805, 0.784792, 0.778746, 0.785343, 0.778746,
-0.784792, 0.824182, 0.831803, 0.824182 ])
-
-landmarks_2D = numpy.stack( [ mean_face_x, mean_face_y ], axis=1 )
 
 def get_align_mat(face, size, should_align_eyes):
-    mat_umeyama = umeyama(numpy.array(face.landmarks_as_xy()[17:]), landmarks_2D, True)[0:2]
+    """ Return the alignment Matrix """
+    mat_umeyama = umeyama(np.array(face.landmarks_as_xy()[17:]),
+                          LANDMARKS_2D,
+                          True)[0:2]
 
     if should_align_eyes is False:
         return mat_umeyama
@@ -34,22 +138,26 @@ def get_align_mat(face, size, should_align_eyes):
     mat_umeyama = mat_umeyama * size
 
     # Convert to matrix
-    landmarks = numpy.matrix(face.landmarks_as_xy())
+    landmarks = np.matrix(face.landmarks_as_xy())
 
-    # cv2 expects points to be in the form np.array([ [[x1, y1]], [[x2, y2]], ... ]), we'll expand the dim
-    landmarks = numpy.expand_dims(landmarks, axis=1)
+    # cv2 expects points to be in the form
+    # np.array([ [[x1, y1]], [[x2, y2]], ... ]), we'll expand the dim
+    landmarks = np.expand_dims(landmarks, axis=1)
 
     # Align the landmarks using umeyama
-    umeyama_landmarks = cv2.transform(landmarks, mat_umeyama, landmarks.shape)
+    umeyama_landmarks = cv2.transform(  # pylint: disable=no-member
+        landmarks,
+        mat_umeyama,
+        landmarks.shape)
 
     # Determine a rotation matrix to align eyes horizontally
-    mat_align_eyes = align_eyes(umeyama_landmarks, size)
+    mat_align_eyes = func_align_eyes(umeyama_landmarks, size)
 
     # Extend the 2x3 transform matrices to 3x3 so we can multiply them
     # and combine them as one
-    mat_umeyama = numpy.matrix(mat_umeyama)
+    mat_umeyama = np.matrix(mat_umeyama)
     mat_umeyama.resize((3, 3))
-    mat_align_eyes = numpy.matrix(mat_align_eyes)
+    mat_align_eyes = np.matrix(mat_align_eyes)
     mat_align_eyes.resize((3, 3))
     mat_umeyama[2] = mat_align_eyes[2] = [0, 0, 1]
 
@@ -57,6 +165,6 @@ def get_align_mat(face, size, should_align_eyes):
     transform_mat = mat_align_eyes * mat_umeyama
 
     # Remove the extra row added, shape needs to be 2x3
-    transform_mat = numpy.delete(transform_mat, 2, 0)
+    transform_mat = np.delete(transform_mat, 2, 0)
     transform_mat = transform_mat / size
     return transform_mat
diff --git a/lib/alignments.py b/lib/alignments.py
new file mode 100644
index 0000000..eacaafb
--- /dev/null
+++ b/lib/alignments.py
@@ -0,0 +1,269 @@
+#!/usr/bin/env python3
+""" Alignments file functions for reading, writing and manipulating
+    a serialized alignments file """
+
+import os
+from datetime import datetime
+
+import cv2
+
+from lib import Serializer
+from lib.utils import rotate_landmarks
+
+
+class Alignments():
+    """ Holds processes pertaining to the alignments file.
+
+        folder:     folder alignments file is stored in
+        filename:   Filename of alignments file excluding extension. If a
+                    valid extension is provided, then it will be used to
+                    decide the serializer, and the serializer argument will
+                    be ignored.
+        serializer: If provided, this will be the format that the data is
+                    saved in (if data is to be saved). Can be 'json', 'pickle'
+                    or 'yaml'
+    """
+    def __init__(self, folder, filename="alignments", serializer="json",
+                 verbose=False):
+        self.verbose = verbose
+        self.serializer = self.get_serializer(filename, serializer)
+        self.file = self.get_location(folder, filename)
+
+        self.data = self.load()
+
+    # << PROPERTIES >> #
+
+    @property
+    def frames_count(self):
+        """ Return current frames count """
+        return len(self.data)
+
+    @property
+    def faces_count(self):
+        """ Return current faces count """
+        return sum(len(faces) for faces in self.data.values())
+
+    @property
+    def have_alignments_file(self):
+        """ Return whether an alignments file exists """
+        return os.path.exists(self.file)
+
+    # << INIT FUNCTIONS >> #
+
+    def get_serializer(self, filename, serializer):
+        """ Set the serializer to be used for loading and
+            saving alignments
+
+            If a filename with a valid extension is passed in
+            this will be used as the serializer, otherwise the
+            specified serializer will be used """
+        extension = os.path.splitext(filename)[1]
+        if extension in (".json", ".p", ".yaml", ".yml"):
+            retval = Serializer.get_serializer_from_ext(extension)
+        elif serializer not in ("json", "pickle", "yaml"):
+            raise ValueError("Error: {} is not a valid serializer. Use "
+                             "'json', 'pickle' or 'yaml'")
+        else:
+            retval = Serializer.get_serializer(serializer)
+        if self.verbose:
+            print("Using {} serializer for alignments".format(retval.ext))
+        return retval
+
+    def get_location(self, folder, filename):
+        """ Return the path to alignments file """
+        extension = os.path.splitext(filename)[1]
+        if extension in (".json", ".p", ".yaml", ".yml"):
+            location = os.path.join(str(folder), filename)
+        else:
+            location = os.path.join(str(folder),
+                                    "{}.{}".format(filename,
+                                                   self.serializer.ext))
+        if self.verbose:
+            print("Alignments filepath: {}".format(location))
+        return location
+
+    # << I/O >> #
+
+    def load(self):
+        """ Load the alignments data if it exists or create empty dict """
+        if not self.have_alignments_file:
+            raise ValueError("Error: Alignments file not found at "
+                             "{}".format(self.file))
+
+        try:
+            print("Reading alignments from: {}".format(self.file))
+            with open(self.file, self.serializer.roptions) as align:
+                data = self.serializer.unmarshal(align.read())
+        except IOError as err:
+            print("Error: {} not read: {}".format(self.file, err.strerror))
+            exit(1)
+        return data
+
+    def reload(self):
+        """ Read the alignments data from the correct format """
+        self.data = self.load()
+
+    def save(self):
+        """ Write the serialized alignments file """
+        try:
+            print("Writing alignments to: {}".format(self.file))
+            with open(self.file, self.serializer.woptions) as align:
+                align.write(self.serializer.marshal(self.data))
+        except IOError as err:
+            print("Error: {} not written: {}".format(self.file, err.strerror))
+
+    def backup(self):
+        """ Backup copy of old alignments """
+        if not os.path.isfile(self.file):
+            return
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        src = self.file
+        split = os.path.splitext(src)
+        dst = split[0] + "_" + now + split[1]
+        print("Backing up original alignments to {}".format(dst))
+        os.rename(src, dst)
+
+    # << VALIDATION >> #
+
+    def frame_exists(self, frame):
+        """ return path of images that have faces """
+        return frame in self.data.keys()
+
+    def frame_has_faces(self, frame):
+        """ Return true if frame exists and has faces """
+        return bool(self.data.get(frame, list()))
+
+    def frame_has_multiple_faces(self, frame):
+        """ Return true if frame exists and has faces """
+        if not frame:
+            return False
+        return bool(len(self.data.get(frame, list())) > 1)
+
+    # << DATA >> #
+
+    def get_faces_in_frame(self, frame):
+        """ Return the alignments for the selected frame """
+        return self.data.get(frame, list())
+
+    def get_full_frame_name(self, frame):
+        """ Return a frame with extension for when the extension is
+            not known """
+        return next(key for key in self.data.keys()
+                    if key.startswith(frame))
+
+    def count_faces_in_frame(self, frame):
+        """ Return number of alignments within frame """
+        return len(self.data.get(frame, list()))
+
+    # << MANIPULATION >> #
+
+    def delete_face_at_index(self, frame, idx):
+        """ Delete the face alignment for given frame at given index """
+        idx = int(idx)
+        if idx + 1 > self.count_faces_in_frame(frame):
+            return False
+        del self.data[frame][idx]
+        return True
+
+    def add_face(self, frame, alignment):
+        """ Add a new face for a frame and return it's index """
+        self.data[frame].append(alignment)
+        return self.count_faces_in_frame(frame) - 1
+
+    def update_face(self, frame, idx, alignment):
+        """ Replace a face for given frame and index """
+        self.data[frame][idx] = alignment
+
+    # << GENERATORS >> #
+
+    def yield_faces(self):
+        """ Yield face alignments for one image """
+        for frame_fullname, alignments in self.data.items():
+            frame_name = os.path.splitext(frame_fullname)[0]
+            yield frame_name, alignments, len(alignments), frame_fullname
+
+    @staticmethod
+    def yield_original_index_reverse(image_alignments, number_alignments):
+        """ Return the correct original index for
+            alignment in reverse order """
+        for idx, _ in enumerate(reversed(image_alignments)):
+            original_idx = number_alignments - 1 - idx
+            yield original_idx
+
+    # << LEGACY FUNCTIONS >> #
+
+    # < Original Frame Dimensions > #
+    # For dfaker and convert-adjust the original dimensions of a frame are
+    # required to calculate the transposed landmarks. As transposed landmarks
+    # will change on face size, we store original frame dimensions
+    # These were not previously required, so this adds the dimensions
+    # to the landmarks file
+
+    def get_legacy_no_dims(self):
+        """ Return a list of frames that do not contain the original frame
+            height and width attributes """
+        keys = list()
+        for key, val in self.data.items():
+            for alignment in val:
+                if "frame_dims" not in alignment.keys():
+                    keys.append(key)
+                    break
+        return keys
+
+    def add_dimensions(self, frame_name, dimensions):
+        """ Backward compatability fix. Add frame dimensions
+            to alignments """
+        for face in self.get_faces_in_frame(frame_name):
+            face["frame_dims"] = dimensions
+
+    # < Rotation > #
+    # The old rotation method would rotate the image to find a face, then
+    # store the rotated landmarks along with a rotation value to tell the
+    # convert process that it had to rotate the frame to find the landmarks.
+    # This is problematic for numerous reasons. The process now rotates the
+    # landmarks to correctly correspond with the original frame. The below are
+    # functions to convert legacy alignments to the currently supported
+    # infrastructure.
+    # This can eventually be removed
+
+    def get_legacy_rotation(self):
+        """ Return a list of frames with legacy rotations
+            Looks for an 'r' value in the alignments file that
+            is not zero """
+        keys = list()
+        for key, val in self.data.items():
+            if any(alignment.get("r", None) for alignment in val):
+                keys.append(key)
+        return keys
+
+    def rotate_existing_landmarks(self, frame_name):
+        """ Backwards compatability fix. Rotates the landmarks to
+            their correct position and deletes r
+
+            NB: The original frame dimensions must be passed in otherwise
+            the transformation cannot be performed """
+        for face in self.get_faces_in_frame(frame_name):
+            angle = face.get("r", 0)
+            if not angle:
+                return
+            dims = face["frame_dims"]
+            r_mat = self.get_original_rotation_matrix(dims, angle)
+            rotate_landmarks(face, r_mat)
+            del face["r"]
+
+    @staticmethod
+    def get_original_rotation_matrix(dimensions, angle):
+        """ Calculate original rotation matrix and invert """
+        height, width = dimensions
+        center = (width/2, height/2)
+        r_mat = cv2.getRotationMatrix2D(  # pylint: disable=no-member
+            center, -1.0 * angle, 1.)
+
+        abs_cos = abs(r_mat[0, 0])
+        abs_sin = abs(r_mat[0, 1])
+        rotated_width = int(height*abs_sin + width*abs_cos)
+        rotated_height = int(height*abs_cos + width*abs_sin)
+        r_mat[0, 2] += rotated_width/2 - center[0]
+        r_mat[1, 2] += rotated_height/2 - center[1]
+
+        return r_mat
diff --git a/lib/cli.py b/lib/cli.py
index 62fba02..326c477 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -274,7 +274,7 @@ class ExtractConvertArgs(FaceSwapArgs):
                               "help": "Output directory. This is where the "
                                       "converted files will be stored. "
                                       "Defaults to 'output'"})
-        argument_list.append({"opts": ("--alignments", ),
+        argument_list.append({"opts": ("-al", "--alignments"),
                               "action": FileFullPaths,
                               "filetypes": 'alignments',
                               "type": str,
@@ -583,12 +583,12 @@ class ConvertArgs(ExtractConvertArgs):
         argument_list.append({"opts": ("-sm", "--smooth-mask"),
                               "action": "store_true",
                               "dest": "smooth_mask",
-                              "default": True,
+                              "default": False,
                               "help": "Smooth mask (Adjust converter only)"})
         argument_list.append({"opts": ("-aca", "--avg-color-adjust"),
                               "action": "store_true",
                               "dest": "avg_color_adjust",
-                              "default": True,
+                              "default": False,
                               "help": "Average color adjust. "
                                       "(Adjust converter only)"})
         argument_list.append({"opts": ("-dt", "--draw-transparent"),
diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index e521d7b..54d0e3c 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -1,20 +1,24 @@
 #!/usr/bin python3
 """ Face and landmarks detection for faceswap.py """
 
-from dlib import rectangle as d_rectangle
+from dlib import rectangle as d_rectangle  # pylint: disable=no-name-in-module
+from lib.aligner import Extract as AlignerExtract, get_align_mat
 
 
 class DetectedFace():
     """ Detected face and landmark information """
     def __init__(self, image=None, x=None, w=None, y=None, h=None,
-                 landmarksXY=None):
+                 frame_dims=None, landmarksXY=None):
         self.image = image
         self.x = x
         self.w = w
         self.y = y
         self.h = h
+        self.frame_dims = frame_dims
         self.landmarksXY = landmarksXY
 
+        self.aligned = dict()
+
     def landmarks_as_xy(self):
         """ Landmarks as XY """
         return self.landmarksXY
@@ -37,7 +41,8 @@ class DetectedFace():
         self.h = d_rect.bottom() - d_rect.top()
 
     def image_to_face(self, image):
-        """ Crop an image around bounding box to the face """
+        """ Crop an image around bounding box to the face
+            and capture it's dimensions """
         self.image = image[self.y: self.y + self.h,
                            self.x: self.x + self.w]
 
@@ -48,6 +53,7 @@ class DetectedFace():
         alignment["w"] = self.w
         alignment["y"] = self.y
         alignment["h"] = self.h
+        alignment["frame_dims"] = self.frame_dims
         alignment["landmarksXY"] = self.landmarksXY
         return alignment
 
@@ -57,6 +63,50 @@ class DetectedFace():
         self.w = alignment["w"]
         self.y = alignment["y"]
         self.h = alignment["h"]
+        self.frame_dims = alignment["frame_dims"]
         self.landmarksXY = alignment["landmarksXY"]
         if image.any():
             self.image_to_face(image)
+
+    # <<< Aligned Face methods and properties >>> #
+    def load_aligned(self, image, size=256, padding=48, align_eyes=False):
+        """ No need to load aligned information for all uses of this
+            class, so only call this to load the information for easy
+            reference to aligned properties for this face """
+        self.aligned["size"] = size
+        self.aligned["padding"] = padding
+        self.aligned["align_eyes"] = align_eyes
+        self.aligned["matrix"] = get_align_mat(self, size, align_eyes)
+        self.aligned["face"] = AlignerExtract().transform(
+            image,
+            self.aligned["matrix"],
+            size,
+            padding)
+
+    @property
+    def original_roi(self):
+        """ Return the square aligned box location on the original
+            image """
+        return AlignerExtract().get_original_roi(self.aligned["matrix"],
+                                                 self.aligned["size"],
+                                                 self.aligned["padding"])
+
+    @property
+    def aligned_landmarks(self):
+        """ Return the landmarks location transposed to extracted face """
+        return AlignerExtract().transform_points(self.landmarksXY,
+                                                 self.aligned["matrix"],
+                                                 self.aligned["size"],
+                                                 self.aligned["padding"])
+
+    @property
+    def aligned_face(self):
+        """ Return aligned detected face """
+        return self.aligned["face"]
+
+    @property
+    def adjusted_matrix(self):
+        """ Return adjusted matrix for size/padding combination """
+        return AlignerExtract().transform_matrix(self.aligned["matrix"],
+                                                 self.aligned["size"],
+                                                 self.aligned["padding"])
diff --git a/plugins/convert/Convert_Adjust.py b/plugins/convert/Convert_Adjust.py
index cf8cc59..59511fe 100644
--- a/plugins/convert/Convert_Adjust.py
+++ b/plugins/convert/Convert_Adjust.py
@@ -1,64 +1,98 @@
-# Based on the original https://www.reddit.com/r/deepfakes/ code sample
-# Adjust code made by https://github.com/yangchen8710
+#!/usr/bin/env python3
+""" Adjust converter for faceswap.py
+
+    Based on the original https://www.reddit.com/r/deepfakes/ code sample
+    Adjust code made by https://github.com/yangchen8710 """
 
 import cv2
-import numpy
-import os
+import numpy as np
+
 
-class Convert(object):
-    def __init__(self, encoder, smooth_mask=True, avg_color_adjust=True, **kwargs):
+class Convert():
+    """ Adjust Converter """
+    def __init__(self, encoder, smooth_mask=True, avg_color_adjust=True,
+                 **kwargs):
         self.encoder = encoder
 
         self.use_smooth_mask = smooth_mask
         self.use_avg_color_adjust = avg_color_adjust
 
-    def patch_image( self, original, face_detected, size ):
-        #assert image.shape == (256, 256, 3)
-        image = cv2.resize(face_detected.image, (256, 256))
-        crop = slice(48, 208)
-        face = image[crop, crop]
-        old_face = face.copy()
+    def patch_image(self, frame, detected_face, size):
+        """ Patch swapped face onto original image """
+        # pylint: disable=no-member
+        # assert image.shape == (256, 256, 3)
+        padding = 48
+        face_size = 256
+        detected_face.load_aligned(frame, face_size, padding,
+                                   align_eyes=False)
+        src_face = detected_face.aligned_face
+
+        crop = slice(padding, face_size - padding)
+        process_face = src_face[crop, crop]
+        old_face = process_face.copy()
 
-        face = cv2.resize(face, (size, size))
-        face = numpy.expand_dims(face, 0)
-        new_face = self.encoder(face / 255.0)[0]
-        new_face = numpy.clip(new_face * 255, 0, 255).astype(image.dtype)
-        new_face = cv2.resize(new_face, (160, 160))
+        process_face = cv2.resize(process_face,
+                                  (size, size),
+                                  interpolation=cv2.INTER_AREA)
+        process_face = np.expand_dims(process_face, 0)
+
+        new_face = self.encoder(process_face / 255.0)[0]
+        new_face = np.clip(new_face * 255, 0, 255).astype(src_face.dtype)
+        new_face = cv2.resize(
+            new_face,
+            (face_size - padding * 2, face_size - padding * 2),
+            interpolation=cv2.INTER_CUBIC)
 
         if self.use_avg_color_adjust:
-            self.adjust_avg_color(old_face,new_face)
+            self.adjust_avg_color(old_face, new_face)
         if self.use_smooth_mask:
-            self.smooth_mask(old_face,new_face)
+            self.smooth_mask(old_face, new_face)
+
+        new_face = self.superpose(src_face, new_face, crop)
+        new_image = frame.copy()
 
-        new_face = self.superpose(image, new_face, crop)
-        original[slice(face_detected.y, face_detected.y + face_detected.h), slice(face_detected.x, face_detected.x + face_detected.w)] = cv2.resize(new_face, (face_detected.w, face_detected.h))
-        return original
+        cv2.warpAffine(
+            new_face,
+            detected_face.adjusted_matrix,
+            (detected_face.frame_dims[1], detected_face.frame_dims[0]),
+            new_image,
+            flags=cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC,
+            borderMode=cv2.BORDER_TRANSPARENT)
+        return new_image
 
-    def adjust_avg_color(self,img_old,img_new):
-        w,h,c = img_new.shape
-        for i in range(img_new.shape[-1]):
-            old_avg = img_old[:, :, i].mean()
-            new_avg = img_new[:, :, i].mean()
+    @staticmethod
+    def adjust_avg_color(old_face, new_face):
+        """ Perform average color adjustment """
+        for i in range(new_face.shape[-1]):
+            old_avg = old_face[:, :, i].mean()
+            new_avg = new_face[:, :, i].mean()
             diff_int = (int)(old_avg - new_avg)
-            for m in range(img_new.shape[0]):
-                for n in range(img_new.shape[1]):
-                    temp = (img_new[m,n,i] + diff_int)
+            for int_h in range(new_face.shape[0]):
+                for int_w in range(new_face.shape[1]):
+                    temp = (new_face[int_h, int_w, i] + diff_int)
                     if temp < 0:
-                        img_new[m,n,i] = 0
+                        new_face[int_h, int_w, i] = 0
                     elif temp > 255:
-                        img_new[m,n,i] = 255
+                        new_face[int_h, int_w, i] = 255
                     else:
-                        img_new[m,n,i] = temp
+                        new_face[int_h, int_w, i] = temp
 
-    def smooth_mask(self,img_old,img_new):
-        w,h,c = img_new.shape
-        crop = slice(0,w)
-        mask = numpy.zeros_like(img_new)
-        mask[h//15:-h//15,w//15:-w//15,:] = 255
-        mask = cv2.GaussianBlur(mask,(15,15),10)
-        img_new[crop,crop] = mask/255*img_new + (1-mask/255)*img_old
+    @staticmethod
+    def smooth_mask(old_face, new_face):
+        """ Smooth the mask """
+        width, height, _ = new_face.shape
+        crop = slice(0, width)
+        mask = np.zeros_like(new_face)
+        mask[height // 15:-height // 15, width // 15:-width // 15, :] = 255
+        mask = cv2.GaussianBlur(mask,  # pylint: disable=no-member
+                                (15, 15),
+                                10)
+        new_face[crop, crop] = (mask / 255 * new_face +
+                                (1 - mask / 255) * old_face)
 
-    def superpose(self,image, new_face, crop):
-        new_image = image.copy()
+    @staticmethod
+    def superpose(src_face, new_face, crop):
+        """ Crop Face """
+        new_image = src_face.copy()
         new_image[crop, crop] = new_face
         return new_image
diff --git a/plugins/extract/align/_base.py b/plugins/extract/align/_base.py
index f8e9b1f..9fa879c 100644
--- a/plugins/extract/align/_base.py
+++ b/plugins/extract/align/_base.py
@@ -17,20 +17,17 @@
     """
 
 import os
-import cv2
-import numpy as np
-
-from lib.aligner import get_align_mat
-from lib.align_eyes import FACIAL_LANDMARKS_IDXS
 
+from lib.aligner import Extract
 from lib.gpu_stats import GPUStats
 
 
 class Aligner():
     """ Landmarks Aligner Object """
-    def __init__(self, verbose=False, align_eyes=False, size=256):
+    def __init__(self, verbose=False, align_eyes=False, size=256, padding=48):
         self.verbose = verbose
         self.size = size
+        self.padding = padding
         self.cachepath = os.path.join(os.path.dirname(__file__), ".cache")
         self.align_eyes = align_eyes
         self.extract = Extract()
@@ -90,19 +87,11 @@ class Aligner():
         detected_faces = output["detected_faces"]
         image = output["image"]
 
-        resized_faces = list()
-        t_mats = list()
-
         for face in detected_faces:
-            resized_face, t_mat = self.extract.extract(image,
-                                                       face,
-                                                       self.size,
-                                                       self.align_eyes)
-            resized_faces.append(resized_face)
-            t_mats.append(t_mat)
-
-        output["resized_faces"] = resized_faces
-        output["t_mats"] = t_mats
+            face.load_aligned(image,
+                              size=self.size,
+                              padding=self.padding,
+                              align_eyes=self.align_eyes)
 
     # <<< MISC METHODS >>> #
     def get_vram_free(self):
@@ -115,82 +104,3 @@ class Aligner():
                 int(vram["free"]),
                 int(vram["total"])))
         return int(vram["card_id"]), int(vram["free"]), int(vram["total"])
-
-
-class Extract():
-    """ Based on the original https://www.reddit.com/r/deepfakes/
-        code sample + contribs """
-
-    def extract(self, image, face, size, align_eyes):
-        """ Extract a face from an image """
-        alignment = get_align_mat(face, size, align_eyes)
-        extracted = self.transform(image, alignment, size, 48)
-        return extracted, alignment
-
-    @staticmethod
-    def transform(image, mat, size, padding=0):
-        """ Transform Image """
-        matrix = mat * (size - 2 * padding)
-        matrix[:, 2] += padding
-        return cv2.warpAffine(image, matrix, (size, size))
-
-    @staticmethod
-    def transform_points(points, mat, size, padding=0):
-        """ Transform points along matrix """
-        matrix = mat * (size - 2 * padding)
-        matrix[:, 2] += padding
-        points = np.expand_dims(points, axis=1)
-        points = cv2.transform(points, matrix, points.shape)
-        points = np.squeeze(points)
-        return points
-
-    @staticmethod
-    def get_feature_mask(aligned_landmarks_68, size,
-                         padding=0, dilation=30):
-        """ Return the face feature mask """
-        scale = size - 2*padding
-        translation = padding
-        pad_mat = np.matrix([[scale, 0.0, translation],
-                             [0.0, scale, translation]])
-        aligned_landmarks_68 = np.expand_dims(aligned_landmarks_68, axis=1)
-        aligned_landmarks_68 = cv2.transform(aligned_landmarks_68,
-                                             pad_mat,
-                                             aligned_landmarks_68.shape)
-        aligned_landmarks_68 = np.squeeze(aligned_landmarks_68)
-
-        (l_start, l_end) = FACIAL_LANDMARKS_IDXS["left_eye"]
-        (r_start, r_end) = FACIAL_LANDMARKS_IDXS["right_eye"]
-        (m_start, m_end) = FACIAL_LANDMARKS_IDXS["mouth"]
-        (n_start, n_end) = FACIAL_LANDMARKS_IDXS["nose"]
-        (lb_start, lb_end) = FACIAL_LANDMARKS_IDXS["left_eyebrow"]
-        (rb_start, rb_end) = FACIAL_LANDMARKS_IDXS["right_eyebrow"]
-        (c_start, c_end) = FACIAL_LANDMARKS_IDXS["chin"]
-
-        l_eye_points = aligned_landmarks_68[l_start:l_end].tolist()
-        l_brow_points = aligned_landmarks_68[lb_start:lb_end].tolist()
-        r_eye_points = aligned_landmarks_68[r_start:r_end].tolist()
-        r_brow_points = aligned_landmarks_68[rb_start:rb_end].tolist()
-        nose_points = aligned_landmarks_68[n_start:n_end].tolist()
-        chin_points = aligned_landmarks_68[c_start:c_end].tolist()
-        mouth_points = aligned_landmarks_68[m_start:m_end].tolist()
-        l_eye_points = l_eye_points + l_brow_points
-        r_eye_points = r_eye_points + r_brow_points
-        mouth_points = mouth_points + nose_points + chin_points
-
-        l_eye_hull = cv2.convexHull(np.array(l_eye_points).reshape(
-            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
-        r_eye_hull = cv2.convexHull(np.array(r_eye_points).reshape(
-            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
-        mouth_hull = cv2.convexHull(np.array(mouth_points).reshape(
-            (-1, 2)).astype(int)).flatten().reshape((-1, 2))
-
-        mask = np.zeros((size, size, 3), dtype=float)
-        cv2.fillConvexPoly(mask, l_eye_hull, (1, 1, 1))
-        cv2.fillConvexPoly(mask, r_eye_hull, (1, 1, 1))
-        cv2.fillConvexPoly(mask, mouth_hull, (1, 1, 1))
-
-        if dilation > 0:
-            kernel = np.ones((dilation, dilation), np.uint8)
-            mask = cv2.dilate(mask, kernel, iterations=1)
-
-        return mask
diff --git a/plugins/extract/detect/_base.py b/plugins/extract/detect/_base.py
index 47fc2f8..7114319 100644
--- a/plugins/extract/detect/_base.py
+++ b/plugins/extract/detect/_base.py
@@ -99,12 +99,15 @@ class Detector():
             and add the cropped face """
         retval = list()
         for d_rect in dlib_rects:
-            if not isinstance(d_rect, dlib.rectangle):
+            if not isinstance(
+                    d_rect,
+                    dlib.rectangle):  # pylint: disable=c-extension-no-member
                 retval.append(list())
                 continue
             detected_face = DetectedFace()
             detected_face.from_dlib_rect(d_rect)
             detected_face.image_to_face(image)
+            detected_face.frame_dims = image.shape[:2]
             retval.append(detected_face)
         return retval
 
@@ -136,6 +139,7 @@ class Detector():
 
     def set_detect_image(self, input_image):
         """ Convert the image to RGB and scale """
+        # pylint: disable=no-member
         image = input_image[:, :, ::-1].copy()
         if self.scale == 1.0:
             return image
@@ -220,7 +224,9 @@ class Detector():
     def is_mmod_rectangle(d_rectangle):
         """ Return whether the passed in object is
             a dlib.mmod_rectangle """
-        return isinstance(d_rectangle, dlib.mmod_rectangle)
+        return isinstance(
+            d_rectangle,
+            dlib.mmod_rectangle)  # pylint: disable=c-extension-no-member
 
     def convert_to_dlib_rectangle(self, d_rect):
         """ Convert detected mmod_rects to dlib_rectangle """
@@ -247,4 +253,5 @@ class Detector():
         # Landmarks should not be extracted again from predetected faces,
         # because face data is lost, resulting in a large variance
         # against extract from original image
-        return [dlib.rectangle(0, 0, width, height)]
+        return [dlib.rectangle(  # pylint: disable=c-extension-no-member
+            0, 0, width, height)]
diff --git a/scripts/convert.py b/scripts/convert.py
index 6b4fb54..73e8239 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -29,8 +29,8 @@ class Convert():
         self.images = Images(self.args)
         self.alignments = Alignments(self.args, False)
 
-        # Legacy rotation conversion
-        Rotate(self.alignments, self.args.verbose, self.images.input_images)
+        # Update Legacy alignments
+        Legacy(self.alignments, self.args.verbose, self.images.input_images)
 
         self.post_process = PostProcess(arguments)
         self.verify_output = False
@@ -180,7 +180,7 @@ class Convert():
         if not self.check_alignments(frame):
             return None
 
-        faces = self.alignments.get_alignments_for_frame(frame)
+        faces = self.alignments.get_faces_in_frame(frame)
         image = self.images.load_one_image(filename)
         detected_faces = list()
 
@@ -209,7 +209,7 @@ class Convert():
                     image = self.convert_one_face(converter,
                                                   (filename, image, idx, face))
                 filename = str(self.output_dir / Path(filename).name)
-                cv2.imwrite(filename, image)
+                cv2.imwrite(filename, image)  # pylint: disable=no-member
         except Exception as err:
             print("Failed to convert image: {}. "
                   "Reason: {}".format(filename, err))
@@ -309,8 +309,11 @@ class OptionalActions():
         return skip_face
 
 
-class Rotate():
-    """ Rotate landmarks and bounding boxes on legacy alignments
+class Legacy():
+    """ Update legacy alignments:
+
+        - Add frame dimensions
+        - Rotate landmarks and bounding boxes on legacy alignments
         and remove the 'r' parameter """
     def __init__(self, alignments, verbose, frames):
         self.verbose = verbose
@@ -321,19 +324,30 @@ class Rotate():
 
     def process(self):
         """ Run the rotate alignments process """
-        rotated = self.alignments.get_legacy_frames()
-        if not rotated:
+        no_dims = self.alignments.get_legacy_no_dims()
+        rotated = self.alignments.get_legacy_rotation()
+        if not no_dims and not rotated:
             return
-        print("Legacy rotated frames found. Converting...")
-        self.rotate_landmarks(rotated)
+        if no_dims:
+            print("Legacy landmarks found. Adding frame dimensions...")
+            self.add_dimensions(no_dims)
+        if rotated:
+            print("Legacy rotated frames found. Converting...")
+            self.rotate_landmarks(rotated)
         self.alignments.save()
 
+    def add_dimensions(self, no_dims):
+        """ Add width and height of original frame to alignments """
+        for no_dim in tqdm(no_dims, desc="Adding Frame Dimensions"):
+            if no_dim not in self.frames.keys():
+                continue
+            filename = self.frames[no_dim]
+            dims = cv2.imread(filename).shape[:2]  # pylint: disable=no-member
+            self.alignments.add_dimensions(no_dim, dims)
+
     def rotate_landmarks(self, rotated):
         """ Rotate the landmarks """
-        for rotate_item in tqdm(rotated,
-                                desc="Rotating Landmarks"):
+        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
             if rotate_item not in self.frames.keys():
                 continue
-            filename = self.frames[rotate_item]
-            dims = cv2.imread(filename).shape[:2]
-            self.alignments.rotate_existing_landmarks(rotate_item, dims)
+            self.alignments.rotate_existing_landmarks(rotate_item)
diff --git a/scripts/extract.py b/scripts/extract.py
index a041932..a1bb0ed 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -47,7 +47,7 @@ class Extract():
         self.run_extraction(save_thread)
         self.alignments.save()
         Utils.finalize(self.images.images_found,
-                       self.alignments.faces_count(),
+                       self.alignments.faces_count,
                        self.verify_output)
 
     def threaded_io(self, task, io_args=None):
@@ -188,13 +188,12 @@ class Extract():
 
         filename = faces["filename"]
         output_file = faces["output_file"]
-        resized_faces = faces["resized_faces"]
 
         for idx, face in enumerate(faces["detected_faces"]):
             if self.export_face:
                 save_queue.put((filename,
                                 output_file,
-                                resized_faces[idx],
+                                face.aligned_face,
                                 idx))
 
             final_faces.append(face.to_alignment())
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index f48338d..120f6fd 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -11,12 +11,12 @@ from pathlib import Path
 import cv2
 import numpy as np
 
-from lib import Serializer
+from lib.aligner import Extract as AlignerExtract
+from lib.alignments import Alignments as AlignmentsBase
 from lib.detect_blur import is_blurry
 from lib.FaceFilter import FaceFilter as FilterFunc
 from lib.utils import (camel_case_split, get_folder, get_image_paths,
-                       rotate_landmarks, set_system_verbosity)
-from plugins.extract.align._base import Extract as AlignerExtract
+                       set_system_verbosity)
 
 
 class Utils():
@@ -46,76 +46,64 @@ class Utils():
         print("Done!")
 
 
-class Alignments():
-    """ Holds processes pertaining to the alignments file """
+class Alignments(AlignmentsBase):
+    """ Override main alignments class for extract """
     def __init__(self, arguments, is_extract):
-        self.is_extract = is_extract
         self.args = arguments
-        self.serializer = self.get_serializer()
-        self.location = self.get_location()
-        self.have_alignments_file = os.path.exists(self.location)
-        self.data = self.load()
-
-    def frames_count(self):
-        """ Return current frames count """
-        return len(self.data)
-
-    def faces_count(self):
-        """ Return current faces count """
-        return sum(len(faces) for faces in self.data.values())
+        self.is_extract = is_extract
+        folder, filename = self.set_folder_filename()
+        serializer = self.set_serializer()
+        super().__init__(folder,
+                         filename=filename,
+                         serializer=serializer,
+                         verbose=self.args.verbose)
+
+    def set_folder_filename(self):
+        """ Return the folder for the alignments file"""
+        if self.args.alignments_path:
+            folder, filename = os.path.split(str(self.args.alignments_path))
+        else:
+            folder = str(self.args.input_dir)
+            filename = "alignments"
+        return folder, filename
 
-    def get_serializer(self):
+    def set_serializer(self):
         """ Set the serializer to be used for loading and
             saving alignments """
-        if (not hasattr(self.args, "serializer")
-                or not self.args.serializer):
-            if self.args.alignments_path:
-                ext = os.path.splitext(self.args.alignments_path)[-1]
-            else:
-                ext = "json"
-            serializer = Serializer.get_serializer_from_ext(ext)
+        if hasattr(self.args, "serializer") and self.args.serializer:
+            serializer = self.args.serializer
         else:
-            serializer = Serializer.get_serializer(self.args.serializer)
-        print("Using {} serializer".format(serializer.ext))
+            # If there is a full filename then this will be overriden
+            # by filename extension
+            serializer = "json"
         return serializer
 
-    def get_location(self):
-        """ Return the path to alignments file """
-        if self.args.alignments_path:
-            alignfile = self.args.alignments_path
-        else:
-            alignfile = os.path.join(
-                str(self.args.input_dir),
-                "alignments.{}".format(self.serializer.ext))
-        print("Alignments filepath: %s" % alignfile)
-        return alignfile
-
     def load(self):
-        """ Load the alignments data if it exists or create empty dict """
+        """ Override  parent loader to handle skip existing on extract """
         data = dict()
-        skip_faces = None
-        if self.is_extract:
-            skip_existing = bool(hasattr(self.args, 'skip_existing')
-                                 and self.args.skip_existing)
-            skip_faces = bool(hasattr(self.args, 'skip_faces')
-                              and self.args.skip_faces)
-
-            if not self.have_alignments_file:
-                if skip_existing or skip_faces:
-                    print("Skip Existing/Skip Faces selected, but no "
-                          "alignments file found!")
-                return data
-            if not skip_existing and not skip_faces:
-                return data
+        if not self.is_extract:
+            data = super().load()
+            return data
+
+        skip_existing = bool(hasattr(self.args, 'skip_existing')
+                             and self.args.skip_existing)
+        skip_faces = bool(hasattr(self.args, 'skip_faces')
+                          and self.args.skip_faces)
+
+        if not skip_existing and not skip_faces:
+            return data
+
+        if not self.have_alignments_file and (skip_existing or skip_faces):
+            print("Skip Existing/Skip Faces selected, but no alignments file "
+                  "found!")
+            return data
 
         try:
-            with open(self.location, self.serializer.roptions) as align:
+            with open(self.file, self.serializer.roptions) as align:
                 data = self.serializer.unmarshal(align.read())
-
-        except Exception as err:
-            print("{} not read!".format(self.location))
-            print(str(err))
-            data = dict()
+        except IOError as err:
+            print("Error: {} not read: {}".format(self.file, err.strerror))
+            exit(1)
 
         if skip_faces:
             # Remove items from algnments that have no faces so they will
@@ -124,63 +112,8 @@ class Alignments():
             for key in del_keys:
                 if key in data:
                     del data[key]
-
         return data
 
-    def save(self):
-        """ Write the serialized alignments file """
-        try:
-            print("Writing alignments to: {}".format(self.location))
-            with open(self.location, self.serializer.woptions) as align:
-                align.write(self.serializer.marshal(self.data))
-        except Exception as err:
-            print("{} not written!".format(self.location))
-            print(str(err))
-
-    def frame_exists(self, frame):
-        """ return path of images that have faces """
-        return frame in self.data.keys()
-
-    def get_alignments_for_frame(self, frame):
-        """ Return the alignments for the selected frame """
-        return self.data.get(frame, list())
-
-    def get_legacy_frames(self):
-        """ Return a list of frames with legacy rotations """
-        keys = list()
-        for key, val in self.data.items():
-            if any(alignment.get("r", None) for alignment in val):
-                keys.append(key)
-        return keys
-
-    def rotate_existing_landmarks(self, frame, dimensions):
-        """ Backwards compatability fix. Rotates the landmarks to
-            their correct position and deletes r """
-        for face in self.get_alignments_for_frame(frame):
-            angle = face.get("r", 0)
-            if not angle:
-                return
-            rotation_matrix = self.get_original_rotation_matrix(dimensions,
-                                                                angle)
-            rotate_landmarks(face, rotation_matrix)
-            del face["r"]
-
-    @staticmethod
-    def get_original_rotation_matrix(dimensions, angle):
-        """ Calculate original rotation matrix and invert """
-        height, width = dimensions
-        center = (width/2, height/2)
-        rotation_matrix = cv2.getRotationMatrix2D(center, -1.0*angle, 1.)
-
-        abs_cos = abs(rotation_matrix[0, 0])
-        abs_sin = abs(rotation_matrix[0, 1])
-        rotated_width = int(height*abs_sin + width*abs_cos)
-        rotated_height = int(height*abs_cos + width*abs_sin)
-        rotation_matrix[0, 2] += rotated_width/2 - center[0]
-        rotation_matrix[1, 2] += rotated_height/2 - center[1]
-
-        return rotation_matrix
-
 
 class Images():
     """ Holds the full frames/images """
@@ -203,12 +136,12 @@ class Images():
     def load(self):
         """ Load an image and yield it with it's filename """
         for filename in self.input_images:
-            yield filename, cv2.imread(filename)
+            yield filename, cv2.imread(filename)  # pylint: disable=no-member
 
     @staticmethod
     def load_one_image(filename):
         """ load requested image """
-        return cv2.imread(filename)
+        return cv2.imread(filename)  # pylint: disable=no-member
 
 
 class PostProcess():
@@ -298,20 +231,16 @@ class BlurryFaceFilter(PostProcessAction):
         """ Detect and move blurry face """
         extractor = AlignerExtract()
 
-        for idx, face in enumerate(output_item["detected_faces"]):
-            resized_face = output_item["resized_faces"][idx]
-            dims = resized_face.shape[:2]
-            size = dims[0]
-            t_mat = output_item["t_mats"][idx]
-
-            aligned_landmarks = extractor.transform_points(
-                face.landmarksXY,
-                t_mat, size, 48)
+        for face in output_item["detected_faces"]:
+            aligned_landmarks = face.aligned_landmarks
+            resized_face = face.aligned_face
+            size = face.aligned["size"]
             feature_mask = extractor.get_feature_mask(
                 aligned_landmarks / size,
                 size, 48)
-            feature_mask = cv2.blur(feature_mask, (10, 10))
-            isolated_face = cv2.multiply(
+            feature_mask = cv2.blur(  # pylint: disable=no-member
+                feature_mask, (10, 10))
+            isolated_face = cv2.multiply(  # pylint: disable=no-member
                 feature_mask,
                 resized_face.astype(float)).astype(np.uint8)
             blurry, focus_measure = is_blurry(isolated_face, self.blur_thresh)
@@ -333,17 +262,12 @@ class DebugLandmarks(PostProcessAction):
 
     def process(self, output_item):
         """ Draw landmarks on image """
-        transform_points = AlignerExtract().transform_points
-        for idx, face in enumerate(output_item["detected_faces"]):
-            dims = output_item["resized_faces"][idx].shape[:2]
-            size = dims[0]
-            landmarks = transform_points(face.landmarksXY,
-                                         output_item["t_mats"][idx],
-                                         size,
-                                         48)
-            for (pos_x, pos_y) in landmarks:
-                cv2.circle(output_item["resized_faces"][idx],
-                           (pos_x, pos_y), 2, (0, 0, 255), -1)
+        for face in output_item["detected_faces"]:
+            aligned_landmarks = face.aligned_landmarks
+            for (pos_x, pos_y) in aligned_landmarks:
+                cv2.circle(  # pylint: disable=no-member
+                    face.aligned_face,
+                    (pos_x, pos_y), 2, (0, 0, 255), -1)
 
 
 class FaceFilter(PostProcessAction):
diff --git a/tools/alignments.py b/tools/alignments.py
index 87ac4ff..5e71437 100644
--- a/tools/alignments.py
+++ b/tools/alignments.py
@@ -3,8 +3,8 @@
 
 # TODO merge alignments
 from lib.utils import set_system_verbosity
-from .lib_alignments import (AlignmentData, Check, Draw, Extract, Manual,
-                             Reformat, RemoveAlignments, Rotate, Sort, Spatial)
+from .lib_alignments import (AlignmentData, Check, Draw, Extract, Legacy,
+                             Manual, Reformat, RemoveAlignments, Sort, Spatial)
 
 
 class Alignments():
diff --git a/tools/cli.py b/tools/cli.py
index 46d07c5..1c4b87e 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -24,10 +24,10 @@ class AlignmentsArgs(FaceSwapArgs):
             "opts": ("-j", "--job"),
             "type": str,
             "choices": ("draw", "extract", "extract-large", "manual",
-                        "missing-alignments", "missing-frames",
+                        "missing-alignments", "missing-frames", "legacy",
                         "leftover-faces", "multi-faces", "no-faces",
                         "reformat", "remove-faces", "remove-frames",
-                        "rotate", "sort-x", "sort-y", "spatial"),
+                        "sort-x", "sort-y", "spatial"),
             "required": True,
             "help": "R|Choose which action you want to perform.\n"
                     "NB: All actions require an alignments file (-a) to"
@@ -51,6 +51,9 @@ class AlignmentsArgs(FaceSwapArgs):
                     "\n'missing-frames': Identify frames in the alignments"
                     "\n\tfile that do not appear within the frames"
                     "\n\tfolder." + output_opts + frames_dir +
+                    "\n'legacy': This updates legacy alignments to the latest "
+                    "\n\tformat by adding frame dimensions and rotating "
+                    "\n\tthe landmarks and bounding boxes" + frames_dir +
                     "\n'leftover-faces': Identify faces in the faces"
                     "\n\tfolder that do not exist in the alignments file."
                     + output_opts + faces_dir +
@@ -77,14 +80,6 @@ class AlignmentsArgs(FaceSwapArgs):
                     "\n\twill be backed up. A different file format for"
                     "\n\tthe alignments file can optionally be specified"
                     "\n\t(-fmt)." + frames_dir +
-                    "\n'rotate' - Rotate landmarks and bounding boxes. Legacy"
-                    "\n\talignments files hold an 'r' parameter indicating"
-                    "\n\tthat the image needs to be rotated for convert. This"
-                    "\n\tmeans that the stored landarks and bounding box do"
-                    "\n\tnot correspond to the actual frame. This command"
-                    "\n\tupdates the alignments file with the correct"
-                    "\n\tlandmarks and bounding boxes and removes the 'r'"
-                    "\n\tparameter." + frames_dir +
                     "\n'sort-x' - Re-index the alignments from left to"
                     "\n\tright. For alignments with multiple faces this will"
                     "\n\tensure that the left-most face is at index 0"
diff --git a/tools/lib_alignments/__init__.py b/tools/lib_alignments/__init__.py
index 74057b2..15e6b1b 100644
--- a/tools/lib_alignments/__init__.py
+++ b/tools/lib_alignments/__init__.py
@@ -1,4 +1,4 @@
 from tools.lib_alignments.media import AlignmentData, ExtractedFaces, Faces, Frames
 from tools.lib_alignments.annotate import Annotate
-from tools.lib_alignments.jobs import Check, Draw, Extract, Reformat, RemoveAlignments, Rotate, Sort, Spatial
+from tools.lib_alignments.jobs import Check, Draw, Extract, Legacy, Reformat, RemoveAlignments, Sort, Spatial
 from tools.lib_alignments.jobs_manual import Manual
diff --git a/tools/lib_alignments/annotate.py b/tools/lib_alignments/annotate.py
index 654a216..4084bd1 100644
--- a/tools/lib_alignments/annotate.py
+++ b/tools/lib_alignments/annotate.py
@@ -1,9 +1,9 @@
 #!/usr/bin/env python3
 """ Tools for annotating an input image """
-# TODO Handle landmark rotation
 
-from cv2 import (rectangle, circle, polylines, putText,
-                 FONT_HERSHEY_DUPLEX, fillPoly, addWeighted)
+from cv2 import (  # pylint: disable=no-name-in-module
+    rectangle, circle, polylines, putText,
+    FONT_HERSHEY_DUPLEX, fillPoly, addWeighted)
 from numpy import array, int32, uint8, zeros
 
 from lib.align_eyes import FACIAL_LANDMARKS_IDXS
@@ -44,11 +44,11 @@ class Annotate():
             return
         color = self.colors[color_id]
         for idx, roi in enumerate(self.roi):
-            top_left = [point for point in roi[0].squeeze()[0]]
+            top_left = [point for point in roi.squeeze()[0]]
             top_left = (top_left[0], top_left[1] - 10)
             putText(self.image, str(idx), top_left, FONT_HERSHEY_DUPLEX, 1.0,
                     color, thickness)
-            polylines(self.image, roi, True, color, thickness)
+            polylines(self.image, [roi], True, color, thickness)
 
     def draw_landmarks(self, color_id=3, radius=1):
         """ Draw the facial landmarks """
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index b9b175d..3bce55d 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -108,7 +108,7 @@ class Check():
         for frame in tqdm(self.items, total=len(self.items)):
             frame_name = frame["frame_fullname"]
             if (frame["frame_extension"] not in exclude_filetypes
-                    and not self.alignments.frame_in_alignments(frame_name)):
+                    and not self.alignments.frame_exists(frame_name)):
                 yield frame_name
 
     def get_missing_frames(self):
@@ -116,8 +116,8 @@ class Check():
             not have a matching file """
         self.output_message = "Missing frames that are in alignments file"
         frames = [item["frame_fullname"] for item in self.items]
-        for frame in tqdm(self.alignments.alignments.keys(),
-                          total=len(self.alignments.count)):
+        for frame in tqdm(self.alignments.data.keys(),
+                          total=len(self.alignments.frames_count)):
             if frame not in frames:
                 yield frame
 
@@ -126,7 +126,7 @@ class Check():
         self.output_message = "Faces missing from the alignments file"
         for face in tqdm(self.items, total=len(self.items)):
             frame = self.alignments.get_full_frame_name(face["frame_name"])
-            alignment_faces = self.alignments.count_alignments_in_frame(frame)
+            alignment_faces = self.alignments.count_faces_in_frame(frame)
 
             if alignment_faces <= face["face_index"]:
                 yield face["face_fullname"]
@@ -214,9 +214,9 @@ class Draw():
 
     def process(self):
         """ Run the draw alignments process """
-        rotate = Rotate(self.alignments, self.arguments,
+        legacy = Legacy(self.alignments, self.arguments,
                         frames=self.frames, child_process=True)
-        rotate.process()
+        legacy.process()
 
         print("\n[DRAW LANDMARKS]")  # Tidy up cli output
         self.extracted_faces = ExtractedFaces(
@@ -229,7 +229,7 @@ class Draw():
 
             frame_name = frame["frame_fullname"]
 
-            if not self.alignments.frame_in_alignments(frame_name):
+            if not self.alignments.frame_exists(frame_name):
                 if self.verbose:
                     print("Skipping {} - Alignments "
                           "not found".format(frame_name))
@@ -241,10 +241,11 @@ class Draw():
 
     def annotate_image(self, frame):
         """ Draw the alignments """
-        alignments = self.alignments.get_alignments_for_frame(frame)
+        alignments = self.alignments.get_faces_in_frame(frame)
         image = self.frames.load_image(frame)
-        original_roi = self.extracted_faces.get_roi_for_frame(frame)
-
+        self.extracted_faces.get_faces_in_frame(frame)
+        original_roi = [face.original_roi
+                        for face in self.extracted_faces.faces]
         annotate = Annotate(image, alignments, original_roi)
         annotate.draw_bounding_box(1, 1)
         annotate.draw_extract_box(2, 1)
@@ -298,7 +299,7 @@ class Extract():
 
             frame_name = frame["frame_fullname"]
 
-            if not self.alignments.frame_in_alignments(frame_name):
+            if not self.alignments.frame_exists(frame_name):
                 if self.verbose:
                     print("Skipping {} - Alignments "
                           "not found".format(frame_name))
@@ -322,7 +323,7 @@ class Extract():
 
     def select_valid_faces(self, frame):
         """ Return valid faces for extraction """
-        faces = self.extracted_faces.get_faces_for_frame(frame)
+        faces = self.extracted_faces.get_faces_in_frame(frame)
         if self.type != "large":
             return faces
         valid_faces = list()
@@ -338,7 +339,7 @@ class Reformat():
     def __init__(self, alignments, arguments):
         self.verbose = arguments.verbose
         self.alignments = alignments
-        if self.alignments.src_format == "dfl":
+        if self.alignments.file == "dfl":
             self.faces = Faces(arguments.faces_dir,
                                self.verbose,
                                dfl=True)
@@ -346,11 +347,12 @@ class Reformat():
     def process(self):
         """ Run reformat """
         print("\n[REFORMAT ALIGNMENTS]")  # Tidy up cli output
-        if self.alignments.src_format == "dfl":
-            self.alignments.alignments = self.load_dfl()
-            self.alignments.file = os.path.join(self.faces.folder,
-                                                "alignments.json")
-        self.alignments.save_alignments()
+        if self.alignments.file == "dfl":
+            self.alignments.data = self.load_dfl()
+            self.alignments.file = self.alignments.get_location(
+                self.faces.folder,
+                "alignments")
+        self.alignments.save()
 
     def load_dfl(self):
         """ Load alignments from DeepFaceLab and format for Faceswap """
@@ -433,13 +435,13 @@ class RemoveAlignments():
         print("\n[REMOVE ALIGNMENTS DATA]")  # Tidy up cli output
         del_count = 0
 
-        iterator = self.alignments.get_alignments_one_image
+        iterator = self.alignments.yield_faces
         if self.type == "frames":
             iterator = list(item[3] for item in iterator())
 
         for item in tqdm(iterator() if self.type == "faces" else iterator,
                          desc="Processing alignments file",
-                         total=self.alignments.count):
+                         total=self.alignments.frames_count):
             task = getattr(self, "remove_{}".format(self.type))
             del_count += task(item)
 
@@ -449,7 +451,7 @@ class RemoveAlignments():
 
         print("{} alignment(s) were removed from "
               "alignments file".format(del_count))
-        self.alignments.save_alignments()
+        self.alignments.save()
 
         if self.type == "faces":
             self.rename_faces()
@@ -458,7 +460,7 @@ class RemoveAlignments():
         """ Process to remove frames from an alignments file """
         if item in self.items:
             return 0
-        del self.alignments.alignments[item]
+        del self.alignments.data[item]
         return 1
 
     def remove_faces(self, item):
@@ -477,7 +479,7 @@ class RemoveAlignments():
         """ Remove the alignment from the alignments file """
         del_count = 0
         frame_name, alignments, number_alignments = item[:3]
-        processor = self.alignments.get_one_alignment_index_reverse
+        processor = self.alignments.yield_original_index_reverse
         for idx in processor(alignments, number_alignments):
             face_indexes = self.items.items.get(frame_name, [-1])
             if idx not in face_indexes:
@@ -537,9 +539,13 @@ class RemoveAlignments():
         return 1
 
 
-class Rotate():
-    """ Rotating landmarks and bounding boxes on legacy alignments
+class Legacy():
+    """ Update legacy alignments:
+
+        - Add frame dimensions
+        - Rotate landmarks and bounding boxes on legacy alignments
         and remove the 'r' parameter """
+
     def __init__(self, alignments, arguments,
                  frames=None, child_process=False):
         self.verbose = arguments.verbose
@@ -551,24 +557,38 @@ class Rotate():
 
     def process(self):
         """ Run the rotate alignments process """
-        rotated = self.alignments.get_rotated()
-        if not rotated and self.child_process:
+        no_dims = self.alignments.get_legacy_no_dims()
+        rotated = self.alignments.get_legacy_rotation()
+        if self.child_process and not rotated and not no_dims:
             return
-        print("\n[ROTATE LANDMARKS]")  # Tidy up cli output
-        if self.child_process:
-            print("Legacy rotated frames found. Rotating landmarks")
-        self.rotate_landmarks(rotated)
-        if not self.child_process:
-            self.alignments.save_alignments()
+        print("\n[UPDATE LEGACY LANDMARKS]")  # Tidy up cli output
+
+        if no_dims:
+            if self.child_process:
+                print("Legacy landmarks found. Adding frame dimensions...")
+            self.add_dimensions(no_dims)
+
+        if rotated:
+            if self.child_process:
+                print("Legacy rotated frames found. Rotating landmarks")
+            self.rotate_landmarks(rotated)
+
+        self.alignments.save()
+
+    def add_dimensions(self, no_dims):
+        """ Add width and height of original frame to alignments """
+        for no_dim in tqdm(no_dims, desc="Adding Frame Dimensions"):
+            if no_dim not in self.frames.items.keys():
+                continue
+            dims = self.frames.load_image(no_dim).shape[:2]
+            self.alignments.add_dimensions(no_dim, dims)
 
     def rotate_landmarks(self, rotated):
         """ Rotate the landmarks """
-        for rotate_item in tqdm(rotated,
-                                desc="Rotating Landmarks"):
+        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
             if rotate_item not in self.frames.items.keys():
                 continue
-            dims = self.frames.load_image(rotate_item).shape[:2]
-            self.alignments.rotate_existing_landmarks(rotate_item, dims)
+            self.alignments.rotate_existing_landmarks(rotate_item)
 
 
 class Sort():
@@ -592,13 +612,13 @@ class Sort():
         print("\n[SORT INDEXES]")  # Tidy up cli output
         self.check_rotated()
         self.reindex_faces()
-        self.alignments.save_alignments()
+        self.alignments.save()
 
     def check_rotated(self):
         """ Legacy rotated alignments will not have the correct x, y
             positions, so generate a warning and exit """
         if any(alignment.get("r", None)
-               for val in self.alignments.alignments.values()
+               for val in self.alignments.data.values()
                for alignment in val):
             print("WARNING: There are rotated frames in the alignments "
                   "file.\n\t Position of faces will not be correctly "
@@ -611,9 +631,9 @@ class Sort():
     def reindex_faces(self):
         """ Re-Index the faces """
         reindexed = 0
-        for alignment in tqdm(self.alignments.get_alignments_one_image(),
+        for alignment in tqdm(self.alignments.yield_faces(),
                               desc="Sort alignment indexes",
-                              total=self.alignments.count):
+                              total=self.alignments.frames_count):
             frame, alignments, count, key = alignment
             if count <= 1:
                 continue
@@ -625,7 +645,7 @@ class Sort():
                                             sorted_alignments,
                                             frame)
             self.rename_faces(map_faces)
-            self.alignments.alignments[key] = sorted_alignments
+            self.alignments.data[key] = sorted_alignments
             reindexed += 1
         print("{} Frames had their faces reindexed".format(reindexed))
 
@@ -695,7 +715,7 @@ class Spatial():
         landmarks = self.spatially_filter()
         landmarks = self.temporally_smooth(landmarks)
         self.update_alignments(landmarks)
-        self.alignments.save_alignments()
+        self.alignments.save()
 
         print("\nDone! To re-extract faces run:\n    python tools.py "
               "alignments -j extract -a {} -fr <path_to_frames_dir> -fc "
@@ -737,13 +757,13 @@ class Spatial():
 
     def normalize(self):
         """ Compile all original and normalized alignments """
-        count = sum(1 for val in self.alignments.alignments.values() if val)
+        count = sum(1 for val in self.alignments.data.values() if val)
         landmarks_all = np.zeros((68, 2, int(count)))
 
         end = 0
-        for key in tqdm(sorted(self.alignments.alignments.keys()),
+        for key in tqdm(sorted(self.alignments.data.keys()),
                         desc="Compiling"):
-            val = self.alignments.alignments[key]
+            val = self.alignments.data[key]
             if not val:
                 continue
             # We should only be normalizing a single face, so just take
@@ -816,4 +836,4 @@ class Spatial():
         for idx, frame in tqdm(self.mappings.items(), desc="Updating"):
             landmarks_update = landmarks[:, :, idx].astype(int)
             landmarks_xy = landmarks_update.reshape(68, 2).tolist()
-            self.alignments.alignments[frame][0]["landmarksXY"] = landmarks_xy
+            self.alignments.data[frame][0]["landmarksXY"] = landmarks_xy
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
index 54ac51e..d940369 100644
--- a/tools/lib_alignments/jobs_manual.py
+++ b/tools/lib_alignments/jobs_manual.py
@@ -9,7 +9,7 @@ import numpy as np
 from lib.multithreading import SpawnProcess
 from lib.queue_manager import queue_manager, QueueEmpty
 from plugins.plugin_loader import PluginLoader
-from . import Annotate, ExtractedFaces, Frames, Rotate
+from . import Annotate, ExtractedFaces, Frames, Legacy
 
 
 class Interface():
@@ -149,7 +149,7 @@ class Interface():
         """ Save alignments """
         if not self.state["edit"]["updated"]:
             return
-        self.alignments.save_alignments()
+        self.alignments.save()
         self.state["edit"]["updated"] = False
         self.set_redraw(True)
 
@@ -168,7 +168,7 @@ class Interface():
         if self.get_edit_mode() == "View" or selected_face is None:
             return
         frame = self.get_frame_name()
-        if self.alignments.delete_alignment_at_index(frame, selected_face):
+        if self.alignments.delete_face_at_index(frame, selected_face):
             self.state["edit"]["selected"] = None
             self.state["edit"]["updated"] = True
             self.state["edit"]["update_faces"] = True
@@ -184,9 +184,9 @@ class Interface():
             return
         current_frame = self.get_frame_name()
         get_frame = self.frames.file_list_sorted[frame_id]["frame_fullname"]
-        alignments = self.alignments.get_alignments_for_frame(get_frame)
+        alignments = self.alignments.get_faces_in_frame(get_frame)
         for alignment in alignments:
-            self.alignments. add_alignment(current_frame, alignment)
+            self.alignments. add_face(current_frame, alignment)
         self.state["edit"]["updated"] = True
         self.state["edit"]["update_faces"] = True
         self.set_redraw(True)
@@ -402,9 +402,9 @@ class Manual():
 
     def process(self):
         """ Process manual extraction """
-        rotate = Rotate(self.alignments, self.arguments,
+        legacy = Legacy(self.alignments, self.arguments,
                         frames=self.frames, child_process=True)
-        rotate.process()
+        legacy.process()
 
         print("\n[MANUAL PROCESSING]")  # Tidy up cli output
         self.extracted_faces = ExtractedFaces(self.frames,
@@ -502,15 +502,16 @@ class Manual():
         """ Compile the frame and get faces """
         image = self.frame_selector()
         frame_name = self.interface.get_frame_name()
-        alignments = self.alignments.get_alignments_for_frame(frame_name)
+        alignments = self.alignments.get_faces_in_frame(frame_name)
         faces_updated = self.interface.state["edit"]["update_faces"]
-        roi = self.extracted_faces.get_roi_for_frame(frame_name,
-                                                     faces_updated)
+        self.extracted_faces.get_faces(frame_name)
+        roi = [face.original_roi for face in self.extracted_faces.faces]
+
         if faces_updated:
             self.interface.state["edit"]["update_faces"] = False
 
         frame = FrameDisplay(image, alignments, roi, self.interface).image
-        faces = self.set_faces(frame_name, alignments).image
+        faces = self.set_faces(frame_name).image
         return frame, faces
 
     def frame_selector(self):
@@ -546,20 +547,15 @@ class Manual():
         navigation["frame_name"] = frame
         return image
 
-    def set_faces(self, frame, alignments):
+    def set_faces(self, frame):
         """ Pass the current frame faces to faces window """
-        extracted = self.extracted_faces
-        size = extracted.size
-
-        faces = extracted.get_faces_for_frame(frame)
-
-        landmarks_xy = [alignment["landmarksXY"] for alignment in alignments]
-        landmarks = [
-            {"landmarksXY": aligned}
-            for aligned
-            in extracted.get_aligned_landmarks_for_frame(frame, landmarks_xy)]
-
-        return FacesDisplay(faces, landmarks, size, self.interface)
+        faces = self.extracted_faces.get_faces_in_frame(frame)
+        landmarks = [{"landmarksXY": face.aligned_landmarks}
+                     for face in self.extracted_faces.faces]
+        return FacesDisplay(faces,
+                            landmarks,
+                            self.extracted_faces.size,
+                            self.interface)
 
 
 class FrameDisplay():
@@ -628,7 +624,7 @@ class FacesDisplay():
     @staticmethod
     def copy_faces(faces):
         """ Copy the extracted faces so as not to save the annotations back """
-        return [face.copy() for face in faces]
+        return [face.aligned_face.copy() for face in faces]
 
     @staticmethod
     def set_full_roi(size):
@@ -717,13 +713,11 @@ class MouseHandler():
 
     def init_extractor(self, verbose):
         """ Initialize FAN """
-        in_queue = queue_manager.get_queue("in")
-        align_queue = queue_manager.get_queue("align")
         out_queue = queue_manager.get_queue("out")
 
-        d_kwargs = {"in_queue": in_queue,
-                    "out_queue": align_queue}
-        a_kwargs = {"in_queue": align_queue,
+        d_kwargs = {"in_queue": queue_manager.get_queue("in"),
+                    "out_queue": queue_manager.get_queue("align")}
+        a_kwargs = {"in_queue": queue_manager.get_queue("align"),
                     "out_queue": out_queue}
         detect_process = SpawnProcess()
         align_process = SpawnProcess()
@@ -824,7 +818,7 @@ class MouseHandler():
         """ Check whether the point clicked is within an existing
             bounding box and set face_id """
         frame = self.media["frame_id"]
-        alignments = self.alignments.get_alignments_for_frame(frame)
+        alignments = self.alignments.get_faces_in_frame(frame)
 
         for idx, alignment in enumerate(alignments):
             left = alignment["x"]
@@ -840,7 +834,7 @@ class MouseHandler():
         """ Set the height and width of bounding box from alignment """
         frame = self.media["frame_id"]
         face_id = self.interface.get_selected_face_id()
-        alignment = self.alignments.get_alignments_for_frame(frame)[face_id]
+        alignment = self.alignments.get_faces_in_frame(frame)[face_id]
         self.dims = (alignment["w"], alignment["h"])
 
     def dims_from_image(self):
@@ -896,22 +890,16 @@ class MouseHandler():
         landmarks = queue_manager.get_queue("out").get()
         if landmarks == "EOF":
             exit(0)
-        face = landmarks["detected_faces"][0]
-        alignment = {"x": face.x,
-                     "w": face.w,
-                     "y": face.y,
-                     "h": face.h,
-                     "landmarksXY": face.landmarksXY}
+        alignment = landmarks["detected_faces"][0].to_alignment()
         frame = self.media["frame_id"]
 
         if self.interface.get_selected_face_id() is None:
-            idx = self.alignments.add_alignment(frame, alignment)
+            idx = self.alignments.add_face(frame, alignment)
             self.interface.set_state_value("edit", "selected", idx)
         else:
-            self.alignments.update_alignment(
-                frame,
-                self.interface.get_selected_face_id(),
-                alignment)
+            self.alignments.update_face(frame,
+                                        self.interface.get_selected_face_id(),
+                                        alignment)
             self.interface.set_redraw(True)
 
         self.interface.state["edit"]["updated"] = True
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index 24e94bb..0403398 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -3,222 +3,81 @@
     for alignments tool """
 
 import os
-from datetime import datetime
 
 import cv2
-import numpy as np
 
-from lib import Serializer
+from lib.alignments import Alignments
 from lib.faces_detect import DetectedFace
-from lib.utils import _image_extensions, rotate_landmarks
-from plugins.extract.align._base import Extract as AlignerExtract
+from lib.utils import _image_extensions
 
 
-class AlignmentData():
+class AlignmentData(Alignments):
     """ Class to hold the alignment data """
 
     def __init__(self, alignments_file, destination_format, verbose):
         print("\n[ALIGNMENT DATA]")  # Tidy up cli output
-        self.file = alignments_file
-        self.verbose = verbose
-
-        self.check_file_exists()
-        self.src_format = self.get_source_format()
-        self.dst_format = self.get_destination_format(destination_format)
-
-        if self.src_format == "dfl":
-            self.set_destination_serializer()
+        folder, filename = self.check_file_exists(alignments_file, verbose)
+        if filename == "dfl":
+            self.set_dfl(verbose, destination_format)
             return
-
-        self.serializer = Serializer.get_serializer_from_ext(
-            self.src_format)
-        self.alignments = self.load()
-        self.count = len(self.alignments)
-
-        self.set_destination_serializer()
+        super().__init__(folder, filename=filename, verbose=verbose)
+        self.set_destination_format(destination_format)
         if self.verbose:
-            print("{} items loaded".format(self.count))
+            print("{} items loaded".format(self.frames_count))
 
-    def check_file_exists(self):
+    @staticmethod
+    def check_file_exists(alignments_file, verbose):
         """ Check the alignments file exists"""
-        if os.path.split(self.file.lower())[1] == "dfl":
-            self.file = "dfl"
-        if self.file.lower() == "dfl":
+        folder, filename = os.path.split(alignments_file)
+        if filename.lower() == "dfl":
+            folder = None
+            filename = "dfl"
             print("Using extracted pngs for alignments")
-            return
-        if not os.path.isfile(self.file):
+        elif not os.path.isfile(alignments_file):
             print("ERROR: alignments file not "
-                  "found at: {}".format(self.file))
+                  "found at: {}".format(alignments_file))
             exit(0)
-        if self.verbose:
-            print("Alignments file exists at {}".format(self.file))
-        return
+        if verbose and folder:
+            print("Alignments file exists at {}".format(alignments_file))
+        return folder, filename
 
-    def get_source_format(self):
-        """ Get the source alignments format """
-        if self.file.lower() == "dfl":
-            return "dfl"
-        return os.path.splitext(self.file)[1].lower()
+    def set_dfl(self, verbose, destination_format):
+        """ Set the alignments for dfl alignments """
+        self.verbose = verbose
+        self.file = "dfl"
+        self.set_destination_format(destination_format)
 
-    def get_destination_format(self, destination_format):
+    def set_destination_format(self, destination_format):
         """ Standardise the destination format to the correct extension """
         extensions = {".json": "json",
                       ".p": "pickle",
                       ".yml": "yaml",
                       ".yaml": "yaml"}
         dst_fmt = None
+        file_ext = os.path.splitext(self.file)[1].lower()
 
         if destination_format is not None:
             dst_fmt = destination_format
-        elif self.src_format == "dfl":
+        elif self.file == "dfl":
             dst_fmt = "json"
-        elif self.src_format in extensions.keys():
-            dst_fmt = extensions[self.src_format]
+        elif file_ext in extensions.keys():
+            dst_fmt = extensions[file_ext]
         else:
             print("{} is not a supported serializer. "
-                  "Exiting".format(self.src_format))
+                  "Exiting".format(file_ext))
             exit(0)
 
         if self.verbose:
             print("Destination format set to {}".format(dst_fmt))
 
-        return dst_fmt
-
-    def set_destination_serializer(self):
-        """ set the destination serializer """
-        self.serializer = Serializer.get_serializer(self.dst_format)
-
-    def load(self):
-        """ Read the alignments data from the correct format """
-        print("Loading alignments from {}".format(self.file))
-        with open(self.file, self.serializer.roptions) as align:
-            alignments = self.serializer.unmarshal(align.read())
-        return alignments
+        self.serializer = self.get_serializer("", dst_fmt)
+        filename = os.path.splitext(self.file)[0]
+        self.file = "{}.{}".format(filename, self.serializer.ext)
 
-    def reload(self):
-        """ Read the alignments data from the correct format """
-        print("Reloading alignments from {}".format(self.file))
-        with open(self.file, self.serializer.roptions) as align:
-            self.alignments = self.serializer.unmarshal(align.read())
-
-    def save_alignments(self):
+    def save(self):
         """ Backup copy of old alignments and save new alignments """
-        dst = os.path.splitext(self.file)[0]
-        dst += ".{}".format(self.serializer.ext)
-        self.backup_alignments()
-
-        print("Saving alignments to {}".format(dst))
-        with open(dst, self.serializer.woptions) as align:
-            align.write(self.serializer.marshal(self.alignments))
-
-    def backup_alignments(self):
-        """ Backup copy of old alignments """
-        if not os.path.isfile(self.file):
-            return
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        src = self.file
-        dst = src.split(".")
-        dst[0] += "_" + now + "."
-        dst = dst[0] + dst[1]
-        print("Backing up original alignments to {}".format(dst))
-        os.rename(src, dst)
-
-    def get_alignments_one_image(self):
-        """ Return the face alignments for one image """
-        for frame_fullname, alignments in self.alignments.items():
-            frame_name = frame_fullname[:frame_fullname.rindex(".")]
-            number_alignments = len(alignments)
-            yield frame_name, alignments, number_alignments, frame_fullname
-
-    @staticmethod
-    def get_one_alignment_index_reverse(image_alignments, number_alignments):
-        """ Return the correct original index for
-            alignment in reverse order """
-        for idx, _ in enumerate(reversed(image_alignments)):
-            original_idx = number_alignments - 1 - idx
-            yield original_idx
-
-    def get_alignments_for_frame(self, frame):
-        """ Return the alignments for the selected frame """
-        return self.alignments.get(frame, list())
-
-    def frame_in_alignments(self, frame):
-        """ Return true if frame exists in alignments file """
-        return bool(self.alignments.get(frame, -1) != -1)
-
-    def frame_has_faces(self, frame):
-        """ Return true if frame exists and has faces """
-        return bool(self.alignments.get(frame, list()))
-
-    def frame_has_multiple_faces(self, frame):
-        """ Return true if frame exists and has faces """
-        if not frame:
-            return False
-        return bool(len(self.alignments.get(frame, list())) > 1)
-
-    def get_full_frame_name(self, frame):
-        """ Return a frame with extension for when the extension is
-            not known """
-        return next(key for key in self.alignments.keys()
-                    if key.startswith(frame))
-
-    def count_alignments_in_frame(self, frame):
-        """ Return number of alignments within frame """
-        return len(self.alignments.get(frame, list()))
-
-    def delete_alignment_at_index(self, frame, idx):
-        """ Delete the face alignment for given frame at given index """
-        idx = int(idx)
-        if idx + 1 > self.count_alignments_in_frame(frame):
-            return False
-        del self.alignments[frame][idx]
-        return True
-
-    def add_alignment(self, frame, alignment):
-        """ Add a new alignment for a frame and return it's index """
-        self.alignments[frame].append(alignment)
-        return self.count_alignments_in_frame(frame) - 1
-
-    def update_alignment(self, frame, idx, alignment):
-        """ Replace an alignment for given frame and index """
-        self.alignments[frame][idx] = alignment
-
-    def get_rotated(self):
-        """ Return list of keys for alignments containing
-            rotated frames """
-        keys = list()
-        for key, val in self.alignments.items():
-            if any(alignment.get("r", None) for alignment in val):
-                keys.append(key)
-        return keys
-
-    def rotate_existing_landmarks(self, frame, dimensions):
-        """ Backwards compatability fix. Rotates the landmarks to
-            their correct position and sets r to 0 """
-        for alignment in self.alignments.get(frame, list()):
-            angle = alignment.get("r", 0)
-            if not angle:
-                return
-            rotation_matrix = self.get_original_rotation_matrix(dimensions,
-                                                                angle)
-            rotate_landmarks(alignment, rotation_matrix)
-            del alignment["r"]
-
-    @staticmethod
-    def get_original_rotation_matrix(dimensions, angle):
-        """ Calculate original rotation matrix and invert """
-        height, width = dimensions
-        center = (width/2, height/2)
-        rotation_matrix = cv2.getRotationMatrix2D(center, -1.0*angle, 1.)
-
-        abs_cos = abs(rotation_matrix[0, 0])
-        abs_sin = abs(rotation_matrix[0, 1])
-        rotated_width = int(height*abs_sin + width*abs_cos)
-        rotated_height = int(height*abs_cos + width*abs_sin)
-        rotation_matrix[0, 2] += rotated_width/2 - center[0]
-        rotation_matrix[1, 2] += rotated_height/2 - center[1]
-
-        return rotation_matrix
+        self.backup()
+        super().save()
 
 
 class MediaLoader():
@@ -274,14 +133,14 @@ class MediaLoader():
     def load_image(self, filename):
         """ Load an image """
         src = os.path.join(self.folder, filename)
-        image = cv2.imread(src)
+        image = cv2.imread(src)  # pylint: disable=no-member
         return image
 
     @staticmethod
     def save_image(output_folder, filename, image):
         """ Save an image """
         output_file = os.path.join(output_folder, filename)
-        cv2.imwrite(output_file, image)
+        cv2.imwrite(output_file, image)  # pylint: disable=no-member
 
 
 class Faces(MediaLoader):
@@ -361,69 +220,49 @@ class ExtractedFaces():
         self.size = size
         self.padding = padding
         self.align_eyes = align_eyes
-        self.extractor = AlignerExtract()
         self.alignments = alignments
         self.frames = frames
 
         self.current_frame = None
         self.faces = list()
-        self.matrices = list()
 
     def get_faces(self, frame):
-        """ Return faces and transformed face matrices
+        """ Return faces and transformed landmarks
             for each face in a given frame with it's alignments"""
         self.current_frame = None
-        self.faces = list()
-        self.matrices = list()
-        alignments = self.alignments.get_alignments_for_frame(frame)
+        alignments = self.alignments.get_faces_in_frame(frame)
         if not alignments:
+            self.faces = list()
             return
         image = self.frames.load_image(frame)
-        for alignment in alignments:
-            face, matrix = self.extract_one_face(alignment, image.copy())
-            self.faces.append(face)
-            self.matrices.append(matrix)
+        self.faces = [self.extract_one_face(alignment, image.copy())
+                      for alignment in alignments]
         self.current_frame = frame
 
     def extract_one_face(self, alignment, image):
         """ Extract one face from image """
         face = DetectedFace()
         face.from_alignment(alignment, image=image)
-        return self.extractor.extract(image, face, self.size, self.align_eyes)
-
-    def original_roi(self, matrix):
-        """ Return the original ROI of an extracted face """
-        points = np.array([[0, 0], [0, self.size - 1],
-                           [self.size - 1, self.size - 1],
-                           [self.size - 1, 0]], np.int32)
-        points = points.reshape((-1, 1, 2))
+        face.load_aligned(image,
+                          size=self.size,
+                          padding=self.padding,
+                          align_eyes=self.align_eyes)
+        return face
 
-        mat = matrix * (self.size - 2 * self.padding)
-        mat[:, 2] += self.padding
-        mat = cv2.invertAffineTransform(mat)
-        return [cv2.transform(points, mat)]
-
-    def get_faces_for_frame(self, frame, update=False):
+    def get_faces_in_frame(self, frame, update=False):
         """ Return the faces for the selected frame """
         if self.current_frame != frame or update:
             self.get_faces(frame)
         return self.faces
 
-    def get_roi_for_frame(self, frame, update=False):
-        """ Return the original rois for the selected frame """
-        if self.current_frame != frame or update:
-            self.get_faces(frame)
-        return [self.original_roi(matrix) for matrix in self.matrices]
-
     def get_roi_size_for_frame(self, frame):
         """ Return the size of the original extract box for
             the selected frame """
         if self.current_frame != frame:
             self.get_faces(frame)
         sizes = list()
-        for matrix in self.matrices:
-            original_roi = self.original_roi(matrix)[0].squeeze()
-            top_left, top_right = original_roi[0], original_roi[3]
+        for face in self.faces:
+            top_left, top_right = face.original_roi[0], face.original_roi[3]
             len_x = top_right[0] - top_left[0]
             len_y = top_right[1] - top_left[1]
             if top_left[1] == top_right[1]:
@@ -432,20 +271,3 @@ class ExtractedFaces():
                 length = int(((len_x ** 2) + (len_y ** 2)) ** 0.5)
             sizes.append(length)
         return sizes
-
-    def get_aligned_landmarks_for_frame(self, frame, landmarks_xy,
-                                        update=False):
-        """ Return the transposed landmarks for the selected face """
-        if self.current_frame != frame or update:
-            self.get_faces(frame)
-        aligned_landmarks = list()
-        if not self.matrices:
-            return aligned_landmarks
-        for idx, landmarks in enumerate(landmarks_xy):
-            matrix = self.matrices[idx]
-            aligned_landmarks.append(
-                self.extractor.transform_points(landmarks,
-                                                matrix,
-                                                self.size,
-                                                self.padding))
-        return aligned_landmarks

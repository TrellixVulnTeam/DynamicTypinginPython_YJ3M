commit 286f6b28b3ccccad983b462b9e0279b4cc50ce5a
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Mon Jul 29 16:53:04 2019 +0000

    Bugfixes
    
    - Fix filter/nfilter for convert
    - Remove existing snapshot folder before creating if it pre-exists
    - Don't initialize training session until after first save. "Nonetype" session fix

diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index b6ffa81..651a107 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -99,16 +99,20 @@ class DetectedFace():
         """ No need to load aligned information for all uses of this
             class, so only call this to load the information for easy
             reference to aligned properties for this face """
-        logger.trace("Loading aligned face: (size: %s, align_eyes: %s, dtype: %s)",
-                     size, align_eyes, dtype)
-        padding = int(size * self.extract_ratio) // 2
-        self.aligned["size"] = size
-        self.aligned["padding"] = padding
-        self.aligned["align_eyes"] = align_eyes
-        self.aligned["matrix"] = get_align_mat(self, size, align_eyes)
-        if image is None:
-            self.aligned["face"] = None
+        # Don't reload an already aligned face:
+        if self.aligned:
+            logger.trace("Skipping alignment calculation for already aligned face")
         else:
+            logger.trace("Loading aligned face: (size: %s, align_eyes: %s, dtype: %s)",
+                         size, align_eyes, dtype)
+            padding = int(size * self.extract_ratio) // 2
+            self.aligned["size"] = size
+            self.aligned["padding"] = padding
+            self.aligned["align_eyes"] = align_eyes
+            self.aligned["matrix"] = get_align_mat(self, size, align_eyes)
+            self.aligned["face"] = None
+        if image is not None and self.aligned["face"] is None:
+            logger.trace("Getting aligned face")
             face = AlignerExtract().transform(
                 image,
                 self.aligned["matrix"],
diff --git a/lib/gui/stats.py b/lib/gui/stats.py
index a3c9cce..0570aff 100644
--- a/lib/gui/stats.py
+++ b/lib/gui/stats.py
@@ -225,7 +225,7 @@ class Session():
         else:
             self.session_id = session_id
         self.initialized = True
-        logger.debug("Initialized session")
+        logger.debug("Initialized session. Session_ID: %s", self.session_id)
 
     def load_state_file(self):
         """ Load the current state file """
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index 9fa8ad1..ea693c3 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -47,8 +47,6 @@ class ProcessWrapper():
         category, command = self.tk_vars["action"].get().split(",")
 
         if self.tk_vars["runningtask"].get():
-            if self.task.command == "train":
-                self.tk_vars["istraining"].set(False)
             self.task.terminate()
         else:
             self.command = command
@@ -126,6 +124,8 @@ class ProcessWrapper():
         """ Finalize wrapper when process has exited """
         logger.debug("Terminating Faceswap processes")
         self.tk_vars["runningtask"].set(False)
+        if self.task.command == "train":
+            self.tk_vars["istraining"].set(False)
         self.statusbar.progress_stop()
         self.statusbar.status_message.set(message)
         self.tk_vars["display"].set(None)
@@ -141,7 +141,8 @@ class FaceswapControl():
     def __init__(self, wrapper):
         logger.debug("Initializing %s", self.__class__.__name__)
         self.wrapper = wrapper
-        self.statusbar = get_config().statusbar
+        self.config = get_config()
+        self.statusbar = self.config.statusbar
         self.command = None
         self.args = None
         self.process = None
@@ -189,6 +190,10 @@ class FaceswapControl():
                     continue
                 if self.command == "train" and "[saved models]" in output.strip().lower():
                     logger.debug("Trigger GUI Training update")
+                    if not self.config.session.initialized:
+                        # Don't initialize session until after the first save as state
+                        # file must exist first
+                        self.config.session.initialize_session(is_training=True)
                     self.wrapper.tk_vars["updatepreview"].set(True)
                     self.wrapper.tk_vars["refreshgraph"].set(True)
                 print(output.strip())
@@ -255,14 +260,9 @@ class FaceswapControl():
         iterations = self.train_stats["iterations"]
 
         if iterations == 0:
-            # Initialize session stats and set initial timestamp
+            # Set initial timestamp
             self.train_stats["timestamp"] = time()
 
-        if not get_config().session.initialized and iterations > 0:
-            # Don't initialize session until after the first iteration as state
-            # file must exist first
-            get_config().session.initialize_session(is_training=True)
-
         iterations += 1
         self.train_stats["iterations"] = iterations
 
@@ -339,16 +339,15 @@ class FaceswapControl():
     def terminate(self):
         """ Terminate the running process in a LongRunningTask so we can still
             output to console """
-        root = get_config().root
         if self.thread is None:
             logger.debug("Terminating wrapper in LongRunningTask")
             self.thread = LongRunningTask(target=self.terminate_in_thread,
                                           args=(self.command, self.process))
             self.thread.start()
-            root.after(1000, self.terminate)
+            self.config.root.after(1000, self.terminate)
         elif not self.thread.complete.is_set():
             logger.debug("Not finished terminating")
-            root.after(1000, self.terminate)
+            self.config.root.after(1000, self.terminate)
         else:
             logger.debug("Termination Complete. Cleaning up")
             _ = self.thread.get_result()  # Terminate the LongRunningTask object
@@ -358,7 +357,7 @@ class FaceswapControl():
         """ Terminate the subprocess """
         logger.debug("Terminating wrapper")
         if command == "train":
-            timeout = get_config().tk_vars["traintimeout"].get()
+            timeout = self.config.tk_vars["traintimeout"].get()
             logger.debug("Sending Exit Signal")
             print("Sending Exit Signal", flush=True)
             now = time()
diff --git a/lib/model/backup_restore.py b/lib/model/backup_restore.py
index 12376c2..0666a5a 100644
--- a/lib/model/backup_restore.py
+++ b/lib/model/backup_restore.py
@@ -5,7 +5,7 @@
 import logging
 import os
 from datetime import datetime
-from shutil import copyfile, copytree
+from shutil import copyfile, copytree, rmtree
 
 from lib import Serializer
 from lib.utils import get_folder
@@ -58,7 +58,13 @@ class Backup():
     def snapshot_models(self, iterations):
         """ Take a snapshot of the model at current state and back up """
         logger.info("Saving snapshot")
-        dst = str(get_folder("{}_snapshot_{}_iters".format(self.model_dir, iterations)))
+        snapshot_dir = "{}_snapshot_{}_iters".format(self.model_dir, iterations)
+
+        if os.path.isdir(snapshot_dir):
+            logger.debug("Removing previously existing snapshot folder: '%s'", snapshot_dir)
+            rmtree(snapshot_dir)
+
+        dst = str(get_folder(snapshot_dir))
         for filename in os.listdir(self.model_dir):
             if not self.check_valid(filename, for_restore=False):
                 logger.debug("Not snapshotting file: '%s'", filename)
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index 3b04adb..0037c8a 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -451,6 +451,7 @@ class FaceFilter(PostProcessAction):
         ret_faces = list()
         for idx, detect_face in enumerate(output_item["detected_faces"]):
             check_item = detect_face["face"] if isinstance(detect_face, dict) else detect_face
+            check_item.load_aligned(output_item["image"])
             if not self.filter.check(check_item):
                 logger.verbose("Skipping not recognized face: (Frame: %s Face %s)",
                                output_item["filename"], idx)

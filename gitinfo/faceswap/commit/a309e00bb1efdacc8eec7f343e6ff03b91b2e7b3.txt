commit a309e00bb1efdacc8eec7f343e6ff03b91b2e7b3
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Wed Oct 3 14:21:41 2018 +0100

    Alignments Tool - Spatio-Temporal Smoothing (#516)
    
    * Alignments Tool: Spatio-temporal smoothing

diff --git a/requirements.txt b/requirements.txt
index 6d74501..bf45e62 100755
--- a/requirements.txt
+++ b/requirements.txt
@@ -4,6 +4,7 @@ h5py==2.8.0
 Keras==2.2.0
 opencv-python==3.4.1.15
 scikit-image
+scikit-learn==0.20.0
 face_recognition
 cmake
 dlib
diff --git a/tools/alignments.py b/tools/alignments.py
index 7b9472c..87ac4ff 100644
--- a/tools/alignments.py
+++ b/tools/alignments.py
@@ -4,7 +4,7 @@
 # TODO merge alignments
 from lib.utils import set_system_verbosity
 from .lib_alignments import (AlignmentData, Check, Draw, Extract, Manual,
-                             Reformat, RemoveAlignments, Rotate, Sort)
+                             Reformat, RemoveAlignments, Rotate, Sort, Spatial)
 
 
 class Alignments():
diff --git a/tools/cli.py b/tools/cli.py
index 0d46767..45fb03a 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -27,7 +27,7 @@ class AlignmentsArgs(FaceSwapArgs):
                         "missing-alignments", "missing-frames",
                         "leftover-faces", "multi-faces", "no-faces",
                         "reformat", "remove-faces", "remove-frames",
-                        "rotate", "sort-x", "sort-y"),
+                        "rotate", "sort-x", "sort-y", "spatial"),
             "required": True,
             "help": "R|Choose which action you want to perform.\n"
                     "NB: All actions require an alignments file (-a) to"
@@ -94,7 +94,9 @@ class AlignmentsArgs(FaceSwapArgs):
                     "\n\tbottom. For alignments with multiple faces this will"
                     "\n\tensure that the top-most face is at index 0"
                     "\n\tOptionally pass in a faces folder (-fc) to also"
-                    "\n\trename extracted faces."})
+                    "\n\trename extracted faces."
+                    "\n'spatial' - Perform spatial and temporal filtering to "
+                    "\n\tsmooth alignments (EXPERIMENTAL!)"})
         argument_list.append({"opts": ("-a", "--alignments_file"),
                               "action": FileFullPaths,
                               "dest": "alignments_file",
diff --git a/tools/lib_alignments/__init__.py b/tools/lib_alignments/__init__.py
index 4038683..74057b2 100644
--- a/tools/lib_alignments/__init__.py
+++ b/tools/lib_alignments/__init__.py
@@ -1,4 +1,4 @@
 from tools.lib_alignments.media import AlignmentData, ExtractedFaces, Faces, Frames
 from tools.lib_alignments.annotate import Annotate
-from tools.lib_alignments.jobs import Check, Draw, Extract, Reformat, RemoveAlignments, Rotate, Sort
+from tools.lib_alignments.jobs import Check, Draw, Extract, Reformat, RemoveAlignments, Rotate, Sort, Spatial
 from tools.lib_alignments.jobs_manual import Manual
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index b73f8ae..4ad53c1 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -6,6 +6,9 @@ import pickle
 import struct
 from datetime import datetime
 
+import numpy as np
+from scipy import signal
+from sklearn import decomposition
 from tqdm import tqdm
 
 from . import Annotate, ExtractedFaces, Faces, Frames
@@ -253,7 +256,7 @@ class Draw():
 
 
 class Extract():
-    """ Re-extract faces from source frames based on 
+    """ Re-extract faces from source frames based on
         Alignment data """
     def __init__(self, alignments, arguments):
         self.verbose = arguments.verbose
@@ -329,6 +332,7 @@ class Extract():
                 valid_faces.append(faces[idx])
         return valid_faces
 
+
 class Reformat():
     """ Reformat Alignment file """
     def __init__(self, alignments, arguments):
@@ -663,3 +667,154 @@ class Sort():
                 os.rename(src, dst)
                 if self.verbose and action == "final":
                     print("Renamed {} to {}".format(old, new))
+
+
+class Spatial():
+    """ Apply spatial temporal filtering to landmarks
+        Adapted from:
+        https://www.kaggle.com/selfishgene/animating-and-smoothing-3d-facial-keypoints/notebook """
+
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.arguments = arguments
+        self.alignments = alignments
+        self.mappings = dict()
+        self.normalized = dict()
+        self.shapes_model = None
+
+    def process(self):
+        """ Perform spatial filtering """
+        print("\n[SPATIO-TEMPORAL FILTERING]")  # Tidy up cli output
+        print("NB: The process only processes the alignments for the first "
+              "face it finds for any given frame\n"
+              "    For best results only run this when:\n"
+              "      - there is only a single face in the alignments file\n"
+              "      - all false positives have been removed\n")
+
+        self.normalize()
+        self.shape_model()
+        landmarks = self.spatially_filter()
+        landmarks = self.temporally_smooth(landmarks)
+        self.update_alignments(landmarks)
+        self.alignments.save_alignments()
+
+        print("\nDone! To re-extract faces run:\n    python tools.py "
+              "alignments -j extract -a {} -fr <path_to_frames_dir> -fc "
+              "<output_folder>\n".format(self.arguments.alignments_file))
+
+    # define shape normalization utility functions
+    @staticmethod
+    def normalize_shapes(shapes_im_coords):
+        """ Normalize a 2D or 3D shape """
+        (num_pts, num_dims, _) = shapes_im_coords.shape
+
+        # calc mean coords and subtract from shapes
+        mean_coords = shapes_im_coords.mean(axis=0)
+        shapes_centered = np.zeros(shapes_im_coords.shape)
+        shapes_centered = shapes_im_coords - np.tile(mean_coords,
+                                                     [num_pts, 1, 1])
+
+        # calc scale factors and divide shapes
+        scale_factors = np.sqrt((shapes_centered**2).sum(axis=1)).mean(axis=0)
+        shapes_normalized = np.zeros(shapes_centered.shape)
+        shapes_normalized = shapes_centered / np.tile(scale_factors,
+                                                      [num_pts, num_dims, 1])
+
+        return shapes_normalized, scale_factors, mean_coords
+
+    @staticmethod
+    def normalized_to_original(shapes_normalized, scale_factors, mean_coords):
+        """ Transform a normalized shape back to original image coordinates """
+        (num_pts, num_dims, _) = shapes_normalized.shape
+
+        # move back to the correct scale
+        shapes_centered = shapes_normalized * np.tile(scale_factors,
+                                                      [num_pts, num_dims, 1])
+        # move back to the correct location
+        shapes_im_coords = shapes_centered + np.tile(mean_coords,
+                                                     [num_pts, 1, 1])
+
+        return shapes_im_coords
+
+    def normalize(self):
+        """ Compile all original and normalized alignments """
+        count = sum(1 for val in self.alignments.alignments.values() if val)
+        landmarks_all = np.zeros((68, 2, int(count)))
+
+        end = 0
+        for key in tqdm(sorted(self.alignments.alignments.keys()),
+                        desc="Compiling"):
+            val = self.alignments.alignments[key]
+            if not val:
+                continue
+            # We should only be normalizing a single face, so just take
+            # the first landmarks found
+            landmarks = np.array(val[0]["landmarksXY"]).reshape(68, 2, 1)
+            start = end
+            end = start + landmarks.shape[2]
+            # store in one big array
+            landmarks_all[:, :, start:end] = landmarks
+            # make sure we keep track of the mapping to the original frame
+            self.mappings[start] = key
+
+        # normalize shapes
+        normalized_shape = self.normalize_shapes(landmarks_all)
+        self.normalized["landmarks"] = normalized_shape[0]
+        self.normalized["scale_factors"] = normalized_shape[1]
+        self.normalized["mean_coords"] = normalized_shape[2]
+
+    def shape_model(self):
+        """ build 2D shape model """
+        landmarks_norm = self.normalized["landmarks"]
+        num_components = 20
+        normalized_shapes_tbl = np.reshape(landmarks_norm,
+                                           [68*2, landmarks_norm.shape[2]]).T
+        self.shapes_model = decomposition.PCA(
+            n_components=num_components,
+            whiten=True,
+            random_state=1).fit(normalized_shapes_tbl)
+        explained = self.shapes_model.explained_variance_ratio_.sum()
+        print("\nTotal explained percent by PCA model with {} components is "
+              "{}%\n".format(num_components, round(100 * explained, 1)))
+
+    def spatially_filter(self):
+        """ interpret the shapes using our shape model
+            (project and reconstruct) """
+        landmarks_norm = self.normalized["landmarks"]
+        # convert to matrix form
+        landmarks_norm_table = np.reshape(landmarks_norm,
+                                          [68 * 2, landmarks_norm.shape[2]]).T
+        # project onto shapes model and reconstruct
+        landmarks_norm_table_rec = self.shapes_model.inverse_transform(
+            self.shapes_model.transform(landmarks_norm_table))
+        # convert back to shapes (numKeypoint, num_dims, numFrames)
+        landmarks_norm_rec = np.reshape(landmarks_norm_table_rec.T,
+                                        [68, 2, landmarks_norm.shape[2]])
+        # transform back to image coords
+        return self.normalized_to_original(landmarks_norm_rec,
+                                           self.normalized["scale_factors"],
+                                           self.normalized["mean_coords"])
+
+    @staticmethod
+    def temporally_smooth(landmarks):
+        """ apply temporal filtering on the 2D points """
+        filter_half_length = 2
+        temporal_filter = np.ones((1, 1, 2*filter_half_length+1))
+        temporal_filter = temporal_filter / temporal_filter.sum()
+
+        start_tileblock = np.tile(landmarks[:, :, 0][:, :, np.newaxis],
+                                  [1, 1, filter_half_length])
+        end_tileblock = np.tile(landmarks[:, :, -1][:, :, np.newaxis],
+                                [1, 1, filter_half_length])
+        landmarks_padded = np.dstack((start_tileblock,
+                                      landmarks,
+                                      end_tileblock))
+        return signal.convolve(landmarks_padded, temporal_filter,
+                               mode='valid', method='fft')
+
+    def update_alignments(self, landmarks):
+        """ Update smoothed landmarks back to alignments """
+        for idx, frame in tqdm(self.mappings.items(), desc="Updating"):
+            landmarks_update = landmarks[:, :, idx].astype(int)
+            landmarks_xy = landmarks_update.reshape(68, 2).tolist()
+            self.alignments.alignments[frame][0]["landmarksXY"] = landmarks_xy

commit e35918cadf0b4bcfbf530e4cb68d52bd2e0bf93f
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Thu Oct 10 23:11:12 2019 +0100

    Standardize serialization (#903)
    
    * Standardize serialization
    
    - Linting
    - Standardize serializer use throughout code
    - Extend serializer to load and save files
    - Always load and save in utf-8
    - Create documentation

diff --git a/docs/full/lib.rst b/docs/full/lib.rst
index 44ca917..83e9642 100644
--- a/docs/full/lib.rst
+++ b/docs/full/lib.rst
@@ -9,6 +9,7 @@ Subpackages
    lib.model
    lib.faces_detect
    lib.image
+   lib.serializer
    lib.training_data
 
 Module contents
diff --git a/docs/full/lib.serializer.rst b/docs/full/lib.serializer.rst
new file mode 100644
index 0000000..19c2bcc
--- /dev/null
+++ b/docs/full/lib.serializer.rst
@@ -0,0 +1,7 @@
+lib.serializer module
+=========================
+
+.. automodule:: lib.serializer
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/lib/Serializer.py b/lib/Serializer.py
deleted file mode 100644
index 23a01d6..0000000
--- a/lib/Serializer.py
+++ /dev/null
@@ -1,104 +0,0 @@
-#!/usr/bin/env python3
-"""
-Library providing convenient classes and methods for writing data to files.
-"""
-import logging
-import json
-import pickle
-
-try:
-    import yaml
-except ImportError:
-    yaml = None
-
-logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
-
-
-class Serializer():
-    """ Parent Serializer class """
-    ext = ""
-    woptions = ""
-    roptions = ""
-
-    @classmethod
-    def marshal(cls, input_data):
-        """ Override for marshalling """
-        raise NotImplementedError()
-
-    @classmethod
-    def unmarshal(cls, input_string):
-        """ Override for unmarshalling """
-        raise NotImplementedError()
-
-
-class YAMLSerializer(Serializer):
-    """ YAML Serializer """
-    ext = "yml"
-    woptions = "w"
-    roptions = "r"
-
-    @classmethod
-    def marshal(cls, input_data):
-        return yaml.dump(input_data, default_flow_style=False)
-
-    @classmethod
-    def unmarshal(cls, input_string):
-        return yaml.load(input_string)
-
-
-class JSONSerializer(Serializer):
-    """ JSON Serializer """
-    ext = "json"
-    woptions = "w"
-    roptions = "r"
-
-    @classmethod
-    def marshal(cls, input_data):
-        return json.dumps(input_data, indent=2)
-
-    @classmethod
-    def unmarshal(cls, input_string):
-        return json.loads(input_string)
-
-
-class PickleSerializer(Serializer):
-    """ Picke Serializer """
-    ext = "p"
-    woptions = "wb"
-    roptions = "rb"
-
-    @classmethod
-    def marshal(cls, input_data):
-        return pickle.dumps(input_data)
-
-    @classmethod
-    def unmarshal(cls, input_bytes):  # pylint: disable=arguments-differ
-        return pickle.loads(input_bytes)
-
-
-def get_serializer(serializer):
-    """ Return requested serializer """
-    if serializer == "json":
-        return JSONSerializer
-    if serializer == "pickle":
-        return PickleSerializer
-    if serializer == "yaml" and yaml is not None:
-        return YAMLSerializer
-    if serializer == "yaml" and yaml is None:
-        logger.warning("You must have PyYAML installed to use YAML as the serializer."
-                       "Switching to JSON as the serializer.")
-    return JSONSerializer
-
-
-def get_serializer_from_ext(ext):
-    """ Get the sertializer from filename extension """
-    if ext == ".json":
-        return JSONSerializer
-    if ext == ".p":
-        return PickleSerializer
-    if ext in (".yaml", ".yml") and yaml is not None:
-        return YAMLSerializer
-    if ext in (".yaml", ".yml") and yaml is None:
-        logger.warning("You must have PyYAML installed to use YAML as the serializer.\n"
-                       "Switching to JSON as the serializer.")
-    return JSONSerializer
diff --git a/lib/alignments.py b/lib/alignments.py
index def51d8..fffb50f 100644
--- a/lib/alignments.py
+++ b/lib/alignments.py
@@ -9,7 +9,7 @@ from datetime import datetime
 import cv2
 
 from lib.faces_detect import rotate_landmarks
-from lib import Serializer
+from lib.serializer import get_serializer, get_serializer_from_filename
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -85,15 +85,15 @@ class Alignments():
                      filename, serializer)
         extension = os.path.splitext(filename)[1]
         if extension in (".json", ".p", ".yaml", ".yml"):
-            logger.debug("Serializer set from file extension: '%s'", extension)
-            retval = Serializer.get_serializer_from_ext(extension)
+            logger.debug("Serializer set from filename extension: '%s'", extension)
+            retval = get_serializer_from_filename(filename)
         elif serializer not in ("json", "pickle", "yaml"):
             raise ValueError("Error: {} is not a valid serializer. Use "
                              "'json', 'pickle' or 'yaml'")
         else:
             logger.debug("Serializer set from argument: '%s'", serializer)
-            retval = Serializer.get_serializer(serializer)
-        logger.verbose("Using '%s' serializer for alignments", retval.ext)
+            retval = get_serializer(serializer)
+        logger.verbose("Using '%s' serializer for alignments", retval.file_extension)
         return retval
 
     def get_location(self, folder, filename):
@@ -106,8 +106,9 @@ class Alignments():
         else:
             location = os.path.join(str(folder),
                                     "{}.{}".format(filename,
-                                                   self.serializer.ext))
-            logger.debug("File extension set from serializer: '%s'", self.serializer.ext)
+                                                   self.serializer.file_extension))
+            logger.debug("File extension set from serializer: '%s'",
+                         self.serializer.file_extension)
         logger.verbose("Alignments filepath: '%s'", location)
         return location
 
@@ -121,13 +122,8 @@ class Alignments():
             raise ValueError("Error: Alignments file not found at "
                              "{}".format(self.file))
 
-        try:
-            logger.info("Reading alignments from: '%s'", self.file)
-            with open(self.file, self.serializer.roptions) as align:
-                data = self.serializer.unmarshal(align.read())
-        except IOError as err:
-            logger.error("'%s' not read: %s", self.file, err.strerror)
-            exit(1)
+        logger.info("Reading alignments from: '%s'", self.file)
+        data = self.serializer.load(self.file)
         logger.debug("Loaded alignments")
         return data
 
@@ -140,13 +136,9 @@ class Alignments():
     def save(self):
         """ Write the serialized alignments file """
         logger.debug("Saving alignments")
-        try:
-            logger.info("Writing alignments to: '%s'", self.file)
-            with open(self.file, self.serializer.woptions) as align:
-                align.write(self.serializer.marshal(self.data))
-            logger.debug("Saved alignments")
-        except IOError as err:
-            logger.error("'%s' not written: %s", self.file, err.strerror)
+        logger.info("Writing alignments to: '%s'", self.file)
+        self.serializer.save(self.file, self.data)
+        logger.debug("Saved alignments")
 
     def backup(self):
         """ Backup copy of old alignments """
diff --git a/lib/gui/menu.py b/lib/gui/menu.py
index a5d1e26..2faeeeb 100644
--- a/lib/gui/menu.py
+++ b/lib/gui/menu.py
@@ -13,7 +13,7 @@ from importlib import import_module
 from subprocess import Popen, PIPE, STDOUT
 
 from lib.multithreading import MultiThread
-from lib.Serializer import JSONSerializer
+from lib.serializer import get_serializer
 
 import update_deps
 from .utils import get_config
@@ -127,13 +127,12 @@ class FileMenu(tk.Menu):  # pylint:disable=too-many-ancestors
     def build_recent_menu(self):
         """ Load recent files into menu bar """
         logger.debug("Building Recent Files menu")
-        serializer = JSONSerializer
+        serializer = get_serializer("json")
         menu_file = os.path.join(self.config.pathcache, ".recent.json")
         if not os.path.isfile(menu_file) or os.path.getsize(menu_file) == 0:
             self.clear_recent_files(serializer, menu_file)
-        with open(menu_file, "rb") as inp:
-            recent_files = serializer.unmarshal(inp.read().decode("utf-8"))
-            logger.debug("Loaded recent files: %s", recent_files)
+        recent_files = serializer.load(menu_file)
+        logger.debug("Loaded recent files: %s", recent_files)
         for recent_item in recent_files:
             filename, command = recent_item
             logger.debug("processing: ('%s', %s)", filename, command)
@@ -153,9 +152,7 @@ class FileMenu(tk.Menu):  # pylint:disable=too-many-ancestors
     def clear_recent_files(serializer, menu_file):
         """ Creates or clears recent file list """
         logger.debug("clearing recent files list: '%s'", menu_file)
-        recent_files = serializer.marshal(list())
-        with open(menu_file, "wb") as out:
-            out.write(recent_files.encode("utf-8"))
+        serializer.save(menu_file, list())
 
     def refresh_recent_menu(self):
         """ Refresh recent menu on save/load of files """
@@ -222,7 +219,7 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         try:
             from lib.sysinfo import sysinfo
             info = sysinfo
-        except Exception as err:
+        except Exception as err:  # pylint:disable=broad-except
             info = "Error obtaining system info: {}".format(str(err))
         self.clear_console()
         logger.debug("Obtained system information: %s", info)
diff --git a/lib/gui/stats.py b/lib/gui/stats.py
index de3a7cc..16fbb4e 100644
--- a/lib/gui/stats.py
+++ b/lib/gui/stats.py
@@ -10,7 +10,7 @@ from math import ceil, sqrt
 
 import numpy as np
 import tensorflow as tf
-from lib.Serializer import JSONSerializer
+from lib.serializer import get_serializer
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -101,7 +101,7 @@ class Session():
     def __init__(self, model_dir=None, model_name=None):
         logger.debug("Initializing %s: (model_dir: %s, model_name: %s)",
                      self.__class__.__name__, model_dir, model_name)
-        self.serializer = JSONSerializer
+        self.serializer = get_serializer("json")
         self.state = None
         self.modeldir = model_dir  # Set and reset by wrapper for training sessions
         self.modelname = model_name  # Set and reset by wrapper for training sessions
@@ -231,13 +231,8 @@ class Session():
         """ Load the current state file """
         state_file = os.path.join(self.modeldir, "{}_state.json".format(self.modelname))
         logger.debug("Loading State: '%s'", state_file)
-        try:
-            with open(state_file, "rb") as inp:
-                state = self.serializer.unmarshal(inp.read().decode("utf-8"))
-                self.state = state
-                logger.debug("Loaded state: %s", state)
-        except IOError as err:
-            logger.warning("Unable to load state file. Graphing disabled: %s", str(err))
+        self.state = self.serializer.load(state_file)
+        logger.debug("Loaded state: %s", self.state)
 
     def get_iterations_for_session(self, session_id):
         """ Return the number of iterations for the given session id """
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 55658f8..095a918 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -13,7 +13,7 @@ import numpy as np
 
 from PIL import Image, ImageDraw, ImageTk
 
-from lib.Serializer import JSONSerializer
+from lib.serializer import get_serializer
 
 from ._config import Config as UserConfig
 from ._redirector import WidgetRedirector
@@ -643,7 +643,7 @@ class Config():
         self.scaling_factor = scaling_factor
         self.pathcache = pathcache
         self.statusbar = statusbar
-        self.serializer = JSONSerializer
+        self.serializer = get_serializer("json")
         self.tk_vars = self.set_tk_vars()
         self.user_config = UserConfig(None)
         self.user_config_dict = self.user_config.config_dict
@@ -740,13 +740,14 @@ class Config():
                 msg = "File does not exist: '{}'".format(filename)
                 logger.error(msg)
                 return
-            with open(filename, "r") as cfgfile:
-                cfg = self.serializer.unmarshal(cfgfile.read())
+            cfg = self.serializer.load(filename)
         else:
             cfgfile = FileHandler("open", "config").retfile
             if not cfgfile:
                 return
-            cfg = self.serializer.unmarshal(cfgfile.read())
+            filename = cfgfile.name
+            cfgfile.close()
+            cfg = self.serializer.load(filename)
 
         if not command and len(cfg.keys()) == 1:
             command = list(cfg.keys())[0]
@@ -764,8 +765,8 @@ class Config():
             else:
                 self.command_notebook.select(self.command_tabs["tools"])
                 self.command_notebook.tools_notebook.select(self.tools_command_tabs[command])
-        self.add_to_recent(cfgfile.name, command)
-        logger.debug("Loaded config: (command: '%s', cfgfile: '%s')", command, cfgfile)
+        self.add_to_recent(filename, command)
+        logger.debug("Loaded config: (command: '%s', filename: '%s')", command, filename)
 
     def get_command_options(self, cfg, command):
         """ return the saved options for the requested
@@ -796,11 +797,12 @@ class Config():
         cfgfile = FileHandler("save", "config").retfile
         if not cfgfile:
             return
-        cfg = self.cli_opts.get_option_values(command)
-        cfgfile.write(self.serializer.marshal(cfg))
+        filename = cfgfile.name
         cfgfile.close()
-        self.add_to_recent(cfgfile.name, command)
-        logger.debug("Saved config: (command: '%s', cfgfile: '%s')", command, cfgfile)
+        cfg = self.cli_opts.get_option_values(command)
+        self.serializer.save(filename, cfg)
+        self.add_to_recent(filename, command)
+        logger.debug("Saved config: (command: '%s', filename: '%s')", command, filename)
 
     def add_to_recent(self, filename, command):
         """ Add to recent files """
@@ -809,8 +811,7 @@ class Config():
         if not os.path.exists(recent_filename) or os.path.getsize(recent_filename) == 0:
             recent_files = list()
         else:
-            with open(recent_filename, "rb") as inp:
-                recent_files = self.serializer.unmarshal(inp.read().decode("utf-8"))
+            recent_files = self.serializer.load(recent_filename)
         logger.debug("Initial recent files: %s", recent_files)
         filenames = [recent[0] for recent in recent_files]
         if filename in filenames:
@@ -819,9 +820,7 @@ class Config():
         recent_files.insert(0, (filename, command))
         recent_files = recent_files[:20]
         logger.debug("Final recent files: %s", recent_files)
-        recent_json = self.serializer.marshal(recent_files)
-        with open(recent_filename, "wb") as out:
-            out.write(recent_json.encode("utf-8"))
+        self.serializer.save(recent_filename, recent_files)
 
 
 class ContextMenu(tk.Menu):  # pylint: disable=too-many-ancestors
diff --git a/lib/model/backup_restore.py b/lib/model/backup_restore.py
index 0666a5a..4a3261c 100644
--- a/lib/model/backup_restore.py
+++ b/lib/model/backup_restore.py
@@ -7,7 +7,7 @@ import os
 from datetime import datetime
 from shutil import copyfile, copytree, rmtree
 
-from lib import Serializer
+from lib.serializer import get_serializer
 from lib.utils import get_folder
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -131,13 +131,12 @@ class Backup():
 
     def get_session_names(self):
         """ Get the existing session names from state file """
-        serializer = Serializer.get_serializer("json")
+        serializer = get_serializer("json")
         state_file = os.path.join(self.model_dir,
-                                  "{}_state.{}".format(self.model_name, serializer.ext))
-        with open(state_file, "rb") as inp:
-            state = serializer.unmarshal(inp.read().decode("utf-8"))
-            session_names = ["session_{}".format(key)
-                             for key in state["sessions"].keys()]
+                                  "{}_state.{}".format(self.model_name, serializer.file_extension))
+        state = serializer.load(state_file)
+        session_names = ["session_{}".format(key)
+                         for key in state["sessions"].keys()]
         logger.debug("Session to restore: %s", session_names)
         return session_names
 
diff --git a/lib/serializer.py b/lib/serializer.py
new file mode 100644
index 0000000..9370db2
--- /dev/null
+++ b/lib/serializer.py
@@ -0,0 +1,287 @@
+#!/usr/bin/env python3
+"""
+Library for serializing python objects to and from various different serializer formats
+"""
+import logging
+import json
+import os
+import pickle
+
+from lib.utils import FaceswapError
+
+try:
+    import yaml
+except ImportError:
+    yaml = None
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
+
+class Serializer():
+    """ A convenience class for various serializers.
+
+    This class should not be called directly as it acts as the parent for various serializers.
+    All serializers should be called from :func:`get_serializer` or
+    :func:`get_serializer_from_filename`
+
+    Example
+    -------
+    >>> from lib.serializer import get_serializer
+    >>> serializer = get_serializer('json')
+    >>> json_file = '/path/to/json/file.json'
+    >>> data = serializer.load(json_file)
+    >>> serializer.save(json_file, data)
+
+    """
+    def __init__(self):
+        self._file_extension = None
+        self._write_option = "wb"
+        self._read_option = "rb"
+
+    @property
+    def file_extension(self):
+        """ str: The file extension of the serializer """
+        return self._file_extension
+
+    def save(self, filename, data):
+        """ Serialize data and save to a file
+
+        Parameters
+        ----------
+        filename: str
+            The path to where the serialized file should be saved
+        data: varies
+            The data that is to be serialized to file
+
+        Example
+        ------
+        >>> serializer = get_serializer('json')
+        >>> data ['foo', 'bar']
+        >>> json_file = '/path/to/json/file.json'
+        >>> serializer.save(json_file, data)
+        """
+        logger.debug("filename: %s, data type: %s", filename, type(data))
+        filename = self._check_extension(filename)
+        try:
+            with open(filename, self._write_option) as s_file:
+                s_file.write(self.marshal(data))
+        except IOError as err:
+            msg = "Error writing to '{}': {}".format(filename, err.strerror)
+            raise FaceswapError(msg) from err
+
+    def _check_extension(self, filename):
+        """ Check the filename has an extension. If not add the correct one for the serializer """
+        extension = os.path.splitext(filename)[1]
+        retval = filename if extension else "{}.{}".format(filename, self.file_extension)
+        logger.debug("Original filename: '%s', final filename: '%s'", filename, retval)
+        return retval
+
+    def load(self, filename):
+        """ Load data from an existing serialized file
+
+        Parameters
+        ----------
+        filename: str
+            The path to the serialized file
+
+        Returns
+        ----------
+        data: varies
+            The data in a python object format
+
+        Example
+        ------
+        >>> serializer = get_serializer('json')
+        >>> json_file = '/path/to/json/file.json'
+        >>> data = serializer.load(json_file)
+        """
+        logger.debug("filename: %s", filename)
+        try:
+            with open(filename, self._read_option) as s_file:
+                data = s_file.read()
+                logger.debug("stored data type: %s", type(data))
+                if isinstance(data, bytes):
+                    data = data.decode("utf-8")
+                retval = self.unmarshal(data)
+        except IOError as err:
+            msg = "Error reading from '{}': {}".format(filename, err.strerror)
+            raise FaceswapError(msg) from err
+        logger.debug("data type: %s", type(retval))
+        return retval
+
+    def marshal(self, data):
+        """ Serialize an object
+
+        Parameters
+        ----------
+        data: varies
+            The data that is to be serialized
+
+        Returns
+        -------
+        data: varies
+            The data in a the serialized data format
+
+        Example
+        ------
+        >>> serializer = get_serializer('json')
+        >>> data ['foo', 'bar']
+        >>> json_data = serializer.marshal(data)
+        """
+        logger.debug("data type: %s", type(data))
+        try:
+            retval = self._marshal(data)
+        except Exception as err:
+            msg = "Error serializing data for type {}: {}".format(type(data), str(err))
+            raise FaceswapError(msg) from err
+        logger.debug("returned data type: %s", type(retval))
+        return retval
+
+    def unmarshal(self, serialized_data):
+        """ Unserialize data to its original object type
+
+        Parameters
+        ----------
+        serialized_data: varies
+            Data in serializer format that is to be unmarshalled to its original object
+
+        Returns
+        -------
+        data: varies
+            The data in a python object format
+
+        Example
+        ------
+        >>> serializer = get_serializer('json')
+        >>> json_data = <json object>
+        >>> data = serializer.unmarshal(json_data)
+        """
+        logger.debug("data type: %s", type(serialized_data))
+        try:
+            retval = self._unmarshal(serialized_data)
+        except Exception as err:
+            msg = "Error unserializing data for type {}: {}".format(type(serialized_data),
+                                                                    str(err))
+            raise FaceswapError(msg) from err
+        logger.debug("returned data type: %s", type(retval))
+        return retval
+
+    @classmethod
+    def _marshal(cls, data):
+        """ Override for serializer specific marshalling """
+        raise NotImplementedError()
+
+    @classmethod
+    def _unmarshal(cls, data):
+        """ Override for serializer specific unmarshalling """
+        raise NotImplementedError()
+
+
+class _YAMLSerializer(Serializer):
+    """ YAML Serializer """
+    def __init__(self):
+        super().__init__()
+        self._file_extension = "yml"
+
+    @classmethod
+    def _marshal(cls, data):
+        return yaml.dump(data, default_flow_style=False).encode("utf-8")
+
+    @classmethod
+    def _unmarshal(cls, data):
+        return yaml.load(data)
+
+
+class _JSONSerializer(Serializer):
+    """ JSON Serializer """
+    def __init__(self):
+        super().__init__()
+        self._file_extension = "json"
+
+    @classmethod
+    def _marshal(cls, data):
+        return json.dumps(data, indent=2).encode("utf-8")
+
+    @classmethod
+    def _unmarshal(cls, data):
+        return json.loads(data)
+
+
+class _PickleSerializer(Serializer):
+    """ Pickle Serializer """
+    def __init__(self):
+        super().__init__()
+        self._file_extension = "p"
+
+    @classmethod
+    def _marshal(cls, data):
+        return pickle.dumps(data)
+
+    @classmethod
+    def _unmarshal(cls, data):
+        return pickle.loads(data)
+
+
+def get_serializer(serializer):
+    """ Obtain a serializer object
+
+    Parameters
+    ----------
+    serializer: {'json', 'pickle', yaml'}
+        The required serializer format
+
+    Returns
+    -------
+    serializer: :class:`Serializer`
+        A serializer object for handling the requested data format
+
+    Example
+    -------
+    >>> serializer = get_serializer('json')
+    """
+    if serializer.lower() == "json":
+        return _JSONSerializer()
+    if serializer.lower() == "pickle":
+        return _PickleSerializer()
+    if serializer.lower() == "yaml" and yaml is not None:
+        return _YAMLSerializer()
+    if serializer.lower() == "yaml" and yaml is None:
+        logger.warning("You must have PyYAML installed to use YAML as the serializer."
+                       "Switching to JSON as the serializer.")
+    logger.warning("Unrecognized serializer: '%s'. Returning json serializer", serializer)
+    return _JSONSerializer()
+
+
+def get_serializer_from_filename(filename):
+    """ Obtain a serializer object from a filename
+
+    Parameters
+    ----------
+    filename: str
+        Filename to determine the serializer type from
+
+    Returns
+    -------
+    serializer: :class:`Serializer`
+        A serializer object for handling the requested data format
+
+    Example
+    -------
+    >>> filename = '/path/to/json/file.json'
+    >>> serializer = get_serializer_from_filename(filename)
+    """
+    logger.debug("filename: '%s'", filename)
+    extension = os.path.splitext(filename)[1].lower()
+    logger.debug("extension: '%s'", extension)
+
+    if extension == ".json":
+        return _JSONSerializer()
+    if extension == ".p":
+        return _PickleSerializer()
+    if extension in (".yaml", ".yml") and yaml is not None:
+        return _YAMLSerializer()
+    if extension in (".yaml", ".yml") and yaml is None:
+        logger.warning("You must have PyYAML installed to use YAML as the serializer.\n"
+                       "Switching to JSON as the serializer.")
+    logger.warning("Unrecognized extension: '%s'. Returning json serializer", extension)
+    return _JSONSerializer()
diff --git a/plugins/train/model/_base.py b/plugins/train/model/_base.py
index 954b238..df561c3 100644
--- a/plugins/train/model/_base.py
+++ b/plugins/train/model/_base.py
@@ -10,7 +10,6 @@ import sys
 import time
 
 from concurrent import futures
-from json import JSONDecodeError
 
 import keras
 from keras import losses
@@ -19,7 +18,7 @@ from keras.layers import Input
 from keras.models import load_model, Model
 from keras.utils import get_custom_objects, multi_gpu_model
 
-from lib import Serializer
+from lib.serializer import get_serializer
 from lib.model.backup_restore import Backup
 from lib.model.losses import (DSSIMObjective, PenalizedLoss, gradient_loss, mask_loss_wrapper,
                               generalized_loss, l_inf_norm, gmsd_loss, gaussian_blur)
@@ -868,8 +867,8 @@ class State():
                      "config_changeable_items: '%s', no_logs: %s, pingpong: %s, "
                      "training_image_size: '%s'", self.__class__.__name__, model_dir, model_name,
                      config_changeable_items, no_logs, pingpong, training_image_size)
-        self.serializer = Serializer.get_serializer("json")
-        filename = "{}_state.{}".format(model_name, self.serializer.ext)
+        self.serializer = get_serializer("json")
+        filename = "{}_state.{}".format(model_name, self.serializer.file_extension)
         self.filename = str(model_dir / filename)
         self.name = model_name
         self.iterations = 0
@@ -947,42 +946,33 @@ class State():
     def load(self, config_changeable_items):
         """ Load state file """
         logger.debug("Loading State")
-        try:
-            with open(self.filename, "rb") as inp:
-                state = self.serializer.unmarshal(inp.read().decode("utf-8"))
-                self.name = state.get("name", self.name)
-                self.sessions = state.get("sessions", dict())
-                self.lowest_avg_loss = state.get("lowest_avg_loss", dict())
-                self.iterations = state.get("iterations", 0)
-                self.training_size = state.get("training_size", 256)
-                self.inputs = state.get("inputs", dict())
-                self.config = state.get("config", dict())
-                logger.debug("Loaded state: %s", state)
-                self.replace_config(config_changeable_items)
-        except IOError as err:
-            logger.warning("No existing state file found. Generating.")
-            logger.debug("IOError: %s", str(err))
-        except JSONDecodeError as err:
-            logger.debug("JSONDecodeError: %s:", str(err))
+        if not os.path.exists(self.filename):
+            logger.info("No existing state file found. Generating.")
+            return
+        state = self.serializer.load(self.filename)
+        self.name = state.get("name", self.name)
+        self.sessions = state.get("sessions", dict())
+        self.lowest_avg_loss = state.get("lowest_avg_loss", dict())
+        self.iterations = state.get("iterations", 0)
+        self.training_size = state.get("training_size", 256)
+        self.inputs = state.get("inputs", dict())
+        self.config = state.get("config", dict())
+        logger.debug("Loaded state: %s", state)
+        self.replace_config(config_changeable_items)
 
     def save(self, backup_func=None):
         """ Save iteration number to state file """
         logger.debug("Saving State")
         if backup_func:
             backup_func(self.filename)
-        try:
-            with open(self.filename, "wb") as out:
-                state = {"name": self.name,
-                         "sessions": self.sessions,
-                         "lowest_avg_loss": self.lowest_avg_loss,
-                         "iterations": self.iterations,
-                         "inputs": self.inputs,
-                         "training_size": self.training_size,
-                         "config": _CONFIG}
-                state_json = self.serializer.marshal(state)
-                out.write(state_json.encode("utf-8"))
-        except IOError as err:
-            logger.error("Unable to save model state: %s", str(err.strerror))
+        state = {"name": self.name,
+                 "sessions": self.sessions,
+                 "lowest_avg_loss": self.lowest_avg_loss,
+                 "iterations": self.iterations,
+                 "inputs": self.inputs,
+                 "training_size": self.training_size,
+                 "config": _CONFIG}
+        self.serializer.save(self.filename, state)
         logger.debug("Saved State")
 
     def replace_config(self, config_changeable_items):
diff --git a/scripts/convert.py b/scripts/convert.py
index a8f4e35..8caa6dd 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -13,7 +13,7 @@ import numpy as np
 from tqdm import tqdm
 
 from scripts.fsmedia import Alignments, Images, PostProcess, Utils
-from lib import Serializer
+from lib.serializer import get_serializer
 from lib.convert import Converter
 from lib.faces_detect import DetectedFace
 from lib.gpu_stats import GPUStats
@@ -419,7 +419,7 @@ class Predict():
         self.args = arguments
         self.in_queue = in_queue
         self.out_queue = queue_manager.get_queue("patch")
-        self.serializer = Serializer.get_serializer("json")
+        self.serializer = get_serializer("json")
         self.faces_count = 0
         self.verify_output = False
         self.model = self.load_model()
@@ -495,9 +495,8 @@ class Predict():
                                 "option.".format(len(statefile)))
         statefile = os.path.join(str(model_dir), statefile[0])
 
-        with open(statefile, "rb") as inp:
-            state = self.serializer.unmarshal(inp.read().decode("utf-8"))
-            trainer = state.get("name", None)
+        state = self.serializer.load(statefile)
+        trainer = state.get("name", None)
 
         if not trainer:
             raise FaceswapError("Trainer name could not be read from state file. "
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index bc866ca..5e62a9d 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -114,12 +114,7 @@ class Alignments(AlignmentsBase):
             logger.warning("Skip Existing/Skip Faces selected, but no alignments file found!")
             return data
 
-        try:
-            with open(self.file, self.serializer.roptions) as align:
-                data = self.serializer.unmarshal(align.read())
-        except IOError as err:
-            logger.error("Error: '%s' not read: %s", self.file, err.strerror)
-            exit(1)
+        data = self.serializer.load(self.file)
 
         if skip_faces:
             # Remove items from algnments that have no faces so they will
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index bfd14ff..a5f043d 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -81,7 +81,7 @@ class AlignmentData(Alignments):
 
         self.serializer = self.get_serializer("", dst_fmt)
         filename = os.path.splitext(self.file)[0]
-        self.file = "{}.{}".format(filename, self.serializer.ext)
+        self.file = "{}.{}".format(filename, self.serializer.file_extension)
         logger.debug("Destination file: '%s'", self.file)
 
     def save(self):
@@ -364,15 +364,15 @@ class ExtractedFaces():
             out_file.write(img)
         return f_hash
 
-    def align_eyes(self, face, image):
+    @staticmethod
+    def align_eyes(face, image):
         """ Re-extract a face with the pupils forced to be absolutely horizontally aligned """
         umeyama_landmarks = face.aligned_landmarks
-        leftEyeCenter = umeyama_landmarks[42:48].mean(axis=0)
-        rightEyeCenter = umeyama_landmarks[36:42].mean(axis=0)
-        eyesCenter = umeyama_landmarks[36:48].mean(axis=0)
-        dY = rightEyeCenter[1] - leftEyeCenter[1]
-        dX = rightEyeCenter[0] - leftEyeCenter[0]
-        theta = np.pi - np.arctan2(dY, dX)
+        left_eye_center = umeyama_landmarks[42:48].mean(axis=0)
+        right_eye_center = umeyama_landmarks[36:42].mean(axis=0)
+        d_y = right_eye_center[1] - left_eye_center[1]
+        d_x = right_eye_center[0] - left_eye_center[0]
+        theta = np.pi - np.arctan2(d_y, d_x)
         rot_cos = np.cos(theta)
         rot_sin = np.sin(theta)
         rotation_matrix = np.array([[rot_cos, -rot_sin, 0.],
diff --git a/tools/sort.py b/tools/sort.py
index 9baf04f..ae77c1a 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -14,7 +14,7 @@ from tqdm import tqdm
 
 # faceswap imports
 from lib.cli import FullHelpArgumentParser
-from lib import Serializer
+from lib.serializer import get_serializer_from_filename
 from lib.faces_detect import DetectedFace
 from lib.image import read_image
 from lib.queue_manager import queue_manager
@@ -69,10 +69,7 @@ class Sort():
                                                        'sort_log.json')
 
             # Set serializer based on logfile extension
-            serializer_ext = os.path.splitext(
-                self.args.log_file_path)[-1]
-            self.serializer = Serializer.get_serializer_from_ext(
-                serializer_ext)
+            self.serializer = get_serializer_from_filename(self.args.log_file_path)
 
         # Prepare sort, group and final process method names
         _sort = "sort_" + self.args.sort_method.lower()
@@ -532,8 +529,7 @@ class Sort():
     def write_to_log(self, changes):
         """ Write the changes to log file """
         logger.info("Writing sort log to: '%s'", self.args.log_file_path)
-        with open(self.args.log_file_path, 'w') as lfile:
-            lfile.write(self.serializer.marshal(changes))
+        self.serializer.save(self.args.log_file_path, changes)
 
     def reload_images(self, group_method, img_list):
         """

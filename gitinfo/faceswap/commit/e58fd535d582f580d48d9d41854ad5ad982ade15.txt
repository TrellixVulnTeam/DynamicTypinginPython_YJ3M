commit e58fd535d582f580d48d9d41854ad5ad982ade15
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Mar 6 12:10:40 2020 +0000

    bugfix: CV2-DNN aligner. Fix Assertion error when bounding box falls out of frame

diff --git a/plugins/extract/align/cv2_dnn.py b/plugins/extract/align/cv2_dnn.py
index 26b2aff..c8971ae 100644
--- a/plugins/extract/align/cv2_dnn.py
+++ b/plugins/extract/align/cv2_dnn.py
@@ -51,7 +51,7 @@ class Align(Aligner):
 
     def process_input(self, batch):
         """ Compile the detected faces for prediction """
-        faces, batch["roi"] = self.align_image(batch)
+        faces, batch["roi"], batch["offsets"] = self.align_image(batch)
         faces = self._normalize_faces(faces)
         batch["feed"] = np.array(faces, dtype="float32")[..., :3].transpose((0, 3, 1, 2))
         return batch
@@ -62,6 +62,7 @@ class Align(Aligner):
         sizes = (self.input_size, self.input_size)
         rois = []
         faces = []
+        offsets = []
         for face, image in zip(batch["detected_faces"], batch["image"]):
             box = (face.left,
                    face.top,
@@ -73,15 +74,17 @@ class Align(Aligner):
 
             # Make box square.
             roi = self.get_square_box(box_moved)
-            # Pad the image if face is outside of boundaries
-            image = self.pad_image(roi, image)
-            face = image[roi[1]: roi[3], roi[0]: roi[2]]
 
+            # Pad the image and adjust roi if face is outside of boundaries
+            image, offset = self.pad_image(roi, image)
+            face = image[roi[1] + offset[1]: roi[3] + offset[1],
+                         roi[0] + offset[0]: roi[2] + offset[0]]
             interpolation = cv2.INTER_CUBIC if face.shape[0] < self.input_size else cv2.INTER_AREA
             face = cv2.resize(face, dsize=sizes, interpolation=interpolation)
             faces.append(face)
             rois.append(roi)
-        return faces, rois
+            offsets.append(offset)
+        return faces, rois, offsets
 
     @staticmethod
     def move_box(box, offset):
@@ -120,16 +123,6 @@ class Align(Aligner):
             if diff % 2 == 1:
                 bottom += 1
 
-        # Shift the box if any points fall below zero
-        if left < 0:
-            shift_right = abs(left)
-            right += shift_right
-            left += shift_right
-        if top < 0:
-            shift_down = abs(top)
-            bottom += shift_down
-            top += shift_down
-
         # Make sure box is always square.
         assert ((right - left) == (bottom - top)), 'Box is not square.'
 
@@ -138,21 +131,23 @@ class Align(Aligner):
     @staticmethod
     def pad_image(box, image):
         """Pad image if face-box falls outside of boundaries """
-        width, height = image.shape[:2]
+        height, width = image.shape[:2]
         pad_l = 1 - box[0] if box[0] < 0 else 0
         pad_t = 1 - box[1] if box[1] < 0 else 0
         pad_r = box[2] - width if box[2] > width else 0
         pad_b = box[3] - height if box[3] > height else 0
         logger.trace("Padding: (l: %s, t: %s, r: %s, b: %s)", pad_l, pad_t, pad_r, pad_b)
-        retval = cv2.copyMakeBorder(image.copy(),
-                                    pad_t,
-                                    pad_b,
-                                    pad_l,
-                                    pad_r,
-                                    cv2.BORDER_CONSTANT,
-                                    value=(0, 0, 0))
-        logger.trace("Padded shape: %s", retval.shape)
-        return retval
+        padded_image = cv2.copyMakeBorder(image.copy(),
+                                          pad_t,
+                                          pad_b,
+                                          pad_l,
+                                          pad_r,
+                                          cv2.BORDER_CONSTANT,
+                                          value=(0, 0, 0))
+        offsets = (pad_l - pad_r, pad_t - pad_b)
+        logger.trace("image_shape: %s, Padded shape: %s, box: %s, offsets: %s",
+                     image.shape, padded_image.shape, box, offsets)
+        return padded_image, offsets
 
     def predict(self, batch):
         """ Predict the 68 point landmarks """
@@ -169,10 +164,10 @@ class Align(Aligner):
     @staticmethod
     def get_pts_from_predict(batch):
         """ Get points from predictor """
-        for prediction, roi in zip(batch["prediction"], batch["roi"]):
+        for prediction, roi, offset in zip(batch["prediction"], batch["roi"], batch["offsets"]):
             points = np.reshape(prediction, (-1, 2))
             points *= (roi[2] - roi[0])
-            points[:, 0] += roi[0]
-            points[:, 1] += roi[1]
+            points[:, 0] += (roi[0] - offset[0])
+            points[:, 1] += (roi[1] - offset[1])
             batch.setdefault("landmarks", []).append(points)
         logger.trace("Predicted Landmarks: %s", batch["landmarks"])

commit 3c83a068ffbd991b69c81dac9ea1f8b9e881b217
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Thu Sep 6 11:16:55 2018 +0100

    Add option to change dlib-cnn buffer size

diff --git a/lib/cli.py b/lib/cli.py
index f6a21d1..6cb9af5 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -9,7 +9,7 @@ import sys
 from plugins.PluginLoader import PluginLoader
 
 
-class ScriptExecutor(object):
+class ScriptExecutor():
     """ Loads the relevant script modules and executes the script.
         This class is initialised in each of the argparsers for the relevant
         command, then execute script is called within their set_default
@@ -192,7 +192,7 @@ class SmartFormatter(argparse.HelpFormatter):
         return argparse.HelpFormatter._split_lines(self, text, width)
 
 
-class FaceSwapArgs(object):
+class FaceSwapArgs():
     """ Faceswap argument parser functions that are universal
         to all commands. Should be the parent function of all
         subsequent argparsers """
@@ -341,6 +341,20 @@ class ExtractConvertArgs(FaceSwapArgs):
                                       "pyramid. Should be a decimal number "
                                       "less than one. Default is 0.709 "
                                       "(MTCNN detector only)"})
+        argument_list.append({"opts": ("-dbf", "--dlib-buffer"),
+                              "type": int,
+                              "dest": "dlib_buffer",
+                              "default": 64,
+                              "help": "This should only be increased if you "
+                                      "are having issues extracting with "
+                                      "DLib-cnn. The calculation of RAM "
+                                      "required is approximate, so some RAM "
+                                      " is held back in reserve (64MB by "
+                                      "default). If this is not enough "
+                                      "increase this figure by providing an "
+                                      "integer representing the amount of "
+                                      "megabytes to reserve. (DLIB-CNN "
+                                      "Only)"})
         argument_list.append({"opts": ("-l", "--ref_threshold"),
                               "type": float,
                               "dest": "ref_threshold",
@@ -432,8 +446,8 @@ class ExtractArgs(ExtractConvertArgs):
                               "type": int,
                               "default": None,
                               "help": "Automatically save the alignments file "
-                                      "after a set amount of frames. Will only "
-                                      "save at the end of extracting by "
+                                      "after a set amount of frames. Will "
+                                      "only save at the end of extracting by "
                                       "default. WARNING: Don't interrupt the "
                                       "script when writing the file because "
                                       "it might get corrupted."})
diff --git a/lib/face_alignment/extractor.py b/lib/face_alignment/extractor.py
index 497b58e..4677685 100644
--- a/lib/face_alignment/extractor.py
+++ b/lib/face_alignment/extractor.py
@@ -17,7 +17,7 @@ VRAM = GPUMem()
 KERAS_MODEL = KerasModel()
 
 
-class Frame(object):
+class Frame():
     """ The current frame for processing """
 
     def __init__(self, detector, input_image,
@@ -87,7 +87,7 @@ class Frame(object):
         self.input_scale = max_length_scale / max_length_image
 
 
-class Align(object):
+class Align():
     """ Perform transformation to align and get landmarks """
     def __init__(self, image, detected_faces, keras_model, verbose):
         self.verbose = verbose
@@ -235,17 +235,18 @@ class Align(object):
         return [(int(pt[0]), int(pt[1])) for pt in pts_img]
 
 
-class Extract(object):
+class Extract():
     """ Extracts faces from an image, crops and
         calculates landmarks """
 
-    def __init__(self, input_image_bgr, detector, mtcnn_kwargs=None,
-                 verbose=False, input_is_predetected_face=False):
+    def __init__(self, input_image_bgr, detector, dlib_buffer=64,
+                 mtcnn_kwargs=None, verbose=False,
+                 input_is_predetected_face=False):
         self.verbose = verbose
         self.keras = KERAS_MODEL
         self.detector = None
 
-        self.initialize(detector, mtcnn_kwargs)
+        self.initialize(detector, mtcnn_kwargs, dlib_buffer)
 
         self.frame = Frame(detector=detector,
                            input_image=input_image_bgr,
@@ -260,10 +261,10 @@ class Extract(object):
                                keras_model=self.keras,
                                verbose=self.verbose).landmarks
 
-    def initialize(self, detector, mtcnn_kwargs):
+    def initialize(self, detector, mtcnn_kwargs, dlib_buffer):
         """ initialize Keras and Dlib """
         if not VRAM.initialized:
-            self.initialize_vram(detector)
+            self.initialize_vram(detector, dlib_buffer)
 
         if not self.keras.initialized:
             self.initialize_keras(detector)
@@ -278,10 +279,12 @@ class Extract(object):
         if not self.detector.initialized:
             self.initialize_detector(detector, mtcnn_kwargs)
 
-    def initialize_vram(self, detector):
+    def initialize_vram(self, detector, dlib_buffer):
         """ Initialize vram based on detector """
         VRAM.verbose = self.verbose
         VRAM.detector = detector
+        if dlib_buffer > VRAM.dlib_buffer:
+            VRAM.dlib_buffer = dlib_buffer
         VRAM.initialized = True
         VRAM.output_stats()
 
diff --git a/lib/face_alignment/vram_allocation.py b/lib/face_alignment/vram_allocation.py
index 8580dc4..18532ea 100644
--- a/lib/face_alignment/vram_allocation.py
+++ b/lib/face_alignment/vram_allocation.py
@@ -12,6 +12,7 @@ class GPUMem():
         self.initialized = False
         self.verbose = False
         self.stats = GPUStats()
+        self.dlib_buffer = 64
         self.vram_free = None
         self.vram_total = None
         self.scale_to = None
@@ -55,7 +56,7 @@ class GPUMem():
         if self.verbose:
             if self.device == -1:
                 print("No GPU. Limiting RAM usage to "
-                      "{}MB".format(self.vram_free)) 
+                      "{}MB".format(self.vram_free))
             print("GPU VRAM free:    {}".format(self.vram_free))
 
     def output_stats(self):
@@ -119,7 +120,6 @@ class GPUMem():
         detector = "dlib" if detector in ("dlib-cnn",
                                           "dlib-hog",
                                           "dlib-all") else detector
-        buffer = 64  # 64MB overhead buffer
         gradient = 3483.2 / 9651200  # MTCNN
         constant = 1.007533156  # MTCNN
         if detector == "dlib":
@@ -127,7 +127,9 @@ class GPUMem():
             gradient = 213 / 524288
             constant = 307
 
-        free_mem = self.vram_free - buffer
+        free_mem = self.vram_free - self.dlib_buffer  # overhead buffer
+        if self.verbose:
+            print("Allocating for DLib: {}".format(free_mem))
 
         self.scale_to = int((free_mem - constant) / gradient)
 
diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index 3f56cf2..47dda81 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -4,10 +4,12 @@
 from lib import face_alignment
 
 
-def detect_faces(frame, detector, verbose, rotation=0, mtcnn_kwargs=None):
+def detect_faces(frame, detector, verbose, rotation=0,
+                 dlib_buffer=64, mtcnn_kwargs=None):
     """ Detect faces and draw landmarks in an image """
     face_detect = face_alignment.Extract(frame,
                                          detector,
+                                         dlib_buffer,
                                          mtcnn_kwargs,
                                          verbose)
     for face in face_detect.landmarks:
@@ -24,7 +26,7 @@ def detect_faces(frame, detector, verbose, rotation=0, mtcnn_kwargs=None):
                            landmarksXY=landmarks)
 
 
-class DetectedFace(object):
+class DetectedFace():
     """ Detected face and landmark information """
     def __init__(self, image=None, r=0, x=None,
                  w=None, y=None, h=None, landmarksXY=None):
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index 124652a..a4f8911 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -19,7 +19,7 @@ from lib.utils import get_folder, get_image_paths, set_system_verbosity
 from plugins.PluginLoader import PluginLoader
 
 
-class Utils(object):
+class Utils():
     """ Holds utility functions that are required by more than one media
         object """
 
@@ -82,7 +82,7 @@ class Utils(object):
         return images_found, num_faces_detected
 
 
-class Images(object):
+class Images():
     """ Holds the full frames/images """
     def __init__(self, arguments):
         self.args = arguments
@@ -165,7 +165,7 @@ class Images(object):
         return image
 
 
-class Faces(object):
+class Faces():
     """ Holds the faces """
     def __init__(self, arguments):
         self.args = arguments
@@ -227,8 +227,12 @@ class Faces(object):
     def get_faces(self, image, rotation=0):
         """ Extract the faces from an image """
         faces_count = 0
-        faces = detect_faces(image, self.args.detector, self.args.verbose,
-                             rotation=rotation, mtcnn_kwargs=self.mtcnn_kwargs)
+        faces = detect_faces(image,
+                             self.args.detector,
+                             self.args.verbose,
+                             rotation=rotation,
+                             dlib_buffer=self.args.dlib_buffer,
+                             mtcnn_kwargs=self.mtcnn_kwargs)
 
         for face in faces:
             if self.filter and not self.filter.check(face):
@@ -305,7 +309,7 @@ class Faces(object):
         return blurry_file
 
 
-class Alignments(object):
+class Alignments():
     """ Holds processes pertaining to the alignments file """
     def __init__(self, arguments):
         self.args = arguments

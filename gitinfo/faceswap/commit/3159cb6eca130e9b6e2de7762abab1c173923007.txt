commit 3159cb6eca130e9b6e2de7762abab1c173923007
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Thu Aug 29 00:03:51 2019 +0100

    GUI Fixups
    
    - GUI Bugfix: Startup options - fix min/max thresholds
    - GUI Bugfix: Make console read-only
    - GUI Bugfix: Rightclick menu for recreated widgets
    - Enhancement: Create ControlPanelOptions Class + migrate options

diff --git a/lib/gui/command.py b/lib/gui/command.py
index f237564..ca75b34 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -92,13 +92,14 @@ class CommandTab(ttk.Frame):  # pylint:disable=too-many-ancestors
         """ Build the tab """
         logger.debug("Build Tab: '%s'", self.command)
         options = get_config().cli_opts.opts[self.command]
-        info = options.get("helptext", None)
-        if info is not None:
-            del options["helptext"]
-        ControlPanel(self, options,
-                     label_width=16, option_columns=3, columns=1, header_text=info)
+        cp_opts = [val["cpanel_option"] for key, val in options.items() if key != "helptext"]
+        ControlPanel(self,
+                     cp_opts,
+                     label_width=16,
+                     option_columns=3,
+                     columns=1,
+                     header_text=options.get("helptext", None))
         self.add_frame_separator()
-
         ActionFrame(self)
         logger.debug("Built Tab: '%s'", self.command)
 
diff --git a/lib/gui/control_helper.py b/lib/gui/control_helper.py
index 603e61d..fa6abd5 100644
--- a/lib/gui/control_helper.py
+++ b/lib/gui/control_helper.py
@@ -13,29 +13,35 @@ from .utils import ContextMenu, FileHandler, get_config, get_images
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
-# We store Tooltips globally when they are created
-# Because we need to add them back to newly cloned widgets
-_TOOLTIPS = dict()
-
-# We store commands globally when they are created
-# Because we need to add them back to newly cloned widgets
-_COMMANDS = dict()
+# We store Tooltips, ContextMenus and Commands globally when they are created
+# Because we need to add them back to newly cloned widgets (they are not easily accessible from
+# original config or are prone to getting destroyed when the original widget is destroyed)
+_RECREATE_OBJECTS = dict(tooltips=dict(), commands=dict(), contextmenus=dict())
 
 
 def get_tooltip(widget, text, wraplength=600):
     """ Store the tooltip layout and widget id in _TOOLTIPS and return a tooltip """
-    _TOOLTIPS[str(widget)] = {"text": text,
-                              "wraplength": wraplength}
+    _RECREATE_OBJECTS["tooltips"][str(widget)] = {"text": text,
+                                                  "wraplength": wraplength}
     logger.debug("Adding to tooltips dict: (widget: %s. text: '%s', wraplength: %s)",
                  widget, text, wraplength)
     return Tooltip(widget, text=text, wraplength=wraplength)
 
 
+def get_contextmenu(widget):
+    """ Create a context menu, store its mapping and return """
+    rc_menu = ContextMenu(widget)
+    _RECREATE_OBJECTS["contextmenus"][str(widget)] = rc_menu
+    logger.debug("Adding to Context menu: (widget: %s. rc_menu: %s)",
+                 widget, rc_menu)
+    return rc_menu
+
+
 def add_command(name, func):
     """ For controls that execute commands, the command must be added to the _COMMAND list so that
         it can be added back to the widget during cloning """
     logger.debug("Adding to commands: %s - %s", name, func)
-    _COMMANDS[name] = func
+    _RECREATE_OBJECTS["commands"][name] = func
 
 
 def set_slider_rounding(value, var, d_type, round_to, min_max):
@@ -54,13 +60,202 @@ def adjust_wraplength(event):
     label.configure(wraplength=event.width - 1)
 
 
+class ControlPanelOption():
+    """
+    A class to hold a control panel option. A list of these is expected
+    to be passed to the ControlPanel object.
+
+    Parameters
+    ----------
+    title: str
+        Title of the control. Will be used for label text and control naming
+    dtype: datatype object
+        Datatype of the control.
+    group: str, optional
+        The group that this control should sit with. If provided, all controls in the same
+        group will be placed together. Default: None
+    default: str, optional
+        Default value for the control. If None is provided, then action will be dictated by
+        whether "blank_nones" is set in ControlPanel
+    initial_value: str, optional
+        Initial value for the control. If None, default will be used
+    choices: list or tuple, object
+        Used for combo boxes and radio control option setting
+    is_radio: bool, optional
+        Specifies to use a Radio control instead of combobox if choices are passed
+    rounding: int or float, optional
+        For slider controls. Sets the stepping
+    min_max: int or float, optional
+        For slider controls. Sets the min and max values
+    sysbrowser: dict, optional
+        Adds Filesystem browser buttons to ttk.Entry options.
+        Expects a dict: {sysbrowser: str, filetypes: str}
+    helptext: str, optional
+        Sets the tooltip text
+    """
+
+    def __init__(self, title, dtype,  # pylint:disable=too-many-arguments
+                 group=None, default=None, initial_value=None, choices=None, is_radio=False,
+                 rounding=None, min_max=None, sysbrowser=None, helptext=None):
+        logger.debug("Initializing %s: (title: '%s', dtype: %s, group: %s, default: %s, "
+                     "initial_value: %s, choices: %s, is_radio: %s, rounding: %s, min_max: %s, "
+                     "sysbrowser: %s, helptext: '%s')", self.__class__.__name__, title, dtype,
+                     group, default, initial_value, choices, is_radio, rounding, min_max,
+                     sysbrowser, helptext)
+
+        self.dtype = dtype
+        self.sysbrowser = sysbrowser
+        self._options = dict(title=title,
+                             group=group,
+                             default=default,
+                             initial_value=initial_value,
+                             choices=choices,
+                             is_radio=is_radio,
+                             rounding=rounding,
+                             min_max=min_max,
+                             helptext=helptext)
+        self.control = self.get_control()
+        self.tk_var = self.get_tk_var()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    @property
+    def name(self):
+        """ Lowered title for naming """
+        return self._options["title"].lower()
+
+    @property
+    def title(self):
+        """ Title case title for naming with underscores removed """
+        return self._options["title"].replace("_", " ").title()
+
+    @property
+    def group(self):
+        """ Return group or _master if no group set """
+        group = self._options["group"]
+        group = "_master" if group is None else group
+        return group
+
+    @property
+    def default(self):
+        """ Return either selected value or default """
+        return self._options["default"]
+
+    @property
+    def value(self):
+        """ Return either selected value or default """
+        val = self._options["initial_value"]
+        val = self.default if val is None else val
+        return val
+
+    @property
+    def choices(self):
+        """ Return choices """
+        return self._options["choices"]
+
+    @property
+    def is_radio(self):
+        """ Return is_radio """
+        return self._options["is_radio"]
+
+    @property
+    def rounding(self):
+        """ Return rounding """
+        return self._options["rounding"]
+
+    @property
+    def min_max(self):
+        """ Return min_max """
+        return self._options["min_max"]
+
+    @property
+    def helptext(self):
+        """ Format and return help text for tooltips """
+        helptext = self._options["helptext"]
+        if helptext is None:
+            return helptext
+        logger.debug("Format control help: '%s'", self.name)
+        if helptext.startswith("R|"):
+            helptext = helptext[2:].replace("\nL|", "\n - ").replace("\n", "\n\n")
+        else:
+            helptext = helptext.replace("\n\t", "\n - ").replace("%%", "%")
+        helptext = ". ".join(i.capitalize() for i in helptext.split(". "))
+        helptext = self.title + " - " + helptext
+        logger.debug("Formatted control help: (name: '%s', help: '%s'", self.name, helptext)
+        return helptext
+
+    def get(self):
+        """ Return the value from the tk_var """
+        return self.tk_var.get()
+
+    def set(self, value):
+        """ Set the tk_var to a new value """
+        self.tk_var.set(value)
+
+    def get_control(self):
+        """ Set the correct control type based on the datatype or for this option """
+        if self.choices and self.is_radio:
+            control = ttk.Radiobutton
+        elif self.choices:
+            control = ttk.Combobox
+        elif self.dtype == bool:
+            control = ttk.Checkbutton
+        elif self.dtype in (int, float):
+            control = ttk.Scale
+        else:
+            control = ttk.Entry
+        logger.debug("Setting control '%s' to %s", self.title, control)
+        return control
+
+    def get_tk_var(self):
+        """ Correct variable type for control """
+        if self.dtype == bool:
+            var = tk.BooleanVar()
+        elif self.dtype == int:
+            var = tk.IntVar()
+        elif self.dtype == float:
+            var = tk.DoubleVar()
+        else:
+            var = tk.StringVar()
+        logger.debug("Setting tk variable: (name: '%s', dtype: %s, tk_var: %s)",
+                     self.name, self.dtype, var)
+        return var
+
+
 class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
-    """ A Panel for holding controls
-        Also keeps tally if groups passed in, so that any options with special
-        processing needs are processed in the correct group frame """
+    """
+    A Control Panel to hold control panel options.
+    This class handles all of the formatting, placing and TK_Variables
+    in a consistent manner.
+
+    It can also provide dynamic columns for resizing widgets
 
-    def __init__(self, parent, options, label_width=20, columns=1, option_columns=4,
-                 header_text=None, blank_nones=True):
+    Parameters
+    ----------
+    parent: tk object
+        Parent widget that should hold this control panel
+    options: list of  ControlPanelOptions objects
+        The list of controls that are to be built into this control panel
+    label_width: int, optional
+        The width that labels for controls should be set to.
+        Defaults to 20
+    columns: int, optional
+        The maximum number of columns that this control panel should be able
+        to accomodate. Setting to 1 means that there will only be 1 column
+        regardless of how wide the control panel is. Higher numbers will
+        dynamically fill extra columns if space permits. Defaults to 1
+    option_columns: int, optional
+        For checkbutton and radiobutton containers, how many options should
+        be displayed on each row. Defaults to 4
+    header_text: str, optional
+        If provided, will place an information box at the top of the control
+        panel with these contents.
+    blank_nones: bool, optional
+        How the control panel should handle Nones. If set to True then Nones
+        will be converted to empty strings. Default: False
+    """
+
+    def __init__(self, parent, options,  # pylint:disable=too-many-arguments
+                 label_width=20, columns=1, option_columns=4, header_text=None, blank_nones=True):
         logger.debug("Initializing %s: (parent: '%s', options: %s, label_width: %s, columns: %s, "
                      "option_columns: %s, header_text: %s, blank_nones: %s)",
                      self.__class__.__name__, parent, options, label_width, columns,
@@ -70,6 +265,7 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         self.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
 
         self.options = options
+        self.controls = []
         self.label_width = label_width
         self.columns = columns
         self.option_columns = option_columns
@@ -126,34 +322,20 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         self.add_scrollbar()
         self.canvas.bind("<Configure>", self.resize_frame)
 
-        for key, val in self.options.items():
-            if key == "helptext":
-                continue
-            group = "_master" if val["group"] is None else val["group"]
-            group_frame = self.get_group_frame(group)
+        for option in self.options:
+            group_frame = self.get_group_frame(option.group)
             ctl = ControlBuilder(group_frame["frame"],
-                                 key,
-                                 val["type"],
-                                 val["default"],
+                                 option,
                                  label_width=self.label_width,
-                                 selected_value=val["value"],
-                                 choices=val["choices"],
-                                 is_radio=val["gui_radio"],
-                                 rounding=val["rounding"],
-                                 min_max=val["min_max"],
-                                 helptext=val["helptext"],
-                                 sysbrowser=val.get("sysbrowser", None),
                                  checkbuttons_frame=group_frame["chkbtns"],
                                  option_columns=self.option_columns,
                                  blank_nones=blank_nones)
             if group_frame["chkbtns"].items > 0:
                 group_frame["chkbtns"].parent.pack(side=tk.BOTTOM, fill=tk.X, anchor=tk.NW)
-            val["selected"] = ctl.tk_var
-            self.options[key]["_gui_option"] = ctl
-        for key, val in self.options.items():
-            if key == "helptext":
-                continue
-            filebrowser = val["_gui_option"].filebrowser
+
+            self.controls.append(ctl)
+        for control in self.controls:
+            filebrowser = control.filebrowser
             if filebrowser is not None:
                 filebrowser.set_context_action_option(self.options)
         logger.debug("Added Config Frame")
@@ -269,17 +451,10 @@ class AutoFillContainer():
 
     def rearrange_columns(self, width):
         """ On column number change redistribute widgets """
-        if not self.single_column_width < width < self.max_width:
-            logger.debug("width outside min/max thresholds: (min: %s, width: %s, max: %s)",
-                         self.single_column_width, width, self.max_width)
+        if not self.validate(width):
             return
-        range_min = self.columns * self.single_column_width
-        range_max = (self.columns + 1) * self.single_column_width
-        if range_min < width < range_max:
-            logger.debug("width outside next step refresh threshold: (step down: %s, width: %s,"
-                         "step up: %s)", range_min, width, range_max)
-            return
-        new_columns = width // self.single_column_width
+
+        new_columns = min(self.max_columns, max(1, width // self.single_column_width))
         logger.debug("Rearranging columns: (width: %s, old_columns: %s, new_columns: %s)",
                      width, self.columns, new_columns)
         self.columns = new_columns
@@ -289,13 +464,29 @@ class AutoFillContainer():
         self.repack_columns()
         self.pack_widget_clones(self._widget_config)
 
+    def validate(self, width):
+        """ Validate that passed in width should trigger column re-arranging """
+        if ((width < self.single_column_width and self.columns == 1) or
+                (width > self.max_width and self.columns == self.max_columns)):
+            logger.debug("width outside min/max thresholds: (min: %s, width: %s, max: %s)",
+                         self.single_column_width, width, self.max_width)
+            return False
+        range_min = self.columns * self.single_column_width
+        range_max = (self.columns + 1) * self.single_column_width
+        if range_min < width < range_max:
+            logger.debug("width outside next step refresh threshold: (step down: %s, width: %s,"
+                         "step up: %s)", range_min, width, range_max)
+            return False
+        return True
+
     def compile_widget_config(self):
         """ Compile all children recursively in correct order if not already compiled """
         zipped = zip_longest(*(subframe.winfo_children() for subframe in self.subframes))
         children = [child for group in zipped for child in group if child is not None]
         self._widget_config = [{"class": child.__class__,
                                 "id": str(child),
-                                "tooltip": _TOOLTIPS.get(str(child), None),
+                                "tooltip": _RECREATE_OBJECTS["tooltips"].get(str(child), None),
+                                "rc_menu": _RECREATE_OBJECTS["contextmenus"].get(str(child), None),
                                 "pack_info": self.pack_config_cleaner(child),
                                 "name": child.winfo_name(),
                                 "config": self.config_cleaner(child),
@@ -308,13 +499,15 @@ class AutoFillContainer():
         for child in widget.winfo_children():
             if child.winfo_ismapped():
                 id_ = str(child)
-                child_list.append({"class": child.__class__,
-                                   "id": id_,
-                                   "tooltip": _TOOLTIPS.get(id_, None),
-                                   "pack_info": self.pack_config_cleaner(child),
-                                   "name": child.winfo_name(),
-                                   "config": self.config_cleaner(child),
-                                   "parent": child.winfo_parent()})
+                child_list.append({
+                    "class": child.__class__,
+                    "id": id_,
+                    "tooltip": _RECREATE_OBJECTS["tooltips"].get(id_, None),
+                    "rc_menu": _RECREATE_OBJECTS["contextmenus"].get(str(id_), None),
+                    "pack_info": self.pack_config_cleaner(child),
+                    "name": child.winfo_name(),
+                    "config": self.config_cleaner(child),
+                    "parent": child.winfo_parent()})
             self.get_all_children_config(child, child_list)
         return child_list
 
@@ -332,7 +525,7 @@ class AutoFillContainer():
             if key in ("anchor", "justify") and val == "":
                 continue
             # Return correct command from master command dict
-            val = _COMMANDS[val] if key == "command" and val != "" else val
+            val = _RECREATE_OBJECTS["commands"][val] if key == "command" and val != "" else val
             new_config[key] = val
         return new_config
 
@@ -373,6 +566,11 @@ class AutoFillContainer():
                 clone.configure(**widget_dict["config"])
             if widget_dict["tooltip"] is not None:
                 Tooltip(clone, **widget_dict["tooltip"])
+            rc_menu = widget_dict["rc_menu"]
+            if rc_menu is not None:
+                # Re-initialize for new widget and bind
+                rc_menu.__init__(widget=clone)
+                rc_menu.cm_bind()
             clone.pack(**widget_dict["pack_info"])
             old_children.append(widget_dict["id"])
             new_children.append(clone)
@@ -383,197 +581,101 @@ class AutoFillContainer():
 class ControlBuilder():
     """
     Builds and returns a frame containing a tkinter control with label
-
-    Currently only setup for config items
+    This should only be called from the ControlPanel class
 
     Parameters
     ----------
     parent: tkinter object
         Parent tkinter object
-    title: str
-        Title of the control. Will be used for label text
-    dtype: datatype object
-        Datatype of the control.
-    default: str
-        Default value for the control
-    selected_value: str, optional
-        Selected value for the control. If None, default will be used
-    choices: list or tuple, object
-        Used for combo boxes and radio control option setting
-    is_radio: bool, optional
-        Specifies to use a Radio control instead of combobox if choices are passed
-    rounding: int or float, optional
-        For slider controls. Sets the stepping
-    min_max: int or float, optional
-        For slider controls. Sets the min and max values
-    sysbrowser: dict, optional
-        Adds Filesystem browser buttons to ttk.Entry options.
-        Expects a dict: {sysbrowser: str, filetypes: str}
-    helptext: str, optional
-        Sets the tooltip text
-    option_columns: int, optional
-        Sets the number of columns to use for grouping radio buttons
-    label_width: int, optional
-        Sets the width of the control label. Defaults to 20
-    checkbuttons_frame: tk.frame, optional
+    option: ControlPanelOption object
+        Holds all of the required option information
+    option_columns: int
+        Number of options to put on a single row for checkbuttons/radiobuttons
+    label_width: int
+        Sets the width of the control label
+    checkbuttons_frame: tk.frame
         If a checkbutton frame is passed in, then checkbuttons will be placed in this frame
         rather than the main options frame
-    control_width: int, optional
-        Sets the width of the control. Default is to auto expand
-    blank_nones: bool, optional
-        Sets selected values to an empty string rather than None if this is true. Default is true
+    blank_nones: bool
+        Sets selected values to an empty string rather than None if this is true.
     """
-    def __init__(self, parent, title, dtype, default,
-                 selected_value=None, choices=None, is_radio=False, rounding=None,
-                 min_max=None, sysbrowser=None, helptext=None, option_columns=3, label_width=20,
-                 checkbuttons_frame=None, control_width=None, blank_nones=True):
-        logger.debug("Initializing %s: (parent: %s, title: %s, dtype: %s, default: %s, "
-                     "selected_value: %s, choices: %s, is_radio: %s, rounding: %s, min_max: %s, "
-                     "sysbrowser: %s, helptext: %s, option_columns: %s, label_width: %s, "
-                     "checkbuttons_frame: %s, control_width: %s, blank_nones: %s)",
-                     self.__class__.__name__, parent, title, dtype, default, selected_value,
-                     choices, is_radio, rounding, min_max, sysbrowser, helptext, option_columns,
-                     label_width, checkbuttons_frame, control_width, blank_nones)
-
-        self.title = title
-        self.default = default
-        self.helptext = self.format_helptext(helptext)
+    def __init__(self, parent, option, option_columns, label_width,  # pylint: disable=too-many-arguments
+                 checkbuttons_frame, blank_nones):
+        logger.debug("Initializing %s: (parent: %s, option: %s, option_columns: %s, "
+                     "label_width: %s, checkbuttons_frame: %s, blank_nones: %s)",
+                     self.__class__.__name__, parent, option, option_columns, label_width,
+                     checkbuttons_frame, blank_nones)
+
+        self.option = option
+        self.option_columns = option_columns
         self.helpset = False
         self.label_width = label_width
         self.filebrowser = None
 
         self.frame = self.control_frame(parent)
         self.chkbtns = checkbuttons_frame
-        self.control = self.set_control(dtype, choices, is_radio)
-        self.tk_var = self.set_tk_var(dtype, selected_value, blank_nones)
-
-        self.build_control(choices,
-                           dtype,
-                           rounding,
-                           min_max,
-                           sysbrowser,
-                           option_columns,
-                           control_width)
+
+        self.set_tk_var(blank_nones)
+        self.build_control()
         logger.debug("Initialized: %s", self.__class__.__name__)
 
     # Frame, control type and varable
     def control_frame(self, parent):
         """ Frame to hold control and it's label """
         logger.debug("Build control frame")
-        frame = ttk.Frame(parent, name="fr_{}".format(self.title.lower()))
+        frame = ttk.Frame(parent, name="fr_{}".format(self.option.name))
         frame.pack(fill=tk.X)
         logger.debug("Built control frame")
         return frame
 
-    def format_helptext(self, helptext):
-        """ Format the help text for tooltips """
-        if helptext is None:
-            return helptext
-        logger.debug("Format control help: '%s'", self.title)
-        if helptext.startswith("R|"):
-            helptext = helptext[2:].replace("\nL|", "\n - ").replace("\n", "\n\n")
-        else:
-            helptext = helptext.replace("\n\t", "\n - ").replace("%%", "%")
-        helptext = ". ".join(i.capitalize() for i in helptext.split(". "))
-        helptext = self.title + " - " + helptext
-        logger.debug("Formatted control help: (title: '%s', help: '%s'", self.title, helptext)
-        return helptext
-
-    def set_control(self, dtype, choices, is_radio):
-        """ Set the correct control type based on the datatype or for this option """
-        if choices and is_radio:
-            control = ttk.Radiobutton
-        elif choices:
-            control = ttk.Combobox
-        elif dtype == bool:
-            control = ttk.Checkbutton
-        elif dtype in (int, float):
-            control = ttk.Scale
-        else:
-            control = ttk.Entry
-        logger.debug("Setting control '%s' to %s", self.title, control)
-        return control
-
-    def set_tk_var(self, dtype, selected_value, blank_nones):
+    def set_tk_var(self, blank_nones):
         """ Correct variable type for control """
-        logger.debug("Setting tk variable: (title: '%s', dtype: %s, selected_value: %s, "
-                     "blank_nones: %s)",
-                     self.title, dtype, selected_value, blank_nones)
-        if dtype == bool:
-            var = tk.BooleanVar
-        elif dtype == int:
-            var = tk.IntVar
-        elif dtype == float:
-            var = tk.DoubleVar
-        else:
-            var = tk.StringVar
-        var = var(self.frame)
-        val = self.default if selected_value is None else selected_value
-        val = "" if val is None and blank_nones else val
-        var.set(val)
-        logger.debug("Set tk variable: (title: '%s', type: %s, value: '%s')",
-                     self.title, type(var), val)
-        return var
+        val = "" if self.option.value is None and blank_nones else self.option.value
+        self.option.tk_var.set(val)
+        logger.debug("Set tk variable: (option: '%s', variable: %s, value: '%s')",
+                     self.option.name, self.option.tk_var, val)
 
     # Build the full control
-    def build_control(self, choices, dtype, rounding, min_max, sysbrowser, option_columns,
-                      control_width):
+    def build_control(self):
         """ Build the correct control type for the option passed through """
         logger.debug("Build config option control")
-        if self.control not in (ttk.Checkbutton, ttk.Radiobutton):
+        if self.option.control not in (ttk.Checkbutton, ttk.Radiobutton):
             self.build_control_label()
-        self.build_one_control(choices,
-                               dtype,
-                               rounding,
-                               min_max,
-                               sysbrowser,
-                               option_columns,
-                               control_width)
+        self.build_one_control()
         logger.debug("Built option control")
 
     def build_control_label(self):
         """ Label for control """
-        logger.debug("Build control label: (title: '%s')", self.title)
-        title = self.title.replace("_", " ").title()
-        lbl = ttk.Label(self.frame, text=title, width=self.label_width, anchor=tk.W)
+        logger.debug("Build control label: (option: '%s')", self.option.name)
+        lbl = ttk.Label(self.frame, text=self.option.title, width=self.label_width, anchor=tk.W)
         lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
-        if self.helptext is not None:
-            get_tooltip(lbl, text=self.helptext, wraplength=600)
-        logger.debug("Built control label: '%s'", self.title)
+        if self.option.helptext is not None:
+            get_tooltip(lbl, text=self.option.helptext, wraplength=600)
+        logger.debug("Built control label: (widget: '%s', title: '%s'",
+                     self.option.name, self.option.title)
 
-    def build_one_control(self, choices, dtype, rounding, min_max,
-                          sysbrowser, option_columns, control_width):
+    def build_one_control(self):
         """ Build and place the option controls """
-        logger.debug("Build control: (title: '%s', control: %s, choices: %s, dtype: %s, "
-                     "rounding: %s, sysbrowser: %s, min_max: %s: option_columns: %s, "
-                     "control_width: %s)", self.title, self.control, choices, dtype, rounding,
-                     sysbrowser, min_max, option_columns, control_width)
-        if self.control == ttk.Scale:
-            ctl = self.slider_control(dtype, rounding, min_max)
-        elif self.control == ttk.Radiobutton:
-            ctl = self.radio_control(choices, option_columns)
-        elif self.control == ttk.Checkbutton:
+        logger.debug("Build control: '%s')", self.option.name)
+        if self.option.control == ttk.Scale:
+            ctl = self.slider_control()
+        elif self.option.control == ttk.Radiobutton:
+            ctl = self.radio_control()
+        elif self.option.control == ttk.Checkbutton:
             ctl = self.control_to_checkframe()
         else:
-            ctl = self.control_to_optionsframe(choices, sysbrowser)
-        self.set_control_width(ctl, control_width)
-        if self.control != ttk.Checkbutton:
+            ctl = self.control_to_optionsframe()
+        if self.option.control != ttk.Checkbutton:
             ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
-            if self.helptext is not None and not self.helpset:
-                get_tooltip(ctl, text=self.helptext, wraplength=600)
+            if self.option.helptext is not None and not self.helpset:
+                get_tooltip(ctl, text=self.option.helptext, wraplength=600)
 
-        logger.debug("Built control: '%s'", self.title)
+        logger.debug("Built control: '%s'", self.option.name)
 
-    @staticmethod
-    def set_control_width(ctl, control_width):
-        """ Set the control width if required """
-        if control_width is not None:
-            ctl.config(width=control_width)
-
-    def radio_control(self, choices, columns):
+    def radio_control(self):
         """ Create a group of radio buttons """
-        logger.debug("Adding radio group: %s", self.title)
-        all_help = [line for line in self.helptext.splitlines()]
+        logger.debug("Adding radio group: %s", self.option.name)
+        all_help = [line for line in self.option.helptext.splitlines()]
         if any(line.startswith(" - ") for line in all_help):
             intro = all_help[0]
         helpitems = {re.sub(r'[^A-Za-z0-9\-]+', '',
@@ -581,15 +683,14 @@ class ControlBuilder():
                      for line in all_help
                      if line.startswith(" - ")}
         ctl = ttk.LabelFrame(self.frame,
-                             text=self.title.replace("_", " ").title(),
+                             text=self.option.title,
                              name="radio_labelframe")
-        radio_holder = AutoFillContainer(ctl, columns)
-        for idx, choice in enumerate(choices):
-            frame_id = idx % columns
+        radio_holder = AutoFillContainer(ctl, self.option_columns)
+        for choice in self.option.choices:
             radio = ttk.Radiobutton(radio_holder.subframe,
-                                    text=choice.title(),
+                                    text=choice.replace("_", " ").title(),
                                     value=choice,
-                                    variable=self.tk_var)
+                                    variable=self.option.tk_var)
             if choice.lower() in helpitems:
                 self.helpset = True
                 helptext = helpitems[choice.lower()].capitalize()
@@ -598,64 +699,67 @@ class ControlBuilder():
                     intro)
                 get_tooltip(radio, text=helptext, wraplength=600)
             radio.pack(anchor=tk.W)
-            logger.debug("Adding radio option %s to column %s", choice, frame_id)
+            logger.debug("Added radio option %s", choice)
         return radio_holder.parent
 
-    def slider_control(self, dtype, rounding, min_max):
+    def slider_control(self):
         """ A slider control with corresponding Entry box """
-        logger.debug("Add slider control to Options Frame: (title: '%s', dtype: %s, rounding: %s, "
-                     "min_max: %s)", self.title, dtype, rounding, min_max)
+        logger.debug("Add slider control to Options Frame: (widget: '%s', dtype: %s, "
+                     "rounding: %s, min_max: %s)", self.option.name, self.option.dtype,
+                     self.option.rounding, self.option.min_max)
         tbox = ttk.Entry(self.frame,
                          width=8,
-                         textvariable=self.tk_var,
+                         textvariable=self.option.tk_var,
                          justify=tk.RIGHT,
                          font=get_config().default_font)
         tbox.pack(padx=(0, 5), side=tk.RIGHT)
         cmd = partial(set_slider_rounding,
-                      var=self.tk_var,
-                      d_type=dtype,
-                      round_to=rounding,
-                      min_max=min_max)
-        ctl = self.control(self.frame, variable=self.tk_var, command=cmd)
+                      var=self.option.tk_var,
+                      d_type=self.option.dtype,
+                      round_to=self.option.rounding,
+                      min_max=self.option.min_max)
+        ctl = self.option.control(self.frame, variable=self.option.tk_var, command=cmd)
         add_command(ctl.cget("command"), cmd)
-        rc_menu = ContextMenu(tbox)
+        rc_menu = get_contextmenu(tbox)
         rc_menu.cm_bind()
-        ctl["from_"] = min_max[0]
-        ctl["to"] = min_max[1]
-        logger.debug("Added slider control to Options Frame: %s", self.title)
+        ctl["from_"] = self.option.min_max[0]
+        ctl["to"] = self.option.min_max[1]
+        logger.debug("Added slider control to Options Frame: %s", self.option.name)
         return ctl
 
-    def control_to_optionsframe(self, choices, sysbrowser):
+    def control_to_optionsframe(self):
         """ Standard non-check buttons sit in the main options frame """
-        logger.debug("Add control to Options Frame: (title: '%s', control: %s, choices: %s)",
-                     self.title, self.control, choices)
-        if self.control == ttk.Checkbutton:
-            ctl = self.control(self.frame, variable=self.tk_var, text=None)
+        logger.debug("Add control to Options Frame: (widget: '%s', control: %s, choices: %s)",
+                     self.option.name, self.option.control, self.option.choices)
+        if self.option.control == ttk.Checkbutton:
+            ctl = self.option.control(self.frame, variable=self.option.tk_var, text=None)
         else:
-            if sysbrowser is not None:
-                self.filebrowser = FileBrowser(self.tk_var, self.frame, sysbrowser)
-            ctl = self.control(self.frame,
-                               textvariable=self.tk_var,
-                               font=get_config().default_font)
-            rc_menu = ContextMenu(ctl)
+            if self.option.sysbrowser is not None:
+                self.filebrowser = FileBrowser(self.option.tk_var,
+                                               self.frame,
+                                               self.option.sysbrowser)
+            ctl = self.option.control(self.frame,
+                                      textvariable=self.option.tk_var,
+                                      font=get_config().default_font)
+            rc_menu = get_contextmenu(ctl)
             rc_menu.cm_bind()
-        if choices:
-            logger.debug("Adding combo choices: %s", choices)
-            ctl["values"] = [choice for choice in choices]
-        logger.debug("Added control to Options Frame: %s", self.title)
+        if self.option.choices:
+            logger.debug("Adding combo choices: %s", self.option.choices)
+            ctl["values"] = [choice for choice in self.option.choices]
+        logger.debug("Added control to Options Frame: %s", self.option.name)
         return ctl
 
     def control_to_checkframe(self):
         """ Add checkbuttons to the checkbutton frame """
-        logger.debug("Add control checkframe: '%s'", self.title)
+        logger.debug("Add control checkframe: '%s'", self.option.name)
         chkframe = self.chkbtns.subframe
-        ctl = self.control(chkframe,
-                           variable=self.tk_var,
-                           text=self.title.replace("_", " ").title(),
-                           name=self.title.lower())
-        get_tooltip(ctl, text=self.helptext, wraplength=600)
+        ctl = self.option.control(chkframe,
+                                  variable=self.option.tk_var,
+                                  text=self.option.title,
+                                  name=self.option.name)
+        get_tooltip(ctl, text=self.option.helptext, wraplength=600)
         ctl.pack(side=tk.TOP, anchor=tk.W)
-        logger.debug("Added control checkframe: '%s'", self.title)
+        logger.debug("Added control checkframe: '%s'", self.option.name)
         return ctl
 
 
@@ -668,7 +772,7 @@ class FileBrowser():
         self.frame = control_frame
         self.browser = sysbrowser_dict["browser"]
         self.filetypes = sysbrowser_dict["filetypes"]
-        self.action_option = sysbrowser_dict.get("action_option", None)
+        self.action_option = self.format_action_option(sysbrowser_dict.get("action_option", None))
         self.command = sysbrowser_dict.get("command", None)
         self.destination = sysbrowser_dict.get("destination", None)
         self.add_browser_buttons()
@@ -684,6 +788,17 @@ class FileBrowser():
                       save="Select a save location...")
         return retval
 
+    @staticmethod
+    def format_action_option(action_option):
+        """ Format the action option to remove any dashes at the start """
+        if action_option is None:
+            return action_option
+        if action_option.startswith("--"):
+            return action_option[2:]
+        if action_option.startswith("-"):
+            return action_option[1:]
+        return action_option
+
     def add_browser_buttons(self):
         """ Add correct file browser button for control """
         logger.debug("Adding browser buttons: (sysbrowser: %s", self.browser)
@@ -703,8 +818,7 @@ class FileBrowser():
             that dictates the context sensitive file browser. """
         if self.browser != ["context"]:
             return
-        actions = {item["opts"][0]: item["selected"]
-                   for item in options.values()}
+        actions = {opt.name: opt.tk_var for opt in options}
         logger.debug("Settiong action option for opt %s", self.action_option)
         self.action_option = actions[self.action_option]
 
diff --git a/lib/gui/options.py b/lib/gui/options.py
index fbd8983..124f609 100644
--- a/lib/gui/options.py
+++ b/lib/gui/options.py
@@ -9,6 +9,7 @@ from collections import OrderedDict
 from lib import cli
 import tools.cli as ToolsCli
 from .utils import get_images
+from .control_helper import ControlPanelOption
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -94,20 +95,21 @@ class CliOptions():
                 logger.trace("Skipping suppressed option: %s", opt)
                 continue
             title = self.set_control_title(opt["opts"])
-            gui_options[title] = {
-                "type": self.get_data_type(opt),
-                "default": opt.get("default", None),
-                "value": opt.get("default", ""),
-                "choices": opt.get("choices", None),
-                "gui_radio": opt.get("action", "") == cli.Radio,
-                "rounding": self.get_rounding(opt),
-                "min_max": opt.get("min_max", None),
-                "sysbrowser": self.get_sysbrowser(opt, command),
-                "group": opt.get("group", None),
-                "helptext": opt["help"],
-                "opts": opt["opts"],
-                "nargs": opt.get("nargs", None)}
-            logger.trace("Processed: %s", opt)
+            cpanel_option = ControlPanelOption(
+                title,
+                self.get_data_type(opt),
+                group=opt.get("group", None),
+                default=opt.get("default", None),
+                choices=opt.get("choices", None),
+                is_radio=opt.get("action", "") == cli.Radio,
+                rounding=self.get_rounding(opt),
+                min_max=opt.get("min_max", None),
+                sysbrowser=self.get_sysbrowser(opt, command_options, command),
+                helptext=opt["help"])
+            gui_options[title] = dict(cpanel_option=cpanel_option,
+                                      opts=opt["opts"],
+                                      nargs=opt.get("nargs", None))
+            logger.trace("Processed: %s", gui_options)
         return gui_options
 
     @staticmethod
@@ -140,8 +142,7 @@ class CliOptions():
             retval = None
         return retval
 
-    @staticmethod
-    def get_sysbrowser(option, command):
+    def get_sysbrowser(self, option, options, command):
         """ Return the system file browser and file types if required else None """
         action = option.get("action", None)
         if action not in (cli.FullPaths,
@@ -154,7 +155,10 @@ class CliOptions():
             return None
 
         retval = dict()
-        action_option = option.get("action_option", None)
+        action_option = None
+        if option.get("action_option", None) is not None:
+            self.expand_action_option(option, options)
+            action_option = option["action_option"]
         retval["filetypes"] = option.get("filetypes", "default")
         if action == cli.FileFullPaths:
             retval["browser"] = ["load"]
@@ -174,19 +178,31 @@ class CliOptions():
         logger.debug(retval)
         return retval
 
+    @staticmethod
+    def expand_action_option(option, options):
+        """ Expand the action option to the full command name """
+        opts = {opt["opts"][0]: opt["opts"][-1]
+                for opt in options}
+        old_val = option["action_option"]
+        new_val = opts[old_val]
+        logger.debug("Updating action option from '%s' to '%s'", old_val, new_val)
+        option["action_option"] = new_val
+
     def gen_command_options(self, command):
         """ Yield each option for specified command """
         for key, val in self.opts[command].items():
+            if not isinstance(val, dict):
+                continue
             yield key, val
 
     def options_to_process(self, command=None):
-        """ Return a consistent object for processing
-            regardless of whether processing all commands
-            or just one command for reset and clear """
+        """ Return a consistent object for processing regardless of whether processing all commands
+            or just one command for reset and clear. Removes helptext from return value """
         if command is None:
-            options = [opt for opts in self.opts.values() for opt in opts.values()]
+            options = [opt for opts in self.opts.values()
+                       for opt in opts.values() if isinstance(opt, dict)]
         else:
-            options = [opt for opt in self.opts[command].values()]
+            options = [opt for opt in self.opts[command].values() if isinstance(opt, dict)]
         return options
 
     def reset(self, command=None):
@@ -194,35 +210,36 @@ class CliOptions():
             back to default value """
         logger.debug("Resetting options to default. (command: '%s'", command)
         for option in self.options_to_process(command):
-            default = option.get("default", "")
-            default = "" if default is None else default
+            cp_opt = option["cpanel_option"]
+            default = "" if cp_opt.default is None else cp_opt.default
             if (option.get("nargs", None)
                     and isinstance(default, (list, tuple))):
                 default = ' '.join(str(val) for val in default)
-            option["selected"].set(default)
+            cp_opt.set(default)
 
     def clear(self, command=None):
-        """ Clear the options values for all or passed
-            commands """
+        """ Clear the options values for all or passed commands """
         logger.debug("Clearing options. (command: '%s'", command)
         for option in self.options_to_process(command):
-            if isinstance(option["selected"].get(), bool):
-                option["selected"].set(False)
-            elif isinstance(option["selected"].get(), int):
-                option["selected"].set(0)
+            cp_opt = option["cpanel_option"]
+            if isinstance(cp_opt.get(), bool):
+                cp_opt.set(False)
+            elif isinstance(cp_opt.get(), (int, float)):
+                cp_opt.set(0)
             else:
-                option["selected"].set("")
+                cp_opt.set("")
 
     def get_option_values(self, command=None):
-        """ Return all or single command control titles
-            with the associated tk_var value """
+        """ Return all or single command control titles with the associated tk_var value """
         ctl_dict = dict()
         for cmd, opts in self.opts.items():
             if command and command != cmd:
                 continue
             cmd_dict = dict()
             for key, val in opts.items():
-                cmd_dict[key] = val["selected"].get()
+                if not isinstance(val, dict):
+                    continue
+                cmd_dict[key] = val["cpanel_option"].get()
             ctl_dict[cmd] = cmd_dict
         logger.debug("command: '%s', ctl_dict: '%s'", command, ctl_dict)
         return ctl_dict
@@ -232,14 +249,13 @@ class CliOptions():
             command and control_title """
         for opt_title, option in self.gen_command_options(command):
             if opt_title == title:
-                return option["selected"]
+                return option["cpanel_option"].tk_var
         return None
 
     def gen_cli_arguments(self, command):
-        """ Return the generated cli arguments for
-            the selected command """
+        """ Return the generated cli arguments for the selected command """
         for _, option in self.gen_command_options(command):
-            optval = str(option.get("selected", "").get())
+            optval = str(option["cpanel_option"].get())
             opt = option["opts"][0]
             if command in ("extract", "convert") and opt == "-o":
                 get_images().pathoutput = optval
diff --git a/lib/gui/popup_configure.py b/lib/gui/popup_configure.py
index 7f77d6e..9a2f8f6 100644
--- a/lib/gui/popup_configure.py
+++ b/lib/gui/popup_configure.py
@@ -1,13 +1,14 @@
 #!/usr/bin python3
 """ Configure Plugins popup of the Faceswap GUI """
 
+from collections import OrderedDict
 from configparser import ConfigParser
 import logging
 import tkinter as tk
 
 from tkinter import ttk
 
-from .control_helper import ControlPanel
+from .control_helper import ControlPanel, ControlPanelOption
 from .tooltip import Tooltip
 from .utils import get_config, get_images
 
@@ -41,7 +42,7 @@ class ConfigurePlugins(tk.Toplevel):
         self.page_frame.pack(fill=tk.BOTH, expand=True)
 
         self.plugin_info = dict()
-        self.config_dict_gui = self.get_config()
+        self.config_cpanel_dict = self.get_config()
         self.build()
         self.update()
         logger.debug("Initialized %s", self.__class__.__name__)
@@ -57,20 +58,30 @@ class ConfigurePlugins(tk.Toplevel):
         self.geometry("{}x{}+{}+{}".format(width, height, pos_x, pos_y))
 
     def get_config(self):
-        """ Format config into useful format for GUI and pull default value if a value has not
-            been supplied """
+        """ Format config into a dict of ControlPanelOptions """
         logger.debug("Formatting Config for GUI")
         conf = dict()
         for section in self.config.config.sections():
             self.config.section = section
             category = section.split(".")[0]
             options = self.config.defaults[section]
-            conf.setdefault(category, dict())[section] = options
-            for key in options.keys():
+            section = section.split(".")[-1]
+            conf.setdefault(category, dict())[section] = OrderedDict()
+            for key, val in options.items():
                 if key == "helptext":
-                    self.plugin_info[section] = options[key]
+                    self.plugin_info[section] = val
                     continue
-                options[key]["value"] = self.config.config_dict.get(key, options[key]["default"])
+                conf[category][section][key] = ControlPanelOption(
+                    title=key,
+                    dtype=val["type"],
+                    group=val["group"],
+                    default=val["default"],
+                    initial_value=self.config.config_dict.get(key, val["default"]),
+                    choices=val["choices"],
+                    is_radio=val["gui_radio"],
+                    rounding=val["rounding"],
+                    min_max=val["min_max"],
+                    helptext=val["helptext"])
         logger.debug("Formatted Config for GUI: %s", conf)
         return conf
 
@@ -79,7 +90,7 @@ class ConfigurePlugins(tk.Toplevel):
         logger.debug("Building plugin config popup")
         container = ttk.Notebook(self.page_frame)
         container.pack(fill=tk.BOTH, expand=True)
-        categories = sorted(list(self.config_dict_gui.keys()))
+        categories = sorted(list(self.config_cpanel_dict.keys()))
         if "global" in categories:  # Move global to first item
             categories.insert(0, categories.pop(categories.index("global")))
         for category in categories:
@@ -93,22 +104,24 @@ class ConfigurePlugins(tk.Toplevel):
     def build_page(self, container, category):
         """ Build a plugin config page """
         logger.debug("Building plugin config page: '%s'", category)
-        plugins = sorted(list(key for key in self.config_dict_gui[category].keys()))
+        plugins = sorted(list(key for key in self.config_cpanel_dict[category].keys()))
         panel_kwargs = dict(columns=2, option_columns=2, blank_nones=False)
         if any(plugin != category for plugin in plugins):
             page = ttk.Notebook(container)
             page.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
             for plugin in plugins:
+                cp_options = [opt for opt in self.config_cpanel_dict[category][plugin].values()]
                 frame = ControlPanel(page,
-                                     self.config_dict_gui[category][plugin],
+                                     cp_options,
                                      header_text=self.plugin_info[plugin],
                                      **panel_kwargs)
                 title = plugin[plugin.rfind(".") + 1:]
                 title = title.replace("_", " ").title()
                 page.add(frame, text=title)
         else:
+            cp_options = [opt for opt in self.config_cpanel_dict[category][plugins[0]].values()]
             page = ControlPanel(container,
-                                self.config_dict_gui[category][plugins[0]],
+                                cp_options,
                                 header_text=self.plugin_info[plugins[0]],
                                 **panel_kwargs)
 
@@ -144,22 +157,20 @@ class ConfigurePlugins(tk.Toplevel):
         logger.debug("Resetting config")
         for section, items in self.config.defaults.items():
             logger.debug("Resetting section: '%s'", section)
-            lookup = [section.split(".")[0], section] if "." in section else [section, section]
+            lookup = [section.split(".")[0], section.split(".")[-1]]
             for item, def_opt in items.items():
                 if item == "helptext":
                     continue
                 default = def_opt["default"]
-                tk_var = self.config_dict_gui[lookup[0]][lookup[1]][item]["selected"]
                 logger.debug("Resetting: '%s' to '%s'", item, default)
-                tk_var.set(default)
+                self.config_cpanel_dict[lookup[0]][lookup[1]][item].set(default)
 
     def save_config(self):
         """ Save the config file """
         logger.debug("Saving config")
-        options = {sect: opts
-                   for value in self.config_dict_gui.values()
+        options = {".".join((key, sect)) if sect != key else key: opts
+                   for key, value in self.config_cpanel_dict.items()
                    for sect, opts in value.items()}
-
         new_config = ConfigParser(allow_no_value=True)
         for section, items in self.config.defaults.items():
             logger.debug("Adding section: '%s')", section)
@@ -167,13 +178,13 @@ class ConfigurePlugins(tk.Toplevel):
             for item, def_opt in items.items():
                 if item == "helptext":
                     continue
-                new_opt = options[section][item]
-                logger.debug("Adding option: (item: '%s', default: '%s' new: '%s'",
+                new_opt = options[section][item].get()
+                logger.debug("Adding option: (item: '%s', default: %s new: '%s'",
                              item, def_opt, new_opt)
                 helptext = def_opt["helptext"]
                 helptext = self.config.format_help(helptext, is_section=False)
                 new_config.set(section, helptext)
-                new_config.set(section, item, str(new_opt["selected"].get()))
+                new_config.set(section, item, str(new_opt))
         self.config.config = new_config
         self.config.save_config()
         print("Saved config: '{}'".format(self.config.configfile))
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 776ce0f..834a40b 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -538,7 +538,7 @@ class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
     def build_console(self):
         """ Build and place the console """
         logger.debug("Build console")
-        self.console.config(width=100, height=6, bg="gray90", fg="black")
+        self.console.config(width=100, height=6, bg="gray90", fg="black", state="disabled")
         self.console.pack(side=tk.LEFT, anchor=tk.N, fill=tk.BOTH, expand=True)
 
         scrollbar = ttk.Scrollbar(self, command=self.console.yview)
@@ -575,7 +575,9 @@ class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
         if not self.console_clear.get():
             logger.debug("Console not set for clearing. Skipping")
             return
+        self.console.configure(state="normal")
         self.console.delete(1.0, tk.END)
+        self.console.configure(state="disabled")
         self.console_clear.set(False)
         logger.debug("Cleared console")
 
@@ -605,8 +607,10 @@ class SysOutRouter():
 
     def write(self, string):
         """ Capture stdout/stderr """
+        self.console.configure(state="normal")
         self.console.insert(tk.END, string, self.get_tag(string))
         self.console.see(tk.END)
+        self.console.configure(state="disabled")
 
     @staticmethod
     def flush():

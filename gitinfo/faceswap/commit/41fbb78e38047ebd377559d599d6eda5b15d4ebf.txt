commit 41fbb78e38047ebd377559d599d6eda5b15d4ebf
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sun Dec 16 19:17:12 2018 +0000

    Add right click menu to GUI. Implement some GUI Logging

diff --git a/lib/gui/command.py b/lib/gui/command.py
index 362519e..7a25f08 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -1,18 +1,24 @@
 #!/usr/bin python3
 """ The command frame for Faceswap GUI """
 
+import logging
 import tkinter as tk
 from tkinter import ttk
 
 from .options import Config
 from .tooltip import Tooltip
-from .utils import Images, FileHandler
+from .utils import ContextMenu, Images, FileHandler
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
 
 class CommandNotebook(ttk.Notebook):
     """ Frame to hold each individual tab of the command notebook """
 
     def __init__(self, parent, cli_options, tk_vars, scaling_factor):
+        logger.debug("Initializing %s: (parent: %s, cli_options: %s, tk_vars: %s, "
+                     "scaling_factor: %s", self.__class__.__name__, parent, cli_options,
+                     tk_vars, scaling_factor)
         width = int(420 * scaling_factor)
         height = int(500 * scaling_factor)
         ttk.Notebook.__init__(self, parent, width=width, height=height)
@@ -24,23 +30,28 @@ class CommandNotebook(ttk.Notebook):
 
         self.set_running_task_trace()
         self.build_tabs()
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def set_running_task_trace(self):
         """ Set trigger action for the running task
             to change the action buttons text and command """
+        logger.debug("Set running trace")
         self.tk_vars["runningtask"].trace("w", self.change_action_button)
 
     def build_tabs(self):
         """ Build the tabs for the relevant command """
+        logger.debug("Build Tabs")
         for category in self.cli_opts.categories:
             cmdlist = self.cli_opts.commands[category]
             for command in cmdlist:
                 title = command.title()
                 commandtab = CommandTab(self, category, command)
                 self.add(commandtab, text=title)
+        logger.debug("Built Tabs")
 
     def change_action_button(self, *args):
         """ Change the action button to relevant control """
+        logger.debug("Update Action Buttons: (args: %s", args)
         for cmd in self.actionbtns.keys():
             btnact = self.actionbtns[cmd]
             if self.tk_vars["runningtask"].get():
@@ -49,6 +60,7 @@ class CommandNotebook(ttk.Notebook):
             else:
                 ttl = cmd.title()
                 hlp = "Run the {} script".format(cmd.title())
+            logger.debug("Updated Action Button: '%s'", ttl)
             btnact.config(text=ttl)
             Tooltip(btnact, text=hlp, wraplength=200)
 
@@ -57,6 +69,8 @@ class CommandTab(ttk.Frame):
     """ Frame to hold each individual tab of the command notebook """
 
     def __init__(self, parent, category, command):
+        logger.debug("Initializing %s: (category: '%s', command: '%s')",
+                     self.__class__.__name__, category, command)
         ttk.Frame.__init__(self, parent)
 
         self.category = category
@@ -66,25 +80,31 @@ class CommandTab(ttk.Frame):
         self.command = command
 
         self.build_tab()
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def build_tab(self):
         """ Build the tab """
+        logger.debug("Build Tab: '%s'", self.command)
         OptionsFrame(self)
 
         self.add_frame_separator()
 
         ActionFrame(self)
+        logger.debug("Built Tab: '%s'", self.command)
 
     def add_frame_separator(self):
         """ Add a separator between top and bottom frames """
+        logger.debug("Add frame seperator")
         sep = ttk.Frame(self, height=2, relief=tk.RIDGE)
         sep.pack(fill=tk.X, pady=(5, 0), side=tk.TOP)
+        logger.debug("Added frame seperator")
 
 
 class OptionsFrame(ttk.Frame):
     """ Options Frame - Holds the Options for each command """
 
     def __init__(self, parent):
+        logger.debug("Initializing %s", self.__class__.__name__)
         ttk.Frame.__init__(self, parent)
         self.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
 
@@ -102,9 +122,11 @@ class OptionsFrame(ttk.Frame):
 
         self.build_frame()
         self.opts.set_context_option(self.command)
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def checkbuttons_frame(self):
         """ Build and format frame for holding the check buttons """
+        logger.debug("Add Options CheckButtons Frame")
         container = ttk.Frame(self.optsframe)
 
         lbl = ttk.Label(container, text="Options", width=16, anchor=tk.W)
@@ -118,11 +140,13 @@ class OptionsFrame(ttk.Frame):
 
         chkright = ttk.Frame(chkframe, name="rightFrame")
         chkright.pack(side=tk.RIGHT, anchor=tk.N, expand=True)
+        logger.debug("Added Options CheckButtons Frame")
 
         return container, chkframe
 
     def build_frame(self):
         """ Build the options frame for this command """
+        logger.debug("Add Options Frame")
         self.add_scrollbar()
         self.canvas.bind("<Configure>", self.resize_frame)
 
@@ -135,13 +159,16 @@ class OptionsFrame(ttk.Frame):
 
         if self.chkbtns[1].winfo_children():
             self.chkbtns[0].pack(side=tk.BOTTOM, fill=tk.X, expand=True)
+        logger.debug("Added Options Frame")
 
     def add_scrollbar(self):
         """ Add a scrollbar to the options frame """
+        logger.debug("Add Options Scrollbar")
         scrollbar = ttk.Scrollbar(self, command=self.canvas.yview)
         scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
         self.canvas.config(yscrollcommand=scrollbar.set)
         self.optsframe.bind("<Configure>", self.update_scrollbar)
+        logger.debug("Added Options Scrollbar")
 
     def update_scrollbar(self, event):
         """ Update the options frame scrollbar """
@@ -149,22 +176,27 @@ class OptionsFrame(ttk.Frame):
 
     def resize_frame(self, event):
         """ Resize the options frame to fit the canvas """
+        logger.debug("Resize Options Frame")
         canvas_width = event.width
         self.canvas.itemconfig(self.optscanvas, width=canvas_width)
+        logger.debug("Resized Options Frame")
 
 
-class OptionControl(object):
+class OptionControl():
     """ Build the correct control for the option parsed and place it on the
     frame """
 
     def __init__(self, command, option, option_frame, checkbuttons_frame):
+        logger.debug("Initializing %s", self.__class__.__name__)
         self.command = command
         self.option = option
         self.option_frame = option_frame
         self.chkbtns = checkbuttons_frame
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def build_full_control(self):
         """ Build the correct control type for the option passed through """
+        logger.debug("Build option control")
         ctl = self.option["control"]
         ctltitle = self.option["control_title"]
         sysbrowser = self.option["filesystem_browser"]
@@ -186,9 +218,11 @@ class OptionControl(object):
                                                       ctlvars,
                                                       choices,
                                                       sysbrowser)
+        logger.debug("Built option control")
 
     def format_help(self, ctltitle):
         """ Format the help text for tooltips """
+        logger.debug("Format control help: '%s'", ctltitle)
         ctlhelp = self.option.get("help", "")
         if ctlhelp.startswith("R|"):
             ctlhelp = ctlhelp[2:].replace("\n\t", " ").replace("\n'", "\n\n'")
@@ -196,22 +230,29 @@ class OptionControl(object):
             ctlhelp = " ".join(ctlhelp.split())
         ctlhelp = ". ".join(i.capitalize() for i in ctlhelp.split(". "))
         ctlhelp = ctltitle + " - " + ctlhelp
+        logger.debug("Formatted control help: (title: '%s', help: '%s'", ctltitle, ctlhelp)
         return ctlhelp
 
     def build_one_control_frame(self):
         """ Build the frame to hold the control """
+        logger.debug("Build control frame")
         frame = ttk.Frame(self.option_frame)
         frame.pack(fill=tk.X, expand=True)
+        logger.debug("Built control frame")
         return frame
 
     @staticmethod
     def build_one_control_label(frame, control_title):
         """ Build and place the control label """
+        logger.debug("Build control label: '%s'", control_title)
         lbl = ttk.Label(frame, text=control_title, width=16, anchor=tk.W)
         lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
+        logger.debug("Built control label: '%s'", control_title)
 
     def build_one_control(self, frame, controlvars, choices, sysbrowser):
         """ Build and place the option controls """
+        logger.debug("Build control: (controlvars: %s, choices: %s, sysbrowser: '%s'",
+                     controlvars, choices, sysbrowser)
         control, control_title, default, helptext = controlvars
         default = default if default is not None else ""
 
@@ -233,10 +274,12 @@ class OptionControl(object):
                                          var,
                                          choices,
                                          helptext)
+        logger.debug("Built control: '%s'", control_title)
         return var
 
     def checkbutton_to_checkframe(self, control, control_title, var, helptext):
         """ Add checkbuttons to the checkbutton frame """
+        logger.debug("Add control checkframe: '%s'", control_title)
         leftframe = self.chkbtns.children["leftFrame"]
         rightframe = self.chkbtns.children["rightFrame"]
         chkbtn_count = len({**leftframe.children, **rightframe.children})
@@ -247,20 +290,27 @@ class OptionControl(object):
         ctl.pack(side=tk.TOP, padx=5, pady=5, anchor=tk.W)
 
         Tooltip(ctl, text=helptext, wraplength=200)
+        logger.debug("Added control checkframe: '%s'", control_title)
 
     @staticmethod
     def control_to_optionsframe(control, frame, var, choices, helptext):
         """ Standard non-check buttons sit in the main options frame """
+        logger.debug("Add control to Options Frame: %s", control)
         ctl = control(frame, textvariable=var)
         ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
-
+        rc_menu = ContextMenu(ctl)
+        rc_menu.cm_bind()
         if control == ttk.Combobox:
+            logger.debug("Adding combo choices: %s", choices)
             ctl["values"] = [choice for choice in choices]
 
         Tooltip(ctl, text=helptext, wraplength=720)
+        logger.debug("Added control to Options Frame: %s", control)
 
     def add_browser_buttons(self, frame, sysbrowser, filepath):
         """ Add correct file browser button for control """
+        logger.debug("Adding browser buttons: (sysbrowser: '%s', filepath: '%s'",
+                     sysbrowser, filepath)
         img = Images().icons[sysbrowser]
         action = getattr(self, "ask_" + sysbrowser)
         filetypes = self.option.get("filetypes", "default")
@@ -268,6 +318,8 @@ class OptionControl(object):
                              command=lambda cmd=action: cmd(filepath,
                                                             filetypes))
         fileopn.pack(padx=(0, 5), side=tk.RIGHT)
+        logger.debug("Added browser buttons: (action: %s, filetypes: %s",
+                     action, filetypes)
 
     @staticmethod
     def ask_folder(filepath, filetypes=None):
@@ -278,6 +330,7 @@ class OptionControl(object):
             filetypes to be given in ask_load(). """
         dirname = FileHandler("dir", filetypes).retfile
         if dirname:
+            logger.debug(dirname)
             filepath.set(dirname)
 
     @staticmethod
@@ -285,6 +338,7 @@ class OptionControl(object):
         """ Pop-up to get path to a file """
         filename = FileHandler("filename", filetypes).retfile
         if filename:
+            logger.debug(filename)
             filepath.set(filename)
 
     @staticmethod
@@ -292,6 +346,7 @@ class OptionControl(object):
         """ Pop-up to get path to save a new file """
         filename = FileHandler("savefilename", filetypes).retfile
         if filename:
+            logger.debug(filename)
             filepath.set(filename)
 
     @staticmethod
@@ -301,6 +356,7 @@ class OptionControl(object):
 
     def ask_context(self, filepath, filetypes):
         """ Method to pop the correct dialog depending on context """
+        logger.debug("Getting context filebrowser")
         selected_action = self.option["action_option"].get()
         selected_variable = self.option["dest"]
         filename = FileHandler("context",
@@ -309,6 +365,7 @@ class OptionControl(object):
                                action=selected_action,
                                variable=selected_variable).retfile
         if filename:
+            logger.debug(filename)
             filepath.set(filename)
 
 
@@ -316,6 +373,7 @@ class ActionFrame(ttk.Frame):
     """Action Frame - Displays action controls for the command tab """
 
     def __init__(self, parent):
+        logger.debug("Initializing %s: (command: '%s')", self.__class__.__name__, parent.command)
         ttk.Frame.__init__(self, parent)
         self.pack(fill=tk.BOTH, padx=5, pady=5, side=tk.BOTTOM, anchor=tk.N)
 
@@ -326,9 +384,11 @@ class ActionFrame(ttk.Frame):
                                parent.actionbtns,
                                parent.tk_vars)
         self.add_util_buttons(parent.cli_opts, parent.tk_vars)
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def add_action_button(self, category, actionbtns, tk_vars):
         """ Add the action buttons for page """
+        logger.debug("Add action buttons: '%s'", self.title)
         actframe = ttk.Frame(self)
         actframe.pack(fill=tk.X, side=tk.LEFT)
 
@@ -352,14 +412,17 @@ class ActionFrame(ttk.Frame):
         Tooltip(btngen,
                 text="Output command line options to the console",
                 wraplength=200)
+        logger.debug("Added action buttons: '%s'", self.title)
 
     def add_util_buttons(self, cli_options, tk_vars):
         """ Add the section utility buttons """
+        logger.debug("Add util buttons")
         utlframe = ttk.Frame(self)
         utlframe.pack(side=tk.RIGHT)
 
         config = Config(cli_options, tk_vars)
         for utl in ("load", "save", "clear", "reset"):
+            logger.debug("Adding button: '%s'", utl)
             img = Images().icons[utl]
             action_cls = config if utl in (("save", "load")) else cli_options
             action = getattr(action_cls, utl)
@@ -370,3 +433,4 @@ class ActionFrame(ttk.Frame):
             Tooltip(btnutl,
                     text=utl.capitalize() + " " + self.title + " config",
                     wraplength=200)
+        logger.debug("Added util buttons")
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 6f46500..04c59fa 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -1,12 +1,17 @@
 #!/usr/bin/env python3
 """ Utility functions for the GUI """
+import logging
+
 import os
+import platform
 import sys
 import tkinter as tk
 
 from tkinter import filedialog, ttk
 from PIL import Image, ImageTk
 
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
 
 class Singleton(type):
     """ Instigate a singleton.
@@ -30,7 +35,9 @@ class FileHandler():
 
     def __init__(self, handletype, filetype, command=None, action=None,
                  variable=None):
-
+        logger.debug("Initializing %s: (Handletype: '%s', filetype: '%s', command: '%s', action: "
+                     "'%s', variable: %s)", self.__class__.__name__, handletype, filetype, command,
+                     action, variable)
         self.handletype = handletype
         all_files = ("All files", "*.*")
         self.filetypes = {"default": (all_files,),
@@ -80,6 +87,7 @@ class FileHandler():
         self.defaults = self.set_defaults()
         self.kwargs = self.set_kwargs(filetype, command, action, variable)
         self.retfile = getattr(self, self.handletype.lower())()
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def set_defaults(self):
         """ Set the default filetype to be first in list of filetypes,
@@ -89,10 +97,13 @@ class FileHandler():
         defaults["default"] = None
         defaults["video"] = ".mp4"
         defaults["image"] = ".png"
+        logger.debug(defaults)
         return defaults
 
     def set_kwargs(self, filetype, command, action, variable=None):
         """ Generate the required kwargs for the requested browser """
+        logger.debug("Setting Kwargs: (filetype: '%s', command: '%s': action: '%s', "
+                     "variable: '%s')", filetype, command, action, variable)
         kwargs = dict()
         if self.handletype.lower() == "context":
             self.set_context_handletype(command, action, variable)
@@ -106,42 +117,52 @@ class FileHandler():
             kwargs["mode"] = "w"
         if self.handletype.lower() == "open":
             kwargs["mode"] = "r"
+        logger.debug("Set Kwargs: %s", kwargs)
         return kwargs
 
     def set_context_handletype(self, command, action, variable):
         """ Choose the correct file browser action based on context """
         if self.contexts[command].get(variable, None) is not None:
-            self.handletype = self.contexts[command][variable][action]
+            handletype = self.contexts[command][variable][action]
         else:
-            self.handletype = self.contexts[command][action]
+            handletype = self.contexts[command][action]
+        logger.debug(handletype)
+        self.handletype = handletype
 
     def open(self):
         """ Open a file """
+        logger.debug("Popping Open browser")
         return filedialog.askopenfile(**self.kwargs)
 
     def save(self):
         """ Save a file """
+        logger.debug("Popping Save browser")
         return filedialog.asksaveasfile(**self.kwargs)
 
     def dir(self):
         """ Get a directory location """
+        logger.debug("Popping Dir browser")
         return filedialog.askdirectory(**self.kwargs)
 
     def savedir(self):
         """ Get a save dir location """
+        logger.debug("Popping SaveDir browser")
         return filedialog.askdirectory(**self.kwargs)
 
     def filename(self):
         """ Get an existing file location """
+        logger.debug("Popping Filename browser")
         return filedialog.askopenfilename(**self.kwargs)
 
     def savefilename(self):
         """ Get a save file location """
+        logger.debug("Popping SaveFilename browser")
         return filedialog.asksaveasfilename(**self.kwargs)
 
     @staticmethod
-    def nothing():
+    def nothing():  # pylint: disable=useless-return
         """ Method that does nothing, used for disabling open/save pop up  """
+        logger.debug("Popping Nothing browser")
         return
 
 
@@ -149,6 +170,7 @@ class Images(metaclass=Singleton):
     """ Holds locations of images and actual images """
 
     def __init__(self, pathcache=None):
+        logger.debug("Initializing %s: (pathcache: '%s'", self.__class__.__name__, pathcache)
         self.pathicons = os.path.join(pathcache, "icons")
         self.pathpreview = os.path.join(pathcache, "preview")
         self.pathoutput = None
@@ -184,17 +206,21 @@ class Images(metaclass=Singleton):
         self.icons["move"] = tk.PhotoImage(file=os.path.join(
             self.pathicons,
             "move.png"))
+        logger.debug("Initialized %s: (icons: %s)", self.__class__.__name__, self.icons)
 
     def delete_preview(self):
         """ Delete the preview files """
+        logger.debug("Deleting previews")
         for item in os.listdir(self.pathpreview):
             if item.startswith(".gui_preview_") and item.endswith(".jpg"):
                 fullitem = os.path.join(self.pathpreview, item)
+                logger.debug("Deleting: '%s'", fullitem)
                 os.remove(fullitem)
         self.clear_image_cache()
 
     def clear_image_cache(self):
         """ Clear all cached images """
+        logger.debug("Clearing image cache")
         self.pathoutput = None
         self.previewoutput = None
         self.previewtrain = dict()
@@ -202,16 +228,21 @@ class Images(metaclass=Singleton):
     @staticmethod
     def get_images(imgpath):
         """ Get the images stored within the given directory """
+        logger.debug("Getting images: '%s'", imgpath)
         if not os.path.isdir(imgpath):
+            logger.debug("Folder does not exist")
             return None
         files = [os.path.join(imgpath, f)
                  for f in os.listdir(imgpath) if f.endswith((".png", ".jpg"))]
+        logger.debug("Image files: %s", files)
         return files
 
     def load_latest_preview(self):
         """ Load the latest preview image for extract and convert """
+        logger.debug("Loading preview image")
         imagefiles = self.get_images(self.pathoutput)
         if not imagefiles or len(imagefiles) == 1:
+            logger.debug("No preview to display")
             self.previewoutput = None
             return
         # Get penultimate file so we don't accidently
@@ -219,13 +250,16 @@ class Images(metaclass=Singleton):
         show_file = sorted(imagefiles, key=os.path.getctime)[-2]
         img = Image.open(show_file)
         img.thumbnail((768, 432))
+        logger.debug("Displaying preview: '%s'", show_file)
         self.previewoutput = (img, ImageTk.PhotoImage(img))
 
     def load_training_preview(self):
         """ Load the training preview images """
+        logger.debug("Loading Training preview images")
         imagefiles = self.get_images(self.pathpreview)
         modified = None
         if not imagefiles:
+            logger.debug("No preview to display")
             self.previewtrain = dict()
             return
         for img in imagefiles:
@@ -234,6 +268,7 @@ class Images(metaclass=Singleton):
             name = os.path.splitext(name)[0]
             name = name[name.rfind("_") + 1:].title()
             try:
+                logger.debug("Displaying preview: '%s'", img)
                 size = self.get_current_size(name)
                 self.previewtrain[name] = [Image.open(img), None, modified]
                 self.resize_image(name, size)
@@ -242,24 +277,31 @@ class Images(metaclass=Singleton):
                 # This is probably an error reading the file whilst it's
                 # being saved  so ignore it for now and only pick up if
                 # there have been multiple consecutive fails
+                logger.warning("Unable to display preview: (image: '%s', attempt: %s)",
+                               img, self.errcount)
                 if self.errcount < 10:
                     self.errcount += 1
                 else:
+                    logger.error("Error reading the preview file for '%s'", img)
                     print("Error reading the preview file for {}".format(name))
                     self.previewtrain[name] = None
 
     def get_current_size(self, name):
         """ Return the size of the currently displayed image """
+        logger.debug("Getting size: '%s'", name)
         if not self.previewtrain.get(name, None):
             return None
         img = self.previewtrain[name][1]
         if not img:
             return None
+        logger.debug("Got size: (name: '%s', width: '%s', height: '%s')",
+                     name, img.width(), img.height())
         return img.width(), img.height()
 
     def resize_image(self, name, framesize):
         """ Resize the training preview image
             based on the passed in frame size """
+        logger.debug("Resizing image: (name: '%s', framesize: %s", name, framesize)
         displayimg = self.previewtrain[name][0]
         if framesize:
             frameratio = float(framesize[0]) / float(framesize[1])
@@ -271,6 +313,7 @@ class Images(metaclass=Singleton):
             else:
                 scale = framesize[1] / float(displayimg.size[1])
                 size = (int(displayimg.size[0] * scale), framesize[1])
+            logger.debug("Scaling: (scale: %s, size: %s", scale, size)
 
             # Hacky fix to force a reload if it happens to find corrupted
             # data, probably due to reading the image whilst it is partially
@@ -288,26 +331,68 @@ class Images(metaclass=Singleton):
         self.previewtrain[name][1] = ImageTk.PhotoImage(displayimg)
 
 
+class ContextMenu(tk.Menu):
+    """ Pop up menu """
+    def __init__(self, widget):
+        logger.debug("Initializing %s: (widget_class: '%s')",
+                     self.__class__.__name__, widget.winfo_class())
+        super().__init__(tearoff=0)
+        self.widget = widget
+        self.standard_actions()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def standard_actions(self):
+        """ Standard menu actions """
+        self.add_command(label="Cut", command=lambda: self.widget.event_generate("<<Cut>>"))
+        self.add_command(label="Copy", command=lambda: self.widget.event_generate("<<Copy>>"))
+        self.add_command(label="Paste", command=lambda: self.widget.event_generate("<<Paste>>"))
+        self.add_separator()
+        self.add_command(label="Select all", command=self.select_all)
+
+    def cm_bind(self):
+        """ Bind the menu to the widget's Right Click event """
+        button = "<Button-2>" if platform.system() == "Darwin" else "<Button-3>"
+        logger.debug("Binding '%s' to '%s'", button, self.widget.winfo_class())
+        self.widget.bind(button, lambda event: self.tk_popup(event.x_root, event.y_root, 0))
+
+    def select_all(self):
+        """ Select all for Text or Entry widgets """
+        logger.debug("Selecting all for '%s'", self.widget.winfo_class())
+        if self.widget.winfo_class() == "Text":
+            self.widget.focus_force()
+            self.widget.tag_add("sel", "1.0", "end")
+        else:
+            self.widget.focus_force()
+            self.widget.select_range(0, tk.END)
+
+
 class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
     """ The Console out section of the GUI """
 
     def __init__(self, parent, debug, tk_vars):
+        logger.debug("Initializing %s: (parent: %s, debug: %s, tk_vars: %s)",
+                     self.__class__.__name__, parent, debug, tk_vars)
         ttk.Frame.__init__(self, parent)
         self.pack(side=tk.TOP, anchor=tk.W, padx=10, pady=(2, 0),
                   fill=tk.BOTH, expand=True)
         self.console = tk.Text(self)
+        rc_menu = ContextMenu(self.console)
+        rc_menu.cm_bind()
         self.console_clear = tk_vars['consoleclear']
         self.set_console_clear_var_trace()
         self.debug = debug
         self.build_console()
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def set_console_clear_var_trace(self):
         """ Set the trigger actions for the clear console var
             when it has been triggered from elsewhere """
+        logger.debug("Set clear trace")
         self.console_clear.trace("w", self.clear)
 
     def build_console(self):
         """ Build and place the console """
+        logger.debug("Build console")
         self.console.config(width=100, height=6, bg="gray90", fg="black")
         self.console.pack(side=tk.LEFT, anchor=tk.N, fill=tk.BOTH, expand=True)
 
@@ -316,30 +401,39 @@ class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
         self.console.configure(yscrollcommand=scrollbar.set)
 
         self.redirect_console()
+        logger.debug("Built console")
 
     def redirect_console(self):
         """ Redirect stdout/stderr to console frame """
+        logger.debug("Redirect console")
         if self.debug:
-            print("Console debug activated. Outputting to main terminal")
+            logger.info("Console debug activated. Outputting to main terminal")
         else:
             sys.stdout = SysOutRouter(console=self.console, out_type="stdout")
             sys.stderr = SysOutRouter(console=self.console, out_type="stderr")
+        logger.debug("Redirected console")
 
     def clear(self, *args):
         """ Clear the console output screen """
+        logger.debug("Clear console")
         if not self.console_clear.get():
+            logger.debug("Console not set for clearing. Skipping")
             return
         self.console.delete(1.0, tk.END)
         self.console_clear.set(False)
+        logger.debug("Cleared console")
 
 
 class SysOutRouter():
     """ Route stdout/stderr to the console window """
 
     def __init__(self, console=None, out_type=None):
+        logger.debug("Initializing %s: (console: %s, out_type: '%s')",
+                     self.__class__.__name__, console, out_type)
         self.console = console
         self.out_type = out_type
         self.color = ("black" if out_type == "stdout" else "red")
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def write(self, string):
         """ Capture stdout/stderr """

commit 533025215d6629a1f506838fc9eeed33f2417591
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Jun 28 16:34:32 2019 +0000

    GUI responsiveness and feature updates
    
    - Add error handling to LongRunningTask
    - Analysis: Fix timestats bug for missing session data
    - Training: Update training graph inside LongRunningTask
    - Training: Smoothing Amount Slider geometry fix
    - Training: Auto update Analysis tab on training start and save interval
    - Scripts: Keep control of the UI when terminating by terminating using LongRunningTask

diff --git a/lib/gui/display_analysis.py b/lib/gui/display_analysis.py
index 843dc37..a0584e1 100644
--- a/lib/gui/display_analysis.py
+++ b/lib/gui/display_analysis.py
@@ -28,8 +28,28 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         self.add_options()
         self.add_main_frame()
         self.thread = None  # Thread for compiling stats data in background
+        self.set_training_callback()
         logger.debug("Initialized: %s", self.__class__.__name__)
 
+    def set_training_callback(self):
+        """ Add a callback to update analysis when the training graph is updated """
+        get_config().tk_vars["refreshgraph"].trace("w", self.update_current_session)
+        get_config().tk_vars["istraining"].trace("w", self.remove_current_session)
+
+    def update_current_session(self, *args):  # pylint:disable=unused-argument
+        """ Update the current session data on a graph update callback """
+        if not get_config().tk_vars["refreshgraph"].get():
+            return
+        logger.debug("Analysis update callback received")
+        self.reset_session()
+
+    def remove_current_session(self, *args):  # pylint:disable=unused-argument
+        """ Remove the current session data on a istraining=False callback """
+        if get_config().tk_vars["istraining"].get():
+            return
+        logger.debug("Remove current training Analysis callback received")
+        self.clear_session()
+
     def set_vars(self):
         """ Analysis specific vars """
         selected_id = tk.StringVar()
@@ -109,7 +129,9 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         """ Set the summary data and info message """
         if self.thread is None:
             logger.debug("Setting session summary. (message: '%s')", message)
-            self.thread = LongRunningTask(target=self.summarise_data, args=(self.session, ))
+            self.thread = LongRunningTask(target=self.summarise_data,
+                                          args=(self.session, ),
+                                          widget=self)
             self.thread.start()
             self.after(1000, lambda msg=message: self.set_session_summary(msg))
         elif not self.thread.complete.is_set():
@@ -173,7 +195,7 @@ class Options():
 
     def add_buttons(self):
         """ Add the option buttons """
-        for btntype in ("reset", "clear", "save", "load"):
+        for btntype in ("clear", "save", "load"):
             logger.debug("Adding button: '%s'", btntype)
             cmd = getattr(self.parent, "{}_session".format(btntype))
             btn = ttk.Button(self.optsframe,
@@ -699,21 +721,23 @@ class SessionPopUp(tk.Toplevel):
             self.thread = LongRunningTask(target=self.get_display_data, kwargs=kwargs, widget=self)
             self.thread.start()
             self.after(1000, self.compile_display_data)
-        elif not self.thread.complete.is_set():
+            return True
+        if not self.thread.complete.is_set():
             logger.debug("Popup Data not yet available")
             self.after(1000, self.compile_display_data)
-        else:
-            logger.debug("Getting Popup from background Thread")
-            self.display_data = self.thread.get_result()
-            self.thread = None
-            if not self.check_valid_data():
-                logger.warning("No valid data to display. Not refreshing")
-                self.vars["status"].set("")
-                return False
-            logger.debug("Compiled Display Data")
-            self.vars["buildgraph"].set(True)
             return True
 
+        logger.debug("Getting Popup from background Thread")
+        self.display_data = self.thread.get_result()
+        self.thread = None
+        if not self.check_valid_data():
+            logger.warning("No valid data to display. Not refreshing")
+            self.vars["status"].set("")
+            return False
+        logger.debug("Compiled Display Data")
+        self.vars["buildgraph"].set(True)
+        return True
+
     @staticmethod
     def get_display_data(**kwargs):
         """ Get the display data in a LongRunningTask """
diff --git a/lib/gui/display_command.py b/lib/gui/display_command.py
index 5c1bf85..f7e87f8 100644
--- a/lib/gui/display_command.py
+++ b/lib/gui/display_command.py
@@ -200,15 +200,17 @@ class GraphDisplay(DisplayOptionalPage):  # pylint: disable=too-many-ancestors
         logger.debug("Adding Smoothing Slider")
         tk_var = get_config().tk_vars["smoothgraph"]
         min_max = (0, 0.99)
+        hlp = "Set the smoothing amount. 0 is no smoothing, 0.99 is maximum smoothing."
 
         ctl_frame = ttk.Frame(self.optsframe)
         ctl_frame.pack(padx=2, side=tk.RIGHT)
 
         lbl = ttk.Label(ctl_frame, text="Smoothing Amount:", anchor=tk.W)
-        lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N, expand=True)
+        lbl.pack(pady=5, side=tk.LEFT, anchor=tk.N, expand=True)
 
-        tbox = ttk.Entry(ctl_frame, width=8, textvariable=tk_var, justify=tk.RIGHT)
+        tbox = ttk.Entry(ctl_frame, width=6, textvariable=tk_var, justify=tk.RIGHT)
         tbox.pack(padx=(0, 5), side=tk.RIGHT)
+
         ctl = ttk.Scale(
             ctl_frame,
             variable=tk_var,
@@ -216,10 +218,11 @@ class GraphDisplay(DisplayOptionalPage):  # pylint: disable=too-many-ancestors
             set_slider_rounding(val, var, dt, rn, mm))
         ctl["from_"] = min_max[0]
         ctl["to"] = min_max[1]
-        ctl.pack()
-        Tooltip(ctl,
-                text="Set the smoothing amount. 0 is no smoothing, 0.99 is maximum smoothing.",
-                wraplength=200)
+        ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
+        for item in (tbox, ctl):
+            Tooltip(item,
+                    text=hlp,
+                    wraplength=200)
         logger.debug("Added Smoothing Slider")
 
     def display_item_set(self):
diff --git a/lib/gui/display_graph.py b/lib/gui/display_graph.py
index 591eaac..d97c8c7 100755
--- a/lib/gui/display_graph.py
+++ b/lib/gui/display_graph.py
@@ -18,7 +18,7 @@ from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,
                                                NavigationToolbar2Tk)  # noqa
 
 from .tooltip import Tooltip  # noqa
-from .utils import get_config, get_images  # noqa
+from .utils import get_config, get_images, LongRunningTask  # noqa
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -255,6 +255,7 @@ class TrainingGraph(GraphBase):  # pylint: disable=too-many-ancestors
 
     def __init__(self, parent, data, ylabel):
         GraphBase.__init__(self, parent, data, ylabel)
+        self.thread = None  # Thread for LongRunningTask
         self.add_callback()
 
     def add_callback(self):
@@ -269,11 +270,25 @@ class TrainingGraph(GraphBase):  # pylint: disable=too-many-ancestors
 
     def refresh(self, *args):  # pylint: disable=unused-argument
         """ Read loss data and apply to graph """
-        logger.debug("Updating plot")
-        self.calcs.refresh()
-        self.update_plot(initiate=False)
-        self.plotcanvas.draw()
-        get_config().tk_vars["refreshgraph"].set(False)
+        refresh_var = get_config().tk_vars["refreshgraph"]
+        if not refresh_var.get() and self.thread is None:
+            return
+
+        if self.thread is None:
+            logger.debug("Updating plot data")
+            self.thread = LongRunningTask(target=self.calcs.refresh)
+            self.thread.start()
+            self.after(1000, self.refresh)
+        elif not self.thread.complete.is_set():
+            logger.debug("Graph Data not yet available")
+            self.after(1000, self.refresh)
+        else:
+            logger.debug("Updating plot with data from background thread")
+            self.calcs = self.thread.get_result()  # Terminate the LongRunningTask object
+            self.thread = None
+            self.update_plot(initiate=False)
+            self.plotcanvas.draw()
+            refresh_var.set(False)
 
     def save_fig(self, location):
         """ Save the figure to file """
diff --git a/lib/gui/stats.py b/lib/gui/stats.py
index fae76b7..5e8fa35 100644
--- a/lib/gui/stats.py
+++ b/lib/gui/stats.py
@@ -259,9 +259,9 @@ class SessionsSummary():
     def time_stats(self):
         """ Return session time stats """
         ts_data = self.session.tb_logs.get_timestamps()
-        time_stats = {sess_id: {"start_time": min(timestamps),
-                                "end_time": max(timestamps),
-                                "datapoints": len(timestamps)}
+        time_stats = {sess_id: {"start_time": min(timestamps) if timestamps else 0,
+                                "end_time": max(timestamps) if timestamps else 0,
+                                "datapoints": len(timestamps) if timestamps else 0}
                       for sess_id, timestamps in ts_data.items()}
         return time_stats
 
@@ -365,12 +365,13 @@ class Calculations():
         logger.debug("Refreshing")
         if not self.session.initialized:
             logger.warning("Session data is not initialized. Not refreshing")
-            return
+            return None
         self.iterations = 0
         self.stats = self.get_raw()
         self.get_calculations()
         self.remove_raw()
         logger.debug("Refreshed")
+        return self
 
     def get_raw(self):
         """ Add raw data to stats dict """
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 60e3b16..ac0a60f 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -590,6 +590,9 @@ class Config():
         runningtask = tk.BooleanVar()
         runningtask.set(False)
 
+        istraining = tk.BooleanVar()
+        istraining.set(False)
+
         actioncommand = tk.StringVar()
         actioncommand.set(None)
 
@@ -613,6 +616,7 @@ class Config():
 
         tk_vars = {"display": display,
                    "runningtask": runningtask,
+                   "istraining": istraining,
                    "action": actioncommand,
                    "generate": generatecommand,
                    "consoleclear": consoleclear,
@@ -937,6 +941,7 @@ class LongRunningTask(Thread):
                      daemon)
         super().__init__(group=group, target=target, name=name, args=args, kwargs=kwargs,
                          daemon=daemon)
+        self.err = None
         self.widget = widget
         self._config = get_config()
         self._config.set_cursor_busy(widget=self.widget)
@@ -950,17 +955,29 @@ class LongRunningTask(Thread):
             if self._target:
                 retval = self._target(*self._args, **self._kwargs)
                 self._queue.put(retval)
-                self.complete.set()
+        except Exception:  # pylint: disable=broad-except
+            self.err = sys.exc_info()
+            logger.debug("Error in thread (%s): %s", self._name,
+                         self.err[1].with_traceback(self.err[2]))
         finally:
+            self.complete.set()
             # Avoid a refcycle if the thread is running a function with
             # an argument that has a member that points to the thread.
             del self._target, self._args, self._kwargs
 
     def get_result(self):
         """ Return the result from the queue """
-        if self.complete.is_set():
-            logger.debug("Getting result from thread")
-            retval = self._queue.get()
+        if not self.complete.is_set():
+            logger.warning("Aborting attempt to retrieve result from a LongRunningTask that is "
+                           "still running")
+            return None
+        if self.err:
+            logger.debug("Error caught in thread")
+            self._config.set_cursor_default(widget=self.widget)
+            raise self.err[1].with_traceback(self.err[2])
+
+        logger.debug("Getting result from thread")
+        retval = self._queue.get()
         logger.debug("Got result from thread")
         self._config.set_cursor_default(widget=self.widget)
         return retval
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index 64cf879..abf81a2 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -11,7 +11,7 @@ from time import time
 
 import psutil
 
-from .utils import get_config, get_images
+from .utils import get_config, get_images, LongRunningTask
 
 if os.name == "nt":
     import win32console  # pylint: disable=import-error
@@ -47,6 +47,8 @@ class ProcessWrapper():
         category, command = self.tk_vars["action"].get().split(",")
 
         if self.tk_vars["runningtask"].get():
+            if self.task.command == "train":
+                self.tk_vars["istraining"].set(False)
             self.task.terminate()
         else:
             self.command = command
@@ -70,6 +72,8 @@ class ProcessWrapper():
         logger.debug("Preparing for execution")
         self.tk_vars["runningtask"].set(True)
         self.tk_vars["consoleclear"].set(True)
+        if self.command == "train":
+            self.tk_vars["istraining"].set(True)
         print("Loading...")
 
         self.statusbar.status_message.set("Executing - {}.py".format(self.command))
@@ -141,6 +145,7 @@ class FaceswapControl():
         self.command = None
         self.args = None
         self.process = None
+        self.thread = None  # Thread for LongRunningTask termination
         self.train_stats = {"iterations": 0, "timestamp": None}
         self.consoleregex = {
             "loss": re.compile(r"([a-zA-Z_]+):.*?(\d+\.\d+)"),
@@ -333,9 +338,26 @@ class FaceswapControl():
         return True
 
     def terminate(self):
+        """ Terminate the running process in a LongRunningTask so we can still
+            output to console """
+        root = get_config().root
+        if self.thread is None:
+            logger.debug("Terminating wrapper in LongRunningTask")
+            self.thread = LongRunningTask(target=self.terminate_in_thread,
+                                          args=(self.command, self.process))
+            self.thread.start()
+            root.after(1000, self.terminate)
+        elif not self.thread.complete.is_set():
+            logger.debug("Not finished terminating")
+            root.after(1000, self.terminate)
+        else:
+            logger.debug("Termination Complete. Cleaning up")
+            _ = self.thread.get_result()  # Terminate the LongRunningTask object
+
+    def terminate_in_thread(self, command, process):
         """ Terminate the subprocess """
         logger.debug("Terminating wrapper")
-        if self.command == "train":
+        if command == "train":
             timeout = get_config().tk_vars["traintimeout"].get()
             logger.debug("Sending Exit Signal")
             print("Sending Exit Signal", flush=True)
@@ -348,16 +370,17 @@ class FaceswapControl():
                 con_in.WriteConsoleInput([keypress])
             else:
                 logger.debug("Sending SIGINT to process")
-                self.process.send_signal(signal.SIGINT)
+                process.send_signal(signal.SIGINT)
             while True:
                 timeelapsed = time() - now
-                if self.process.poll() is not None:
+                if process.poll() is not None:
                     break
                 if timeelapsed > timeout:
                     logger.error("Timeout reached sending Exit Signal")
                     self.terminate_all_children()
         else:
             self.terminate_all_children()
+        return True
 
     @staticmethod
     def generate_windows_keypress(character):
diff --git a/scripts/train.py b/scripts/train.py
index e7127e4..52e6544 100644
--- a/scripts/train.py
+++ b/scripts/train.py
@@ -114,9 +114,10 @@ class Train():
             log = logger.critical
         else:
             msg = ("Exit requested! The trainer will complete its current cycle, "
-                   "save the models and quit (it can take up a couple of seconds "
-                   "depending on your training speed). If you want to kill it now, "
-                   "press Ctrl + c")
+                   "save the models and quit (This can take a couple of minutes "
+                   "depending on your training speed).")
+            if not self.args.redirect_gui:
+                msg += " If you want to kill it now, press Ctrl + c"
             log = logger.info
         log(msg)
         self.stop = True

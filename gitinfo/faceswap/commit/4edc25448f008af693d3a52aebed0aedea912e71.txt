commit 4edc25448f008af693d3a52aebed0aedea912e71
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Oct 25 18:08:20 2019 +0000

    Mask tool
    
    tools.mask - A tool for creating masks for existing alignments files and outputting mask previews
    lib.image.BackgroundIO - A background image loader and saver

diff --git a/docs/full/modules.rst b/docs/full/modules.rst
index f632b60..09bbbac 100644
--- a/docs/full/modules.rst
+++ b/docs/full/modules.rst
@@ -6,3 +6,4 @@ faceswap
 
    lib
    plugins
+   tools
diff --git a/docs/full/tools.mask.rst b/docs/full/tools.mask.rst
new file mode 100644
index 0000000..5a5d3e0
--- /dev/null
+++ b/docs/full/tools.mask.rst
@@ -0,0 +1,7 @@
+tools.mask module
+======================================
+
+.. automodule:: tools.mask
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/docs/full/tools.rst b/docs/full/tools.rst
new file mode 100644
index 0000000..45b22b5
--- /dev/null
+++ b/docs/full/tools.rst
@@ -0,0 +1,17 @@
+tools package
+=============
+
+Subpackages
+-----------
+
+.. toctree::
+
+   tools.mask
+
+Module contents
+---------------
+
+.. automodule:: tools
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/lib/image.py b/lib/image.py
index 9913aca..5466d8f 100644
--- a/lib/image.py
+++ b/lib/image.py
@@ -3,16 +3,20 @@
 
 import logging
 import subprocess
+import os
 import sys
 
 from concurrent import futures
 from hashlib import sha1
 
 import cv2
+import imageio
 import imageio_ffmpeg as im_ffm
 import numpy as np
 
-from lib.utils import convert_to_secs, FaceswapError
+from lib.multithreading import MultiThread
+from lib.queue_manager import queue_manager, QueueEmpty
+from lib.utils import convert_to_secs, FaceswapError, _video_extensions, get_image_paths
 
 logger = logging.getLogger(__name__)  # pylint:disable=invalid-name
 
@@ -23,7 +27,7 @@ logger = logging.getLogger(__name__)  # pylint:disable=invalid-name
 
 # <<< IMAGE IO >>> #
 
-def read_image(filename, raise_error=False):
+def read_image(filename, raise_error=False, with_hash=False):
     """ Read an image file from a file location.
 
     Extends the functionality of :func:`cv2.imread()` by ensuring that an image was actually
@@ -35,20 +39,23 @@ def read_image(filename, raise_error=False):
     filename: str
         Full path to the image to be loaded.
     raise_error: bool, optional
-        If ``True``, then any failures (including the returned image being ``None``) will be
+        If ``True`` then any failures (including the returned image being ``None``) will be
         raised. If ``False`` then an error message will be logged, but the error will not be
         raised. Default: ``False``
+    with_hash: bool, optional
+        If ``True`` then returns the image's sha1 hash with the image. Default: ``False``
 
     Returns
     -------
-    numpy.ndarray
-        The image in `BGR` channel order.
-
+    numpy.ndarray or tuple
+        If :attr:`with_hash` is ``False`` then returns a `numpy.ndarray` of the image in `BGR`
+        channel order. If :attr:`with_hash` is ``True`` then returns a `tuple` of (`numpy.ndarray`"
+        of the image in `BGR`, `str` of sha` hash of image)
     Example
     -------
     >>> image_file = "/path/to/image.png"
     >>> try:
-    >>>    image = read_image(image_file, raise_error=True)
+    >>>    image = read_image(image_file, raise_error=True, with_hash=False)
     >>> except:
     >>>     raise ValueError("There was an error")
     """
@@ -79,7 +86,8 @@ def read_image(filename, raise_error=False):
         if raise_error:
             raise Exception(msg)
     logger.trace("Loaded image: '%s'. Success: %s", filename, success)
-    return image
+    retval = (image, sha1(image).hexdigest()) if with_hash else image
+    return retval
 
 
 def read_image_batch(filenames):
@@ -258,7 +266,7 @@ def count_frames_and_secs(filename, timeout=90):
     """ Count the number of frames and seconds in a video file.
 
     Adapted From :mod:`ffmpeg_imageio` to handle the issue of ffmpeg occasionally hanging
-    inside a subprocess.
+    inside a sub-process.
 
     If the operation times out then the process will try to read the data again, up to a total
     of 3 times. If the data still cannot be read then an exception will be raised.
@@ -275,9 +283,9 @@ def count_frames_and_secs(filename, timeout=90):
 
     Returns
     -------
-    nframes: int
+    frames: int
         The number of frames in the given video file.
-    nsecs: float
+    secs: float
         The duration, in seconds, of the given video file.
 
     Example
@@ -318,7 +326,7 @@ def count_frames_and_secs(filename, timeout=90):
                            "Retrying %s of %s", this_attempt + 1, attempts)
             continue
 
-    # Note that other than with the subprocess calls below, ffmpeg wont hang here.
+    # Note that other than with the sub-process calls below, ffmpeg wont hang here.
     # Worst case Python will stop/crash and ffmpeg will continue running until done.
 
     nframes = nsecs = None
@@ -338,4 +346,270 @@ def count_frames_and_secs(filename, timeout=90):
         logger.debug("nframes: %s, nsecs: %s", nframes, nsecs)
         return nframes, nsecs
 
-    raise RuntimeError("Could not get number of frames")  # pragma: no cover
+    raise RuntimeError("Could not get number of frames")
+
+
+class BackgroundIO():
+    """ Perform disk IO for images or videos in a background thread.
+
+    Loads images or videos from a given location in a background thread.
+    Saves images to the given location in a background thread.
+    Images/Videos will be loaded or saved in deterministic order.
+
+    Parameters
+    ----------
+    path: str
+        The path to load or save images to/from. For loading this can be a folder which contains
+        images or a video file. For saving this must be an existing folder.
+    task: {'load', 'save'}
+        The task to be performed. ``'load'`` to load images/video frames, ``'save'`` to save
+        images.
+    load_with_hash: bool, optional
+        When loading images, set to ``True`` to return the sha1 hash of the image along with the
+        image. Default: ``False``.
+    queue_size: int, optional
+        The amount of images to hold in the internal buffer. Default: 16.
+
+    Examples
+    --------
+    Loading from a video file:
+
+    >>> loader = BackgroundIO('/path/to/video.mp4', 'load')
+    >>> for filename, image in loader.load():
+    >>>     <do processing>
+
+    Loading faces with their sha1 hash:
+
+    >>> loader = BackgroundIO('/path/to/faces/folder', 'load', load_with_hash=True)
+    >>> for filename, image, sha1_hash in loader.load():
+    >>>     <do processing>
+
+    Saving out images:
+
+    >>> saver = BackgroundIO('/path/to/save/folder', 'save')
+    >>> for filename, image in <image_iterator>:
+    >>>     saver.save(filename, image)
+    >>> saver.close()
+    """
+
+    def __init__(self, path, task, load_with_hash=False, queue_size=16):
+        logger.debug("Initializing %s: (path: %s, task: %s, load_with_hash: %s, queue_size: %s)",
+                     self.__class__.__name__, path, task, load_with_hash, queue_size)
+        self._location = path
+
+        self._task = task.lower()
+        self._is_video = self._check_input()
+        self._input = self.location if self._is_video else get_image_paths(self.location)
+        self._count = count_frames_and_secs(self._input)[0] if self._is_video else len(self._input)
+        self._queue = queue_manager.get_queue(name="{}_{}".format(self.__class__.__name__,
+                                                                  self._task),
+                                              maxsize=queue_size)
+        self._thread = self._set_thread(io_args=(load_with_hash, ))
+        self._thread.start()
+
+    @property
+    def count(self):
+        """ int: The number of images or video frames to be processed """
+        return self._count
+
+    @property
+    def location(self):
+        """ str: The folder or video that was passed in as the :attr:`path` parameter. """
+        return self._location
+
+    def _check_input(self):
+        """ Check whether the input path is valid and return if it is a video.
+
+        Returns
+        -------
+        bool: 'True' if input is a video 'False' if it is a folder.
+        """
+        if not os.path.exists(self.location):
+            raise FaceswapError("The location '{}' does not exist".format(self.location))
+
+        if self._task == "save" and not os.path.isdir(self.location):
+            raise FaceswapError("The output location '{}' is not a folder".format(self.location))
+
+        is_video = (self._task == "load" and
+                    os.path.isfile(self.location) and
+                    os.path.splitext(self.location)[1].lower() in _video_extensions)
+        if is_video:
+            logger.debug("Input is video")
+        else:
+            logger.debug("Input is folder")
+        return is_video
+
+    def _set_thread(self, io_args=None):
+        """ Set the load/save thread
+
+        Parameters
+        ----------
+        io_args: tuple, optional
+            The arguments to be passed to the load or save thread. Default: `None`.
+
+        Returns
+        -------
+        :class:`lib.multithreading.MultiThread`: Thread containing the load/save function.
+        """
+        io_args = (self._queue) if io_args is None else (self._queue, *io_args)
+        retval = MultiThread(getattr(self, "_{}".format(self._task)), *io_args, thread_count=1)
+        logger.trace(retval)
+        return retval
+
+    # LOADING #
+    def _load(self, *args):
+        """ The load thread.
+
+        Loads from a folder of images or from a video and puts to a queue
+
+        Parameters
+        ----------
+        args: tuple
+            The arguments to be passed to the load iterator
+        """
+        queue = args[0]
+        io_args = args[1:]
+        iterator = self._load_video if self._is_video else self._load_images
+        logger.debug("Load iterator: %s", iterator)
+        for retval in iterator(*io_args):
+            logger.trace("Putting to queue: %s", [v.shape if isinstance(v, np.ndarray) else v
+                                                  for v in retval])
+            queue.put(retval)
+        logger.trace("Putting EOF")
+        queue.put("EOF")
+
+    def _load_video(self, *args):  # pylint:disable=unused-argument
+        """ Generator for loading frames from a video
+
+        Parameters
+        ----------
+        args: tuple
+            Unused
+
+        Yields
+        ------
+        filename: str
+            The dummy filename of the loaded video frame.
+        image: numpy.ndarray
+            The loaded video frame.
+        """
+        logger.debug("Loading frames from video: '%s'", self._input)
+        vidname = os.path.splitext(os.path.basename(self._input))[0]
+        reader = imageio.get_reader(self._input, "ffmpeg")
+        for i, frame in enumerate(reader):
+            # Convert to BGR for cv2 compatibility
+            frame = frame[:, :, ::-1]
+            filename = "{}_{:06d}.png".format(vidname, i + 1)
+            logger.trace("Loading video frame: '%s'", filename)
+            yield filename, frame
+        reader.close()
+
+    def _load_images(self, with_hash):
+        """ Generator for loading images from a folder
+
+        Parameters
+        ----------
+        with_hash: bool
+            If ``True`` adds the sha1 hash to the output tuple as the final item.
+
+        Yields
+        ------
+        filename: str
+            The filename of the loaded image.
+        image: numpy.ndarray
+            The loaded image.
+        sha1_hash: str, optional
+            The sha1 hash of the loaded image. Only yielded if :class:`BackgroundIO` was
+            initialized with :attr:`load_with_hash` set to ``True`` and the :attr:`location`
+            is a folder of images.
+        """
+        logger.debug("Loading images from folder: '%s'", self._input)
+        for filename in self._input:
+            image_read = read_image(filename, raise_error=False, with_hash=with_hash)
+            if with_hash:
+                retval = filename, *image_read
+            else:
+                retval = filename, image_read
+            if retval[1] is None:
+                logger.debug("Image not loaded: '%s'", filename)
+                continue
+            yield retval
+
+    def load(self):
+        """ Generator for loading images from the given :attr:`location`
+
+        If :class:`BackgroundIO` was initialized with :attr:`load_with_hash` set to ``True`` then
+        the sha1 hash of the image is added as the final item in the output `tuple`.
+
+        Yields
+        ------
+        filename: str
+            The filename of the loaded image.
+        image: numpy.ndarray
+            The loaded image.
+        sha1_hash: str, optional
+            The sha1 hash of the loaded image. Only yielded if :class:`BackgroundIO` was
+            initialized with :attr:`load_with_hash` set to ``True`` and the :attr:`location`
+            is a folder of images.
+        """
+        while True:
+            self._thread.check_and_raise_error()
+            try:
+                retval = self._queue.get(True, 1)
+            except QueueEmpty:
+                continue
+            if retval == "EOF":
+                logger.trace("Got EOF")
+                break
+            logger.trace("Yielding: %s", [v.shape if isinstance(v, np.ndarray) else v
+                                          for v in retval])
+            yield retval
+        self._thread.join()
+
+    # SAVING #
+    @staticmethod
+    def _save(*args):
+        """ Saves images from the save queue to the given :attr:`location` inside a thread.
+
+        Parameters
+        ----------
+        args: tuple
+            The save arguments
+        """
+        queue = args[0]
+        while True:
+            item = queue.get()
+            if item == "EOF":
+                logger.debug("EOF received")
+                break
+            filename, image = item
+            logger.trace("Saving image: '%s'", filename)
+            cv2.imwrite(filename, image)
+
+    def save(self, filename, image):
+        """ Save the given image in the background thread
+
+        Ensure that :func:`close` is called once all save operations are complete.
+
+        Parameters
+        ----------
+        filename: str
+            The filename of the image to be saved
+        image: numpy.ndarray
+            The image to be saved
+        """
+        logger.trace("Putting to save queue: '%s'", filename)
+        self._queue.put((filename, image))
+
+    def close(self):
+        """ Closes down and joins the internal threads
+
+        Must be called after a :func:`save` operation to ensure all items are saved before the
+        parent process exits.
+        """
+        logger.debug("Received Close")
+        if self._task == "save":
+            logger.debug("Putting EOF to save queue")
+            self._queue.put("EOF")
+        self._thread.join()
+        logger.debug("Closed")
diff --git a/tools.py b/tools.py
index 0032d74..fed945c 100755
--- a/tools.py
+++ b/tools.py
@@ -37,6 +37,9 @@ if __name__ == "__main__":
     EFFMPEG = cli.EffmpegArgs(SUBPARSER,
                               "effmpeg",
                               "This command allows you to easily execute common ffmpeg tasks.")
+    MASK = cli.MaskArgs(SUBPARSER,
+                        "mask",
+                        "This command lets you generate masks for existing alignments.")
     RESTORE = cli.RestoreArgs(SUBPARSER,
                               "restore",
                               "This command lets you restore models from backup.")
diff --git a/tools/cli.py b/tools/cli.py
index c3331de..eb80c59 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -6,10 +6,11 @@ from lib.cli import FaceSwapArgs
 from lib.cli import (ContextFullPaths, DirOrFileFullPaths, DirFullPaths, FileFullPaths,
                      FilesFullPaths, SaveFileFullPaths, Radio, Slider)
 from lib.utils import _image_extensions
+from plugins.plugin_loader import PluginLoader
 
 
 class AlignmentsArgs(FaceSwapArgs):
-    """ Class to parse the command line arguments for Aligments tool """
+    """ Class to parse the command line arguments for Alignments tool """
 
     @staticmethod
     def get_info():
@@ -430,6 +431,117 @@ class EffmpegArgs(FaceSwapArgs):
         return argument_list
 
 
+class MaskArgs(FaceSwapArgs):
+    """ Class to parse the command line arguments for Mask tool """
+
+    @staticmethod
+    def get_info():
+        """ Return command information """
+        return "Mask tool\nGenerate masks for existing alignments files."
+
+    def get_argument_list(self):
+        argument_list = list()
+        argument_list.append({
+            "opts": ("-a", "--alignments"),
+            "action": FileFullPaths,
+            "type": str,
+            "group": "data",
+            "required": True,
+            "filetypes": "alignments",
+            "help": "Full path to the alignments file to add the mask to. NB: if the mask already "
+                    "exists in the alignments file it will be overwritten."})
+        argument_list.append({
+            "opts": ("-i", "--input"),
+            "action": DirOrFileFullPaths,
+            "type": str,
+            "group": "data",
+            "required": True,
+            "help": "Directory containing extracted faces, source frames, or a video file."})
+        argument_list.append({
+            "opts": ("-it", "--input-type"),
+            "action": Radio,
+            "type": str.lower,
+            "choices": ("faces", "frames"),
+            "dest": "input_type",
+            "group": "data",
+            "default": "frames",
+            "help": "R|Whether the `input` is a folder of faces or a folder frames/video"
+                    "\nL|faces: The input is a folder containing extracted faces."
+                    "\nL|frames: The input is a folder containing frames or is a video"})
+        argument_list.append({
+            "opts": ("-M", "--masker"),
+            "action": Radio,
+            "type": str.lower,
+            "choices": PluginLoader.get_available_extractors("mask"),
+            "default": "extended",
+            "group": "process",
+            "help": "R|Masker to use."
+                    "\nL|components: Mask designed to provide facial segmentation based on the "
+                    "positioning of landmark locations. A convex hull is constructed around the "
+                    "exterior of the landmarks to create a mask."
+                    "\nL|extended: Mask designed to provide facial segmentation based on the "
+                    "positioning of landmark locations. A convex hull is constructed around the "
+                    "exterior of the landmarks and the mask is extended upwards onto the forehead."
+                    "\nL|vgg-clear: Mask designed to provide smart segmentation of mostly frontal "
+                    "faces clear of obstructions. Profile faces and obstructions may result in "
+                    "sub-par performance."
+                    "\nL|vgg-obstructed: Mask designed to provide smart segmentation of mostly "
+                    "frontal faces. The mask model has been specifically trained to recognize "
+                    "some facial obstructions (hands and eyeglasses). Profile faces may result in "
+                    "sub-par performance."
+                    "\nL|unet-dfl: Mask designed to provide smart segmentation of mostly frontal "
+                    "faces. The mask model has been trained by community members and will need "
+                    "testing for further description. Profile faces may result in sub-par "
+                    "performance."})
+        argument_list.append({
+            "opts": ("-p", "--processing"),
+            "action": Radio,
+            "type": str.lower,
+            "choices": ("all", "missing", "output"),
+            "default": "missing",
+            "group": "process",
+            "help": "R|Whether to update all masks in the alignments files, only those faces "
+                    "that do not already have a mask of the given `mask type` or just to output "
+                    "the masks to the `output` location."
+                    "\nL|all: Update the mask for all faces in the alignments file."
+                    "\nL|missing: Create a mask for all faces in the alignments file where a mask "
+                    "does not previously exist."
+                    "\nL|output: Don't update the masks, just output them for review in the given "
+                    "output folder."})
+        argument_list.append({
+            "opts": ("-o", "--output-folder"),
+            "action": DirFullPaths,
+            "dest": "output",
+            "type": str,
+            "group": "output",
+            "help": "Optional output location. If provided, a preview of the masks created will "
+                    "be output in the given folder."})
+        argument_list.append({
+            "opts": ("-b", "--blur_kernel"),
+            "action": Slider,
+            "type": int,
+            "group": "output",
+            "min_max": (0, 8),
+            "default": 3,
+            "rounding": 1,
+            "help": "Apply gaussian blur to the mask output. Has the effect of smoothing the "
+                    "edges of the mask giving less of a hard edge. the size is in pixels. NB: "
+                    "Only effects the output preview. Set to 0 for off"})
+        argument_list.append({
+            "opts": ("-t", "--threshold"),
+            "action": Slider,
+            "type": int,
+            "group": "output",
+            "min_max": (0, 50),
+            "default": 4,
+            "rounding": 1,
+            "help": "Helps reduce 'blotchiness' on some masks by making light shades white "
+                    "and dark shades black. Higher values will impact more of the mask. NB: "
+                    "Only effects the output preview. Set to 0 for off"})
+
+        return argument_list
+
+
 class RestoreArgs(FaceSwapArgs):
     """ Class to restore model files from backup """
 
diff --git a/tools/mask.py b/tools/mask.py
new file mode 100644
index 0000000..c803c5b
--- /dev/null
+++ b/tools/mask.py
@@ -0,0 +1,368 @@
+#!/usr/bin/env python3
+""" Tool to generate masks and previews of masks for existing alignments file """
+import logging
+import os
+
+import cv2
+import numpy as np
+from tqdm import tqdm
+
+from lib.alignments import Alignments
+from lib.faces_detect import DetectedFace
+from lib.image import BackgroundIO
+
+from lib.multithreading import MultiThread
+from lib.utils import set_system_verbosity, get_folder
+from plugins.extract.pipeline import Extractor
+
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
+
+class Mask():
+    """ This tool is part of the Faceswap Tools suite and should be called from
+    ``python tools.py mask``.
+
+    Faceswap Masks tool. Generate masks from existing alignments files, and output masks
+    for preview.
+
+    Parameters
+    ----------
+    arguments: :class:`argparse.Namespace`
+        The :mod:`argparse` arguments as passed in from :mod:`tools.py`
+    """
+    def __init__(self, arguments):
+        logger.debug("Initializing %s: (arguments: %s", self.__class__.__name__, arguments)
+        print(type(arguments))
+        exit(0)
+        set_system_verbosity(arguments.loglevel)
+        self._update_type = arguments.processing
+        self._input_is_faces = arguments.input_type == "faces"
+        self._mask_type = arguments.masker
+        self._output_opts = dict(blur_kernel=arguments.blur_kernel, threshold=arguments.threshold)
+
+        self._face_count = 0
+        self._skip_count = 0
+        self._update_count = 0
+
+        self._check_input(arguments.input)
+        self._saver = self._set_saver(arguments)
+        self._loader = BackgroundIO(arguments.input,
+                                    "load",
+                                    load_with_hash=self._input_is_faces,
+                                    queue_size=16)
+        self._alignments = Alignments(os.path.dirname(arguments.alignments),
+                                      filename=os.path.basename(arguments.alignments))
+
+        self._extractor = self._get_extractor()
+        self._extractor_input_thread = self._feed_extractor()
+
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def _check_input(self, mask_input):
+        """ Check the input is valid. If it isn't exit with a logged error
+
+        Parameters
+        ----------
+        mask_input: str
+            Path to the input folder/video
+        """
+        if not os.path.exists(mask_input):
+            logger.error("Location cannot be found: '%s'", mask_input)
+            exit(0)
+        if os.path.isfile(mask_input) and self._input_is_faces:
+            logger.error("Input type 'faces' was selected but input is not a folder: '%s'",
+                         mask_input)
+            exit(0)
+        logger.debug("input '%s' is valid", mask_input)
+
+    def _set_saver(self, arguments):
+        """ set the saver in a background thread
+
+        Parameters
+        ----------
+        arguments: :class:`argparse.Namespace`
+            The :mod:`argparse` arguments as passed in from :mod:`tools.py`
+
+        Returns
+        -------
+        ``None`` or :class:`lib.image.BackgroundIO`:
+            If output is requested, returns a :class:`lib.image.BackgroundIO` in saver mode
+            otherwise returns ``None``
+        """
+        if not hasattr(arguments, "output") or arguments.output is None or not arguments.output:
+            if self._update_type == "output":
+                logger.error("Processing set as 'output' but no output folder provided.")
+                exit(0)
+            logger.debug("No output provided. Not creating saver")
+            return None
+        output_dir = str(get_folder(arguments.output, make_folder=True))
+        logger.info("Saving preview masks to: '%s'", output_dir)
+        saver = BackgroundIO(output_dir, "save", queue_size=16)
+        logger.debug(saver)
+        return saver
+
+    def _get_extractor(self):
+        """ Obtain a Mask extractor plugin and launch it
+
+        Returns
+        -------
+        :class:`plugins.extract.pipeline.Extractor`:
+            The launched Extractor
+        """
+        if self._update_type == "output":
+            logger.debug("Update type `output` selected. Not launching extractor")
+            return None
+        logger.debug("masker: %s", self._mask_type)
+        extractor = Extractor(None, None, self._mask_type,
+                              image_is_aligned=self._input_is_faces)
+        extractor.launch()
+        logger.debug(extractor)
+        return extractor
+
+    def _feed_extractor(self):
+        """ Feed the input queue to the Extractor from a faces folder or from source frames in a
+        background thread
+
+        Returns
+        -------
+        :class:`lib.multithreading.Multithread`:
+            The thread that is feeding the extractor.
+        """
+        masker_input = getattr(self,
+                               "_input_{}".format("faces" if self._input_is_faces else "frames"))
+        logger.debug("masker_input: %s", masker_input)
+
+        args = tuple() if self._update_type == "output" else (self._extractor.input_queue, )
+        input_thread = MultiThread(masker_input, *args, thread_count=1)
+        input_thread.start()
+        logger.debug(input_thread)
+        return input_thread
+
+    def _input_faces(self, *args):
+        """ Input pre-aligned faces to the Extractor plugin inside a thread
+
+        Parameters
+        ----------
+        args: tuple
+            The arguments that are to be loaded inside this thread. Contains the queue that the
+            faces should be put to
+        """
+        logger.debug("args: %s", args)
+        if self._update_type != "output":
+            queue = args[0]
+        for filename, image, hsh in tqdm(self._loader.load(), total=self._loader.count):
+            if hsh not in self._alignments.hashes_to_frame:
+                self._skip_count += 1
+                logger.warning("Skipping face not in alignments file: '%s'", filename)
+                continue
+            for frame, idx in self._alignments.hashes_to_frame[hsh].items():
+                self._face_count += 1
+                alignment = self._alignments.get_faces_in_frame(frame)[idx]
+                if self._check_for_missing(frame, idx, alignment):
+                    continue
+                detected_face = self._get_detected_face(alignment)
+                if self._update_type == "output":
+                    detected_face.image = image
+                    self._save(frame, idx, detected_face)
+                else:
+                    queue.put(dict(filename=filename, image=image, detected_faces=[detected_face]))
+                    self._update_count += 1
+        if self._update_type != "output":
+            queue.put("EOF")
+
+    def _input_frames(self, *args):
+        """ Input frames to the Extractor plugin inside a thread
+
+        Parameters
+        ----------
+        args: tuple
+            The arguments that are to be loaded inside this thread. Contains the queue that the
+            faces should be put to
+        """
+        logger.debug("args: %s", args)
+        if self._update_type != "output":
+            queue = args[0]
+        for filename, image in tqdm(self._loader.load(), total=self._loader.count):
+            frame = os.path.basename(filename)
+            if not self._alignments.frame_exists(frame):
+                self._skip_count += 1
+                logger.warning("Skipping frame not in alignments file: '%s'", frame)
+                continue
+            if not self._alignments.frame_has_faces(frame):
+                logger.debug("Skipping frame with no faces: '%s'", frame)
+                continue
+            detected_faces = []
+            for idx, alignment in enumerate(self._alignments.get_faces_in_frame(frame)):
+                self._face_count += 1
+                if self._check_for_missing(frame, idx, alignment):
+                    continue
+                detected_face = self._get_detected_face(alignment)
+                if self._update_type == "output":
+                    detected_face.image = image
+                    self._save(frame, idx, detected_face)
+                else:
+                    detected_faces.append(detected_face)
+                    self._update_count += 1
+            if self._update_type != "output":
+                queue.put(dict(filename=filename, image=image, detected_faces=detected_faces))
+        if self._update_type != "output":
+            queue.put("EOF")
+
+    def _check_for_missing(self, frame, idx, alignment):
+        """ Check if the alignment is missing the requested mask_type
+
+        Parameters
+        ----------
+        frame: str
+            The frame name in the alignments file
+        idx: int
+            The index of the face for this frame in the alignments file
+        alignment: dict
+            The alignment for a face
+
+        Returns
+        -------
+        bool:
+            ``True`` if the update_type is "missing" and the mask does not exist in the alignments
+            file otherwise ``False``
+        """
+        retval = (self._update_type == "missing" and
+                  alignment.get("mask", None) is not None and
+                  alignment["mask"].get(self._mask_type, None) is not None)
+        if retval:
+            logger.debug("Not updating existing mask for face: '%s' - %s", frame, idx)
+        return retval
+
+    @staticmethod
+    def _get_detected_face(alignment):
+        """ Convert an alignment dict item to a detected_face object
+
+        Parameters
+        ----------
+        alignment: dict
+            The alignment dict for a face
+
+        Returns
+        -------
+        :class:`lib.FacesDetect.detected_face`:
+            The corresponding detected_face object for the alignment
+        """
+        detected_face = DetectedFace()
+        detected_face.from_alignment(alignment)
+        return detected_face
+
+    def process(self):
+        """ The entry point for the Mask tool from :file:`lib.tools.cli`. Runs the Mask process """
+        logger.debug("Starting masker process")
+        updater = getattr(self, "_update_{}".format("faces" if self._input_is_faces else "frames"))
+        if self._update_type != "output":
+            for extractor_output in self._extractor.detected_faces():
+                self._extractor_input_thread.check_and_raise_error()
+                updater(extractor_output)
+            self._extractor_input_thread.join()
+            if self._update_count != 0:
+                self._alignments.backup()
+                self._alignments.save()
+        else:
+            self._extractor_input_thread.join()
+            self._saver.close()
+
+        if self._skip_count != 0:
+            logger.warning("%s face(s) skipped due to not existing in the alignments file",
+                           self._skip_count)
+        if self._update_type != "output":
+            if self._update_count == 0:
+                logger.warning("No masks were updated of the %s faces seen", self._face_count)
+            else:
+                logger.info("Updated masks for %s faces of %s",
+                            self._update_count, self._face_count)
+        logger.debug("Completed masker process")
+
+    def _update_faces(self, extractor_output):
+        """ Update alignments for the mask if the input type is a faces folder
+
+        If an output location has been indicated, then puts the mask preview to the save queue
+
+        Parameters
+        ----------
+        extractor_output: dict
+            The output from the :class:`plugins.extract.pipeline.Extractor` object
+        """
+        for face in extractor_output["detected_faces"]:
+            for frame, idx in self._alignments.hashes_to_frame[face.hash].items():
+                self._alignments.update_face(frame, idx, face.to_alignment())
+                if self._saver is not None:
+                    self._save(frame, idx, face)
+
+    def _update_frames(self, extractor_output):
+        """ Update alignments for the mask if the input type is a frames folder or video
+
+        If an output location has been indicated, then puts the mask preview to the save queue
+
+        Parameters
+        ----------
+        extractor_output: dict
+            The output from the :class:`plugins.extract.pipeline.Extractor` object
+        """
+        frame = os.path.basename(extractor_output["filename"])
+        for idx, face in enumerate(extractor_output["detected_faces"]):
+            self._alignments.update_face(frame, idx, face.to_alignment())
+            if self._saver is not None:
+                self._save(frame, idx, face)
+
+    def _save(self, frame, idx, detected_face):
+        """ Build the mask preview image and save
+
+        Parameters
+        ----------
+        frame: str
+            The frame name in the alignments file
+        idx: int
+            The index of the face for this frame in the alignments file
+        detected_face: `lib.FacesDetect.detected_face`
+            A detected_face object for a face
+        """
+        filename = os.path.join(self._saver.location,
+                                "{}_{}_{}_mask_preview.png".format(os.path.splitext(frame)[0],
+                                                                   idx,
+                                                                   self._mask_type))
+        if detected_face.mask is None or detected_face.mask.get(self._mask_type, None) is None:
+            logger.warning("Mask type '%s' does not exist for frame '%s' index %s. Skipping",
+                           self._mask_type, frame, idx)
+            return
+        image = self._create_image(detected_face)
+        logger.trace("filename: '%s', image_shape: %s", image.shape)
+        self._saver.save(filename, image)
+
+    def _create_image(self, detected_face):
+        """ Create a mask preview image for saving out to disk
+
+        Parameters
+        ----------
+        detected_face: `lib.FacesDetect.detected_face`
+            A detected_face object for a face
+
+        Returns
+        numpy.ndarray:
+            A preview image, containing 3 sub images: The original face, the masked face and
+            the mask.
+        """
+        if self._input_is_faces:
+            face = detected_face.image
+        else:
+            detected_face.load_aligned(detected_face.image)
+            face = detected_face.aligned_face
+        size = face.shape[0]
+        detected_face.mask[self._mask_type].set_blur_kernel_and_threshold(**self._output_opts)
+        mask = cv2.resize(detected_face.mask[self._mask_type].mask,
+                          (size, size),
+                          interpolation=cv2.INTER_CUBIC)[..., None]
+        masked = (face.astype("float32") * mask.astype("float32") / 255.).astype("uint8")
+        mask = np.tile(mask, 3)
+
+        for img in (face, masked, mask):
+            cv2.rectangle(img, (0, 0), (size - 1, size - 1), (255, 255, 255), 1)
+
+        out_image = np.concatenate((face, masked, mask), axis=1)
+        return out_image

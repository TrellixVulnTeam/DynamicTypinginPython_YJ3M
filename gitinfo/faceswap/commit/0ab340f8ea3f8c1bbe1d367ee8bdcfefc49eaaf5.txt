commit 0ab340f8ea3f8c1bbe1d367ee8bdcfefc49eaaf5
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Nov 9 11:40:24 2018 +0000

    add draw transparent to adjust. Disable seamless clone with -dt flag

diff --git a/lib/utils.py b/lib/utils.py
index 29bb2dc..106da5e 100644
--- a/lib/utils.py
+++ b/lib/utils.py
@@ -78,6 +78,26 @@ def set_system_verbosity(loglevel):
             warnings.simplefilter(action='ignore', category=warncat)
 
 
+def add_alpha_channel(image, intensity=100):
+    """ Add an alpha channel to an image
+
+        intensity: The opacity of the alpha channel between 0 and 100
+                   100 = transparent,
+                   0 = solid  """
+    assert 0 <= intensity <= 100, "Invalid intensity supplied"
+    intensity = (255.0 / 100.0) * intensity
+
+    d_type = image.dtype
+    image = image.astype("float32")
+
+    ch_b, ch_g, ch_r = cv2.split(image)  # pylint: disable=no-member
+    ch_a = np.ones(ch_b.shape, dtype="float32") * intensity
+
+    image_bgra = cv2.merge(  # pylint: disable=no-member
+        (ch_b, ch_g, ch_r, ch_a))
+    return image_bgra.astype(d_type)
+
+
 def rotate_image_by_angle(image, angle,
                           rotated_width=None, rotated_height=None):
     """ Rotate an image by a given angle.
@@ -85,7 +105,8 @@ def rotate_image_by_angle(image, angle,
 
     height, width = image.shape[:2]
     image_center = (width/2, height/2)
-    rotation_matrix = cv2.getRotationMatrix2D(image_center, -1.*angle, 1.)
+    rotation_matrix = cv2.getRotationMatrix2D(  # pylint: disable=no-member
+        image_center, -1.*angle, 1.)
     if rotated_width is None or rotated_height is None:
         abs_cos = abs(rotation_matrix[0, 0])
         abs_sin = abs(rotation_matrix[0, 1])
@@ -95,7 +116,7 @@ def rotate_image_by_angle(image, angle,
             rotated_height = int(height*abs_cos + width*abs_sin)
     rotation_matrix[0, 2] += rotated_width/2 - image_center[0]
     rotation_matrix[1, 2] += rotated_height/2 - image_center[1]
-    return (cv2.warpAffine(image,
+    return (cv2.warpAffine(image,  # pylint: disable=no-member
                            rotation_matrix,
                            (rotated_width, rotated_height)),
             rotation_matrix)
@@ -122,7 +143,8 @@ def rotate_landmarks(face, rotation_matrix):
                          face.get("y", 0) + face.get("h", 0)]]
         landmarks = face.get("landmarksXY", list())
 
-    elif isinstance(face, dlib.rectangle):
+    elif isinstance(face,
+                    dlib.rectangle):  # pylint: disable=c-extension-no-member
         bounding_box = [[face.left(), face.top()],
                         [face.right(), face.top()],
                         [face.right(), face.bottom()],
@@ -131,14 +153,15 @@ def rotate_landmarks(face, rotation_matrix):
     else:
         raise ValueError("Unsupported face type")
 
-    rotation_matrix = cv2.invertAffineTransform(rotation_matrix)
+    rotation_matrix = cv2.invertAffineTransform(  # pylint: disable=no-member
+        rotation_matrix)
     rotated = list()
     for item in (bounding_box, landmarks):
         if not item:
             continue
         points = np.array(item, np.int32)
         points = np.expand_dims(points, axis=0)
-        transformed = cv2.transform(points,
+        transformed = cv2.transform(points,  # pylint: disable=no-member
                                     rotation_matrix).astype(np.int32)
         rotated.append(transformed.squeeze())
 
@@ -167,7 +190,8 @@ def rotate_landmarks(face, rotation_matrix):
             face["landmarksXY"] = [tuple(point)
                                    for point in rotated[1].tolist()]
     else:
-        face = dlib.rectangle(int(pt_x), int(pt_y), int(pt_x1), int(pt_y1))
+        face = dlib.rectangle(  # pylint: disable=c-extension-no-member
+            int(pt_x), int(pt_y), int(pt_x1), int(pt_y1))
 
     return face
 
@@ -251,5 +275,5 @@ class Timelapse:
     def work(self):
         """ Write out timelapse image """
         image = self.trainer.show_sample(self.images_a, self.images_b)
-        cv2.imwrite(os.path.join(self.output_dir,
+        cv2.imwrite(os.path.join(self.output_dir,  # pylint: disable=no-member
                                  str(int(time())) + ".png"), image)
diff --git a/plugins/convert/Convert_Adjust.py b/plugins/convert/Convert_Adjust.py
index 59511fe..4b4217f 100644
--- a/plugins/convert/Convert_Adjust.py
+++ b/plugins/convert/Convert_Adjust.py
@@ -7,15 +7,18 @@
 import cv2
 import numpy as np
 
+from lib.utils import add_alpha_channel
+
 
 class Convert():
     """ Adjust Converter """
     def __init__(self, encoder, smooth_mask=True, avg_color_adjust=True,
-                 **kwargs):
+                 draw_transparent=False, **kwargs):
         self.encoder = encoder
 
         self.use_smooth_mask = smooth_mask
         self.use_avg_color_adjust = avg_color_adjust
+        self.draw_transparent = draw_transparent
 
     def patch_image(self, frame, detected_face, size):
         """ Patch swapped face onto original image """
@@ -51,6 +54,10 @@ class Convert():
         new_face = self.superpose(src_face, new_face, crop)
         new_image = frame.copy()
 
+        if self.draw_transparent:
+            new_image, new_face = self.convert_transparent(new_image,
+                                                           new_face)
+
         cv2.warpAffine(
             new_face,
             detected_face.adjusted_matrix,
@@ -96,3 +103,12 @@ class Convert():
         new_image = src_face.copy()
         new_image[crop, crop] = new_face
         return new_image
+
+    @staticmethod
+    def convert_transparent(image, new_face):
+        """ Add alpha channels to images and change to
+            transparent background """
+        height, width = image.shape[:2]
+        image = np.zeros((height, width, 4), dtype=np.uint8)
+        new_face = add_alpha_channel(new_face, 100)
+        return image, new_face
diff --git a/plugins/convert/Convert_Masked.py b/plugins/convert/Convert_Masked.py
index dc635bf..f03a195 100644
--- a/plugins/convert/Convert_Masked.py
+++ b/plugins/convert/Convert_Masked.py
@@ -4,6 +4,7 @@ import cv2
 import numpy
 
 from lib.aligner import get_align_mat
+from lib.utils import add_alpha_channel
 
 class Convert():
     def __init__(self, encoder, trainer, blur_size=2, seamless_clone=False, mask_type="facehullandrect", erosion_kernel_size=None, match_histogram=False, sharpen_image=None, draw_transparent=False, **kwargs):
@@ -44,33 +45,27 @@ class Convert():
 
     @staticmethod
     def convert_transparent(image, new_face, image_mask, image_size):
-        """ Add alpha channels to images and change to 
+        """ Add alpha channels to images and change to
             transparent background """
         image = numpy.zeros((image_size[1], image_size[0], 4),
                             dtype=numpy.uint8)
-        
-        mask_b, mask_g, mask_r = cv2.split(image_mask)
-        face_b, face_g, face_r = cv2.split(new_face)
-
-        alpha_mask = numpy.ones(mask_b.shape, dtype=mask_b.dtype) * 50
-        alpha_face = numpy.ones(face_b.shape, dtype=face_b.dtype) * 50
-
-        image_mask = cv2.merge((mask_b, mask_g, mask_r, alpha_mask))
-        new_face = cv2.merge((face_b, face_g, face_r, alpha_face))
+        image_mask = add_alpha_channel(image_mask, 100)
+        new_face = add_alpha_channel(new_face, 100)
         return image, new_face, image_mask
-    
+
     def apply_new_face(self, image, new_face, image_mask, mat, image_size, size):
-    
+
         if self.draw_transparent:
             image, new_face, image_mask = self.convert_transparent(image,
                                                                    new_face,
                                                                    image_mask,
                                                                    image_size)
+            self.seamless_clone = False  # Alpha channel not supported in seamless
         base_image = numpy.copy( image )
         new_image = numpy.copy( image )
 
         cv2.warpAffine( new_face, mat, image_size, new_image, cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC, cv2.BORDER_TRANSPARENT )
-        
+
         if self.sharpen_image == "bsharpen":
             # Sharpening using filter2D
             kernel = numpy.ones((3, 3)) * (-1)
@@ -85,7 +80,9 @@ class Convert():
         outimage = None
         if self.seamless_clone:
             unitMask = numpy.clip( image_mask * 365, 0, 255 ).astype(numpy.uint8)
-
+            print(unitMask.shape)
+            print(new_image.shape)
+            print(base_image.shape)
             maxregion = numpy.argwhere(unitMask==255)
 
             if maxregion.size > 0:
@@ -96,7 +93,6 @@ class Convert():
               masky = int(minx+(lenx//2))
               maskx = int(miny+(leny//2))
               outimage = cv2.seamlessClone(new_image.astype(numpy.uint8),base_image.astype(numpy.uint8),unitMask,(masky,maskx) , cv2.NORMAL_CLONE )
-
               return outimage
 
         foreground = cv2.multiply(image_mask, new_image.astype(float))

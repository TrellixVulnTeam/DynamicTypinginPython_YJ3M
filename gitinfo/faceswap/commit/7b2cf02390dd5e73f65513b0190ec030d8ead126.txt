commit 7b2cf02390dd5e73f65513b0190ec030d8ead126
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sat Oct 27 23:52:09 2018 +0100

    Bugfixes

diff --git a/lib/gpu_stats.py b/lib/gpu_stats.py
index 443f3f9..6911356 100644
--- a/lib/gpu_stats.py
+++ b/lib/gpu_stats.py
@@ -11,7 +11,7 @@ else:
     is_macos = False
 
 
-class GPUStats(object):
+class GPUStats():
     """ Holds information about system GPU(s) """
     def __init__(self):
         self.verbose = False
@@ -96,10 +96,10 @@ class GPUStats(object):
         self.initialize()
         if is_macos:
             names = [pynvx.cudaGetName(handle, ignore=True)
-                    for handle in self.handles]
+                     for handle in self.handles]
         else:
             names = [pynvml.nvmlDeviceGetName(handle).decode("utf-8")
-                    for handle in self.handles]
+                     for handle in self.handles]
         return names
 
     def get_vram(self):
@@ -109,7 +109,8 @@ class GPUStats(object):
             vram = [pynvx.cudaGetMemTotal(handle, ignore=True) / (1024 * 1024)
                     for handle in self.handles]
         else:
-            vram = [pynvml.nvmlDeviceGetMemoryInfo(handle).total / (1024 * 1024)
+            vram = [pynvml.nvmlDeviceGetMemoryInfo(handle).total /
+                    (1024 * 1024)
                     for handle in self.handles]
         return vram
 
@@ -144,6 +145,11 @@ class GPUStats(object):
     def get_card_most_free(self):
         """ Return the card and available VRAM for card with
             most VRAM free """
+        if self.device_count == 0:
+            return {"card_id": -1,
+                    "device": "No Nvidia devices found",
+                    "free": 2048,
+                    "total": 2048}
         free_vram = self.get_free()
         vram_free = max(free_vram)
         card_id = free_vram.index(vram_free)
@@ -152,7 +158,6 @@ class GPUStats(object):
                 "free": vram_free,
                 "total": self.vram[card_id]}
 
-    
     def print_info(self):
         """ Output GPU info in verbose mode """
         print("GPU Driver:       {}".format(self.driver))
diff --git a/lib/multithreading.py b/lib/multithreading.py
index 7d22022..be4331f 100644
--- a/lib/multithreading.py
+++ b/lib/multithreading.py
@@ -3,63 +3,7 @@
 
 import multiprocessing as mp
 import queue as Queue
-from queue import Empty as QueueEmpty  # Used for imports
 import threading
-from time import sleep
-
-
-class QueueManager():
-    """ Manage queues for availabilty across processes
-        Don't import this class directly, instead
-        import the variable: queue_manager """
-    def __init__(self):
-        self.manager = mp.Manager()
-        self.queues = dict()
-
-    def add_queue(self, name, maxsize=0):
-        """ Add a queue to the manager """
-        if name in self.queues.keys():
-            raise ValueError("Queue '{}' already exists.".format(name))
-        queue = self.manager.Queue(maxsize=maxsize)
-        self.queues[name] = queue
-
-    def del_queue(self, name):
-        """ remove a queue from the manager """
-        del self.queues[name]
-
-    def get_queue(self, name, maxsize=0):
-        """ Return a queue from the manager
-            If it doesn't exist, create it """
-        queue = self.queues.get(name, None)
-        if queue:
-            return queue
-        self.add_queue(name, maxsize)
-        return self.queues[name]
-
-    def terminate_queues(self):
-        """ Clear all queues and send EOF
-            To be called if there is an error """
-        for queue in self.queues.values():
-            while not queue.empty():
-                queue.get()
-            queue.put("EOF")
-
-    def debug_monitor(self, update_secs=2):
-        """ Debug tool for monitoring queues """
-        thread = MultiThread(thread_count=update_secs)
-        thread.in_thread(self.debug_queue_sizes)
-
-    def debug_queue_sizes(self):
-        """ Output the queue sizes """
-        while True:
-            print("=== QUEUE SIZES ===")
-            for name in sorted(self.queues.keys()):
-                print(name, self.queues[name].qsize())
-            print("====================\n")
-            sleep(2)
-
-
-queue_manager = QueueManager()
 
 
 class PoolProcess():
diff --git a/lib/queue_manager.py b/lib/queue_manager.py
new file mode 100644
index 0000000..e34c45a
--- /dev/null
+++ b/lib/queue_manager.py
@@ -0,0 +1,67 @@
+#!/usr/bin/env python3
+""" Queue Manager for faceswap
+
+    NB: Keep this in it's own module! If it gets loaded from
+    a multiprocess on a Windows System it will break Faceswap"""
+
+import multiprocessing as mp
+import threading
+
+from queue import Empty as QueueEmpty  # Used for imports
+from time import sleep
+
+
+class QueueManager():
+    """ Manage queues for availabilty across processes
+        Don't import this class directly, instead
+        import the variable: queue_manager """
+    def __init__(self):
+        self.manager = mp.Manager()
+        self.queues = dict()
+
+    def add_queue(self, name, maxsize=0):
+        """ Add a queue to the manager """
+        if name in self.queues.keys():
+            raise ValueError("Queue '{}' already exists.".format(name))
+        queue = self.manager.Queue(maxsize=maxsize)
+        self.queues[name] = queue
+
+    def del_queue(self, name):
+        """ remove a queue from the manager """
+        del self.queues[name]
+
+    def get_queue(self, name, maxsize=0):
+        """ Return a queue from the manager
+            If it doesn't exist, create it """
+        queue = self.queues.get(name, None)
+        if queue:
+            return queue
+        self.add_queue(name, maxsize)
+        return self.queues[name]
+
+    def terminate_queues(self):
+        """ Clear all queues and send EOF
+            To be called if there is an error """
+        for queue in self.queues.values():
+            while not queue.empty():
+                queue.get()
+            queue.put("EOF")
+
+    def debug_monitor(self, update_secs=2):
+        """ Debug tool for monitoring queues """
+        thread = threading.Thread(target=self.debug_queue_sizes,
+                                  args=(update_secs, ))
+        thread.daemon = True
+        thread.start()
+
+    def debug_queue_sizes(self, update_secs):
+        """ Output the queue sizes """
+        while True:
+            print("=== QUEUE SIZES ===")
+            for name in sorted(self.queues.keys()):
+                print(name, self.queues[name].qsize())
+            print("====================\n")
+            sleep(update_secs)
+
+
+queue_manager = QueueManager()
diff --git a/plugins/extract/align/_base.py b/plugins/extract/align/_base.py
index 1149390..f8e9b1f 100644
--- a/plugins/extract/align/_base.py
+++ b/plugins/extract/align/_base.py
@@ -114,7 +114,7 @@ class Aligner():
                 vram["device"],
                 int(vram["free"]),
                 int(vram["total"])))
-        return int(vram["free"]), int(vram["total"])
+        return int(vram["card_id"]), int(vram["free"]), int(vram["total"])
 
 
 class Extract():
diff --git a/plugins/extract/align/dlib.py b/plugins/extract/align/dlib.py
index 2d97572..931aab6 100644
--- a/plugins/extract/align/dlib.py
+++ b/plugins/extract/align/dlib.py
@@ -33,6 +33,9 @@ class Align(Aligner):
             item = self.queues["in"].get()
             if item == "EOF":
                 break
+            if item.get("exception", False):
+                self.queues["out"].put(item)
+                break
             image = item["image"][:, :, ::-1].copy()
             self.process_landmarks(image, item["detected_faces"])
             self.finalize(item)
diff --git a/plugins/extract/align/fan.py b/plugins/extract/align/fan.py
index 84bb216..2c99554 100644
--- a/plugins/extract/align/fan.py
+++ b/plugins/extract/align/fan.py
@@ -34,7 +34,13 @@ class Align(Aligner):
         print("Initializing Face Alignment Network...")
         super().initialize(*args, **kwargs)
 
-        _, vram_total = self.get_vram_free()
+        card_id, _, vram_total = self.get_vram_free()
+        if card_id == -1:
+            self.queues["out"].put("No Graphics Card Detected! FAN is not "
+                                   "supported on CPU. Use another aligner.")
+            self.init.set()
+            return
+
         if vram_total <= self.vram:
             tf_ratio = 1.0
         else:
@@ -56,6 +62,9 @@ class Align(Aligner):
                 item = self.queues["in"].get()
                 if item == "EOF":
                     break
+                if item.get("exception", False):
+                    self.queues["out"].put(item)
+                    break
                 image = item["image"][:, :, ::-1].copy()
                 self.process_landmarks(image, item["detected_faces"])
                 self.finalize(item)
@@ -188,7 +197,7 @@ class Align(Aligner):
                 for i in range(var_a.shape[0])]
 
 
-class FAN(object):
+class FAN():
     """The FAN Model.
     Converted from pyTorch via ONNX from:
     https://github.com/1adrianb/face-alignment """
diff --git a/scripts/convert.py b/scripts/convert.py
index b2ca7a7..6b4fb54 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -7,12 +7,12 @@ import sys
 from pathlib import Path
 
 import cv2
-import numpy as np
 from tqdm import tqdm
 
 from scripts.fsmedia import Alignments, Images, PostProcess, Utils
 from lib.faces_detect import DetectedFace
-from lib.multithreading import BackgroundGenerator, SpawnProcess, queue_manager
+from lib.multithreading import BackgroundGenerator, SpawnProcess
+from lib.queue_manager import queue_manager
 from lib.utils import get_folder, get_image_paths
 
 from plugins.plugin_loader import PluginLoader
@@ -155,7 +155,8 @@ class Convert():
             faces_count = len(detected_faces)
             if faces_count != 0:
                 # Post processing requires a dict with "detected_faces" key
-                self.post_process.do_actions({"detected_faces": detected_faces})
+                self.post_process.do_actions(
+                    {"detected_faces": detected_faces})
                 self.faces_count += faces_count
 
             if faces_count > 1:
diff --git a/scripts/extract.py b/scripts/extract.py
index c3ef112..ae55e82 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -1,6 +1,5 @@
 #!/usr/bin python3
 """ The script to run the extract process of faceswap """
-# TODO S3FD Detector
 
 import os
 import sys
@@ -10,8 +9,8 @@ import cv2
 from tqdm import tqdm
 
 from lib.gpu_stats import GPUStats
-from lib.multithreading import (MultiThread, PoolProcess, QueueEmpty,
-                                SpawnProcess, queue_manager)
+from lib.multithreading import MultiThread, PoolProcess, SpawnProcess
+from lib.queue_manager import queue_manager, QueueEmpty
 from lib.utils import get_folder
 from plugins.plugin_loader import PluginLoader
 from scripts.fsmedia import Alignments, Images, PostProcess, Utils
@@ -108,7 +107,6 @@ class Extract():
         if self.plugins.is_parallel:
             self.plugins.launch_aligner()
             self.plugins.launch_detector()
-
         if not self.plugins.is_parallel:
             self.run_detection(to_process)
             self.plugins.launch_aligner()
@@ -120,7 +118,7 @@ class Extract():
 
             exception = faces.get("exception", False)
             if exception:
-                break
+                exit(1)
             filename = faces["filename"]
 
             faces["output_file"] = self.output_dir / Path(filename).stem
@@ -301,6 +299,17 @@ class Plugins():
         if not event.is_set():
             raise ValueError("Error inititalizing Aligner")
 
+        try:
+            err = None
+            err = out_queue.get(True, 1)
+        except QueueEmpty:
+            pass
+
+        if err:
+            queue_manager.terminate_queues()
+            print(err)
+            exit(1)
+
     def launch_detector(self):
         """ Launch the face detector """
         out_queue = queue_manager.get_queue("detect")
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
index 6c85977..6d51f0a 100644
--- a/tools/lib_alignments/jobs_manual.py
+++ b/tools/lib_alignments/jobs_manual.py
@@ -6,7 +6,8 @@ import sys
 import cv2
 import numpy as np
 
-from lib.multithreading import SpawnProcess, queue_manager
+from lib.multithreading import SpawnProcess
+from lib.queue_manager import queue_manager
 from plugins.plugin_loader import PluginLoader
 from . import Annotate, ExtractedFaces, Frames, Rotate
 
diff --git a/tools/sort.py b/tools/sort.py
index d65bf0f..f3838e7 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -17,7 +17,8 @@ import face_recognition
 from lib.cli import FullHelpArgumentParser
 from lib import Serializer
 from lib.faces_detect import DetectedFace
-from lib.multithreading import queue_manager, SpawnProcess
+from lib.multithreading import SpawnProcess
+from lib.queue_manager import queue_manager
 from plugins.plugin_loader import PluginLoader
 
 from . import cli

commit afd4fa789b00e2aafd0f4ef1f864f87a62a44499
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sat Dec 22 19:29:03 2018 +0000

    Add ability to extract from and convert from a video file (#559)
    
    * Add ability to extract from and convert from a video file
    
    * Update cli helptext. Add filebrowser button for GUI input
    
    * Add video support to Alignments Tool

diff --git a/lib/cli.py b/lib/cli.py
index 2382bf7..0d848c0 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -147,6 +147,13 @@ class FileFullPaths(FullPaths):
         return [(name, getattr(self, name)) for name in names]
 
 
+class DirOrFileFullPaths(FileFullPaths):
+    """ Class that the gui uses to determine that the input can take a folder or a filename.
+        Inherits functionality from FileFullPaths
+        Has the effect of giving the user 2 Open Dialogue buttons in the gui """
+    pass
+
+
 class SaveFileFullPaths(FileFullPaths):
     """
     Class that gui uses to determine if you need to save a file.
@@ -306,12 +313,14 @@ class ExtractConvertArgs(FaceSwapArgs):
         argparse and gui """
         argument_list = list()
         argument_list.append({"opts": ("-i", "--input-dir"),
-                              "action": DirFullPaths,
+                              "action": DirOrFileFullPaths,
+                              "filetypes": "video",
                               "dest": "input_dir",
                               "default": "input",
-                              "help": "Input directory. A directory "
-                                      "containing the files you wish to "
-                                      "process. Defaults to 'input'"})
+                              "help": "Input directory or video. Either a "
+                                      "directory containing the image files "
+                                      "you wish to process or path to a "
+                                      "video file. Defaults to 'input'"})
         argument_list.append({"opts": ("-o", "--output-dir"),
                               "action": DirFullPaths,
                               "dest": "output_dir",
diff --git a/lib/gui/command.py b/lib/gui/command.py
index 7a25f08..3db839a 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -260,7 +260,7 @@ class OptionControl():
             frame) if control == ttk.Checkbutton else tk.StringVar(frame)
         var.set(default)
 
-        if sysbrowser is not None:
+        if sysbrowser:
             self.add_browser_buttons(frame, sysbrowser, var)
 
         if control == ttk.Checkbutton:
@@ -311,15 +311,16 @@ class OptionControl():
         """ Add correct file browser button for control """
         logger.debug("Adding browser buttons: (sysbrowser: '%s', filepath: '%s'",
                      sysbrowser, filepath)
-        img = Images().icons[sysbrowser]
-        action = getattr(self, "ask_" + sysbrowser)
-        filetypes = self.option.get("filetypes", "default")
-        fileopn = ttk.Button(frame, image=img,
-                             command=lambda cmd=action: cmd(filepath,
-                                                            filetypes))
-        fileopn.pack(padx=(0, 5), side=tk.RIGHT)
-        logger.debug("Added browser buttons: (action: %s, filetypes: %s",
-                     action, filetypes)
+        for browser in sysbrowser:
+            img = Images().icons[browser]
+            action = getattr(self, "ask_" + browser)
+            filetypes = self.option.get("filetypes", "default")
+            fileopn = ttk.Button(frame, image=img,
+                                 command=lambda cmd=action: cmd(filepath,
+                                                                filetypes))
+            fileopn.pack(padx=(0, 5), side=tk.RIGHT)
+            logger.debug("Added browser buttons: (action: %s, filetypes: %s",
+                         action, filetypes)
 
     @staticmethod
     def ask_folder(filepath, filetypes=None):
diff --git a/lib/gui/options.py b/lib/gui/options.py
index 92fedd0..3433eab 100644
--- a/lib/gui/options.py
+++ b/lib/gui/options.py
@@ -2,6 +2,7 @@
 """ Cli Options and Config functions for the GUI """
 import inspect
 from argparse import SUPPRESS
+import logging
 from tkinter import ttk
 
 from lib import cli
@@ -10,23 +11,28 @@ import tools.cli as ToolsCli
 from .utils import FileHandler, Images
 
 # TODO Fix the bug that breaks GUI if timeshift isn't the last option in it's group
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
 
 class CliOptions():
     """ Class and methods for the command line options """
     def __init__(self):
+        logger.debug("Initializing %s", self.__class__.__name__)
         self.categories = ("faceswap", "tools")
         self.commands = dict()
         self.opts = dict()
         self.build_options()
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def build_options(self):
         """ Get the commands that belong to each category """
         for category in self.categories:
+            logger.debug("Building '%s'", category)
             src = ToolsCli if category == "tools" else cli
             mod_classes = self.get_cli_classes(src)
             self.commands[category] = self.sort_commands(category, mod_classes)
             self.opts.update(self.extract_options(src, mod_classes))
+            logger.debug("Built '%s'", category)
 
     @staticmethod
     def get_cli_classes(cli_source):
@@ -38,6 +44,7 @@ class CliOptions():
                                               "extractconvertargs",
                                               "guiargs")):
                 mod_classes.append(name)
+        logger.debug(mod_classes)
         return mod_classes
 
     def sort_commands(self, category, classes):
@@ -50,6 +57,7 @@ class CliOptions():
             ordered = ["extract", "train", "convert"]
             commands = ordered + [command for command in commands
                                   if command not in ordered]
+        logger.debug(commands)
         return commands
 
     @staticmethod
@@ -62,9 +70,12 @@ class CliOptions():
             into master options Dictionary """
         subopts = dict()
         for classname in mod_classes:
+            logger.debug("Processing: (classname: '%s')", classname)
             command = self.format_command_name(classname)
             options = self.get_cli_arguments(cli_source, classname, command)
             self.process_options(options)
+            logger.debug("Processed: (classname: '%s', command: '%s', options: %s)",
+                         classname, command, options)
             subopts[command] = options
         return subopts
 
@@ -77,6 +88,7 @@ class CliOptions():
     def process_options(self, command_options):
         """ Process the options for a single command """
         for opt in command_options:
+            logger.trace("Processing: %s", opt)
             if opt.get("help", "") == SUPPRESS:
                 command_options.remove(opt)
             ctl, sysbrowser, filetypes, action_option = self.set_control(opt)
@@ -86,6 +98,7 @@ class CliOptions():
             opt["filesystem_browser"] = sysbrowser
             opt["filetypes"] = filetypes
             opt["action_option"] = action_option
+            logger.trace("Processed: %s", opt)
 
     @staticmethod
     def set_control_title(opts):
@@ -104,6 +117,7 @@ class CliOptions():
         if action in (cli.FullPaths,
                       cli.DirFullPaths,
                       cli.FileFullPaths,
+                      cli.DirOrFileFullPaths,
                       cli.SaveFileFullPaths,
                       cli.ContextFullPaths):
             sysbrowser, filetypes = self.set_sysbrowser(action,
@@ -119,14 +133,17 @@ class CliOptions():
     def set_sysbrowser(action, filetypes, action_option):
         """ Set the correct file system browser and filetypes
             for the passed in action """
-        sysbrowser = "folder"
+        sysbrowser = ["folder"]
         filetypes = "default" if not filetypes else filetypes
         if action == cli.FileFullPaths:
-            sysbrowser = "load"
+            sysbrowser = ["load"]
         elif action == cli.SaveFileFullPaths:
-            sysbrowser = "save"
+            sysbrowser = ["save"]
+        elif action == cli.DirOrFileFullPaths:
+            sysbrowser = ["folder", "load"]
         elif action == cli.ContextFullPaths and action_option:
-            sysbrowser = "context"
+            sysbrowser = ["context"]
+        logger.debug("sysbrowser: %s, filetypes: '%s'", sysbrowser, filetypes)
         return sysbrowser, filetypes
 
     def set_context_option(self, command):
@@ -156,6 +173,7 @@ class CliOptions():
     def reset(self, command=None):
         """ Reset the options for all or passed command
             back to default value """
+        logger.debug("Resetting options to default. (command: '%s'", command)
         for option in self.options_to_process(command):
             default = option.get("default", "")
             default = "" if default is None else default
@@ -167,6 +185,7 @@ class CliOptions():
     def clear(self, command=None):
         """ Clear the options values for all or passed
             commands """
+        logger.debug("Clearing options. (command: '%s'", command)
         for option in self.options_to_process(command):
             if isinstance(option["value"].get(), bool):
                 option["value"].set(False)
@@ -186,6 +205,7 @@ class CliOptions():
             for opt in opts:
                 cmd_dict[opt["control_title"]] = opt["value"].get()
             ctl_dict[cmd] = cmd_dict
+        logger.debug("command: '%s', ctl_dict: '%s'", command, ctl_dict)
         return ctl_dict
 
     def get_one_option_variable(self, command, title):
@@ -221,12 +241,15 @@ class Config():
     """ Actions for loading and saving Faceswap GUI command configurations """
 
     def __init__(self, cli_opts, tk_vars):
+        logger.debug("Initializing %s", self.__class__.__name__)
         self.cli_opts = cli_opts
         self.serializer = JSONSerializer
         self.tk_vars = tk_vars
+        logger.debug("Initialized %s", self.__class__.__name__)
 
     def load(self, command=None):
         """ Load a saved config file """
+        logger.debug("Loading config: (command: '%s')", command)
         cfgfile = FileHandler("open", "config").retfile
         if not cfgfile:
             return
@@ -234,6 +257,7 @@ class Config():
         opts = self.get_command_options(cfg, command) if command else cfg
         for cmd, opts in opts.items():
             self.set_command_args(cmd, opts)
+        logger.debug("Loaded config: (command: '%s', cfgfile: '%s')", command, cfgfile)
 
     def get_command_options(self, cfg, command):
         """ return the saved options for the requested
@@ -241,8 +265,11 @@ class Config():
         opts = cfg.get(command, None)
         if not opts:
             self.tk_vars["consoleclear"].set(True)
-            print("No " + command + " section found in file")
-        return {command: opts}
+            print("No {} section found in file".format(command))
+            logger.info("No  %s section found in file", command)
+        retval = {command: opts}
+        logger.debug(retval)
+        return retval
 
     def set_command_args(self, command, options):
         """ Pass the saved config items back to the CliOptions """
@@ -256,9 +283,11 @@ class Config():
 
     def save(self, command=None):
         """ Save the current GUI state to a config file in json format """
+        logger.debug("Saving config: (command: '%s')", command)
         cfgfile = FileHandler("save", "config").retfile
         if not cfgfile:
             return
         cfg = self.cli_opts.get_option_values(command)
         cfgfile.write(self.serializer.marshal(cfg))
         cfgfile.close()
+        logger.debug("Saved config: (command: '%s', cfgfile: '%s')", command, cfgfile)
diff --git a/scripts/convert.py b/scripts/convert.py
index ce02f34..4aaf571 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -31,7 +31,7 @@ class Convert():
         self.faces_count = 0
 
         self.images = Images(self.args)
-        self.alignments = Alignments(self.args, False)
+        self.alignments = Alignments(self.args, False, self.images.is_video)
 
         # Update Legacy alignments
         Legacy(self.alignments, self.images.input_images, arguments.input_aligned_dir)
@@ -139,9 +139,9 @@ class Convert():
     def prepare_images(self):
         """ Prepare the images for conversion """
         filename = ""
-        for filename in tqdm(self.images.input_images,
-                             total=self.images.images_found,
-                             file=sys.stdout):
+        for filename, image in tqdm(self.images.load(),
+                                    total=self.images.images_found,
+                                    file=sys.stdout):
 
             if (self.args.discard_frames and
                     self.opts.check_skipframe(filename) == "discard"):
@@ -149,13 +149,12 @@ class Convert():
 
             frame = os.path.basename(filename)
             if self.extract_faces:
-                convert_item = self.detect_faces(filename)
+                detected_faces = self.detect_faces(filename, image)
             else:
-                convert_item = self.alignments_faces(filename, frame)
+                detected_faces = self.alignments_faces(frame, image)
 
-            if not convert_item:
+            if not detected_faces:
                 continue
-            image, detected_faces = convert_item
 
             faces_count = len(detected_faces)
             if faces_count != 0:
@@ -171,28 +170,27 @@ class Convert():
 
             yield filename, image, detected_faces
 
-    def detect_faces(self, filename):
+    @staticmethod
+    def detect_faces(filename, image):
         """ Extract the face from a frame (If not alignments file found) """
-        image = self.images.load_one_image(filename)
         queue_manager.get_queue("load").put((filename, image))
         item = queue_manager.get_queue("align").get()
         detected_faces = item["detected_faces"]
-        return image, detected_faces
+        return detected_faces
 
-    def alignments_faces(self, filename, frame):
+    def alignments_faces(self, frame, image):
         """ Get the face from alignments file """
         if not self.check_alignments(frame):
             return None
 
         faces = self.alignments.get_faces_in_frame(frame)
-        image = self.images.load_one_image(filename)
         detected_faces = list()
 
         for rawface in faces:
             face = DetectedFace()
             face.from_alignment(rawface, image=image)
             detected_faces.append(face)
-        return image, detected_faces
+        return detected_faces
 
     def check_alignments(self, frame):
         """ If we have no alignments for this image, skip it """
diff --git a/scripts/extract.py b/scripts/extract.py
index fa70b3c..f09f766 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -28,7 +28,7 @@ class Extract():
         self.output_dir = get_folder(self.args.output_dir)
         logger.info("Output Directory: %s", self.args.output_dir)
         self.images = Images(self.args)
-        self.alignments = Alignments(self.args, True)
+        self.alignments = Alignments(self.args, True, self.images.is_video)
         self.plugins = Plugins(self.args)
 
         self.post_process = PostProcess(arguments)
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index 5e7c988..74db537 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -16,7 +16,7 @@ from lib.aligner import Extract as AlignerExtract
 from lib.alignments import Alignments as AlignmentsBase
 from lib.face_filter import FaceFilter as FilterFunc
 from lib.utils import (camel_case_split, get_folder, get_image_paths,
-                       set_system_verbosity)
+                       set_system_verbosity, _video_extensions)
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -49,22 +49,27 @@ class Utils():
 
 class Alignments(AlignmentsBase):
     """ Override main alignments class for extract """
-    def __init__(self, arguments, is_extract):
-        logger.debug("Initializing %s: (is_extract: %s)", self.__class__.__name__, is_extract)
+    def __init__(self, arguments, is_extract, input_is_video=False):
+        logger.debug("Initializing %s: (is_extract: %s, input_is_video: %s)",
+                     self.__class__.__name__, is_extract, input_is_video)
         self.args = arguments
         self.is_extract = is_extract
-        folder, filename = self.set_folder_filename()
+        folder, filename = self.set_folder_filename(input_is_video)
         serializer = self.set_serializer()
         super().__init__(folder,
                          filename=filename,
                          serializer=serializer)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def set_folder_filename(self):
+    def set_folder_filename(self, input_is_video):
         """ Return the folder for the alignments file"""
         if self.args.alignments_path:
             logger.debug("Alignments File provided: '%s'", self.args.alignments_path)
             folder, filename = os.path.split(str(self.args.alignments_path))
+        elif input_is_video:
+            logger.debug("Alignments from Video File: '%s'", self.args.input_dir)
+            folder, filename = os.path.split(self.args.input_dir)
+            filename = "{}_alignments".format(os.path.splitext(filename)[0])
         else:
             logger.debug("Alignments from Input Folder: '%s'", self.args.input_dir)
             folder = str(self.args.input_dir)
@@ -129,23 +134,53 @@ class Images():
     def __init__(self, arguments):
         logger.debug("Initializing %s", self.__class__.__name__)
         self.args = arguments
+        self.is_video = self.check_input_folder()
         self.input_images = self.get_input_images()
-        self.images_found = len(self.input_images)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def get_input_images(self):
-        """ Return the list of images that are to be processed """
+    @property
+    def images_found(self):
+        """ Number of images or frames """
+        if self.is_video:
+            cap = cv2.VideoCapture(self.args.input_dir)  # pylint: disable=no-member
+            retval = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))  # pylint: disable=no-member
+            cap.release()
+        else:
+            retval = len(self.input_images)
+        return retval
+
+    def check_input_folder(self):
+        """ Check whether the input is a folder or video """
         if not os.path.exists(self.args.input_dir):
-            logger.error("Input directory %s not found.", self.args.input_dir)
+            logger.error("Input location %s not found.", self.args.input_dir)
             exit(1)
+        if (os.path.isfile(self.args.input_dir) and
+                os.path.splitext(self.args.input_dir)[1] in _video_extensions):
+            logger.info("Input Video: %s", self.args.input_dir)
+            retval = True
+        else:
+            logger.info("Input Directory: %s", self.args.input_dir)
+            retval = False
+        return retval
 
-        logger.info("Input Directory: %s", self.args.input_dir)
-        input_images = get_image_paths(self.args.input_dir)
+    def get_input_images(self):
+        """ Return the list of images or video file that is to be processed """
+        if self.is_video:
+            input_images = self.args.input_dir
+        else:
+            input_images = get_image_paths(self.args.input_dir)
 
         return input_images
 
     def load(self):
         """ Load an image and yield it with it's filename """
+        iterator = self.load_video_frames if self.is_video else self.load_disk_frames
+        for filename, image in iterator():
+            yield filename, image
+
+    def load_disk_frames(self):
+        """ Load frames from disk """
+        logger.debug("Input is Seperate Frames. Loading images")
         for filename in self.input_images:
             logger.trace("Loading image: '%s'", filename)
             try:
@@ -155,6 +190,24 @@ class Images():
                 continue
             yield filename, image
 
+    def load_video_frames(self):
+        """ Return frames from a video file """
+        logger.debug("Input is video. Capturing frames")
+        vidname = os.path.splitext(os.path.basename(self.args.input_dir))[0]
+        cap = cv2.VideoCapture(self.args.input_dir)  # pylint: disable=no-member
+        i = 0
+        while True:
+            ret, frame = cap.read()
+            if not ret:
+                logger.debug("Video terminated")
+                break
+            i += 1
+            # Keep filename format for outputted face
+            filename = "{}_{:06d}.png".format(vidname, i)
+            logger.trace("Loading video frame: '%s'", filename)
+            yield filename, frame
+        cap.release()
+
     @staticmethod
     def load_one_image(filename):
         """ load requested image """
diff --git a/tools/cli.py b/tools/cli.py
index e186031..fa1e986 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -10,13 +10,13 @@ class AlignmentsArgs(FaceSwapArgs):
     """ Class to parse the command line arguments for Aligments tool """
 
     def get_argument_list(self):
-        frames_dir = "\n\tMust Pass in a frames folder (-fr)."
+        frames_dir = "\n\tMust Pass in a frames folder/source video file (-fr)."
         faces_dir = "\n\tMust Pass in a faces folder (-fc)."
-        frames_or_faces_dir = ("\n\tMust Pass in either a frames folder"
-                               "\n\tOR a faces folder (-fr or -fc).")
-        frames_and_faces_dir = ("\n\tMust Pass in a frames folder AND a faces"
+        frames_or_faces_dir = ("\n\tMust Pass in either a frames folder/source video file OR a"
+                               "\n\tfaces folder (-fr or -fc).")
+        frames_and_faces_dir = ("\n\tMust Pass in a frames folder/source video file AND a faces "
                                 "\n\tfolder (-fr and -fc).")
-        output_opts = "\n\tUse the output option (-o) to process\n\tresults."
+        output_opts = "\n\tUse the output option (-o) to process results."
         align_eyes = "\n\tCan optionally use the align-eyes switch (-ae)."
         argument_list = list()
         argument_list.append({
@@ -29,76 +29,55 @@ class AlignmentsArgs(FaceSwapArgs):
                         "rename", "sort-x", "sort-y", "spatial", "update-hashes"),
             "required": True,
             "help": "R|Choose which action you want to perform.\n"
-                    "NB: All actions require an alignments file (-a) to"
-                    "\nbe passed in."
-                    "\n'draw': Draw landmarks on frames in the selected"
-                    "\n\tfolder. A subfolder will be created within"
-                    "\n\tthe frames folder to hold the output." +
+                    "NB: All actions require an alignments file (-a) to be passed in."
+                    "\n'draw': Draw landmarks on frames in the selected folder/video. A subfolder"
+                    "\n\twill be created within the frames folder to hold the output." +
                     frames_dir + align_eyes +
-                    "\n'extract': Re-extract faces from the source frames"
-                    "\n\tbased on alignment data. This is a"
-                    "\n\tlot quicker than re-detecting faces." +
+                    "\n'extract': Re-extract faces from the source frames/video based on "
+                    "\n\talignment data. This is a lot quicker than re-detecting faces." +
                     frames_and_faces_dir + align_eyes +
-                    "\n'extract-large' - Extract all faces that have not been"
-                    "\n\tupscaled. Useful for excluding low-res images from a"
-                    "\n\ttraining set" + frames_and_faces_dir + align_eyes +
-                    "\n'manual': Manually view and edit landmarks." +
-                    frames_dir + align_eyes +
-                    "\n'merge': Merge multiple alignment files into one."
-                    "\n\tSpecify the main alignments file with the -a flag"
-                    "\n\tand the file to be merged with the -a2 flag."
-                    "\n'missing-alignments': Identify frames that do not"
-                    "\n\texist in the alignments file." + output_opts +
-                    frames_dir +
-                    "\n'missing-frames': Identify frames in the alignments"
-                    "\n\tfile that do not appear within the frames"
-                    "\n\tfolder." + output_opts + frames_dir +
-                    "\n'legacy': This updates legacy alignments to the latest"
-                    "\n\tformat by adding frame dimensions, rotating the"
-                    "\n\tlandmarks and bounding boxes and adding face_hashes" +
-                    frames_and_faces_dir +
-                    "\n'leftover-faces': Identify faces in the faces"
-                    "\n\tfolder that do not exist in the alignments file."
-                    + output_opts + faces_dir +
-                    "\n'multi-faces': Identify where multiple faces exist"
-                    "\n\twithin the alignments file." + output_opts +
-                    frames_or_faces_dir +
-                    "\n'no-faces': Identify frames that exist within the"
-                    "\n\talignment file but no faces were detected." +
-                    output_opts + frames_dir +
-                    "\n'reformat': Save a copy of alignments file in a"
-                    "\n\tdifferent format. Specify a format with"
-                    "\n\tthe -fmt option."
-                    "\n\tAlignments can be converted from"
-                    "\n\tDeepFaceLab by specifing:"
+                    "\n'extract-large' - Extract all faces that have not been upscaled. Useful"
+                    "\n\tfor excluding low-res images from a training set." +
+                    frames_and_faces_dir + align_eyes +
+                    "\n'manual': Manually view and edit landmarks." + frames_dir + align_eyes +
+                    "\n'merge': Merge multiple alignment files into one. Specify the main"
+                    "\n\talignments file with the -a flag and the file to be merged with the"
+                    "\n\t-a2 flag."
+                    "\n'missing-alignments': Identify frames that do not exist in the alignments"
+                    "\n\tfile." + output_opts + frames_dir +
+                    "\n'missing-frames': Identify frames in the alignments file that do no "
+                    "\n\tappear within the frames folder/video." + output_opts + frames_dir +
+                    "\n'legacy': This updates legacy alignments to the latest format by adding"
+                    "\n\tframe dimensions, rotating the landmarks and bounding boxes and adding"
+                    "\n\tface_hashes" + frames_and_faces_dir +
+                    "\n'leftover-faces': Identify faces in the faces folder that do not exist in"
+                    "\n\tthe alignments file." + output_opts + faces_dir +
+                    "\n'multi-faces': Identify where multiple faces exist within the alignments"
+                    "\n\tfile." + output_opts + frames_or_faces_dir +
+                    "\n'no-faces': Identify frames that exist within the alignment file but no"
+                    "\n\tfaces were detected." + output_opts + frames_dir +
+                    "\n'reformat': Save a copy of alignments file in a different format. Specify"
+                    "\n\ta format with the -fmt option."
+                    "\n\tAlignments can be converted from DeepFaceLab by specifing:"
                     "\n\t    -a dfl"
                     "\n\t    -fc <source faces folder>"
-                    "\n'remove-faces': Remove deleted faces from an"
-                    "\n\talignments file. The original alignments file"
-                    "\n\t will be backed up. A different file format or"
-                    "\n\tthe alignments file can optionally be specified"
-                    "\n\t(-fmt)." + faces_dir +
-                    "\n'remove-frames': Remove deleted frames from an"
-                    "\n\talignments file. The original alignments file"
-                    "\n\twill be backed up. A different file format for"
-                    "\n\tthe alignments file can optionally be specified"
-                    "\n\t(-fmt)." + frames_dir +
-                    "\n'rename' - Rename faces to correspond with their"
-                    "\n\tparent frame and position index in the alignments"
-                    "\n\tfile (i.e. how they are named after running"
+                    "\n'remove-faces': Remove deleted faces from an alignments file. The original"
+                    "\n\talignments file will be backed up. A different file format for the"
+                    "\n\talignments file can optionally be specified (-fmt)." + faces_dir +
+                    "\n'remove-frames': Remove deleted frames from an alignments file. The"
+                    "\n\toriginal alignments file will be backed up. A different file format for"
+                    "\n\tthe alignments file can optionally be specified (-fmt)." + frames_dir +
+                    "\n'rename' - Rename faces to correspond with their parent frame and position"
+                    "\n\tindex in the alignments file (i.e. how they are named after running"
                     "\n\textract)." + faces_dir +
-                    "\n'sort-x' - Re-index the alignments from left to"
-                    "\n\tright. For alignments with multiple faces this will"
-                    "\n\tensure that the left-most face is at index 0"
-                    "\n\tOptionally pass in a faces folder (-fc) to also"
-                    "\n\trename extracted faces."
-                    "\n'sort-y' - Re-index the alignments from top to"
-                    "\n\tbottom. For alignments with multiple faces this will"
-                    "\n\tensure that the top-most face is at index 0"
-                    "\n\tOptionally pass in a faces folder (-fc) to also"
-                    "\n\trename extracted faces."
-                    "\n'spatial' - Perform spatial and temporal filtering to"
-                    "\n\tsmooth alignments (EXPERIMENTAL!)"})
+                    "\n'sort-x' - Re-index the alignments from left to right. For alignments with"
+                    "\n\tmultiple faces this will ensure that the left-most face is at index 0"
+                    "\n\tOptionally pass in a faces folder (-fc) to also rename extracted faces."
+                    "\n'sort-y' - Re-index the alignments from top to bottom. For alignments with"
+                    "\n\tmultiple faces this will ensure that the top-most face is at index 0"
+                    "\n\tOptionally pass in a faces folder (-fc) to also  rename extracted faces."
+                    "\n'spatial' - Perform spatial and temporal filtering to smooth alignments"
+                    "\n\t(EXPERIMENTAL!)"})
         argument_list.append({"opts": ("-a", "--alignments_file"),
                               "action": FileFullPaths,
                               "dest": "alignments_file",
@@ -135,12 +114,11 @@ class AlignmentsArgs(FaceSwapArgs):
             "default": "console",
             "help": "R|How to output discovered items ('faces' and"
                     "\n'frames' only):"
-                    "\n'console': Print the list of frames to the screen."
-                    "\n\t(DEFAULT)"
-                    "\n'file': Output the list of frames to a text file"
-                    "\n\t(stored within the source directory)."
-                    "\n'move': Move the discovered items to a sub-folder"
-                    "\n\twithin the source directory."})
+                    "\n'console': Print the list of frames to the screen. (DEFAULT)"
+                    "\n'file': Output the list of frames to a text file (stored within the source"
+                    "\n\tdirectory)."
+                    "\n'move': Move the discovered items to a sub-folder within the source"
+                    "\n\tdirectory."})
         argument_list.append({"opts": ("-ae", "--align-eyes"),
                               "action": "store_true",
                               "dest": "align_eyes",
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index fb84064..eca0bad 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -1,6 +1,5 @@
 #!/usr/bin/env python3
 """ Tools for manipulating the alignments seralized file """
-# TODO merge alignments
 
 import logging
 import os
@@ -224,7 +223,11 @@ class Draw():
         """ Set the output folder path """
         now = datetime.now().strftime("%Y%m%d_%H%M%S")
         folder_name = "drawn_landmarks_{}".format(now)
-        output_folder = os.path.join(self.frames.folder, folder_name)
+        if self.frames.vid_cap:
+            dest_folder = os.path.split(self.frames.folder)[0]
+        else:
+            dest_folder = self.frames.folder
+        output_folder = os.path.join(dest_folder, folder_name)
         logger.debug("Creating folder: '%s'", output_folder)
         os.makedirs(output_folder)
         return output_folder
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index 6e6b742..0004827 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -10,7 +10,7 @@ import cv2
 
 from lib.alignments import Alignments
 from lib.faces_detect import DetectedFace
-from lib.utils import _image_extensions, hash_image_file, hash_encode_image
+from lib.utils import _image_extensions, _video_extensions, hash_image_file, hash_encode_image
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -91,27 +91,44 @@ class MediaLoader():
         logger.debug("Initializing %s: (folder: '%s')", self.__class__.__name__, folder)
         logger.info("[%s DATA]", self.__class__.__name__.upper())
         self.folder = folder
-        self.check_folder_exists()
+        self.vid_cap = self.check_input_folder()
         self.file_list_sorted = self.sorted_items()
         self.items = self.load_items()
-        self.count = len(self.file_list_sorted)
         logger.verbose("%s items loaded", self.count)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def check_folder_exists(self):
-        """ makes sure that the faces folder exists """
+    @property
+    def count(self):
+        """ Number of faces or frames """
+        if self.vid_cap:
+            retval = int(self.vid_cap.get(cv2.CAP_PROP_FRAME_COUNT))  # pylint: disable=no-member
+        else:
+            retval = len(self.file_list_sorted)
+        return retval
+
+    def check_input_folder(self):
+        """ makes sure that the frames or faces folder exists
+            If frames folder contains a video file return video capture object """
         err = None
         loadtype = self.__class__.__name__
         if not self.folder:
             err = "ERROR: A {} folder must be specified".format(loadtype)
-        elif not os.path.isdir(self.folder):
-            err = ("ERROR: The {} folder {} could not be "
+        elif not os.path.exists(self.folder):
+            err = ("ERROR: The {} location {} could not be "
                    "found".format(loadtype, self.folder))
         if err:
             logger.error(err)
             exit(0)
 
-        logger.verbose("Folder exists at '%s'", self.folder)
+        if (loadtype == "Frames" and
+                os.path.isfile(self.folder) and
+                os.path.splitext(self.folder)[1] in _video_extensions):
+            logger.verbose("Video exists at : '%s'", self.folder)
+            retval = cv2.VideoCapture(self.folder)  # pylint: disable=no-member
+        else:
+            logger.verbose("Folder exists at '%s'", self.folder)
+            retval = None
+        return retval
 
     @staticmethod
     def valid_extension(filename):
@@ -138,9 +155,21 @@ class MediaLoader():
 
     def load_image(self, filename):
         """ Load an image """
-        src = os.path.join(self.folder, filename)
-        logger.trace("Loading image: '%s'", src)
-        image = cv2.imread(src)  # pylint: disable=no-member
+        if self.vid_cap:
+            image = self.load_video_frame(filename)
+        else:
+            src = os.path.join(self.folder, filename)
+            logger.trace("Loading image: '%s'", src)
+            image = cv2.imread(src)  # pylint: disable=no-member
+        return image
+
+    def load_video_frame(self, filename):
+        """ Load a requested frame from video """
+        frame = os.path.splitext(filename)[0]
+        logger.trace("Loading video frame: '%s'", frame)
+        frame_no = int(frame[frame.rfind("_") + 1:])
+        self.vid_cap.set(cv2.CAP_PROP_POS_FRAMES, frame_no)  # pylint: disable=no-member
+        _, image = self.vid_cap.read()
         return image
 
     @staticmethod
@@ -191,6 +220,13 @@ class Frames(MediaLoader):
     def process_folder(self):
         """ Iterate through the frames dir pulling the base filename """
         logger.info("Loading file list from %s", self.folder)
+        iterator = self.process_video if self.vid_cap else self.process_frames
+        for item in iterator():
+            yield item
+
+    def process_frames(self):
+        """ Process exported Frames """
+        logger.info("Loading file list from %s", self.folder)
         for frame in os.listdir(self.folder):
             if not self.valid_extension(frame):
                 continue
@@ -203,6 +239,20 @@ class Frames(MediaLoader):
             logger.trace(retval)
             yield retval
 
+    def process_video(self):
+        """Dummy in frames for video """
+        logger.info("Loading video frames from %s", self.folder)
+        vidname = os.path.splitext(os.path.basename(self.folder))[0]
+        for i in range(self.count):
+            idx = i + 1
+            # Keep filename format for outputted face
+            filename = "{}_{:06d}".format(vidname, idx)
+            retval = {"frame_fullname": "{}.png".format(filename),
+                      "frame_name": filename,
+                      "frame_extension": ".png"}
+            logger.trace(retval)
+            yield retval
+
     def load_items(self):
         """ Load the frame info into dictionary """
         frames = dict()

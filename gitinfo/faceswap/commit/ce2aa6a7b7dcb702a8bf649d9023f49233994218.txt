commit ce2aa6a7b7dcb702a8bf649d9023f49233994218
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sun Apr 15 17:22:51 2018 +0100

    GUI v0.2.1b (#352)
    
    * Code refactor
    
    * Console Added
    
    * Add graphing with matplotlib
    
    * Add GUI preview support
    
    * Improve import handling.
    
    * Add GUI integration for tools.py (Launch tools.py with the gui command)
    
    * Reformat to conform to PEP8.
    
    * Add Tooltips,
    
    * Make panels user adjustable
    
    * Fix convert.py Sharpen default value

diff --git a/faceswap.py b/faceswap.py
index 1070ec0..f6df460 100755
--- a/faceswap.py
+++ b/faceswap.py
@@ -27,7 +27,7 @@ if __name__ == "__main__":
         subparser, "convert", "Convert a source image to a new one with the face swapped.")
     guiparsers = {'extract': extract, 'train': train, 'convert': convert}
     gui = TKGui(
-        subparser, guiparsers, parser, "gui", "Launch the Faceswap Graphical User Interface.")
+        subparser, guiparsers, "gui", "Launch the Faceswap Graphical User Interface.")
     parser.set_defaults(func=bad_args)
     arguments = parser.parse_args()
     arguments.func(arguments)
diff --git a/requirements-gpu-python35-cuda8.txt b/requirements-gpu-python35-cuda8.txt
index cc2d687..8e3ad09 100644
--- a/requirements-gpu-python35-cuda8.txt
+++ b/requirements-gpu-python35-cuda8.txt
@@ -8,3 +8,4 @@ scikit-image
 dlib
 face_recognition
 tqdm
+matplotlib
diff --git a/requirements-gpu-python36-cuda9.txt b/requirements-gpu-python36-cuda9.txt
index 3e9c2a5..fe1066d 100644
--- a/requirements-gpu-python36-cuda9.txt
+++ b/requirements-gpu-python36-cuda9.txt
@@ -7,4 +7,5 @@ tensorflow-gpu==1.5.0
 scikit-image
 dlib
 face_recognition
-tqdm
\ No newline at end of file
+tqdm
+matplotlib
diff --git a/requirements-python35.txt b/requirements-python35.txt
index 9d559c5..e0de3ff 100644
--- a/requirements-python35.txt
+++ b/requirements-python35.txt
@@ -8,3 +8,4 @@ scikit-image
 dlib
 face_recognition
 tqdm
+matplotlib
diff --git a/requirements-python36.txt b/requirements-python36.txt
index 7b0fc3f..cd846f6 100644
--- a/requirements-python36.txt
+++ b/requirements-python36.txt
@@ -7,4 +7,5 @@ tensorflow==1.5.0
 scikit-image
 dlib
 face_recognition
-tqdm
\ No newline at end of file
+tqdm
+matplotlib
diff --git a/scripts/convert.py b/scripts/convert.py
index 0ce62f6..ac85fc3 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -116,7 +116,7 @@ class ConvertImage(DirectoryProcessor):
                                "type": str.lower,
                                "dest": "sharpen_image",
                                "choices": ["bsharpen", "gsharpen"],
-                               "default": "none",
+                               "default": None,
                                "help": "Use Sharpen Image - bsharpen = Box Blur, gsharpen = Gaussian Blur (Masked converter only)"})
         argument_list.append({ "opts": ('-sm', '--smooth-mask'),
                                "action": "store_true",
diff --git a/scripts/gui.py b/scripts/gui.py
index 632ac39..92ca065 100644
--- a/scripts/gui.py
+++ b/scripts/gui.py
@@ -1,101 +1,132 @@
-import sys
+#!/usr/bin python3
+""" The optional GUI for faceswap """
+
 import os
+import signal
+import re
+import subprocess
+from subprocess import PIPE, Popen, TimeoutExpired
+import sys
 
-from os import path
+from argparse import SUPPRESS
+from math import ceil, floor
 from threading import Thread
+from time import time
+
+import numpy
+import matplotlib
+matplotlib.use('TkAgg')
+import matplotlib.animation as animation
+from matplotlib import pyplot as plt
+from matplotlib import style
+from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
 
 from lib.cli import FullPaths
 from lib.Serializer import JSONSerializer
 
-# Users without tkinter distrubtion packages or without an X-Console will error out
-# importing tkinter. Therefore run a check on these and only import if required 
-tk = None
-ttk = None
-filedialog = None
-
-def import_tkinter(command):
-    ''' Perform checks when importing tkinter module to ensure that GUI will load '''
-    global tk
-    global ttk
-    global filedialog
-    try:
-        import tkinter
-        from tkinter import ttk
-        from tkinter import filedialog
-        tk = tkinter
-    except ImportError:
-        if 'gui' in command:
-            print(  'It looks like TkInter isn''t installed for your OS, so the GUI has been '
-                    'disabled. To enable the GUI please install the TkInter application.\n'
-                    'You can try:\n'
-                    '  Windows/macOS:      Install ActiveTcl Community Edition from '
-                    'www.activestate.com\n'
-                    '  Ubuntu/Mint/Debian: sudo apt install python3-tk\n'
-                    '  Arch:               sudo pacman -S tk\n'
-                    '  CentOS/Redhat:      sudo yum install tkinter\n'
-                    '  Fedora:             sudo dnf install python3-tkinter\n')
-        return False
-    return True    
-
-def check_display(command):
-    # Check whether there is a display to output the GUI. If running on Windows
-    # then assume not running in headless mode
-    if not os.environ.get('DISPLAY', None) and os.name != 'nt':
-        if 'gui' in command:
-            print ('Could not detect a display. The GUI has been disabled')
-        return False
-    return True
+PATHSCRIPT = os.path.realpath(os.path.dirname(sys.argv[0]))
 
-class FaceswapGui(object):
-    ''' The Graphical User Interface '''
-    def __init__(self, options, parser):
-        self.gui = tk.Tk()
+# An error will be thrown when importing tkinter for users without tkinter
+# distribution packages or without an X-Console. Therefore if importing fails
+# no attempt will be made to instantiate the gui.
+try:
+    import tkinter as tk
+    from tkinter import ttk
+    from tkinter import filedialog
+    from tkinter import messagebox
+    from tkinter import TclError
+except ImportError:
+    tk = None
+    ttk = None
+    filedialog = None
+    messagebox = None
+    TclError = None
+
+class Utils(object):
+    """ Inter-class object holding items that are required across classes """
+
+    def __init__(self, options, calling_file="faceswap.py"):
         self.opts = options
-        self.parser = parser
-        
-        pathscript = path.realpath(path.dirname(sys.argv[0]))
-        pathicons = path.join(pathscript, 'icons')
-        self.icofolder = tk.PhotoImage(file=path.join(pathicons,'open_folder.png'))
-        self.icoload = tk.PhotoImage(file=path.join(pathicons,'open_file.png'))
-        self.icosave = tk.PhotoImage(file=path.join(pathicons,'save.png'))
-        self.icoreset = tk.PhotoImage(file=path.join(pathicons,'reset.png'))
-        self.icoclear = tk.PhotoImage(file=path.join(pathicons,'clear.png'))
-
-        self.helptext = tk.StringVar()
-        self.statustext = tk.StringVar()
+
+        self.icons = dict()
+        self.guitext = dict()
+        self.actionbtns = dict()
+
+        self.console = None
+        self.debugconsole = False
+
         self.serializer = JSONSerializer
-        self.filetypes=(('Faceswap files', '*.fsw'),  ('All files', '*.*'))
-        self.task = FaceswapControl()
+        self.filetypes = (('Faceswap files', '*.fsw'), ('All files', '*.*'))
 
-    def build_gui(self):
-        ''' Build the GUI '''
-        self.gui.title('faceswap.py')
-        self.menu()
-        notebook = ttk.Notebook(self.gui)
-        notebook.pack(fill=tk.BOTH, expand=True)
+        self.task = FaceswapControl(self, calling_file=calling_file)
+        self.runningtask = False
 
-        # Commands explicitly stated to ensure consistent ordering
-        for command in ('extract', 'train', 'convert'):
-            commandtab = CommandTab(self, notebook, command)
-            commandtab.build_tab()
+        self.previewloc = os.path.join(PATHSCRIPT, '.gui_preview.png')
 
-# All pages stuff
-    def menu(self):
-        ''' Menu bar for loading and saving configs '''
-        menubar = tk.Menu(self.gui)
-        filemenu = tk.Menu(menubar, tearoff=0)
-        filemenu.add_command(label='Load full config...', command=self.load_config)
-        filemenu.add_command(label='Save full config...', command=self.save_config)
-        filemenu.add_separator()
-        filemenu.add_command(label='Reset all to default', command=self.reset_config)
-        filemenu.add_command(label='Clear all', command=self.clear_config)
-        filemenu.add_separator()
-        filemenu.add_command(label='Quit', command=self.gui.quit)
-        menubar.add_cascade(label="File", menu=filemenu)
-        self.gui.config(menu=menubar)
+        self.lossdict = dict()
+
+    def init_tk(self):
+        """ TK System must be on prior to setting tk variables,
+        so initialised from GUI """
+        pathicons = os.path.join(PATHSCRIPT, 'icons')
+        self.icons['folder'] = tk.PhotoImage(
+            file=os.path.join(pathicons, 'open_folder.png'))
+        self.icons['load'] = tk.PhotoImage(
+            file=os.path.join(pathicons, 'open_file.png'))
+        self.icons['save'] = tk.PhotoImage(
+            file=os.path.join(pathicons, 'save.png'))
+        self.icons['reset'] = tk.PhotoImage(
+            file=os.path.join(pathicons, 'reset.png'))
+        self.icons['clear'] = tk.PhotoImage(
+            file=os.path.join(pathicons, 'clear.png'))
+
+        self.guitext['help'] = tk.StringVar()
+        self.guitext['status'] = tk.StringVar()
+
+    def action_command(self, command):
+        """ The action to perform when the action button is pressed """
+        if self.runningtask:
+            self.action_terminate()
+        else:
+            self.action_execute(command)
+
+    def action_execute(self, command):
+        """ Execute the task in Faceswap.py """
+        self.clear_console()
+        self.task.prepare(self.opts, command)
+        self.task.execute_script()
+
+    def action_terminate(self):
+        """ Terminate the subprocess Faceswap.py task """
+        self.task.terminate()
+        self.runningtask = False
+        self.clear_display_panel()
+        self.change_action_button()
+
+    def clear_display_panel(self):
+        ''' Clear the preview window and graph '''
+        self.delete_preview()
+        self.lossdict = dict()
+
+    def change_action_button(self):
+        """ Change the action button to relevant control """
+        for cmd in self.actionbtns.keys():
+            btnact = self.actionbtns[cmd]
+            if self.runningtask:
+                ttl = 'Terminate'
+                hlp = 'Exit the running process'
+            else:
+                ttl = cmd.title()
+                hlp = 'Run the {} script'.format(cmd.title())
+            btnact.config(text=ttl)
+            Tooltip(btnact, text=hlp, wraplength=200)
+
+    def clear_console(self):
+        """ Clear the console output screen """
+        self.console.delete(1.0, tk.END)
 
     def load_config(self, command=None):
-        ''' Load a saved config file '''
+        """ Load a saved config file """
         cfgfile = filedialog.askopenfile(mode='r', filetypes=self.filetypes)
         if not cfgfile:
             return
@@ -104,35 +135,39 @@ class FaceswapGui(object):
             for cmd, opts in cfg.items():
                 self.set_command_args(cmd, opts)
         else:
-            opts = cfg[command]
-            self.set_command_args(command, opts)
-                
+            opts = cfg.get(command, None)
+            if opts:
+                self.set_command_args(command, opts)
+            else:
+                self.clear_console()
+                print('No ' + command + ' section found in file')
+
     def set_command_args(self, command, options):
-        ''' Pass the saved config items back to the GUI '''
+        """ Pass the saved config items back to the GUI """
         for srcopt, srcval in options.items():
             for dstopts in self.opts[command]:
                 if dstopts['control_title'] == srcopt:
                     dstopts['value'].set(srcval)
                     break
-        
+
     def save_config(self, command=None):
-        ''' Save the current GUI state to a config file in json format '''
-        cfgfile = filedialog.asksaveasfile( mode='w',
-                                            filetypes=self.filetypes, 
-                                            defaultextension='.fsw')
+        """ Save the current GUI state to a config file in json format """
+        cfgfile = filedialog.asksaveasfile(mode='w',
+                                           filetypes=self.filetypes,
+                                           defaultextension='.fsw')
         if not cfgfile:
             return
         if command is None:
-            cfg = {cmd: {opt['control_title']: opt['value'].get() for opt in opts} 
+            cfg = {cmd: {opt['control_title']: opt['value'].get() for opt in opts}
                    for cmd, opts in self.opts.items()}
         else:
             cfg = {command: {opt['control_title']: opt['value'].get()
-                   for opt in self.opts[command]}}
+                             for opt in self.opts[command]}}
         cfgfile.write(self.serializer.marshal(cfg))
-        cfgfile.close
+        cfgfile.close()
 
     def reset_config(self, command=None):
-        ''' Reset the GUI to the default values '''
+        """ Reset the GUI to the default values """
         if command is None:
             options = [opt for opts in self.opts.values() for opt in opts]
         else:
@@ -143,7 +178,7 @@ class FaceswapGui(object):
             option['value'].set(default)
 
     def clear_config(self, command=None):
-        ''' Clear all values from the GUI '''
+        """ Clear all values from the GUI """
         if command is None:
             options = [opt for opts in self.opts.values() for opt in opts]
         else:
@@ -156,307 +191,982 @@ class FaceswapGui(object):
             else:
                 option['value'].set('')
 
-    def bind_help(self, control, helptext):
-        ''' Controls the help text displayed on mouse hover '''
-        for action in ('<Enter>', '<FocusIn>', '<Leave>', '<FocusOut>'):
-            helptext = helptext if action in ('<Enter>', '<FocusIn>') else ''
-            control.bind(action, lambda event, txt=helptext: self.helptext.set(txt))
+    def delete_preview(self):
+        """ Delete the preview file """
+        if os.path.exists(self.previewloc):
+            os.remove(self.previewloc)
 
-    def execute_task(self, command):
-        ''' Execute the task in Faceswap.py '''
-        self.task.execute_script(self.opts, command, self.parser, self.statustext)
 
-class ActionFrame(object):
-    '''Action Frame - Displays information and action controls '''
-    def __init__(self, gui, page, command):
-        self.gui = gui
-        self.page = page
-        self.command = command
-        self.title = command.title()
+class Tooltip:
+    """
+    Create a tooltip for a given widget as the mouse goes on it.
 
-    def build_frame(self):
-        ''' Add help display and Action buttons to the left frame of each page '''
-        frame = tk.Frame(self.page)
-        frame.pack(fill=tk.X, padx=(10,5), side=tk.LEFT, anchor=tk.N)
+    Adapted from StackOverflow:
 
-        self.add_info_section(frame)
-        self.add_action_buttons(frame)
-        self.add_util_buttons(frame)
-        self.add_status_section(frame)
-        
-    def add_info_section(self, frame):
-        ''' Build the info text section page '''
-        hlpframe=tk.Frame(frame)
-        hlpframe.pack(fill=tk.X, side=tk.TOP, pady=5)
-        lbltitle = tk.Label(hlpframe, text='Info', width=15, anchor=tk.SW)
-        lbltitle.pack(side=tk.TOP)
-        self.gui.helptext.set('')
-        lblhelp = tk.Label( hlpframe,
-                            height=20,
-                            width=15,
-                            textvariable=self.gui.helptext,
-                            wraplength=120, 
-                            justify=tk.LEFT, 
-                            anchor=tk.NW,
-                            bg="gray90")
-        lblhelp.pack(side=tk.TOP, anchor=tk.N)
-
-    def add_action_buttons(self, frame):
-        ''' Add the action buttons for page '''
-        actframe = tk.Frame(frame)
-        actframe.pack(fill=tk.X, side=tk.TOP, pady=(15, 0))
-
-        btnexecute = tk.Button( actframe,
-                                text=self.title,
-                                height=2,
-                                width=12,
-                                command=lambda: self.gui.execute_task(self.command))
-        btnexecute.pack(side=tk.TOP)
-        self.gui.bind_help(btnexecute, 'Run the {} script'.format(self.title))
+    http://stackoverflow.com/questions/3221956/
+           what-is-the-simplest-way-to-make-tooltips-
+           in-tkinter/36221216#36221216
 
-    def add_util_buttons(self, frame):
-        ''' Add the section utility buttons '''
-        utlframe = tk.Frame(frame)
-        utlframe.pack(side=tk.TOP, pady=(5,0))
+    http://www.daniweb.com/programming/software-development/
+           code/484591/a-tooltip-class-for-tkinter
+
+    - Originally written by vegaseat on 2014.09.09.
+
+    - Modified to include a delay time by Victor Zaccardo on 2016.03.25.
+
+    - Modified
+        - to correct extreme right and extreme bottom behavior,
+        - to stay inside the screen whenever the tooltip might go out on
+          the top but still the screen is higher than the tooltip,
+        - to use the more flexible mouse positioning,
+        - to add customizable background color, padding, waittime and
+          wraplength on creation
+      by Alberto Vassena on 2016.11.05.
+
+      Tested on Ubuntu 16.04/16.10, running Python 3.5.2
+
+    """
+
+    def __init__(self, widget,
+                 *,
+                 background='#FFFFEA',
+                 pad=(5, 3, 5, 3),
+                 text='widget info',
+                 waittime=400,
+                 wraplength=250):
+
+        self.waittime = waittime  # in miliseconds, originally 500
+        self.wraplength = wraplength  # in pixels, originally 180
+        self.widget = widget
+        self.text = text
+        self.widget.bind("<Enter>", self.on_enter)
+        self.widget.bind("<Leave>", self.on_leave)
+        self.widget.bind("<ButtonPress>", self.on_leave)
+        self.background = background
+        self.pad = pad
+        self.ident = None
+        self.topwidget = None
+
+    def on_enter(self, event=None):
+        """ Schedule on an enter event """
+        self.schedule()
+
+    def on_leave(self, event=None):
+        """ Unschedule on a leave event """
+        self.unschedule()
+        self.hide()
+
+    def schedule(self):
+        """ Show the tooltip after wait period """
+        self.unschedule()
+        self.ident = self.widget.after(self.waittime, self.show)
+
+    def unschedule(self):
+        """ Hide the tooltip """
+        id_ = self.ident
+        self.ident = None
+        if id_:
+            self.widget.after_cancel(id_)
+
+    def show(self):
+        """ Show the tooltip """
+        def tip_pos_calculator(widget, label,
+                               *,
+                               tip_delta=(10, 5), pad=(5, 3, 5, 3)):
+            """ Calculate the tooltip position """
+
+            s_width, s_height = widget.winfo_screenwidth(), widget.winfo_screenheight()
+
+            width, height = (pad[0] + label.winfo_reqwidth() + pad[2],
+                             pad[1] + label.winfo_reqheight() + pad[3])
+
+            mouse_x, mouse_y = widget.winfo_pointerxy()
+
+            x_1, y_1 = mouse_x + tip_delta[0], mouse_y + tip_delta[1]
+            x_2, y_2 = x_1 + width, y_1 + height
+
+            x_delta = x_2 - s_width
+            if x_delta < 0:
+                x_delta = 0
+            y_delta = y_2 - s_height
+            if y_delta < 0:
+                y_delta = 0
+
+            offscreen = (x_delta, y_delta) != (0, 0)
+
+            if offscreen:
+
+                if x_delta:
+                    x_1 = mouse_x - tip_delta[0] - width
+
+                if y_delta:
+                    y_1 = mouse_y - tip_delta[1] - height
+
+            offscreen_again = y_1 < 0  # out on the top
+
+            if offscreen_again:
+                # No further checks will be done.
+
+                # TIP:
+                # A further mod might automagically augment the
+                # wraplength when the tooltip is too high to be
+                # kept inside the screen.
+                y_1 = 0
+
+            return x_1, y_1
+
+        background = self.background
+        pad = self.pad
+        widget = self.widget
+
+        # creates a toplevel window
+        self.topwidget = tk.Toplevel(widget)
+
+        # Leaves only the label and removes the app window
+        self.topwidget.wm_overrideredirect(True)
+
+        win = tk.Frame(self.topwidget,
+                       background=background,
+                       borderwidth=0)
+        label = tk.Label(win,
+                         text=self.text,
+                         justify=tk.LEFT,
+                         background=background,
+                         relief=tk.SOLID,
+                         borderwidth=0,
+                         wraplength=self.wraplength)
+
+        label.grid(padx=(pad[0], pad[2]),
+                   pady=(pad[1], pad[3]),
+                   sticky=tk.NSEW)
+        win.grid()
+
+        xpos, ypos = tip_pos_calculator(widget, label)
+
+        self.topwidget.wm_geometry("+%d+%d" % (xpos, ypos))
+
+    def hide(self):
+        """ Hide the tooltip """
+        topwidget = self.topwidget
+        if topwidget:
+            topwidget.destroy()
+        self.topwidget = None
+
+class FaceswapGui(object):
+    """ The Graphical User Interface """
+
+    def __init__(self, utils, calling_file='faceswap.py'):
+        self.gui = tk.Tk()
+        self.utils = utils
+        self.calling_file = calling_file
+        self.utils.delete_preview()
+        self.utils.init_tk()
+        self.gui.protocol('WM_DELETE_WINDOW', self.close_app)
+
+    def build_gui(self):
+        """ Build the GUI """
+        self.gui.title(self.calling_file)
+        self.menu()
+
+        container = tk.PanedWindow(self.gui,
+                                   sashrelief=tk.RAISED,
+                                   orient=tk.VERTICAL)
+        container.pack(fill=tk.BOTH, expand=True)
+
+        topcontainer = tk.PanedWindow(container,
+                                      sashrelief=tk.RAISED,
+                                      orient=tk.HORIZONTAL)
+        container.add(topcontainer)
+
+        bottomcontainer = ttk.Frame(container, height=150)
+        container.add(bottomcontainer)
+
+        optsnotebook = ttk.Notebook(topcontainer, width=400, height=500)
+        topcontainer.add(optsnotebook)
+
+        if self.calling_file == 'faceswap.py':
+            # Commands explicitly stated to ensure consistent ordering
+            cmdlist = ('extract', 'train', 'convert')
+        else:
+            cmdlist = self.utils.opts.keys()
+
+        for command in cmdlist:
+            commandtab = CommandTab(self.utils, optsnotebook, command)
+            commandtab.build_tab()
+
+        dspnotebook = ttk.Notebook(topcontainer, width=780)
+        topcontainer.add(dspnotebook)
+
+        for display in ('graph', 'preview'):
+            displaytab = DisplayTab(self.utils, dspnotebook, display)
+            displaytab.build_tab()
+
+        self.add_console(bottomcontainer)
+        self.add_status_bar(bottomcontainer)
+
+    def menu(self):
+        """ Menu bar for loading and saving configs """
+        menubar = tk.Menu(self.gui)
+        filemenu = tk.Menu(menubar, tearoff=0)
+        filemenu.add_command(label='Load full config...',
+                             command=self.utils.load_config)
+        filemenu.add_command(label='Save full config...',
+                             command=self.utils.save_config)
+        filemenu.add_separator()
+        filemenu.add_command(label='Reset all to default',
+                             command=self.utils.reset_config)
+        filemenu.add_command(label='Clear all',
+                             command=self.utils.clear_config)
+        filemenu.add_separator()
+        filemenu.add_command(label='Quit', command=self.close_app)
+        menubar.add_cascade(label="File", menu=filemenu)
+        self.gui.config(menu=menubar)
+
+    def add_console(self, frame):
+        """ Build the output console """
+        consoleframe = ttk.Frame(frame)
+        consoleframe.pack(side=tk.TOP, anchor=tk.W, padx=10, pady=(2, 0),
+                          fill=tk.BOTH, expand=True)
+        console = ConsoleOut(consoleframe, self.utils)
+        console.build_console()
+
+    def add_status_bar(self, frame):
+        """ Build the info text section page """
+        statusframe = ttk.Frame(frame)
+        statusframe.pack(side=tk.BOTTOM, anchor=tk.W, padx=10, pady=2,
+                         fill=tk.X, expand=False)
+
+        lbltitle = ttk.Label(statusframe, text='Status:', width=6, anchor=tk.W)
+        lbltitle.pack(side=tk.LEFT, expand=False)
+        self.utils.guitext['status'].set('Ready')
+        lblstatus = ttk.Label(statusframe,
+                              width=20,
+                              textvariable=self.utils.guitext['status'],
+                              anchor=tk.W)
+        lblstatus.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=True)
+
+    def close_app(self):
+        """ Close Python. This is here because the graph animation function
+        continues to
+            run even when tkinter has gone away """
+        confirm = messagebox.askokcancel
+        confirmtxt = 'Processes are still running. Are you sure...?'
+        if self.utils.runningtask and not confirm('Close', confirmtxt):
+            return
+        if self.utils.runningtask:
+            self.utils.task.terminate()
+        self.utils.delete_preview()
+        self.gui.quit()
+        exit()
+
+class ConsoleOut(object):
+    """ The Console out tab of the Display section """
+
+    def __init__(self, frame, utils):
+        self.frame = frame
+        utils.console = tk.Text(self.frame)
+        self.console = utils.console
+        self.debug = utils.debugconsole
+
+    def build_console(self):
+        """ Build and place the console """
+        self.console.config(width=100, height=6, bg='gray90', fg='black')
+        self.console.pack(side=tk.LEFT, anchor=tk.N, fill=tk.BOTH, expand=True)
+
+        scrollbar = ttk.Scrollbar(self.frame, command=self.console.yview)
+        scrollbar.pack(side=tk.LEFT, fill='y')
+        self.console.configure(yscrollcommand=scrollbar.set)
+
+        if self.debug:
+            print('Console debug activated. Outputting to main terminal')
+        else:
+            sys.stdout = SysOutRouter(console=self.console, out_type="stdout")
+            sys.stderr = SysOutRouter(console=self.console, out_type="stderr")
+
+
+class SysOutRouter(object):
+    """ Route stdout/stderr to the console window """
+
+    def __init__(self, console=None, out_type=None):
+        self.console = console
+        self.out_type = out_type
+        self.color = ("black" if out_type == "stdout" else "red")
+
+    def write(self, string):
+        """ Capture stdout/stderr """
+        self.console.insert(tk.END, string, self.out_type)
+        self.console.tag_config(self.out_type, foreground=self.color)
+        self.console.see(tk.END)
+
+    @staticmethod
+    def flush():
+        """ If flush is forced, send it to normal terminal """
+        sys.__stdout__.flush()
 
-        for utl in ('load', 'save', 'clear', 'reset'):
-            img = getattr(self.gui, 'ico' + utl)
-            action = getattr(self.gui, utl + '_config')
-            btnutl = tk.Button( utlframe,
-                                height=16,
-                                width=16,
-                                image=img,
-                                command=lambda cmd=action: cmd(self.command))
-            btnutl.pack(padx=2, pady=2, side=tk.LEFT)
-            self.gui.bind_help(btnutl, utl.capitalize() + ' ' + self.title + ' config')
-
-    def add_status_section(self, frame):
-        ''' Build the info text section page '''
-        statusframe = tk.Frame(frame)
-        statusframe.pack(side=tk.TOP, pady=(5,0))
-        
-        lbltitle = tk.Label(statusframe, text='Status', width=15, anchor=tk.SW)
-        lbltitle.pack(side=tk.TOP)
-        self.gui.statustext.set('Idle')
-        lblstatus = tk.Label(   statusframe,
-                                height=1,
-                                width=15,
-                                textvariable=self.gui.statustext,
-                                wraplength=120,
-                                justify=tk.LEFT,
-                                anchor=tk.NW,
-                                bg="gray90")
-        lblstatus.pack(side=tk.BOTTOM, anchor=tk.N)
 
 class CommandTab(object):
-    ''' Tabs to hold the command options '''
-    def __init__(self, gui, notebook, command):
-        self.gui = gui
+
+    """ Tabs to hold the command options """
+
+    def __init__(self, utils, notebook, command):
+        self.utils = utils
         self.notebook = notebook
         self.page = ttk.Frame(self.notebook)
         self.command = command
         self.title = command.title()
 
     def build_tab(self):
-        ''' Build the tab '''
-        actionframe = ActionFrame(self.gui, self.page, self.command)
+        """ Build the tab """
+        actionframe = ActionFrame(self.utils, self.page, self.command)
         actionframe.build_frame()
-        self.add_frame_seperator()
-        opt_frame = self.add_right_frame()
-        
-        for option in self.gui.opts[self.command]:
-            self.build_tabs(option, opt_frame)
-        
+
+        self.add_frame_separator()
+        opts_frame = OptionsFrame(self.utils, self.page, self.command)
+        opts_frame.build_frame()
+
         self.notebook.add(self.page, text=self.title)
 
-    def add_frame_seperator(self):
-        ''' Add a seperator between left and right frames '''
-        sep = tk.Frame(self.page, width=2, bd=1, relief=tk.SUNKEN)
-        sep.pack(fill=tk.Y, padx=5, side=tk.LEFT)
+    def add_frame_separator(self):
+        """ Add a separator between left and right frames """
+        sep = ttk.Frame(self.page, height=2, relief=tk.RIDGE)
+        sep.pack(fill=tk.X, pady=(5, 0), side=tk.BOTTOM)
+
+class OptionsFrame(object):
+    """ Options Frame - Holds the Options for each command """
+
+    def __init__(self, utils, page, command):
+        self.utils = utils
+        self.page = page
+        self.command = command
 
-    def add_right_frame(self):
-        ''' Add the options panel to the right frame of each page '''
-        frame = tk.Frame(self.page)
-        frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(0,5))
+        self.canvas = tk.Canvas(self.page, bd=0, highlightthickness=0)
+        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 
-        canvas = tk.Canvas(frame, width=490, height=450, bd=0, highlightthickness=0)
-        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
+        self.optsframe = tk.Frame(self.canvas)
+        self.optscanvas = self.canvas.create_window((0, 0), window=self.optsframe, anchor=tk.NW)
 
-        self.add_scrollbar(frame, canvas)
+    def build_frame(self):
+        """ Build the options frame for this command """
+        self.add_scrollbar()
+        self.canvas.bind('<Configure>', self.resize_frame)
 
-        optsframe = tk.Frame(canvas)
-        canvas.create_window((0,0), window=optsframe, anchor=tk.NW)
+        for option in self.utils.opts[self.command]:
+            optioncontrol = OptionControl(self.utils, option, self.optsframe)
+            optioncontrol.build_full_control()
 
-        return optsframe
+    def add_scrollbar(self):
+        """ Add a scrollbar to the options frame """
+        scrollbar = ttk.Scrollbar(self.page, command=self.canvas.yview)
+        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
+        self.canvas.config(yscrollcommand=scrollbar.set)
+        self.optsframe.bind("<Configure>", self.update_scrollbar)
 
-    def add_scrollbar(self, frame, canvas):
-        ''' Add a scrollbar to the options frame '''
-        scrollbar = tk.Scrollbar(frame, command=canvas.yview)
-        scrollbar.pack(side=tk.LEFT, fill='y')
-        canvas.configure(yscrollcommand = scrollbar.set)
-        canvas.bind('<Configure>',lambda event, cvs=canvas: self.update_scrollbar(event, cvs))
+    def update_scrollbar(self, event):
+        """ Update the options frame scrollbar """
+        self.canvas.configure(scrollregion=self.canvas.bbox('all'))
 
-    @staticmethod
-    def update_scrollbar(event, canvas):
-        canvas.configure(scrollregion=canvas.bbox('all'))
-
-# Build the Right Frame Options
-    def build_tabs(self, option, option_frame):
-        ''' Build the correct control type for the option passed through '''
-        ctl = option['control']
-        ctltitle = option['control_title']
-        sysbrowser = option['filesystem_browser']
-        ctlhelp = ' '.join(option.get('help', '').split())
+    def resize_frame(self, event):
+        """ Resize the options frame to fit the canvas """
+        canvas_width = event.width
+        self.canvas.itemconfig(self.optscanvas, width=canvas_width)
+
+class OptionControl(object):
+    """ Build the correct control for the option parsed and place it on the
+    frame """
+
+    def __init__(self, utils, option, option_frame):
+        self.utils = utils
+        self.option = option
+        self.option_frame = option_frame
+
+    def build_full_control(self):
+        """ Build the correct control type for the option passed through """
+        ctl = self.option['control']
+        ctltitle = self.option['control_title']
+        sysbrowser = self.option['filesystem_browser']
+        ctlhelp = ' '.join(self.option.get('help', '').split())
         ctlhelp = '. '.join(i.capitalize() for i in ctlhelp.split('. '))
         ctlhelp = ctltitle + ' - ' + ctlhelp
-        ctlframe = self.build_control_frame(option_frame)
-        
-        dflt = option.get('default', False) if ctl == tk.Checkbutton else option.get('default', '')
-        choices = option['choices'] if ctl == ttk.Combobox else None
-
-        self.build_control_label(ctlframe, ctltitle)
-        option['value'] = self.build_control(ctlframe, ctl, dflt, ctlhelp, choices, sysbrowser)
-
-    def build_control_frame(self, option_frame):
-        ''' Build the frame to hold the control '''
-        frame = tk.Frame(option_frame)
-        frame.pack(fill=tk.X)
+        ctlframe = self.build_one_control_frame()
+        dflt = self.option.get('default', '')
+        dflt = self.option.get('default', False) if ctl == ttk.Checkbutton else dflt
+        choices = self.option['choices'] if ctl == ttk.Combobox else None
+
+        self.build_one_control_label(ctlframe, ctltitle)
+        self.option['value'] = self.build_one_control(ctlframe,
+                                                      ctl,
+                                                      dflt,
+                                                      ctlhelp,
+                                                      choices,
+                                                      sysbrowser)
+
+    def build_one_control_frame(self):
+        """ Build the frame to hold the control """
+        frame = ttk.Frame(self.option_frame)
+        frame.pack(fill=tk.X, expand=True)
         return frame
-    
-    def build_control_label(self, frame, control_title):
-        ''' Build and place the control label '''
-        lbl = tk.Label(frame, text=control_title, width=15, anchor=tk.W)
+
+    @staticmethod
+    def build_one_control_label(frame, control_title):
+        """ Build and place the control label """
+        lbl = ttk.Label(frame, text=control_title, width=18, anchor=tk.W)
         lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
 
-    def build_control(self, frame, control, default, helptext, choices, sysbrowser):
-        ''' Build and place the option controls '''
+    def build_one_control(self, frame, control, default, helptext, choices,
+                          sysbrowser):
+        """ Build and place the option controls """
         default = default if default is not None else ''
 
-        var = tk.BooleanVar(frame) if control == tk.Checkbutton else tk.StringVar(frame)
+        var = tk.BooleanVar(
+            frame) if control == ttk.Checkbutton else tk.StringVar(frame)
         var.set(default)
 
         if sysbrowser is not None:
             self.add_browser_buttons(frame, sysbrowser, var)
 
-        ctlkwargs = {'variable': var} if control == tk.Checkbutton else {'textvariable': var}
-        packkwargs = {'anchor': tk.W} if control == tk.Checkbutton else {'fill': tk.X}
-
-        if control == ttk.Combobox: #TODO: Remove this hacky fix to force the width of the frame
-            ctlkwargs['width'] = 40
-
+        ctlkwargs = {'variable': var} if control == ttk.Checkbutton else {
+            'textvariable': var}
+        packkwargs = {'anchor': tk.W} if control == ttk.Checkbutton else {
+            'fill': tk.X, 'expand': True}
         ctl = control(frame, **ctlkwargs)
-        
+
         if control == ttk.Combobox:
             ctl['values'] = [choice for choice in choices]
-        
-        ctl.pack(padx=5, pady=5, **packkwargs)
 
-        self.gui.bind_help(ctl, helptext)
-        return(var)
+        ctl.pack(padx=5, pady=5, **packkwargs)
+        Tooltip(ctl, text=helptext, wraplength=200)
+        return var
 
     def add_browser_buttons(self, frame, sysbrowser, filepath):
-        ''' Add correct file browser button for control '''
-        img = getattr(self.gui, 'ico' + sysbrowser)
+        """ Add correct file browser button for control """
+        img = self.utils.icons[sysbrowser]
         action = getattr(self, 'ask_' + sysbrowser)
-        fileopn = tk.Button(frame, image=img, command=lambda cmd=action: cmd(filepath))
-        fileopn.pack(side=tk.RIGHT)
+        fileopn = ttk.Button(frame, image=img,
+                             command=lambda cmd=action: cmd(filepath))
+        fileopn.pack(padx=(0, 5), side=tk.RIGHT)
 
     @staticmethod
     def ask_folder(filepath):
-        ''' Pop-up to get path to a folder '''
+        """ Pop-up to get path to a folder """
         dirname = filedialog.askdirectory()
         if dirname:
             filepath.set(dirname)
-   
+
     @staticmethod
     def ask_load(filepath):
-        ''' Pop-up to get path to a file '''
+        """ Pop-up to get path to a file """
         filename = filedialog.askopenfilename()
         if filename:
             filepath.set(filename)
 
+class ActionFrame(object):
+    """Action Frame - Displays information and action controls """
+
+    def __init__(self, utils, page, command):
+        self.utils = utils
+        self.page = page
+        self.command = command
+        self.title = command.title()
+
+    def build_frame(self):
+        """ Add help display and Action buttons to the left frame of each
+        page """
+        frame = ttk.Frame(self.page)
+        frame.pack(fill=tk.BOTH, padx=(10, 5), side=tk.BOTTOM, anchor=tk.N)
+
+        self.add_action_button(frame)
+        self.add_util_buttons(frame)
+
+    def add_action_button(self, frame):
+        """ Add the action buttons for page """
+        actframe = ttk.Frame(frame)
+        actframe.pack(fill=tk.X, side=tk.LEFT, padx=5, pady=5)
+
+        btnact = ttk.Button(actframe,
+                            text=self.title,
+                            width=12,
+                            command=lambda: self.utils.action_command(
+                                self.command))
+        btnact.pack(side=tk.TOP)
+        Tooltip(btnact, text='Run the {} script'.format(self.title), wraplength=200)
+        self.utils.actionbtns[self.command] = btnact
+
+    def add_util_buttons(self, frame):
+        """ Add the section utility buttons """
+        utlframe = ttk.Frame(frame)
+        utlframe.pack(side=tk.RIGHT, padx=(5, 10), pady=5)
+
+        for utl in ('load', 'save', 'clear', 'reset'):
+            img = self.utils.icons[utl]
+            action = getattr(self.utils, utl + '_config')
+            btnutl = ttk.Button(utlframe,
+                                image=img,
+                                command=lambda cmd=action: cmd(self.command))
+            btnutl.pack(padx=2, side=tk.LEFT)
+            Tooltip(btnutl, text=utl.capitalize() + ' ' + self.title + ' config', wraplength=200)
+
+class DisplayTab(object):
+    """ The display tabs """
+
+    def __init__(self, utils, notebook, display):
+        self.utils = utils
+        self.notebook = notebook
+        self.page = ttk.Frame(self.notebook)
+        self.display = display
+        self.title = self.display.title()
+
+    def build_tab(self):
+        """ Build the tab """
+        frame = ttk.Frame(self.page)
+        frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
+
+        if self.display == 'graph':
+            graphframe = GraphDisplay(frame, self.utils)
+            graphframe.create_graphs()
+        elif self.display == 'preview':
+            preview = PreviewDisplay(frame, self.utils.previewloc)
+            preview.update_preview()
+        else:  # Dummy in a placeholder
+            lbl = ttk.Label(frame, text=self.display, width=15, anchor=tk.NW)
+            lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
+
+        self.notebook.add(self.page, text=self.title)
+
+
+class GraphDisplay(object):
+    """ The Graph Tab of the Display section """
+
+    def __init__(self, frame, utils):
+        self.frame = frame
+        self.utils = utils
+        self.losskeys = None
+
+        self.graphpane = tk.PanedWindow(self.frame, sashrelief=tk.RAISED, orient=tk.VERTICAL)
+        self.graphpane.pack(fill=tk.BOTH, expand=True)
+
+        self.graphs = list()
+
+    def create_graphs(self):
+        """ create the graph frames when there are loss values to graph """
+        if not self.utils.lossdict:
+            self.frame.after(1000, self.create_graphs)
+            return
+
+        self.losskeys = sorted([key for key in self.utils.lossdict.keys()])
+
+        framecount = int(len(self.utils.lossdict) / 2)
+        for i in range(framecount):
+            self.add_graph(i)
+
+        self.monitor_state()
+
+    def add_graph(self, index):
+        """ Add a single graph to the graph window """
+        graphframe = ttk.Frame(self.graphpane)
+        self.graphpane.add(graphframe)
+
+        selectedkeys = self.losskeys[index * 2:(index + 1) * 2]
+        selectedloss = {key: self.utils.lossdict[key] for key in selectedkeys}
+
+        graph = Graph(graphframe, selectedloss, selectedkeys)
+        self.graphs.append(graph)
+        graph.build_graph()
+
+    def monitor_state(self):
+        """ Check there is a task still running. If not, destroy graphs
+            and reset graph display to waiting state """
+        if self.utils.lossdict:
+            self.frame.after(5000, self.monitor_state)
+            return
+        self.destroy_graphs()
+        self.create_graphs()
+
+    def destroy_graphs(self):
+        """ Destroy graphs when the process has stopped """
+        for graph in self.graphs:
+            del graph
+        self.graphs = list()
+        for child in self.graphpane.panes():
+            self.graphpane.remove(child)
+
+class Graph(object):
+    """ Each graph to be displayed. Until training is run it is not known
+        how many graphs will be required, so they sit in their own class
+        ready to be created when requested """
+
+    def __init__(self, frame, loss, losskeys):
+        self.frame = frame
+        self.loss = loss
+        self.losskeys = losskeys
+
+        self.ylim = (100, 0)
+
+        style.use('ggplot')
+
+        self.fig = plt.figure(figsize=(4, 4), dpi=75)
+        self.ax1 = self.fig.add_subplot(1, 1, 1)
+        self.losslines = list()
+        self.trndlines = list()
+
+    def build_graph(self):
+        """ Update the plot area with loss values and cycle through to
+        animate """
+        self.ax1.set_xlabel('Iterations')
+        self.ax1.set_ylabel('Loss')
+        self.ax1.set_ylim(0.00, 0.01)
+        self.ax1.set_xlim(0, 1)
+
+        losslbls = [lbl.replace('_', ' ').title() for lbl in self.losskeys]
+        for idx, linecol in enumerate(['blue', 'red']):
+            self.losslines.extend(self.ax1.plot(0, 0,
+                                                color=linecol,
+                                                linewidth=1,
+                                                label=losslbls[idx]))
+        for idx, linecol in enumerate(['navy', 'firebrick']):
+            lbl = losslbls[idx]
+            lbl = 'Trend{}'.format(lbl[lbl.rfind(' '):])
+            self.trndlines.extend(self.ax1.plot(0, 0,
+                                                color=linecol,
+                                                linewidth=2,
+                                                label=lbl))
+
+        self.ax1.legend(loc='upper right')
+
+        plt.subplots_adjust(left=0.075, bottom=0.075, right=0.95, top=0.95,
+                            wspace=0.2, hspace=0.2)
+
+        plotcanvas = FigureCanvasTkAgg(self.fig, self.frame)
+        plotcanvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)
+        ani = animation.FuncAnimation(self.fig, self.animate, interval=2000, blit=False)
+        plotcanvas.draw()
+
+    def animate(self, i):
+        """ Read loss data and apply to graph """
+        loss = [self.loss[key][:] for key in self.losskeys]
+
+        xlim = self.recalculate_axes(loss)
+
+        xrng = [x for x in range(xlim)]
+
+        self.raw_plot(xrng, loss)
+
+        if xlim > 10:
+            self.trend_plot(xrng, loss)
+
+    def recalculate_axes(self, loss):
+        ''' Recalculate the latest x and y axes limits from latest data '''
+        ymin = floor(min([min(lossvals) for lossvals in loss]) * 100) / 100
+        ymax = ceil(max([max(lossvals) for lossvals in loss]) * 100) / 100
+
+        if ymin < self.ylim[0] or ymax > self.ylim[1]:
+            self.ylim = (ymin, ymax)
+            self.ax1.set_ylim(self.ylim[0], self.ylim[1])
+
+        xlim = len(loss[0])
+        xlim = 2 if xlim == 1 else xlim
+        self.ax1.set_xlim(0, xlim - 1)
+
+        return xlim
+
+    def raw_plot(self, x_range, loss):
+        ''' Raw value plotting '''
+        for idx, lossvals in enumerate(loss):
+            self.losslines[idx].set_data(x_range, lossvals)
+
+    def trend_plot(self, x_range, loss):
+        ''' Trend value plotting '''
+        for idx, lossvals in enumerate(loss):
+            fit = numpy.polyfit(x_range, lossvals, 3)
+            poly = numpy.poly1d(fit)
+            self.trndlines[idx].set_data(x_range, poly(x_range))
+
+class PreviewDisplay(object):
+    """ The Preview tab of the Display section """
+
+    def __init__(self, frame, previewloc):
+        self.frame = frame
+        self.previewimg = None
+        self.errcount = 0
+        self.previewloc = previewloc
+
+        self.previewlbl = ttk.Label(self.frame, image=None, anchor=tk.NW)
+        self.previewlbl.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
+
+    def update_preview(self):
+        """ Display the image if it exists or a place holder if it doesn't """
+        self.load_preview()
+        if self.previewimg is None:
+            self.previewlbl.config(image=None)
+        else:
+            self.previewlbl.config(image=self.previewimg)
+        self.previewlbl.after(1000, self.update_preview)
+
+    def load_preview(self):
+        """ Load the preview image into tk PhotoImage """
+        if os.path.exists(self.previewloc):
+            try:
+                self.previewimg = tk.PhotoImage(file=self.previewloc)
+                self.errcount = 0
+            except TclError:
+                # This is probably an error reading the file whilst it's
+                # being saved
+                # so ignore it for now and only pick up if there have been
+                # multiple
+                # consecutive fails
+                if self.errcount < 10:
+                    self.errcount += 1
+                    self.previewimg = None
+                else:
+                    print('Error reading the preview file')
+        else:
+            self.previewimg = None
+
+
 class FaceswapControl(object):
-    ''' Control the underlying Faceswap tasks '''
-    def __init__(self):
-        self.opts = None
-        self.command = None
-        self.parser = None
-        self.statustext = None
+    """ Control the underlying Faceswap tasks """
 
-    def bad_args(self, args):
-        self.parser.print_help()
-        exit(0)
+    def __init__(self, utils, calling_file="faceswap.py"):
+        self.pathexecscript = os.path.join(PATHSCRIPT, calling_file)
+        self.utils = utils
 
-    def execute_script(self, options, command, parser, statustext):
-        self.opts = options
+        self.command = None
+        self.args = None
+        self.process = None
+        self.lenloss = 0
+
+    def prepare(self, options, command):
+        """ Prepare for running the subprocess """
         self.command = command
-        self.parser = parser
-        self.statustext = statustext
-        
-        optlist = ['faceswap.py', self.command]
-        for item in self.opts[self.command]:
-            optval = str(item.get('value','').get())
+        self.utils.runningtask = True
+        self.utils.change_action_button()
+        self.utils.guitext['status'].set('Executing - ' + self.command + '.py')
+        print('Loading...')
+        self.args = ['python', '-u', self.pathexecscript, self.command]
+        self.build_args(options)
+
+    def build_args(self, options):
+        """ Build the faceswap command and arguments list """
+        for item in options[self.command]:
+            optval = str(item.get('value', '').get())
             opt = item['opts'][0]
             if optval == 'False' or optval == '':
                 continue
             elif optval == 'True':
-                optlist.append(opt)
+                if self.command == 'train' and opt == '-p':  # Embed the preview pane
+                    self.args.append('-gui')
+                else:
+                    self.args.append(opt)
             else:
-                optlist.extend((opt, optval))
-        sys.argv = optlist
-        process = Thread(target=self.launch_faceswap, args=(self.command,))
-        process.start()
-
-    def launch_faceswap(self, command):
-        ''' Launch the script inside a subprocess to keep the GUI active '''
-        self.statustext.set('Executing: ' + command.title())
+                self.args.extend((opt, optval))
+
+    def execute_script(self):
+        """ Execute the requested Faceswap Script """
+        kwargs = {'stdout': PIPE,
+                  'stderr': PIPE,
+                  'bufsize': 1,
+                  'universal_newlines': True}
+        if os.name == 'nt':
+            kwargs['creationflags'] = subprocess.CREATE_NEW_PROCESS_GROUP
+        self.process = Popen(self.args, **kwargs)
+        self.thread_stdout()
+        self.thread_stderr()
+
+    def read_stdout(self):
+        """ Read stdout from the subprocess. If training, pass the loss
+        values to Queue """
+        while True:
+            output = self.process.stdout.readline()
+            if output == '' and self.process.poll() is not None:
+                break
+            if output:
+                if self.command == 'train' and str.startswith(output, '['):
+                    self.capture_loss(output)
+                print(output.strip())
+        returncode = self.process.poll()
+        self.utils.runningtask = False
+        self.utils.change_action_button()
+        self.set_final_status(returncode)
+        print('Process exited.')
+
+    def read_stderr(self):
+        """ Read stdout from the subprocess. If training, pass the loss
+        values to Queue """
+        while True:
+            output = self.process.stderr.readline()
+            if output == '' and self.process.poll() is not None:
+                break
+            print(output.strip(), file=sys.stderr)
+
+    def thread_stdout(self):
+        """ Put the subprocess stdout so that it can be read without
+        blocking """
+        thread = Thread(target=self.read_stdout)
+        thread.daemon = True
+        thread.start()
+
+    def thread_stderr(self):
+        """ Put the subprocess stderr so that it can be read without
+        blocking """
+        thread = Thread(target=self.read_stderr)
+        thread.daemon = True
+        thread.start()
+
+    def capture_loss(self, string):
+        """ Capture loss values from stdout """
+        #TODO: Remove this hideous hacky fix. When the subprocess is terminated and
+        # the loss dictionary is reset, 1 set of loss values ALWAYS slips through
+        # and appends to the lossdict AFTER the subprocess has closed meaning that
+        # checks on whether the dictionary is empty fail.
+        # Therefore if the size of current loss dictionary is smaller than the
+        # previous loss dictionary, assume that the process has been terminated
+        # and reset it.
+        # I have tried and failed to empty the subprocess stdout with:
+        #   sys.exit() on the stdout/err threads (no effect)
+        #   sys.stdout/stderr.flush (no effect)
+        #   thread.join (locks the whole process up, because the stdout thread
+        #       stubbonly refuses to release it's last line)
+
+        currentlenloss = len(self.utils.lossdict)
+        if self.lenloss > currentlenloss:
+            self.utils.lossdict = dict()
+            self.lenloss = 0
+            return
+        self.lenloss = currentlenloss
+
+        loss = re.findall(r'([a-zA-Z_]+):.*?(\d+\.\d+)', string)
+
+        if len(loss) < 2:
+            return
+
+        if not self.utils.lossdict:
+            self.utils.lossdict.update((item[0], []) for item in loss)
+
+        for item in loss:
+            self.utils.lossdict[item[0]].append(float(item[1]))
+
+    def terminate(self):
+        """ Terminate the subprocess """
+        if self.command == 'train':
+            print('Sending Exit Signal', flush=True)
+            try:
+                now = time()
+                if os.name == 'nt':
+                    os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)
+                else:
+                    self.process.send_signal(signal.SIGINT)
+                while True:
+                    timeelapsed = time() - now
+                    if self.process.poll() is not None:
+                        break
+                    if timeelapsed > 30:
+                        raise ValueError('Timeout reached sending Exit Signal')
+                return
+            except ValueError as err:
+                print(err)
+        print('Terminating Process...')
         try:
-            self.parser.set_defaults(func=self.bad_args)
-            arguments = self.parser.parse_args()
-            arguments.func(arguments)
-        except:
-            self.statustext.set('Failed: ' + command.title())    
-            raise
-        self.statustext.set('Idle')
-        exit()        
+            self.process.terminate()
+            self.process.wait(timeout=10)
+            print('Terminated')
+        except TimeoutExpired:
+            print('Termination timed out. Killing Process...')
+            self.process.kill()
+            print('Killed')
+
+    def set_final_status(self, returncode):
+        """ Set the status bar output based on subprocess return code """
+        if returncode == 0 or returncode == 3221225786:
+            status = 'Ready'
+        elif returncode == -15:
+            status = 'Terminated - {}.py'.format(self.command)
+        elif returncode == -9:
+            status = 'Killed - {}.py'.format(self.command)
+        elif returncode == -6:
+            status = 'Aborted - {}.py'.format(self.command)
+        else:
+            status = 'Failed - {}.py. Return Code: {}'.format(self.command, returncode)
+        self.utils.guitext['status'].set(status)
+
 
 class TKGui(object):
-    ''' Main GUI Control '''
-    def __init__ (self, subparser, subparsers, parser, command, description='default'):
-    # Don't try to load the GUI if there is no display or there are problems importing tkinter
+    """ Main GUI Control """
+
+    def __init__(self, subparser, subparsers, command, description='default'):
+        # Don't try to load the GUI if there is no display or there are
+        # problems importing tkinter
         cmd = sys.argv
-        if not check_display(cmd) or not import_tkinter(cmd):
+        if not self.check_display(cmd) or not self.check_tkinter_available(cmd):
             return
-       
-        self.parser = parser
+
+        self.arguments = None
         self.opts = self.extract_options(subparsers)
-        self.root = FaceswapGui(self.opts, self.parser)
+        self.utils = Utils(self.opts, calling_file=cmd[0])
+        self.root = FaceswapGui(self.utils, calling_file=cmd[0])
         self.parse_arguments(description, subparser, command)
 
+    @staticmethod
+    def check_display(command):
+        """ Check whether there is a display to output the GUI. If running on
+            Windows then assume not running in headless mode """
+        if not os.environ.get('DISPLAY', None) and os.name != 'nt':
+            if 'gui' in command:
+                print('Could not detect a display. The GUI has been disabled.')
+                if os.name == 'posix':
+                    print('macOS users need to install XQuartz. '
+                          'See https://support.apple.com/en-gb/HT201341')
+            return False
+        return True
+
+    @staticmethod
+    def check_tkinter_available(command):
+        """ Check whether TkInter is installed on user's machine """
+        tkinter_vars = [tk, ttk, filedialog, messagebox, TclError]
+        if any(var is None for var in tkinter_vars):
+            if "gui" in command:
+                print(
+                    "It looks like TkInter isn't installed for your OS, so "
+                    "the GUI has been "
+                    "disabled. To enable the GUI please install the TkInter "
+                    "application.\n"
+                    "You can try:\n"
+                    "  Windows/macOS:      Install ActiveTcl Community "
+                    "Edition from "
+                    "www.activestate.com\n"
+                    "  Ubuntu/Mint/Debian: sudo apt install python3-tk\n"
+                    "  Arch:               sudo pacman -S tk\n"
+                    "  CentOS/Redhat:      sudo yum install tkinter\n"
+                    "  Fedora:             sudo dnf install python3-tkinter\n",
+                    file=sys.stderr)
+            return False
+        return True
+
     def extract_options(self, subparsers):
-        ''' Extract the existing ArgParse Options '''
-        opts = {cmd: subparsers[cmd].argument_list + 
-                subparsers[cmd].optional_arguments for cmd in subparsers.keys()}
+        """ Extract the existing ArgParse Options """
+        opts = {cmd: subparsers[cmd].argument_list + subparsers[cmd].optional_arguments
+                for cmd in subparsers.keys()}
         for command in opts.values():
             for opt in command:
+                if opt.get('help', '') == SUPPRESS:
+                    command.remove(opt)
                 ctl, sysbrowser = self.set_control(opt)
-                opt['control_title'] = self.set_control_title(opt.get('opts',''))
+                opt['control_title'] = self.set_control_title(
+                    opt.get('opts', ''))
                 opt['control'] = ctl
                 opt['filesystem_browser'] = sysbrowser
         return opts
 
     @staticmethod
     def set_control_title(opts):
-        ''' Take the option switch and format it nicely '''
+        """ Take the option switch and format it nicely """
         ctltitle = opts[1] if len(opts) == 2 else opts[0]
-        ctltitle = ctltitle.replace('-',' ').replace('_',' ').strip().title()
+        ctltitle = ctltitle.replace('-', ' ').replace('_', ' ').strip().title()
         return ctltitle
- 
+
     @staticmethod
     def set_control(option):
-        ''' Set the control and filesystem browser to use for each option '''
+        """ Set the control and filesystem browser to use for each option """
         sysbrowser = None
-        ctl = tk.Entry
+        ctl = ttk.Entry
         if option.get('dest', '') == 'alignments_path':
             sysbrowser = 'load'
         elif option.get('action', '') == FullPaths:
@@ -464,22 +1174,28 @@ class TKGui(object):
         elif option.get('choices', '') != '':
             ctl = ttk.Combobox
         elif option.get('action', '') == 'store_true':
-            ctl = tk.Checkbutton
+            ctl = ttk.Checkbutton
         return ctl, sysbrowser
 
     def parse_arguments(self, description, subparser, command):
+        """ Parse the command line arguments for the GUI """
         parser = subparser.add_parser(
             command,
             help="This Launches a GUI for Faceswap.",
             description=description,
             epilog="Questions and feedback: \
-            https://github.com/deepfakes/faceswap-playground"
-        )
-        parser.set_defaults(func=self.process)        
+                    https://github.com/deepfakes/faceswap-playground")
+
+        parser.add_argument('-d', '--debug',
+                            action='store_true',
+                            dest='debug',
+                            default=False,
+                            help='Output to Shell console instead of GUI console')
+        parser.set_defaults(func=self.process)
 
     def process(self, arguments):
-        ''' Builds the GUI '''
+        """ Builds the GUI """
         self.arguments = arguments
+        self.utils.debugconsole = self.arguments.debug
         self.root.build_gui()
         self.root.gui.mainloop()
-
diff --git a/scripts/train.py b/scripts/train.py
index d7c26f7..f89ade7 100644
--- a/scripts/train.py
+++ b/scripts/train.py
@@ -4,7 +4,7 @@ import time
 
 import threading 
 from lib.utils import get_image_paths, get_folder
-from lib.cli import FullPaths
+from lib.cli import FullPaths, argparse, os, sys
 from plugins.PluginLoader import PluginLoader
 
 tf = None
@@ -106,6 +106,13 @@ class TrainingProcessor(object):
                                "type": int,
                                "default": 1,
                                "help": "Number of GPUs to use for training"})
+        # This is a hidden argument to indicate that the GUI is being used, so the preview window
+        # should be redirected Accordingly
+        argument_list.append({ "opts": ("-gui", "--gui"),
+                               "action": "store_true",
+                               "dest": "redirect_gui",
+                               "default": False,
+                               "help": argparse.SUPPRESS})
         return argument_list
 
     @staticmethod
@@ -161,8 +168,11 @@ class TrainingProcessor(object):
                 except KeyboardInterrupt:
                     break
         else:
-            input() # TODO how to catch a specific key instead of Enter?
-            # there isnt a good multiplatform solution: https://stackoverflow.com/questions/3523174/raw-input-in-python-without-pressing-enter
+            try:
+                input() # TODO how to catch a specific key instead of Enter?
+                # there isnt a good multiplatform solution: https://stackoverflow.com/questions/3523174/raw-input-in-python-without-pressing-enter
+            except KeyboardInterrupt:
+                pass
 
         print("Exit requested! The trainer will complete its current cycle, save the models and quit (it can take up a couple of seconds depending on your training speed). If you want to kill it now, press Ctrl + c")
         self.stop = True
@@ -225,7 +235,12 @@ class TrainingProcessor(object):
 
     def show(self, image, name=''):
         try:
-            if self.arguments.preview:
+            if self.arguments.redirect_gui:
+                scriptpath = os.path.realpath(os.path.dirname(sys.argv[0]))
+                img = '.gui_preview.png'
+                imgfile = os.path.join(scriptpath, img)
+                cv2.imwrite(imgfile, image)
+            elif self.arguments.preview:
                 with self.lock:
                     self.preview_buffer[name] = image
             elif self.arguments.write_image:
diff --git a/tools.py b/tools.py
index 87bdfa8..54e5fde 100755
--- a/tools.py
+++ b/tools.py
@@ -3,6 +3,7 @@ import sys
 from lib.cli import FullHelpArgumentParser
 # Importing the various tools
 from tools.sort import SortProcessor
+from scripts.gui import TKGui
 
 # Python version check
 if sys.version_info[0] < 3:
@@ -27,6 +28,10 @@ if __name__ == "__main__":
     sort = SortProcessor(
         subparser, "sort", "This command lets you sort images using various "
                            "methods.")
+    guiparsers = {'sort': sort}
+    print(__file__)
+    gui = TKGui(
+            subparser, guiparsers, "gui", "Launch the Faceswap Tools Graphical User Interface.")
     parser.set_defaults(func=bad_args)
     arguments = parser.parse_args()
     arguments.func(arguments)
diff --git a/tools/sort.py b/tools/sort.py
index f077a1d..db2b2a3 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python3
+#!/usr/bin python3
 import argparse
 import os
 import sys
@@ -8,36 +8,165 @@ import cv2
 from tqdm import tqdm
 from shutil import copyfile
 import json
-import re
+from lib.cli import FullPaths
 
-# DLIB is a GPU Memory hog, so the following modules should only be imported when required
+# DLIB is a GPU Memory hog, so the following modules should only be imported
+# when required
 face_recognition = None
 FaceLandmarksExtractor = None
 
+
 def import_face_recognition():
-    ''' Import the face_recognition module only when it is required '''
+    """ Import the face_recognition module only when it is required """
     global face_recognition
     if face_recognition is None:
         import face_recognition
 
+
 def import_FaceLandmarksExtractor():
-    ''' Import the FaceLandmarksExtractor module only when it is required '''
+    """ Import the FaceLandmarksExtractor module only when it is required """
     global FaceLandmarksExtractor
     if FaceLandmarksExtractor is None:
         import lib.FaceLandmarksExtractor
         FaceLandmarksExtractor = lib.FaceLandmarksExtractor
 
-if sys.version_info[0] < 3:
-    raise Exception("This program requires at least python3.2")
-if sys.version_info[0] == 3 and sys.version_info[1] < 2:
-    raise Exception("This program requires at least python3.2")
 
 class SortProcessor(object):
     def __init__(self, subparser, command, description='default'):
-        self.arguments = None
+        self.argument_list = self.get_argument_list()
+        self.optional_arguments = self.get_optional_arguments()
+        self.args = None
         self.changes = None
         self.parse_arguments(description, subparser, command)
 
+    @staticmethod
+    def get_argument_list():
+        arguments_list = list()
+        arguments_list.append({"opts": ('-i', '--input'),
+                               "action": FullPaths,
+                               "dest": "input_dir",
+                               "default": "input_dir",
+                               "help": "Input directory of aligned faces.",
+                               "required": True})
+
+        arguments_list.append({"opts": ('-o', '--output'),
+                               "dest": "output_dir",
+                               "default": "output_dir",
+                               "help": "Output directory for sorted aligned "
+                                       "faces."})
+
+        arguments_list.append({"opts": ('-f', '--final-process'),
+                               "type": str,
+                               "choices": ("folders", "rename"),
+                               "dest": 'final_process',
+                               "default": "rename",
+                               "help": "'folders': files are sorted using the "
+                                       "-s/--sort-by method, then they are "
+                                       "organized into folders using the "
+                                       "-g/--group-by grouping method. "
+                                       "'rename': files are sorted using the "
+                                       "-s/--sort-by then they are renamed. "
+                                       "Default: rename"})
+
+        arguments_list.append({"opts": ('-t', '--ref_threshold'),
+                               "type": float,
+                               "dest": 'min_threshold',
+                               "default": -1.0,
+                               "help": "Float value. "
+                                       "Minimum threshold to use for grouping "
+                                       "comparison with 'face' and 'hist' methods. "
+                                       "The lower the value the more discriminating "
+                                       "the grouping is. "
+                                       "Leaving -1.0 will make the program "
+                                       "set the default value automatically. "
+                                       "For face 0.6 should be enough, with 0.5 "
+                                       "being very discriminating. "
+                                       "For face-cnn 7.2 should be enough, with 4 "
+                                       "being very discriminating. "
+                                       "For hist 0.3 should be enough, with 0.2 "
+                                       "being very discriminating. "
+                                       "Be careful setting a value that's too "
+                                       "low in a directory with many images, as "
+                                       "this could result in a lot of directories "
+                                       " being created. "
+                                       "Defaults: face 0.6, face-cnn 7.2, hist 0.3"})
+
+        arguments_list.append({"opts": ('-b', '--bins'),
+                               "type": int,
+                               "dest": 'num_bins',
+                               "default": 5,
+                               "help": "Integer value. "
+                                       "Number of folders that will be used to "
+                                       "group by blur. Folder 0 will be the least "
+                                       "blurry, while the last folder will be the "
+                                       "blurriest. If the number of images doesn't "
+                                       "divide evenly into the number of bins, the "
+                                       "remaining images get put in the last bin as "
+                                       "they will be the blurriest by definition. "
+                                       "Default value: 5"})
+
+        arguments_list.append({"opts": ('-k', '--keep'),
+                               "action": 'store_true',
+                               "dest": 'keep_original',
+                               "default": False,
+                               "help": "Keeps the original files in the input "
+                                       "directory. Be careful when using this with "
+                                       "rename grouping and no specified output "
+                                       "directory as this would keep the original "
+                                       "and renamed files in the same directory."})
+
+        arguments_list.append({"opts": ('-l', '--log-changes'),
+                               "action": 'store_true',
+                               "dest": 'log_changes',
+                               "default": False,
+                               "help": "Logs file renaming changes if grouping by "
+                                       "renaming, or it logs the file "
+                                       "copying/movement if grouping by folders. "
+                                       "If no log file is specified with "
+                                       "'--log-file', then a 'sort_log.json' file "
+                                       "will be created in the input directory."})
+
+        arguments_list.append({"opts": ('-lf', '--log-file'),
+                               "dest": 'log_file_path',
+                               "default": 'sort_log.json',
+                               "help": "Specify a log file to use for saving the "
+                                       "renaming or grouping information. "
+                                       "Default: sort_log.json"})
+
+        arguments_list.append({"opts": ('-s', '--sort-by'),
+                               "type": str,
+                               "choices": ("blur", "face", "face-cnn",
+                                           "face-cnn-dissim", "face-dissim",
+                                           "face-yaw", "hist",
+                                           "hist-dissim"),
+                               "dest": 'sort_method',
+                               "default": "hist",
+                               "help": "Sort by method. "
+                                       "Choose how images are sorted. "
+                                       "Default: hist"})
+
+        arguments_list.append({"opts": ('-g', '--group-by'),
+                               "type": str,
+                               "choices": ("blur", "face", "face-cnn", "hist"),
+                               "dest": 'group_method',
+                               "default": "hist",
+                               "help": "Group by method. "
+                                       "When -fp/--final-processing by folders "
+                                       "choose the how the images are grouped after "
+                                       "sorting. "
+                                       "Default: hist"})
+        return arguments_list
+
+    @staticmethod
+    def get_optional_arguments():
+        """
+        Put the arguments in a list so that they are accessible from both
+        argparse and gui.
+        """
+        # Override this for custom arguments
+        argument_list = []
+        return argument_list
+
     def parse_arguments(self, description, subparser, command):
         parser = subparser.add_parser(
                 command,
@@ -50,158 +179,64 @@ class SortProcessor(object):
                         https://github.com/deepfakes/faceswap-playground"
         )
 
-        parser.add_argument('-i', '--input',
-                            dest="input_dir",
-                            default="input_dir",
-                            help="Input directory of aligned faces.",
-                            required=True)
-
-        parser.add_argument('-o', '--output',
-                            dest="output_dir",
-                            default="__default",
-                            help="Output directory for sorted aligned faces.")
-
-        parser.add_argument('-f', '--final-process',
-                            type=str,
-                            choices=("folders", "rename"),
-                            dest='final_process',
-                            default="rename",
-                            help="'folders': files are sorted using the "
-                                 "-s/--sort-by method, then they are "
-                                 "organized into folders using the "
-                                 "-g/--group-by grouping method. "
-                                 "'rename': files are sorted using the "
-                                 "-s/--sort-by then they are renamed."
-                                 "Default: rename")
-
-        parser.add_argument('-t', '--ref_threshold',
-                            type=float,
-                            dest='min_threshold',
-                            default=-1.0,
-                            help="Float value. "
-                                 "Minimum threshold to use for grouping "
-                                 "comparison with 'face' and 'hist' methods. "
-                                 "The lower the value the more discriminating "
-                                 "the grouping is. "
-                                 "For face 0.6 should be enough, with 0.5 "
-                                 "being very discriminating. "
-                                 "For face-cnn 7.2 should be enough, with 4 "
-                                 "being very discriminating. "
-                                 "For hist 0.3 should be enough, with 0.2 "
-                                 "being very discriminating. "
-                                 "Be careful setting a value that's too "
-                                 "low in a directory with many images, as "
-                                 "this could result in a lot of directories "
-                                 " being created. "
-                                 "Defaults: face 0.6, face-cnn 7.2, hist 0.3")
-
-        parser.add_argument('-b', '--bins',
-                            type=int,
-                            dest='num_bins',
-                            default=5,
-                            help="Integer value. "
-                                 "Number of folders that will be used to " 
-                                 "group by blur. Folder 0 will be the least "
-                                 "blurry, while the last folder will be the "
-                                 "blurriest. If the number of images doesn't "
-                                 "divide evenly into the number of bins, the "
-                                 "remaining images get put in the last bin as "
-                                 "they will be the blurriest by definition. "
-                                 "Default value: 5")
-
-        parser.add_argument('-k', '--keep',
-                            action='store_true',
-                            dest='keep_original',
-                            default=False,
-                            help="Keeps the original files in the input "
-                                 "directory. Be careful when using this with "
-                                 "rename grouping and no specified output "
-                                 "directory as this would keep the original "
-                                 "and renamed files in the same directory.")
-
-        parser.add_argument('-l', '--log-changes',
-                            action='store_true',
-                            dest='log_changes',
-                            default=False,
-                            help="Logs file renaming changes if grouping by "
-                                 "renaming, or it logs the file "
-                                 "copying/movement if grouping by folders. "
-                                 "If no log file is specified with "
-                                 "'--log-file', then a 'sort_log.json' file "
-                                 "will be created in the input directory.")
-
-        parser.add_argument('-lf', '--log-file',
-                            dest='log_file',
-                            default='__default',
-                            help="Specify a log file to use for saving the "
-                                 "renaming or grouping information. "
-                                 "Default: sort_log.json")
-
-        parser.add_argument('-s', '--sort-by',
-                            type=str,
-                            choices=("blur", "face", "face-cnn",
-                                     "face-cnn-dissim", "face-dissim", "face-yaw", "hist",
-                                     "hist-dissim"),
-                            dest='sort_method',
-                            default="hist",
-                            help="Sort by method. "
-                                 "Choose how images are sorted. "
-                                 "Default: hist")
-
-        parser.add_argument('-g', '--group-by',
-                            type=str,
-                            choices=("blur", "face", "face-cnn", "hist"),
-                            dest='group_method',
-                            default="__default",
-                            help="Group by method. "
-                                 "When -fp/--final-processing by folders "
-                                 "choose the how the images are grouped after "
-                                 "sorting. "
-                                 "Default: non-dissim version of "
-                                 "-s/--sort-by method")
+        for option in self.argument_list:
+            args = option['opts']
+            kwargs = {key: option[key] for key in option.keys() if key != 'opts'}
+            parser.add_argument(*args, **kwargs)
 
         parser = self.add_optional_arguments(parser)
         parser.set_defaults(func=self.process_arguments)
 
     def add_optional_arguments(self, parser):
-        # Override this for custom arguments
+        for option in self.optional_arguments:
+            args = option['opts']
+            kwargs = {key: option[key] for key in option.keys() if key != 'opts'}
+            parser.add_argument(*args, **kwargs)
         return parser
 
     def process_arguments(self, arguments):
-        self.arguments = arguments
+        self.args = arguments
 
         # Setting default argument values that cannot be set by argparse
 
         # Set output dir to the same value as input dir
         # if the user didn't specify it.
-        if self.arguments.output_dir.lower() == "__default":
-            self.arguments.output_dir = self.arguments.input_dir
+        if self.args.output_dir.lower() == "--default":
+            self.args.output_dir = self.args.input_dir
 
         # Set final_process to group if folders was chosen
-        if self.arguments.final_process.lower() == "folders":
-            self.arguments.final_process = "group"
+        if self.args.final_process.lower() == "folders":
+            self.args.final_process = "group"
 
         # Assign default group_method if not set by user
-        if self.arguments.group_method == '__default':
-            self.arguments.group_method = self.arguments.sort_method.replace('-dissim', '')
+        #if self.args.group_method == '--default':
+        #    self.args.group_method = self.args.sort_method.replace('-dissim', '')
 
         # Assigning default threshold values based on grouping method
-        if self.arguments.min_threshold == -1.0 and self.arguments.final_process == "group":
-            method = self.arguments.group_method.lower()
+        if self.args.min_threshold == -1.0 and self.args.final_process == "group":
+            method = self.args.group_method.lower()
             if method == 'face':
-                self.arguments.min_threshold = 0.6
+                self.args.min_threshold = 0.6
             elif method == 'face-cnn':
-                self.arguments.min_threshold = 7.2
+                self.args.min_threshold = 7.2
             elif method == 'hist':
-                self.arguments.min_threshold = 0.3
+                self.args.min_threshold = 0.3
 
         # If logging is enabled, prepare container
-        if self.arguments.log_changes:
+        if self.args.log_changes:
             self.changes = dict()
 
         # Assign default sort_log.json value if user didn't specify one
-        if self.arguments.log_file.lower() == '__default':
-            self.arguments.log_file = os.path.join(self.arguments.input_dir, 'sort_log.json')
+        if self.args.log_file_path.lower() == 'sort_log.json':
+            self.args.log_file_path = os.path.join(self.args.input_dir, 'sort_log.json')
+
+        # Prepare sort, group and final process method names
+        _sort = "sort_" + self.args.sort_method.lower()
+        _group = "group_" + self.args.group_method.lower()
+        _final = "final_process_" + self.args.final_process.lower()
+        self.args.sort_method = _sort.replace('-', '_')
+        self.args.group_method = _group.replace('-', '_')
+        self.args.final_process = _final.replace('-', '_')
 
         self.process()
 
@@ -211,19 +246,14 @@ class SortProcessor(object):
         the core process of sorting, optionally grouping, renaming/moving into
         folders. After the functions are assigned they are executed.
         """
-        __sort_method = self.arguments.sort_method.lower()
-        __group_method = self.arguments.group_method.lower()
-        final_process = self.arguments.final_process.lower()
-
-        # Assign the methods that will be used for processing the files
-        sort_method = self.set_process_method("sort", __sort_method)
-        group_method = self.set_process_method("group", __group_method)
-        final_method = self.set_process_method("final_process", final_process)
+        sort_method = self.args.sort_method.lower()
+        group_method = self.args.group_method.lower()
+        final_method = self.args.final_process.lower()
 
         img_list = getattr(self, sort_method)()
-        if "group" in final_process:
+        if "group" in final_method:
             # Check if non-dissim sort method and group method are not the same
-            if __sort_method.replace('-dissim', '') != __group_method:
+            if group_method.replace('group_', '') not in sort_method:
                 img_list = self.reload_images(group_method, img_list)
                 img_list = getattr(self, group_method)(img_list)
             else:
@@ -231,15 +261,17 @@ class SortProcessor(object):
 
         getattr(self, final_method)(img_list)
 
-        print ("Done.")
+        print("Done.")
 
     # Methods for sorting
     def sort_blur(self):
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
 
-        print ("Sorting by blur...")
-        img_list = [ [x, self.estimate_blur(cv2.imread(x))] for x in tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout) ]
-        print ("Sorting...")
+        print("Sorting by blur...")
+        img_list = [[x, self.estimate_blur(cv2.imread(x))]
+                    for x in
+                    tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout)]
+        print("Sorting...")
 
         img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)
 
@@ -247,46 +279,50 @@ class SortProcessor(object):
 
     def sort_face(self):
         import_face_recognition()
-       
-        input_dir = self.arguments.input_dir
 
-        print ("Sorting by face similarity...")
-        
-        img_list = [ [x, face_recognition.face_encodings(cv2.imread(x)) ] for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout) ]
+        input_dir = self.args.input_dir
+
+        print("Sorting by face similarity...")
+
+        img_list = [[x, face_recognition.face_encodings(cv2.imread(x))]
+                    for x in
+                    tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout)]
 
         img_list_len = len(img_list)
-        for i in tqdm ( range(0, img_list_len-1), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len - 1), desc="Sorting", file=sys.stdout):
             min_score = float("inf")
-            j_min_score = i+1
-            for j in range(i+1,len(img_list)):
-            
+            j_min_score = i + 1
+            for j in range(i + 1, len(img_list)):
                 f1encs = img_list[i][1]
                 f2encs = img_list[j][1]
-                if f1encs is not None and f2encs is not None and len(f1encs) > 0 and len(f2encs) > 0:
+                if f1encs is not None and f2encs is not None and len(
+                        f1encs) > 0 and len(f2encs) > 0:
                     score = face_recognition.face_distance(f1encs[0], f2encs)[0]
-                else: 
+                else:
                     score = float("inf")
-                
+
                 if score < min_score:
                     min_score = score
-                    j_min_score = j            
-            img_list[i+1], img_list[j_min_score] = img_list[j_min_score], img_list[i+1]
-            
+                    j_min_score = j
+            img_list[i + 1], img_list[j_min_score] = img_list[j_min_score], img_list[i + 1]
+
         return img_list
 
     def sort_face_dissim(self):
         import_face_recognition()
-        
-        input_dir = self.arguments.input_dir
 
-        print ("Sorting by face dissimilarity...")
+        input_dir = self.args.input_dir
 
-        img_list = [ [x, face_recognition.face_encodings(cv2.imread(x)), 0 ] for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout) ]
+        print("Sorting by face dissimilarity...")
+
+        img_list = [[x, face_recognition.face_encodings(cv2.imread(x)), 0]
+                    for x in
+                    tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout)]
 
         img_list_len = len(img_list)
-        for i in tqdm ( range(0, img_list_len), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len), desc="Sorting", file=sys.stdout):
             score_total = 0
-            for j in range( 0, img_list_len):
+            for j in range(0, img_list_len):
                 if i == j:
                     continue
                 try:
@@ -296,131 +332,142 @@ class SortProcessor(object):
 
             img_list[i][2] = score_total
 
-
-        print ("Sorting...")
+        print("Sorting...")
         img_list = sorted(img_list, key=operator.itemgetter(2), reverse=True)
         return img_list
 
     def sort_face_cnn(self):
         import_FaceLandmarksExtractor()
 
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
 
-        print ("Sorting by face-cnn similarity...")
+        print("Sorting by face-cnn similarity...")
 
         img_list = []
-        for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout):
+        for x in tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout):
             d = FaceLandmarksExtractor.extract(cv2.imread(x), 'cnn', True, input_is_predetected_face=True)
-            img_list.append( [x, np.array(d[0][1]) if len(d) > 0 else np.zeros ( (68,2) ) ] )
+            img_list.append([x, np.array(d[0][1]) if len(d) > 0 else np.zeros((68, 2))])
 
         img_list_len = len(img_list)
-        for i in tqdm ( range(0, img_list_len-1), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len - 1), desc="Sorting", file=sys.stdout):
             min_score = float("inf")
-            j_min_score = i+1
-            for j in range(i+1,len(img_list)):
-
+            j_min_score = i + 1
+            for j in range(i + 1, len(img_list)):
                 fl1 = img_list[i][1]
                 fl2 = img_list[j][1]
-                score = np.sum ( np.absolute ( (fl2 - fl1).flatten() ) )
+                score = np.sum(np.absolute((fl2 - fl1).flatten()))
 
                 if score < min_score:
                     min_score = score
                     j_min_score = j
-            img_list[i+1], img_list[j_min_score] = img_list[j_min_score], img_list[i+1]
+            img_list[i + 1], img_list[j_min_score] = img_list[j_min_score], img_list[i + 1]
 
         return img_list
 
     def sort_face_cnn_dissim(self):
         import_FaceLandmarksExtractor()
 
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
 
-        print ("Sorting by face-cnn dissimilarity...")
+        print("Sorting by face-cnn dissimilarity...")
 
         img_list = []
-        for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout):
+        for x in tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout):
             d = FaceLandmarksExtractor.extract(cv2.imread(x), 'cnn', True, input_is_predetected_face=True)
-            img_list.append( [x, np.array(d[0][1]) if len(d) > 0 else np.zeros ( (68,2) ), 0 ] )
+            img_list.append([x, np.array(d[0][1]) if len(d) > 0 else np.zeros((68, 2)), 0])
 
         img_list_len = len(img_list)
-        for i in tqdm( range(0, img_list_len-1), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len - 1), desc="Sorting", file=sys.stdout):
             score_total = 0
-            for j in range(i+1,len(img_list)):
+            for j in range(i + 1, len(img_list)):
                 if i == j:
                     continue
                 fl1 = img_list[i][1]
                 fl2 = img_list[j][1]
-                score_total += np.sum ( np.absolute ( (fl2 - fl1).flatten() ) )
+                score_total += np.sum(np.absolute((fl2 - fl1).flatten()))
 
             img_list[i][2] = score_total
 
-        print ("Sorting...")
+        print("Sorting...")
         img_list = sorted(img_list, key=operator.itemgetter(2), reverse=True)
 
         return img_list
-        
+
     def sort_face_yaw(self):
-        def calc_landmarks_face_pitch(fl): #unused
-            t = ( (fl[6][1]-fl[8][1]) + (fl[10][1]-fl[8][1]) ) / 2.0   
+        def calc_landmarks_face_pitch(fl):  # unused
+            t = ((fl[6][1] - fl[8][1]) + (fl[10][1] - fl[8][1])) / 2.0
             b = fl[8][1]
-            return b-t
+            return b - t
+
         def calc_landmarks_face_yaw(fl):
-            l = ( (fl[27][0]-fl[0][0]) + (fl[28][0]-fl[1][0]) + (fl[29][0]-fl[2][0]) ) / 3.0   
-            r = ( (fl[16][0]-fl[27][0]) + (fl[15][0]-fl[28][0]) + (fl[14][0]-fl[29][0]) ) / 3.0
-            return r-l
-            
+            l = ((fl[27][0] - fl[0][0]) + (fl[28][0] - fl[1][0]) + (fl[29][0] - fl[2][0])) / 3.0
+            r = ((fl[16][0] - fl[27][0]) + (fl[15][0] - fl[28][0]) + (fl[14][0] - fl[29][0])) / 3.0
+            return r - l
+
         import_FaceLandmarksExtractor()
-        input_dir = self.arguments.input_dir
-    
+        input_dir = self.args.input_dir
+
         img_list = []
-        for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout):
+        for x in tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout):
             d = FaceLandmarksExtractor.extract(cv2.imread(x), 'cnn', True, input_is_predetected_face=True)
-            img_list.append( [x, calc_landmarks_face_yaw(np.array(d[0][1])) ] )
+            img_list.append([x, calc_landmarks_face_yaw(np.array(d[0][1]))])
 
-        print ("Sorting...")
+        print("Sorting...")
         img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)
-        
+
         return img_list
-        
+
     def sort_hist(self):
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
 
-        print ("Sorting by histogram similarity...")
+        print("Sorting by histogram similarity...")
 
-        img_list = [ [x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256]) ] for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout) ]
+        img_list = [
+            [x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256])]
+            for x in
+            tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout)
+        ]
 
         img_list_len = len(img_list)
-        for i in tqdm( range(0, img_list_len-1), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len - 1), desc="Sorting",
+                      file=sys.stdout):
             min_score = float("inf")
-            j_min_score = i+1
-            for j in range(i+1,len(img_list)):
-                score = cv2.compareHist(img_list[i][1], img_list[j][1], cv2.HISTCMP_BHATTACHARYYA)
+            j_min_score = i + 1
+            for j in range(i + 1, len(img_list)):
+                score = cv2.compareHist(img_list[i][1],
+                                        img_list[j][1],
+                                        cv2.HISTCMP_BHATTACHARYYA)
                 if score < min_score:
                     min_score = score
                     j_min_score = j
-            img_list[i+1], img_list[j_min_score] = img_list[j_min_score], img_list[i+1]
+            img_list[i + 1], img_list[j_min_score] = img_list[j_min_score], img_list[i + 1]
 
         return img_list
 
     def sort_hist_dissim(self):
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
 
-        print ("Sorting by histogram dissimilarity...")
+        print("Sorting by histogram dissimilarity...")
 
-        img_list = [ [x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256]), 0] for x in tqdm( self.find_images(input_dir), desc="Loading", file=sys.stdout) ]
+        img_list = [
+            [x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256]), 0]
+            for x in
+            tqdm(self.find_images(input_dir), desc="Loading", file=sys.stdout)
+        ]
 
         img_list_len = len(img_list)
-        for i in tqdm ( range(0, img_list_len), desc="Sorting", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len), desc="Sorting", file=sys.stdout):
             score_total = 0
-            for j in range( 0, img_list_len):
+            for j in range(0, img_list_len):
                 if i == j:
                     continue
-                score_total += cv2.compareHist(img_list[i][1], img_list[j][1], cv2.HISTCMP_BHATTACHARYYA)
+                score_total += cv2.compareHist(img_list[i][1],
+                                               img_list[j][1],
+                                               cv2.HISTCMP_BHATTACHARYYA)
 
             img_list[i][2] = score_total
 
-
-        print ("Sorting...")
+        print("Sorting...")
         img_list = sorted(img_list, key=operator.itemgetter(2), reverse=True)
 
         return img_list
@@ -428,15 +475,15 @@ class SortProcessor(object):
     # Methods for grouping
     def group_blur(self, img_list):
         # Starting the binning process
-        num_bins = self.arguments.num_bins
+        num_bins = self.args.num_bins
 
         # The last bin will get all extra images if it's
         # not possible to distribute them evenly
         num_per_bin = len(img_list) // num_bins
         remainder = len(img_list) % num_bins
 
-        print ("Grouping by blur...")
-        bins = [ [] for _ in range(num_bins) ]
+        print("Grouping by blur...")
+        bins = [[] for _ in range(num_bins)]
         image_index = 0
         for i in range(num_bins):
             for j in range(num_per_bin):
@@ -450,7 +497,7 @@ class SortProcessor(object):
         return bins
 
     def group_face(self, img_list):
-        print ("Grouping by face similarity...")
+        print("Grouping by face similarity...")
 
         # Groups are of the form: group_num -> reference face
         reference_groups = dict()
@@ -462,7 +509,7 @@ class SortProcessor(object):
 
         # Comparison threshold used to decide how similar
         # faces have to be to be grouped together.
-        min_threshold = self.arguments.min_threshold
+        min_threshold = self.args.min_threshold
 
         img_list_len = len(img_list)
 
@@ -501,7 +548,7 @@ class SortProcessor(object):
         return bins
 
     def group_face_cnn(self, img_list):
-        print ("Grouping by face-cnn similarity...")
+        print("Grouping by face-cnn similarity...")
 
         # Groups are of the form: group_num -> reference faces
         reference_groups = dict()
@@ -514,11 +561,11 @@ class SortProcessor(object):
         # faces have to be to be grouped together.
         # It is multiplied by 1000 here to allow the cli option to use smaller
         # numbers.
-        min_threshold = self.arguments.min_threshold * 1000
+        min_threshold = self.args.min_threshold * 1000
 
         img_list_len = len(img_list)
 
-        for i in tqdm ( range(0, img_list_len - 1), desc="Grouping", file=sys.stdout):
+        for i in tqdm(range(0, img_list_len - 1), desc="Grouping", file=sys.stdout):
             fl1 = img_list[i][1]
 
             current_best = [-1, float("inf")]
@@ -543,7 +590,7 @@ class SortProcessor(object):
         return bins
 
     def group_hist(self, img_list):
-        print ("Grouping by histogram...")
+        print("Grouping by histogram...")
 
         # Groups are of the form: group_num -> reference histogram
         reference_groups = dict()
@@ -552,7 +599,7 @@ class SortProcessor(object):
         # an array containing the file paths to the images in that group
         bins = []
 
-        min_threshold = self.arguments.min_threshold
+        min_threshold = self.args.min_threshold
 
         img_list_len = len(img_list)
         reference_groups[0] = [img_list[0][1]]
@@ -576,70 +623,78 @@ class SortProcessor(object):
 
     # Final process methods
     def final_process_rename(self, img_list):
-        output_dir = self.arguments.output_dir
+        output_dir = self.args.output_dir
 
-        process_file = self.set_process_file_method(self.arguments.log_changes, self.arguments.keep_original)
+        process_file = self.set_process_file_method(self.args.log_changes,
+                                                    self.args.keep_original)
 
         # Make sure output directory exists
-        if not os.path.exists (output_dir):
-            os.makedirs (output_dir)
+        if not os.path.exists(output_dir):
+            os.makedirs(output_dir)
 
-        description = ("Copying and Renaming" if self.arguments.keep_original else "Moving and Renaming")
+        description = (
+            "Copying and Renaming" if self.args.keep_original
+            else "Moving and Renaming"
+        )
 
         for i in tqdm(range(0, len(img_list)), desc=description, leave=False, file=sys.stdout):
             src = img_list[i][0]
             src_basename = os.path.basename(src)
 
-            dst = os.path.join (output_dir, '%.5d_%s' % (i, src_basename ) )
+            dst = os.path.join(output_dir, '{:05d}_{}'.format(i, src_basename))
             try:
-                process_file (src, dst, self.changes)
+                process_file(src, dst, self.changes)
             except FileNotFoundError as e:
                 print(e)
-                print ('fail to rename %s' % (src) )
+                print('fail to rename {}'.format(src))
 
-        for i in tqdm( range(0,len(img_list)) , desc=description, file=sys.stdout):
-            renaming = self.set_renaming_method(self.arguments.log_changes)
+        for i in tqdm(range(0, len(img_list)), desc=description, file=sys.stdout):
+            renaming = self.set_renaming_method(self.args.log_changes)
             src, dst = renaming(img_list[i][0], output_dir, i, self.changes)
 
             try:
-                os.rename (src, dst)
+                os.rename(src, dst)
             except FileNotFoundError as e:
                 print(e)
-                print ('fail to rename %s' % (src) )
+                print('fail to rename {}'.format(src))
 
-        if self.arguments.log_changes:
-            self.write_to_log(self.arguments.log_file, self.changes)
+        if self.args.log_changes:
+            self.write_to_log(self.args.log_file_path, self.changes)
 
     def final_process_group(self, bins):
-        output_dir = self.arguments.output_dir
+        output_dir = self.args.output_dir
 
-        process_file = self.set_process_file_method(self.arguments.log_changes, self.arguments.keep_original)
+        process_file = self.set_process_file_method(self.args.log_changes,
+                                                    self.args.keep_original)
 
         # First create new directories to avoid checking
         # for directory existence in the moving loop
-        print ("Creating group directories.")
+        print("Creating group directories.")
         for i in range(len(bins)):
-            directory = os.path.join (output_dir, str(i))
-            if not os.path.exists (directory):
-                os.makedirs (directory)
+            directory = os.path.join(output_dir, str(i))
+            if not os.path.exists(directory):
+                os.makedirs(directory)
 
-        description = ("Copying into Groups" if self.arguments.keep_original else "Moving into Groups")
+        description = (
+            "Copying into Groups" if self.args.keep_original
+            else "Moving into Groups"
+        )
 
-        print ("Total groups found: {}".format(len(bins)))
+        print("Total groups found: {}".format(len(bins)))
         for i in tqdm(range(len(bins)), desc=description, file=sys.stdout):
             for j in range(len(bins[i])):
                 src = bins[i][j]
-                src_basename = os.path.basename (src)
+                src_basename = os.path.basename(src)
 
-                dst = os.path.join (output_dir, str(i), src_basename)
+                dst = os.path.join(output_dir, str(i), src_basename)
                 try:
-                    process_file (src, dst, self.changes)
+                    process_file(src, dst, self.changes)
                 except FileNotFoundError as e:
-                    print (e)
-                    print ('Failed to move {0} to {1}'.format(src, dst))
+                    print(e)
+                    print('Failed to move {0} to {1}'.format(src, dst))
 
-        if self.arguments.log_changes:
-            self.write_to_log(self.arguments.log_file, self.changes)
+        if self.args.log_changes:
+            self.write_to_log(self.args.log_file_path, self.changes)
 
     # Various helper methods
     def reload_images(self, group_method, img_list):
@@ -654,20 +709,29 @@ class SortProcessor(object):
         """
         import_face_recognition()
 
-        input_dir = self.arguments.input_dir
+        input_dir = self.args.input_dir
         print("Preparing to group...")
         if group_method == 'group_blur':
-            temp_list = [[x, self.estimate_blur(cv2.imread(x))] for x in tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)]
+            temp_list = [[x, self.estimate_blur(cv2.imread(x))]
+                         for x in
+                         tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)]
         elif group_method == 'group_face':
-            temp_list = [[x, face_recognition.face_encodings(cv2.imread(x))] for x in tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)]
+            temp_list = [[x, face_recognition.face_encodings(cv2.imread(x))]
+                         for x in
+                         tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)]
         elif group_method == 'group_face_cnn':
             import_FaceLandmarksExtractor()
             temp_list = []
             for x in tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout):
-                d = FaceLandmarksExtractor.extract(cv2.imread(x), 'cnn', True, input_is_predetected_face=True)
+                d = FaceLandmarksExtractor.extract(cv2.imread(x), 'cnn', True,
+                                                   input_is_predetected_face=True)
                 temp_list.append([x, np.array(d[0][1]) if len(d) > 0 else np.zeros((68, 2))])
         elif group_method == 'group_hist':
-            temp_list = [[x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256])] for x in tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)]
+            temp_list = [
+                [x, cv2.calcHist([cv2.imread(x)], [0], None, [256], [0, 256])]
+                for x in
+                tqdm(self.find_images(input_dir), desc="Reloading", file=sys.stdout)
+            ]
         else:
             raise ValueError("{} group_method not found.".format(group_method))
 
@@ -706,7 +770,7 @@ class SortProcessor(object):
         for root, dirs, files in os.walk(input_dir):
             for file in files:
                 if os.path.splitext(file)[1].lower() in extensions:
-                    result.append (os.path.join(root, file))
+                    result.append(os.path.join(root, file))
         return result
 
     @staticmethod
@@ -718,11 +782,6 @@ class SortProcessor(object):
         score = np.var(blur_map)
         return score
 
-    @staticmethod
-    def set_process_method(prefix, method):
-        _method = re.sub(r'-', r'_', method)
-        return prefix + "_" + _method
-
     @staticmethod
     def set_process_file_method(log_changes, keep_original):
         """
@@ -737,20 +796,24 @@ class SortProcessor(object):
                 def process_file(src, dst, changes):
                     copyfile(src, dst)
                     changes[src] = dst
+
                 return process_file
             else:
                 def process_file(src, dst, changes):
                     os.rename(src, dst)
                     changes[src] = dst
+
                 return process_file
         else:
             if keep_original:
                 def process_file(src, dst, changes):
                     copyfile(src, dst)
+
                 return process_file
             else:
                 def process_file(src, dst, changes):
                     os.rename(src, dst)
+
                 return process_file
 
     @staticmethod
@@ -759,19 +822,21 @@ class SortProcessor(object):
             def renaming(src, output_dir, i, changes):
                 src_basename = os.path.basename(src)
 
-                __src = os.path.join (output_dir, '%.5d_%s' % (i, src_basename) )
-                dst = os.path.join (output_dir, '%.5d%s' % (i, os.path.splitext(src_basename)[1] ) )
+                __src = os.path.join(output_dir, '{:05d}_{}'.format(i, src_basename))
+                dst = os.path.join(output_dir, '{:05d}{}'.format(i, os.path.splitext(src_basename)[1]))
                 changes[src] = dst
                 return __src, dst
+
             return renaming
 
         else:
             def renaming(src, output_dir, i, changes):
                 src_basename = os.path.basename(src)
 
-                src = os.path.join (output_dir, '%.5d_%s' % (i, src_basename) )
-                dst = os.path.join (output_dir, '%.5d%s' % (i, os.path.splitext(src_basename)[1] ) )
+                src = os.path.join(output_dir, '{:05d}_{}'.format(i, src_basename))
+                dst = os.path.join(output_dir, '{:05d}{}'.format(i, os.path.splitext(src_basename)[1]))
                 return src, dst
+
             return renaming
 
     @staticmethod
@@ -780,7 +845,7 @@ class SortProcessor(object):
         for img2 in references:
             score = cv2.compareHist(img1, img2, cv2.HISTCMP_BHATTACHARYYA)
             scores.append(score)
-        return sum(scores)/len(scores)
+        return sum(scores) / len(scores)
 
     @staticmethod
     def get_avg_score_faces(f1encs, references):
@@ -789,19 +854,19 @@ class SortProcessor(object):
         for f2encs in references:
             score = face_recognition.face_distance(f1encs, f2encs)[0]
             scores.append(score)
-        return sum(scores)/len(scores)
+        return sum(scores) / len(scores)
 
     @staticmethod
     def get_avg_score_faces_cnn(fl1, references):
         scores = []
         for fl2 in references:
-            score = np.sum ( np.absolute ( (fl2 - fl1).flatten() ) )
+            score = np.sum(np.absolute((fl2 - fl1).flatten()))
             scores.append(score)
-        return sum(scores)/len(scores)
+        return sum(scores) / len(scores)
 
     @staticmethod
-    def write_to_log(log_file, changes):
-        with open(log_file, 'w') as lf:
+    def write_to_log(log_file_path, changes):
+        with open(log_file_path, 'w') as lf:
             json.dump(changes, lf, sort_keys=True, indent=4)
 
 
@@ -814,9 +879,9 @@ if __name__ == "__main__":
     __warning_string = "Important: face-cnn method will cause an error when "
     __warning_string += "this tool is called directly instead of through the "
     __warning_string += "tools.py command script."
-    print (__warning_string)
-    print ("Images sort tool.\n")
-    
+    print(__warning_string)
+    print("Images sort tool.\n")
+
     parser = argparse.ArgumentParser()
     subparser = parser.add_subparsers()
     sort = SortProcessor(

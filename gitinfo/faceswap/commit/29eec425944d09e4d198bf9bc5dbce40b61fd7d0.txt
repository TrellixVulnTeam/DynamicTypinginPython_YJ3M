commit 29eec425944d09e4d198bf9bc5dbce40b61fd7d0
Author: Gareth Dunstone <freedom.2.the.leetle.people@gmail.com>
Date:   Fri Feb 9 02:44:31 2018 +1100

    Added serializers.
    
    This speeds up convert speed x4 on my machine.

diff --git a/lib/Serializer.py b/lib/Serializer.py
new file mode 100644
index 0000000..aafef80
--- /dev/null
+++ b/lib/Serializer.py
@@ -0,0 +1,83 @@
+import json, pickle
+class Serializer(object):
+    ext = "wtf"
+    woptions = "????"
+    roptions = "????"
+
+    @classmethod
+    def marshal(cls, input_data):
+        raise NotImplementedError()
+
+    @classmethod
+    def unmarshal(cls, input_string):
+        raise NotImplementedError()
+
+
+class YAMLSerializer(Serializer):
+    ext = "yml"
+    woptions = "w"
+    roptions = "r"
+
+    @classmethod
+    def marshal(cls, input_data):
+        try:
+            import yaml
+        except ImportError:
+            print("You must have PyYAML installed to use YAMLSerializer")
+        return yaml.dump(input_data, default_flow_style=False)
+
+    @classmethod
+    def unmarshal(cls, input_string):
+        try:
+            import yaml
+        except ImportError:
+            print("You must have PyYAML installed to use YAMLSerializer")
+        return yaml.load(input_string)
+
+
+
+class JSONSerializer(Serializer):
+    ext = "json"
+    woptions = "w"
+    roptions = "r"
+
+    @classmethod
+    def marshal(cls, input_data):
+        return json.dumps(input_data, indent=2)
+
+    @classmethod
+    def unmarshal(cls, input_string):
+        return json.loads(input_string)
+
+
+class PickleSerializer(Serializer):
+    ext = "p"
+    woptions = "wb"
+    roptions = "rb"
+
+    @classmethod
+    def marshal(cls, input_data):
+        return pickle.dumps(input_data)
+
+    @classmethod
+    def unmarshal(cls, input_bytes):
+        return pickle.loads(input_bytes)
+
+def get_serializer(serializer):
+    if serializer == "yaml":
+        return YAMLSerializer
+    if serializer == "json":
+        return JSONSerializer
+    if serializer == "pickle":
+        return PickleSerializer
+    raise NotImplementedError()
+
+
+def get_serializer_fromext(ext):
+    if ext in (".yaml", ".yml"):
+        return YAMLSerializer
+    if ext == ".json":
+        return JSONSerializer
+    if ext == ".p":
+        return PickleSerializer
+    raise NotImplementedError("No serializer matching that file type.")
diff --git a/lib/cli.py b/lib/cli.py
index 2cfe23f..40de8d5 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -4,8 +4,9 @@ import time
 
 from pathlib import Path
 from lib.FaceFilter import FaceFilter
-from lib.faces_detect import detect_faces
+from lib.faces_detect import detect_faces, DetectedFace
 from lib.utils import get_image_paths, get_folder
+from lib import Serializer
 
 class FullPaths(argparse.Action):
     """Expand user- and relative-paths"""
@@ -26,17 +27,28 @@ class DirectoryProcessor(object):
     output_dir = None
 
     images_found = 0
-    faces_detected = 0
+    num_faces_detected = 0
+    faces_detected = dict()
     verify_output = False
 
     def __init__(self, subparser, command, description='default'):
         self.create_parser(subparser, command, description)
         self.parse_arguments(description, subparser, command)
 
+
     def process_arguments(self, arguments):
         self.arguments = arguments
         print("Input Directory: {}".format(self.arguments.input_dir))
         print("Output Directory: {}".format(self.arguments.output_dir))
+        self.serializer = None
+        if self.arguments.serializer is None and self.arguments.alignments_path is not None:
+            ext = os.path.splitext(self.arguments.alignments_path)[-1]
+            self.serializer = Serializer.get_serializer_fromext(ext)
+            print(self.serializer, self.arguments.alignments_path)
+        else:
+            self.serializer = Serializer.get_serializer(self.arguments.serializer or "json")
+        print("Using {} serializer".format(self.serializer.ext))
+
         print('Starting, this may take a while...')
 
         self.output_dir = get_folder(self.arguments.output_dir)
@@ -49,27 +61,76 @@ class DirectoryProcessor(object):
         self.filter = self.load_filter()
         self.process()
         self.finalize()
-        
+
+    def read_alignments(self):
+
+        fn = os.path.join(self.arguments.input_dir,"alignments.{}".format(self.serializer.ext))
+        if self.arguments.alignments_path is not None:
+            fn = self.arguments.alignments_path
+
+        try:
+            print("Reading alignments from: {}".format(fn))
+            with open(fn, self.serializer.roptions) as f:
+                self.faces_detected = self.serializer.unmarshal(f.read())
+        except Exception as e:
+            print("{} not read!".format(fn))
+            print(str(e))
+            self.faces_detected = dict()
+
+    def write_alignments(self):
+
+        fn = os.path.join(self.output_dir,"alignments.{}".format(self.serializer.ext))
+        if self.arguments.alignments_path is not None:
+            fn = self.arguments.alignments_path
+        try:
+            print("Writing alignments to: {}".format(fn))
+            with open(fn, self.serializer.woptions) as fh:
+                fh.write(self.serializer.marshal(self.faces_detected))
+        except Exception as e:
+            print("{} not written!".format(fn))
+            print(str(e))
+            self.faces_detected = dict()
+
     def read_directory(self):
         self.images_found = len(self.input_dir)
         return self.input_dir
-    
-    def get_faces(self, image):
+
+    def have_face(self, filename):
+        return filename in self.faces_detected
+
+    def get_faces_alignments(self, filename):
         faces_count = 0
-        for face in detect_faces(image, self.arguments.detector):
+        faces = self.faces_detected[filename]
+        for rawface in faces:
+            face = DetectedFace(**rawface)
             if self.filter is not None and not self.filter.check(face):
                 print('Skipping not recognized face!')
                 continue
 
             yield faces_count, face
+            self.num_faces_detected += 1
+            faces_count += 1
+        if faces_count > 1 and self.arguments.verbose:
+            print('Note: Found more than one face in an image!')
+            self.verify_output = True
+
+    def get_faces(self, image):
+        faces_count = 0
+        faces = detect_faces(image, self.arguments.detector)
+
+        for face in faces:
+            if self.filter is not None and not self.filter.check(face):
+                print('Skipping not recognized face!')
+                continue
+            yield faces_count, face
 
-            self.faces_detected = self.faces_detected + 1
+            self.num_faces_detected += 1
             faces_count += 1
-        
+
         if faces_count > 1 and self.arguments.verbose:
             print('Note: Found more than one face in an image!')
             self.verify_output = True
-    
+
     def load_filter(self):
         filter_file = self.arguments.filter
         if Path(filter_file).exists():
@@ -94,6 +155,18 @@ class DirectoryProcessor(object):
                             default="output",
                             help="Output directory. This is where the converted files will \
                                 be stored. Defaults to 'output'")
+
+        self.parser.add_argument('--serializer',
+                                type=str.lower,
+                                dest="serializer",
+                                choices=("yaml", "json", "pickle"),
+                                help="serializer for alignments file")
+
+        self.parser.add_argument('--alignments',
+                                type=str,
+                                dest="alignments_path",
+                                help="optional path to alignments file.")
+
         self.parser.add_argument('-v', '--verbose',
                             action="store_true",
                             dest="verbose",
@@ -118,7 +191,7 @@ class DirectoryProcessor(object):
     def finalize(self):
         print('-------------------------')
         print('Images found:        {}'.format(self.images_found))
-        print('Faces detected:      {}'.format(self.faces_detected))
+        print('Faces detected:      {}'.format(self.num_faces_detected))
         print('-------------------------')
 
         if self.verify_output:
diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index 0960ed0..365f686 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -22,13 +22,17 @@ def _css_to_rect(css):
 # end of Copy/Paste
 
 class DetectedFace(object):
-    def __init__(self, image, x, w, y, h, landmarks):
+    def __init__(self, image=None, x=None, w=None, y=None, h=None, landmarks=None, landmarksXY=None):
         self.image = image
         self.x = x
         self.w = w
         self.y = y
         self.h = h
         self.landmarks = landmarks
-    
+        self.landmarksXY = landmarksXY
+
     def landmarksAsXY(self):
-        return [(p.x, p.y) for p in self.landmarks.parts()]
+        if self.landmarksXY:
+            return self.landmarksXY
+        self.landmarksXY = [(p.x, p.y) for p in self.landmarks.parts()]
+        return self.landmarksXY
diff --git a/scripts/convert.py b/scripts/convert.py
index f38d129..0e18d35 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -33,7 +33,7 @@ class ConvertImage(DirectoryProcessor):
                             choices=("Original", "LowMem", "GAN"), # case sensitive because this is used to load a plug-in.
                             default="Original",
                             help="Select the trainer that was used to create the model.")
-                            
+
         parser.add_argument('-s', '--swap-model',
                             action="store_true",
                             dest="swap_model",
@@ -110,14 +110,14 @@ class ConvertImage(DirectoryProcessor):
                             default=True,
                             help="Average color adjust. (Adjust converter only)")
         return parser
-    
+
     def process(self):
         # Original & LowMem models go with Adjust or Masked converter
         # GAN converter & model must go together
         # Note: GAN prediction outputs a mask + an image, while other predicts only an image
         model_name = self.arguments.trainer
         conv_name = self.arguments.converter
-        
+
         if conv_name.startswith("GAN"):
             assert model_name.startswith("GAN") is True, "GAN converter can only be used with GAN model!"
         else:
@@ -141,13 +141,13 @@ class ConvertImage(DirectoryProcessor):
 
         # frame ranges stuff...
         self.frame_ranges = None
-        
+
         # split out the frame ranges and parse out "min" and "max" values
         minmax = {
             "min": 0, # never any frames less than 0
             "max": float("inf")
         }
-        
+
         if self.arguments.frame_ranges:
             self.frame_ranges = [tuple(map(lambda q: minmax[q] if q in minmax.keys() else int(q), v.split("-"))) for v in self.arguments.frame_ranges]
 
@@ -156,7 +156,7 @@ class ConvertImage(DirectoryProcessor):
 
         for item in batch.iterator():
             self.convert(converter, item)
-    
+
     def check_skipframe(self, filename):
         try:
             idx = int(self.imageidxre.findall(filename)[0])
@@ -171,17 +171,23 @@ class ConvertImage(DirectoryProcessor):
             skip = self.check_skipframe(filename)
             if self.arguments.discard_frames and skip:
                 return
-            
+
             if not skip: # process as normal
                 for idx, face in faces:
                     image = converter.patch_image(image, face)
-            
+
             output_file = get_folder(self.output_dir) / Path(filename).name
             cv2.imwrite(str(output_file), image)
         except Exception as e:
             print('Failed to convert image: {}. Reason: {}'.format(filename, e))
 
     def prepare_images(self):
+        self.read_alignments()
         for filename in tqdm(self.read_directory()):
             image = cv2.imread(filename)
-            yield filename, image, self.get_faces(image)
+
+            if self.have_face(filename):
+                faces = self.get_faces_alignments(filename)
+            else:
+                faces = self.get_faces(image)
+            yield filename, image, faces
diff --git a/scripts/extract.py b/scripts/extract.py
index de56f0a..8f7fd39 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -41,33 +41,46 @@ class ExtractTrainingData(DirectoryProcessor):
     def process(self):
         extractor_name = "Align" # TODO Pass as argument
         self.extractor = PluginLoader.get_extractor(extractor_name)()
-        self.faces_detected = 0
         processes = self.arguments.processes
-        if processes != 1:
-            files = list(self.read_directory())
-            for _ in tqdm(pool_process(self.processFiles, files, processes=processes), total = len(files)):
-                self.faces_detected +=1
-        else:
-            try:
-                for filename in tqdm(self.read_directory()):
-                    self.handleImage(filename)
-
-            except Exception as e:
-                print('Failed to extract from image: {}. Reason: {}'.format(filename, e))
+        try:
+            if processes != 1:
+                files = list(self.read_directory())
+                for fn, faces in tqdm(pool_process(self.processFiles, files, processes=processes), total = len(files)):
+                    self.num_faces_detected += 1
+                    self.faces_detected[fn] = faces
+            else:
+                try:
+                    for filename in tqdm(self.read_directory()):
+                         self.faces_detected[filename] = self.handleImage(filename)[1]
+                except Exception as e:
+                    print('Failed to extract from image: {}. Reason: {}'.format(filename, e))
+        finally:
+            self.write_alignments()
 
     def processFiles(self, filename):
         try:
             return self.handleImage(filename)
         except Exception as e:
             print('Failed to extract from image: {}. Reason: {}'.format(filename, e))
-    
+
     def handleImage(self, filename):
         count = 0
+
         image = cv2.imread(filename)
-        for idx, face in self.get_faces(image):
+        faces = self.get_faces(image)
+        rvals = []
+        for idx, face in faces:
             count = idx
+
             resized_image = self.extractor.extract(image, face, 256)
             output_file = get_folder(self.output_dir) / Path(filename).stem
             cv2.imwrite(str(output_file) + str(idx) + Path(filename).suffix, resized_image)
-        return count + 1
-
+            f = {
+                "x": face.x,
+                "w": face.w,
+                "y": face.y,
+                "h": face.h,
+                "landmarksXY": face.landmarksAsXY()
+            }
+            rvals.append(f)
+        return filename, rvals

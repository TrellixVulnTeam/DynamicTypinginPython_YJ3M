commit 3978ab3cb5e351e3daa42e8ba8edf6f545a34c98
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Thu Dec 6 00:53:29 2018 +0000

    Rotating File Handler permissions fix for Windows

diff --git a/lib/logger.py b/lib/logger.py
index 16e9b25..6cd898b 100644
--- a/lib/logger.py
+++ b/lib/logger.py
@@ -14,13 +14,85 @@ from time import sleep
 from lib.queue_manager import queue_manager
 from lib.sysinfo import sysinfo
 
+# ### << START: ROTATING FILE HANDLER - WINDOWS PERMISSION FIX >> ###
+# This works around file locking issue on Windows specifically in the case of
+# long lived child processes.
+#
+# Python opens files with inheritable handle and without file sharing by
+# default. This causes the RotatingFileHandler file handle to be duplicated in
+# the subprocesses even if the log file is not used in it. Because of this
+# handle in the child process, when the RotatingFileHandler tries to os.rename()
+# the file in the parent process, it fails with:
+#     WindowsError: [Error 32] The process cannot access the file because
+#     it is being used by another process
+# Taken from: https://github.com/luci/client-py/blob/master/utils/logging_utils.py
+# # Copyright 2015 The LUCI Authors. All rights reserved.
+# Use of this source code is governed under the Apache License, Version 2.0
+
+
+if sys.platform == "win32":
+    import codecs
+    import ctypes
+    import msvcrt  # pylint: disable=F0401
+    import _subprocess  # noqa pylint: disable=F0401,W0611
+
+    FILE_ATTRIBUTE_NORMAL = 0x00000080
+    FILE_SHARE_READ = 1
+    FILE_SHARE_WRITE = 2
+    FILE_SHARE_DELETE = 4
+    GENERIC_READ = 0x80000000
+    GENERIC_WRITE = 0x40000000
+    OPEN_ALWAYS = 4
+
+    def shared_open(path):
+        """Opens a file with full sharing mode and without inheritance.
+
+        The file is open for both read and write.
+
+        See https://bugs.python.org/issue15244 for inspiration.
+        """
+        path = str(path)
+        handle = ctypes.windll.kernel32.CreateFileW(
+            path,
+            GENERIC_READ | GENERIC_WRITE,
+            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+            None,
+            OPEN_ALWAYS,
+            FILE_ATTRIBUTE_NORMAL,
+            None)
+        ctr_handle = msvcrt.open_osfhandle(
+            handle,
+            os.O_BINARY | os.O_NOINHERIT)  # pylint: disable=no-member
+        return os.fdopen(ctr_handle, "r+b")
+
+    class NoInheritRotatingFileHandler(RotatingFileHandler):
+        """ Overide Rotating FileHandler for Windows """
+        def _open(self):
+            """Opens the log file without handle inheritance but with file sharing.
+
+            Ignores self.mode.
+            """
+            winf = shared_open(self.baseFilename)
+            if self.encoding:
+                # Do the equivalent of
+                # codecs.open(self.baseFilename, self.mode, self.encoding)
+                info = codecs.lookup(self.encoding)
+                winf = codecs.StreamReaderWriter(
+                    winf, info.streamreader, info.streamwriter, "replace")
+                winf.encoding = self.encoding
+            return winf
+else:  # Not Windows.
+    NoInheritRotatingFileHandler = RotatingFileHandler
+# ### << END: ROTATING FILE HANDLER - WINDOWS PERMISSION FIX >> ###
+
+
 LOG_QUEUE = queue_manager._log_queue  # pylint: disable=protected-access
 
 
 class MultiProcessingLogger(logging.Logger):
     """ Create custom logger  with custom levels """
     def __init__(self, name):
-        for new_level in (('VERBOSE', 15), ('TRACE', 5)):
+        for new_level in (("VERBOSE", 15), ("TRACE", 5)):
             level_name, level_num = new_level
             if hasattr(logging, level_name):
                 continue
@@ -83,14 +155,14 @@ def log_setup(loglevel):
     q_listener = QueueListener(LOG_QUEUE, f_handler, s_handler, c_handler,
                                respect_handler_level=True)
     q_listener.start()
-    logging.info('Log level set to: %s', loglevel.upper())
+    logging.info("Log level set to: %s", loglevel.upper())
 
 
 def file_handler(loglevel, log_format):
     """ Add a logging rotating file handler """
     filename = os.path.join(os.path.dirname(os.path.realpath(sys.argv[0])), "faceswap.log")
     should_rotate = os.path.isfile(filename)
-    log_file = RotatingFileHandler(filename, backupCount=1)
+    log_file = NoInheritRotatingFileHandler(filename, backupCount=1)
     if should_rotate:
         log_file.doRollover()
     log_file.setFormatter(log_format)
@@ -121,10 +193,10 @@ def crash_handler(log_format):
 
 
 def get_loglevel(loglevel):
-    ''' Check valid log level supplied and return numeric log level '''
+    """ Check valid log level supplied and return numeric log level """
     numeric_level = getattr(logging, loglevel.upper(), None)
     if not isinstance(numeric_level, int):
-        raise ValueError('Invalid log level: %s' % loglevel)
+        raise ValueError("Invalid log level: %s" % loglevel)
 
     return numeric_level
 
@@ -132,7 +204,7 @@ def get_loglevel(loglevel):
 def crash_log():
     """ Write debug_buffer to a crash log on crash """
     path = os.getcwd()
-    filename = os.path.join(path, datetime.now().strftime('crash_report.%Y.%m.%d.%H%M%S%f.log'))
+    filename = os.path.join(path, datetime.now().strftime("crash_report.%Y.%m.%d.%H%M%S%f.log"))
 
     # Wait until all log items have been processed
     while not LOG_QUEUE.empty():

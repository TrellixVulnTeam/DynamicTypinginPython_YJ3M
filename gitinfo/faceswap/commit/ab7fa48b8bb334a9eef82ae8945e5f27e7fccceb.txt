commit ab7fa48b8bb334a9eef82ae8945e5f27e7fccceb
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Tue May 7 10:01:00 2019 +0000

    Remove dlib.rectangles. Replace with BoundingBox class

diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index 80493a4..fe8f090 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -4,7 +4,6 @@ import logging
 
 import numpy as np
 
-from dlib import rectangle as d_rectangle  # pylint: disable=no-name-in-module
 from lib.aligner import Extract as AlignerExtract, get_align_mat, get_matrix_scaling
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -39,28 +38,28 @@ class DetectedFace():
         """ Landmarks as XY """
         return self.landmarksXY
 
-    def to_dlib_rect(self):
-        """ Return Bounding Box as Dlib Rectangle """
+    def to_bounding_box(self):
+        """ Return Bounding Box as BoundingBox """
         left = self.x
         top = self.y
         right = self.x + self.w
         bottom = self.y + self.h
-        retval = d_rectangle(left, top, right, bottom)
+        retval = BoundingBox(left, top, right, bottom)
         logger.trace("Returning: %s", retval)
         return retval
 
-    def from_dlib_rect(self, d_rect, image=None):
-        """ Set Bounding Box from a Dlib Rectangle """
-        logger.trace("Creating from dlib_rectangle: %s", d_rect)
-        if not isinstance(d_rect, d_rectangle):
-            raise ValueError("Supplied Bounding Box is not a dlib.rectangle.")
-        self.x = d_rect.left()
-        self.w = d_rect.right() - d_rect.left()
-        self.y = d_rect.top()
-        self.h = d_rect.bottom() - d_rect.top()
+    def from_bounding_box(self, bounding_box, image=None):
+        """ Set Bounding Box from a BoundingBox """
+        logger.trace("Creating from BoundingBox: %s", bounding_box)
+        if not isinstance(bounding_box, BoundingBox):
+            raise ValueError("Supplied Bounding Box is not a BoundingBox.")
+        self.x = bounding_box.left
+        self.w = bounding_box.width
+        self.y = bounding_box.top
+        self.h = bounding_box.height
         if image is not None and image.any():
             self.image_to_face(image)
-        logger.trace("Created from dlib_rectangle: (x: %s, w: %s, y: %s. h: %s)",
+        logger.trace("Created from BoundingBox: (x: %s, w: %s, y: %s. h: %s)",
                      self.x, self.w, self.y, self.h)
 
     def image_to_face(self, image):
@@ -263,3 +262,42 @@ class DetectedFace():
     def reference_interpolators(self):
         """ Return the interpolators for an output face """
         return get_matrix_scaling(self.reference_matrix)
+
+
+class BoundingBox():
+    """ Bounding box class """
+    def __init__(self, left, top, right, bottom):
+        logger.trace("Initializing %s: (left: %s, top: %s, right: %s, bottom: %s)",
+                     self.__class__.__name__, left, top, right, bottom)
+        self._box = (left, top, right, bottom)
+        logger.trace("Initialized %s", self.__class__.__name__)
+
+    @property
+    def left(self):
+        """ Return left point as int """
+        return int(round(self._box[0]))
+
+    @property
+    def top(self):
+        """ Return top point as int """
+        return int(round(self._box[1]))
+
+    @property
+    def right(self):
+        """ Return right point as int """
+        return int(round(self._box[2]))
+
+    @property
+    def bottom(self):
+        """ Return bottom point as int """
+        return int(round(self._box[3]))
+
+    @property
+    def width(self):
+        """ Return width of bounding box """
+        return self.right - self.left
+
+    @property
+    def height(self):
+        """ Return height of bounding box """
+        return self.bottom - self.top
diff --git a/lib/utils.py b/lib/utils.py
index 91662e5..b22414a 100644
--- a/lib/utils.py
+++ b/lib/utils.py
@@ -14,11 +14,10 @@ from re import finditer
 
 import cv2
 import numpy as np
-import dlib
 
 from tqdm import tqdm
 
-from lib.faces_detect import DetectedFace
+from lib.faces_detect import BoundingBox, DetectedFace
 from lib.logger import get_loglevel
 
 
@@ -120,7 +119,7 @@ def rotate_landmarks(face, rotation_matrix):
     # pylint: disable=c-extension-no-member
     """ Rotate the landmarks and bounding box for faces
         found in rotated images.
-        Pass in a DetectedFace object, Alignments dict or DLib rectangle"""
+        Pass in a DetectedFace object, Alignments dict or BoundingBox"""
     logger.trace("Rotating landmarks: (rotation_matrix: %s, type(face): %s",
                  rotation_matrix, type(face))
     if isinstance(face, DetectedFace):
@@ -140,12 +139,11 @@ def rotate_landmarks(face, rotation_matrix):
                          face.get("y", 0) + face.get("h", 0)]]
         landmarks = face.get("landmarksXY", list())
 
-    elif isinstance(face,
-                    dlib.rectangle):  # pylint: disable=c-extension-no-member
-        bounding_box = [[face.left(), face.top()],
-                        [face.right(), face.top()],
-                        [face.right(), face.bottom()],
-                        [face.left(), face.bottom()]]
+    elif isinstance(face, BoundingBox):
+        bounding_box = [[face.left, face.top],
+                        [face.right, face.top],
+                        [face.right, face.bottom],
+                        [face.left, face.bottom]]
         landmarks = list()
     else:
         raise ValueError("Unsupported face type")
@@ -190,8 +188,7 @@ def rotate_landmarks(face, rotation_matrix):
             rotated_landmarks = [tuple(point) for point in rotated[1].tolist()]
             face["landmarksXY"] = rotated_landmarks
     else:
-        rotated_landmarks = dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(pt_x), int(pt_y), int(pt_x1), int(pt_y1))
+        rotated_landmarks = BoundingBox(pt_x, pt_y, pt_x1, pt_y1)
         face = rotated_landmarks
 
     logger.trace("Rotated landmarks: %s", rotated_landmarks)
diff --git a/plugins/extract/align/_base.py b/plugins/extract/align/_base.py
index 30c90d0..713c915 100644
--- a/plugins/extract/align/_base.py
+++ b/plugins/extract/align/_base.py
@@ -8,12 +8,12 @@
     The plugin will receive a dict containing:
     {"filename": <filename of source frame>,
      "image": <source image>,
-     "detected_faces": <list of DlibRectangles>}
+     "detected_faces": <list of BoundingBoxes>}
 
     For each source item, the plugin must pass a dict to finalize containing:
     {"filename": <filename of source frame>,
      "image": <source image>,
-     "detected_faces": <list of dlibRectangles>,
+     "detected_faces": <list of BoundingBoxes>, (Class defined in /lib/faces_detect)
      "landmarks": <list of landmarks>}
     """
 
diff --git a/plugins/extract/align/cv2_dnn.py b/plugins/extract/align/cv2_dnn.py
index 4361352..2498744 100644
--- a/plugins/extract/align/cv2_dnn.py
+++ b/plugins/extract/align/cv2_dnn.py
@@ -59,9 +59,8 @@ class Align(Aligner):
         """ Align the incoming image for prediction """
         logger.trace("Aligning image around center")
 
-        box = (detected_face.left(), detected_face.top(),
-               detected_face.right(), detected_face.bottom())
-        diff_height_width = (box[3] - box[1]) - (box[2] - box[0])
+        box = (detected_face.left, detected_face.top, detected_face.right, detected_face.bottom)
+        diff_height_width = detected_face.height - detected_face.width
         offset_y = int(abs(diff_height_width / 2))
         box_moved = self.move_box(box, [0, offset_y])
 
diff --git a/plugins/extract/align/fan.py b/plugins/extract/align/fan.py
index 9d1077a..3c2a87c 100644
--- a/plugins/extract/align/fan.py
+++ b/plugins/extract/align/fan.py
@@ -53,18 +53,12 @@ class Align(Aligner):
     def get_center_scale(self, detected_face):
         """ Get the center and set scale of bounding box """
         logger.trace("Calculating center and scale")
-        center = np.array([(detected_face.left()
-                            + detected_face.right()) / 2.0,
-                           (detected_face.top()
-                            + detected_face.bottom()) / 2.0])
-
-        center[1] -= (detected_face.bottom()
-                      - detected_face.top()) * 0.12
-
-        scale = (detected_face.right()
-                 - detected_face.left()
-                 + detected_face.bottom()
-                 - detected_face.top()) / self.reference_scale
+        center = np.array([(detected_face.left + detected_face.right) / 2.0,
+                           (detected_face.top + detected_face.bottom) / 2.0])
+
+        center[1] -= detected_face.height * 0.12
+
+        scale = (detected_face.width + detected_face.height) / self.reference_scale
 
         logger.trace("Calculated center and scale: %s, %s", center, scale)
         return center, scale
diff --git a/plugins/extract/detect/_base.py b/plugins/extract/detect/_base.py
index 397348a..820468a 100755
--- a/plugins/extract/detect/_base.py
+++ b/plugins/extract/detect/_base.py
@@ -8,7 +8,7 @@
     For each source frame, the plugin must pass a dict to finalize containing:
     {"filename": <filename of source frame>,
      "image": <source image>,
-     "detected_faces": <list of dlib.rectangles>}
+     "detected_faces": <list of BoundingBoxes>} (Class defined in /lib/faces_detect)
     """
 
 import logging
@@ -17,8 +17,8 @@ import traceback
 from io import StringIO
 
 import cv2
-import dlib
 
+from lib.faces_detect import BoundingBox
 from lib.gpu_stats import GPUStats
 from lib.utils import rotate_landmarks, GetModel
 from plugins.extract._config import Config
@@ -82,7 +82,7 @@ class Detector():
     def detect_faces(self, *args, **kwargs):
         """ Detect faces in rgb image
             Override for specific detector
-            Must return a list of dlib rects"""
+            Must return a list of BoundingBox's"""
         try:
             if not self.init:
                 self.initialize(*args, **kwargs)
@@ -141,8 +141,7 @@ class Detector():
         """ Filter out any faces smaller than the min size threshold """
         retval = list()
         for face in detected_faces:
-            face_size = ((face.right() - face.left()) ** 2 +
-                         (face.bottom() - face.top()) ** 2) ** 0.5
+            face_size = (face.width ** 2 + face.height ** 2) ** 0.5
             if face_size < self.min_size:
                 logger.debug("Removing detected face: (face_size: %s, min_size: %s",
                              face_size, self.min_size)
@@ -243,11 +242,11 @@ class Detector():
         return self.rotate_image_by_angle(image, angle)
 
     @staticmethod
-    def rotate_rect(d_rect, rotation_matrix):
-        """ Rotate a dlib rect based on the rotation_matrix"""
-        logger.trace("Rotating d_rectangle")
-        d_rect = rotate_landmarks(d_rect, rotation_matrix)
-        return d_rect
+    def rotate_rect(bounding_box, rotation_matrix):
+        """ Rotate a BoundingBox based on the rotation_matrix"""
+        logger.trace("Rotating BoundingBox")
+        bounding_box = rotate_landmarks(bounding_box, rotation_matrix)
+        return bounding_box
 
     @staticmethod
     def rotate_image_by_angle(image, angle,
@@ -311,21 +310,6 @@ class Detector():
         logger.trace("Returning batch size: %s", len(batch))
         return (exhausted, batch)
 
-    # <<< DLIB RECTANGLE METHODS >>> #
-    @staticmethod
-    def is_mmod_rectangle(d_rectangle):
-        """ Return whether the passed in object is
-            a dlib.mmod_rectangle """
-        return isinstance(
-            d_rectangle,
-            dlib.mmod_rectangle)  # pylint: disable=c-extension-no-member
-
-    def convert_to_dlib_rectangle(self, d_rect):
-        """ Convert detected mmod_rects to dlib_rectangle """
-        if self.is_mmod_rectangle(d_rect):
-            return d_rect.rect
-        return d_rect
-
     # <<< MISC METHODS >>> #
     @staticmethod
     def get_vram_free():
@@ -340,10 +324,10 @@ class Detector():
 
     @staticmethod
     def set_predetected(width, height):
-        """ Set a dlib rectangle for predetected faces """
+        """ Set a BoundingBox for predetected faces """
         # Predetected_face is used for sort tool.
         # Landmarks should not be extracted again from predetected faces,
         # because face data is lost, resulting in a large variance
         # against extract from original image
         logger.debug("Setting predetected face")
-        return [dlib.rectangle(0, 0, width, height)]  # pylint: disable=c-extension-no-member
+        return [BoundingBox(0, 0, width, height)]
diff --git a/plugins/extract/detect/cv2_dnn.py b/plugins/extract/detect/cv2_dnn.py
index 8b282a8..a1496c8 100755
--- a/plugins/extract/detect/cv2_dnn.py
+++ b/plugins/extract/detect/cv2_dnn.py
@@ -4,7 +4,7 @@ from time import sleep
 
 import numpy as np
 
-from ._base import cv2, Detector, dlib, logger
+from ._base import BoundingBox, cv2, Detector, logger
 
 
 class Detect(Detector):
@@ -86,14 +86,12 @@ class Detect(Detector):
         logger.trace("Processing Output: (faces: %s, rotation_matrix: %s)",
                      faces, rotation_matrix)
 
-        faces = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face[0]), int(face[1]), int(face[2]), int(face[3])) for face in faces]
+        faces = [BoundingBox(face[0], face[1], face[2], face[3]) for face in faces]
         if isinstance(rotation_matrix, np.ndarray):
             faces = [self.rotate_rect(face, rotation_matrix)
                      for face in faces]
-        detected = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face.left() / scale), int(face.top() / scale),
-            int(face.right() / scale), int(face.bottom() / scale))
+        detected = [BoundingBox(face.left / scale, face.top / scale,
+                                face.right / scale, face.bottom / scale)
                     for face in faces]
 
         logger.trace("Processed Output: %s", detected)
diff --git a/plugins/extract/detect/manual.py b/plugins/extract/detect/manual.py
index 703d011..d5c7441 100644
--- a/plugins/extract/detect/manual.py
+++ b/plugins/extract/detect/manual.py
@@ -1,7 +1,7 @@
 #!/usr/bin/env python3
 """ Manual face detection plugin """
 
-from ._base import Detector, dlib, logger
+from ._base import BoundingBox, Detector, logger
 
 
 class Detect(Detector):
@@ -17,7 +17,7 @@ class Detect(Detector):
         logger.info("Initialized Manual Detector.")
 
     def detect_faces(self, *args, **kwargs):
-        """ Return the given bounding box in a dlib rectangle """
+        """ Return the given bounding box in a BoundingBox """
         super().detect_faces(*args, **kwargs)
         while True:
             item = self.get_item()
@@ -25,8 +25,7 @@ class Detect(Detector):
                 break
             face = item["face"]
 
-            bounding_box = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-                int(face[0]), int(face[1]), int(face[2]), int(face[3]))]
+            bounding_box = [BoundingBox(face[0], face[1], face[2], face[3])]
             item["detected_faces"] = bounding_box
             self.finalize(item)
 
diff --git a/plugins/extract/detect/mtcnn.py b/plugins/extract/detect/mtcnn.py
index 1126005..95e5e26 100755
--- a/plugins/extract/detect/mtcnn.py
+++ b/plugins/extract/detect/mtcnn.py
@@ -11,7 +11,7 @@ import cv2
 import numpy as np
 
 from lib.multithreading import MultiThread
-from ._base import Detector, dlib, logger
+from ._base import BoundingBox, Detector, logger
 
 
 # Must import tensorflow inside the spawned process
@@ -155,17 +155,12 @@ class Detect(Detector):
         logger.trace("Processing Output: (faces: %s, points: %s, rotation_matrix: %s)",
                      faces, points, rotation_matrix)
         faces = self.recalculate_bounding_box(faces, points)
-        faces = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face[0]), int(face[1]), int(face[2]), int(face[3]))
-                 for face in faces]
+        faces = [BoundingBox(face[0], face[1], face[2], face[3]) for face in faces]
         if isinstance(rotation_matrix, np.ndarray):
             faces = [self.rotate_rect(face, rotation_matrix)
                      for face in faces]
-        detected = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face.left() / scale),
-            int(face.top() / scale),
-            int(face.right() / scale),
-            int(face.bottom() / scale))
+        detected = [BoundingBox(face.left / scale, face.top / scale,
+                                face.right / scale, face.bottom / scale)
                     for face in faces]
         logger.trace("Processed Output: %s", detected)
         return detected
diff --git a/plugins/extract/detect/s3fd.py b/plugins/extract/detect/s3fd.py
index 2df7311..61fc33d 100644
--- a/plugins/extract/detect/s3fd.py
+++ b/plugins/extract/detect/s3fd.py
@@ -11,7 +11,7 @@ from scipy.special import logsumexp
 import numpy as np
 
 from lib.multithreading import MultiThread
-from ._base import Detector, dlib, logger
+from ._base import BoundingBox, Detector, logger
 
 
 class Detect(Detector):
@@ -105,17 +105,12 @@ class Detect(Detector):
     def process_output(self, faces, rotation_matrix, scale):
         """ Compile found faces for output """
         logger.trace("Processing Output: (faces: %s, rotation_matrix: %s)", faces, rotation_matrix)
-        faces = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face[0]), int(face[1]), int(face[2]), int(face[3]))
-                 for face in faces]
+        faces = [BoundingBox(face[0], face[1], face[2], face[3]) for face in faces]
         if isinstance(rotation_matrix, np.ndarray):
             faces = [self.rotate_rect(face, rotation_matrix)
                      for face in faces]
-        detected = [dlib.rectangle(  # pylint: disable=c-extension-no-member
-            int(face.left() / scale),
-            int(face.top() / scale),
-            int(face.right() / scale),
-            int(face.bottom() / scale))
+        detected = [BoundingBox(face.left / scale, face.top / scale,
+                                face.right / scale, face.bottom / scale)
                     for face in faces]
         logger.trace("Processed Output: %s", detected)
         return detected
diff --git a/scripts/extract.py b/scripts/extract.py
index 3993628..e6cbd4b 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -230,7 +230,7 @@ class Extract():
         detected_faces = faces["detected_faces"]
         for idx, face in enumerate(detected_faces):
             detected_face = DetectedFace()
-            detected_face.from_dlib_rect(face, image)
+            detected_face.from_bounding_box(face, image)
             detected_face.landmarksXY = landmarks[idx]
             detected_face.load_aligned(image, size=size, align_eyes=align_eyes)
             final_faces.append({"file_location": self.output_dir / Path(filename).stem,
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
index 3a5ba01..cd43e95 100644
--- a/tools/lib_alignments/jobs_manual.py
+++ b/tools/lib_alignments/jobs_manual.py
@@ -461,8 +461,8 @@ class Manual():
         """ Iterate through frames """
         # pylint: disable=no-member
         logger.debug("Display frames")
-        is_windows = True if platform.system() == "Windows" else False
-        is_conda = True if "conda" in sys.version.lower() else False
+        is_windows = platform.system() == "Windows"
+        is_conda = "conda" in sys.version.lower()
         logger.debug("is_windows: %s, is_conda: %s", is_windows, is_conda)
         cv2.namedWindow("Frame")
         cv2.namedWindow("Faces")
@@ -784,7 +784,7 @@ class MouseHandler():
         d_event = detect_process.event
         detect_process.start()
 
-        for plugin in ("fan", "dlib"):
+        for plugin in ("fan", "cv2_dnn"):
             aligner = PluginLoader.get_aligner(plugin)(loglevel=loglevel)
             align_process = SpawnProcess(aligner.run, **a_kwargs)
             a_event = align_process.event
@@ -797,11 +797,11 @@ class MouseHandler():
             if not a_event.is_set():
                 if plugin == "fan":
                     align_process.join()
-                    logger.error("Error initializing FAN. Trying Dlib")
+                    logger.error("Error initializing FAN. Trying CV2-DNN")
                     continue
                 else:
                     raise ValueError("Error inititalizing Aligner")
-            if plugin == "dlib":
+            if plugin == "cv2_dnn":
                 break
 
             try:
@@ -812,7 +812,7 @@ class MouseHandler():
             if not err:
                 break
             align_process.join()
-            logger.error("Error initializing FAN. Trying Dlib")
+            logger.error("Error initializing FAN. Trying CV2-DNN")
 
         d_event.wait(10)
         if not d_event.is_set():
@@ -984,10 +984,10 @@ class MouseHandler():
     def extracted_to_alignment(extract_data):
         """ Convert Extracted Tuple to Alignments data """
         alignment = dict()
-        d_rect, landmarks = extract_data
-        alignment["x"] = d_rect.left()
-        alignment["w"] = d_rect.right() - d_rect.left()
-        alignment["y"] = d_rect.top()
-        alignment["h"] = d_rect.bottom() - d_rect.top()
+        bbox, landmarks = extract_data
+        alignment["x"] = bbox.left
+        alignment["w"] = bbox.width
+        alignment["y"] = bbox.top
+        alignment["h"] = bbox.height
         alignment["landmarksXY"] = landmarks
         return alignment
diff --git a/tools/sort.py b/tools/sort.py
index ade3b76..310a45e 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -87,7 +87,7 @@ class Sort():
         kwargs = {"in_queue": queue_manager.get_queue("in"),
                   "out_queue": out_queue}
 
-        for plugin in ("fan", "dlib"):
+        for plugin in ("fan", "cv2_dnn"):
             aligner = PluginLoader.get_aligner(plugin)(loglevel=self.args.loglevel)
             process = SpawnProcess(aligner.run, **kwargs)
             event = process.event
@@ -100,11 +100,11 @@ class Sort():
             if not event.is_set():
                 if plugin == "fan":
                     process.join()
-                    logger.error("Error initializing FAN. Trying Dlib")
+                    logger.error("Error initializing FAN. Trying CV2-DNN")
                     continue
                 else:
                     raise ValueError("Error inititalizing Aligner")
-            if plugin == "dlib":
+            if plugin == "cv2_dnn":
                 return
 
             try:
@@ -115,14 +115,14 @@ class Sort():
             if not err:
                 break
             process.join()
-            logger.error("Error initializing FAN. Trying Dlib")
+            logger.error("Error initializing FAN. Trying CV2-DNN")
 
     @staticmethod
     def alignment_dict(image):
         """ Set the image to a dict for alignment """
         height, width = image.shape[:2]
         face = DetectedFace(x=0, w=width, y=0, h=height)
-        face = face.to_dlib_rect()
+        face = face.to_bounding_box()
         return {"image": image,
                 "detected_faces": [face]}
 

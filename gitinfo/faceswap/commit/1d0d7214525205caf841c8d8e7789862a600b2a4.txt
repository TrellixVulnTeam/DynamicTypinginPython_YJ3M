commit 1d0d7214525205caf841c8d8e7789862a600b2a4
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Tue Jul 30 16:59:50 2019 +0000

    bugfix: Frame ranges for ffmpeg/gif writers

diff --git a/plugins/convert/writer/_base.py b/plugins/convert/writer/_base.py
index 35ee1ad..5e24384 100644
--- a/plugins/convert/writer/_base.py
+++ b/plugins/convert/writer/_base.py
@@ -53,6 +53,7 @@ class Output():
         frame_no = int(re.search(self.re_search, filename).group())
         self.cache[frame_no] = image
         logger.trace("Added to cache. Frame no: %s", frame_no)
+        logger.trace("Current cache: %s", sorted(self.cache.keys()))
 
     def write(self, filename, image):
         """ Override for specific frame writing method """
diff --git a/plugins/convert/writer/ffmpeg.py b/plugins/convert/writer/ffmpeg.py
index a6f3383..672ad99 100644
--- a/plugins/convert/writer/ffmpeg.py
+++ b/plugins/convert/writer/ffmpeg.py
@@ -13,10 +13,13 @@ from ._base import Output, logger
 
 class Writer(Output):
     """ Video output writer using imageio """
-    def __init__(self, output_folder, total_count, source_video, **kwargs):
+    def __init__(self, output_folder, total_count, frame_ranges, source_video, **kwargs):
         super().__init__(output_folder, **kwargs)
+        logger.debug("total_count: %s, frame_ranges: %s, source_video: '%s'",
+                     total_count, frame_ranges, source_video)
         self.source_video = source_video
-        self.frame_order = list(range(1, total_count + 1))
+        self.frame_ranges = frame_ranges
+        self.frame_order = self.set_frame_order(total_count)
         self.output_dimensions = None  # Fix dims of 1st frame in case of different sized images
         self.writer = None  # Need to know dimensions of first frame, so set writer then
 
@@ -50,6 +53,7 @@ class Writer(Output):
         """ Return the fps of source video """
         reader = imageio.get_reader(self.source_video)
         retval = reader.get_meta_data()["fps"]
+        reader.close()
         logger.debug(retval)
         return retval
 
@@ -77,6 +81,17 @@ class Writer(Output):
         logger.debug(output_args)
         return output_args
 
+    def set_frame_order(self, total_count):
+        """ Return the full list of frames to be converted in order """
+        if self.frame_ranges is None:
+            retval = list(range(1, total_count + 1))
+        else:
+            retval = list()
+            for rng in self.frame_ranges:
+                retval.extend(list(range(rng[0], rng[1] + 1)))
+        logger.debug("frame_order: %s", retval)
+        return retval
+
     def get_writer(self):
         """ Add the requested encoding options and return the writer """
         logger.debug("writer config: %s", self.config)
@@ -131,6 +146,16 @@ class Writer(Output):
             however muxing audio is non-trivial, so this is done afterwards with ffmpy.
             A future fix could be implemented to mux audio with the frames """
         logger.info("Muxing Audio...")
+        if self.frame_ranges is not None:
+            logger.warning("Muxing audio is not currently supported for limited frame ranges."
+                           "The output video has been created but you will need to mux audio "
+                           "yourself")
+            os.rename(self.video_tmp_file, self.video_file)
+            logger.debug("Removing temp file")
+            if os.path.isfile(self.video_tmp_file):
+                os.remove(self.video_tmp_file)
+            return
+
         exe = im_ffm.get_ffmpeg_exe()
         inputs = OrderedDict([(self.video_tmp_file, None), (self.source_video, None)])
         outputs = {self.video_file: "-map 0:0 -map 1:1 -c: copy"}
diff --git a/plugins/convert/writer/gif.py b/plugins/convert/writer/gif.py
index 01ca03a..b6f44fd 100644
--- a/plugins/convert/writer/gif.py
+++ b/plugins/convert/writer/gif.py
@@ -10,9 +10,10 @@ from ._base import Output, logger
 
 class Writer(Output):
     """ Video output writer using imageio """
-    def __init__(self, output_folder, total_count, **kwargs):
+    def __init__(self, output_folder, total_count, frame_ranges, **kwargs):
+        logger.debug("total_count: %s, frame_ranges: %s", total_count, frame_ranges)
         super().__init__(output_folder, **kwargs)
-        self.frame_order = list(range(1, total_count + 1))
+        self.frame_order = self.set_frame_order(total_count, frame_ranges)
         self.output_dimensions = None  # Fix dims of 1st frame in case of different sized images
         self.writer = None  # Need to know dimensions of first frame, so set writer then
         self.gif_file = None  # Set filename based on first file seen
@@ -24,6 +25,18 @@ class Writer(Output):
         logger.debug(kwargs)
         return kwargs
 
+    @staticmethod
+    def set_frame_order(total_count, frame_ranges):
+        """ Return the full list of frames to be converted in order """
+        if frame_ranges is None:
+            retval = list(range(1, total_count + 1))
+        else:
+            retval = list()
+            for rng in frame_ranges:
+                retval.extend(list(range(rng[0], rng[1] + 1)))
+        logger.debug("frame_order: %s", retval)
+        return retval
+
     def get_writer(self):
         """ Add the requested encoding options and return the writer """
         logger.debug("writer config: %s", self.config)
diff --git a/scripts/convert.py b/scripts/convert.py
index 6d80539..698cb6d 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -211,7 +211,7 @@ class DiskIO():
         """ Return the writer plugin """
         args = [self.args.output_dir]
         if self.args.writer in ("ffmpeg", "gif"):
-            args.append(self.total_count)
+            args.extend([self.total_count, self.frame_ranges])
         if self.args.writer == "ffmpeg":
             if self.images.is_video:
                 args.append(self.args.input_dir)
@@ -345,6 +345,7 @@ class DiskIO():
             return False
         idx = int(indices[0]) if indices else None
         skipframe = not any(map(lambda b: b[0] <= idx <= b[1], self.frame_ranges))
+        logger.trace("idx: %s, skipframe: %s", idx, skipframe)
         return skipframe
 
     def get_detected_faces(self, filename, image):

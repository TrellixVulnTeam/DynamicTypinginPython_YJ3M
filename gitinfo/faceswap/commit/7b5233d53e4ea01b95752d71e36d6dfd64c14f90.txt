commit 7b5233d53e4ea01b95752d71e36d6dfd64c14f90
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Mon Apr 1 17:08:11 2019 +0100

    Add timeout slider to train tab. Terminate properly on timeout

diff --git a/lib/gui/command.py b/lib/gui/command.py
index f414a7e..757099d 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -454,12 +454,43 @@ class ActionFrame(ttk.Frame):  # pylint: disable=too-many-ancestors
                             text="Generate",
                             width=10,
                             command=lambda: tk_vars["generate"].set(var_value))
-        btngen.pack(side=tk.RIGHT, padx=5)
+        btngen.pack(side=tk.LEFT, padx=5)
+        if self.command == "train":
+            self.add_timeout(actframe)
         Tooltip(btngen,
                 text="Output command line options to the console",
                 wraplength=200)
         logger.debug("Added action buttons: '%s'", self.title)
 
+    def add_timeout(self, actframe):
+        """ Add a timeout option for training """
+        logger.debug("Adding timeout box for %s", self.command)
+        tk_var = get_config().tk_vars["traintimeout"]
+        min_max = (10, 600)
+
+        frameto = ttk.Frame(actframe)
+        frameto.pack(padx=5, pady=5, side=tk.RIGHT, fill=tk.X, expand=True)
+        lblto = ttk.Label(frameto, text="Timeout:", anchor=tk.W)
+        lblto.pack(side=tk.LEFT)
+        sldto = ttk.Scale(frameto,
+                          variable=tk_var,
+                          from_=min_max[0],
+                          to=min_max[1],
+                          command=lambda val, var=tk_var, dt=int, rn=10, mm=min_max:
+                          set_slider_rounding(val, var, dt, rn, mm))
+        sldto.pack(padx=5, side=tk.LEFT, fill=tk.X, expand=True)
+        tboxto = ttk.Entry(frameto, width=3, textvariable=tk_var, justify=tk.RIGHT)
+        tboxto.pack(side=tk.RIGHT)
+        helptxt = ("Training can take some time to save and shutdown. "
+                   "Set the timeout in seconds before giving up and force quitting.")
+        Tooltip(sldto,
+                text=helptxt,
+                wraplength=200)
+        Tooltip(tboxto,
+                text=helptxt,
+                wraplength=200)
+        logger.debug("Added timeout box for %s", self.command)
+
     def add_util_buttons(self):
         """ Add the section utility buttons """
         logger.debug("Add util buttons")
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 229c120..dd3a473 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -348,8 +348,7 @@ class Images():
                 except OSError:
                     if i == 999:
                         raise
-                    else:
-                        continue
+                    continue
                 break
 
         self.previewtrain[name][1] = ImageTk.PhotoImage(displayimg)
@@ -524,13 +523,17 @@ class Config():
         updatepreview = tk.BooleanVar()
         updatepreview.set(False)
 
+        traintimeout = tk.IntVar()
+        traintimeout.set(120)
+
         tk_vars = {"display": display,
                    "runningtask": runningtask,
                    "action": actioncommand,
                    "generate": generatecommand,
                    "consoleclear": consoleclear,
                    "refreshgraph": refreshgraph,
-                   "updatepreview": updatepreview}
+                   "updatepreview": updatepreview,
+                   "traintimeout": traintimeout}
         logger.debug(tk_vars)
         return tk_vars
 
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index c90dc85..3cf2b3a 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -327,57 +327,61 @@ class FaceswapControl():
         """ Terminate the subprocess """
         logger.debug("Terminating wrapper")
         if self.command == "train":
+            timeout = get_config().tk_vars["traintimeout"].get()
             logger.debug("Sending Exit Signal")
             print("Sending Exit Signal", flush=True)
-            try:
+            if os.name == "nt":
+                try:
+                    logger.debug("Sending carriage return to process")
+                    self.process.communicate(input="\n", timeout=timeout)
+                except TimeoutExpired:
+                    logger.error("Timeout reached sending Exit Signal")
+                    self.terminate_all_children()
+            else:
+                logger.debug("Sending SIGINT to process")
                 now = time()
-                if os.name == "nt":
-                    try:
-                        logger.debug("Sending carriage return to process")
-                        self.process.communicate(input="\n", timeout=60)
-                    except TimeoutExpired:
-                        raise ValueError("Timeout reached sending Exit Signal")
-                else:
-                    logger.debug("Sending SIGINT to process")
-                    self.process.send_signal(signal.SIGINT)
-                    while True:
-                        timeelapsed = time() - now
-                        if self.process.poll() is not None:
-                            break
-                        if timeelapsed > 60:
-                            raise ValueError("Timeout reached sending Exit Signal")
+                self.process.send_signal(signal.SIGINT)
+                while True:
+                    timeelapsed = time() - now
+                    if self.process.poll() is not None:
+                        break
+                    if timeelapsed > timeout:
+                        logger.error("Timeout reached sending Exit Signal")
+                        self.terminate_all_children()
                 return
-            except ValueError as err:
-                logger.error("Error terminating process", exc_info=True)
-                print(err)
         else:
-            logger.debug("Terminating Process...")
-            print("Terminating Process...")
-            children = psutil.Process().children(recursive=True)
-            for child in children:
-                child.terminate()
-            _, alive = psutil.wait_procs(children, timeout=10)
-            if not alive:
-                logger.debug("Terminated")
-                print("Terminated")
-                return
+            self.terminate_all_children()
 
-            logger.debug("Termination timed out. Killing Process...")
-            print("Termination timed out. Killing Process...")
+    @staticmethod
+    def terminate_all_children():
+        """ Terminates all children """
+        logger.debug("Terminating Process...")
+        print("Terminating Process...", flush=True)
+        children = psutil.Process().children(recursive=True)
+        for child in children:
+            child.terminate()
+        _, alive = psutil.wait_procs(children, timeout=10)
+        if not alive:
+            logger.debug("Terminated")
+            print("Terminated")
+            return
+
+        logger.debug("Termination timed out. Killing Process...")
+        print("Termination timed out. Killing Process...", flush=True)
+        for child in alive:
+            child.kill()
+        _, alive = psutil.wait_procs(alive, timeout=10)
+        if not alive:
+            logger.debug("Killed")
+            print("Killed")
+        else:
             for child in alive:
-                child.kill()
-            _, alive = psutil.wait_procs(alive, timeout=10)
-            if not alive:
-                logger.debug("Killed")
-                print("Killed")
-            else:
-                for child in alive:
-                    msg = "Process {} survived SIGKILL. Giving up".format(child)
-                    logger.debug(msg)
-                    print(msg)
+                msg = "Process {} survived SIGKILL. Giving up".format(child)
+                logger.debug(msg)
+                print(msg)
 
     def set_final_status(self, returncode):
-        """ Set the status bar output based on subprocess return code 
+        """ Set the status bar output based on subprocess return code
             and reset training stats """
         logger.debug("Setting final status. returncode: %s", returncode)
         self.train_stats = {"iterations": 0, "timestamp": None}

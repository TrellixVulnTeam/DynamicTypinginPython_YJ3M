commit c3adc9311ea4d8486371305036ea79437d27cd9c
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Jul 26 17:51:18 2019 +0000

    Update GUI Graph + Stats when model has finished saving

diff --git a/lib/gui/display_analysis.py b/lib/gui/display_analysis.py
index c920327..ff4c436 100644
--- a/lib/gui/display_analysis.py
+++ b/lib/gui/display_analysis.py
@@ -117,7 +117,6 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         session = get_config().session
         if not session.initialized:
             logger.debug("Training not running")
-            print("Training not running")
             return
         if session.logging_disabled:
             logger.trace("Logging disabled. Not triggering analysis update")
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index 14417ea..9fa8ad1 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -188,8 +188,9 @@ class FaceswapControl():
                         (self.command not in ("train", "effmpeg") and self.capture_tqdm(output))):
                     continue
                 if self.command == "train" and "[saved models]" in output.strip().lower():
-                    logger.debug("Trigger update preview")
+                    logger.debug("Trigger GUI Training update")
                     self.wrapper.tk_vars["updatepreview"].set(True)
+                    self.wrapper.tk_vars["refreshgraph"].set(True)
                 print(output.strip())
         returncode = self.process.poll()
         message = self.set_final_status(returncode)
@@ -261,11 +262,8 @@ class FaceswapControl():
             # Don't initialize session until after the first iteration as state
             # file must exist first
             get_config().session.initialize_session(is_training=True)
-            self.wrapper.tk_vars["refreshgraph"].set(True)
 
         iterations += 1
-        if iterations % 100 == 0:
-            self.wrapper.tk_vars["refreshgraph"].set(True)
         self.train_stats["iterations"] = iterations
 
         elapsed = self.calc_elapsed()

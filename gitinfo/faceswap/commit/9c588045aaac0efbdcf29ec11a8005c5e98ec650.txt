commit 9c588045aaac0efbdcf29ec11a8005c5e98ec650
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Nov 22 19:20:23 2019 +0000

    GUI Updates (#940)
    
    * lib.gui: Update icons
    * tools.cli: Add video filetype flag to mask input
    * lib.gui.popup_configure: Refresh GUI on config save
    * lib.gui._config: Add Icon size and load last session options
    * lib.gui.control_helper - Add control modification tracking
    * lib.gui - Add Projects and Last Session
    - Main root title handled by projects
    - Add Hotkeys
    - Create projects module
    - split fsw and fst filetypes
    - Add last_session saving
    
    * lib.project
    - Documentation
    - Ask confirm on closing unsaved project
    -Fixups
    
    * Track model folder changes
    - Shuffle some globals
    - Activate System Verbosity for GUI
    
    * lib.gui.utils - Documentation and clean up
    - lib.gui.custom_widgets - Create and document
    
    * Add GUI config option to disable auto loading model stats

diff --git a/docs/full/lib.gui.custom_widgets.rst b/docs/full/lib.gui.custom_widgets.rst
new file mode 100644
index 0000000..e67fd07
--- /dev/null
+++ b/docs/full/lib.gui.custom_widgets.rst
@@ -0,0 +1,7 @@
+lib.gui.custom\_widgets module
+==============================
+
+.. automodule:: lib.gui.custom_widgets
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/docs/full/lib.gui.project.rst b/docs/full/lib.gui.project.rst
new file mode 100644
index 0000000..75b99be
--- /dev/null
+++ b/docs/full/lib.gui.project.rst
@@ -0,0 +1,7 @@
+lib.gui.project module
+======================
+
+.. automodule:: lib.gui.project
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/docs/full/lib.gui.rst b/docs/full/lib.gui.rst
new file mode 100644
index 0000000..e8d44f6
--- /dev/null
+++ b/docs/full/lib.gui.rst
@@ -0,0 +1,11 @@
+lib.gui package
+===============
+
+Submodules
+----------
+
+.. toctree::
+
+   lib.gui.custom_widgets
+   lib.gui.project
+   lib.gui.utils
diff --git a/docs/full/lib.gui.utils.rst b/docs/full/lib.gui.utils.rst
new file mode 100644
index 0000000..b3904a3
--- /dev/null
+++ b/docs/full/lib.gui.utils.rst
@@ -0,0 +1,7 @@
+lib.gui.utils module
+====================
+
+.. automodule:: lib.gui.utils
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/docs/full/lib.rst b/docs/full/lib.rst
index 83e9642..d1aebce 100644
--- a/docs/full/lib.rst
+++ b/docs/full/lib.rst
@@ -6,9 +6,10 @@ Subpackages
 
 .. toctree::
 
-   lib.model
    lib.faces_detect
+   lib.gui
    lib.image
+   lib.model
    lib.serializer
    lib.training_data
 
diff --git a/lib/gui/.cache/icons/clear.png b/lib/gui/.cache/icons/clear.png
index 0f2c636..78060cb 100755
Binary files a/lib/gui/.cache/icons/clear.png and b/lib/gui/.cache/icons/clear.png differ
diff --git a/lib/gui/.cache/icons/clear2.png b/lib/gui/.cache/icons/clear2.png
new file mode 100644
index 0000000..1ace1a5
Binary files /dev/null and b/lib/gui/.cache/icons/clear2.png differ
diff --git a/lib/gui/.cache/icons/context.png b/lib/gui/.cache/icons/context.png
new file mode 100644
index 0000000..7176139
Binary files /dev/null and b/lib/gui/.cache/icons/context.png differ
diff --git a/lib/gui/.cache/icons/favicon.png b/lib/gui/.cache/icons/favicon.png
new file mode 100644
index 0000000..4c8f094
Binary files /dev/null and b/lib/gui/.cache/icons/favicon.png differ
diff --git a/lib/gui/.cache/icons/folder.png b/lib/gui/.cache/icons/folder.png
new file mode 100644
index 0000000..1eab92f
Binary files /dev/null and b/lib/gui/.cache/icons/folder.png differ
diff --git a/lib/gui/.cache/icons/generate.png b/lib/gui/.cache/icons/generate.png
new file mode 100644
index 0000000..f952175
Binary files /dev/null and b/lib/gui/.cache/icons/generate.png differ
diff --git a/lib/gui/.cache/icons/graph.png b/lib/gui/.cache/icons/graph.png
old mode 100755
new mode 100644
index 7056a9a..253647e
Binary files a/lib/gui/.cache/icons/graph.png and b/lib/gui/.cache/icons/graph.png differ
diff --git a/lib/gui/.cache/icons/load.png b/lib/gui/.cache/icons/load.png
new file mode 100644
index 0000000..b8b2cad
Binary files /dev/null and b/lib/gui/.cache/icons/load.png differ
diff --git a/lib/gui/.cache/icons/load2.png b/lib/gui/.cache/icons/load2.png
new file mode 100644
index 0000000..64ded4a
Binary files /dev/null and b/lib/gui/.cache/icons/load2.png differ
diff --git a/lib/gui/.cache/icons/model.png b/lib/gui/.cache/icons/model.png
new file mode 100644
index 0000000..6f5bd40
Binary files /dev/null and b/lib/gui/.cache/icons/model.png differ
diff --git a/lib/gui/.cache/icons/move.png b/lib/gui/.cache/icons/move.png
index 8fb918a..3732602 100755
Binary files a/lib/gui/.cache/icons/move.png and b/lib/gui/.cache/icons/move.png differ
diff --git a/lib/gui/.cache/icons/multi_load.png b/lib/gui/.cache/icons/multi_load.png
new file mode 100644
index 0000000..05ce022
Binary files /dev/null and b/lib/gui/.cache/icons/multi_load.png differ
diff --git a/lib/gui/.cache/icons/new.png b/lib/gui/.cache/icons/new.png
new file mode 100644
index 0000000..5dcf4be
Binary files /dev/null and b/lib/gui/.cache/icons/new.png differ
diff --git a/lib/gui/.cache/icons/open_file.png b/lib/gui/.cache/icons/open_file.png
deleted file mode 100755
index e91a27b..0000000
Binary files a/lib/gui/.cache/icons/open_file.png and /dev/null differ
diff --git a/lib/gui/.cache/icons/open_folder.png b/lib/gui/.cache/icons/open_folder.png
deleted file mode 100755
index 8e4b2aa..0000000
Binary files a/lib/gui/.cache/icons/open_folder.png and /dev/null differ
diff --git a/lib/gui/.cache/icons/picture.png b/lib/gui/.cache/icons/picture.png
new file mode 100644
index 0000000..e667c66
Binary files /dev/null and b/lib/gui/.cache/icons/picture.png differ
diff --git a/lib/gui/.cache/icons/reload.png b/lib/gui/.cache/icons/reload.png
new file mode 100644
index 0000000..a6082ca
Binary files /dev/null and b/lib/gui/.cache/icons/reload.png differ
diff --git a/lib/gui/.cache/icons/reload2.png b/lib/gui/.cache/icons/reload2.png
new file mode 100644
index 0000000..ba57c1d
Binary files /dev/null and b/lib/gui/.cache/icons/reload2.png differ
diff --git a/lib/gui/.cache/icons/reset.png b/lib/gui/.cache/icons/reset.png
deleted file mode 100755
index bc5cd44..0000000
Binary files a/lib/gui/.cache/icons/reset.png and /dev/null differ
diff --git a/lib/gui/.cache/icons/save.png b/lib/gui/.cache/icons/save.png
index 97dc732..09e3cb3 100755
Binary files a/lib/gui/.cache/icons/save.png and b/lib/gui/.cache/icons/save.png differ
diff --git a/lib/gui/.cache/icons/save2.png b/lib/gui/.cache/icons/save2.png
new file mode 100644
index 0000000..8005fd0
Binary files /dev/null and b/lib/gui/.cache/icons/save2.png differ
diff --git a/lib/gui/.cache/icons/save_as.png b/lib/gui/.cache/icons/save_as.png
new file mode 100644
index 0000000..02de122
Binary files /dev/null and b/lib/gui/.cache/icons/save_as.png differ
diff --git a/lib/gui/.cache/icons/save_as2.png b/lib/gui/.cache/icons/save_as2.png
new file mode 100644
index 0000000..c98ec39
Binary files /dev/null and b/lib/gui/.cache/icons/save_as2.png differ
diff --git a/lib/gui/.cache/icons/settings.png b/lib/gui/.cache/icons/settings.png
new file mode 100644
index 0000000..b2fc465
Binary files /dev/null and b/lib/gui/.cache/icons/settings.png differ
diff --git a/lib/gui/.cache/icons/settings_convert.png b/lib/gui/.cache/icons/settings_convert.png
new file mode 100644
index 0000000..888c98d
Binary files /dev/null and b/lib/gui/.cache/icons/settings_convert.png differ
diff --git a/lib/gui/.cache/icons/settings_extract.png b/lib/gui/.cache/icons/settings_extract.png
new file mode 100644
index 0000000..4ffc931
Binary files /dev/null and b/lib/gui/.cache/icons/settings_extract.png differ
diff --git a/lib/gui/.cache/icons/settings_train.png b/lib/gui/.cache/icons/settings_train.png
new file mode 100644
index 0000000..fb2ae56
Binary files /dev/null and b/lib/gui/.cache/icons/settings_train.png differ
diff --git a/lib/gui/.cache/icons/start.png b/lib/gui/.cache/icons/start.png
new file mode 100644
index 0000000..1aba1c2
Binary files /dev/null and b/lib/gui/.cache/icons/start.png differ
diff --git a/lib/gui/.cache/icons/stop.png b/lib/gui/.cache/icons/stop.png
new file mode 100644
index 0000000..9bd2038
Binary files /dev/null and b/lib/gui/.cache/icons/stop.png differ
diff --git a/lib/gui/.cache/icons/video.png b/lib/gui/.cache/icons/video.png
new file mode 100644
index 0000000..bd56560
Binary files /dev/null and b/lib/gui/.cache/icons/video.png differ
diff --git a/lib/gui/.cache/icons/zoom.png b/lib/gui/.cache/icons/zoom.png
index c2a5653..0658f02 100755
Binary files a/lib/gui/.cache/icons/zoom.png and b/lib/gui/.cache/icons/zoom.png differ
diff --git a/lib/gui/__init__.py b/lib/gui/__init__.py
index dca41f2..b611c3c 100644
--- a/lib/gui/__init__.py
+++ b/lib/gui/__init__.py
@@ -1,9 +1,10 @@
 from lib.gui.command import CommandNotebook
+from lib.gui.custom_widgets import ConsoleOut, StatusBar
 from lib.gui.display import DisplayNotebook
 from lib.gui.options import CliOptions
-from lib.gui.menu import MainMenuBar
+from lib.gui.menu import MainMenuBar, TaskBar
 from lib.gui.popup_configure import popup_config
+from lib.gui.project import LastSession
 from lib.gui.stats import Session
-from lib.gui.statusbar import StatusBar
-from lib.gui.utils import ConsoleOut, get_config, get_images, initialize_config, initialize_images
+from lib.gui.utils import get_config, get_images, initialize_config, initialize_images
 from lib.gui.wrapper import ProcessWrapper
diff --git a/lib/gui/_config.py b/lib/gui/_config.py
index cf6a864..323ec3e 100644
--- a/lib/gui/_config.py
+++ b/lib/gui/_config.py
@@ -26,8 +26,8 @@ class Config(FaceswapConfig):
         logger.debug("Setting global config")
         section = "global"
         self.add_section(title=section,
-                         info="Faceswap GUI Options.\nNB: Faceswap will need to be restarted for "
-                              "any changes to take effect.")
+                         info="Faceswap GUI Options.\nConfigure the appearance and behaviour of "
+                              "the GUI")
         self.add_item(
             section=section, title="fullscreen", datatype=bool, default=False, group="startup",
             info="Start Faceswap maximized.")
@@ -43,6 +43,10 @@ class Config(FaceswapConfig):
             section=section, title="console_panel_height", datatype=int, default=20,
             min_max=(10, 90), rounding=1, group="layout",
             info="How tall the bottom console panel is as a percentage of GUI height at startup.")
+        self.add_item(
+            section=section, title="icon_size", datatype=int, default=14,
+            min_max=(10, 20), rounding=1, group="layout",
+            info="Pixel size for icons. NB: Size is scaled by DPI.")
         self.add_item(
             section=section, title="font", datatype=str,
             choices=get_clean_fonts(),
@@ -51,6 +55,23 @@ class Config(FaceswapConfig):
             section=section, title="font_size", datatype=int, default=9,
             min_max=(6, 12), rounding=1, group="font",
             info="Global font size.")
+        self.add_item(
+            section=section, title="autosave_last_session", datatype=str, default="prompt",
+            choices=["never", "prompt", "always"], group="startup", gui_radio=True,
+            info="Automatically save the current settings on close and reload on startup"
+                 "\n\tnever - Don't autosave session"
+                 "\n\tprompt - Prompt to reload last session on launch"
+                 "\n\talways - Always load last session on launch")
+        self.add_item(
+            section=section, title="timeout", datatype=int, default=120,
+            min_max=(10, 600), rounding=10, group="behaviour",
+            info="Training can take some time to save and shutdown. Set the timeout in seconds "
+                 "before giving up and force quitting.")
+        self.add_item(
+            section=section, title="auto_load_model_stats", datatype=bool, default=True,
+            group="behaviour",
+            info="Auto load model statistics into the Analysis tab when selecting a model "
+                 "in Train or Convert tabs.")
 
 
 def get_commands():
@@ -70,7 +91,7 @@ def get_commands():
 
 
 def get_clean_fonts():
-    """ Return the font list with any @prefixed or non-unicode characters stripped
+    """ Return the font list with any @prefixed or non-Unicode characters stripped
         and default prefixed """
     cleaned_fonts = sorted([fnt for fnt in font.families()
                             if not fnt.startswith("@") and not any([ord(c) > 127 for c in fnt])])
diff --git a/lib/gui/_redirector.py b/lib/gui/_redirector.py
deleted file mode 100644
index df33291..0000000
--- a/lib/gui/_redirector.py
+++ /dev/null
@@ -1,154 +0,0 @@
-#!/usr/bin/env python3
-""" Widget redirector from IdleLib
-https://github.com/python/cpython/blob/master/Lib/idlelib/redirector.py
-"""
-
-from tkinter import TclError
-
-
-class WidgetRedirector:
-    """Support for redirecting arbitrary widget subcommands.
-
-    Some Tk operations don't normally pass through tkinter.  For example, if a
-    character is inserted into a Text widget by pressing a key, a default Tk
-    binding to the widget's 'insert' operation is activated, and the Tk library
-    processes the insert without calling back into tkinter.
-
-    Although a binding to <Key> could be made via tkinter, what we really want
-    to do is to hook the Tk 'insert' operation itself.  For one thing, we want
-    a text.insert call in idle code to have the same effect as a key press.
-
-    When a widget is instantiated, a Tcl command is created whose name is the
-    same as the pathname widget._w.  This command is used to invoke the various
-    widget operations, e.g. insert (for a Text widget). We are going to hook
-    this command and provide a facility ('register') to intercept the widget
-    operation.  We will also intercept method calls on the tkinter class
-    instance that represents the tk widget.
-
-    In IDLE, WidgetRedirector is used in Percolator to intercept Text
-    commands.  The function being registered provides access to the top
-    of a Percolator chain.  At the bottom of the chain is a call to the
-    original Tk widget operation.
-    """
-    def __init__(self, widget):
-        """Initialize attributes and setup redirection.
-
-        _operations: dict mapping operation name to new function.
-        widget: the widget whose tcl command is to be intercepted.
-        tk: widget.tk, a convenience attribute, probably not needed.
-        orig: new name of the original tcl command.
-
-        Since renaming to orig fails with TclError when orig already
-        exists, only one WidgetDirector can exist for a given widget.
-        """
-        self._operations = {}
-        self.widget = widget                                # widget instance
-        self.tk_ = tk_ = widget.tk                          # widget's root
-        wgt = widget._w  # pylint:disable=protected-access  # widget's (full) Tk pathname
-        self.orig = wgt + "_orig"
-        # Rename the Tcl command within Tcl:
-        tk_.call("rename", wgt, self.orig)
-        # Create a new Tcl command whose name is the widget's pathname, and
-        # whose action is to dispatch on the operation passed to the widget:
-        tk_.createcommand(wgt, self.dispatch)
-
-    def __repr__(self):
-        return "%s(%s<%s>)" % (self.__class__.__name__,
-                               self.widget.__class__.__name__,
-                               self.widget._w)  # pylint:disable=protected-access
-
-    def close(self):
-        "Unregister operations and revert redirection created by .__init__."
-        for operation in list(self._operations):
-            self.unregister(operation)
-        widget = self.widget
-        tk_ = widget.tk
-        wgt = widget._w  # pylint:disable=protected-access
-        # Restore the original widget Tcl command.
-        tk_.deletecommand(wgt)
-        tk_.call("rename", self.orig, wgt)
-        del self.widget, self.tk_  # Should not be needed
-        # if instance is deleted after close, as in Percolator.
-
-    def register(self, operation, function):
-        """Return OriginalCommand(operation) after registering function.
-
-        Registration adds an operation: function pair to ._operations.
-        It also adds a widget function attribute that masks the tkinter
-        class instance method.  Method masking operates independently
-        from command dispatch.
-
-        If a second function is registered for the same operation, the
-        first function is replaced in both places.
-        """
-        self._operations[operation] = function
-        setattr(self.widget, operation, function)
-        return OriginalCommand(self, operation)
-
-    def unregister(self, operation):
-        """Return the function for the operation, or None.
-
-        Deleting the instance attribute unmasks the class attribute.
-        """
-        if operation in self._operations:
-            function = self._operations[operation]
-            del self._operations[operation]
-            try:
-                delattr(self.widget, operation)
-            except AttributeError:
-                pass
-            return function
-        return None
-
-    def dispatch(self, operation, *args):
-        """Callback from Tcl which runs when the widget is referenced.
-
-        If an operation has been registered in self._operations, apply the
-        associated function to the args passed into Tcl. Otherwise, pass the
-        operation through to Tk via the original Tcl function.
-
-        Note that if a registered function is called, the operation is not
-        passed through to Tk.  Apply the function returned by self.register()
-        to *args to accomplish that.  For an example, see colorizer.py.
-
-        """
-        op_ = self._operations.get(operation)
-        try:
-            if op_:
-                return op_(*args)
-            return self.tk_.call((self.orig, operation) + args)
-        except TclError:
-            return ""
-
-
-class OriginalCommand:
-    """Callable for original tk command that has been redirected.
-
-    Returned by .register; can be used in the function registered.
-    redir = WidgetRedirector(text)
-    def my_insert(*args):
-        print("insert", args)
-        original_insert(*args)
-    original_insert = redir.register("insert", my_insert)
-    """
-
-    def __init__(self, redir, operation):
-        """Create .tk_call and .orig_and_operation for .__call__ method.
-
-        .redir and .operation store the input args for __repr__.
-        .tk and .orig copy attributes of .redir (probably not needed).
-        """
-        self.redir = redir
-        self.operation = operation
-        self.tk_ = redir.tk_  # redundant with self.redir
-        self.orig = redir.orig  # redundant with self.redir
-        # These two could be deleted after checking recipient code.
-        self.tk_call = redir.tk_.call
-        self.orig_and_operation = (redir.orig, operation)
-
-    def __repr__(self):
-        return "%s(%r, %r)" % (self.__class__.__name__,
-                               self.redir, self.operation)
-
-    def __call__(self, *args):
-        return self.tk_call(self.orig_and_operation + args)
diff --git a/lib/gui/command.py b/lib/gui/command.py
index ca75b34..08af864 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -5,8 +5,8 @@ import logging
 import tkinter as tk
 from tkinter import ttk
 
-from .control_helper import set_slider_rounding, ControlPanel
-from .tooltip import Tooltip
+from .control_helper import ControlPanel
+from .custom_widgets import Tooltip
 from .utils import get_images, get_config
 
 logger = logging.getLogger(__name__)  # pylint:disable=invalid-name
@@ -24,9 +24,22 @@ class CommandNotebook(ttk.Notebook):  # pylint:disable=too-many-ancestors
         self.tools_notebook = ToolsNotebook(self)
         self.set_running_task_trace()
         self.build_tabs()
-        get_config().command_notebook = self
+        self.modified_vars = self._set_modified_vars()
+        get_config().set_command_notebook(self)
         logger.debug("Initialized %s", self.__class__.__name__)
 
+    @property
+    def tab_names(self):
+        """ dict: Command tab titles with their IDs """
+        return {self.tab(tab_id, "text").lower(): tab_id
+                for tab_id in range(0, self.index("end"))}
+
+    @property
+    def tools_tab_names(self):
+        """ dict: Tools tab titles with their IDs """
+        return {self.tools_notebook.tab(tab_id, "text").lower(): tab_id
+                for tab_id in range(0, self.tools_notebook.index("end"))}
+
     def set_running_task_trace(self):
         """ Set trigger action for the running task
             to change the action buttons text and command """
@@ -56,15 +69,34 @@ class CommandNotebook(ttk.Notebook):  # pylint:disable=too-many-ancestors
         for cmd, action in self.actionbtns.items():
             btnact = action
             if tk_vars["runningtask"].get():
-                ttl = "Terminate"
+                ttl = " Stop"
+                img = get_images().icons["stop"]
                 hlp = "Exit the running process"
             else:
-                ttl = cmd.title()
+                ttl = " {}".format(cmd.title())
+                img = get_images().icons["start"]
                 hlp = "Run the {} script".format(cmd.title())
             logger.debug("Updated Action Button: '%s'", ttl)
-            btnact.config(text=ttl)
+            btnact.config(text=ttl, image=img)
             Tooltip(btnact, text=hlp, wraplength=200)
 
+    def _set_modified_vars(self):
+        """ Set the tkinter variable for each tab to indicate whether contents
+        have been modified """
+        tkvars = dict()
+        for tab in self.tab_names:
+            if tab == "tools":
+                for ttab in self.tools_tab_names:
+                    var = tk.BooleanVar()
+                    var.set(False)
+                    tkvars[ttab] = var
+                continue
+            var = tk.BooleanVar()
+            var.set(False)
+            tkvars[tab] = var
+        logger.debug("Set modified vars: %s", tkvars)
+        return tkvars
+
 
 class ToolsNotebook(ttk.Notebook):  # pylint:disable=too-many-ancestors
     """ Tools sit in their own tab, but need to inherit objects from the main command notebook """
@@ -124,86 +156,38 @@ class ActionFrame(ttk.Frame):  # pylint:disable=too-many-ancestors
 
         self.add_action_button(parent.category,
                                parent.actionbtns)
-        self.add_util_buttons()
         logger.debug("Initialized %s", self.__class__.__name__)
 
     def add_action_button(self, category, actionbtns):
         """ Add the action buttons for page """
         logger.debug("Add action buttons: '%s'", self.title)
         actframe = ttk.Frame(self)
-        actframe.pack(fill=tk.X, side=tk.LEFT)
-        tk_vars = get_config().tk_vars
+        actframe.pack(fill=tk.X, side=tk.RIGHT)
 
+        tk_vars = get_config().tk_vars
         var_value = "{},{}".format(category, self.command)
 
-        btnact = ttk.Button(actframe,
-                            text=self.title,
-                            width=10,
-                            command=lambda: tk_vars["action"].set(var_value))
-        btnact.pack(side=tk.LEFT)
-        Tooltip(btnact,
-                text="Run the {} script".format(self.title),
-                wraplength=200)
-        actionbtns[self.command] = btnact
-
         btngen = ttk.Button(actframe,
-                            text="Generate",
-                            width=10,
+                            image=get_images().icons["generate"],
+                            text=" Generate",
+                            compound=tk.LEFT,
+                            width=14,
                             command=lambda: tk_vars["generate"].set(var_value))
         btngen.pack(side=tk.LEFT, padx=5)
-        if self.command == "train":
-            self.add_timeout(actframe)
         Tooltip(btngen,
                 text="Output command line options to the console",
                 wraplength=200)
-        logger.debug("Added action buttons: '%s'", self.title)
 
-    def add_timeout(self, actframe):
-        """ Add a timeout option for training """
-        logger.debug("Adding timeout box for %s", self.command)
-        tk_var = get_config().tk_vars["traintimeout"]
-        min_max = (10, 600)
-
-        frameto = ttk.Frame(actframe)
-        frameto.pack(padx=5, pady=5, side=tk.RIGHT, fill=tk.X, expand=True)
-        lblto = ttk.Label(frameto, text="Timeout:", anchor=tk.W)
-        lblto.pack(side=tk.LEFT)
-        sldto = ttk.Scale(frameto,
-                          variable=tk_var,
-                          from_=min_max[0],
-                          to=min_max[1],
-                          command=lambda val, var=tk_var, dt=int, rn=10, mm=min_max:
-                          set_slider_rounding(val, var, dt, rn, mm))
-        sldto.pack(padx=5, side=tk.LEFT, fill=tk.X, expand=True)
-        tboxto = ttk.Entry(frameto, width=3, textvariable=tk_var, justify=tk.RIGHT)
-        tboxto.pack(side=tk.RIGHT)
-        helptxt = ("Training can take some time to save and shutdown. "
-                   "Set the timeout in seconds before giving up and force quitting.")
-        Tooltip(sldto,
-                text=helptxt,
-                wraplength=200)
-        Tooltip(tboxto,
-                text=helptxt,
+        btnact = ttk.Button(actframe,
+                            image=get_images().icons["start"],
+                            text=" {}".format(self.title),
+                            compound=tk.LEFT,
+                            width=14,
+                            command=lambda: tk_vars["action"].set(var_value))
+        btnact.pack(side=tk.LEFT, fill=tk.X, expand=True)
+        Tooltip(btnact,
+                text="Run the {} script".format(self.title),
                 wraplength=200)
-        logger.debug("Added timeout box for %s", self.command)
-
-    def add_util_buttons(self):
-        """ Add the section utility buttons """
-        logger.debug("Add util buttons")
-        utlframe = ttk.Frame(self)
-        utlframe.pack(side=tk.RIGHT)
-
-        config = get_config()
-        for utl in ("load", "save", "clear", "reset"):
-            logger.debug("Adding button: '%s'", utl)
-            img = get_images().icons[utl]
-            action_cls = config if utl in (("save", "load")) else config.cli_opts
-            action = getattr(action_cls, utl)
-            btnutl = ttk.Button(utlframe,
-                                image=img,
-                                command=lambda cmd=action: cmd(self.command))
-            btnutl.pack(padx=2, side=tk.LEFT)
-            Tooltip(btnutl,
-                    text=utl.capitalize() + " " + self.title + " config",
-                    wraplength=200)
-        logger.debug("Added util buttons")
+        actionbtns[self.command] = btnact
+
+        logger.debug("Added action buttons: '%s'", self.title)
diff --git a/lib/gui/control_helper.py b/lib/gui/control_helper.py
index dd4059b..dee44a8 100644
--- a/lib/gui/control_helper.py
+++ b/lib/gui/control_helper.py
@@ -10,8 +10,9 @@ from functools import partial
 
 from _tkinter import Tcl_Obj
 
-from .tooltip import Tooltip
-from .utils import ContextMenu, FileHandler, get_config, get_images
+from .custom_widgets import ContextMenu
+from .custom_widgets import Tooltip
+from .utils import FileHandler, get_config, get_images
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -21,7 +22,7 @@ logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 _RECREATE_OBJECTS = dict(tooltips=dict(), commands=dict(), contextmenus=dict())
 
 
-def get_tooltip(widget, text, wraplength=600):
+def _get_tooltip(widget, text, wraplength=600):
     """ Store the tooltip layout and widget id in _TOOLTIPS and return a tooltip """
     _RECREATE_OBJECTS["tooltips"][str(widget)] = {"text": text,
                                                   "wraplength": wraplength}
@@ -30,7 +31,7 @@ def get_tooltip(widget, text, wraplength=600):
     return Tooltip(widget, text=text, wraplength=wraplength)
 
 
-def get_contextmenu(widget):
+def _get_contextmenu(widget):
     """ Create a context menu, store its mapping and return """
     rc_menu = ContextMenu(widget)
     _RECREATE_OBJECTS["contextmenus"][str(widget)] = rc_menu
@@ -39,7 +40,7 @@ def get_contextmenu(widget):
     return rc_menu
 
 
-def add_command(name, func):
+def _add_command(name, func):
     """ For controls that execute commands, the command must be added to the _COMMAND list so that
         it can be added back to the widget during cloning """
     logger.debug("Adding to commands: %s - %s", name, func)
@@ -47,7 +48,22 @@ def add_command(name, func):
 
 
 def set_slider_rounding(value, var, d_type, round_to, min_max):
-    """ Set the underlying variable to correct number based on slider rounding """
+    """ Set the value of sliders underlying variable based on their datatype,
+    rounding value and min/max.
+
+    Parameters
+    ----------
+    var: tkinter.Var
+        The variable to set the value for
+    d_type: [:class:`int`, :class:`float`]
+        The type of value that is stored in :attr:`var`
+    round_to: int
+        If :attr:`dtype` is :class:`float` then this is the decimal place rounding for :attr:`var`.
+        If :attr:`dtype` is :class:`int` then this is the number of steps between each increment
+        for :attr:`var`
+    min_max: tuple (`int`, `int`)
+        The (``min``, ``max``) values that this slider accepts
+    """
     if d_type == float:
         var.set(round(float(value), round_to))
     else:
@@ -56,12 +72,6 @@ def set_slider_rounding(value, var, d_type, round_to, min_max):
         var.set(value)
 
 
-def adjust_wraplength(event):
-    """ dynamically adjust the wraplength of a label on event """
-    label = event.widget
-    label.configure(wraplength=event.width - 1)
-
-
 class ControlPanelOption():
     """
     A class to hold a control panel option. A list of these is expected
@@ -94,19 +104,26 @@ class ControlPanelOption():
         Expects a dict: {sysbrowser: str, filetypes: str}
     helptext: str, optional
         Sets the tooltip text
+    track_modified: bool, optional
+        Set whether to set a callback trace indicating that the parameter has been modified.
+        Default: False
+    command: str, optional
+        Required if tracking modified. The command that this option belongs to. Default: None
     """
 
     def __init__(self, title, dtype,  # pylint:disable=too-many-arguments
                  group=None, default=None, initial_value=None, choices=None, is_radio=False,
-                 rounding=None, min_max=None, sysbrowser=None, helptext=None):
+                 rounding=None, min_max=None, sysbrowser=None, helptext=None,
+                 track_modified=False, command=None):
         logger.debug("Initializing %s: (title: '%s', dtype: %s, group: %s, default: %s, "
                      "initial_value: %s, choices: %s, is_radio: %s, rounding: %s, min_max: %s, "
-                     "sysbrowser: %s, helptext: '%s')", self.__class__.__name__, title, dtype,
-                     group, default, initial_value, choices, is_radio, rounding, min_max,
-                     sysbrowser, helptext)
+                     "sysbrowser: %s, helptext: '%s', track_modified: %s, command: '%s')",
+                     self.__class__.__name__, title, dtype, group, default, initial_value, choices,
+                     is_radio, rounding, min_max, sysbrowser, helptext, track_modified, command)
 
         self.dtype = dtype
         self.sysbrowser = sysbrowser
+        self._command = command
         self._options = dict(title=title,
                              group=group,
                              default=default,
@@ -117,7 +134,7 @@ class ControlPanelOption():
                              min_max=min_max,
                              helptext=helptext)
         self.control = self.get_control()
-        self.tk_var = self.get_tk_var()
+        self.tk_var = self.get_tk_var(track_modified)
         logger.debug("Initialized %s", self.__class__.__name__)
 
     @property
@@ -208,7 +225,7 @@ class ControlPanelOption():
         logger.debug("Setting control '%s' to %s", self.title, control)
         return control
 
-    def get_tk_var(self):
+    def get_tk_var(self, track_modified):
         """ Correct variable type for control """
         if self.dtype == bool:
             var = tk.BooleanVar()
@@ -220,8 +237,43 @@ class ControlPanelOption():
             var = tk.StringVar()
         logger.debug("Setting tk variable: (name: '%s', dtype: %s, tk_var: %s)",
                      self.name, self.dtype, var)
+        if track_modified and self._command is not None:
+            logger.debug("Tracking variable modification: %s", self.name)
+            var.trace("w",
+                      lambda name, index, mode, cmd=self._command: self._modified_callback(cmd))
+
+        if track_modified and self._command in ("train", "convert") and self.title == "Model Dir":
+            var.trace("w", lambda name, index, mode, v=var: self._model_callback(v))
+
         return var
 
+    @staticmethod
+    def _modified_callback(command):
+        """ Set the modified variable for this tab to TRUE
+
+        On initial setup the notebook won't yet exist, and we don't want to track the changes
+        for initial variables anyway, so make sure notebook exists prior to performing the callback
+        """
+        config = get_config()
+        if config.command_notebook is None:
+            return
+        config.set_modified_true(command)
+
+    @staticmethod
+    def _model_callback(var):
+        """ Set a callback to load model stats for existing models when a model
+        folder is selected """
+        config = get_config()
+        if not config.user_config_dict["auto_load_model_stats"]:
+            logger.debug("Session updating disabled by user config")
+            return
+        if config.tk_vars["runningtask"].get():
+            logger.debug("Task running. Not updating session")
+            return
+        folder = var.get()
+        logger.debug("Setting analysis model folder callback: '%s'", folder)
+        get_config().tk_vars["analysis_folder"].set(folder)
+
 
 class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
     """
@@ -233,7 +285,7 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
 
     Parameters
     ----------
-    parent: tk object
+    parent: tkinter object
         Parent widget that should hold this control panel
     options: list of  ControlPanelOptions objects
         The list of controls that are to be built into this control panel
@@ -242,18 +294,18 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         Defaults to 20
     columns: int, optional
         The maximum number of columns that this control panel should be able
-        to accomodate. Setting to 1 means that there will only be 1 column
+        to accommodate. Setting to 1 means that there will only be 1 column
         regardless of how wide the control panel is. Higher numbers will
         dynamically fill extra columns if space permits. Defaults to 1
     option_columns: int, optional
-        For checkbutton and radiobutton containers, how many options should
+        For check-button and radio-button containers, how many options should
         be displayed on each row. Defaults to 4
     header_text: str, optional
         If provided, will place an information box at the top of the control
         panel with these contents.
     blank_nones: bool, optional
-        How the control panel should handle Nones. If set to True then Nones
-        will be converted to empty strings. Default: False
+        How the control panel should handle None values. If set to True then None values will be
+        converted to empty strings. Default: False
     """
 
     def __init__(self, parent, options,  # pylint:disable=too-many-arguments
@@ -285,8 +337,14 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
 
         logger.debug("Initialized %s", self.__class__.__name__)
 
+    @staticmethod
+    def _adjust_wraplength(event):
+        """ dynamically adjust the wrap length of a label on event """
+        label = event.widget
+        label.configure(wraplength=event.width - 1)
+
     def get_opts_frame(self):
-        """ Return an autofill container for the options inside a main frame """
+        """ Return an auto-fill container for the options inside a main frame """
         mainframe = ttk.Frame(self.canvas)
         if self.header_text is not None:
             self.add_info(mainframe)
@@ -315,7 +373,7 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
                 continue
             style = "Header.TLabel" if idx == 0 else "Body.TLabel"
             info = ttk.Label(label_frame, text=line, style=style, anchor=tk.W)
-            info.bind("<Configure>", adjust_wraplength)
+            info.bind("<Configure>", self._adjust_wraplength)
             info.pack(fill=tk.X, padx=0, pady=0, expand=True, side=tk.TOP)
 
     def build_panel(self, blank_nones):
@@ -396,7 +454,7 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
 
 
 class AutoFillContainer():
-    """ A container object that autofills columns """
+    """ A container object that auto-fills columns """
     def __init__(self, parent, columns):
         logger.debug("Initializing: %s: (parent: %s, columns: %s)", self.__class__.__name__,
                      parent, columns)
@@ -425,12 +483,12 @@ class AutoFillContainer():
 
     @property
     def items(self):
-        """ Returns the number of items held in this containter """
+        """ Returns the number of items held in this container """
         return self._items
 
     @property
     def subframe(self):
-        """ Returns the next subframe to be populated """
+        """ Returns the next sub-frame to be populated """
         frame = self.subframes[self._idx]
         next_idx = self._idx + 1 if self._idx + 1 < self.columns else 0
         logger.debug("current_idx: %s, next_idx: %s", self._idx, next_idx)
@@ -439,7 +497,7 @@ class AutoFillContainer():
         return frame
 
     def set_subframes(self):
-        """ Set a subrame for each possible column """
+        """ Set a sub-frame for each possible column """
         subframes = []
         for idx in range(self.max_columns):
             name = "af_subframe_{}".format(idx)
@@ -520,7 +578,7 @@ class AutoFillContainer():
     def config_cleaner(widget):
         """ Some options don't like to be copied, so this returns a cleaned
             configuration from a widget
-            We use config() instead of configure() because some items (TScale) do
+            We use config() instead of configure() because some items (ttk Scale) do
             not populate configure()"""
         new_config = dict()
         for key in widget.config():
@@ -569,7 +627,7 @@ class AutoFillContainer():
                 parent = new_children[old_children.index(widget_dict["parent"])]
                 logger.trace("old parent: '%s', new_parent: '%s'", widget_dict["parent"], parent)
             else:
-                # Get the next subframe if this doesn't have a logged parent
+                # Get the next sub-frame if this doesn't have a logged parent
                 parent = self.subframe
             clone = widget_dict["class"](parent, name=widget_dict["name"])
             if widget_dict["config"] is not None:
@@ -600,11 +658,11 @@ class ControlBuilder():
     option: ControlPanelOption object
         Holds all of the required option information
     option_columns: int
-        Number of options to put on a single row for checkbuttons/radiobuttons
+        Number of options to put on a single row for check-buttons/radio-buttons
     label_width: int
         Sets the width of the control label
-    checkbuttons_frame: tk.frame
-        If a checkbutton frame is passed in, then checkbuttons will be placed in this frame
+    checkbuttons_frame: tkinter.frame
+        If a check-button frame is passed in, then check-buttons will be placed in this frame
         rather than the main options frame
     blank_nones: bool
         Sets selected values to an empty string rather than None if this is true.
@@ -629,7 +687,7 @@ class ControlBuilder():
         self.build_control()
         logger.debug("Initialized: %s", self.__class__.__name__)
 
-    # Frame, control type and varable
+    # Frame, control type and variable
     def control_frame(self, parent):
         """ Frame to hold control and it's label """
         logger.debug("Build control frame")
@@ -660,7 +718,7 @@ class ControlBuilder():
         lbl = ttk.Label(self.frame, text=self.option.title, width=self.label_width, anchor=tk.W)
         lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
         if self.option.helptext is not None:
-            get_tooltip(lbl, text=self.option.helptext, wraplength=600)
+            _get_tooltip(lbl, text=self.option.helptext, wraplength=600)
         logger.debug("Built control label: (widget: '%s', title: '%s'",
                      self.option.name, self.option.title)
 
@@ -678,7 +736,7 @@ class ControlBuilder():
         if self.option.control != ttk.Checkbutton:
             ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
             if self.option.helptext is not None and not self.helpset:
-                get_tooltip(ctl, text=self.option.helptext, wraplength=600)
+                _get_tooltip(ctl, text=self.option.helptext, wraplength=600)
 
         logger.debug("Built control: '%s'", self.option.name)
 
@@ -707,7 +765,7 @@ class ControlBuilder():
                 helptext = "{}\n\n - {}".format(
                     '. '.join(item.capitalize() for item in helptext.split('. ')),
                     intro)
-                get_tooltip(radio, text=helptext, wraplength=600)
+                _get_tooltip(radio, text=helptext, wraplength=600)
             radio.pack(anchor=tk.W)
             logger.debug("Added radio option %s", choice)
         return radio_holder.parent
@@ -729,8 +787,8 @@ class ControlBuilder():
                       round_to=self.option.rounding,
                       min_max=self.option.min_max)
         ctl = self.option.control(self.frame, variable=self.option.tk_var, command=cmd)
-        add_command(ctl.cget("command"), cmd)
-        rc_menu = get_contextmenu(tbox)
+        _add_command(ctl.cget("command"), cmd)
+        rc_menu = _get_contextmenu(tbox)
         rc_menu.cm_bind()
         ctl["from_"] = self.option.min_max[0]
         ctl["to"] = self.option.min_max[1]
@@ -745,13 +803,14 @@ class ControlBuilder():
             ctl = self.option.control(self.frame, variable=self.option.tk_var, text=None)
         else:
             if self.option.sysbrowser is not None:
-                self.filebrowser = FileBrowser(self.option.tk_var,
+                self.filebrowser = FileBrowser(self.option.name,
+                                               self.option.tk_var,
                                                self.frame,
                                                self.option.sysbrowser)
             ctl = self.option.control(self.frame,
                                       textvariable=self.option.tk_var,
                                       font=get_config().default_font)
-            rc_menu = get_contextmenu(ctl)
+            rc_menu = _get_contextmenu(ctl)
             rc_menu.cm_bind()
         if self.option.choices:
             logger.debug("Adding combo choices: %s", self.option.choices)
@@ -760,14 +819,14 @@ class ControlBuilder():
         return ctl
 
     def control_to_checkframe(self):
-        """ Add checkbuttons to the checkbutton frame """
+        """ Add check-buttons to the check-button frame """
         logger.debug("Add control checkframe: '%s'", self.option.name)
         chkframe = self.chkbtns.subframe
         ctl = self.option.control(chkframe,
                                   variable=self.option.tk_var,
                                   text=self.option.title,
                                   name=self.option.name)
-        get_tooltip(ctl, text=self.option.helptext, wraplength=600)
+        _get_tooltip(ctl, text=self.option.helptext, wraplength=600)
         ctl.pack(side=tk.TOP, anchor=tk.W)
         logger.debug("Added control checkframe: '%s'", self.option.name)
         return ctl
@@ -775,9 +834,10 @@ class ControlBuilder():
 
 class FileBrowser():
     """ Add FileBrowser buttons to control and handle routing """
-    def __init__(self, tk_var, control_frame, sysbrowser_dict):
+    def __init__(self, opt_name, tk_var, control_frame, sysbrowser_dict):
         logger.debug("Initializing: %s: (tk_var: %s, control_frame: %s, sysbrowser_dict: %s)",
                      self.__class__.__name__, tk_var, control_frame, sysbrowser_dict)
+        self._opt_name = opt_name
         self.tk_var = tk_var
         self.frame = control_frame
         self.browser = sysbrowser_dict["browser"]
@@ -793,9 +853,13 @@ class FileBrowser():
         """ Dict containing tooltip text for buttons """
         retval = dict(folder="Select a folder...",
                       load="Select a file...",
-                      load_multi="Select one or more files...",
+                      load2="Select a file...",
+                      picture="Select a folder of images...",
+                      video="Select a video...",
+                      model="Select a model folder...",
+                      multi_load="Select one or more files...",
                       context="Select a file or folder...",
-                      save="Select a save location...")
+                      save_as="Select a save location...")
         return retval
 
     @staticmethod
@@ -812,14 +876,30 @@ class FileBrowser():
     def add_browser_buttons(self):
         """ Add correct file browser button for control """
         logger.debug("Adding browser buttons: (sysbrowser: %s", self.browser)
+        frame = ttk.Frame(self.frame)
+        frame.pack(side=tk.RIGHT, padx=(0, 5))
+
         for browser in self.browser:
-            img = get_images().icons[browser]
+            if browser == "save":
+                lbl = "save_as"
+            elif browser == "load" and self.filetypes == "video":
+                lbl = self.filetypes
+            elif browser == "load":
+                lbl = "load2"
+            elif browser == "folder" and (self._opt_name.startswith(("frames", "faces"))
+                                          or "input" in self._opt_name):
+                lbl = "picture"
+            elif browser == "folder" and "model" in self._opt_name:
+                lbl = "model"
+            else:
+                lbl = browser
+            img = get_images().icons[lbl]
             action = getattr(self, "ask_" + browser)
             cmd = partial(action, filepath=self.tk_var, filetypes=self.filetypes)
-            fileopn = ttk.Button(self.frame, image=img, command=cmd)
-            add_command(fileopn.cget("command"), cmd)
-            fileopn.pack(padx=(0, 5), side=tk.RIGHT)
-            get_tooltip(fileopn, text=self.helptext[browser], wraplength=600)
+            fileopn = ttk.Button(frame, image=img, command=cmd)
+            _add_command(fileopn.cget("command"), cmd)
+            fileopn.pack(padx=0, side=tk.RIGHT)
+            _get_tooltip(fileopn, text=self.helptext[lbl], wraplength=600)
             logger.debug("Added browser buttons: (action: %s, filetypes: %s",
                          action, self.filetypes)
 
@@ -853,7 +933,7 @@ class FileBrowser():
             filepath.set(filename)
 
     @staticmethod
-    def ask_load_multi(filepath, filetypes):
+    def ask_multi_load(filepath, filetypes):
         """ Pop-up to get path to a file """
         filenames = FileHandler("filename_multi", filetypes).retfile
         if filenames:
diff --git a/lib/gui/custom_widgets.py b/lib/gui/custom_widgets.py
new file mode 100644
index 0000000..4d29092
--- /dev/null
+++ b/lib/gui/custom_widgets.py
@@ -0,0 +1,635 @@
+#!/usr/bin/env python3
+""" Custom widgets for Faceswap GUI """
+
+import logging
+import platform
+import re
+import sys
+import tkinter as tk
+from tkinter import ttk, TclError
+
+from .utils import get_config
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
+
+class ContextMenu(tk.Menu):  # pylint: disable=too-many-ancestors
+    """ A Pop up menu to be triggered when right clicking on widgets that this menu has been
+    applied to.
+
+    This widget provides a simple right click pop up menu to the widget passed in with `Cut`,
+    `Copy`, `Paste` and `Select all` menu items.
+
+    Parameters
+    ----------
+    widget: tkinter object
+        The widget to apply the :class:`ContextMenu` to
+
+    Example
+    -------
+    >>> text_box = ttk.Entry(parent)
+    >>> text_box.pack()
+    >>> right_click_menu = ContextMenu(text_box)
+    >>> right_click_menu.cm_bind()
+    """
+    def __init__(self, widget):
+        logger.debug("Initializing %s: (widget_class: '%s')",
+                     self.__class__.__name__, widget.winfo_class())
+        super().__init__(tearoff=0)
+        self._widget = widget
+        self._standard_actions()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def _standard_actions(self):
+        """ Standard menu actions """
+        self.add_command(label="Cut", command=lambda: self._widget.event_generate("<<Cut>>"))
+        self.add_command(label="Copy", command=lambda: self._widget.event_generate("<<Copy>>"))
+        self.add_command(label="Paste", command=lambda: self._widget.event_generate("<<Paste>>"))
+        self.add_separator()
+        self.add_command(label="Select all", command=self._select_all)
+
+    def cm_bind(self):
+        """ Bind the menu to the given widgets Right Click event
+
+        After associating a widget with this :class:`ContextMenu` this function should be called
+        to bind it to the right click button
+        """
+        button = "<Button-2>" if platform.system() == "Darwin" else "<Button-3>"
+        logger.debug("Binding '%s' to '%s'", button, self._widget.winfo_class())
+        scaling_factor = get_config().scaling_factor if get_config() is not None else 1.0
+        x_offset = int(34 * scaling_factor)
+        self._widget.bind(button,
+                          lambda event: self.tk_popup(event.x_root + x_offset, event.y_root, 0))
+
+    def _select_all(self):
+        """ Select all for Text or Entry widgets """
+        logger.debug("Selecting all for '%s'", self._widget.winfo_class())
+        if self._widget.winfo_class() == "Text":
+            self._widget.focus_force()
+            self._widget.tag_add("sel", "1.0", "end")
+        else:
+            self._widget.focus_force()
+            self._widget.select_range(0, tk.END)
+
+
+class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
+    """ The Console out section of the GUI.
+
+    A Read only text box for displaying the output from stdout/stderr.
+
+    All handling is internal to this method. To clear the console, the stored tkinter variable in
+    :attr:`~lib.gui.Config.tk_vars` ``consoleclear`` should be triggered.
+
+    Parameters
+    ----------
+    parent: tkinter object
+        The Console's parent widget
+    debug: bool
+        ``True`` if console output should not be directed to this widget otherwise ``False``
+
+    """
+
+    def __init__(self, parent, debug):
+        logger.debug("Initializing %s: (parent: %s, debug: %s)",
+                     self.__class__.__name__, parent, debug)
+        super().__init__(parent)
+        self.pack(side=tk.TOP, anchor=tk.W, padx=10, pady=(2, 0),
+                  fill=tk.BOTH, expand=True)
+        self._console = _ReadOnlyText(self)
+        rc_menu = ContextMenu(self._console)
+        rc_menu.cm_bind()
+        self._console_clear = get_config().tk_vars['consoleclear']
+        self._set_console_clear_var_trace()
+        self._debug = debug
+        self._build_console()
+        self._add_tags()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def _set_console_clear_var_trace(self):
+        """ Set a trace on the consoleclear tkinter variable to trigger :func:`_clear` """
+        logger.debug("Set clear trace")
+        self._console_clear.trace("w", self._clear)
+
+    def _build_console(self):
+        """ Build and place the console  and add stdout/stderr redirection """
+        logger.debug("Build console")
+        self._console.config(width=100, height=6, bg="gray90", fg="black")
+        self._console.pack(side=tk.LEFT, anchor=tk.N, fill=tk.BOTH, expand=True)
+
+        scrollbar = ttk.Scrollbar(self, command=self._console.yview)
+        scrollbar.pack(side=tk.LEFT, fill="y")
+        self._console.configure(yscrollcommand=scrollbar.set)
+
+        self._redirect_console()
+        logger.debug("Built console")
+
+    def _add_tags(self):
+        """ Add tags to text widget to color based on output """
+        logger.debug("Adding text color tags")
+        self._console.tag_config("default", foreground="#1E1E1E")
+        self._console.tag_config("stderr", foreground="#E25056")
+        self._console.tag_config("info", foreground="#2B445E")
+        self._console.tag_config("verbose", foreground="#008140")
+        self._console.tag_config("warning", foreground="#F77B00")
+        self._console.tag_config("critical", foreground="red")
+        self._console.tag_config("error", foreground="red")
+
+    def _redirect_console(self):
+        """ Redirect stdout/stderr to console Text Box """
+        logger.debug("Redirect console")
+        if self._debug:
+            logger.info("Console debug activated. Outputting to main terminal")
+        else:
+            sys.stdout = _SysOutRouter(self._console, "stdout")
+            sys.stderr = _SysOutRouter(self._console, "stderr")
+        logger.debug("Redirected console")
+
+    def _clear(self, *args):  # pylint: disable=unused-argument
+        """ Clear the console output screen """
+        logger.debug("Clear console")
+        if not self._console_clear.get():
+            logger.debug("Console not set for clearing. Skipping")
+            return
+        self._console.delete(1.0, tk.END)
+        self._console_clear.set(False)
+        logger.debug("Cleared console")
+
+
+class _ReadOnlyText(tk.Text):  # pylint: disable=too-many-ancestors
+    """ A read only text widget.
+
+    Standard tkinter Text widgets are read/write by default. As we want to make the console
+    display writable by the Faceswap process but not the user, we need to redirect its insert and
+    delete attributes.
+
+    Source: https://stackoverflow.com/questions/3842155
+    """
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.redirector = _WidgetRedirector(self)
+        self.insert = self.redirector.register("insert", lambda *args, **kw: "break")
+        self.delete = self.redirector.register("delete", lambda *args, **kw: "break")
+
+
+class _SysOutRouter():
+    """ Route stdout/stderr to the given text box.
+
+    Parameters
+    ----------
+    console: tkinter Object
+        The widget that will receive the output from stderr/stdout
+    out_type: ['stdout', 'stderr']
+        The output type to redirect
+    """
+
+    def __init__(self, console, out_type):
+        logger.debug("Initializing %s: (console: %s, out_type: '%s')",
+                     self.__class__.__name__, console, out_type)
+        self._console = console
+        self._out_type = out_type
+        self._recolor = re.compile(r".+?(\s\d+:\d+:\d+\s)(?P<lvl>[A-Z]+)\s")
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def _get_tag(self, string):
+        """ Set the tag based on regex of log output """
+        if self._out_type == "stderr":
+            # Output all stderr in red
+            return self._out_type
+
+        output = self._recolor.match(string)
+        if not output:
+            return "default"
+        tag = output.groupdict()["lvl"].strip().lower()
+        return tag
+
+    def write(self, string):
+        """ Capture stdout/stderr """
+        self._console.insert(tk.END, string, self._get_tag(string))
+        self._console.see(tk.END)
+
+    @staticmethod
+    def flush():
+        """ If flush is forced, send it to normal terminal """
+        sys.__stdout__.flush()
+
+
+class _WidgetRedirector:
+    """Support for redirecting arbitrary widget sub-commands.
+
+    Some Tk operations don't normally pass through tkinter.  For example, if a
+    character is inserted into a Text widget by pressing a key, a default Tk
+    binding to the widget's 'insert' operation is activated, and the Tk library
+    processes the insert without calling back into tkinter.
+
+    Although a binding to <Key> could be made via tkinter, what we really want
+    to do is to hook the Tk 'insert' operation itself.  For one thing, we want
+    a text.insert call in idle code to have the same effect as a key press.
+
+    When a widget is instantiated, a Tcl command is created whose name is the
+    same as the path name widget._w.  This command is used to invoke the various
+    widget operations, e.g. insert (for a Text widget). We are going to hook
+    this command and provide a facility ('register') to intercept the widget
+    operation.  We will also intercept method calls on the tkinter class
+    instance that represents the tk widget.
+
+    In IDLE, WidgetRedirector is used in Percolator to intercept Text
+    commands.  The function being registered provides access to the top
+    of a Percolator chain.  At the bottom of the chain is a call to the
+    original Tk widget operation.
+
+    Attributes
+    -----------
+    _operations: dict
+        Dictionary mapping operation name to new function. widget: the widget whose tcl command
+        is to be intercepted.
+    tk: widget.tk
+        A convenience attribute, probably not needed.
+    orig: str
+        new name of the original tcl command.
+
+    Notes
+    -----
+    Since renaming to orig fails with TclError when orig already exists, only one
+    WidgetDirector can exist for a given widget.
+    """
+    def __init__(self, widget):
+        self._operations = {}
+        self.widget = widget                                # widget instance
+        self.tk_ = tk_ = widget.tk                          # widget's root
+        wgt = widget._w  # pylint:disable=protected-access  # widget's (full) Tk pathname
+        self.orig = wgt + "_orig"
+        # Rename the Tcl command within Tcl:
+        tk_.call("rename", wgt, self.orig)
+        # Create a new Tcl command whose name is the widget's path name, and
+        # whose action is to dispatch on the operation passed to the widget:
+        tk_.createcommand(wgt, self.dispatch)
+
+    def __repr__(self):
+        return "%s(%s<%s>)" % (self.__class__.__name__,
+                               self.widget.__class__.__name__,
+                               self.widget._w)  # pylint:disable=protected-access
+
+    def close(self):
+        "Unregister operations and revert redirection created by .__init__."
+        for operation in list(self._operations):
+            self.unregister(operation)
+        widget = self.widget
+        tk_ = widget.tk
+        wgt = widget._w  # pylint:disable=protected-access
+        # Restore the original widget Tcl command.
+        tk_.deletecommand(wgt)
+        tk_.call("rename", self.orig, wgt)
+        del self.widget, self.tk_  # Should not be needed
+        # if instance is deleted after close, as in Percolator.
+
+    def register(self, operation, function):
+        """Return _OriginalCommand(operation) after registering function.
+
+        Registration adds an operation: function pair to ._operations.
+        It also adds a widget function attribute that masks the tkinter
+        class instance method.  Method masking operates independently
+        from command dispatch.
+
+        If a second function is registered for the same operation, the
+        first function is replaced in both places.
+        """
+        self._operations[operation] = function
+        setattr(self.widget, operation, function)
+        return _OriginalCommand(self, operation)
+
+    def unregister(self, operation):
+        """Return the function for the operation, or None.
+
+        Deleting the instance attribute unmasks the class attribute.
+        """
+        if operation in self._operations:
+            function = self._operations[operation]
+            del self._operations[operation]
+            try:
+                delattr(self.widget, operation)
+            except AttributeError:
+                pass
+            return function
+        return None
+
+    def dispatch(self, operation, *args):
+        """Callback from Tcl which runs when the widget is referenced.
+
+        If an operation has been registered in self._operations, apply the
+        associated function to the args passed into Tcl. Otherwise, pass the
+        operation through to Tk via the original Tcl function.
+
+        Note that if a registered function is called, the operation is not
+        passed through to Tk.  Apply the function returned by self.register()
+        to *args to accomplish that.  For an example, see colorizer.py.
+
+        """
+        op_ = self._operations.get(operation)
+        try:
+            if op_:
+                return op_(*args)
+            return self.tk_.call((self.orig, operation) + args)
+        except TclError:
+            return ""
+
+
+class _OriginalCommand:
+    """Callable for original tk command that has been redirected.
+
+    Returned by .register; can be used in the function registered.
+    redir = WidgetRedirector(text)
+    def my_insert(*args):
+        print("insert", args)
+        original_insert(*args)
+    original_insert = redir.register("insert", my_insert)
+    """
+
+    def __init__(self, redir, operation):
+        """Create .tk_call and .orig_and_operation for .__call__ method.
+
+        .redir and .operation store the input args for __repr__.
+        .tk and .orig copy attributes of .redir (probably not needed).
+        """
+        self.redir = redir
+        self.operation = operation
+        self.tk_ = redir.tk_  # redundant with self.redir
+        self.orig = redir.orig  # redundant with self.redir
+        # These two could be deleted after checking recipient code.
+        self.tk_call = redir.tk_.call
+        self.orig_and_operation = (redir.orig, operation)
+
+    def __repr__(self):
+        return "%s(%r, %r)" % (self.__class__.__name__,
+                               self.redir, self.operation)
+
+    def __call__(self, *args):
+        return self.tk_call(self.orig_and_operation + args)
+
+
+class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
+    """ Status Bar for displaying the Status Message and  Progress Bar at the
+    bottom of the GUI. """
+
+    def __init__(self, parent):
+        ttk.Frame.__init__(self, parent)
+        self.pack(side=tk.BOTTOM, padx=10, pady=2, fill=tk.X, expand=False)
+
+        self._status_message = tk.StringVar()
+        self._pbar_message = tk.StringVar()
+        self._pbar_position = tk.IntVar()
+
+        self._status_message.set("Ready")
+
+        self._status()
+        self._pbar = self._progress_bar()
+
+    @property
+    def status_message(self):
+        """:class:`tkinter.StringVar`: The variable to hold the status bar message on the left
+        hand side of the status bar. """
+        return self._status_message
+
+    def _status(self):
+        """ Place Status label into left of the status bar. """
+        statusframe = ttk.Frame(self)
+        statusframe.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=False)
+
+        lbltitle = ttk.Label(statusframe, text="Status:", width=6, anchor=tk.W)
+        lbltitle.pack(side=tk.LEFT, expand=False)
+
+        lblstatus = ttk.Label(statusframe,
+                              width=40,
+                              textvariable=self._status_message,
+                              anchor=tk.W)
+        lblstatus.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=True)
+
+    def _progress_bar(self):
+        """ Place progress bar into right of the status bar. """
+        progressframe = ttk.Frame(self)
+        progressframe.pack(side=tk.RIGHT, anchor=tk.E, fill=tk.X)
+
+        lblmessage = ttk.Label(progressframe, textvariable=self._pbar_message)
+        lblmessage.pack(side=tk.LEFT, padx=3, fill=tk.X, expand=True)
+
+        pbar = ttk.Progressbar(progressframe,
+                               length=200,
+                               variable=self._pbar_position,
+                               maximum=100,
+                               mode="determinate")
+        pbar.pack(side=tk.LEFT, padx=2, fill=tk.X, expand=True)
+        pbar.pack_forget()
+        return pbar
+
+    def progress_start(self, mode):
+        """ Set progress bar mode and display,
+
+        Parameters
+        ----------
+        mode: ["indeterminate", "determinate"]
+            The mode that the progress bar should be executed in
+        """
+        self._progress_set_mode(mode)
+        self._pbar.pack()
+
+    def progress_stop(self):
+        """ Reset progress bar and hide """
+        self._pbar_message.set("")
+        self._pbar_position.set(0)
+        self._progress_set_mode("determinate")
+        self._pbar.pack_forget()
+
+    def _progress_set_mode(self, mode):
+        """ Set the progress bar mode """
+        self._pbar.config(mode=mode)
+        if mode == "indeterminate":
+            self._pbar.config(maximum=100)
+            self._pbar.start()
+        else:
+            self._pbar.stop()
+            self._pbar.config(maximum=100)
+
+    def progress_update(self, message, position, update_position=True):
+        """ Update the GUIs progress bar and position.
+
+        Parameters
+        ----------
+        message: str
+            The message to display next to the progress bar
+        position: int
+            The position that the progress bar should be set to
+        update_position: bool, optional
+            If ``True`` then the progress bar will be updated to the position given in
+            :attr:`position`. If ``False`` the progress bar will not be updates. Default: ``True``
+        """
+        self._pbar_message.set(message)
+        if update_position:
+            self._pbar_position.set(position)
+
+
+class Tooltip:
+    """
+    Create a tooltip for a given widget as the mouse goes on it.
+
+    Parameters
+    ----------
+    widget: tkinter object
+        The widget to apply the tool-tip to
+    background: str, optional
+        The hex code for the background color. Default:'#FFFFEA'
+    pad: tuple, optional
+        (left, top, right, bottom) padding for the tool-tip. Default: (5, 3, 5, 3)
+    text: str, optional
+        The text to be displayed in the tool-tip. Default: 'widget info'
+    waittime: int, optional
+        The time in miliseconds to wait before showing the tool-tip. Default: 400
+    wraplength: int, optional
+        The text length for each line before wrapping. Default: 250
+
+    Example
+    -------
+    >>> button = ttk.Button(parent, text="Exit")
+    >>> Tooltip(button, text="Click to exit")
+    >>> button.pack()
+
+    Notes
+    -----
+    Adapted from StackOverflow: http://stackoverflow.com/questions/3221956 and
+    http://www.daniweb.com/programming/software-development/code/484591/a-tooltip-class-for-tkinter
+
+
+    - Originally written by vegaseat on 2014.09.09.
+    - Modified to include a delay time by Victor Zaccardo on 2016.03.25.
+    - Modified to correct extreme right and extreme bottom behavior by Alberto Vassena on \
+        2016.11.05.
+    - Modified to stay inside the screen whenever the tooltip might go out on the top but still \
+        the screen is higher than the tooltip  by Alberto Vassena on 2016.11.05.
+    - Modified to use the more flexible mouse positioning  by Alberto Vassena on 2016.11.05.
+    - Modified to add customizable background color, padding, waittime and wraplength on creation \
+        by Alberto Vassena on 2016.11.05.
+
+    Tested on Ubuntu 16.04/16.10, running Python 3.5.2
+    """
+    def __init__(self, widget, *, background="#FFFFEA", pad=(5, 3, 5, 3), text="widget info",
+                 waittime=400, wraplength=250):
+
+        self._waittime = waittime  # in milliseconds, originally 500
+        self._wraplength = wraplength  # in pixels, originally 180
+        self._widget = widget
+        self._text = text
+        self._widget.bind("<Enter>", self._on_enter)
+        self._widget.bind("<Leave>", self._on_leave)
+        self._widget.bind("<ButtonPress>", self._on_leave)
+        self._background = background
+        self._pad = pad
+        self._ident = None
+        self._topwidget = None
+
+    def _on_enter(self, event=None):  # pylint:disable=unused-argument
+        """ Schedule on an enter event """
+        self._schedule()
+
+    def _on_leave(self, event=None):  # pylint:disable=unused-argument
+        """ Unschedule on a leave event """
+        self._unschedule()
+        self._hide()
+
+    def _schedule(self):
+        """ Show the tooltip after wait period """
+        self._unschedule()
+        self._ident = self._widget.after(self._waittime, self._show)
+
+    def _unschedule(self):
+        """ Hide the tooltip """
+        id_ = self._ident
+        self._ident = None
+        if id_:
+            self._widget.after_cancel(id_)
+
+    def _show(self):
+        """ Show the tooltip """
+        def tip_pos_calculator(widget, label,
+                               *,
+                               tip_delta=(10, 5), pad=(5, 3, 5, 3)):
+            """ Calculate the tooltip position """
+
+            s_width, s_height = widget.winfo_screenwidth(), widget.winfo_screenheight()
+
+            width, height = (pad[0] + label.winfo_reqwidth() + pad[2],
+                             pad[1] + label.winfo_reqheight() + pad[3])
+
+            mouse_x, mouse_y = widget.winfo_pointerxy()
+
+            x_1, y_1 = mouse_x + tip_delta[0], mouse_y + tip_delta[1]
+            x_2, y_2 = x_1 + width, y_1 + height
+
+            x_delta = x_2 - s_width
+            if x_delta < 0:
+                x_delta = 0
+            y_delta = y_2 - s_height
+            if y_delta < 0:
+                y_delta = 0
+
+            offscreen = (x_delta, y_delta) != (0, 0)
+
+            if offscreen:
+
+                if x_delta:
+                    x_1 = mouse_x - tip_delta[0] - width
+
+                if y_delta:
+                    y_1 = mouse_y - tip_delta[1] - height
+
+            offscreen_again = y_1 < 0  # out on the top
+
+            if offscreen_again:
+                # No further checks will be done.
+
+                # TIP:
+                # A further mod might auto-magically augment the
+                # wraplength when the tooltip is too high to be
+                # kept inside the screen.
+                y_1 = 0
+
+            return x_1, y_1
+
+        background = self._background
+        pad = self._pad
+        widget = self._widget
+
+        # creates a toplevel window
+        self._topwidget = tk.Toplevel(widget)
+        if platform.system() == "Darwin":
+            # For Mac OS
+            self._topwidget.tk.call("::tk::unsupported::MacWindowStyle",
+                                    "style", self._topwidget._w,  # pylint:disable=protected-access
+                                    "help", "none")
+
+        # Leaves only the label and removes the app window
+        self._topwidget.wm_overrideredirect(True)
+
+        win = tk.Frame(self._topwidget,
+                       background=background,
+                       borderwidth=0)
+        label = tk.Label(win,
+                         text=self._text,
+                         justify=tk.LEFT,
+                         background=background,
+                         relief=tk.SOLID,
+                         borderwidth=0,
+                         wraplength=self._wraplength)
+
+        label.grid(padx=(pad[0], pad[2]),
+                   pady=(pad[1], pad[3]),
+                   sticky=tk.NSEW)
+        win.grid()
+
+        xpos, ypos = tip_pos_calculator(widget, label)
+
+        self._topwidget.wm_geometry("+%d+%d" % (xpos, ypos))
+
+    def _hide(self):
+        """ Hide the tooltip """
+        topwidget = self._topwidget
+        if topwidget:
+            topwidget.destroy()
+        self._topwidget = None
diff --git a/lib/gui/display_analysis.py b/lib/gui/display_analysis.py
index bebf267..8bd3da2 100644
--- a/lib/gui/display_analysis.py
+++ b/lib/gui/display_analysis.py
@@ -11,7 +11,7 @@ from .control_helper import ControlBuilder, ControlPanelOption
 from .display_graph import SessionGraph
 from .display_page import DisplayPage
 from .stats import Calculations, Session
-from .tooltip import Tooltip
+from .custom_widgets import Tooltip
 from .utils import FileHandler, get_config, get_images, LongRunningTask
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -29,13 +29,15 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         self.add_options()
         self.add_main_frame()
         self.thread = None  # Thread for compiling stats data in background
-        self.set_training_callback()
+        self.set_callbacks()
         logger.debug("Initialized: %s", self.__class__.__name__)
 
-    def set_training_callback(self):
+    def set_callbacks(self):
         """ Add a callback to update analysis when the training graph is updated """
-        get_config().tk_vars["refreshgraph"].trace("w", self.update_current_session)
-        get_config().tk_vars["istraining"].trace("w", self.remove_current_session)
+        tkv = get_config().tk_vars
+        tkv["refreshgraph"].trace("w", self.update_current_session)
+        tkv["istraining"].trace("w", self.remove_current_session)
+        tkv["analysis_folder"].trace("w", self.populate_from_folder)
 
     def update_current_session(self, *args):  # pylint:disable=unused-argument
         """ Update the current session data on a graph update callback """
@@ -57,7 +59,7 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         return {"selected_id": selected_id}
 
     def add_main_frame(self):
-        """ Add the main frame to the subnotebook
+        """ Add the main frame to the sub-notebook
             to hold stats and session data """
         logger.debug("Adding main frame")
         mainframe = self.subnotebook_add_page("stats")
@@ -79,12 +81,38 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
         logger.debug("Resetting session info")
         self.set_info("No session data loaded")
 
-    def load_session(self):
+    def populate_from_folder(self, *args):  # pylint:disable=unused-argument
+        """ Populate the Analysis tab from just a model folder. Triggered
+        when tkinter variable ``analysis_folder`` is set.
+        """
+        folder = get_config().tk_vars["analysis_folder"].get()
+        if not folder or not os.path.isdir(folder):
+            logger.debug("Not a valid folder")
+            self.clear_session()
+            return
+
+        state_files = [fname
+                       for fname in os.listdir(folder)
+                       if fname.endswith("_state.json")]
+        if not state_files:
+            logger.debug("No state files found in folder: '%s'", folder)
+            self.clear_session()
+            return
+
+        state_file = state_files[0]
+        if len(state_files) > 1:
+            logger.debug("Multiple models found. Selecting: '%s'", state_file)
+
+        if self.thread is None:
+            self.load_session(fullpath=os.path.join(folder, state_file))
+
+    def load_session(self, fullpath=None):
         """ Load previously saved sessions """
         logger.debug("Loading session")
-        fullpath = FileHandler("filename", "state").retfile
-        if not fullpath:
-            return
+        if fullpath is None:
+            fullpath = FileHandler("filename", "state").retfile
+            if not fullpath:
+                return
         self.clear_session()
         logger.debug("state_file: '%s'", fullpath)
         model_dir, state_file = os.path.split(fullpath)
@@ -155,7 +183,7 @@ class Analysis(DisplayPage):  # pylint: disable=too-many-ancestors
 
     @staticmethod
     def summarise_data(session):
-        """ Summarise data in a LongRunningThread as it can take a while """
+        """ Summarize data in a LongRunningThread as it can take a while """
         return session.full_summary
 
     def clear_session(self):
@@ -217,10 +245,10 @@ class Options():
 
     @staticmethod
     def set_help(btntype):
-        """ Set the helptext for option buttons """
+        """ Set the help text for option buttons """
         logger.debug("Setting help")
         hlp = ""
-        if btntype == "reset":
+        if btntype == "reload":
             hlp = "Load/Refresh stats for the currently training session"
         elif btntype == "clear":
             hlp = "Clear currently displayed session stats"
@@ -261,7 +289,7 @@ class StatsData(ttk.Frame):  # pylint: disable=too-many-ancestors
         logger.debug("Initialized: %s", self.__class__.__name__)
 
     def add_label(self):
-        """ Add Treeview Title """
+        """ Add tree-view Title """
         logger.debug("Adding Treeview title")
         lbl = ttk.Label(self.sub_frame, text="Session Stats", anchor=tk.CENTER)
         lbl.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)
@@ -275,7 +303,7 @@ class StatsData(ttk.Frame):  # pylint: disable=too-many-ancestors
         logger.debug("Resized Analysis Frame")
 
     def tree_configure(self, helptext):
-        """ Build a treeview widget to hold the sessions stats """
+        """ Build a tree-view widget to hold the sessions stats """
         logger.debug("Configuring Treeview")
         self.tree.configure(yscrollcommand=self.scrollbar.set)
         self.tree.tag_configure("total", background="black", foreground="white")
@@ -285,7 +313,7 @@ class StatsData(ttk.Frame):  # pylint: disable=too-many-ancestors
         return self.tree_columns()
 
     def tree_columns(self):
-        """ Add the columns to the totals treeview """
+        """ Add the columns to the totals tree-view """
         logger.debug("Adding Treeview columns")
         columns = (("session", 40, "#"),
                    ("start", 130, None),
@@ -307,7 +335,7 @@ class StatsData(ttk.Frame):  # pylint: disable=too-many-ancestors
         return [column[0] for column in columns]
 
     def tree_insert_data(self, sessions_summary):
-        """ Insert the data into the totals treeview """
+        """ Insert the data into the totals tree-view """
         logger.debug("Inserting treeview data")
         self.tree.configure(height=len(sessions_summary))
 
@@ -461,7 +489,7 @@ class SessionPopUp(tk.Toplevel):
         logger.debug("Built popup")
 
     def set_callback(self):
-        """ Set a tk boolean var to callback when graph is ready to build """
+        """ Set a tkinter Boolean var to callback when graph is ready to build """
         logger.debug("Setting tk graph build variable")
         var = tk.BooleanVar()
         var.set(False)
@@ -517,7 +545,7 @@ class SessionPopUp(tk.Toplevel):
             cmb.current(0)
             cmb.pack(fill=tk.X, side=tk.RIGHT)
 
-            cmd = self.optbtn_reset if item == "Display" else self.graph_scale
+            cmd = self.optbtn_reload if item == "Display" else self.graph_scale
             var.trace("w", cmd)
             self.vars[item.lower().strip()] = var
 
@@ -527,7 +555,7 @@ class SessionPopUp(tk.Toplevel):
 
     @staticmethod
     def add_section(frame, title):
-        """ Add a seperator and section title """
+        """ Add a separator and section title """
         sep = ttk.Frame(frame, height=2, relief=tk.SOLID)
         sep.pack(fill=tk.X, pady=(5, 0), side=tk.TOP)
         lbl = ttk.Label(frame, text=title)
@@ -629,7 +657,7 @@ class SessionPopUp(tk.Toplevel):
                               anchor=tk.W)
         lblstatus.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=True)
 
-        for btntype in ("reset", "save"):
+        for btntype in ("reload", "save"):
             cmd = getattr(self, "optbtn_{}".format(btntype))
             btn = ttk.Button(btnframe,
                              image=get_images().icons[btntype],
@@ -655,7 +683,7 @@ class SessionPopUp(tk.Toplevel):
             csvout.writerow(fieldnames)
             csvout.writerows(zip(*[save_data[key] for key in fieldnames]))
 
-    def optbtn_reset(self, *args):  # pylint: disable=unused-argument
+    def optbtn_reload(self, *args):  # pylint: disable=unused-argument
         """ Action for reset button press and checkbox changes"""
         logger.debug("Refreshing Graph")
         if not self.graph_initialised:
@@ -677,10 +705,10 @@ class SessionPopUp(tk.Toplevel):
 
     @staticmethod
     def set_help(control):
-        """ Set the helptext for option buttons """
+        """ Set the help text for option buttons """
         hlp = ""
         control = control.lower()
-        if control == "reset":
+        if control == "reload":
             hlp = "Refresh graph"
         elif control == "save":
             hlp = "Save display data to csv"
diff --git a/lib/gui/display_command.py b/lib/gui/display_command.py
index 6c15ff9..4626dac 100644
--- a/lib/gui/display_command.py
+++ b/lib/gui/display_command.py
@@ -10,7 +10,7 @@ from tkinter import ttk
 
 from .display_graph import TrainingGraph
 from .display_page import DisplayOptionalPage
-from .tooltip import Tooltip
+from .custom_widgets import Tooltip
 from .stats import Calculations
 from .control_helper import set_slider_rounding
 from .utils import FileHandler, get_config, get_images
diff --git a/lib/gui/display_graph.py b/lib/gui/display_graph.py
index 05a2062..6a2652c 100755
--- a/lib/gui/display_graph.py
+++ b/lib/gui/display_graph.py
@@ -17,7 +17,7 @@ from matplotlib.figure import Figure  # noqa
 from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg,
                                                NavigationToolbar2Tk)  # noqa
 
-from .tooltip import Tooltip  # noqa
+from .custom_widgets import Tooltip  # noqa
 from .utils import get_config, get_images, LongRunningTask  # noqa
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -34,7 +34,7 @@ class NavigationToolbar(NavigationToolbar2Tk):  # pylint: disable=too-many-ances
     def _Button(frame, text, file, command, extension=".gif"):  # pylint: disable=arguments-differ
         """ Map Buttons to their own frame.
             Use custom button icons, Use ttk buttons pack to the right """
-        iconmapping = {"home": "reset",
+        iconmapping = {"home": "reload",
                        "filesave": "save",
                        "zoom_to_rect": "zoom"}
         icon = iconmapping[file] if iconmapping.get(file, None) else file
@@ -44,7 +44,7 @@ class NavigationToolbar(NavigationToolbar2Tk):  # pylint: disable=too-many-ances
         return btn
 
     def _init_toolbar(self):
-        """ Same as original but ttk widgets and standard tooltips used. Separator added and
+        """ Same as original but ttk widgets and standard tool-tips used. Separator added and
             message label packed to the left """
         xmin, xmax = self.canvas.figure.bbox.intervalx
         height, width = 50, xmax-xmin
@@ -308,7 +308,7 @@ class TrainingGraph(GraphBase):  # pylint: disable=too-many-ancestors
         """ Resize the figure back to the canvas """
         class Event():  # pylint: disable=too-few-public-methods
             """ Event class that needs to be passed to plotcanvas.resize """
-            pass
+            pass  # pylint: disable=unnecessary-pass
         Event.width = self.winfo_width()
         Event.height = self.winfo_height()
         self.plotcanvas.resize(Event)  # pylint: disable=no-value-for-parameter
diff --git a/lib/gui/display_page.py b/lib/gui/display_page.py
index a984ffc..d872e86 100644
--- a/lib/gui/display_page.py
+++ b/lib/gui/display_page.py
@@ -5,7 +5,7 @@ import logging
 import tkinter as tk
 from tkinter import ttk
 
-from .tooltip import Tooltip
+from .custom_widgets import Tooltip
 from .utils import get_images
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
diff --git a/lib/gui/menu.py b/lib/gui/menu.py
index 2faeeeb..047001a 100644
--- a/lib/gui/menu.py
+++ b/lib/gui/menu.py
@@ -6,24 +6,28 @@ import logging
 import os
 import sys
 import tkinter as tk
+from tkinter import ttk
 import webbrowser
 
-
 from importlib import import_module
 from subprocess import Popen, PIPE, STDOUT
 
 from lib.multithreading import MultiThread
 from lib.serializer import get_serializer
-
 import update_deps
-from .utils import get_config
+
 from .popup_configure import popup_config
+from .custom_widgets import Tooltip
+from .utils import get_config, get_images
 
 _RESOURCES = [("faceswap.dev - Guides and Forum", "https://www.faceswap.dev"),
               ("Patreon - Support this project", "https://www.patreon.com/faceswap"),
               ("Discord - The FaceSwap Discord server", "https://discord.gg/VasFUAy"),
               ("Github - Our Source Code", "https://github.com/deepfakes/faceswap")]
 
+_CONFIG_FILES = []
+_CONFIGS = dict()
+
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
 
@@ -56,6 +60,7 @@ class SettingsMenu(tk.Menu):  # pylint:disable=too-many-ancestors
 
     def scan_for_plugin_configs(self):
         """ Scan for config.ini file locations """
+        global _CONFIGS, _CONFIG_FILES  # pylint:disable=global-statement
         root_path = os.path.abspath(os.path.dirname(sys.argv[0]))
         plugins_path = os.path.join(root_path, "plugins")
         logger.debug("Scanning path: '%s'", plugins_path)
@@ -66,6 +71,12 @@ class SettingsMenu(tk.Menu):  # pylint:disable=too-many-ancestors
                 config = self.load_config(plugin_type)
                 configs[plugin_type] = config
         logger.debug("Configs loaded: %s", sorted(list(configs.keys())))
+        keys = list(configs.keys())
+        for key in ("extract", "train", "convert"):
+            if key in keys:
+                _CONFIG_FILES.append(keys.pop(keys.index(key)))
+        _CONFIG_FILES.extend([key for key in sorted(keys)])
+        _CONFIGS = configs
         return configs
 
     @staticmethod
@@ -80,8 +91,9 @@ class SettingsMenu(tk.Menu):  # pylint:disable=too-many-ancestors
 
     def build(self):
         """ Add the settings menu to the menu bar """
+        # pylint: disable=cell-var-from-loop
         logger.debug("Building settings menu")
-        for name in sorted(list(self.configs.keys())):
+        for name in _CONFIG_FILES:
             label = "Configure {} Plugins...".format(name.title())
             config = self.configs[name]
             self.add_command(
@@ -103,7 +115,7 @@ class FileMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         logger.debug("Initializing %s", self.__class__.__name__)
         super().__init__(parent, tearoff=0)
         self.root = parent.root
-        self.config = get_config()
+        self._config = get_config()
         self.recent_menu = tk.Menu(self, tearoff=0, postcommand=self.refresh_recent_menu)
         self.build()
         logger.debug("Initialized %s", self.__class__.__name__)
@@ -111,35 +123,78 @@ class FileMenu(tk.Menu):  # pylint:disable=too-many-ancestors
     def build(self):
         """ Add the file menu to the menu bar """
         logger.debug("Building File menu")
-        self.add_command(label="Load full config...", underline=0, command=self.config.load)
-        self.add_command(label="Save full config...", underline=0, command=self.config.save)
+        self.add_command(label="New Project...",
+                         underline=0,
+                         accelerator="Ctrl+N",
+                         command=self._config.project.new)
+        self.root.bind_all("<Control-n>", self._config.project.new)
+        self.add_command(label="Open Project...",
+                         underline=0,
+                         accelerator="Ctrl+O",
+                         command=self._config.project.load)
+        self.root.bind_all("<Control-o>", self._config.project.load)
+        self.add_command(label="Save Project",
+                         underline=0,
+                         accelerator="Ctrl+S",
+                         command=lambda: self._config.project.save(save_as=False))
+        self.root.bind_all("<Control-s>", lambda e: self._config.project.save(e, save_as=False))
+        self.add_command(label="Save Project as...",
+                         underline=13,
+                         accelerator="Ctrl+Alt+S",
+                         command=lambda: self._config.project.save(save_as=True))
+        self.root.bind_all("<Control-Alt-s>", lambda e: self._config.project.save(e, save_as=True))
+        self.add_command(label="Reload Project from Disk",
+                         underline=0,
+                         accelerator="F5",
+                         command=self._config.project.reload)
+        self.root.bind_all("<F5>", self._config.project.reload)
+        self.add_command(label="Close Project",
+                         underline=0,
+                         accelerator="Ctrl+W",
+                         command=self._config.project.close)
+        self.root.bind_all("<Control-w>", self._config.project.close)
+        self.add_separator()
+        self.add_command(label="Open Task...",
+                         underline=5,
+                         accelerator="Ctrl+Alt+T",
+                         command=lambda: self._config.tasks.load(current_tab=False))
+        self.root.bind_all("<Control-Alt-t>",
+                           lambda e: self._config.tasks.load(e, current_tab=False))
         self.add_separator()
         self.add_cascade(label="Open recent", underline=6, menu=self.recent_menu)
         self.add_separator()
-        self.add_command(label="Reset all to default",
+        self.add_command(label="Quit",
                          underline=0,
-                         command=self.config.cli_opts.reset)
-        self.add_command(label="Clear all", underline=0, command=self.config.cli_opts.clear)
-        self.add_separator()
-        self.add_command(label="Quit", underline=0, command=self.root.close_app)
+                         accelerator="Alt+F4",
+                         command=self.root.close_app)
+        self.root.bind_all("<Alt-F4>", self.root.close_app)
         logger.debug("Built File menu")
 
     def build_recent_menu(self):
         """ Load recent files into menu bar """
         logger.debug("Building Recent Files menu")
         serializer = get_serializer("json")
-        menu_file = os.path.join(self.config.pathcache, ".recent.json")
+        menu_file = os.path.join(self._config.pathcache, ".recent.json")
         if not os.path.isfile(menu_file) or os.path.getsize(menu_file) == 0:
             self.clear_recent_files(serializer, menu_file)
         recent_files = serializer.load(menu_file)
         logger.debug("Loaded recent files: %s", recent_files)
         for recent_item in recent_files:
             filename, command = recent_item
+            # Legacy project files didn't have a command stored
+            command = command if command else "project"
             logger.debug("processing: ('%s', %s)", filename, command)
-            lbl_command = command if command else "All"
+            if command.lower() == "project":
+                load_func = self._config.project.load
+                lbl = command
+                kwargs = dict(filename=filename)
+            else:
+                load_func = self._config.tasks.load
+                lbl = "{} Task".format(command)
+                kwargs = dict(filename=filename, current_tab=False)
             self.recent_menu.add_command(
-                label="{} ({})".format(filename, lbl_command.title()),
-                command=lambda fnm=filename, cmd=command: self.config.load(cmd, fnm))
+                label="{} ({})".format(filename, lbl.title()),
+                command=lambda kw=kwargs, fn=load_func: fn(**kw))
         self.recent_menu.add_separator()
         self.recent_menu.add_command(
             label="Clear recent files",
@@ -191,6 +246,7 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
 
     def build_recources_menu(self):
         """ Build resources menu """
+        # pylint: disable=cell-var-from-loop
         logger.debug("Building Resources Files menu")
         for resource in _RESOURCES:
             self.recources_menu.add_command(
@@ -215,7 +271,6 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         logger.debug("Obtaining system information")
         self.root.config(cursor="watch")
         self.clear_console()
-        print("Obtaining system information...")
         try:
             from lib.sysinfo import sysinfo
             info = sysinfo
@@ -227,7 +282,7 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         self.root.config(cursor="")
 
     def check(self):
-        """ Check for updates and clone repo """
+        """ Check for updates and clone repository """
         logger.debug("Checking for updates...")
         self.root.config(cursor="watch")
         encoding = locale.getpreferredencoding()
@@ -236,7 +291,7 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         self.root.config(cursor="")
 
     def update(self):
-        """ Check for updates and clone repo """
+        """ Check for updates and clone repository """
         logger.debug("Updating Faceswap...")
         self.root.config(cursor="watch")
         encoding = locale.getpreferredencoding()
@@ -305,3 +360,121 @@ class HelpMenu(tk.Menu):  # pylint:disable=too-many-ancestors
         else:
             retval = True
         return retval
+
+
+class TaskBar(ttk.Frame):  # pylint: disable=too-many-ancestors
+    """ Task bar buttons """
+    def __init__(self, parent):
+        super().__init__(parent)
+        self._config = get_config()
+        self.pack(side=tk.TOP, anchor=tk.W, fill=tk.X, expand=False)
+        self._btn_frame = ttk.Frame(self)
+        self._btn_frame.pack(side=tk.TOP, pady=2, anchor=tk.W, fill=tk.X, expand=False)
+
+        self._project_btns()
+        self._group_separator()
+        self._task_btns()
+        self._group_separator()
+        self._settings_btns()
+        self._section_separator()
+
+    def _project_btns(self):
+        frame = ttk.Frame(self._btn_frame)
+        frame.pack(side=tk.LEFT, anchor=tk.W, expand=False, padx=2)
+
+        for btntype in ("new", "load", "save", "save_as", "reload"):
+            logger.debug("Adding button: '%s'", btntype)
+
+            loader, kwargs = self._loader_and_kwargs(btntype)
+            cmd = getattr(self._config.project, loader)
+            btn = ttk.Button(frame,
+                             image=get_images().icons[btntype],
+                             command=lambda fn=cmd, kw=kwargs: fn(**kw))
+            btn.pack(side=tk.LEFT, anchor=tk.W)
+            hlp = self.set_help(btntype)
+            Tooltip(btn, text=hlp, wraplength=200)
+
+    def _task_btns(self):
+        frame = ttk.Frame(self._btn_frame)
+        frame.pack(side=tk.LEFT, anchor=tk.W, expand=False, padx=2)
+
+        for loadtype in ("load", "save", "save_as", "clear", "reload"):
+            btntype = "{}2".format(loadtype)
+            logger.debug("Adding button: '%s'", btntype)
+
+            loader, kwargs = self._loader_and_kwargs(loadtype)
+            if loadtype == "load":
+                kwargs["current_tab"] = True
+            cmd = getattr(self._config.tasks, loader)
+            btn = ttk.Button(
+                frame,
+                image=get_images().icons[btntype],
+                command=lambda fn=cmd, kw=kwargs: fn(**kw))
+            btn.pack(side=tk.LEFT, anchor=tk.W)
+            hlp = self.set_help(btntype)
+            Tooltip(btn, text=hlp, wraplength=200)
+
+    @staticmethod
+    def _loader_and_kwargs(btntype):
+        if btntype == "save":
+            loader = btntype
+            kwargs = dict(save_as=False)
+        elif btntype == "save_as":
+            loader = "save"
+            kwargs = dict(save_as=True)
+        else:
+            loader = btntype
+            kwargs = dict()
+        logger.debug("btntype: %s, loader: %s, kwargs: %s", btntype, loader, kwargs)
+        return loader, kwargs
+
+    def _settings_btns(self):
+        # pylint: disable=cell-var-from-loop
+        frame = ttk.Frame(self._btn_frame)
+        frame.pack(side=tk.LEFT, anchor=tk.W, expand=False, padx=2)
+        root = get_config().root
+        for name in _CONFIG_FILES:
+            config = _CONFIGS[name]
+            btntype = "settings_{}".format(name)
+            btntype = btntype if btntype in get_images().icons else "settings"
+            logger.debug("Adding button: '%s'", btntype)
+            btn = ttk.Button(
+                frame,
+                image=get_images().icons[btntype],
+                command=lambda conf=(name, config), root=root: popup_config(conf, root))
+            btn.pack(side=tk.LEFT, anchor=tk.W)
+            hlp = "Configure {} settings...".format(name.title())
+            Tooltip(btn, text=hlp, wraplength=200)
+
+    @staticmethod
+    def set_help(btntype):
+        """ Set the helptext for option buttons """
+        logger.debug("Setting help")
+        hlp = ""
+        task = "currently selected Task" if btntype[-1] == "2" else "Project"
+        if btntype.startswith("reload"):
+            hlp = "Reload {} from disk".format(task)
+        if btntype == "new":
+            hlp = "Crate a new {}...".format(task)
+        if btntype.startswith("clear"):
+            hlp = "Reset {} to default".format(task)
+        elif btntype.startswith("save") and "_" not in btntype:
+            hlp = "Save {}".format(task)
+        elif btntype.startswith("save_as"):
+            hlp = "Save {} as...".format(task)
+        elif btntype.startswith("load"):
+            msg = task
+            if msg.endswith("Task"):
+                msg += " from a task or project file"
+            hlp = "Load {}...".format(msg)
+        return hlp
+
+    def _group_separator(self):
+        separator = ttk.Separator(self._btn_frame, orient="vertical")
+        separator.pack(padx=(2, 1), fill=tk.Y, side=tk.LEFT)
+
+    def _section_separator(self):
+        frame = ttk.Frame(self)
+        frame.pack(side=tk.BOTTOM, fill=tk.X)
+        separator = ttk.Separator(frame, orient="horizontal")
+        separator.pack(fill=tk.X, side=tk.LEFT, expand=True)
diff --git a/lib/gui/options.py b/lib/gui/options.py
index 124f609..7de3945 100644
--- a/lib/gui/options.py
+++ b/lib/gui/options.py
@@ -36,7 +36,7 @@ class CliOptions():
 
     @staticmethod
     def get_cli_classes(cli_source):
-        """ Parse the cli scripts for the arg classes """
+        """ Parse the cli scripts for the argument classes """
         mod_classes = list()
         for name, obj in inspect.getmembers(cli_source):
             if inspect.isclass(obj) and name.lower().endswith("args") \
@@ -105,7 +105,9 @@ class CliOptions():
                 rounding=self.get_rounding(opt),
                 min_max=opt.get("min_max", None),
                 sysbrowser=self.get_sysbrowser(opt, command_options, command),
-                helptext=opt["help"])
+                helptext=opt["help"],
+                track_modified=True,
+                command=command)
             gui_options[title] = dict(cpanel_option=cpanel_option,
                                       opts=opt["opts"],
                                       nargs=opt.get("nargs", None))
@@ -163,7 +165,7 @@ class CliOptions():
         if action == cli.FileFullPaths:
             retval["browser"] = ["load"]
         elif action == cli.FilesFullPaths:
-            retval["browser"] = ["load_multi"]
+            retval["browser"] = ["multi_load"]
         elif action == cli.SaveFileFullPaths:
             retval["browser"] = ["save"]
         elif action == cli.DirOrFileFullPaths:
@@ -241,7 +243,7 @@ class CliOptions():
                     continue
                 cmd_dict[key] = val["cpanel_option"].get()
             ctl_dict[cmd] = cmd_dict
-        logger.debug("command: '%s', ctl_dict: '%s'", command, ctl_dict)
+        logger.debug("command: '%s', ctl_dict: %s", command, ctl_dict)
         return ctl_dict
 
     def get_one_option_variable(self, command, title):
@@ -258,7 +260,7 @@ class CliOptions():
             optval = str(option["cpanel_option"].get())
             opt = option["opts"][0]
             if command in ("extract", "convert") and opt == "-o":
-                get_images().pathoutput = optval
+                get_images().set_faceswap_output_path(optval)
             if optval in ("False", ""):
                 continue
             elif optval == "True":
diff --git a/lib/gui/popup_configure.py b/lib/gui/popup_configure.py
index 9a2f8f6..76c90d6 100644
--- a/lib/gui/popup_configure.py
+++ b/lib/gui/popup_configure.py
@@ -9,7 +9,7 @@ import tkinter as tk
 from tkinter import ttk
 
 from .control_helper import ControlPanel, ControlPanelOption
-from .tooltip import Tooltip
+from .custom_widgets import Tooltip
 from .utils import get_config, get_images
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -32,11 +32,12 @@ class ConfigurePlugins(tk.Toplevel):
     def __init__(self, config, root):
         logger.debug("Initializing %s", self.__class__.__name__)
         super().__init__()
-        name, self.config = config
-        self.title("{} Plugins".format(name.title()))
+        self._name, self.config = config
+        self.title("{} Plugins".format(self._name.title()))
         self.tk.call('wm', 'iconphoto', self._w, get_images().icons["favicon"])
 
-        self.set_geometry(root)
+        self._root = root
+        self.set_geometry()
 
         self.page_frame = ttk.Frame(self)
         self.page_frame.pack(fill=tk.BOTH, expand=True)
@@ -47,11 +48,11 @@ class ConfigurePlugins(tk.Toplevel):
         self.update()
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def set_geometry(self, root):
+    def set_geometry(self):
         """ Set pop-up geometry """
         scaling_factor = get_config().scaling_factor
-        pos_x = root.winfo_x() + 80
-        pos_y = root.winfo_y() + 80
+        pos_x = self._root.winfo_x() + 80
+        pos_y = self._root.winfo_y() + 80
         width = int(600 * scaling_factor)
         height = int(400 * scaling_factor)
         logger.debug("Pop up Geometry: %sx%s, %s+%s", width, height, pos_x, pos_y)
@@ -187,6 +188,13 @@ class ConfigurePlugins(tk.Toplevel):
                 new_config.set(section, item, str(new_opt))
         self.config.config = new_config
         self.config.save_config()
-        print("Saved config: '{}'".format(self.config.configfile))
+        logger.info("Saved config: '%s'", self.config.configfile)
         self.destroy()
+
+        running_task = get_config().tk_vars["runningtask"].get()
+        if self._name.lower() == "gui" and not running_task:
+            self._root.rebuild()
+        elif self._name.lower() == "gui" and running_task:
+            logger.info("Can't redraw GUI whilst a task is running. GUI Settings will be applied "
+                        "at the next restart.")
         logger.debug("Saved config")
diff --git a/lib/gui/project.py b/lib/gui/project.py
new file mode 100644
index 0000000..bc214f3
--- /dev/null
+++ b/lib/gui/project.py
@@ -0,0 +1,993 @@
+#!/usr/bin/env python3
+""" Handling of Faceswap GUI Projects, Tasks and Last Session """
+
+import logging
+import os
+import tkinter as tk
+from tkinter import messagebox
+
+from lib.serializer import get_serializer
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
+
+class _GuiSession():  # pylint:disable=too-few-public-methods
+    """ Parent class for GUI Session Handlers.
+
+    Parameters
+    ----------
+    config: :class:`lib.gui.utils.Config`
+        The master GUI config
+    file_handler: :class:`lib.gui.utils.FileHandler`
+        A file handler object
+
+    """
+    def __init__(self, config, file_handler=None):
+        # NB file_handler has to be passed in to avoid circular imports
+        logger.debug("Initializing: %s: (config: %s, file_handler: %s)",
+                     self.__class__.__name__, config, file_handler)
+        self._serializer = get_serializer("json")
+        self._config = config
+
+        self._default_opts = None
+        self._options = None
+        self._file_handler = file_handler
+        self._filename = None
+        self._saved_tasks = None
+        self._modified = False
+        logger.debug("Initialized: %s", self.__class__.__name__)
+
+    @property
+    def _active_tab(self):
+        """ str: The name of the currently selected :class:`lib.gui.command.CommandNotebook`
+        tab. """
+        notebook = self._config.command_notebook
+        toolsbook = self._config.tools_notebook
+        command = notebook.tab(notebook.select(), "text").lower()
+        if command == "tools":
+            command = toolsbook.tab(toolsbook.select(), "text").lower()
+        logger.debug("Active tab: %s", command)
+        return command
+
+    @property
+    def _modified_vars(self):
+        """ dict: The tkinter Boolean vars indicating the modified state for each tab. """
+        return self._config.modified_vars
+
+    @property
+    def _file_exists(self):
+        """ bool: ``True`` if :attr:`_filename` exists otherwise ``False``. """
+        return self._filename is not None and os.path.isfile(self._filename)
+
+    @property
+    def _cli_options(self):
+        """ dict: the raw cli options from :attr:`_options` with project fields removed. """
+        return {key: val for key, val in self._options.items() if isinstance(val, dict)}
+
+    @property
+    def _dirname(self):
+        """ str: The folder name that :attr:`_filename` resides in. Returns ``None`` if
+        filename is ``None``. """
+        return os.path.dirname(self._filename) if self._filename is not None else None
+
+    @property
+    def _basename(self):
+        """ str: The base name of :attr:`_filename`. Returns ``None`` if filename is ``None``. """
+        return os.path.basename(self._filename) if self._filename is not None else None
+
+    def _current_gui_state(self, command=None):
+        """ The current state of the GUI.
+
+        Parameters
+        ----------
+        command: str, optional
+        If provided, returns the state of just the given tab command. If ``None`` returns options
+        for all tabs. Default ``None``
+
+        Returns
+        -------
+        dict: The options currently set in the GUI
+        """
+        return self._config.cli_opts.get_option_values(command)
+
+    def _set_filename(self, filename=None, sess_type="project"):
+        """ Set the :attr:`_filename` attribute.
+
+        :attr:`_filename` is set either from a given filename or the result from
+        a :attr:`_file_handler`.
+
+        Parameters
+        ----------
+        filename: str, optional
+            An optional filename. If given then this filename will be used otherwise it will be
+            collected by a :attr:`_file_handler`
+
+        sess_type: {all, project, task}, optional
+            The session type that the filename is being set for. Dictates the type of file handler
+            that is opened.
+
+        Returns
+        -------
+        bool: `True` if filename has been successfully set otherwise ``False``
+        """
+        logger.debug("filename: '%s', sess_type: '%s'", filename, sess_type)
+        handler = "config_{}".format(sess_type)
+
+        if filename is None:
+            logger.debug("Popping file handler")
+            cfgfile = self._file_handler("open", handler).retfile
+            if not cfgfile:
+                logger.debug("No filename given")
+                return False
+            filename = cfgfile.name
+            cfgfile.close()
+
+        if not os.path.isfile(filename):
+            msg = "File does not exist: '{}'".format(filename)
+            logger.error(msg)
+            return False
+        ext = os.path.splitext(filename)[1]
+        if (sess_type == "project" and ext != ".fsw") or (sess_type == "task" and ext != ".fst"):
+            logger.debug("Invalid file extension for session type: (sess_type: '%s', "
+                         "extension: '%s')", sess_type, ext)
+            return False
+        logger.debug("Setting filename: '%s'", filename)
+        self._filename = filename
+        return True
+
+    # GUI STATE SETTING
+    def _set_options(self, command=None):
+        """ Set the GUI options based on the currently stored properties of :attr:`_options`
+        and sets the active tab.
+
+        Parameters
+        ----------
+        command: str, optional
+            The tab to set the options for. If None then sets options for all tabs.
+            Default: ``None``
+        """
+        opts = self._get_options_for_command(command) if command else self._cli_options
+        logger.debug("command: %s, opts: %s", command, opts)
+        if opts is None:
+            logger.debug("No options found. Returning")
+            return
+        for cmd, opt in opts.items():
+            self._set_gui_state_for_command(cmd, opt)
+        tab_name = self._options.get("tab_name", None) if command is None else command
+        tab_name = tab_name if tab_name is not None else "extract"
+        logger.debug("tab_name: %s", tab_name)
+        self._config.set_active_tab_by_name(tab_name)
+
+    def _get_options_for_command(self, command):
+        """ Return a single command's options from :attr:`_options` formatted consistently with
+        an all options dict.
+
+        Parameters
+        ----------
+        command: str
+            The command to return the options for
+
+        Returns
+        -------
+        dict: The options for a single command in the format {command: options}. If the command
+        is not found then returns ``None``
+        """
+        logger.debug(command)
+        opts = self._options.get(command, None)
+        retval = {command: opts}
+        if not opts:
+            self._config.tk_vars["consoleclear"].set(True)
+            logger.info("No  %s section found in file", command)
+            retval = None
+        logger.debug(retval)
+        return retval
+
+    def _set_gui_state_for_command(self, command, options):
+        """ Set the GUI state for the given command.
+
+        Parameters
+        ----------
+        command: str
+            The tab to set the options for
+        options: dict
+            The option values to set the GUI to
+        """
+        logger.debug("command: %s: options: %s", command, options)
+        if not options:
+            logger.debug("No options provided, not updating GUI")
+            return
+        for srcopt, srcval in options.items():
+            optvar = self._config.cli_opts.get_one_option_variable(command, srcopt)
+            if not optvar:
+                continue
+            logger.trace("setting option: (srcopt: %s, optvar: %s, srcval: %s)",
+                         srcopt, optvar, srcval)
+            optvar.set(srcval)
+
+    def _reset_modified_var(self, command=None):
+        """ Reset :attr:`_modified_vars` variables back to unmodified (`False`) for all
+        commands or for the given command.
+
+        Parameters
+        ----------
+        command: str, optional
+            The command to reset the modified tkinter variable for. If ``None`` then all tkinter
+            modified variables are reset to `False`. Default: ``None``
+        """
+        for key, tk_var in self._modified_vars.items():
+            if (command is None or command == key) and tk_var.get():
+                logger.debug("Reset modified state for: %s", command)
+                tk_var.set(False)
+
+    # RECENT FILE HANDLING
+    def _add_to_recent(self, command=None):
+        """ Add the file for this session to the recent files list.
+
+        Parameters
+        ----------
+        command: str, optional
+            The command that this session relates to. If `None` then the whole project is added.
+            Default: ``None``
+        """
+        logger.debug(command)
+        if self._filename is None:
+            logger.debug("No filename for selected file. Not adding to recent.")
+            return
+        recent_filename = os.path.join(self._config.pathcache, ".recent.json")
+        logger.debug("Adding to recent files '%s': (%s, %s)",
+                     recent_filename, self._filename, command)
+        if not os.path.exists(recent_filename) or os.path.getsize(recent_filename) == 0:
+            logger.debug("Starting with empty recent_files list")
+            recent_files = []
+        else:
+            logger.debug("loading recent_files list: %s", recent_filename)
+            recent_files = self._serializer.load(recent_filename)
+        logger.debug("Initial recent files: %s", recent_files)
+        recent_files = self._del_from_recent(self._filename, recent_files)
+        ftype = "project" if command is None else command
+        recent_files.insert(0, (self._filename, ftype))
+        recent_files = recent_files[:20]
+        logger.debug("Final recent files: %s", recent_files)
+        self._serializer.save(recent_filename, recent_files)
+
+    def _del_from_recent(self, filename, recent_files=None, save=False):
+        """ Remove an item from the recent files list.
+
+        Parameters
+        ----------
+        filename: str
+            The filename to be removed from the recent files list
+        recent_files: list, optional
+            If the recent files list has already been loaded, it can be passed in to avoid
+            loading again. If ``None`` then load the recent files list from disk. Default: ``None``
+        save: bool, optional
+            Whether the recent files list should be saved after removing the file. ``True`` saves
+            the file, ``False`` does not. Default: ``False``
+        """
+        recent_filename = os.path.join(self._config.pathcache, ".recent.json")
+        if recent_files is None:
+            logger.debug("Loading file list from disk: %s", recent_filename)
+            if not os.path.exists(recent_filename) or os.path.getsize(recent_filename) == 0:
+                logger.debug("No recent file list")
+                return None
+            recent_files = self._serializer.load(recent_filename)
+        filenames = [recent[0] for recent in recent_files]
+        if filename in filenames:
+            idx = filenames.index(filename)
+            logger.debug("Removing from recent file list: %s", filename)
+            del recent_files[idx]
+            if save:
+                logger.debug("Saving recent files list: %s", recent_filename)
+                self._serializer.save(recent_filename, recent_files)
+        else:
+            logger.debug("Filename '%s' does not appear in recent file list", filename)
+        return recent_files
+
+    def _get_lone_task(self):
+        """ Get the sole command name from :attr:`_options`.
+
+        Returns
+        -------
+        str: The only existing command name in the current :attr:`_options` dict or ``None`` if
+        there are multiple commands stored.
+        """
+        command = None
+        if len(self._cli_options) == 1:
+            command = list(self._cli_options.keys())[0]
+        logger.debug(command)
+        return command
+
+    # DISK IO
+    def _load(self):
+        """ Load GUI options from :attr:`_filename` location and set to :attr:`_options`.
+
+        Returns
+        -------
+        bool: ``True`` if successfully loaded otherwise ``False``
+        """
+        if self._file_exists:
+            logger.debug("Loading config")
+            self._options = self._serializer.load(self._filename)
+            retval = True
+        else:
+            logger.debug("File doesn't exist. Aborting")
+            retval = False
+        return retval
+
+    def _save_as_to_filename(self, session_type):
+        """ Set :attr:`_filename` from a save as dialog.
+
+        Parameters
+        ----------
+        session_type: ['all', 'task', 'project']
+            The type of session to pop the save as dialog for. Limits the allowed filetypes
+
+        Returns
+        -------
+        bool:
+            True if :attr:`filename` successfully set otherwise ``False``
+        """
+        logger.debug("Popping save as file handler. session_type: '%s'", session_type)
+        title = "Save {}As...".format("{} ".format(session_type.title())
+                                      if session_type != "all" else "")
+        cfgfile = self._file_handler("save",
+                                     "config_{}".format(session_type),
+                                     title=title,
+                                     initialdir=self._dirname).retfile
+        if not cfgfile:
+            logger.debug("No filename provided. session_type: '%s'", session_type)
+            return False
+        self._filename = cfgfile.name
+        logger.debug("Set filename: (session_type: '%s', filename: '%s'",
+                     session_type, self._filename)
+        cfgfile.close()
+        return True
+
+    def _save(self, command=None):
+        """ Collect the options in the current GUI state and save.
+
+        Obtains the current options set in the GUI with the selected tab and applies them to
+        :attr:`_options`. Saves :attr:`_options` to :attr:`_filename`. Resets :attr:_modified_vars
+        for either the given command or all commands,
+
+        Parameters
+        ----------
+        command: str, optional
+            The tab to collect the current state for. If ``None`` then collects the current
+            state for all tabs. Default: ``None``
+        """
+        self._options = self._current_gui_state(command)
+        self._options["tab_name"] = self._active_tab
+        logger.debug("Saving options: (filename: %s, options: %s", self._filename, self._options)
+        self._serializer.save(self._filename, self._options)
+        self._reset_modified_var(command)
+        self._add_to_recent(command)
+
+
+class Tasks(_GuiSession):
+    """ Faceswap ``.fst`` Task File handling.
+
+    Faceswap tasks handle the management of each individual task tab in the GUI. Unlike
+    :class:`Projects`, Tasks contains all the active tasks currently running, rather than an
+    individual task.
+
+    Parameters
+    ----------
+    config: :class:`lib.gui.utils.Config`
+        The master GUI config
+    file_handler: :class:`lib.gui.utils.FileHandler`
+        A file handler object
+    """
+    def __init__(self, config, file_handler):
+        super().__init__(config, file_handler)
+        self._tasks = dict()
+
+    @property
+    def _is_project(self):
+        """ str: ``True`` if all tasks are from an overarching session project else ``False``."""
+        retval = False if not self._tasks else all(v.get("is_project", False)
+                                                   for v in self._tasks.values())
+        return retval
+
+    @property
+    def _project_filename(self):
+        """ str: The overarching session project filename."""
+        fname = None
+        if not self._is_project:
+            return fname
+
+        for val in self._tasks.values():
+            fname = val["filename"]
+            break
+        return fname
+
+    def load(self, *args,  # pylint:disable=unused-argument
+             filename=None, current_tab=True):
+        """ Load a task into this :class:`Tasks` class.
+
+        Tasks can be loaded from project ``.fsw`` files or task ``.fst`` files, depending on where
+        this function is being called from.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        filename: str, optional
+            If a filename is passed in, This will be used, otherwise a file handler will be
+            launched to select the relevant file.
+        current_tab: bool, optional
+            ``True`` if the task to be loaded must be for the currently selected tab. ``False``
+            if loading a task into any tab. If current_tab is `True` then tasks can be loaded from
+            ``.fsw`` and ``.fst`` files, otherwise they can only be loaded from ``.fst`` files.
+            Default: ``True``
+        """
+        logger.debug("Loading task config: (filename: '%s', current_tab: '%s')",
+                     filename, current_tab)
+
+        # Option to load specific task from project files:
+        sess_type = "all" if current_tab else "task"
+
+        is_legacy = (not self._is_project and
+                     filename is not None and sess_type == "task" and
+                     os.path.splitext(filename)[1] == ".fsw")
+        if is_legacy:
+            filename = self._update_legacy_task(filename)
+
+        filename_set = self._set_filename(filename, sess_type=sess_type)
+        if not filename_set:
+            return
+        loaded = self._load()
+        if not loaded:
+            return
+
+        command = self._active_tab if current_tab else self._get_lone_task()
+        if command is None:
+            logger.error("Unable to determine task from the given file: '%s'", filename)
+            return
+        if command not in self._options:
+            logger.error("No '%s' task in '%s'", command, self._filename)
+            return
+
+        self._set_options(command)
+        if self._is_project:
+            self._filename = self._project_filename
+        elif self._filename.endswith(".fsw"):
+            self._filename = None
+
+        self._add_to_recent(command)
+        self._add_task(command)
+        if is_legacy:
+            self.save()
+
+        logger.debug("Loaded task config: (command: '%s', filename: '%s')", command, filename)
+
+    def _update_legacy_task(self, filename):
+        """ Update legacy ``.fsw`` tasks to ``.fst`` tasks.
+
+        Tasks loaded from the recent files menu may be passed in with a ``.fsw`` extension.
+        This renames the file and removes it from the recent file list.
+
+        Parameters
+        ----------
+        filename: str
+            The filename of the `.fsw` file that needs converting
+
+        Returns
+        -------
+        str:
+            The new filename of the updated tasks file
+        """
+        # TODO remove this code after a period of time. Implemented November 2019
+
+        logger.debug("original filename: '%s'", filename)
+        fname, ext = os.path.splitext(filename)
+        if ext != ".fsw":
+            logger.debug("Not a .fsw file: '%s'", filename)
+            return filename
+
+        new_filename = "{}.fst".format(fname)
+        logger.debug("Renaming '%s' to '%s'", filename, new_filename)
+        os.rename(filename, new_filename)
+        self._del_from_recent(filename, save=True)
+        logger.debug("new filename: '%s'", new_filename)
+        return new_filename
+
+    def save(self, save_as=False):
+        """ Save the current GUI state for the active tab to a ``.fst`` faceswap task file.
+
+        Parameters
+        ----------
+        save_as: bool, optional
+            Whether to save to the stored filename, or pop open a file handler to ask for a
+            location. If there is no stored filename, then a file handler will automatically be
+            popped.
+        """
+        logger.debug("Saving config...")
+        self._set_active_task()
+        save_as = save_as or self._is_project or self._filename is None
+
+        if save_as and not self._save_as_to_filename("task"):
+            return
+
+        command = self._active_tab
+        self._save(command=command)
+        self._add_task(command)
+        if not save_as:
+            logger.info("Saved project to: '%s'", self._filename)
+        else:
+            logger.debug("Saved project to: '%s'", self._filename)
+
+    def clear(self):
+        """ Reset all GUI options to their default values for the active tab. """
+        self._config.cli_opts.reset(self._active_tab)
+
+    def reload(self):
+        """ Reset currently selected tab GUI options to their last saved state. """
+        self._set_active_task()
+
+        if self._options is None:
+            logger.info("No active task to reload")
+            return
+        logger.debug("Reloading task")
+        self.load(filename=self._filename, current_tab=True)
+        if self._is_project:
+            self._reset_modified_var(self._active_tab)
+
+    def _add_task(self, command):
+        """ Add the currently active task to the internal :attr:`_tasks` dict.
+
+        If the currently stored task is from an overarching session project, then
+        only the options are updated. When resetting a tab to saved a project will always
+        be preferred to a task loaded into the project, so the original reference file name
+        stays with the project.
+
+        Parameters
+        ----------
+        command: str
+            The tab that pertains to the currently active task
+
+        """
+        self._tasks[command] = dict(filename=self._filename,
+                                    options=self._options,
+                                    is_project=self._is_project)
+
+    def clear_tasks(self):
+        """ Clears all of the stored tasks.
+
+        This is required when loading a task stored in a legacy project file, and is only to be
+        called by :class:`Project` when a project has been loaded which is in fact a task.
+        """
+        logger.debug("Clearing stored tasks")
+        self._tasks = dict()
+
+    def add_project_task(self, filename, command, options):
+        """ Add an individual task from a loaded :class:`Project` to the internal :attr:`_tasks`
+        dict.
+
+        Project tasks take priority over any other tasks, so the individual tasks from a new
+        project must be placed in the _tasks dict.
+
+        Parameters
+        ----------
+        filename: str
+            The filename of the session project file
+        command: str
+            The tab that this task's options belong to
+        options: dict
+            The options for this task loaded from the project
+        """
+        self._tasks[command] = dict(filename=filename, options=options, is_project=True)
+
+    def _set_active_task(self, command=None):
+        """ Set the active :attr:`_filename` and :attr:`_options` to currently selected tab's
+        options.
+
+        Parameters
+        ----------
+        command: str, optional
+            If a command is passed in then set the given tab to active, If this is none set the tab
+            which currently has focus to active. Default: ``None``
+        """
+        logger.debug(command)
+        command = self._active_tab if command is None else command
+        task = self._tasks.get(command, None)
+        if task is None:
+            self._filename, self._options = (None, None)
+        else:
+            self._filename, self._options = (task.get("filename", None), task.get("options", None))
+        logger.debug("tab: %s, filename: %s, options: %s",
+                     self._active_tab, self._filename, self._options)
+
+
+class Project(_GuiSession):
+    """ Faceswap ``.fsw`` Project File handling.
+
+    Faceswap projects handle the management of all task tabs in the GUI and updates
+    the main Faceswap title bar with the project name and modified state.
+
+    Parameters
+    ----------
+    config: :class:`lib.gui.utils.Config`
+        The master GUI config
+    file_handler: :class:`lib.gui.utils.FileHandler`
+        A file handler object
+    """
+
+    def __init__(self, config, file_handler):
+        super().__init__(config, file_handler)
+        self._update_root_title()
+
+    @property
+    def filename(self):
+        """ str: The currently active project filename. """
+        return self._filename
+
+    @property
+    def cli_options(self):
+        """ dict: the raw cli options from :attr:`_options` with project fields removed. """
+        return self._cli_options
+
+    @property
+    def _project_modified(self):
+        """bool: ``True`` if the project has been modified otherwise ``False``. """
+        return any([var.get() for var in self._modified_vars.values()])
+
+    @property
+    def _tasks(self):
+        """ :class:`Tasks`: The current session's :class:``Tasks``. """
+        return self._config.tasks
+
+    def initialize_default_options(self):
+        """ Collect the default options. and store locally.
+
+        The Default GUI options are stored on Faceswap startup.
+
+        Exposed as the :attr:`_default_opts` for a project cannot be set until after the main
+        Command Tabs have been loaded.
+        """
+        self._default_opts = self._current_gui_state()
+        self._set_default_options()
+
+    def _set_default_options(self):
+        """ Set the default options. The Default GUI options are stored on Faceswap startup.
+
+        Exposed as the :attr:`_default_opts` for a project cannot be set until after the main
+        Command Tabs have been loaded.
+        """
+        self._options = self._default_opts
+
+    # MODIFIED STATE CALLBACK
+    def set_modified_callback(self):
+        """ Adds a callback to each of the :attr:`_modified_vars` tkinter variables
+        When one of these variables is changed, triggers :func:`_modified_callback`
+        with the command that was changed.
+
+        This is exposed as the callback can only be added after the main Command Tabs have
+        been drawn, and their options' initial values have been set.
+
+        """
+        for key, tkvar in self._modified_vars.items():
+            logger.debug("Adding callback for tab: %s", key)
+            tkvar.trace("w", self._modified_callback)
+
+    def _modified_callback(self, *args):  # pylint:disable=unused-argument
+        """ Update the project modified state on a GUI modification change and
+        update the Faceswap title bar. """
+        if self._project_modified and self._current_gui_state() == self._cli_options:
+            logger.debug("Project is same as stored. Setting modified to False")
+            self._reset_modified_var()
+
+        if self._modified != self._project_modified:
+            logger.debug("Updating project state from variable: (modified: %s)",
+                         self._project_modified)
+            self._modified = self._project_modified
+            self._update_root_title()
+
+    def load(self, *args, filename=None):  # pylint:disable=unused-argument
+        """ Load a project from a saved ``.fsw`` project file.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        filename: str, optional
+            If a filename is passed in, This will be used, otherwise a file handler will be
+            launched to select the relevant file.
+        """
+        logger.debug("Loading project config: (filename: '%s')", filename)
+        filename_set = self._set_filename(filename, sess_type="project")
+
+        if not filename_set:
+            logger.debug("No filename set")
+            return
+        loaded = self._load()
+        if not loaded:
+            logger.debug("Options not loaded")
+            return
+
+        # Legacy .fsw files could store projects or tasks. Check if this is a legacy file
+        # and hand off file to Tasks if necessary
+        command = self._get_lone_task()
+        legacy = command is not None
+        if legacy:
+            self._handoff_legacy_task()
+            return
+
+        self._set_options()
+        self._update_tasks()
+        self._add_to_recent()
+        self._reset_modified_var()
+        self._update_root_title()
+        logger.debug("Loaded project config: (command: '%s', filename: '%s')", command, filename)
+
+    def _handoff_legacy_task(self):
+        """ Update legacy tasks saved with the old file extension ``.fsw`` to tasks ``.fst``.
+
+        Hands off file handling to :class:`Tasks` and resets project to default.
+        """
+        logger.debug("Updating legacy task '%s", self._filename)
+        filename = self._filename
+        self._filename = None
+        self._set_default_options()
+        self._tasks.clear_tasks()
+        self._tasks.load(filename=filename, current_tab=False)
+        logger.debug("Updated legacy task and reset project")
+
+    def _update_tasks(self):
+        """ Add the tasks from the loaded project to the :class:`Tasks` class. """
+        for key, val in self._cli_options.items():
+            opts = {key: val}
+            opts["tab_name"] = key
+            self._tasks.add_project_task(self._filename, key, opts)
+
+    def reload(self, *args):  # pylint:disable=unused-argument
+        """ Reset all GUI's option tabs to their last saved state.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        """
+        if self._options is None:
+            logger.info("No active project to reload")
+            return
+        logger.debug("Reloading project")
+        self._set_options()
+        self._update_tasks()
+        self._reset_modified_var()
+        self._update_root_title()
+
+    def _update_root_title(self):
+        """ Update the root Window title with the project name. Add a asterisk
+        if the file is modified. """
+        text = "<untitled project>" if self._basename is None else self._basename
+        text += "*" if self._modified else ""
+        self._config.set_root_title(text=text)
+
+    def save(self, *args, save_as=False):  # pylint:disable=unused-argument
+        """ Save the current GUI state to a ``.fsw`` project file.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        save_as: bool, optional
+            Whether to save to the stored filename, or pop open a file handler to ask for a
+            location. If there is no stored filename, then a file handler will automatically be
+            popped.
+        """
+        logger.debug("Saving config as...")
+
+        save_as = save_as or self._filename is None
+        if save_as and not self._save_as_to_filename("project"):
+            return
+        self._save()
+        self._update_tasks()
+        self._update_root_title()
+        if not save_as:
+            logger.info("Saved project to: '%s'", self._filename)
+        else:
+            logger.debug("Saved project to: '%s'", self._filename)
+
+    def new(self, *args):  # pylint:disable=unused-argument
+        """ Create a new project with default options.
+
+        Pops a file handler to select location.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        """
+        logger.debug("Creating new project")
+        if not self.confirm_close():
+            logger.debug("Creating new project cancelled")
+            return
+
+        cfgfile = self._file_handler("save",
+                                     "config_project",
+                                     title="New Project...",
+                                     initialdir=self._basename).retfile
+        if not cfgfile:
+            logger.debug("No filename selected")
+            return
+        self._filename = cfgfile.name
+        cfgfile.close()
+
+        self._set_default_options()
+        self._config.cli_opts.reset()
+        self._save()
+        self._update_root_title()
+
+    def close(self, *args):  # pylint:disable=unused-argument
+        """ Clear the current project and set all options to default.
+
+        Parameters
+        ----------
+        *args: tuple
+            Unused, but needs to be present for arguments passed by tkinter event handling
+        """
+        logger.debug("Close requested")
+        if not self.confirm_close():
+            logger.debug("Close cancelled")
+            return
+        self._config.cli_opts.reset()
+        self._filename = None
+        self._set_default_options()
+        self._reset_modified_var()
+        self._update_root_title()
+        self._config.set_active_tab_by_name(self._config.user_config_dict["tab"])
+
+    def confirm_close(self):
+        """ Pop a message box to get confirmation that an unsaved project should be closed
+
+        Returns
+        -------
+        bool: ``True`` if user confirms close, ``False`` if user cancels close
+        """
+        if not self._modified:
+            logger.debug("Project is not modified")
+            return True
+        confirmtxt = "You have unsaved changes.\n\nAre you sure you want to close the project?"
+        if messagebox.askokcancel("Close", confirmtxt, default="cancel", icon="warning"):
+            logger.debug("Close Cancelled")
+            return True
+        logger.debug("Close confirmed")
+        return False
+
+
+class LastSession(_GuiSession):
+    """ Faceswap Last Session handling.
+
+    Faceswap :class:`LastSession` handles saving the state of the Faceswap GUI at close and
+    reloading the state  at launch.
+
+    Last Session behavior can be configured in :file:`config.gui.ini`.
+
+    Parameters
+    ----------
+    config: :class:`lib.gui.utils.Config`
+        The master GUI config
+    """
+
+    def __init__(self, config):
+        super().__init__(config)
+        self._filename = os.path.join(self._config.pathcache, ".last_session.json")
+        if not self._enabled:
+            return
+
+        if self._save_option == "prompt":
+            self.ask_load()
+        elif self._save_option == "always":
+            self.load()
+
+    @property
+    def _save_option(self):
+        """ str: The user config autosave option. """
+        return self._config.user_config_dict.get("autosave_last_session", "never")
+
+    @property
+    def _enabled(self):
+        """ bool: ``True`` if autosave is enabled otherwise ``False``. """
+        return self._save_option != "never"
+
+    def from_dict(self, options):
+        """ Set the :attr:`_options` property based on the given options dictionary
+        and update the GUI to use these values.
+
+        This function is required for reloading the GUI state when the GUI has been force
+        refreshed on a config change.
+
+        Parameters
+        ----------
+        options: dict
+            The options to set. Should be the output of :func:`to_dict`
+        """
+        logger.debug("Setting options from dict: %s", options)
+        self._options = options
+        self._set_options()
+
+    def to_dict(self):
+        """ Collect the current GUI options and place them in a dict for retrieval or storage.
+
+        This function is required for reloading the GUI state when the GUI has been force
+        refreshed on a config change.
+
+        Returns
+        -------
+        dict: The current cli options ready for saving or retrieval by :func:`from_dict`
+        """
+        opts = self._current_gui_state()
+        logger.debug("Collected opts: %s", opts)
+        if not opts or opts == self._default_opts:
+            logger.debug("Default session, or no opts found. Not saving last session.")
+            return None
+        opts["tab_name"] = self._active_tab
+        opts["project"] = self._config.project.filename
+        logger.debug("Added project items: %s", {k: v for k, v in opts.items()
+                                                 if k in ("tab_name", "project")})
+        return opts
+
+    def ask_load(self):
+        """ Pop a message box to ask the user if they wish to load their last session.  """
+        if not self._file_exists:
+            logger.debug("No last session file found")
+        elif tk.messagebox.askyesno("Last Session", "Load last session?"):
+            logger.debug("Loading last session at user request")
+            self.load()
+        else:
+            logger.debug("Not loading last session at user request")
+
+    def load(self):
+        """ Load the last session.
+
+        Loads the last saved session options. Checks if a previous project was loaded
+        and whether there have been changes since the last saved version of the project.
+        Sets the display and :class:`Project` and :class:`Task` objects accordingly.
+        """
+        loaded = self._load()
+        if not loaded:
+            return
+        needs_update = self._set_project()
+        if needs_update:
+            self._set_options()
+
+    def _set_project(self):
+        """ Set the :class:`Project` if session is resuming from one.
+
+        Returns
+        -------
+        bool:
+            ``True`` If the GUI still needs to be updated from the last session, ``False`` if
+            the returned GUI state is the last session
+        """
+        if self._options.get("project", None) is None:
+            logger.debug("No project stored")
+            retval = True
+        else:
+            logger.debug("Loading stored project")
+            self._config.project.load(filename=self._options["project"])
+            retval = self._cli_options != self._config.project.cli_options
+
+        logger.debug("Needs update: %s", retval)
+        return retval
+
+    def save(self):
+        """ Save a snapshot of currently set GUI config options.
+
+        Called on Faceswap shutdown.
+        """
+        if not self._enabled:
+            logger.debug("LastSession not enabled")
+            if os.path.exists(self._filename):
+                logger.debug("Deleting existing LastSession file")
+                os.remove(self._filename)
+            return
+
+        opts = self.to_dict()
+        if opts is None and os.path.exists(self._filename):
+            logger.debug("Last session default or blank. Clearing saved last session.")
+            os.remove(self._filename)
+        if opts is not None:
+            self._serializer.save(self._filename, opts)
+            logger.debug("Saved last session. (filename: '%s', opts: %s", self._filename, opts)
diff --git a/lib/gui/statusbar.py b/lib/gui/statusbar.py
deleted file mode 100644
index f6bdb0e..0000000
--- a/lib/gui/statusbar.py
+++ /dev/null
@@ -1,82 +0,0 @@
-#!/usr/bin python3
-""" Status bar for the GUI """
-
-import tkinter as tk
-from tkinter import ttk
-
-
-class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
-    """ Status Bar for displaying the Status Message and
-        Progress Bar """
-
-    def __init__(self, parent):
-        ttk.Frame.__init__(self, parent)
-        self.pack(side=tk.BOTTOM, padx=10, pady=2, fill=tk.X, expand=False)
-
-        self.status_message = tk.StringVar()
-        self.pbar_message = tk.StringVar()
-        self.pbar_position = tk.IntVar()
-
-        self.status_message.set("Ready")
-
-        self.status()
-        self.pbar = self.progress_bar()
-
-    def status(self):
-        """ Place Status into bottom bar """
-        statusframe = ttk.Frame(self)
-        statusframe.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=False)
-
-        lbltitle = ttk.Label(statusframe, text="Status:", width=6, anchor=tk.W)
-        lbltitle.pack(side=tk.LEFT, expand=False)
-
-        lblstatus = ttk.Label(statusframe,
-                              width=40,
-                              textvariable=self.status_message,
-                              anchor=tk.W)
-        lblstatus.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=True)
-
-    def progress_bar(self):
-        """ Place progress bar into bottom bar """
-        progressframe = ttk.Frame(self)
-        progressframe.pack(side=tk.RIGHT, anchor=tk.E, fill=tk.X)
-
-        lblmessage = ttk.Label(progressframe, textvariable=self.pbar_message)
-        lblmessage.pack(side=tk.LEFT, padx=3, fill=tk.X, expand=True)
-
-        pbar = ttk.Progressbar(progressframe,
-                               length=200,
-                               variable=self.pbar_position,
-                               maximum=100,
-                               mode="determinate")
-        pbar.pack(side=tk.LEFT, padx=2, fill=tk.X, expand=True)
-        pbar.pack_forget()
-        return pbar
-
-    def progress_start(self, mode):
-        """ Set progress bar mode and display """
-        self.progress_set_mode(mode)
-        self.pbar.pack()
-
-    def progress_stop(self):
-        """ Reset progress bar and hide """
-        self.pbar_message.set("")
-        self.pbar_position.set(0)
-        self.progress_set_mode("determinate")
-        self.pbar.pack_forget()
-
-    def progress_set_mode(self, mode):
-        """ Set the progress bar mode """
-        self.pbar.config(mode=mode)
-        if mode == "indeterminate":
-            self.pbar.config(maximum=100)
-            self.pbar.start()
-        else:
-            self.pbar.stop()
-            self.pbar.config(maximum=100)
-
-    def progress_update(self, message, position, update_position=True):
-        """ Update the GUIs progress bar and position """
-        self.pbar_message.set(message)
-        if update_position:
-            self.pbar_position.set(position)
diff --git a/lib/gui/tooltip.py b/lib/gui/tooltip.py
deleted file mode 100755
index d89e8eb..0000000
--- a/lib/gui/tooltip.py
+++ /dev/null
@@ -1,165 +0,0 @@
-#!/usr/bin python3
-""" Tooltip. Pops up help messages for the GUI """
-import platform
-import tkinter as tk
-
-
-class Tooltip:
-    """
-    Create a tooltip for a given widget as the mouse goes on it.
-
-    Adapted from StackOverflow:
-
-    http://stackoverflow.com/questions/3221956/
-           what-is-the-simplest-way-to-make-tooltips-
-           in-tkinter/36221216#36221216
-
-    http://www.daniweb.com/programming/software-development/
-           code/484591/a-tooltip-class-for-tkinter
-
-    - Originally written by vegaseat on 2014.09.09.
-
-    - Modified to include a delay time by Victor Zaccardo on 2016.03.25.
-
-    - Modified
-        - to correct extreme right and extreme bottom behavior,
-        - to stay inside the screen whenever the tooltip might go out on
-          the top but still the screen is higher than the tooltip,
-        - to use the more flexible mouse positioning,
-        - to add customizable background color, padding, waittime and
-          wraplength on creation
-      by Alberto Vassena on 2016.11.05.
-
-      Tested on Ubuntu 16.04/16.10, running Python 3.5.2
-
-    """
-
-    def __init__(self, widget,
-                 *,
-                 background="#FFFFEA",
-                 pad=(5, 3, 5, 3),
-                 text="widget info",
-                 waittime=400,
-                 wraplength=250):
-
-        self.waittime = waittime  # in milliseconds, originally 500
-        self.wraplength = wraplength  # in pixels, originally 180
-        self.widget = widget
-        self.text = text
-        self.widget.bind("<Enter>", self.on_enter)
-        self.widget.bind("<Leave>", self.on_leave)
-        self.widget.bind("<ButtonPress>", self.on_leave)
-        self.background = background
-        self.pad = pad
-        self.ident = None
-        self.topwidget = None
-
-    def on_enter(self, event=None):
-        """ Schedule on an enter event """
-        self.schedule()
-
-    def on_leave(self, event=None):
-        """ Unschedule on a leave event """
-        self.unschedule()
-        self.hide()
-
-    def schedule(self):
-        """ Show the tooltip after wait period """
-        self.unschedule()
-        self.ident = self.widget.after(self.waittime, self.show)
-
-    def unschedule(self):
-        """ Hide the tooltip """
-        id_ = self.ident
-        self.ident = None
-        if id_:
-            self.widget.after_cancel(id_)
-
-    def show(self):
-        """ Show the tooltip """
-        def tip_pos_calculator(widget, label,
-                               *,
-                               tip_delta=(10, 5), pad=(5, 3, 5, 3)):
-            """ Calculate the tooltip position """
-
-            s_width, s_height = widget.winfo_screenwidth(), widget.winfo_screenheight()
-
-            width, height = (pad[0] + label.winfo_reqwidth() + pad[2],
-                             pad[1] + label.winfo_reqheight() + pad[3])
-
-            mouse_x, mouse_y = widget.winfo_pointerxy()
-
-            x_1, y_1 = mouse_x + tip_delta[0], mouse_y + tip_delta[1]
-            x_2, y_2 = x_1 + width, y_1 + height
-
-            x_delta = x_2 - s_width
-            if x_delta < 0:
-                x_delta = 0
-            y_delta = y_2 - s_height
-            if y_delta < 0:
-                y_delta = 0
-
-            offscreen = (x_delta, y_delta) != (0, 0)
-
-            if offscreen:
-
-                if x_delta:
-                    x_1 = mouse_x - tip_delta[0] - width
-
-                if y_delta:
-                    y_1 = mouse_y - tip_delta[1] - height
-
-            offscreen_again = y_1 < 0  # out on the top
-
-            if offscreen_again:
-                # No further checks will be done.
-
-                # TIP:
-                # A further mod might auto-magically augment the
-                # wraplength when the tooltip is too high to be
-                # kept inside the screen.
-                y_1 = 0
-
-            return x_1, y_1
-
-        background = self.background
-        pad = self.pad
-        widget = self.widget
-
-        # creates a toplevel window
-        self.topwidget = tk.Toplevel(widget)
-        if platform.system() == "Darwin":
-            # For Mac OS
-            self.topwidget.tk.call("::tk::unsupported::MacWindowStyle",
-                                   "style", self.topwidget._w,
-                                   "help", "none")
-
-        # Leaves only the label and removes the app window
-        self.topwidget.wm_overrideredirect(True)
-
-        win = tk.Frame(self.topwidget,
-                       background=background,
-                       borderwidth=0)
-        label = tk.Label(win,
-                         text=self.text,
-                         justify=tk.LEFT,
-                         background=background,
-                         relief=tk.SOLID,
-                         borderwidth=0,
-                         wraplength=self.wraplength)
-
-        label.grid(padx=(pad[0], pad[2]),
-                   pady=(pad[1], pad[3]),
-                   sticky=tk.NSEW)
-        win.grid()
-
-        xpos, ypos = tip_pos_calculator(widget, label)
-
-        self.topwidget.wm_geometry("+%d+%d" % (xpos, ypos))
-
-    def hide(self):
-        """ Hide the tooltip """
-        topwidget = self.topwidget
-        if topwidget:
-            topwidget.destroy()
-        self.topwidget = None
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 0c2b7dc..0d32701 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -2,99 +2,149 @@
 """ Utility functions for the GUI """
 import logging
 import os
-import platform
-import re
 import sys
 import tkinter as tk
-from tkinter import filedialog, ttk
+from tkinter import filedialog
 from threading import Event, Thread
 from queue import Queue
 import numpy as np
 
 from PIL import Image, ImageDraw, ImageTk
 
-from lib.serializer import get_serializer
-
 from ._config import Config as UserConfig
-from ._redirector import WidgetRedirector
+from .project import Project, Tasks
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 _CONFIG = None
 _IMAGES = None
+PATHCACHE = os.path.join(os.path.realpath(os.path.dirname(sys.argv[0])), "lib", "gui", ".cache")
+
 
+def initialize_config(root, cli_opts, statusbar, session):
+    """ Initialize the GUI Master :class:`Config` and add to global constant.
 
-def initialize_config(root, cli_opts, scaling_factor, pathcache, statusbar, session):
-    """ Initialize the config and add to global constant """
+    This should only be called once on first GUI startup. Future access to :class:`Config`
+    should only be executed through :func:`get_config`.
+
+    Parameters
+    ----------
+    root: :class:`tkinter.Tk`
+        The root Tkinter object
+    cli_opts: :class:`lib.gui.options.CliOpts`
+        The command line options object
+    statusbar: :class:`lib.gui.custom_widgets.StatusBar`
+        The GUI Status bar
+    session: :class:`lib.gui.stats.Session`
+        The current training Session
+    """
     global _CONFIG  # pylint: disable=global-statement
     if _CONFIG is not None:
-        return
-    logger.debug("Initializing config: (root: %s, cli_opts: %s, tk_vars: %s, pathcache: %s, "
-                 "statusbar: %s, session: %s)", root, cli_opts, scaling_factor, pathcache,
-                 statusbar, session)
-    _CONFIG = Config(root, cli_opts, scaling_factor, pathcache, statusbar, session)
+        return None
+    logger.debug("Initializing config: (root: %s, cli_opts: %s, "
+                 "statusbar: %s, session: %s)", root, cli_opts, statusbar, session)
+    _CONFIG = Config(root, cli_opts, statusbar, session)
+    return _CONFIG
 
 
 def get_config():
-    """ return the _CONFIG constant """
+    """ Get the Master GUI configuration.
+
+    Returns
+    -------
+    :class:`Config`
+        The Master GUI Config
+    """
     return _CONFIG
 
 
-def initialize_images(pathcache=None):
-    """ Initialize the images and add to global constant """
+def initialize_images():
+    """ Initialize the :class:`Images` handler  and add to global constant.
+
+    This should only be called once on first GUI startup. Future access to :class:`Images`
+    handler should only be executed through :func:`get_images`.
+    """
     global _IMAGES  # pylint: disable=global-statement
     if _IMAGES is not None:
         return
     logger.debug("Initializing images")
-    _IMAGES = Images(pathcache)
+    _IMAGES = Images()
 
 
 def get_images():
-    """ return the _CONFIG constant """
+    """ Get the Master GUI Images handler.
+
+    Returns
+    -------
+    :class:`Images`
+        The Master GUI Images handler
+    """
     return _IMAGES
 
 
-class FileHandler():
-    """ Raise a filedialog box and capture input """
+class FileHandler():  # pylint:disable=too-few-public-methods
+    """ Handles all GUI File Dialog actions and tasks.
+
+    Parameters
+    ----------
+    handletype: ['open', 'save', 'filename', 'filename_multi', 'savefilename', 'context']
+        The type of file dialog to return. `open` and `save` will perform the open and save actions
+        and return the file. `filename` returns the filename from an `open` dialog.
+        `filename_multi` allows for multi-selection of files and returns a list of files selected.
+        `savefilename` returns the filename from a `save as` dialog. `context` is a context
+        sensitive parameter that returns a certain dialog based on the current options
+    filetype: ['default', 'alignments', 'config_project', 'config_task', 'config_all', 'csv', \
+               'image', 'ini', 'state', 'log', 'video']
+        The type of file that this dialog is for. `default` allows selection of any files. Other
+        options limit the file type selection
+    title: str, optional
+        The title to display on the file dialog. If `None` then the default title will be used.
+        Default: ``None``
+    initialdir: str, optional
+        The folder to initially open with the file dialog. If `None` then tkinter will decide.
+        Default: ``None``
+    command: str, optional
+        Required for context handling file dialog, otherwise unused. Default: ``None``
+    action: str, optional
+        Required for context handling file dialog, otherwise unused. Default: ``None``
+    variable: :class:`tkinter.StringVar`, optional
+        Required for context handling file dialog, otherwise unused. The variable to associate
+        with this file dialog. Default: ``None``
+
+    Attributes
+    ----------
+    retfile: str or object
+        The return value from the file dialog
+
+    Example
+    -------
+    >>> handler = FileHandler('filename', 'video', title='Select a video...')
+    >>> video_file = handler.retfile
+    >>> print(video_file)
+    '/path/to/selected/video.mp4'
+    """
 
-    def __init__(self, handletype, filetype, command=None, action=None,
-                 variable=None):
-        logger.debug("Initializing %s: (Handletype: '%s', filetype: '%s', command: '%s', action: "
-                     "'%s', variable: %s)", self.__class__.__name__, handletype, filetype, command,
+    def __init__(self, handletype, filetype, title=None, initialdir=None, command=None,
+                 action=None, variable=None):
+        logger.debug("Initializing %s: (Handletype: '%s', filetype: '%s', title: '%s', "
+                     "initialdir: '%s, 'command: '%s', action: '%s', variable: %s)",
+                     self.__class__.__name__, handletype, filetype, title, initialdir, command,
                      action, variable)
-        self.handletype = handletype
-        self.contexts = {
-            "effmpeg": {
-                "input": {"extract": "filename",
-                          "gen-vid": "dir",
-                          "get-fps": "filename",
-                          "get-info": "filename",
-                          "mux-audio": "filename",
-                          "rescale": "filename",
-                          "rotate": "filename",
-                          "slice": "filename"},
-                "output": {"extract": "dir",
-                           "gen-vid": "savefilename",
-                           "get-fps": "nothing",
-                           "get-info": "nothing",
-                           "mux-audio": "savefilename",
-                           "rescale": "savefilename",
-                           "rotate": "savefilename",
-                           "slice": "savefilename"}
-            }
-        }
-        self.defaults = self.set_defaults()
-        self.kwargs = self.set_kwargs(filetype, command, action, variable)
-        self.retfile = getattr(self, self.handletype.lower())()
+        self._handletype = handletype
+        self._defaults = self._set_defaults()
+        self._kwargs = self._set_kwargs(title, initialdir, filetype, command, action, variable)
+        self.retfile = getattr(self, "_{}".format(self._handletype.lower()))()
         logger.debug("Initialized %s", self.__class__.__name__)
 
     @property
-    def filetypes(self):
-        """ Set the filetypes for opening/saving """
+    def _filetypes(self):
+        """ dict: The accepted extensions for each file type for opening/saving """
         all_files = ("All files", "*.*")
         filetypes = {"default": (all_files,),
                      "alignments": [("Faceswap Alignments", "*.fsa *.json"),
                                     all_files],
-                     "config": [("Faceswap GUI config files", "*.fsw"), all_files],
+                     "config_project": [("Faceswap Project files", "*.fsw"), all_files],
+                     "config_task": [("Faceswap Task files", "*.fst"), all_files],
+                     "config_all": [("Faceswap Project and Task files", "*.fst *.fsw"), all_files],
                      "csv": [("Comma separated values", "*.csv"), all_files],
                      "image": [("Bitmap", "*.bmp"),
                                ("JPG", "*.jpeg *.jpg"),
@@ -122,221 +172,386 @@ class FileHandler():
             val.insert(0, tuple(multi))
         return filetypes
 
-    def set_defaults(self):
-        """ Set the default filetype to be first in list of filetypes,
-            or set a custom filetype if the first is not correct """
+    @property
+    def _contexts(self):
+        """dict: Mapping of commands, actions and their corresponding file dialog for context
+        handle types. """
+        return {
+            "effmpeg": {
+                "input": {
+                    "extract": "filename",
+                    "gen-vid": "dir",
+                    "get-fps": "filename",
+                    "get-info": "filename",
+                    "mux-audio": "filename",
+                    "rescale": "filename",
+                    "rotate": "filename",
+                    "slice": "filename"},
+                "output": {
+                    "extract": "dir",
+                    "gen-vid": "savefilename",
+                    "get-fps": "nothing",
+                    "get-info": "nothing",
+                    "mux-audio": "savefilename",
+                    "rescale": "savefilename",
+                    "rotate": "savefilename",
+                    "slice": "savefilename"}
+                }
+            }
+
+    def _set_defaults(self):
+        """ Set the default file type for the file dialog. Generally the first found file type
+        will be used, but this is overridden if it is not appropriate.
+
+        Returns
+        -------
+        dict:
+            The default file extension for each file type
+        """
         defaults = {key: val[0][1].replace("*", "")
-                    for key, val in self.filetypes.items()}
+                    for key, val in self._filetypes.items()}
         defaults["default"] = None
         defaults["video"] = ".mp4"
         defaults["image"] = ".png"
         logger.debug(defaults)
         return defaults
 
-    def set_kwargs(self, filetype, command, action, variable=None):
-        """ Generate the required kwargs for the requested browser """
-        logger.debug("Setting Kwargs: (filetype: '%s', command: '%s': action: '%s', "
-                     "variable: '%s')", filetype, command, action, variable)
+    def _set_kwargs(self, title, initialdir, filetype, command, action, variable=None):
+        """ Generate the required kwargs for the requested file dialog browser.
+
+        Returns
+        -------
+        dict:
+            The key word arguments for the file dialog to be launched
+        """
+        logger.debug("Setting Kwargs: (title: %s, initialdir: %s, filetype: '%s', "
+                     "command: '%s': action: '%s', variable: '%s')",
+                     title, initialdir, filetype, command, action, variable)
         kwargs = dict()
-        if self.handletype.lower() == "context":
-            self.set_context_handletype(command, action, variable)
+        if self._handletype.lower() == "context":
+            self._set_context_handletype(command, action, variable)
+
+        if title is not None:
+            kwargs["title"] = title
 
-        if self.handletype.lower() in (
+        if initialdir is not None:
+            kwargs["initialdir"] = initialdir
+
+        if self._handletype.lower() in (
                 "open", "save", "filename", "filename_multi", "savefilename"):
-            kwargs["filetypes"] = self.filetypes[filetype]
-            if self.defaults.get(filetype, None):
-                kwargs['defaultextension'] = self.defaults[filetype]
-        if self.handletype.lower() == "save":
+            kwargs["filetypes"] = self._filetypes[filetype]
+            if self._defaults.get(filetype, None):
+                kwargs['defaultextension'] = self._defaults[filetype]
+        if self._handletype.lower() == "save":
             kwargs["mode"] = "w"
-        if self.handletype.lower() == "open":
+        if self._handletype.lower() == "open":
             kwargs["mode"] = "r"
         logger.debug("Set Kwargs: %s", kwargs)
         return kwargs
 
-    def set_context_handletype(self, command, action, variable):
-        """ Choose the correct file browser action based on context """
-        if self.contexts[command].get(variable, None) is not None:
-            handletype = self.contexts[command][variable][action]
+    def _set_context_handletype(self, command, action, variable):
+        """ Sets the correct handle type  based on context.
+
+        Parameters
+        ----------
+        command: str
+            The command that is being executed. Used to look up the context actions
+        action: str
+            The action that is being performed. Used to look up the correct file dialog
+        variable: :class:`tkinter.StringVar`
+            The variable associated with this file dialog
+        """
+        if self._contexts[command].get(variable, None) is not None:
+            handletype = self._contexts[command][variable][action]
         else:
-            handletype = self.contexts[command][action]
+            handletype = self._contexts[command][action]
         logger.debug(handletype)
-        self.handletype = handletype
+        self._handletype = handletype
 
-    def open(self):
-        """ Open a file """
+    def _open(self):
+        """ Open a file. """
         logger.debug("Popping Open browser")
-        return filedialog.askopenfile(**self.kwargs)
+        return filedialog.askopenfile(**self._kwargs)
 
-    def save(self):
-        """ Save a file """
+    def _save(self):
+        """ Save a file. """
         logger.debug("Popping Save browser")
-        return filedialog.asksaveasfile(**self.kwargs)
+        return filedialog.asksaveasfile(**self._kwargs)
 
-    def dir(self):
-        """ Get a directory location """
+    def _dir(self):
+        """ Get a directory location. """
         logger.debug("Popping Dir browser")
-        return filedialog.askdirectory(**self.kwargs)
+        return filedialog.askdirectory(**self._kwargs)
 
-    def savedir(self):
-        """ Get a save dir location """
+    def _savedir(self):
+        """ Get a save directory location. """
         logger.debug("Popping SaveDir browser")
-        return filedialog.askdirectory(**self.kwargs)
+        return filedialog.askdirectory(**self._kwargs)
 
-    def filename(self):
-        """ Get an existing file location """
+    def _filename(self):
+        """ Get an existing file location. """
         logger.debug("Popping Filename browser")
-        return filedialog.askopenfilename(**self.kwargs)
+        return filedialog.askopenfilename(**self._kwargs)
 
-    def filename_multi(self):
-        """ Get multiple existing file locations """
+    def _filename_multi(self):
+        """ Get multiple existing file locations. """
         logger.debug("Popping Filename browser")
-        return filedialog.askopenfilenames(**self.kwargs)
+        return filedialog.askopenfilenames(**self._kwargs)
 
-    def savefilename(self):
-        """ Get a save file location """
+    def _savefilename(self):
+        """ Get a save file location. """
         logger.debug("Popping SaveFilename browser")
-        return filedialog.asksaveasfilename(**self.kwargs)
+        return filedialog.asksaveasfilename(**self._kwargs)
 
     @staticmethod
-    def nothing():  # pylint: disable=useless-return
-        """ Method that does nothing, used for disabling open/save pop up  """
+    def _nothing():  # pylint: disable=useless-return
+        """ Method that does nothing, used for disabling open/save pop up.  """
         logger.debug("Popping Nothing browser")
         return
 
 
 class Images():
-    """ Holds locations of images and actual images
+    """ The centralized image repository for holding all icons and images required by the GUI.
 
-        Don't call directly. Call get_images()
+    This class should be initialized on GUI startup through :func:`initialize_images`. Any further
+    access to this class should be through :func:`get_images`.
     """
-
-    def __init__(self, pathcache=None):
+    def __init__(self):
         logger.debug("Initializing %s", self.__class__.__name__)
-        pathcache = get_config().pathcache if pathcache is None else pathcache
-        self.pathicons = os.path.join(pathcache, "icons")
-        self.pathpreview = os.path.join(pathcache, "preview")
-        self.pathoutput = None
-        self.previewoutput = None
-        self.previewtrain = dict()
-        self.previewcache = dict(modified=None,  # cache for extract and convert
-                                 images=None,
-                                 filenames=list(),
-                                 placeholder=None)
-        self.errcount = 0
-        self.icons = dict()
-        self.icons["folder"] = ImageTk.PhotoImage(file=os.path.join(
-            self.pathicons, "open_folder.png"))
-        self.icons["load"] = ImageTk.PhotoImage(file=os.path.join(
-            self.pathicons, "open_file.png"))
-        self.icons["load_multi"] = ImageTk.PhotoImage(file=os.path.join(
-            self.pathicons, "open_file.png"))
-        self.icons["context"] = ImageTk.PhotoImage(file=os.path.join(
-            self.pathicons, "open_file.png"))
-        self.icons["save"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "save.png"))
-        self.icons["reset"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "reset.png"))
-        self.icons["clear"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "clear.png"))
-        self.icons["graph"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "graph.png"))
-        self.icons["zoom"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "zoom.png"))
-        self.icons["move"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "move.png"))
-        self.icons["favicon"] = ImageTk.PhotoImage(file=os.path.join(self.pathicons, "logo.png"))
-        logger.debug("Initialized %s: (icons: %s)", self.__class__.__name__, self.icons)
+        self._pathpreview = os.path.join(PATHCACHE, "preview")
+        self._pathoutput = None
+        self._previewoutput = None
+        self._previewtrain = dict()
+        self._previewcache = dict(modified=None,  # cache for extract and convert
+                                  images=None,
+                                  filenames=list(),
+                                  placeholder=None)
+        self._errcount = 0
+        self._icons = self._load_icons()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    @property
+    def previewoutput(self):
+        """ Tuple or ``None``: First item in the tuple is the extract or convert preview image
+        (:class:`PIL.Image`), the second item is the image in a format that tkinter can display
+        (:class:`PIL.ImageTK.PhotoImage`).
+
+        The value of the property is ``None`` if no extract or convert task is running or there are
+        no files available in the output folder. """
+        return self._previewoutput
+
+    @property
+    def previewtrain(self):
+        """ dict or ``None``: The training preview images. Dictionary key is the image name
+        (`str`). Dictionary values are a `list` of the training image (:class:`PIL.Image`), the
+        image formatted for tkinter display (:class:`PIL.ImageTK.PhotoImage`), the last
+        modification time of the image (`float`).
+
+        The value of this property is ``None`` if training is not running or there are no preview
+        images available.
+        """
+        return self._previewtrain
+
+    @property
+    def icons(self):
+        """ dict: The faceswap icons for all parts of the GUI. The dictionary key is the icon
+        name (`str`) the value is the icon sized and formatted for display
+        (:class:`PIL.ImageTK.PhotoImage`).
+
+        Example
+        -------
+        >>> icons = get_images().icons
+        >>> save = icons["save"]
+        >>> button = ttk.Button(parent, image=save)
+        >>> button.pack()
+        """
+        return self._icons
+
+    @staticmethod
+    def _load_icons():
+        """ Scan the icons cache folder and load the icons into :attr:`icons` for retrieval
+        throughout the GUI.
+
+        Returns
+        -------
+        dict:
+            The icons formatted as described in :attr:`icons`
+
+        """
+        size = get_config().user_config_dict.get("icon_size", 16)
+        size = int(round(size * get_config().scaling_factor))
+        icons = dict()
+        pathicons = os.path.join(PATHCACHE, "icons")
+        for fname in os.listdir(pathicons):
+            name, ext = os.path.splitext(fname)
+            if ext != ".png":
+                continue
+            img = Image.open(os.path.join(pathicons, fname))
+            img = ImageTk.PhotoImage(img.resize((size, size), resample=Image.HAMMING))
+            icons[name] = img
+        logger.debug(icons)
+        return icons
+
+    def set_faceswap_output_path(self, location):
+        """ Set the path that will contain the output from an Extract or Convert task.
+
+        Required so that the GUI can fetch output images to display for return in
+        :attr:`previewoutput`.
+
+        Parameters
+        ----------
+        location: str
+            The output location that has been specified for an Extract or Convert task
+        """
+        self._pathoutput = location
 
     def delete_preview(self):
-        """ Delete the preview files """
+        """ Delete the preview files in the cache folder and reset the image cache.
+
+        Should be called when terminating tasks, or when Faceswap starts up or shuts down.
+        """
         logger.debug("Deleting previews")
-        for item in os.listdir(self.pathpreview):
+        for item in os.listdir(self._pathpreview):
             if item.startswith(".gui_training_preview") and item.endswith(".jpg"):
-                fullitem = os.path.join(self.pathpreview, item)
+                fullitem = os.path.join(self._pathpreview, item)
                 logger.debug("Deleting: '%s'", fullitem)
                 os.remove(fullitem)
-        for fname in self.previewcache["filenames"]:
+        for fname in self._previewcache["filenames"]:
             if os.path.basename(fname) == ".gui_preview.jpg":
                 logger.debug("Deleting: '%s'", fname)
                 try:
                     os.remove(fname)
                 except FileNotFoundError:
                     logger.debug("File does not exist: %s", fname)
-        self.clear_image_cache()
+        self._clear_image_cache()
 
-    def clear_image_cache(self):
-        """ Clear all cached images """
+    def _clear_image_cache(self):
+        """ Clear all cached images. """
         logger.debug("Clearing image cache")
-        self.pathoutput = None
-        self.previewoutput = None
-        self.previewtrain = dict()
-        self.previewcache = dict(modified=None,  # cache for extract and convert
-                                 images=None,
-                                 filenames=list(),
-                                 placeholder=None)
+        self._pathoutput = None
+        self._previewoutput = None
+        self._previewtrain = dict()
+        self._previewcache = dict(modified=None,  # cache for extract and convert
+                                  images=None,
+                                  filenames=list(),
+                                  placeholder=None)
 
     @staticmethod
-    def get_images(imgpath):
-        """ Get the images stored within the given directory """
-        logger.debug("Getting images: '%s'", imgpath)
-        if not os.path.isdir(imgpath):
+    def _get_images(image_path):
+        """ Get the images stored within the given directory.
+
+        Parameters
+        ----------
+        image_path: str
+            The folder containing images to be scanned
+
+        Returns
+        -------
+        list:
+            The image filenames stored within the given folder
+
+        """
+        logger.debug("Getting images: '%s'", image_path)
+        if not os.path.isdir(image_path):
             logger.debug("Folder does not exist")
             return None
-        files = [os.path.join(imgpath, f)
-                 for f in os.listdir(imgpath) if f.lower().endswith((".png", ".jpg"))]
+        files = [os.path.join(image_path, f)
+                 for f in os.listdir(image_path) if f.lower().endswith((".png", ".jpg"))]
         logger.debug("Image files: %s", files)
         return files
 
     def load_latest_preview(self, thumbnail_size, frame_dims):
-        """ Load the latest preview image for extract and convert """
+        """ Load the latest preview image for extract and convert.
+
+        Retrieves the latest preview images from the faceswap output folder, resizes to thumbnails
+        and lays out for display. Places the images into :attr:`previewoutput` for loading into
+        the display panel.
+
+        Parameters
+        ----------
+        thumbnail_size: int
+            The size of each thumbnail that should be created
+        frame_dims: tuple
+            The (width (`int`), height (`int`)) of the display panel that will display the preview
+        """
         logger.debug("Loading preview image: (thumbnail_size: %s, frame_dims: %s)",
                      thumbnail_size, frame_dims)
-        imagefiles = self.get_images(self.pathoutput)
-        gui_preview = os.path.join(self.pathoutput, ".gui_preview.jpg")
-        if not imagefiles or (len(imagefiles) == 1 and gui_preview not in imagefiles):
+        image_files = self._get_images(self._pathoutput)
+        gui_preview = os.path.join(self._pathoutput, ".gui_preview.jpg")
+        if not image_files or (len(image_files) == 1 and gui_preview not in image_files):
             logger.debug("No preview to display")
-            self.previewoutput = None
+            self._previewoutput = None
             return
         # Filter to just the gui_preview if it exists in folder output
-        imagefiles = [gui_preview] if gui_preview in imagefiles else imagefiles
-        logger.debug("Image Files: %s", len(imagefiles))
+        image_files = [gui_preview] if gui_preview in image_files else image_files
+        logger.debug("Image Files: %s", len(image_files))
 
-        imagefiles = self.get_newest_filenames(imagefiles)
-        if not imagefiles:
+        image_files = self._get_newest_filenames(image_files)
+        if not image_files:
             return
 
-        self.load_images_to_cache(imagefiles, frame_dims, thumbnail_size)
-        if imagefiles == [gui_preview]:
+        self._load_images_to_cache(image_files, frame_dims, thumbnail_size)
+        if image_files == [gui_preview]:
             # Delete the preview image so that the main scripts know to output another
             logger.debug("Deleting preview image")
-            os.remove(imagefiles[0])
-        show_image = self.place_previews(frame_dims)
+            os.remove(image_files[0])
+        show_image = self._place_previews(frame_dims)
         if not show_image:
-            self.previewoutput = None
+            self._previewoutput = None
             return
-        logger.debug("Displaying preview: %s", self.previewcache["filenames"])
-        self.previewoutput = (show_image, ImageTk.PhotoImage(show_image))
-
-    def get_newest_filenames(self, imagefiles):
-        """ Return image filenames that have been modified since the last check """
-        if self.previewcache["modified"] is None:
-            retval = imagefiles
+        logger.debug("Displaying preview: %s", self._previewcache["filenames"])
+        self._previewoutput = (show_image, ImageTk.PhotoImage(show_image))
+
+    def _get_newest_filenames(self, image_files):
+        """ Return image filenames that have been modified since the last check.
+
+        Parameters
+        ----------
+        image_files: list
+            The list of image files to check the modification date for
+
+        Returns
+        -------
+        list:
+            A list of images that have been modified since the last check
+        """
+        if self._previewcache["modified"] is None:
+            retval = image_files
         else:
-            retval = [fname for fname in imagefiles
-                      if os.path.getmtime(fname) > self.previewcache["modified"]]
+            retval = [fname for fname in image_files
+                      if os.path.getmtime(fname) > self._previewcache["modified"]]
         if not retval:
             logger.debug("No new images in output folder")
         else:
-            self.previewcache["modified"] = max([os.path.getmtime(img) for img in retval])
+            self._previewcache["modified"] = max([os.path.getmtime(img) for img in retval])
             logger.debug("Number new images: %s, Last Modified: %s",
-                         len(retval), self.previewcache["modified"])
+                         len(retval), self._previewcache["modified"])
         return retval
 
-    def load_images_to_cache(self, imagefiles, frame_dims, thumbnail_size):
-        """ Load new images and append to cache, filtering to the number of display images """
-        logger.debug("Number imagefiles: %s, frame_dims: %s, thumbnail_size: %s",
-                     len(imagefiles), frame_dims, thumbnail_size)
+    def _load_images_to_cache(self, image_files, frame_dims, thumbnail_size):
+        """ Load preview images to the image cache.
+
+        Load new images and append to cache, filtering the cache the number of thumbnails that will
+        fit  inside the display panel.
+
+        Parameters
+        ----------
+        image_files: list
+            A list of new image files that have been modified since the last check
+        frame_dims: tuple
+            The (width (`int`), height (`int`)) of the display panel that will display the preview
+        thumbnail_size: int
+            The size of each thumbnail that should be created
+        """
+        logger.debug("Number image_files: %s, frame_dims: %s, thumbnail_size: %s",
+                     len(image_files), frame_dims, thumbnail_size)
         num_images = (frame_dims[0] // thumbnail_size) * (frame_dims[1] // thumbnail_size)
         logger.debug("num_images: %s", num_images)
         if num_images == 0:
             return
         samples = list()
-        start_idx = len(imagefiles) - num_images if len(imagefiles) > num_images else 0
-        show_files = sorted(imagefiles, key=os.path.getctime)[start_idx:]
+        start_idx = len(image_files) - num_images if len(image_files) > num_images else 0
+        show_files = sorted(image_files, key=os.path.getctime)[start_idx:]
         for fname in show_files:
             img = Image.open(fname)
             width, height = img.size
@@ -353,56 +568,38 @@ class Images():
             draw.rectangle(((0, 0), (thumbnail_size, thumbnail_size)), outline="#E5E5E5", width=1)
             samples.append(np.array(img))
         samples = np.array(samples)
-        self.previewcache["filenames"] = (self.previewcache["filenames"] +
-                                          show_files)[-num_images:]
-        cache = self.previewcache["images"]
+        self._previewcache["filenames"] = (self._previewcache["filenames"] +
+                                           show_files)[-num_images:]
+        cache = self._previewcache["images"]
         if cache is None:
             logger.debug("Creating new cache")
             cache = samples[-num_images:]
         else:
             logger.debug("Appending to existing cache")
             cache = np.concatenate((cache, samples))[-num_images:]
-        self.previewcache["images"] = cache
-        logger.debug("Cache shape: %s", self.previewcache["images"].shape)
-
-    @staticmethod
-    def get_preview_samples(imagefiles, num_images, thumbnail_size):
-        """ Return a subset of the imagefiles images
-            Exclude final file so we don't accidentally load a file that is being saved """
-        logger.debug("num_images: %s", num_images)
-        samples = list()
-        start_idx = len(imagefiles) - (num_images + 1)
-        end_idx = len(imagefiles) - 1
-        logger.debug("start_idx: %s, end_idx: %s", start_idx, end_idx)
-        show_files = sorted(imagefiles, key=os.path.getctime)[start_idx: end_idx]
-        for fname in show_files:
-            img = Image.open(fname)
-            width, height = img.size
-            scaling = thumbnail_size / max(width, height)
-            logger.debug("image width: %s, height: %s, scaling: %s", width, height, scaling)
-            img = img.resize((int(width * scaling), int(height * scaling)))
-            if img.size[0] != img.size[1]:
-                # Pad to square
-                new_img = Image.new("RGB", (thumbnail_size, thumbnail_size))
-                new_img.paste(img, ((thumbnail_size - img.size[0])//2,
-                                    (thumbnail_size - img.size[1])//2))
-                img = new_img
-            draw = ImageDraw.Draw(img)
-            draw.rectangle(((0, 0), (thumbnail_size, thumbnail_size)), outline="#E5E5E5", width=1)
-            samples.append(np.array(img))
-        samples = np.array(samples)
-        logger.debug("Samples shape: %s", samples.shape)
-        return show_files, samples
-
-    def place_previews(self, frame_dims):
-        """ Stack the preview images to fit display """
-        if self.previewcache.get("images", None) is None:
+        self._previewcache["images"] = cache
+        logger.debug("Cache shape: %s", self._previewcache["images"].shape)
+
+    def _place_previews(self, frame_dims):
+        """ Format the preview thumbnails stored in the cache into a grid fitting the display
+        panel.
+
+        Parameters
+        ----------
+        frame_dims: tuple
+            The (width (`int`), height (`int`)) of the display panel that will display the preview
+
+        Returns
+        :class:`PIL.Image`:
+            The final preview display image
+        """
+        if self._previewcache.get("images", None) is None:
             logger.debug("No images in cache. Returning None")
             return None
-        samples = self.previewcache["images"].copy()
+        samples = self._previewcache["images"].copy()
         num_images, thumbnail_size = samples.shape[:2]
-        if self.previewcache["placeholder"] is None:
-            self.create_placeholder(thumbnail_size)
+        if self._previewcache["placeholder"] is None:
+            self._create_placeholder(thumbnail_size)
 
         logger.debug("num_images: %s, thumbnail_size: %s", num_images, thumbnail_size)
         cols, rows = frame_dims[0] // thumbnail_size, frame_dims[1] // thumbnail_size
@@ -413,7 +610,7 @@ class Images():
         remainder = (cols * rows) - num_images
         if remainder != 0:
             logger.debug("Padding sample display. Remainder: %s", remainder)
-            placeholder = np.concatenate([np.expand_dims(self.previewcache["placeholder"],
+            placeholder = np.concatenate([np.expand_dims(self._previewcache["placeholder"],
                                                          0)] * remainder)
             samples = np.concatenate((samples, placeholder))
 
@@ -422,77 +619,110 @@ class Images():
         logger.debug("display shape: %s", display.shape)
         return Image.fromarray(display)
 
-    def create_placeholder(self, thumbnail_size):
-        """ Create a placeholder image for when there are fewer samples available
-            then columns to display them """
+    def _create_placeholder(self, thumbnail_size):
+        """ Create a placeholder image for when there are fewer thumbnails available
+        than columns to display them.
+
+        Parameters
+        ----------
+        thumbnail_size: int
+            The size of the thumbnail that the placeholder should replicate
+        """
         logger.debug("Creating placeholder. thumbnail_size: %s", thumbnail_size)
         placeholder = Image.new("RGB", (thumbnail_size, thumbnail_size))
         draw = ImageDraw.Draw(placeholder)
         draw.rectangle(((0, 0), (thumbnail_size, thumbnail_size)), outline="#E5E5E5", width=1)
         placeholder = np.array(placeholder)
-        self.previewcache["placeholder"] = placeholder
+        self._previewcache["placeholder"] = placeholder
         logger.debug("Created placeholder. shape: %s", placeholder.shape)
 
     def load_training_preview(self):
-        """ Load the training preview images """
+        """ Load the training preview images.
+
+        Reads the training image currently stored in the cache folder and loads them to
+        :attr:`previewtrain` for retrieval in the GUI.
+        """
         logger.debug("Loading Training preview images")
-        imagefiles = self.get_images(self.pathpreview)
+        image_files = self._get_images(self._pathpreview)
         modified = None
-        if not imagefiles:
+        if not image_files:
             logger.debug("No preview to display")
-            self.previewtrain = dict()
+            self._previewtrain = dict()
             return
-        for img in imagefiles:
+        for img in image_files:
             modified = os.path.getmtime(img) if modified is None else modified
             name = os.path.basename(img)
             name = os.path.splitext(name)[0]
             name = name[name.rfind("_") + 1:].title()
             try:
                 logger.debug("Displaying preview: '%s'", img)
-                size = self.get_current_size(name)
-                self.previewtrain[name] = [Image.open(img), None, modified]
+                size = self._get_current_size(name)
+                self._previewtrain[name] = [Image.open(img), None, modified]
                 self.resize_image(name, size)
-                self.errcount = 0
+                self._errcount = 0
             except ValueError:
                 # This is probably an error reading the file whilst it's
                 # being saved  so ignore it for now and only pick up if
                 # there have been multiple consecutive fails
                 logger.warning("Unable to display preview: (image: '%s', attempt: %s)",
-                               img, self.errcount)
-                if self.errcount < 10:
-                    self.errcount += 1
+                               img, self._errcount)
+                if self._errcount < 10:
+                    self._errcount += 1
                 else:
                     logger.error("Error reading the preview file for '%s'", img)
                     print("Error reading the preview file for {}".format(name))
-                    self.previewtrain[name] = None
-
-    def get_current_size(self, name):
-        """ Return the size of the currently displayed image """
+                    self._previewtrain[name] = None
+
+    def _get_current_size(self, name):
+        """ Return the size of the currently displayed training preview image.
+
+        Parameters
+        ----------
+        name: str
+            The name of the training image to get the size for
+
+        Returns
+        -------
+        width: int
+            The width of the training image
+        height: int
+            The height of the training image
+        """
         logger.debug("Getting size: '%s'", name)
-        if not self.previewtrain.get(name, None):
+        if not self._previewtrain.get(name, None):
             return None
-        img = self.previewtrain[name][1]
+        img = self._previewtrain[name][1]
         if not img:
             return None
         logger.debug("Got size: (name: '%s', width: '%s', height: '%s')",
                      name, img.width(), img.height())
         return img.width(), img.height()
 
-    def resize_image(self, name, framesize):
-        """ Resize the training preview image
-            based on the passed in frame size """
-        logger.debug("Resizing image: (name: '%s', framesize: %s", name, framesize)
-        displayimg = self.previewtrain[name][0]
-        if framesize:
-            frameratio = float(framesize[0]) / float(framesize[1])
+    def resize_image(self, name, frame_dims):
+        """ Resize the training preview image based on the passed in frame size.
+
+        If the canvas that holds the preview image changes, update the image size
+        to fit the new canvas and refresh :attr:`previewtrain`.
+
+        Parameters
+        ----------
+        name: str
+            The name of the training image to be resized
+        frame_dims: tuple
+            The (width (`int`), height (`int`)) of the display panel that will display the preview
+        """
+        logger.debug("Resizing image: (name: '%s', frame_dims: %s", name, frame_dims)
+        displayimg = self._previewtrain[name][0]
+        if frame_dims:
+            frameratio = float(frame_dims[0]) / float(frame_dims[1])
             imgratio = float(displayimg.size[0]) / float(displayimg.size[1])
 
             if frameratio <= imgratio:
-                scale = framesize[0] / float(displayimg.size[0])
-                size = (framesize[0], int(displayimg.size[1] * scale))
+                scale = frame_dims[0] / float(displayimg.size[0])
+                size = (frame_dims[0], int(displayimg.size[1] * scale))
             else:
-                scale = framesize[1] / float(displayimg.size[1])
-                size = (int(displayimg.size[0] * scale), framesize[1])
+                scale = frame_dims[1] / float(displayimg.size[1])
+                size = (int(displayimg.size[0] * scale), frame_dims[1])
             logger.debug("Scaling: (scale: %s, size: %s", scale, size)
 
             # Hacky fix to force a reload if it happens to find corrupted
@@ -506,187 +736,238 @@ class Images():
                         raise
                     continue
                 break
-
-        self.previewtrain[name][1] = ImageTk.PhotoImage(displayimg)
+        self._previewtrain[name][1] = ImageTk.PhotoImage(displayimg)
 
 
-class ReadOnlyText(tk.Text):  # pylint: disable=too-many-ancestors
-    """ A read only text widget that redirects a standard tk.Text widget's insert and delete
-    attributes.
-    Source: https://stackoverflow.com/questions/3842155
+class Config():
+    """ The centralized configuration class for holding items that should be made available to all
+    parts of the GUI.
+
+    This class should be initialized on GUI startup through :func:`initialize_config`. Any further
+    access to this class should be through :func:`get_config`.
+
+    Parameters
+    ----------
+    root: :class:`tkinter.Tk`
+        The root Tkinter object
+    cli_opts: :class:`lib.gui.options.CliOpts`
+        The command line options object
+    statusbar: :class:`lib.gui.custom_widgets.StatusBar`
+        The GUI Status bar
+    session: :class:`lib.gui.stats.Session`
+        The current training Session
     """
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.redirector = WidgetRedirector(self)
-        self.insert = self.redirector.register("insert", lambda *args, **kw: "break")
-        self.delete = self.redirector.register("delete", lambda *args, **kw: "break")
-
-
-class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
-    """ The Console out section of the GUI """
-
-    def __init__(self, parent, debug):
-        logger.debug("Initializing %s: (parent: %s, debug: %s)",
-                     self.__class__.__name__, parent, debug)
-        ttk.Frame.__init__(self, parent)
-        self.pack(side=tk.TOP, anchor=tk.W, padx=10, pady=(2, 0),
-                  fill=tk.BOTH, expand=True)
-        self.console = ReadOnlyText(self)
-        rc_menu = ContextMenu(self.console)
-        rc_menu.cm_bind()
-        self.console_clear = get_config().tk_vars['consoleclear']
-        self.set_console_clear_var_trace()
-        self.debug = debug
-        self.build_console()
-        self.add_tags()
+    def __init__(self, root, cli_opts, statusbar, session):
+        logger.debug("Initializing %s: (root %s, cli_opts: %s, statusbar: %s, session: %s)",
+                     self.__class__.__name__, root, cli_opts, statusbar, session)
+        self._constants = dict(
+            root=root,
+            scaling_factor=self._get_scaling(root),
+            default_font=tk.font.nametofont("TkDefaultFont").configure()["family"])
+        self._gui_objects = dict(
+            cli_opts=cli_opts,
+            tk_vars=self._set_tk_vars(),
+            project=Project(self, FileHandler),
+            tasks=Tasks(self, FileHandler),
+            status_bar=statusbar,
+            command_notebook=None)  # set in command.py
+        self._user_config = UserConfig(None)
+        self.session = session
+        self._default_font = tk.font.nametofont("TkDefaultFont").configure()["family"]
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def set_console_clear_var_trace(self):
-        """ Set the trigger actions for the clear console var
-            when it has been triggered from elsewhere """
-        logger.debug("Set clear trace")
-        self.console_clear.trace("w", self.clear)
-
-    def build_console(self):
-        """ Build and place the console """
-        logger.debug("Build console")
-        self.console.config(width=100, height=6, bg="gray90", fg="black")
-        self.console.pack(side=tk.LEFT, anchor=tk.N, fill=tk.BOTH, expand=True)
-
-        scrollbar = ttk.Scrollbar(self, command=self.console.yview)
-        scrollbar.pack(side=tk.LEFT, fill="y")
-        self.console.configure(yscrollcommand=scrollbar.set)
-
-        self.redirect_console()
-        logger.debug("Built console")
-
-    def add_tags(self):
-        """ Add tags to text widget to color based on output """
-        logger.debug("Adding text color tags")
-        self.console.tag_config("default", foreground="#1E1E1E")
-        self.console.tag_config("stderr", foreground="#E25056")
-        self.console.tag_config("info", foreground="#2B445E")
-        self.console.tag_config("verbose", foreground="#008140")
-        self.console.tag_config("warning", foreground="#F77B00")
-        self.console.tag_config("critical", foreground="red")
-        self.console.tag_config("error", foreground="red")
-
-    def redirect_console(self):
-        """ Redirect stdout/stderr to console frame """
-        logger.debug("Redirect console")
-        if self.debug:
-            logger.info("Console debug activated. Outputting to main terminal")
-        else:
-            sys.stdout = SysOutRouter(console=self.console, out_type="stdout")
-            sys.stderr = SysOutRouter(console=self.console, out_type="stderr")
-        logger.debug("Redirected console")
-
-    def clear(self, *args):  # pylint: disable=unused-argument
-        """ Clear the console output screen """
-        logger.debug("Clear console")
-        if not self.console_clear.get():
-            logger.debug("Console not set for clearing. Skipping")
-            return
-        self.console.delete(1.0, tk.END)
-        self.console_clear.set(False)
-        logger.debug("Cleared console")
+    # Constants
+    @property
+    def root(self):
+        """ :class:`tkinter.Tk`: The root tkinter window. """
+        return self._constants["root"]
 
+    @property
+    def scaling_factor(self):
+        """ float: The scaling factor for current display. """
+        return self._constants["scaling_factor"]
 
-class SysOutRouter():
-    """ Route stdout/stderr to the console window """
+    @property
+    def pathcache(self):
+        """ str: The path to the GUI cache folder """
+        return PATHCACHE
 
-    def __init__(self, console=None, out_type=None):
-        logger.debug("Initializing %s: (console: %s, out_type: '%s')",
-                     self.__class__.__name__, console, out_type)
-        self.console = console
-        self.out_type = out_type
-        self.recolor = re.compile(r".+?(\s\d+:\d+:\d+\s)(?P<lvl>[A-Z]+)\s")
-        logger.debug("Initialized %s", self.__class__.__name__)
+    # GUI Objects
+    @property
+    def cli_opts(self):
+        """ :class:`lib.gui.options.CliOptions`: The command line options for this GUI Session. """
+        return self._gui_objects["cli_opts"]
 
-    def get_tag(self, string):
-        """ Set the tag based on regex of log output """
-        if self.out_type == "stderr":
-            # Output all stderr in red
-            return self.out_type
+    @property
+    def tk_vars(self):
+        """ dict: The global tkinter variables. """
+        return self._gui_objects["tk_vars"]
 
-        output = self.recolor.match(string)
-        if not output:
-            return "default"
-        tag = output.groupdict()["lvl"].strip().lower()
-        return tag
+    @property
+    def project(self):
+        """ :class:`lib.gui.project.Project`: The project session handler. """
+        return self._gui_objects["project"]
 
-    def write(self, string):
-        """ Capture stdout/stderr """
-        self.console.insert(tk.END, string, self.get_tag(string))
-        self.console.see(tk.END)
+    @property
+    def tasks(self):
+        """ :class:`lib.gui.project.Tasks`: The session tasks handler. """
+        return self._gui_objects["tasks"]
 
-    @staticmethod
-    def flush():
-        """ If flush is forced, send it to normal terminal """
-        sys.__stdout__.flush()
+    @property
+    def statusbar(self):
+        """ :class:`lib.gui.custom_widgets.StatusBar`: The GUI StatusBar
+        :class:`tkinter.ttk.Frame`. """
+        return self._gui_objects["status_bar"]
 
+    @property
+    def command_notebook(self):
+        """ :class:`lib.gui.command.CommandNoteboook`: The main Faceswap Command Notebook. """
+        return self._gui_objects["command_notebook"]
 
-class Config():
-    """ Global configuration settings
+    # Convenience GUI Objects
+    @property
+    def tools_notebook(self):
+        """ :class:`lib.gui.command.ToolsNotebook`: The Faceswap Tools sub-Notebook. """
+        return self.command_notebook.tools_notebook
 
-        Don't call directly. Call get_config()
-    """
+    @property
+    def modified_vars(self):
+        """ dict: The command notebook modified tkinter variables. """
+        return self.command_notebook.modified_vars
 
-    def __init__(self, root, cli_opts, scaling_factor, pathcache, statusbar, session):
-        logger.debug("Initializing %s: (root %s, cli_opts: %s, scaling_factor: %s, pathcache: %s, "
-                     "statusbar: %s, session: %s)", self.__class__.__name__, root, cli_opts,
-                     scaling_factor, pathcache, statusbar, session)
-        self.root = root
-        self.cli_opts = cli_opts
-        self.scaling_factor = scaling_factor
-        self.pathcache = pathcache
-        self.statusbar = statusbar
-        self.serializer = get_serializer("json")
-        self.tk_vars = self.set_tk_vars()
-        self.user_config = UserConfig(None)
-        self.user_config_dict = self.user_config.config_dict
-        self.command_notebook = None  # set in command.py
-        self.session = session
-        logger.debug("Initialized %s", self.__class__.__name__)
+    @property
+    def _command_tabs(self):
+        """ dict: Command tab titles with their IDs. """
+        return self.command_notebook.tab_names
+
+    @property
+    def _tools_tabs(self):
+        """ dict: Tools command tab titles with their IDs. """
+        return self.command_notebook.tools_tab_names
+
+    # Config
+    @property
+    def user_config(self):
+        """ dict: The GUI config in dict form. """
+        return self._user_config
+
+    @property
+    def user_config_dict(self):
+        """ dict: The GUI config in dict form. """
+        return self._user_config.config_dict
 
     @property
     def default_font(self):
-        """ Return the selected font """
+        """ tuple: The selected font as configured in user settings. First item is the font (`str`)
+        second item the font size (`int`). """
         font = self.user_config_dict["font"]
-        if font == "default":
-            font = tk.font.nametofont("TkDefaultFont").configure()["family"]
+        font = self._default_font if font == "default" else font
         return (font, self.user_config_dict["font_size"])
 
-    @property
-    def command_tabs(self):
-        """ Return dict of command tab titles with their IDs """
-        return {self.command_notebook.tab(tab_id, "text").lower(): tab_id
-                for tab_id in range(0, self.command_notebook.index("end"))}
+    @staticmethod
+    def _get_scaling(root):
+        """ Get the display DPI.
+
+        Returns
+        -------
+        float:
+            The scaling factor
+        """
+        dpi = root.winfo_fpixels("1i")
+        scaling = dpi / 72.0
+        logger.debug("dpi: %s, scaling: %s'", dpi, scaling)
+        return scaling
+
+    def set_command_notebook(self, notebook):
+        """ Set the command notebook to the :attr:`command_notebook` attribute
+        and enable the modified callback for :attr:`project`.
+
+        Parameters
+        ----------
+        notebook: :class:`lib.gui.command.CommandNotebook`
+            The main command notebook for the Faceswap GUI
+        """
+        logger.debug("Setting commane notebook: %s", notebook)
+        self._gui_objects["command_notebook"] = notebook
+        self.project.set_modified_callback()
+
+    def set_active_tab_by_name(self, name):
+        """ Sets the :attr:`command_notebook` or :attr:`tools_notebook` to active based on given
+        name.
+
+        Parameters
+        ----------
+        name: str
+            The name of the tab to set active
+        """
+        name = name.lower()
+        if name in self._command_tabs:
+            tab_id = self._command_tabs[name]
+            logger.debug("Setting active tab to: (name: %s, id: %s)", name, tab_id)
+            self.command_notebook.select(tab_id)
+        elif name in self._tools_tabs:
+            self.command_notebook.select(self._command_tabs["tools"])
+            tab_id = self._tools_tabs[name]
+            logger.debug("Setting active Tools tab to: (name: %s, id: %s)", name, tab_id)
+            self.tools_notebook.select()
+        else:
+            logger.debug("Name couldn't be found. Setting to id 0: %s", name)
+            self.command_notebook.select(0)
 
-    @property
-    def tools_command_tabs(self):
-        """ Return dict of tools command tab titles with their IDs """
-        return {self.command_notebook.tools_notebook.tab(tab_id, "text").lower(): tab_id
-                for tab_id in range(0, self.command_notebook.tools_notebook.index("end"))}
+    def set_modified_true(self, command):
+        """ Set the modified variable to ``True`` for the given command in :attr:`modified_vars`.
+
+        Parameters
+        ----------
+        command: str
+            The command to set the modified state to ``True``
+
+        """
+        tkvar = self.modified_vars.get(command, None)
+        if tkvar is None:
+            logger.debug("No tkvar for command: '%s'", command)
+            return
+        tkvar.set(True)
+        logger.debug("Set modified var to True for: '%s'", command)
+
+    def refresh_config(self):
+        """ Reload the user config from file. """
+        self._user_config = UserConfig(None)
 
     def set_cursor_busy(self, widget=None):
-        """ Set the root or widget cursor to busy """
+        """ Set the root or widget cursor to busy.
+
+        Parameters
+        ----------
+        widget: tkinter object, optional
+            The widget to set busy cursor for. If the provided value is ``None`` then sets the
+            cursor busy for the whole of the GUI. Default: ``None``.
+        """
         logger.debug("Setting cursor to busy. widget: %s", widget)
         widget = self.root if widget is None else widget
         widget.config(cursor="watch")
         widget.update_idletasks()
 
     def set_cursor_default(self, widget=None):
-        """ Set the root or widget cursor to default """
+        """ Set the root or widget cursor to default.
+
+        Parameters
+        ----------
+        widget: tkinter object, optional
+            The widget to set default cursor for. If the provided value is ``None`` then sets the
+            cursor busy for the whole of the GUI. Default: ``None``
+        """
         logger.debug("Setting cursor to default. widget: %s", widget)
         widget = self.root if widget is None else widget
         widget.config(cursor="")
         widget.update_idletasks()
 
     @staticmethod
-    def set_tk_vars():
-        """ TK Variables to be triggered by to indicate
-            what state various parts of the GUI should be in """
+    def _set_tk_vars():
+        """ Set the global tkinter variables stored for easy access in :class:`Config`.
+
+        The variables are available through :attr:`tk_vars`.
+        """
         display = tk.StringVar()
         display.set(None)
 
@@ -714,8 +995,8 @@ class Config():
         updatepreview = tk.BooleanVar()
         updatepreview.set(False)
 
-        traintimeout = tk.IntVar()
-        traintimeout.set(120)
+        analysis_folder = tk.StringVar()
+        analysis_folder.set(None)
 
         tk_vars = {"display": display,
                    "runningtask": runningtask,
@@ -726,142 +1007,38 @@ class Config():
                    "refreshgraph": refreshgraph,
                    "smoothgraph": smoothgraph,
                    "updatepreview": updatepreview,
-                   "traintimeout": traintimeout}
+                   "analysis_folder": analysis_folder}
         logger.debug(tk_vars)
         return tk_vars
 
-    def load(self, command=None, filename=None):
-        """ Pop up load dialog for a saved config file """
-        logger.debug("Loading config: (command: '%s')", command)
-        if filename:
-            if not os.path.isfile(filename):
-                msg = "File does not exist: '{}'".format(filename)
-                logger.error(msg)
-                return
-            cfg = self.serializer.load(filename)
-        else:
-            cfgfile = FileHandler("open", "config").retfile
-            if not cfgfile:
-                return
-            filename = cfgfile.name
-            cfgfile.close()
-            cfg = self.serializer.load(filename)
-
-        if not command and len(cfg.keys()) == 1:
-            command = list(cfg.keys())[0]
-
-        opts = self.get_command_options(cfg, command) if command else cfg
-        if not opts:
-            return
+    def set_root_title(self, text=None):
+        """ Set the main title text for Faceswap.
 
-        for cmd, opts in opts.items():
-            self.set_command_args(cmd, opts)
+        The title will always begin with 'Faceswap.py'. Additional text can be appended.
 
-        if command:
-            if command in self.command_tabs:
-                self.command_notebook.select(self.command_tabs[command])
-            else:
-                self.command_notebook.select(self.command_tabs["tools"])
-                self.command_notebook.tools_notebook.select(self.tools_command_tabs[command])
-        self.add_to_recent(filename, command)
-        logger.debug("Loaded config: (command: '%s', filename: '%s')", command, filename)
-
-    def get_command_options(self, cfg, command):
-        """ return the saved options for the requested
-            command, if not loading global options """
-        opts = cfg.get(command, None)
-        retval = {command: opts}
-        if not opts:
-            self.tk_vars["consoleclear"].set(True)
-            print("No {} section found in file".format(command))
-            logger.info("No  %s section found in file", command)
-            retval = None
-        logger.debug(retval)
-        return retval
+        Parameters
+        ----------
+        text: str, optional
+            Additional text to be appended to the GUI title bar. Default: ``None``
+        """
+        title = "Faceswap.py"
+        title += " - {}".format(text) if text is not None and text else ""
+        self.root.title(title)
 
-    def set_command_args(self, command, options):
-        """ Pass the saved config items back to the CliOptions """
-        if not options:
-            return
-        for srcopt, srcval in options.items():
-            optvar = self.cli_opts.get_one_option_variable(command, srcopt)
-            if not optvar:
-                continue
-            optvar.set(srcval)
-
-    def save(self, command=None):
-        """ Save the current GUI state to a config file in json format """
-        logger.debug("Saving config: (command: '%s')", command)
-        cfgfile = FileHandler("save", "config").retfile
-        if not cfgfile:
-            return
-        filename = cfgfile.name
-        cfgfile.close()
-        cfg = self.cli_opts.get_option_values(command)
-        self.serializer.save(filename, cfg)
-        self.add_to_recent(filename, command)
-        logger.debug("Saved config: (command: '%s', filename: '%s')", command, filename)
-
-    def add_to_recent(self, filename, command):
-        """ Add to recent files """
-        recent_filename = os.path.join(self.pathcache, ".recent.json")
-        logger.debug("Adding to recent files '%s': (%s, %s)", recent_filename, filename, command)
-        if not os.path.exists(recent_filename) or os.path.getsize(recent_filename) == 0:
-            recent_files = list()
-        else:
-            recent_files = self.serializer.load(recent_filename)
-        logger.debug("Initial recent files: %s", recent_files)
-        filenames = [recent[0] for recent in recent_files]
-        if filename in filenames:
-            idx = filenames.index(filename)
-            del recent_files[idx]
-        recent_files.insert(0, (filename, command))
-        recent_files = recent_files[:20]
-        logger.debug("Final recent files: %s", recent_files)
-        self.serializer.save(recent_filename, recent_files)
-
-
-class ContextMenu(tk.Menu):  # pylint: disable=too-many-ancestors
-    """ Pop up menu """
-    def __init__(self, widget):
-        logger.debug("Initializing %s: (widget_class: '%s')",
-                     self.__class__.__name__, widget.winfo_class())
-        super().__init__(tearoff=0)
-        self.widget = widget
-        self.standard_actions()
-        logger.debug("Initialized %s", self.__class__.__name__)
 
-    def standard_actions(self):
-        """ Standard menu actions """
-        self.add_command(label="Cut", command=lambda: self.widget.event_generate("<<Cut>>"))
-        self.add_command(label="Copy", command=lambda: self.widget.event_generate("<<Copy>>"))
-        self.add_command(label="Paste", command=lambda: self.widget.event_generate("<<Paste>>"))
-        self.add_separator()
-        self.add_command(label="Select all", command=self.select_all)
-
-    def cm_bind(self):
-        """ Bind the menu to the widget's Right Click event """
-        button = "<Button-2>" if platform.system() == "Darwin" else "<Button-3>"
-        logger.debug("Binding '%s' to '%s'", button, self.widget.winfo_class())
-        scaling_factor = get_config().scaling_factor if get_config() is not None else 1.0
-        x_offset = int(34 * scaling_factor)
-        self.widget.bind(button,
-                         lambda event: self.tk_popup(event.x_root + x_offset, event.y_root, 0))
-
-    def select_all(self):
-        """ Select all for Text or Entry widgets """
-        logger.debug("Selecting all for '%s'", self.widget.winfo_class())
-        if self.widget.winfo_class() == "Text":
-            self.widget.focus_force()
-            self.widget.tag_add("sel", "1.0", "end")
-        else:
-            self.widget.focus_force()
-            self.widget.select_range(0, tk.END)
+class LongRunningTask(Thread):
+    """ Runs long running tasks in a background thread to prevent the GUI from becoming
+    unresponsive.
 
+    This is sub-classed from :class:`Threading.Thread` so check documentation there for base
+    parameters. Additional parameters listed below.
 
-class LongRunningTask(Thread):
-    """ For long running tasks, to stop the GUI becoming unresponsive
-        Run in a thread and handle cursor events """
+    Parameters
+    ----------
+    widget: tkinter object, optional
+        The widget that this :class:`LongRunningTask` is associated with. Used for setting the busy
+        cursor in the correct location. Default: ``None``.
+    """
     def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=True,
                  widget=None):
         logger.debug("Initializing %s: (group: %s, target: %s, name: %s, args: %s, kwargs: %s, "
@@ -870,15 +1047,22 @@ class LongRunningTask(Thread):
         super().__init__(group=group, target=target, name=name, args=args, kwargs=kwargs,
                          daemon=daemon)
         self.err = None
-        self.widget = widget
+        self._widget = widget
         self._config = get_config()
-        self._config.set_cursor_busy(widget=self.widget)
-        self.complete = Event()
+        self._config.set_cursor_busy(widget=self._widget)
+        self._complete = Event()
         self._queue = Queue()
         logger.debug("Initialized %s", self.__class__.__name__,)
 
+    @property
+    def complete(self):
+        """ :class:`threading.Event`:  Event is set if the thread has completed its task,
+        otherwise it is unset.
+        """
+        return self._complete
+
     def run(self):
-        """ Run the target in a thread """
+        """ Commence the given task in a background thread. """
         try:
             if self._target:
                 retval = self._target(*self._args, **self._kwargs)
@@ -888,24 +1072,32 @@ class LongRunningTask(Thread):
             logger.debug("Error in thread (%s): %s", self._name,
                          self.err[1].with_traceback(self.err[2]))
         finally:
-            self.complete.set()
-            # Avoid a refcycle if the thread is running a function with
+            self._complete.set()
+            # Avoid a ref-cycle if the thread is running a function with
             # an argument that has a member that points to the thread.
             del self._target, self._args, self._kwargs
 
     def get_result(self):
-        """ Return the result from the queue """
-        if not self.complete.is_set():
+        """ Return the result from the given task.
+
+        Returns
+        -------
+        varies:
+            The result of the thread will depend on the given task. If a call is made to
+            :func:`get_result` prior to the thread completing its task then ``None`` will be
+            returned
+        """
+        if not self._complete.is_set():
             logger.warning("Aborting attempt to retrieve result from a LongRunningTask that is "
                            "still running")
             return None
         if self.err:
             logger.debug("Error caught in thread")
-            self._config.set_cursor_default(widget=self.widget)
+            self._config.set_cursor_default(widget=self._widget)
             raise self.err[1].with_traceback(self.err[2])
 
         logger.debug("Getting result from thread")
         retval = self._queue.get()
         logger.debug("Got result from thread")
-        self._config.set_cursor_default(widget=self.widget)
+        self._config.set_cursor_default(widget=self._widget)
         return retval
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index 36cebc7..1eab26c 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -24,18 +24,18 @@ class ProcessWrapper():
     """ Builds command, launches and terminates the underlying
         faceswap process. Updates GUI display depending on state """
 
-    def __init__(self, pathscript=None):
-        logger.debug("Initializing %s: (pathscript: %s)", self.__class__.__name__, pathscript)
+    def __init__(self):
+        logger.debug("Initializing %s", self.__class__.__name__)
         self.tk_vars = get_config().tk_vars
         self.set_callbacks()
-        self.pathscript = pathscript
+        self.pathscript = os.path.realpath(os.path.dirname(sys.argv[0]))
         self.command = None
         self.statusbar = get_config().statusbar
         self.task = FaceswapControl(self)
         logger.debug("Initialized %s", self.__class__.__name__)
 
     def set_callbacks(self):
-        """ Set the tk variable callbacks """
+        """ Set the tkinter variable callbacks """
         logger.debug("Setting tk variable traces")
         self.tk_vars["action"].trace("w", self.action_command)
         self.tk_vars["generate"].trace("w", self.generate_command)
@@ -364,7 +364,7 @@ class FaceswapControl():
         """ Terminate the subprocess """
         logger.debug("Terminating wrapper")
         if command == "train":
-            timeout = self.config.tk_vars["traintimeout"].get()
+            timeout = self.config.user_config_dict.get("timeout", 120)
             logger.debug("Sending Exit Signal")
             print("Sending Exit Signal", flush=True)
             now = time()
@@ -390,7 +390,7 @@ class FaceswapControl():
 
     @staticmethod
     def generate_windows_keypress(character):
-        """ Generate an 'Enter' keypress to terminate Windows training """
+        """ Generate an 'Enter' key press to terminate Windows training """
         buf = win32console.PyINPUT_RECORDType(  # pylint:disable=c-extension-no-member
             win32console.KEY_EVENT)  # pylint:disable=c-extension-no-member
         buf.KeyDown = 1
diff --git a/scripts/gui.py b/scripts/gui.py
index f2032d9..df5f70d 100644
--- a/scripts/gui.py
+++ b/scripts/gui.py
@@ -2,14 +2,14 @@
 """ The optional GUI for faceswap """
 
 import logging
-import os
 import sys
 import tkinter as tk
 from tkinter import messagebox, ttk
 
-from lib.gui import (CliOptions, CommandNotebook, ConsoleOut, Session, DisplayNotebook,
-                     get_config, get_images, initialize_images, initialize_config, MainMenuBar,
-                     ProcessWrapper, StatusBar)
+from lib.gui import (TaskBar, CliOptions, CommandNotebook, ConsoleOut, Session, DisplayNotebook,
+                     get_images, initialize_images, initialize_config, LastSession,
+                     MainMenuBar, ProcessWrapper, StatusBar)
+from lib.utils import set_system_verbosity
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -17,39 +17,40 @@ logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 class FaceswapGui(tk.Tk):
     """ The Graphical User Interface """
 
-    def __init__(self, pathscript):
+    def __init__(self, debug):
         logger.debug("Initializing %s", self.__class__.__name__)
         super().__init__()
 
-        self.initialize_globals(pathscript)
+        self._init_args = dict(debug=debug)
+        self._config = self.initialize_globals()
         self.set_fonts()
         self.set_styles()
         self.set_geometry()
 
-        self.wrapper = ProcessWrapper(pathscript)
+        self.wrapper = ProcessWrapper()
         self.objects = dict()
 
         get_images().delete_preview()
         self.protocol("WM_DELETE_WINDOW", self.close_app)
+        self.build_gui()
+        self._last_session = LastSession(self._config)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def initialize_globals(self, pathscript):
+    def initialize_globals(self):
         """ Initialize config and images global constants """
         cliopts = CliOptions()
-        scaling_factor = self.get_scaling()
-        pathcache = os.path.join(pathscript, "lib", "gui", ".cache")
         statusbar = StatusBar(self)
         session = Session()
-        initialize_config(self, cliopts, scaling_factor, pathcache, statusbar, session)
+        config = initialize_config(self, cliopts, statusbar, session)
         initialize_images()
+        return config
 
-    @staticmethod
-    def set_fonts():
+    def set_fonts(self):
         """ Set global default font """
-        tk.font.nametofont("TkFixedFont").configure(size=get_config().default_font[1])
+        tk.font.nametofont("TkFixedFont").configure(size=self._config.default_font[1])
         for font in ("TkDefaultFont", "TkHeadingFont", "TkMenuFont"):
-            tk.font.nametofont(font).configure(family=get_config().default_font[0],
-                                               size=get_config().default_font[1])
+            tk.font.nametofont(font).configure(family=self._config.default_font[0],
+                                               size=self._config.default_font[1])
 
     @staticmethod
     def set_styles():
@@ -57,17 +58,10 @@ class FaceswapGui(tk.Tk):
         gui_style = ttk.Style()
         gui_style.configure('TLabelframe.Label', foreground="#0046D5", relief=tk.SOLID)
 
-    def get_scaling(self):
-        """ Get the display DPI """
-        dpi = self.winfo_fpixels("1i")
-        scaling = dpi / 72.0
-        logger.debug("dpi: %s, scaling: %s'", dpi, scaling)
-        return scaling
-
     def set_geometry(self):
         """ Set GUI geometry """
-        fullscreen = get_config().user_config_dict["fullscreen"]
-        scaling_factor = get_config().scaling_factor
+        fullscreen = self._config.user_config_dict["fullscreen"]
+        scaling_factor = self._config.scaling_factor
 
         if fullscreen:
             initial_dimensions = (self.winfo_screenwidth(), self.winfo_screenheight())
@@ -83,20 +77,29 @@ class FaceswapGui(tk.Tk):
                                                str(initial_dimensions[1])))
         logger.debug("Geometry: %sx%s", *initial_dimensions)
 
-    def build_gui(self, debug_console):
+    def build_gui(self, rebuild=False):
         """ Build the GUI """
         logger.debug("Building GUI")
-        self.title("Faceswap.py")
-        self.tk.call('wm', 'iconphoto', self._w, get_images().icons["favicon"])
-        self.configure(menu=MainMenuBar(self))
+        if not rebuild:
+            self.tk.call('wm', 'iconphoto', self._w, get_images().icons["favicon"])
+            self.configure(menu=MainMenuBar(self))
 
+        if rebuild:
+            objects = list(self.objects.keys())
+            for obj in objects:
+                self.objects[obj].destroy()
+                del self.objects[obj]
+
+        self.objects["taskbar"] = TaskBar(self)
         self.add_containers()
 
-        self.objects["command"] = CommandNotebook(self.objects["containers"]["top"])
-        self.objects["display"] = DisplayNotebook(self.objects["containers"]["top"])
-        self.objects["console"] = ConsoleOut(self.objects["containers"]["bottom"], debug_console)
+        self.objects["command"] = CommandNotebook(self.objects["container_top"])
+        self.objects["display"] = DisplayNotebook(self.objects["container_top"])
+        self.objects["console"] = ConsoleOut(self.objects["container_bottom"],
+                                             self._init_args["debug"])
         self.set_initial_focus()
         self.set_layout()
+        self._config.project.initialize_default_options()
         logger.debug("Built GUI")
 
     def add_containers(self):
@@ -121,75 +124,93 @@ class FaceswapGui(tk.Tk):
 
         bottomcontainer = ttk.Frame(maincontainer, name="frame_bottom")
         maincontainer.add(bottomcontainer)
-        self.objects["containers"] = dict(main=maincontainer,
-                                          top=topcontainer,
-                                          bottom=bottomcontainer)
+        self.objects["container_main"] = maincontainer
+        self.objects["container_top"] = topcontainer
+        self.objects["container_bottom"] = bottomcontainer
 
         logger.debug("Added containers")
 
-    @staticmethod
-    def set_initial_focus():
+    def set_initial_focus(self):
         """ Set the tab focus from settings """
-        config = get_config()
-        tab = config.user_config_dict["tab"]
+        tab = self._config.user_config_dict["tab"]
         logger.debug("Setting focus for tab: %s", tab)
-        tabs = config.command_tabs
-        if tab in tabs:
-            config.command_notebook.select(tabs[tab])
-        else:
-            tool_tabs = config.tools_command_tabs
-            if tab in tool_tabs:
-                config.command_notebook.select(tabs["tools"])
-                config.command_notebook.tools_notebook.select(tool_tabs[tab])
+        self._config.set_active_tab_by_name(tab)
         logger.debug("Focus set to: %s", tab)
 
     def set_layout(self):
         """ Set initial layout """
         self.update_idletasks()
-        root = get_config().root
-        config = get_config().user_config_dict
-        r_width = root.winfo_width()
-        r_height = root.winfo_height()
-        w_ratio = config["options_panel_width"] / 100.0
-        h_ratio = 1 - (config["console_panel_height"] / 100.0)
+        config_opts = self._config.user_config_dict
+        r_width = self.winfo_width()
+        r_height = self.winfo_height()
+        w_ratio = config_opts["options_panel_width"] / 100.0
+        h_ratio = 1 - (config_opts["console_panel_height"] / 100.0)
         width = round(r_width * w_ratio)
         height = round(r_height * h_ratio)
         logger.debug("Setting Initial Layout: (root_width: %s, root_height: %s, width_ratio: %s, "
                      "height_ratio: %s, width: %s, height: %s", r_width, r_height, w_ratio,
                      h_ratio, width, height)
-        self.objects["containers"]["top"].sash_place(0, width, 1)
-        self.objects["containers"]["main"].sash_place(0, 1, height)
+        self.objects["container_top"].sash_place(0, width, 1)
+        self.objects["container_main"].sash_place(0, 1, height)
         self.update_idletasks()
 
-    def close_app(self):
+    def rebuild(self):
+        """ Rebuild the GUI on config change """
+        logger.debug("Redrawing GUI")
+        session_state = self._last_session.to_dict()
+        self._config.refresh_config()
+        get_images().__init__()
+        self.set_fonts()
+        self.build_gui(rebuild=True)
+        if session_state is not None:
+            self._last_session.from_dict(session_state)
+        logger.debug("GUI Redrawn")
+
+    def close_app(self, *args):  # pylint: disable=unused-argument
         """ Close Python. This is here because the graph
             animation function continues to run even when
             tkinter has gone away """
         logger.debug("Close Requested")
-        confirm = messagebox.askokcancel
-        confirmtxt = "Processes are still running. Are you sure...?"
-        tk_vars = get_config().tk_vars
-        if (tk_vars["runningtask"].get()
-                and not confirm("Close", confirmtxt)):
-            logger.debug("Close Cancelled")
+
+        if not self._confirm_close_on_running_task():
+            return
+        if not self._config.project.confirm_close():
             return
-        if tk_vars["runningtask"].get():
+
+        if self._config.tk_vars["runningtask"].get():
             self.wrapper.task.terminate()
+
+        self._last_session.save()
         get_images().delete_preview()
         self.quit()
         logger.debug("Closed GUI")
         exit()
 
+    def _confirm_close_on_running_task(self):
+        """ Pop a confirmation box to close the GUI if a task is running
+
+        Returns
+        -------
+        bool: ``True`` if user confirms close, ``False`` if user cancels close
+        """
+        if not self._config.tk_vars["runningtask"].get():
+            logger.debug("No tasks currently running")
+            return True
+
+        confirmtxt = "Processes are still running.\n\nAre you sure you want to exit?"
+        if not messagebox.askokcancel("Close", confirmtxt, default="cancel", icon="warning"):
+            logger.debug("Close Cancelled")
+            return True
+        logger.debug("Close confirmed")
+        return False
+
 
 class Gui():  # pylint: disable=too-few-public-methods
     """ The GUI process. """
     def __init__(self, arguments):
-        cmd = sys.argv[0]
-        pathscript = os.path.realpath(os.path.dirname(cmd))
-        self.args = arguments
-        self.root = FaceswapGui(pathscript)
+        set_system_verbosity(arguments.loglevel)
+        self.root = FaceswapGui(arguments.debug)
 
     def process(self):
         """ Builds the GUI """
-        self.root.build_gui(self.args.debug)
         self.root.mainloop()
diff --git a/tools/cli.py b/tools/cli.py
index d3e3eef..28cb2a9 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -207,7 +207,7 @@ class PreviewArgs(FaceSwapArgs):
                               "default": False,
                               "backend": "nvidia",
                               "help": "Sets allow_growth option of Tensorflow to spare memory "
-                              "on some configurations."})
+                                      "on some configurations."})
 
         return argument_list
 
@@ -462,6 +462,7 @@ class MaskArgs(FaceSwapArgs):
             "action": DirOrFileFullPaths,
             "type": str,
             "group": "data",
+            "filetypes": "video",
             "required": True,
             "help": "Directory containing extracted faces, source frames, or a video file."})
         argument_list.append({
diff --git a/tools/preview.py b/tools/preview.py
index 5c33d0f..5fbe9f0 100644
--- a/tools/preview.py
+++ b/tools/preview.py
@@ -6,7 +6,7 @@ import random
 import tkinter as tk
 from tkinter import ttk
 import os
-import sys
+
 from configparser import ConfigParser
 from threading import Event, Lock
 
@@ -16,7 +16,8 @@ from PIL import Image, ImageTk
 
 from lib.aligner import Extract as AlignerExtract
 from lib.cli import ConvertArgs
-from lib.gui.utils import get_images, initialize_images, ContextMenu
+from lib.gui.custom_widgets import ContextMenu
+from lib.gui.utils import get_images, initialize_images
 from lib.gui.tooltip import Tooltip
 from lib.gui.control_helper import set_slider_rounding
 from lib.convert import Converter
@@ -71,9 +72,7 @@ class Preview():
     def initialize_tkinter(self):
         """ Initialize tkinter for standalone or GUI """
         logger.debug("Initializing tkinter")
-        pathscript = os.path.realpath(os.path.dirname(sys.argv[0]))
-        pathcache = os.path.join(pathscript, "lib", "gui", ".cache")
-        initialize_images(pathcache=pathcache)
+        initialize_images()
         self.set_geometry()
         self.root.title("Faceswap.py - Convert Settings")
         self.root.tk.call(
@@ -784,7 +783,7 @@ class ActionFrame(ttk.Frame):  # pylint: disable=too-many-ancestors
         self.busy_indicator.start()
 
     def add_actions(self, parent):
-        """ Add Actio Buttons """
+        """ Add Action Buttons """
         logger.debug("Adding util buttons")
         frame = ttk.Frame(parent)
         frame.pack(padx=5, pady=(5, 10), side=tk.BOTTOM, fill=tk.X, anchor=tk.E)
@@ -942,7 +941,7 @@ class ConfigFrame(ttk.Frame):  # pylint: disable=too-many-ancestors
         return sep
 
     def add_actions(self, parent, config_key):
-        """ Add Actio Buttons """
+        """ Add Action Buttons """
         logger.debug("Adding util buttons")
 
         title = config_key.split(".")[1].replace("_", " ").title()
@@ -968,7 +967,6 @@ class ConfigFrame(ttk.Frame):  # pylint: disable=too-many-ancestors
 
 
 class ControlBuilder():
-    # TODO Expand out for cli options
     """
     Builds and returns a frame containing a tkinter control with label
 

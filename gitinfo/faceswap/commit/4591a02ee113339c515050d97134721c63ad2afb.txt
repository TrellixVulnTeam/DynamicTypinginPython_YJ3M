commit 4591a02ee113339c515050d97134721c63ad2afb
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sun Nov 24 13:54:33 2019 +0000

    bugfix: tools.preview - Fix for new icons
    bugfix: lib.vgg_face2_keras - Remove debug code
    documentation: lib.vgg_face2_keras

diff --git a/docs/full/lib.rst b/docs/full/lib.rst
index d1aebce..ce60321 100644
--- a/docs/full/lib.rst
+++ b/docs/full/lib.rst
@@ -12,6 +12,7 @@ Subpackages
    lib.model
    lib.serializer
    lib.training_data
+   lib.vgg_face2_keras
 
 Module contents
 ---------------
diff --git a/docs/full/lib.vgg_face2_keras.rst b/docs/full/lib.vgg_face2_keras.rst
new file mode 100644
index 0000000..eeb6088
--- /dev/null
+++ b/docs/full/lib.vgg_face2_keras.rst
@@ -0,0 +1,7 @@
+lib.vgg\_face2\_keras module
+============================
+
+.. automodule:: lib.vgg_face2_keras
+   :members:
+   :undoc-members:
+   :show-inheritance:
diff --git a/lib/vgg_face2_keras.py b/lib/vgg_face2_keras.py
index b071454..5dfbeae 100644
--- a/lib/vgg_face2_keras.py
+++ b/lib/vgg_face2_keras.py
@@ -1,11 +1,5 @@
 #!/usr/bin python3
-""" VGG_Face2 inference
-Model exported from: https://github.com/WeidiXie/Keras-VGGFace2-ResNet50
-which is based on: https://www.robots.ox.ac.uk/~vgg/software/vgg_face/
-
-Licensed under Creative Commons Attribution License.
-https://creativecommons.org/licenses/by-nc/4.0/
-"""
+""" VGG_Face2 inference and sorting """
 
 import logging
 import sys
@@ -22,7 +16,27 @@ logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
 class VGGFace2():
     """ VGG Face feature extraction.
-        Input images should be in BGR Order """
+
+    Extracts feature vectors from faces in order to compare similarity.
+
+    Parameters
+    ----------
+    backend: ['GPU', 'CPU']
+        Whether to run inference on a GPU or on the CPU
+    loglevel: ['INFO', 'VERBODE', 'DEBUG', 'TRACE']
+        The system log level
+
+    Notes
+    -----
+    Input images should be in BGR Order
+
+    Model exported from: https://github.com/WeidiXie/Keras-VGGFace2-ResNet50 which is based on:
+    https://www.robots.ox.ac.uk/~vgg/software/vgg_face/
+
+
+    Licensed under Creative Commons Attribution License.
+    https://creativecommons.org/licenses/by-nc/4.0/
+    """
 
     def __init__(self, backend="GPU", loglevel="INFO"):
         logger.debug("Initializing %s: (backend: %s, loglevel: %s)",
@@ -35,13 +49,29 @@ class VGGFace2():
         # Average image provided in https://github.com/ox-vgg/vgg_face2
         self.average_img = np.array([91.4953, 103.8827, 131.0912])
 
-        self.model = self.get_model(git_model_id, model_filename, backend)
+        self.model = self._get_model(git_model_id, model_filename, backend)
         logger.debug("Initialized %s", self.__class__.__name__)
 
     # <<< GET MODEL >>> #
     @staticmethod
-    def get_model(git_model_id, model_filename, backend):
-        """ Check if model is available, if not, download and unzip it """
+    def _get_model(git_model_id, model_filename, backend):
+        """ Check if model is available, if not, download and unzip it
+
+        Parameters
+        ----------
+        git_model_id: int
+            The second digit in the github tag that identifies this model. See
+            https://github.com/deepfakes-models/faceswap-models for more information
+        model_filename: str
+            The name of the model to be loaded (see :class:`lib.utils.GetModel` for more
+            information)
+        backend: ['GPU', 'CPU']
+            Whether to run inference on a GPU or on the CPU
+
+        See Also
+        --------
+        lib.utils.GetModel: The model downloading and allocation class.
+        """
         root_path = os.path.abspath(os.path.dirname(sys.argv[0]))
         cache_path = os.path.join(root_path, "plugins", "extract", "recognition", ".cache")
         model = GetModel(model_filename, cache_path, git_model_id).model_path
@@ -62,15 +92,37 @@ class VGGFace2():
             })
 
     def predict(self, face):
-        """ Return encodings for given image from vgg_face """
+        """ Return encodings for given image from vgg_face2.
+
+        Parameters
+        ----------
+        face: numpy.ndarray
+            The face to be fed through the predictor. Should be in BGR channel order
+
+        Returns
+        -------
+        numpy.ndarray
+            The encodings for the face
+        """
         if face.shape[0] != self.input_size:
-            face = self.resize_face(face)
+            face = self._resize_face(face)
         face = face[None, :, :, :3] - self.average_img
         preds = self.model.predict(face)
         return preds[0, :]
 
-    def resize_face(self, face):
-        """ Resize incoming face to model_input_size """
+    def _resize_face(self, face):
+        """ Resize incoming face to model_input_size.
+
+        Parameters
+        ----------
+        face: numpy.ndarray
+            The face to be fed through the predictor. Should be in BGR channel order
+
+        Returns
+        -------
+        numpy.ndarray
+            The face resized to model input size
+        """
         sizes = (self.input_size, self.input_size)
         interpolation = cv2.INTER_CUBIC if face.shape[0] < self.input_size else cv2.INTER_AREA
         face = cv2.resize(face, dsize=sizes, interpolation=interpolation)
@@ -78,47 +130,64 @@ class VGGFace2():
 
     @staticmethod
     def find_cosine_similiarity(source_face, test_face):
-        """ Find the cosine similarity between a source face and a test face """
+        """ Find the cosine similarity between two faces.
+
+        Parameters
+        ----------
+        source_face: numpy.ndarray
+            The first face to test against :attr:`test_face`
+        test_face: numpy.ndarray
+            The second face to test against :attr:`source_face`
+
+        Returns
+        -------
+        float:
+            The cosine similarity between the two faces
+        """
         var_a = np.matmul(np.transpose(source_face), test_face)
         var_b = np.sum(np.multiply(source_face, source_face))
         var_c = np.sum(np.multiply(test_face, test_face))
         return 1 - (var_a / (np.sqrt(var_b) * np.sqrt(var_c)))
 
     def sorted_similarity(self, predictions, method="ward"):
-        """ Sort a matrix of predictions by similarity Adapted from:
-            https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html
-        input:
-            - predictions is a stacked matrix of vgg_face predictions shape: (x, 4096)
-            - method = ["ward","single","average","complete"]
-        output:
-            - result_order is a list of indices with the order implied by the hierarhical tree
-
-        sorted_similarity transforms a distance matrix into a sorted distance matrix according to
-        the order implied by the hierarchical tree (dendrogram)
+        """ Sort a matrix of predictions by similarity.
+
+        Transforms a distance matrix into a sorted distance matrix according to the order implied
+        by the hierarchical tree (dendrogram).
+
+        Parameters
+        ----------
+        predictions: numpy.ndarray
+            A stacked matrix of vgg_face2 predictions of the shape (`N`, `D`) where `N` is the
+            number of observations and `D` are the number of dimensions.  NB: The given
+            :attr:`predictions` will be overwritten to save memory. If you still require the 
+            original values you should take a copy prior to running this method
+        method: ['single','centroid','median','ward']
+            The clustering method to use.
+
+        Returns
+        -------
+        list:
+            List of indices with the order implied by the hierarchical tree
         """
         logger.info("Sorting face distances. Depending on your dataset this may take some time...")
         num_predictions, dims = predictions.shape
 
-        clustering_method = self._get_clustering_method(num_predictions, dims)
-
         kwargs = dict(method=method)
-        if clustering_method == "linkage":
+        if self._use_vector_linkage(num_predictions, dims):
+            func = linkage_vector
+        else:
             kwargs["preserve_input"] = False
             func = linkage
-        else:
-            func = linkage_vector
 
         result_linkage = func(predictions, **kwargs)
-        print(result_linkage.shape)
-        exit(0)
-        result_order = self.seriation(result_linkage,
-                                      num_predictions,
-                                      num_predictions + num_predictions - 2)
-
+        result_order = self._seriation(result_linkage,
+                                       num_predictions,
+                                       num_predictions + num_predictions - 2)
         return result_order
 
     @staticmethod
-    def _get_clustering_method(item_count, dims):
+    def _use_vector_linkage(item_count, dims):
         """ Calculate the RAM that will be required to sort these images and select the appropriate
         clustering method.
 
@@ -128,7 +197,7 @@ class VGGFace2():
             also:
             "half the memory can be saved by specifying :attr:`preserve_input`=``False``"
 
-        To avoid undercalculating we divide the memory calculation by 1.7 instead of 2
+        To avoid under calculating we divide the memory calculation by 1.8 instead of 2
 
         Parameters
         ----------
@@ -139,45 +208,55 @@ class VGGFace2():
 
         Returns
         -------
-            str: 'linkage' or 'vector'
+            bool:
+                ``True`` if vector_linkage should be used. ``False`` if linkage should be used
         """
         np_float = 24  # bytes size of a numpy float
         divider = 1024 * 1024  # bytes to MB
 
         free_ram = psutil.virtual_memory().free / divider
-        linkage_required = (((item_count ** 2) * np_float) / 1.7) / divider
+        linkage_required = (((item_count ** 2) * np_float) / 1.8) / divider
         vector_required = ((item_count * dims) * np_float) / divider
         logger.debug("free_ram: %sMB, linkage_required: %sMB, vector_required: %sMB",
                      int(free_ram), int(linkage_required), int(vector_required))
 
         if linkage_required < free_ram:
             logger.verbose("Using linkage method")
-            retval = "linkage"
+            retval = False
         elif vector_required < free_ram:
             logger.warning("Not enough RAM to perform linkage clustering. Using vector "
                            "clustering. This will be significantly slower. Free RAM: %sMB. "
                            "Required for linkage method: %sMB",
                            int(free_ram), int(linkage_required))
-            retval = "vector"
+            retval = True
         else:
             raise FaceswapError("Not enough RAM available to sort faces. Try reducing "
                                 "the size of  your dataset. Free RAM: {}MB. "
                                 "Required RAM: {}MB".format(int(free_ram), int(vector_required)))
+        logger.debug(retval)
         return retval
 
-    def seriation(self, tree, points, current_index):
-        """ Seriation method for sorted similarity
-            input:
-                - tree is a hierarchical tree (dendrogram)
-                - points is the number of points given to the clustering process
-                - current_index is the position in the tree for the recursive traversal
-            output:
-                - order implied by the hierarchical tree
+    def _seriation(self, tree, points, current_index):
+        """ Seriation method for sorted similarity.
 
-            seriation computes the order implied by a hierarchical tree (dendrogram)
+        Seriation computes the order implied by a hierarchical tree (dendrogram).
+
+        Parameters
+        ----------
+        tree: numpy.ndarray
+           A hierarchical tree (dendrogram)
+        points: int
+            The number of points given to the clustering process
+        current_index: int
+            The position in the tree for the recursive traversal
+
+        Returns
+        -------
+        list:
+            The indices in the order implied by the hierarchical tree
         """
         if current_index < points:
             return [current_index]
         left = int(tree[current_index-points, 0])
         right = int(tree[current_index-points, 1])
-        return self.seriation(tree, points, left) + self.seriation(tree, points, right)
+        return self._seriation(tree, points, left) + self._seriation(tree, points, right)
diff --git a/tools/preview.py b/tools/preview.py
index 1becd7a..5c05eb9 100644
--- a/tools/preview.py
+++ b/tools/preview.py
@@ -17,7 +17,7 @@ from PIL import Image, ImageTk
 from lib.aligner import Extract as AlignerExtract
 from lib.cli import ConvertArgs
 from lib.gui.custom_widgets import ContextMenu
-from lib.gui.utils import get_images, initialize_images
+from lib.gui.utils import get_images, initialize_config, initialize_images
 from lib.gui.custom_widgets import Tooltip
 from lib.gui.control_helper import set_slider_rounding
 from lib.convert import Converter
@@ -72,6 +72,7 @@ class Preview():
     def initialize_tkinter(self):
         """ Initialize tkinter for standalone or GUI """
         logger.debug("Initializing tkinter")
+        initialize_config(self.root, None, None, None)
         initialize_images()
         self.set_geometry()
         self.root.title("Faceswap.py - Convert Settings")

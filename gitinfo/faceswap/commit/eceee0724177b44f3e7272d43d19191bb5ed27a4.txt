commit eceee0724177b44f3e7272d43d19191bb5ed27a4
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Tue Oct 15 16:08:20 2019 +0000

    Legacy alignments update
    
    - Remove legacy update hashes
    - Remove legacy job from alignment-tools
    - Remove legacy landmark rotation
    - Add rotate face method to plugins/extract/detect
    - Update travis test for new alignments extension
    - Alignments format to .fsa
    - Remove serializer option from alignments-tool
    - Auto update legacy format alignment files to new format

diff --git a/_travis/simple_tests.py b/_travis/simple_tests.py
index 89c8776..52d0530 100644
--- a/_travis/simple_tests.py
+++ b/_travis/simple_tests.py
@@ -154,7 +154,7 @@ if __name__ == '__main__':
             "Rename sorted faces.",
             (
                 py_exe, "tools.py", "alignments", "-j", "rename",
-                "-a", pathjoin(vid_base, "test_alignments.json"),
+                "-a", pathjoin(vid_base, "test_alignments.fsa"),
                 "-fc", pathjoin(vid_base, "faces_sorted"),
             )
         )
@@ -163,7 +163,7 @@ if __name__ == '__main__':
             "Train lightweight model for 1 iteration with WTL.",
             train_args(
                 "lightweight", pathjoin(vid_base, "model"),
-                pathjoin(vid_base, "faces"), pathjoin(vid_base, "test_alignments.json"),
+                pathjoin(vid_base, "faces"), pathjoin(vid_base, "test_alignments.fsa"),
                 iterations=1, extra_args="-wl"
             )
         )
@@ -172,7 +172,7 @@ if __name__ == '__main__':
             "Train lightweight model for 5 iterations WITHOUT WTL.",
             train_args(
                 "lightweight", pathjoin(vid_base, "model"),
-                pathjoin(vid_base, "faces"), pathjoin(vid_base, "test_alignments.json")
+                pathjoin(vid_base, "faces"), pathjoin(vid_base, "test_alignments.fsa")
             )
         )
 
diff --git a/lib/alignments.py b/lib/alignments.py
index 294dd1a..09f9b55 100644
--- a/lib/alignments.py
+++ b/lib/alignments.py
@@ -6,10 +6,8 @@ import logging
 import os
 from datetime import datetime
 
-import cv2
-
-from lib.faces_detect import rotate_landmarks
 from lib.serializer import get_serializer, get_serializer_from_filename
+from lib.utils import FaceswapError
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -26,7 +24,7 @@ class Alignments():
     def __init__(self, folder, filename="alignments"):
         logger.debug("Initializing %s: (folder: '%s', filename: '%s')",
                      self.__class__.__name__, folder, filename)
-        self.serializer = self.get_serializer(filename)
+        self.serializer = get_serializer("compressed")
         self.file = self.get_location(folder, filename)
 
         self.data = self.load()
@@ -69,38 +67,21 @@ class Alignments():
 
     # << INIT FUNCTIONS >> #
 
-    @staticmethod
-    def get_serializer(filename):
-        """ Set the serializer to be used for loading and
-            saving alignments
-
-            If a filename with a valid extension is passed in
-            this will be used as the serializer, otherwise the
-            compressed pickle will be used """
-        logger.debug("Getting serializer: (filename: '%s')", filename)
-        extension = os.path.splitext(filename)[1]
-        if extension in (".json", ".p", ".yaml", ".yml"):
-            logger.debug("Serializer set from filename extension: '%s'", extension)
-            retval = get_serializer_from_filename(filename)
-        else:
-            logger.debug("Returning default Pickle serializer")
-            retval = get_serializer("compressed")
-        logger.verbose("Using '%s' serializer for alignments", retval.file_extension)
-        return retval
-
     def get_location(self, folder, filename):
         """ Return the path to alignments file """
         logger.debug("Getting location: (folder: '%s', filename: '%s')", folder, filename)
         extension = os.path.splitext(filename)[1]
         if extension in (".json", ".p", ".yaml", ".yml"):
-            logger.debug("File extension set from filename: '%s'", extension)
-            location = os.path.join(str(folder), filename)
-        else:
-            location = os.path.join(str(folder),
-                                    "{}.{}".format(filename,
-                                                   self.serializer.file_extension))
+            # Reformat legacy alignments file
+            filename = self.update_file_format(folder, filename)
+            logger.debug("Updated legacy alignments. New filename: '%s'", filename)
+        elif not extension:
+            filename = "{}.{}".format(filename, self.serializer.file_extension)
             logger.debug("File extension set from serializer: '%s'",
                          self.serializer.file_extension)
+        elif extension != ".fsa":
+            raise FaceswapError("{} is not a valid alignments file".format(filename))
+        location = os.path.join(str(folder), filename)
         logger.verbose("Alignments filepath: '%s'", location)
         return location
 
@@ -111,8 +92,8 @@ class Alignments():
             Override for custom loading logic """
         logger.debug("Loading alignments")
         if not self.have_alignments_file:
-            raise ValueError("Error: Alignments file not found at "
-                             "{}".format(self.file))
+            raise FaceswapError("Error: Alignments file not found at "
+                                "{}".format(self.file))
 
         logger.info("Reading alignments from: '%s'", self.file)
         data = self.serializer.load(self.file)
@@ -262,95 +243,21 @@ class Alignments():
         if self.has_legacy_landmarksxy():
             logger.info("Updating legacy alignments")
             self.update_legacy_landmarksxy()
-    # < Rotation > #
-    # The old rotation method would rotate the image to find a face, then
-    # store the rotated landmarks along with a rotation value to tell the
-    # convert process that it had to rotate the frame to find the landmarks.
-    # This is problematic for numerous reasons. The process now rotates the
-    # landmarks to correctly correspond with the original frame. The below are
-    # functions to convert legacy alignments to the currently supported
-    # infrastructure.
-    # This can eventually be removed
-
-    def get_legacy_rotation(self):
-        """ Return a list of frames with legacy rotations
-            Looks for an 'r' value in the alignments file that
-            is not zero """
-        logger.debug("Getting alignments containing legacy rotations")
-        keys = list()
-        for key, val in self.data.items():
-            if any(alignment.get("r", None) for alignment in val):
-                keys.append(key)
-        logger.debug("Got alignments containing legacy rotations: %s", len(keys))
-        return keys
-
-    def rotate_existing_landmarks(self, frame_name, frame):
-        """ Backwards compatability fix. Rotates the landmarks to
-            their correct position and deletes r
-
-            NB: The original frame must be passed in otherwise
-            the transformation cannot be performed """
-        logger.trace("Rotating existing landmarks for frame: '%s'", frame_name)
-        dims = frame.shape[:2]
-        for face in self.get_faces_in_frame(frame_name):
-            angle = face.get("r", 0)
-            if not angle:
-                logger.trace("Landmarks do not require rotation: '%s'", frame_name)
-                return
-            logger.trace("Rotating landmarks: (frame: '%s', angle: %s)", frame_name, angle)
-            r_mat = self.get_original_rotation_matrix(dims, angle)
-            rotate_landmarks(face, r_mat)
-            del face["r"]
-        logger.trace("Rotatated existing landmarks for frame: '%s'", frame_name)
 
-    @staticmethod
-    def get_original_rotation_matrix(dimensions, angle):
-        """ Calculate original rotation matrix and invert """
-        logger.trace("Getting original rotation matrix: (dimensions: %s, angle: %s)",
-                     dimensions, angle)
-        height, width = dimensions
-        center = (width/2, height/2)
-        r_mat = cv2.getRotationMatrix2D(  # pylint: disable=no-member
-            center, -1.0 * angle, 1.)
-
-        abs_cos = abs(r_mat[0, 0])
-        abs_sin = abs(r_mat[0, 1])
-        rotated_width = int(height*abs_sin + width*abs_cos)
-        rotated_height = int(height*abs_cos + width*abs_sin)
-        r_mat[0, 2] += rotated_width/2 - center[0]
-        r_mat[1, 2] += rotated_height/2 - center[1]
-        logger.trace("Returning rotation matrix: %s", r_mat)
-        return r_mat
-
-    # <Face Hashes> #
-    # The old index based method of face matching is problematic.
-    # The SHA1 Hash of the extracted face is now stored in the alignments file.
-    # This has it's own issues, but they are far reduced from the index/filename method
-    # This can eventually be removed
-    def get_legacy_no_hashes(self):
-        """ Get alignments without face hashes """
-        logger.debug("Getting alignments without face hashes")
-        keys = list()
-        for key, val in self.data.items():
-            for alignment in val:
-                if "hash" not in alignment.keys():
-                    keys.append(key)
-                    break
-        logger.debug("Got alignments without face hashes: %s", len(keys))
-        return keys
-
-    def add_face_hashes(self, frame_name, hashes):
-        """ Backward compatability fix. Add face hash to alignments """
-        logger.trace("Adding face hash: (frame: '%s', hashes: %s)", frame_name, hashes)
-        faces = self.get_faces_in_frame(frame_name)
-        count_match = len(faces) - len(hashes)
-        if count_match != 0:
-            msg = "more" if count_match > 0 else "fewer"
-            logger.warning("There are %s %s face(s) in the alignments file than exist in the "
-                           "faces folder. Check your sources for frame '%s'.",
-                           abs(count_match), msg, frame_name)
-        for idx, i_hash in hashes.items():
-            faces[idx]["hash"] = i_hash
+    # <File Format> #
+    # Serializer is now a compressed pickle .fsa format. This used to be any number of serializers
+    def update_file_format(self, folder, filename):
+        """ Convert old style alignments format to new style format """
+        logger.info("Reformatting legacy alignments file...")
+        old_location = os.path.join(str(folder), filename)
+        new_location = "{}.{}".format(os.path.splitext(old_location)[0],
+                                      self.serializer.file_extension)
+        logger.info("Old location: '%s', New location: '%s'", old_location, new_location)
+
+        load_serializer = get_serializer_from_filename(old_location)
+        data = load_serializer.load(old_location)
+        self.serializer.save(new_location, data)
+        return os.path.basename(new_location)
 
     # <landmarks> #
     # Landmarks renamed from landmarksXY to landmarks_xy for PEP compliance
diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index efb460a..8f89d83 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -612,89 +612,3 @@ class Mask():
         retval = "_{}".format(dict_key) if dict_key != "stored_size" else dict_key
         logger.trace("dict_key: %s, attribute_name: %s", dict_key, retval)
         return retval
-
-
-def rotate_landmarks(face, rotation_matrix):
-    """ Rotates the 68 point landmarks and detection bounding box around the given rotation matrix.
-
-    Parameters
-    ----------
-    face: DetectedFace or dict
-        A :class:`DetectedFace` or an `alignments file` ``dict`` containing the 68 point landmarks
-        and the `x`, `w`, `y`, `h` detection bounding box points.
-    rotation_matrix: numpy.ndarray
-        The rotation matrix to rotate the given object by.
-
-    Returns
-    -------
-    DetectedFace or dict
-        The rotated :class:`DetectedFace` or `alignments file` ``dict`` with the landmarks and
-        detection bounding box points rotated by the given matrix. The return type is the same as
-        the input type for ``face``
-    """
-    logger.trace("Rotating landmarks: (rotation_matrix: %s, type(face): %s",
-                 rotation_matrix, type(face))
-    rotated_landmarks = None
-    # Detected Face Object
-    if isinstance(face, DetectedFace):
-        bounding_box = [[face.x, face.y],
-                        [face.x + face.w, face.y],
-                        [face.x + face.w, face.y + face.h],
-                        [face.x, face.y + face.h]]
-        landmarks = face.landmarks_xy
-
-    # Alignments Dict
-    elif isinstance(face, dict) and "x" in face:
-        bounding_box = [[face.get("x", 0), face.get("y", 0)],
-                        [face.get("x", 0) + face.get("w", 0),
-                         face.get("y", 0)],
-                        [face.get("x", 0) + face.get("w", 0),
-                         face.get("y", 0) + face.get("h", 0)],
-                        [face.get("x", 0),
-                         face.get("y", 0) + face.get("h", 0)]]
-        landmarks = face.get("landmarks_xy", list())
-
-    else:
-        raise ValueError("Unsupported face type")
-
-    logger.trace("Original landmarks: %s", landmarks)
-
-    rotation_matrix = cv2.invertAffineTransform(
-        rotation_matrix)
-    rotated = list()
-    for item in (bounding_box, landmarks):
-        if not item:
-            continue
-        points = np.array(item, np.int32)
-        points = np.expand_dims(points, axis=0)
-        transformed = cv2.transform(points,
-                                    rotation_matrix).astype(np.int32)
-        rotated.append(transformed.squeeze())
-
-    # Bounding box should follow x, y planes, so get min/max
-    # for non-90 degree rotations
-    pt_x = min([pnt[0] for pnt in rotated[0]])
-    pt_y = min([pnt[1] for pnt in rotated[0]])
-    pt_x1 = max([pnt[0] for pnt in rotated[0]])
-    pt_y1 = max([pnt[1] for pnt in rotated[0]])
-    width = pt_x1 - pt_x
-    height = pt_y1 - pt_y
-
-    if isinstance(face, DetectedFace):
-        face.x = int(pt_x)
-        face.y = int(pt_y)
-        face.w = int(width)
-        face.h = int(height)
-        face.r = 0
-        if len(rotated) > 1:
-            rotated_landmarks = [tuple(point) for point in rotated[1].tolist()]
-            face.landmarks_xy = rotated_landmarks
-    else:
-        face["left"] = int(pt_x)
-        face["top"] = int(pt_y)
-        face["right"] = int(pt_x1)
-        face["bottom"] = int(pt_y1)
-        rotated_landmarks = face
-
-    logger.trace("Rotated landmarks: %s", rotated_landmarks)
-    return face
diff --git a/lib/gui/utils.py b/lib/gui/utils.py
index 095a918..abe40c1 100644
--- a/lib/gui/utils.py
+++ b/lib/gui/utils.py
@@ -92,9 +92,7 @@ class FileHandler():
         """ Set the filetypes for opening/saving """
         all_files = ("All files", "*.*")
         filetypes = {"default": (all_files,),
-                     "alignments": [("JSON", "*.json"),
-                                    ("Pickle", "*.p"),
-                                    ("YAML", "*.yaml *.yml"),
+                     "alignments": [("Faceswap Alignments", "*.fsa"),
                                     all_files],
                      "config": [("Faceswap GUI config files", "*.fsw"), all_files],
                      "csv": [("Comma separated values", "*.csv"), all_files],
diff --git a/lib/serializer.py b/lib/serializer.py
index 1b5b7e4..eca9222 100644
--- a/lib/serializer.py
+++ b/lib/serializer.py
@@ -255,7 +255,7 @@ class _CompressedSerializer(Serializer):
     """ A compressed pickle serializer for Faceswap """
     def __init__(self):
         super().__init__()
-        self._file_extension = "fsc"
+        self._file_extension = "fsa"
         self._child = get_serializer("pickle")
 
     def _marshal(self, data):
@@ -334,7 +334,7 @@ def get_serializer_from_filename(filename):
         retval = _PickleSerializer()
     elif extension == ".npy":
         retval = _NPYSerializer()
-    elif extension == ".fsc":
+    elif extension == ".fsa":
         retval = _CompressedSerializer()
     elif extension in (".yaml", ".yml") and yaml is not None:
         retval = _YAMLSerializer()
diff --git a/plugins/extract/detect/_base.py b/plugins/extract/detect/_base.py
index 81907e0..21c3183 100644
--- a/plugins/extract/detect/_base.py
+++ b/plugins/extract/detect/_base.py
@@ -18,7 +18,7 @@ To get a :class:`~lib.faces_detect.DetectedFace` object use the function:
 import cv2
 import numpy as np
 
-from lib.faces_detect import DetectedFace, rotate_landmarks
+from lib.faces_detect import DetectedFace
 from plugins.extract._base import Extractor, logger
 
 
@@ -164,7 +164,7 @@ class Detector(Extractor):
                        for faces in batch["prediction"]]
         # Rotations
         if any(m.any() for m in batch["rotmat"]) and any(batch_faces):
-            batch_faces = [[self._rotate_rect(face, rotmat) if rotmat.any() else face
+            batch_faces = [[self._rotate_face(face, rotmat) if rotmat.any() else face
                             for face in faces]
                            for faces, rotmat in zip(batch_faces, batch["rotmat"])]
 
@@ -363,11 +363,47 @@ class Detector(Extractor):
         batch["rotmat"] = retval["rotmat"]
 
     @staticmethod
-    def _rotate_rect(bounding_box, rotation_matrix):
-        """ Rotate a bounding box dict based on the rotation_matrix"""
-        logger.trace("Rotating bounding box")
-        bounding_box = rotate_landmarks(bounding_box, rotation_matrix)
-        return bounding_box
+    def _rotate_face(face, rotation_matrix):
+        """ Rotates the detection bounding box around the given rotation matrix.
+
+        Parameters
+        ----------
+        face: :class:`DetectedFace`
+            A :class:`DetectedFace` containing the `x`, `w`, `y`, `h` detection bounding box
+            points.
+        rotation_matrix: numpy.ndarray
+            The rotation matrix to rotate the given object by.
+
+        Returns
+        -------
+        :class:`DetectedFace`
+            The same class with the detection bounding box points rotated by the given matrix.
+        """
+        logger.trace("Rotating face: (face: %s, rotation_matrix: %s)", face, rotation_matrix)
+        bounding_box = [[face.left, face.top],
+                        [face.right, face.top],
+                        [face.right, face.bottom],
+                        [face.left, face.bottom]]
+        rotation_matrix = cv2.invertAffineTransform(rotation_matrix)
+
+        points = np.array(bounding_box, "int32")
+        points = np.expand_dims(points, axis=0)
+        transformed = cv2.transform(points, rotation_matrix).astype("int32")
+        rotated = transformed.squeeze()
+
+        # Bounding box should follow x, y planes, so get min/max for non-90 degree rotations
+        pt_x = min([pnt[0] for pnt in rotated])
+        pt_y = min([pnt[1] for pnt in rotated])
+        pt_x1 = max([pnt[0] for pnt in rotated])
+        pt_y1 = max([pnt[1] for pnt in rotated])
+        width = pt_x1 - pt_x
+        height = pt_y1 - pt_y
+
+        face.x = int(pt_x)
+        face.y = int(pt_y)
+        face.w = int(width)
+        face.h = int(height)
+        return face
 
     def _rotate_image_by_angle(self, image, angle):
         """ Rotate an image by a given angle.
diff --git a/plugins/train/trainer/_base.py b/plugins/train/trainer/_base.py
index e4aef16..2e71e07 100644
--- a/plugins/train/trainer/_base.py
+++ b/plugins/train/trainer/_base.py
@@ -676,12 +676,7 @@ class Landmarks():
         landmarks = dict()
         for side, fullpath in self.paths.items():
             path, filename = os.path.split(fullpath)
-            filename, extension = os.path.splitext(filename)
-            serializer = extension[1:]
-            alignments = Alignments(
-                path,
-                filename=filename,
-                serializer=serializer)
+            alignments = Alignments(path, filename=filename)
             landmarks[side] = self.transform_landmarks(alignments)
         return landmarks
 
diff --git a/scripts/convert.py b/scripts/convert.py
index 8caa6dd..f150c13 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -38,8 +38,6 @@ class Convert():
         self.images = Images(self.args)
         self.validate()
         self.alignments = Alignments(self.args, False, self.images.is_video)
-        # Update Legacy alignments
-        Legacy(self.alignments, self.images.input_images, arguments.input_aligned_dir)
         self.opts = OptionalActions(self.args, self.images.input_images, self.alignments)
 
         self.add_queues()
@@ -690,61 +688,3 @@ class OptionalActions():
                 logger.warning("Aligned directory contains far fewer images than the input "
                                "directory, are you sure this is the right folder?")
         return face_hashes
-
-
-class Legacy():
-    """ Update legacy alignments:
-        - Rotate landmarks and bounding boxes on legacy alignments
-          and remove the 'r' parameter
-        - Add face hashes to alignments file
-        """
-    def __init__(self, alignments, frames, faces_dir):
-        self.alignments = alignments
-        self.frames = {os.path.basename(frame): frame
-                       for frame in frames}
-        self.process(faces_dir)
-
-    def process(self, faces_dir):
-        """ Run the rotate alignments process """
-        rotated = self.alignments.get_legacy_rotation()
-        hashes = self.alignments.get_legacy_no_hashes()
-        if not rotated and not hashes:
-            return
-        if rotated:
-            logger.info("Legacy rotated frames found. Converting...")
-            self.rotate_landmarks(rotated)
-            self.alignments.save()
-        if hashes and faces_dir:
-            logger.info("Legacy alignments found. Adding Face Hashes...")
-            self.add_hashes(hashes, faces_dir)
-            self.alignments.save()
-
-    def rotate_landmarks(self, rotated):
-        """ Rotate the landmarks """
-        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
-            frame = self.frames.get(rotate_item, None)
-            if frame is None:
-                logger.debug("Skipping missing frame: '%s'", rotate_item)
-                continue
-            self.alignments.rotate_existing_landmarks(rotate_item, frame)
-
-    def add_hashes(self, hashes, faces_dir):
-        """ Add Face Hashes to the alignments file """
-        all_faces = dict()
-        face_files = sorted(face for face in os.listdir(faces_dir) if "_" in face)
-        for face in face_files:
-            filename, extension = os.path.splitext(face)
-            index = filename[filename.rfind("_") + 1:]
-            if not index.isdigit():
-                continue
-            orig_frame = filename[:filename.rfind("_")] + extension
-            all_faces.setdefault(orig_frame, dict())[int(index)] = os.path.join(faces_dir, face)
-
-        for frame in tqdm(hashes):
-            if frame not in all_faces.keys():
-                logger.warning("Skipping missing frame: '%s'", frame)
-                continue
-            hash_faces = all_faces[frame]
-            for index, face_path in hash_faces.items():
-                hash_faces[index] = read_image_hash(face_path)
-            self.alignments.add_face_hashes(frame, hash_faces)
diff --git a/tools/alignments.py b/tools/alignments.py
index 27cee52..a76742d 100644
--- a/tools/alignments.py
+++ b/tools/alignments.py
@@ -4,7 +4,7 @@ import logging
 
 from lib.utils import set_system_verbosity
 from .lib_alignments import (AlignmentData, Check, Draw, # noqa pylint: disable=unused-import
-                             Extract, Legacy, Manual, Merge, Reformat, Rename,
+                             Extract, Manual, Merge, Reformat, Rename,
                              RemoveAlignments, Sort, Spatial, UpdateHashes)
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -29,22 +29,13 @@ class Alignments():
             logger.error("More than one alignments file required for merging")
             exit(0)
 
-        dest_format = self.get_dest_format()
         if len(self.args.alignments_file) == 1:
-            retval = AlignmentData(self.args.alignments_file[0], dest_format)
+            retval = AlignmentData(self.args.alignments_file[0])
         else:
-            retval = [AlignmentData(a_file, dest_format) for a_file in self.args.alignments_file]
+            retval = [AlignmentData(a_file) for a_file in self.args.alignments_file]
         logger.debug("Alignments: %s", retval)
         return retval
 
-    def get_dest_format(self):
-        """ Set the destination format for Alignments """
-        dest_format = None
-        if hasattr(self.args, 'alignment_format') and self.args.alignment_format:
-            dest_format = self.args.alignment_format
-        logger.debug(dest_format)
-        return dest_format
-
     def process(self):
         """ Main processing function of the Align tool """
         if self.args.job == "update-hashes":
diff --git a/tools/cli.py b/tools/cli.py
index 3480698..003775b 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -32,7 +32,7 @@ class AlignmentsArgs(FaceSwapArgs):
             "action": Radio,
             "type": str,
             "choices": ("draw", "extract", "manual", "merge", "missing-alignments",
-                        "missing-frames", "legacy", "leftover-faces", "multi-faces", "no-faces",
+                        "missing-frames", "leftover-faces", "multi-faces", "no-faces",
                         "reformat", "remove-faces", "remove-frames", "rename", "sort-x", "sort-y",
                         "spatial", "update-hashes"),
             "required": True,
@@ -54,9 +54,6 @@ class AlignmentsArgs(FaceSwapArgs):
                     "alignments file." + output_opts + frames_dir +
                     "\nL|'missing-frames': Identify frames in the alignments file that do not "
                     "appear within the frames folder/video." + output_opts + frames_dir +
-                    "\nL|'legacy': This updates legacy alignments to the latest format by "
-                    "rotating the landmarks and bounding boxes and adding face_hashes." +
-                    frames_and_faces_dir +
                     "\nL|'leftover-faces': Identify faces in the faces folder that do not exist "
                     "in the alignments file." + output_opts + faces_dir +
                     "\nL|'multi-faces': Identify where multiple faces exist within the alignments "
@@ -109,12 +106,6 @@ class AlignmentsArgs(FaceSwapArgs):
                               "group": "data",
                               "help": "Directory containing source frames "
                                       "that faces were extracted from."})
-        argument_list.append({"opts": ("-fmt", "--alignment_format"),
-                              "type": str,
-                              "choices": ("json", "pickle", "yaml"),
-                              "group": "data",
-                              "help": "The file format to save the alignment "
-                                      "data in. Defaults to same as source."})
         argument_list.append({
             "opts": ("-o", "--output"),
             "action": Radio,
diff --git a/tools/lib_alignments/__init__.py b/tools/lib_alignments/__init__.py
index 95a74e6..f23a628 100644
--- a/tools/lib_alignments/__init__.py
+++ b/tools/lib_alignments/__init__.py
@@ -1,4 +1,4 @@
 from tools.lib_alignments.media import AlignmentData, ExtractedFaces, Faces, Frames
 from tools.lib_alignments.annotate import Annotate
-from tools.lib_alignments.jobs import Check, Draw, Extract, Legacy, Merge, Reformat, RemoveAlignments, Rename, Sort, Spatial, UpdateHashes
+from tools.lib_alignments.jobs import Check, Draw, Extract, Merge, Reformat, RemoveAlignments, Rename, Sort, Spatial, UpdateHashes
 from tools.lib_alignments.jobs_manual import Manual
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index c677ec3..f2d74cd 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -283,9 +283,6 @@ class Draw():
 
     def process(self):
         """ Run the draw alignments process """
-        legacy = Legacy(self.alignments, None, frames=self.frames, child_process=True)
-        legacy.process()
-
         logger.info("[DRAW LANDMARKS]")  # Tidy up cli output
         self.extracted_faces = ExtractedFaces(self.frames, self.alignments, size=256)
         frames_drawn = 0
@@ -414,74 +411,6 @@ class Extract():
         return valid_faces
 
 
-class Legacy():
-    """ Update legacy alignments:
-        - Rotate landmarks and bounding boxes on legacy alignments
-          and remove the 'r' parameter
-        - Add face hashes to alignments file
-    """
-
-    def __init__(self, alignments, arguments, frames=None, faces=None, child_process=False):
-        logger.debug("Initializing %s: (arguments: %s, child_process: %s)",
-                     self.__class__.__name__, arguments, child_process)
-        self.alignments = alignments
-        if child_process:
-            self.frames = frames
-            self.faces = faces
-        else:
-            self.frames = Frames(arguments.frames_dir)
-            self.faces = Faces(arguments.faces_dir)
-        logger.debug("Initialized %s", self.__class__.__name__)
-
-    def process(self):
-        """ Run the rotate alignments process """
-        rotated = self.alignments.get_legacy_rotation()
-        hashes = self.alignments.get_legacy_no_hashes()
-        if (not self.frames or not rotated) and (not self.faces or not hashes):
-            return
-        logger.info("[UPDATE LEGACY LANDMARKS]")  # Tidy up cli output
-        if rotated and self.frames:
-            logger.info("Legacy rotated frames found. Converting...")
-            self.rotate_landmarks(rotated)
-            self.alignments.save()
-        if hashes and self.faces:
-            logger.info("Legacy alignments found. Adding Face Hashes...")
-            self.add_hashes(hashes)
-            self.alignments.save()
-
-    def rotate_landmarks(self, rotated):
-        """ Rotate the landmarks """
-        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
-            frame = self.frames.get(rotate_item, None)
-            if frame is None:
-                continue
-            self.alignments.rotate_existing_landmarks(rotate_item, frame)
-
-    def add_hashes(self, hashes):
-        """ Add Face Hashes to the alignments file """
-        all_faces = dict()
-        logger.info("Getting original filenames, indexes and hashes...")
-        for face in self.faces.file_list_sorted:
-            filename = face["face_name"]
-            extension = face["face_extension"]
-            if "_" not in face["face_name"]:
-                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
-                continue
-            index = filename[filename.rfind("_") + 1:]
-            if not index.isdigit():
-                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
-                continue
-            orig_frame = filename[:filename.rfind("_")] + extension
-            all_faces.setdefault(orig_frame, dict())[int(index)] = face["face_hash"]
-
-        logger.info("Updating hashes to alignments...")
-        for frame in hashes:
-            if frame not in all_faces.keys():
-                logger.warning("Skipping missing frame: '%s'", frame)
-                continue
-            self.alignments.add_face_hashes(frame, all_faces[frame])
-
-
 class Merge():
     """ Merge two alignments files into one """
     def __init__(self, alignments, arguments):
@@ -693,10 +622,6 @@ class RemoveAlignments():
 
     def process(self):
         """ run removal """
-        if self.type == "faces":
-            legacy = Legacy(self.alignments, None, faces=self.items, child_process=True)
-            legacy.process()
-
         logger.info("[REMOVE ALIGNMENTS DATA]")  # Tidy up cli output
         del_count = 0
         task = getattr(self, "remove_{}".format(self.type))
@@ -839,20 +764,17 @@ class Sort():
         self.faces = self.get_faces(arguments)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def get_faces(self, arguments):
-        """ If faces argument is specified, load faces_dir
-            otherwise return None """
+    @staticmethod
+    def get_faces(arguments):
+        """ If faces argument is specified, load faces_dir otherwise return None """
         if not hasattr(arguments, "faces_dir") or not arguments.faces_dir:
             return None
         faces = Faces(arguments.faces_dir)
-        legacy = Legacy(self.alignments, None, faces=faces, child_process=True)
-        legacy.process()
         return faces
 
     def process(self):
         """ Execute the sort process """
         logger.info("[SORT INDEXES]")  # Tidy up cli output
-        self.check_legacy()
         reindexed = self.reindex_faces()
         if reindexed:
             self.alignments.save()
@@ -860,19 +782,6 @@ class Sort():
             rename = Rename(self.alignments, None, self.faces)
             rename.process()
 
-    def check_legacy(self):
-        """ Legacy rotated alignments will not have the correct x, y
-            positions. Faces without hashes won't process.
-            Check for these and generate a warning and exit """
-        rotated = self.alignments.get_legacy_rotation()
-        hashes = self.alignments.get_legacy_no_hashes()
-        if rotated or hashes:
-            logger.error("Legacy alignments found. Sort cannot continue. You should run legacy "
-                         "tool to update the file prior to running sort: 'python tools.py "
-                         "alignments -j legacy -a <alignments_file> -fr <frames_folder> -fc "
-                         "<faces_folder>'")
-            exit(0)
-
     def reindex_faces(self):
         """ Re-Index the faces """
         reindexed = 0
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
index 53408a6..2cf4d63 100644
--- a/tools/lib_alignments/jobs_manual.py
+++ b/tools/lib_alignments/jobs_manual.py
@@ -9,7 +9,7 @@ import numpy as np
 
 from lib.queue_manager import queue_manager
 from plugins.extract.pipeline import Extractor
-from . import Annotate, ExtractedFaces, Frames, Legacy
+from . import Annotate, ExtractedFaces, Frames
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -454,10 +454,6 @@ class Manual():
 
     def process(self):
         """ Process manual extraction """
-        legacy = Legacy(self.alignments, self.arguments,
-                        frames=self.frames, child_process=True)
-        legacy.process()
-
         logger.info("[MANUAL PROCESSING]")  # Tidy up cli output
         self.extracted_faces = ExtractedFaces(self.frames, self.alignments, size=256)
         self.interface = Interface(self.alignments, self.frames)
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index a5f043d..f9a3941 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -23,16 +23,15 @@ logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 class AlignmentData(Alignments):
     """ Class to hold the alignment data """
 
-    def __init__(self, alignments_file, destination_format):
-        logger.debug("Initializing %s: (alignments file: '%s', destination_format: '%s')",
-                     self.__class__.__name__, alignments_file, destination_format)
+    def __init__(self, alignments_file):
+        logger.debug("Initializing %s: (alignments file: '%s')",
+                     self.__class__.__name__, alignments_file)
         logger.info("[ALIGNMENT DATA]")  # Tidy up cli output
         folder, filename = self.check_file_exists(alignments_file)
         if filename.lower() == "dfl":
-            self.set_dfl(destination_format)
+            self.file = filename
             return
         super().__init__(folder, filename=filename)
-        self.set_destination_format(destination_format)
         logger.verbose("%s items loaded", self.frames_count)
         logger.debug("Initialized %s", self.__class__.__name__)
 
@@ -43,7 +42,7 @@ class AlignmentData(Alignments):
         if filename.lower() == "dfl":
             folder = None
             filename = "dfl"
-            logger.info("Using extracted pngs for alignments")
+            logger.info("Using extracted DFL faces for alignments")
         elif not os.path.isfile(alignments_file):
             logger.error("ERROR: alignments file not found at: '%s'", alignments_file)
             exit(0)
@@ -51,39 +50,6 @@ class AlignmentData(Alignments):
             logger.verbose("Alignments file exists at '%s'", alignments_file)
         return folder, filename
 
-    def set_dfl(self, destination_format):
-        """ Set the alignments for dfl alignments """
-        logger.debug("Alignments are DFL format")
-        self.file = "dfl"
-        self.set_destination_format(destination_format)
-
-    def set_destination_format(self, destination_format):
-        """ Standardize the destination format to the correct extension """
-        extensions = {".json": "json",
-                      ".p": "pickle",
-                      ".yml": "yaml",
-                      ".yaml": "yaml"}
-        dst_fmt = None
-        file_ext = os.path.splitext(self.file)[1].lower()
-        logger.debug("File extension: '%s'", file_ext)
-
-        if destination_format is not None:
-            dst_fmt = destination_format
-        elif self.file == "dfl":
-            dst_fmt = "json"
-        elif file_ext in extensions.keys():
-            dst_fmt = extensions[file_ext]
-        else:
-            logger.error("'%s' is not a supported serializer. Exiting", file_ext)
-            exit(0)
-
-        logger.verbose("Destination format set to '%s'", dst_fmt)
-
-        self.serializer = self.get_serializer("", dst_fmt)
-        filename = os.path.splitext(self.file)[0]
-        self.file = "{}.{}".format(filename, self.serializer.file_extension)
-        logger.debug("Destination file: '%s'", self.file)
-
     def save(self):
         """ Backup copy of old alignments and save new alignments """
         self.backup()

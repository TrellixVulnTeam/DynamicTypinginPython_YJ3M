commit f41f3e99c164863ca7b957b704c0e2cc40245272
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Mon Aug 20 09:30:36 2018 +0100

    Implement Alignments tool and other minor fixes (#473)
    
    * Fix helptext formatting for cli and gui
    * Extract faces from alignments file
    * Add draw landmarks
    * fix analysis hours past 24 bug
    * Remove tools flag. Enlarge GUI tooltips

diff --git a/lib/cli.py b/lib/cli.py
index 01476ad..398c28e 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -176,6 +176,22 @@ class FullHelpArgumentParser(argparse.ArgumentParser):
         self.exit(2, "%(prog)s: error: %(message)s\n" % args)
 
 
+class SmartFormatter(argparse.HelpFormatter):
+    """ Smart formatter for allowing raw formatting in help
+        text.
+
+        To use prefix the help item with "R|" to overide
+        default formatting
+
+        from: https://stackoverflow.com/questions/3853722 """
+
+    def _split_lines(self, text, width):
+        if text.startswith("R|"):
+            return text[2:].splitlines()
+        # this is the RawTextHelpFormatter._split_lines
+        return argparse.HelpFormatter._split_lines(self, text, width)
+
+
 class FaceSwapArgs(object):
     """ Faceswap argument parser functions that are universal
         to all commands. Should be the parent function of all
@@ -218,7 +234,8 @@ class FaceSwapArgs(object):
             help=description,
             description=description,
             epilog="Questions and feedback: \
-            https://github.com/deepfakes/faceswap-playground")
+            https://github.com/deepfakes/faceswap-playground",
+            formatter_class=SmartFormatter)
         return parser
 
     def add_arguments(self):
@@ -279,18 +296,19 @@ class ExtractConvertArgs(FaceSwapArgs):
                               "choices": ("dlib-hog", "dlib-cnn",
                                           "dlib-all", "mtcnn"),
                               "default": "mtcnn",
-                              "help": "Detector to use. 'dlib-hog': uses "
-                                      "least resources, but is the least "
-                                      "reliable. 'dlib-cnn': faster than "
-                                      "mtcnn but detects fewer faces and "
-                                      "fewer false positives. 'dlib-all': "
+                              "help": "R|Detector to use.\n'dlib-hog': uses "
+                                      "least resources, but is the least\n\t"
+                                      "reliable.\n'dlib-cnn': faster than "
+                                      "mtcnn but detects fewer faces\n\tand "
+                                      "fewer false positives.\n'dlib-all': "
                                       "attempts to find faces using "
-                                      "dlib-cnn, if none are found, attempts "
-                                      "to find faces using dlib-hog. "
-                                      "'mtcnn': slower than dlib, but uses "
-                                      "fewer resources whilst detecting more "
-                                      "faces and more false positives. "
-                                      "Has superior alignment to dlib"})
+                                      "dlib-cnn,\n\tif none are found, "
+                                      "attempts to find faces\n\tusing "
+                                      "dlib-hog.\n'mtcnn': slower than dlib, "
+                                      "but uses fewer resources\n\twhilst "
+                                      "detecting more faces and more false\n\t"
+                                      "positives. Has superior alignment to "
+                                      "dlib"})
         argument_list.append({"opts": ("-mtms", "--mtcnn-minsize"),
                               "type": int,
                               "dest": "mtcnn_minsize",
@@ -305,14 +323,14 @@ class ExtractConvertArgs(FaceSwapArgs):
                               "type": str,
                               "dest": "mtcnn_threshold",
                               "default": ["0.6", "0.7", "0.7"],
-                              "help": "Three step threshold for face "
-                                      "detection. Should be three decimal "
-                                      "numbers each less than 1. Eg: "
-                                      "'--mtcnn-threshold 0.6 0.7 0.7'. "
-                                      "1st stage: obtains face candidates, "
+                              "help": "R|Three step threshold for face "
+                                      "detection. Should be\nthree decimal "
+                                      "numbers each less than 1. Eg:\n"
+                                      "'--mtcnn-threshold 0.6 0.7 0.7'.\n"
+                                      "1st stage: obtains face candidates.\n"
                                       "2nd stage: refinement of face "
-                                      "candidates, 3rd stage: further "
-                                      "refinement of face candidates. "
+                                      "candidates.\n3rd stage: further "
+                                      "refinement of face candidates.\n"
                                       "Default is 0.6 0.7 0.7 "
                                       "(MTCNN detector only)"})
         argument_list.append({"opts": ("-mtsc", "--mtcnn-scalefactor"),
diff --git a/lib/gui/command.py b/lib/gui/command.py
index f4b5889..270d7b3 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -168,9 +168,7 @@ class OptionControl(object):
         ctl = self.option["control"]
         ctltitle = self.option["control_title"]
         sysbrowser = self.option["filesystem_browser"]
-        ctlhelp = " ".join(self.option.get("help", "").split())
-        ctlhelp = ". ".join(i.capitalize() for i in ctlhelp.split(". "))
-        ctlhelp = ctltitle + " - " + ctlhelp
+        ctlhelp = self.format_help(ctltitle)
         dflt = self.option.get("default", "")
         if self.option.get("nargs", None) and isinstance(dflt, (list, tuple)):
             dflt = ' '.join(str(val) for val in dflt)
@@ -189,6 +187,17 @@ class OptionControl(object):
                                                       choices,
                                                       sysbrowser)
 
+    def format_help(self, ctltitle):
+        """ Format the help text for tooltips """
+        ctlhelp = self.option.get("help", "")
+        if ctlhelp.startswith("R|"):
+            ctlhelp = ctlhelp[2:].replace("\n\t", " ").replace("\n'", "\n\n'")
+        else:
+            ctlhelp = " ".join(ctlhelp.split())
+        ctlhelp = ". ".join(i.capitalize() for i in ctlhelp.split(". "))
+        ctlhelp = ctltitle + " - " + ctlhelp
+        return ctlhelp
+
     def build_one_control_frame(self):
         """ Build the frame to hold the control """
         frame = ttk.Frame(self.option_frame)
@@ -248,7 +257,7 @@ class OptionControl(object):
         if control == ttk.Combobox:
             ctl["values"] = [choice for choice in choices]
 
-        Tooltip(ctl, text=helptext, wraplength=200)
+        Tooltip(ctl, text=helptext, wraplength=400)
 
     def add_browser_buttons(self, frame, sysbrowser, filepath):
         """ Add correct file browser button for control """
diff --git a/lib/gui/stats.py b/lib/gui/stats.py
index d695991..468b0ad 100644
--- a/lib/gui/stats.py
+++ b/lib/gui/stats.py
@@ -12,6 +12,16 @@ import numpy as np
 from lib.Serializer import PickleSerializer
 
 
+def convert_time(timestamp):
+    """ Convert time stamp to total hours, mins and second """
+    hrs = int(timestamp // 3600)
+    if hrs < 10:
+        hrs = "{0:02d}".format(hrs)
+    mins = "{0:02d}".format((int(timestamp % 3600) // 60))
+    secs = "{0:02d}".format((int(timestamp % 3600) % 60))
+    return hrs, mins, secs
+
+
 class SavedSessions(object):
     """ Saved Training Session """
     def __init__(self, sessions_data):
@@ -77,8 +87,8 @@ class CurrentSession(object):
         now = time.time()
         self.stats["timestamps"].append(now)
         elapsed_time = now - self.timestats["start"]
-        self.timestats["elapsed"] = time.strftime("%H:%M:%S",
-                                                  time.gmtime(elapsed_time))
+        hrs, mins, secs = convert_time(elapsed_time)
+        self.timestats["elapsed"] = "{}:{}:{}".format(hrs, mins, secs)
 
     def save_session(self):
         """ Save the session file to the modeldir """
@@ -195,8 +205,8 @@ class SessionsSummary(object):
                                              time.gmtime(summary["start"]))
             summary["end"] = time.strftime("%x %X",
                                            time.gmtime(summary["end"]))
-            summary["elapsed"] = time.strftime("%H:%M:%S",
-                                               time.gmtime(summary["elapsed"]))
+            hrs, mins, secs = convert_time(summary["elapsed"])
+            summary["elapsed"] = "{}:{}:{}".format(hrs, mins, secs)
             summary["rate"] = "{0:.1f}".format(summary["rate"])
         self.summary = raw_summaries
 
diff --git a/tools.py b/tools.py
index 385b950..188a86e 100755
--- a/tools.py
+++ b/tools.py
@@ -26,12 +26,18 @@ if __name__ == "__main__":
 
     PARSER = FullHelpArgumentParser()
     SUBPARSER = PARSER.add_subparsers()
+    ALIGN = cli.AlignmentsArgs(SUBPARSER,
+                               "alignments",
+                               "This command lets you perform various tasks "
+                               "pertaining to an alignments file.")
     EFFMPEG = cli.EffmpegArgs(SUBPARSER,
                               "effmpeg",
-                              "This command allows you to easily execute common ffmpeg tasks.")
+                              "This command allows you to easily execute "
+                              "common ffmpeg tasks.")
     SORT = cli.SortArgs(SUBPARSER,
                         "sort",
-                        "This command lets you sort images using various methods.")
+                        "This command lets you sort images using various "
+                        "methods.")
     GUI = GuiArgs(SUBPARSER,
                   "gui",
                   "Launch the Faceswap Tools Graphical User Interface.")
diff --git a/tools/alignments.py b/tools/alignments.py
new file mode 100644
index 0000000..3d0216f
--- /dev/null
+++ b/tools/alignments.py
@@ -0,0 +1,664 @@
+#!/usr/bin/env python3
+""" Tools for manipulating the alignments seralized file """
+
+# TODO merge alignments
+# TODO Remove whole frames from alignments file
+import os
+from datetime import datetime
+
+from cv2 import circle, imread, imwrite, rectangle
+from tqdm import tqdm
+
+from lib import Serializer
+from plugins.PluginLoader import PluginLoader
+
+
+class Alignments(object):
+    """ Perform tasks relating to alignments file """
+    def __init__(self, arguments):
+        self.args = arguments
+
+        dest_format = self.get_dest_format()
+        self.alignments = AlignmentData(self.args.alignments_file,
+                                        dest_format,
+                                        self.args.verbose)
+
+    def get_dest_format(self):
+        """ Set the destination format for Alignments """
+        dest_format = None
+        if (hasattr(self.args, 'alignment_format')
+                and self.args.alignment_format):
+            dest_format = self.args.alignment_format
+        return dest_format
+
+    def process(self):
+        """ Main processing function of the Align tool """
+        if self.args.job == "draw":
+            job = Draw(self.alignments, self.args)
+        elif self.args.job == "extract":
+            job = Extract(self.alignments, self.args)
+        elif self.args.job in("missing-alignments", "missing-frames",
+                              "multi-faces", "no-faces"):
+            job = Check(self.alignments, self.args)
+        elif self.args.job == "remove":
+            job = RemoveAlignments(self.alignments, self.args)
+        elif self.args.job == "reformat":
+            job = self.alignments
+
+        job.process()
+
+
+class AlignmentData(object):
+    """ Class to hold the alignment data """
+
+    def __init__(self, alignments_file, destination_format, verbose):
+        print("\n[ALIGNMENT DATA]")  # Tidy up cli output
+        self.alignments_file = alignments_file
+        self.verbose = verbose
+
+        self.check_alignments_file_exists()
+        self.alignments_format = os.path.splitext(
+            self.alignments_file)[1].lower()
+        self.destination_format = self.get_destination_format(
+            destination_format)
+
+        self.serializer = Serializer.get_serializer_from_ext(
+            self.alignments_format)
+        self.alignments = self.load_alignments()
+        self.count = len(self.alignments)
+        self.count_per_frame = {key: len(value)
+                                for key, value in self.alignments.items()}
+
+        self.set_destination_serializer()
+        if self.verbose:
+            print("{} items loaded".format(self.count))
+
+    def process(self):
+        """ Commmand to run if calling the reformat command """
+        print("\n[REFORMAT ALIGNMENTS]")  # Tidy up cli output
+        self.save_alignments()
+
+    def check_alignments_file_exists(self):
+        """ Check the alignments file exists"""
+        if not os.path.isfile(self.alignments_file):
+            print("ERROR: alignments file not "
+                  "found at: {}".format(self.alignments_file))
+            exit(0)
+        if self.verbose:
+            print("Alignments file exists at {}".format(self.alignments_file))
+
+    def get_destination_format(self, destination_format):
+        """ Standardise the destination format to the correct extension """
+        extensions = {".json": "json",
+                      ".p": "pickle",
+                      ".yml": "yaml",
+                      ".yaml": "yaml"}
+        dst_fmt = None
+
+        if destination_format is not None:
+            dst_fmt = destination_format
+        elif self.alignments_format in extensions.keys():
+            dst_fmt = extensions[self.alignments_format]
+        else:
+            print("{} is not a supported serializer. "
+                  "Exiting".format(self.alignments_format))
+            exit(0)
+
+        if self.verbose:
+            print("Destination format set to {}".format(dst_fmt))
+
+        return dst_fmt
+
+    def set_destination_serializer(self):
+        """ set the destination serializer """
+        self.serializer = Serializer.get_serializer(self.destination_format)
+
+    def load_alignments(self):
+        """ Read the alignments data from the correct format """
+        print("Loading alignments from {}".format(self.alignments_file))
+        with open(self.alignments_file, self.serializer.roptions) as align:
+            alignments = self.serializer.unmarshal(align.read())
+        return alignments
+
+    def save_alignments(self):
+        """ Backup copy of old alignments and save new alignments """
+        dst = os.path.splitext(self.alignments_file)[0]
+        dst += ".{}".format(self.serializer.ext)
+        self.backup_alignments()
+
+        print("Saving alignments to {}".format(dst))
+        with open(dst, self.serializer.woptions) as align:
+            align.write(self.serializer.marshal(self.alignments))
+
+    def backup_alignments(self):
+        """ Backup copy of old alignments """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        src = self.alignments_file
+        dst = src.split(".")
+        dst[0] += "_" + now + "."
+        dst = dst[0] + dst[1]
+        print("Backing up original alignments to {}".format(dst))
+        os.rename(src, dst)
+
+    def get_alignments_one_image(self):
+        """ Return the face alignments for one image """
+        for image, alignments in self.alignments.items():
+            image_stripped = image[:image.rindex(".")]
+            number_alignments = len(alignments)
+            yield image_stripped, alignments, number_alignments
+
+    @staticmethod
+    def get_one_alignment_index_reverse(image_alignments, number_alignments):
+        """ Return the correct original index for
+            alignment in reverse order """
+        for idx, _ in enumerate(reversed(image_alignments)):
+            original_idx = number_alignments - 1 - idx
+            yield original_idx
+
+    def has_alignments(self, filename, alignments):
+        """ Check whether this frame has alignments """
+        if not alignments:
+            if self.verbose:
+                print("Skipping {} - Alignments not found".format(filename))
+            return False
+        return True
+
+
+class MediaLoader(object):
+    """ Class to load filenames from folder """
+    def __init__(self, folder, verbose):
+        print("\n[{} DATA]".format(self.__class__.__name__.upper()))
+        self.verbose = verbose
+        self.folder = folder
+        self.check_folder_exists()
+        self.file_list_sorted = sorted([item
+                                        for item in self.process_folder()])
+        self.items = self.load_items()
+        self.count = len(self.file_list_sorted)
+        if self.verbose:
+            print("{} items loaded".format(self.count))
+
+    def check_folder_exists(self):
+        """ makes sure that the faces folder exists """
+        if not self.folder or not os.path.isdir(self.folder):
+            print("ERROR: The folder {} could not "
+                  "be found".format(self.folder))
+            exit(0)
+        if self.verbose:
+            print("Folder exists at {}".format(self.folder))
+
+    @staticmethod
+    def process_folder():
+        """ Override for specific folder processing """
+        return list()
+
+    @staticmethod
+    def load_items():
+        """ Override for specific item loading """
+        return dict()
+
+    def load_image(self, filename):
+        """ Load an image """
+        src = os.path.join(self.folder, filename)
+        image = imread(src)
+        return image
+
+    @staticmethod
+    def save_image(output_folder, filename, image):
+        """ Save an image """
+        output_file = os.path.join(output_folder, filename)
+        imwrite(output_file, image)
+
+
+class Faces(MediaLoader):
+    """ Object to hold the faces that are to be swapped out """
+
+    def process_folder(self):
+        """ Iterate through the faces dir pulling out various information """
+        print("Loading file list from {}".format(self.folder))
+        for face in os.listdir(self.folder):
+            filename = os.path.splitext(face)[0]
+            file_extension = os.path.splitext(face)[1]
+            index = int(filename[filename.rindex("_") + 1:])
+            original_file = "{}".format(filename[:filename.rindex("_")])
+            yield (filename, file_extension, original_file, index)
+
+    def load_items(self):
+        """ Load the face names into dictionary """
+        faces = dict()
+        for face in self.file_list_sorted:
+            original_file, index = face[2:4]
+            if faces.get(original_file, "") == "":
+                faces[original_file] = [index]
+            else:
+                faces[original_file].append(index)
+        return faces
+
+
+class Frames(MediaLoader):
+    """ Object to hold the frames that are to be checked against """
+
+    def process_folder(self):
+        """ Iterate through the frames dir pulling the base filename """
+        print("Loading file list from {}".format(self.folder))
+        for frame in os.listdir(self.folder):
+            filename = os.path.basename(frame)
+            yield filename
+
+    def load_items(self):
+        """ Load the frame info into dictionary """
+        frames = dict()
+        for frame in self.file_list_sorted:
+            frames[frame] = (frame[:frame.rfind(".")],
+                             frame[frame.rfind("."):])
+        return frames
+
+
+class Draw(object):
+    """ Draw Alignments on passed in images """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.frames = Frames(arguments.frames_dir, self.verbose)
+        self.output_folder = self.set_output()
+
+    def set_output(self):
+        """ Set the output folder path """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        folder_name = "drawn_landmarks_{}".format(now)
+        output_folder = os.path.join(self.frames.folder, folder_name)
+        os.makedirs(output_folder)
+        return output_folder
+
+    def process(self):
+        """ Run the draw alignments process """
+        print("\n[DRAW LANDMARKS]")  # Tidy up cli output
+        frames_drawn = 0
+        for frame, alignments in tqdm(self.get_frame_alignments(),
+                                      desc="Drawing landmarks",
+                                      total=self.frames.count):
+            if not self.alignments.has_alignments(frame, alignments):
+                continue
+            self.annotate_image(frame, alignments)
+            frames_drawn += 1
+        print("{} Frame(s) output".format(frames_drawn))
+
+    def get_frame_alignments(self):
+        """ Retrieve each frame and it's corresponding alignments """
+        for frame in self.frames.file_list_sorted:
+            alignments = self.alignments.alignments.get(frame, None)
+            yield frame, alignments
+
+    def annotate_image(self, frame, alignments):
+        """ Draw the alignments """
+        image = self.frames.load_image(frame)
+        for alignment in alignments:
+            self.draw_bounding_box(image, alignment)
+            self.draw_landmarks(image, alignment["landmarksXY"])
+        self.frames.save_image(self.output_folder, frame, image)
+
+    @staticmethod
+    def draw_bounding_box(image, alignment):
+        """ Draw the bounding box around face """
+        top_left = (alignment["x"], alignment["y"])
+        bottom_right = (alignment["x"] + alignment["w"],
+                        alignment["y"] + alignment["h"])
+        rectangle(image, top_left, bottom_right, (0, 0, 255), 1)
+
+    @staticmethod
+    def draw_landmarks(image, landmarks):
+        """ Draw the facial landmarks """
+        for (pos_x, pos_y) in landmarks:
+            circle(image, (pos_x, pos_y), 1, (0, 255, 0), -1)
+
+
+class Extract(object):
+    """ Re-extract faces from source frames based on
+        Alignment data """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.faces_dir = arguments.faces_dir
+        self.align_eyes = arguments.align_eyes
+        self.frames = Frames(arguments.frames_dir, self.verbose)
+        self.extractor = None
+
+    class DetectedFace(object):
+        """ Detected face and landmark information """
+        def __init__(self, image, r, x, w, y, h, landmarksXY):
+            self.image = image
+            self.r = r
+            self.x = x
+            self.w = w
+            self.y = y
+            self.h = h
+            self.landmarksXY = landmarksXY
+
+        def landmarks_as_xy(self):
+            """ Landmarks as XY """
+            return self.landmarksXY
+
+    def process(self):
+        """ Run extraction """
+        print("\n[EXTRACT FACES]")  # Tidy up cli output
+        self.check_folder()
+        self.extractor = PluginLoader.get_extractor("Align")()
+        self.export_faces()
+
+    def check_folder(self):
+        """ Check that the faces folder doesn't pre-exist
+            and create """
+        err = None
+        if not self.faces_dir:
+            err = "ERROR: Output faces folder not provided."
+        if os.path.isdir(self.faces_dir):
+            err = "ERROR: Folder already exists at {}".format(self.faces_dir)
+        if err:
+            print(err)
+            exit(0)
+        if self.verbose:
+            print("Creating output folder at {}".format(self.faces_dir))
+        os.makedirs(self.faces_dir)
+
+    def export_faces(self):
+        """ Export the faces """
+        extracted_faces = 0
+        for frame, frame_info, alignments in tqdm(self.get_frame_alignments(),
+                                                  desc="Extracting faces",
+                                                  total=self.frames.count):
+            if not self.alignments.has_alignments(frame, alignments):
+                continue
+            extracted_faces += self.output_faces(frame,
+                                                 frame_info,
+                                                 alignments)
+        print("{} face(s) extracted".format(extracted_faces))
+
+    def get_frame_alignments(self):
+        """ Return the alignments for each frame """
+        for key, value in self.frames.items.items():
+            alignments = self.alignments.alignments.get(key, None)
+            yield key, value, alignments
+
+    def output_faces(self, frame, frame_info, alignments):
+        """ Output the frame's faces to file """
+        face_count = 0
+        image = self.frames.load_image(frame)
+        name, extension = frame_info
+        for idx, alignment in enumerate(alignments):
+            face = self.DetectedFace(image,
+                                     alignment["r"],
+                                     alignment["x"],
+                                     alignment["w"],
+                                     alignment["y"],
+                                     alignment["h"],
+                                     alignment["landmarksXY"])
+            resized_face, _ = self.extractor.extract(image,
+                                                     face,
+                                                     256,
+                                                     self.align_eyes)
+            output = "{}_{}{}".format(name, str(idx), extension)
+            self.frames.save_image(self.faces_dir, output, resized_face)
+            face_count += 1
+        return face_count
+
+
+class RemoveAlignments(object):
+    """ Remove items from alignments file """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.faces = Faces(arguments.faces_dir, self.verbose)
+        self.removed = set()
+
+    def process(self):
+        """ run removal """
+        print("\n[REMOVE ALIGNMENTS DATA]")  # Tidy up cli output
+        del_count = 0
+        for item in tqdm(self.alignments.get_alignments_one_image(),
+                         desc="Processing alignments file",
+                         total=self.alignments.count):
+            if self.faces_count_matches(item):
+                continue
+            del_count += self.remove_alignment(item)
+
+        if del_count == 0:
+            print("No changes made to alignments file. Exiting")
+            return
+
+        print("{} alignments(s) were removed from "
+              "alignments file".format(del_count))
+        self.alignments.save_alignments()
+        self.rename_faces()
+
+    def faces_count_matches(self, item):
+        """ Check the selected face exits """
+        image_name, number_alignments = item[0], item[2]
+        number_faces = len(self.faces.items.get(image_name, []))
+        return bool(number_alignments == 0
+                    or number_alignments == number_faces)
+
+    def remove_alignment(self, item):
+        """ Remove the alignment from the alignments file """
+        del_count = 0
+        image_name, alignments, number_alignments = item
+        processor = self.alignments.get_one_alignment_index_reverse
+        for idx in processor(alignments, number_alignments):
+            face_indexes = self.faces.items.get(image_name, [-1])
+            if idx not in face_indexes:
+                del alignments[idx]
+                self.removed.add(image_name)
+                if self.verbose:
+                    print("Removed alignment data for image:{} "
+                          "index: {}".format(image_name, str(idx)))
+                del_count += 1
+        return del_count
+
+    def rename_faces(self):
+        """ Rename the aligned faces to match their "
+            new index in alignments file """
+        current_image = ""
+        current_index = 0
+        rename_count = 0
+        for item in tqdm(self.faces.file_list_sorted,
+                         desc="Renaming aligned faces",
+                         total=self.faces.count):
+            filename, extension, original_file, index = item
+            if original_file not in self.removed:
+                continue
+            current_index, current_image = self.set_image_index(current_index,
+                                                                current_image,
+                                                                original_file)
+            if current_index != index:
+                rename_count += self.rename_file(filename,
+                                                 extension,
+                                                 current_image,
+                                                 current_index)
+
+            current_index += 1
+        if rename_count == 0:
+            print("No files were renamed. Exiting")
+            return
+        print("{} face(s) were renamed to match with "
+              "alignments file".format(rename_count))
+
+    @staticmethod
+    def set_image_index(index, current, original):
+        """ Set the current processing image and index """
+        idx = 0 if current != original else index
+        return idx, original
+
+    def rename_file(self, filename, extension, image, index):
+        """ Rename the selected file """
+        old_file = filename + extension
+        new_file = "{}_{}{}".format(image, str(index), extension)
+        src = os.path.join(self.faces.folder, old_file)
+        dst = os.path.join(self.faces.folder, new_file)
+        os.rename(src, dst)
+        if self.verbose:
+            print("Renamed {} to {}".format(src, dst))
+        return 1
+
+
+class Check(object):
+    """ Frames and faces checking tasks """
+    def __init__(self, alignments, arguments):
+        self.alignments_data = alignments.count_per_frame
+        self.job = arguments.job
+        self.type = None
+        self.output = arguments.output
+        self.source_dir = self.get_source_dir(arguments)
+        self.items = self.get_items(arguments)
+
+        self.items_output = []
+        self.items_discovered = 0
+        self.output_message = ""
+
+    def get_source_dir(self, arguments):
+        """ Set the correct source dir """
+        if hasattr(arguments, "faces_dir"):
+            self.type = "faces"
+            source_dir = arguments.faces_dir
+        elif hasattr(arguments, "frames_dir"):
+            self.type = "frames"
+            source_dir = arguments.frames_dir
+        else:
+            print("No source folder (-fr or -fc) was provided")
+            exit(0)
+        return source_dir
+
+    def get_items(self, arguments):
+        """ Set the correct items to process """
+        items = Frames
+        if self.type == "faces":
+            items = Faces
+        return items(self.source_dir, arguments.verbose).file_list_sorted
+
+    def process(self):
+        """ Process the frames check against the alignments file """
+        print("\n[CHECK {}]".format(self.type.upper()))
+        self.validate()
+        self.compile_output()
+        self.output_results()
+
+    def validate(self):
+        """ Check that the selected type is valid for
+            selected task and job """
+        if self.job == "missing-frames" and self.output == "move":
+            print("WARNING: missing_frames was selected with move output, but "
+                  "there will be nothing to move. "
+                  "Defaulting to output: console")
+            self.output = "console"
+        elif self.type == "faces" and self.job != "multi-faces":
+            print("WARNING: The selected folder is not valid. Only folder set "
+                  "with '-fc' is supported for 'multi-faces'")
+            exit(0)
+
+    def compile_output(self):
+        """ Compile list of frames that meet criteria """
+        action = self.job.replace("-", "_")
+        processor = getattr(self, "get_{}".format(action))
+        self.items_output = [item for item in processor()]
+
+    def get_no_faces(self):
+        """ yield each frame that has no face match in alignments file """
+        self.output_message = "Frames with no faces"
+        for item in self.items:
+            if self.alignments_data.get(item, -1) == 0:
+                yield item
+
+    def get_multi_faces(self):
+        """ yield each frame that has multiple faces
+            matched in alignments file """
+        self.output_message = "Frames with multiple faces"
+        items = self.items
+        if self.type == "faces":
+            self.output_message = "Multiple faces in frame"
+        for item in items:
+            check_item = item
+            return_item = item
+            if self.type == "faces":
+                check_item = str(item[2]) + str(item[1])
+                return_item = str(item[0]) + str(item[1])
+            if self.alignments_data.get(check_item, -1) > 1:
+                yield return_item
+
+    def get_missing_alignments(self):
+        """ yield each frame that does not exist in alignments file """
+        self.output_message = "Frames missing from alignments file"
+        exclude_filetypes = ["yaml", "yml", "p", "json", "txt"]
+        for item in self.items:
+            extension = item[item.rindex(".") + 1:]
+            if (extension not in exclude_filetypes
+                    and self.alignments_data.get(item, -1)) == -1:
+                yield item
+
+    def get_missing_frames(self):
+        """ yield each frame in alignments that does
+            not have a matching file """
+        self.output_message = "Missing frames that are in alignments file"
+        for item in self.alignments_data.keys():
+            if item not in self.items:
+                yield item
+
+    def output_results(self):
+        """ Output the results in the requested format """
+        self.items_discovered = len(self.items_output)
+        if self.items_discovered == 0:
+            print("No {} were found meeting the criteria".format(self.type))
+            return
+        if self.output == "move":
+            self.move_file()
+            return
+        output_message = "-----------------------------------------------\r\n"
+        output_message += " {} ({})\r\n".format(self.output_message,
+                                                self.items_discovered)
+        output_message += "-----------------------------------------------\r\n"
+        output_message += "\r\n".join([frame for frame in self.items_output])
+        if self.output == "console":
+            print("\n" + output_message)
+        if self.output == "file":
+            self.output_file(output_message)
+
+    def output_file(self, output_message):
+        """ Save the output to a text file in the frames directory """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        filename = self.output_message.replace(" ", "_").lower()
+        filename += "_" + now + ".txt"
+        output_file = os.path.join(self.source_dir, filename)
+        print("Saving {} result(s) to {}".format(self.items_discovered,
+                                                 output_file))
+        with open(output_file, "w") as f_output:
+            f_output.write(output_message)
+
+    def move_file(self):
+        """ Move the identified frames to a new subfolder """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        folder_name = self.output_message.replace(" ", "_").lower()
+        folder_name += "_" + now
+        output_folder = os.path.join(self.source_dir, folder_name)
+        os.makedirs(output_folder)
+        move = getattr(self, "move_{}".format(self.type))
+        move(output_folder)
+
+    def move_frames(self, output_folder):
+        """ Move frames into single subfolder """
+        print("Moving {} frame(s) to {}".format(self.items_discovered,
+                                                output_folder))
+        for frame in self.items_output:
+            src = os.path.join(self.source_dir, frame)
+            dst = os.path.join(output_folder, frame)
+            os.rename(src, dst)
+
+    def move_faces(self, output_folder):
+        """ Make additional subdirs for each face that appears
+            Enables easier manual sorting """
+        print("Moving {} faces(s) to {}".format(self.items_discovered,
+                                                output_folder))
+        for frame in self.items_output:
+            idx = frame[frame.rfind("_") + 1:frame.rfind(".")]
+            src = os.path.join(self.source_dir, frame)
+            dst_folder = os.path.join(output_folder, idx)
+            if not os.path.isdir(dst_folder):
+                os.makedirs(dst_folder)
+            dst = os.path.join(dst_folder, frame)
+            os.rename(src, dst)
diff --git a/tools/cli.py b/tools/cli.py
index b578102..c31ee9e 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -1,10 +1,120 @@
 #!/usr/bin/env python3
 """ Command Line Arguments for tools """
 from lib.cli import FaceSwapArgs
-from lib.cli import ContextFullPaths, DirFullPaths, FileFullPaths, SaveFileFullPaths
+from lib.cli import (ContextFullPaths, DirFullPaths,
+                     FileFullPaths, SaveFileFullPaths)
 from lib.utils import _image_extensions
 
 
+class AlignmentsArgs(FaceSwapArgs):
+    """ Class to parse the command line arguments for Aligments tool """
+
+    def get_argument_list(self):
+        frames_dir = "\n\tMust Pass in a frames folder (-fr)."
+        frames_or_faces_dir = ("\n\tMust Pass in either a frames folder \n\t"
+                               "OR a faces folder (-fr or -fc).")
+        output_opts = "\n\tUse the output option (-o) to process\n\tresults."
+        argument_list = list()
+        argument_list.append({"opts": ("-j", "--job"),
+                              "type": str,
+                              "choices": ("draw", "extract",
+                                          "missing-alignments",
+                                          "missing-frames", "multi-faces",
+                                          "no-faces", "reformat", "remove"),
+                              "required": True,
+                              "help": "R|Choose which action you want to "
+                                      "perform.\nNB: All actions require an "
+                                      "alignments file (-a) to\nbe passed "
+                                      "in.\n"
+                                      "'draw': Draw landmarks on frames in "
+                                      "the selected\n\tfolder. A subfolder "
+                                      "will be created within\n\tthe frames "
+                                      "folder to hold the output." +
+                                      frames_dir + "\n"
+                                      "'extract': Re-extract faces from the "
+                                      "source frames\n\tbased on alignment "
+                                      "data. This is a\n\tlot quicker than "
+                                      "re-detecting faces. Can\n\toptionally "
+                                      "use the align-eyes switch (-ae)." +
+                                      frames_dir + "\n"
+                                      "'missing-alignments': Identify frames "
+                                      "that do not\n\texist in the "
+                                      "alignments file." + output_opts +
+                                      frames_dir + "\n"
+                                      "'missing-frames': Identify frames in "
+                                      "the alignments\n\tfile that do not "
+                                      "appear within the frames\n\t"
+                                      "folder." + output_opts +
+                                      frames_dir + "\n"
+                                      "'multi-faces': Identify where multiple "
+                                      "faces exist\n\twithin the alignments "
+                                      "file." + output_opts +
+                                      frames_or_faces_dir + "\n"
+                                      "'no-faces': Identify frames that exist "
+                                      "within the\n\talignment file but no "
+                                      "faces were detected." + output_opts +
+                                      frames_dir + "\n"
+                                      "'reformat': Save a copy of alignments "
+                                      "file in a\n\tdifferent format. "
+                                      "Specify a format with\n\tthe -fmt "
+                                      "option.\n"
+                                      "'remove': Remove deleted faces from "
+                                      "an alignments\n\tfile. The original "
+                                      "alignments file will be\n\tbacked up. "
+                                      "A different file format for the\n\t"
+                                      "alignments file can optionally be\n\t"
+                                      "specified (-fmt).\n\tMust pass in a "
+                                      "faces folder (-fc).\n"})
+        argument_list.append({"opts": ("-a", "--alignments_file"),
+                              "action": FileFullPaths,
+                              "dest": "alignments_file",
+                              "required": True,
+                              "filetypes": "alignments",
+                              "help": "Full path to the alignments "
+                                      "file to be processed."})
+        argument_list.append({"opts": ("-fc", "-faces_folder"),
+                              "action": DirFullPaths,
+                              "dest": "faces_dir",
+                              "help": "Directory containing extracted faces."})
+        argument_list.append({"opts": ("-fr", "-frames_folder"),
+                              "action": DirFullPaths,
+                              "dest": "frames_dir",
+                              "help": "Directory containing source frames "
+                                      "that faces were extracted from."})
+        argument_list.append({"opts": ("-fmt", "--alignment_format"),
+                              "type": str,
+                              "choices": ("json", "pickle", "yaml"),
+                              "help": "The file format to save the alignment "
+                                      "data in. Defaults to same as source."})
+        argument_list.append({"opts": ("-o", "--output"),
+                              "type": str,
+                              "choices": ("console", "file", "move"),
+                              "default": "console",
+                              "help": "R|How to output discovered items "
+                                      "('faces'\nand 'frames' only):\n"
+                                      "'console': Print the list of frames to "
+                                      "the screen.\n\t(DEFAULT)\n"
+                                      "'file': Output the list of frames to a "
+                                      "text file\n\t(stored within the source "
+                                      "directory).\n"
+                                      "'move': Move the discovered items to a "
+                                      "sub-folder\n\twithin the source "
+                                      "directory."})
+        argument_list.append({"opts": ("-ae", "--align-eyes"),
+                              "action": "store_true",
+                              "dest": "align_eyes",
+                              "default": False,
+                              "help": "Perform extra alignment to ensure "
+                                      "left/right eyes are  at the same "
+                                      "height. (Extract only)"})
+        argument_list.append({"opts": ("-v", "--verbose"),
+                              "action": "store_true",
+                              "dest": "verbose",
+                              "default": False,
+                              "help": "Show verbose output"})
+        return argument_list
+
+
 class EffmpegArgs(FaceSwapArgs):
     """ Class to parse the command line arguments for EFFMPEG tool """
 
@@ -143,20 +253,21 @@ class EffmpegArgs(FaceSwapArgs):
                                       "action. 'mux-audio' action has this "
                                       "turned on implicitly."})
 
-        argument_list.append({"opts": ('-tr', '--transpose'),
-                              "choices": ("(0, 90CounterClockwise&VerticalFlip)",
-                                          "(1, 90Clockwise)",
-                                          "(2, 90CounterClockwise)",
-                                          "(3, 90Clockwise&VerticalFlip)"),
-                              "type": lambda v: self.__parse_transpose(v),
-                              "dest": "transpose",
-                              "default": None,
-                              "help": "Transpose the video. If transpose is "
-                                      "set, then degrees will be ignored. For "
-                                      "cli you can enter either the number "
-                                      "or the long command name, "
-                                      "e.g. to use (1, 90Clockwise) "
-                                      "-tr 1 or -tr 90Clockwise"})
+        argument_list.append(
+            {"opts": ('-tr', '--transpose'),
+             "choices": ("(0, 90CounterClockwise&VerticalFlip)",
+                         "(1, 90Clockwise)",
+                         "(2, 90CounterClockwise)",
+                         "(3, 90Clockwise&VerticalFlip)"),
+             "type": lambda v: self.__parse_transpose(v),
+             "dest": "transpose",
+             "default": None,
+             "help": "Transpose the video. If transpose is "
+                     "set, then degrees will be ignored. For "
+                     "cli you can enter either the number "
+                     "or the long command name, "
+                     "e.g. to use (1, 90Clockwise) "
+                     "-tr 1 or -tr 90Clockwise"})
 
         argument_list.append({"opts": ('-de', '--degrees'),
                               "type": str,
@@ -228,13 +339,13 @@ class SortArgs(FaceSwapArgs):
                               "choices": ("folders", "rename"),
                               "dest": 'final_process',
                               "default": "rename",
-                              "help": "'folders': files are sorted using the "
-                                      "-s/--sort-by method, then they are "
-                                      "organized into folders using the "
-                                      "-g/--group-by grouping method. "
-                                      "'rename': files are sorted using the "
-                                      "-s/--sort-by then they are renamed. "
-                                      "Default: rename"})
+                              "help": "R|\n'folders': files are sorted using "
+                                      "the -s/--sort-by\n\tmethod, then they "
+                                      "are organized into\n\tfolders using "
+                                      "the -g/--group-by grouping\n\tmethod."
+                                      "\n'rename': files are sorted using "
+                                      "the -s/--sort-by\n\tthen they are "
+                                      "renamed.\nDefault: rename"})
 
         argument_list.append({"opts": ('-k', '--keep'),
                               "action": 'store_true',

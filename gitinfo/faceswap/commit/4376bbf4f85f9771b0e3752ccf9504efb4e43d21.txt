commit 4376bbf4f85f9771b0e3752ccf9504efb4e43d21
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Wed Jan 23 00:19:48 2019 +0000

    Alignments tool: Filename clash bugfix

diff --git a/lib/alignments.py b/lib/alignments.py
index 7da5025..ad25dfc 100644
--- a/lib/alignments.py
+++ b/lib/alignments.py
@@ -62,10 +62,13 @@ class Alignments():
     @property
     def hashes_to_frame(self):
         """ Return a dict of each face_hash with their parent
-            frame name and their index in the frame """
-        return{face["hash"]: (frame_name, idx)
-               for frame_name, faces in self.data.items()
-               for idx, face in enumerate(faces)}
+            frame name(s) and their index in the frame
+            """
+        hash_faces = dict()
+        for frame_name, faces in self.data.items():
+            for idx, face in enumerate(faces):
+                hash_faces.setdefault(face["hash"], dict())[frame_name] = idx
+        return hash_faces
 
     # << INIT FUNCTIONS >> #
 
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index efcf002..1334485 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -102,15 +102,16 @@ class Check():
         for item in tqdm(self.items, desc=self.output_message):
             frame = item[frame_key]
             if self.type == "faces":
-                frame, idx = self.alignments.hashes_to_frame[frame]
+                frame_idx = [(frame, idx)
+                             for frame, idx in self.alignments.hashes_to_frame[frame].items()]
             retval = item[retval_key]
-
-            if self.alignments.frame_has_multiple_faces(frame):
-                if self.type == "faces":
-                    # Add correct alignments index for moving faces
-                    retval = (retval, idx)
-                logger.trace("Returning: '%s'", retval)
-                yield retval
+            for frame, idx in frame_idx:
+                if self.alignments.frame_has_multiple_faces(frame):
+                    if self.type == "faces":
+                        # Add correct alignments index for moving faces
+                        retval = (retval, idx)
+                    logger.trace("Returning: '%s'", retval)
+                    yield retval
 
     def get_missing_alignments(self):
         """ yield each frame that does not exist in alignments file """
@@ -359,6 +360,88 @@ class Extract():
         return valid_faces
 
 
+class Legacy():
+    """ Update legacy alignments:
+
+        - Add frame dimensions
+        - Rotate landmarks and bounding boxes on legacy alignments
+          and remove the 'r' parameter
+        - Add face hashes to alignments file
+    """
+
+    def __init__(self, alignments, arguments, frames=None, faces=None, child_process=False):
+        logger.debug("Initializing %s: (arguments: %s, child_process: %s)",
+                     self.__class__.__name__, arguments, child_process)
+        self.alignments = alignments
+        if child_process:
+            self.frames = frames
+            self.faces = faces
+        else:
+            self.frames = Frames(arguments.frames_dir)
+            self.faces = Faces(arguments.faces_dir)
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def process(self):
+        """ Run the rotate alignments process """
+        no_dims = self.alignments.get_legacy_no_dims()
+        rotated = self.alignments.get_legacy_rotation()
+        hashes = self.alignments.get_legacy_no_hashes()
+        if (not self.frames or (not no_dims and not rotated)) and (not self.faces or not hashes):
+            return
+        logger.info("[UPDATE LEGACY LANDMARKS]")  # Tidy up cli output
+        if no_dims and self.frames:
+            logger.info("Legacy landmarks found. Adding frame dimensions...")
+            self.add_dimensions(no_dims)
+            self.alignments.save()
+        if rotated and self.frames:
+            logger.info("Legacy rotated frames found. Converting...")
+            self.rotate_landmarks(rotated)
+            self.alignments.save()
+        if hashes and self.faces:
+            logger.info("Legacy alignments found. Adding Face Hashes...")
+            self.add_hashes(hashes)
+            self.alignments.save()
+
+    def add_dimensions(self, no_dims):
+        """ Add width and height of original frame to alignments """
+        for no_dim in tqdm(no_dims, desc="Adding Frame Dimensions"):
+            if no_dim not in self.frames.items.keys():
+                continue
+            dims = self.frames.load_image(no_dim).shape[:2]
+            self.alignments.add_dimensions(no_dim, dims)
+
+    def rotate_landmarks(self, rotated):
+        """ Rotate the landmarks """
+        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
+            if rotate_item not in self.frames.items.keys():
+                continue
+            self.alignments.rotate_existing_landmarks(rotate_item)
+
+    def add_hashes(self, hashes):
+        """ Add Face Hashes to the alignments file """
+        all_faces = dict()
+        logger.info("Getting original filenames, indexes and hashes...")
+        for face in self.faces.file_list_sorted:
+            filename = face["face_name"]
+            extension = face["face_extension"]
+            if "_" not in face["face_name"]:
+                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
+                continue
+            index = filename[filename.rfind("_") + 1:]
+            if not index.isdigit():
+                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
+                continue
+            orig_frame = filename[:filename.rfind("_")] + extension
+            all_faces.setdefault(orig_frame, dict())[int(index)] = face["face_hash"]
+
+        logger.info("Updating hashes to alignments...")
+        for frame in hashes:
+            if frame not in all_faces.keys():
+                logger.warning("Skipping missing frame: '%s'", frame)
+                continue
+            self.alignments.add_face_hashes(frame, all_faces[frame])
+
+
 class Merge():
     """ Merge two alignments files into one """
     def __init__(self, alignments, arguments):
@@ -390,16 +473,16 @@ class Merge():
             self.alignments.save()
 
     def check_exists(self, frame, alignment, idx):
-        """ Check whether this has already exists """
+        """ Check whether this face already exists """
         existing_frame = self.alignments.hashes_to_frame.get(alignment["hash"], None)
         if not existing_frame:
             return False
-        if existing_frame[0] == frame:
+        if frame in existing_frame.keys():
             logger.verbose("Face '%s': %s already exists in destination at position %s. "
-                           "Skipping", frame, idx, existing_frame[1])
-        elif existing_frame[0] != frame:
-            logger.verbose("Face '%s': %s exists in destination as face '%s': %s. "
-                           "Skipping", frame, idx, existing_frame[0], existing_frame[1])
+                           "Skipping", frame, idx, existing_frame[frame])
+        elif frame not in existing_frame.keys():
+            logger.verbose("Face '%s': %s exists in destination as: %s. "
+                           "Skipping", frame, idx, existing_frame)
         return True
 
     def merge_alignment(self, frame, alignment, idx):
@@ -578,88 +661,6 @@ class RemoveAlignments():
         return del_count
 
 
-class Legacy():
-    """ Update legacy alignments:
-
-        - Add frame dimensions
-        - Rotate landmarks and bounding boxes on legacy alignments
-          and remove the 'r' parameter
-        - Add face hashes to alignments file
-    """
-
-    def __init__(self, alignments, arguments, frames=None, faces=None, child_process=False):
-        logger.debug("Initializing %s: (arguments: %s, child_process: %s)",
-                     self.__class__.__name__, arguments, child_process)
-        self.alignments = alignments
-        if child_process:
-            self.frames = frames
-            self.faces = faces
-        else:
-            self.frames = Frames(arguments.frames_dir)
-            self.faces = Faces(arguments.faces_dir)
-        logger.debug("Initialized %s", self.__class__.__name__)
-
-    def process(self):
-        """ Run the rotate alignments process """
-        no_dims = self.alignments.get_legacy_no_dims()
-        rotated = self.alignments.get_legacy_rotation()
-        hashes = self.alignments.get_legacy_no_hashes()
-        if (not self.frames or (not no_dims and not rotated)) and (not self.faces or not hashes):
-            return
-        logger.info("[UPDATE LEGACY LANDMARKS]")  # Tidy up cli output
-        if no_dims and self.frames:
-            logger.info("Legacy landmarks found. Adding frame dimensions...")
-            self.add_dimensions(no_dims)
-            self.alignments.save()
-        if rotated and self.frames:
-            logger.info("Legacy rotated frames found. Converting...")
-            self.rotate_landmarks(rotated)
-            self.alignments.save()
-        if hashes and self.faces:
-            logger.info("Legacy alignments found. Adding Face Hashes...")
-            self.add_hashes(hashes)
-            self.alignments.save()
-
-    def add_dimensions(self, no_dims):
-        """ Add width and height of original frame to alignments """
-        for no_dim in tqdm(no_dims, desc="Adding Frame Dimensions"):
-            if no_dim not in self.frames.items.keys():
-                continue
-            dims = self.frames.load_image(no_dim).shape[:2]
-            self.alignments.add_dimensions(no_dim, dims)
-
-    def rotate_landmarks(self, rotated):
-        """ Rotate the landmarks """
-        for rotate_item in tqdm(rotated, desc="Rotating Landmarks"):
-            if rotate_item not in self.frames.items.keys():
-                continue
-            self.alignments.rotate_existing_landmarks(rotate_item)
-
-    def add_hashes(self, hashes):
-        """ Add Face Hashes to the alignments file """
-        all_faces = dict()
-        logger.info("Getting original filenames, indexes and hashes...")
-        for face in self.faces.file_list_sorted:
-            filename = face["face_name"]
-            extension = face["face_extension"]
-            if "_" not in face["face_name"]:
-                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
-                continue
-            index = filename[filename.rfind("_") + 1:]
-            if not index.isdigit():
-                logger.warning("Unable to determine index of file. Skipping: '%s'", filename)
-                continue
-            orig_frame = filename[:filename.rfind("_")] + extension
-            all_faces.setdefault(orig_frame, dict())[int(index)] = face["face_hash"]
-
-        logger.info("Updating hashes to alignments...")
-        for frame in hashes:
-            if frame not in all_faces.keys():
-                logger.warning("Skipping missing frame: '%s'", frame)
-                continue
-            self.alignments.add_face_hashes(frame, all_faces[frame])
-
-
 class Rename():
     """ Rename faces to match their source frame and position index """
     def __init__(self, alignments, arguments, faces=None):
@@ -667,6 +668,7 @@ class Rename():
                      self.__class__.__name__, arguments, faces)
         self.alignments = alignments
         self.faces = faces if faces else Faces(arguments.faces_dir)
+        self.seen_multihash = set()
         logger.debug("Initialized %s", self.__class__.__name__)
 
     def process(self):
@@ -684,28 +686,60 @@ class Rename():
             Done in 2 iterations as two files cannot share the same name """
         logger.trace("Renaming faces for frame: '%s'", frame_fullname)
         temp_ext = ".temp_move"
-        frame_faces = [(f_hash, details[1])
+        frame_faces = list()
+        frame_faces = [(f_hash, idx)
                        for f_hash, details in self.alignments.hashes_to_frame.items()
-                       if details[0] == frame_fullname]
+                       for frame_name, idx in details.items()
+                       if frame_name == frame_fullname]
         rename_count = 0
+        rename_files = list()
         for f_hash, idx in frame_faces:
-            face_name, face_ext = self.faces.items[f_hash]
+            faces = self.faces.items[f_hash]
+            if len(faces) == 1:
+                face_name, face_ext = faces[0]
+            else:
+                face_name, face_ext = self.check_multi_hashes(faces, frame, idx)
             old = face_name + face_ext
             new = "{}_{}{}".format(frame, idx, face_ext)
             if old == new:
                 logger.trace("Face does not require renaming: '%s'", old)
                 continue
-            for action in ("temp", "final"):
+            rename_files.append((old, new))
+        for action in ("temp", "final"):
+            for files in rename_files:
+                old, new = files
                 old_file = old if action == "temp" else old + temp_ext
                 new_file = old + temp_ext if action == "temp" else new
                 src = os.path.join(self.faces.folder, old_file)
                 dst = os.path.join(self.faces.folder, new_file)
                 logger.trace("Renaming: '%s' to '%s'", old_file, new_file)
                 os.rename(src, dst)
-            rename_count += 1
-            logger.verbose("Renamed '%s' to '%s'", old, new)
+                if action == "final":
+                    rename_count += 1
+                    logger.verbose("Renamed '%s' to '%s'", old, new)
         return rename_count
 
+    def check_multi_hashes(self, faces, frame, idx):
+        """ Check filenames for where multiple faces have the
+            same hash (e.g. for freeze frames) """
+        frame_idx = "{}_{}".format(frame, idx)
+        for face_name, extension in faces:
+            if (face_name, extension) in self.seen_multihash:
+                # Don't return a filename that has already been processed
+                continue
+            if face_name == frame_idx:
+                # If a matching filename already exists return that
+                self.seen_multihash.add((face_name, extension))
+                return face_name, extension
+            if face_name.startswith(frame):
+                # If a matching framename already exists return that
+                self.seen_multihash.add((face_name, extension))
+                return face_name, extension
+        # If no matches, just pop the first filename
+        face_name, extension = faces[0]
+        self.seen_multihash.add((face_name, extension))
+        return face_name, extension
+
 
 class Sort():
     """ Sort alignments' index by the order they appear in
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index f4c7b38..5f68371 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -201,8 +201,10 @@ class Faces(MediaLoader):
 
     def load_items(self):
         """ Load the face names into dictionary """
-        faces = {face["face_hash"]: (face["face_name"], face["face_extension"])
-                 for face in self.file_list_sorted}
+        faces = dict()
+        for face in self.file_list_sorted:
+            faces.setdefault(face["face_hash"], list()).append((face["face_name"],
+                                                                face["face_extension"]))
         logger.trace(faces)
         return faces
 

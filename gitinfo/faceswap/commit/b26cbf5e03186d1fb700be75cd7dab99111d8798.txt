commit b26cbf5e03186d1fb700be75cd7dab99111d8798
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Mon Sep 17 16:31:43 2018 +0100

    Alignments Tool - Manual (#503)
    
    * Initial alignment tool implementation
    
    * Add face processing. Fix helptext formatting for cli and gui
    
    * Extract faces from alignments file
    
    * Add draw landmarks
    
    * fix analysis hours past 24 bug
    
    * Remove tools flag. Enlarge GUI tooltips
    
    * Add filename extension check for image folders
    
    * Fix folder nonetype bug and linting
    
    * Bugfix renaming of faces
    
    * Import alignments from DeepFaceLab
    
    * Remove frames requirement for dfl
    
    * Alignments Tool: Add remove frames
    
    * Alignments: Add remove frames (#492)
    
    * Alignments Tool: Add remove frames
    
    * Implement Frame display for manual extract
    
    * Alignments refactor
    
    * Further navigation improvements
    
    * Further navigation improvements
    
    * Alignment Tool: Refactor
    
    * Move rotate_image_by_angle() to utils
    
    * Further refactoring improvements
    
    * Reduce key bindings. Add skip to has faces, Add resize frame binding
    
    * More navigation options. Delete faces added. Save alignments added
    
    * Add: Reload alignments. Add extra api calls. Better redraw handling.
    
    * Manual Alignments - Alpha Build
    
    * Rotate landmarks for rotated images
    
    * Rebase to remove OriginalHiRes changes

diff --git a/.gitignore b/.gitignore
index bd31020..04e56c5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,3 +19,4 @@
 !scripts
 !plugins
 !tools
+!tools/lib*
diff --git a/lib/face_alignment/detectors.py b/lib/face_alignment/detectors.py
index 7937d4c..992d2a8 100644
--- a/lib/face_alignment/detectors.py
+++ b/lib/face_alignment/detectors.py
@@ -42,6 +42,25 @@ class Detector(object):
         return isinstance(d_rectangle, dlib.mmod_rectangle)
 
 
+class ManualDetector(Detector):
+    """ Manual Detector """
+    def set_data_path(self):
+        return None
+
+    def create_detector(self, verbose):
+        """ Create the mtcnn detector """
+        self.verbose = verbose
+
+        if self.verbose:
+            print("Adding Manual detector")
+
+    def detect_faces(self, bounding_box):
+        """ Return the given bounding box in a dlib rectangle """
+        face = bounding_box
+        self.detected_faces = [dlib.rectangle(int(face[0]), int(face[1]),
+                                              int(face[2]), int(face[3]))]
+
+
 class DLibDetector(Detector):
     """ Dlib detector for face recognition """
     def __init__(self):
diff --git a/lib/face_alignment/extractor.py b/lib/face_alignment/extractor.py
index 4677685..cf4d416 100644
--- a/lib/face_alignment/extractor.py
+++ b/lib/face_alignment/extractor.py
@@ -7,12 +7,13 @@
 import cv2
 import numpy as np
 
-from .detectors import DLibDetector, MTCNNDetector
+from .detectors import DLibDetector, MTCNNDetector, ManualDetector
 from .vram_allocation import GPUMem
 from .model import KerasModel
 
 DLIB_DETECTORS = DLibDetector()
 MTCNN_DETECTOR = MTCNNDetector()
+MANUAL_DETECTOR = ManualDetector()
 VRAM = GPUMem()
 KERAS_MODEL = KerasModel()
 
@@ -40,6 +41,8 @@ class Frame():
 
         if detector == "mtcnn":
             self.scale_mtcnn()
+        elif detector == "manual":
+            self.input_scale = 1.0
         else:
             self.scale_dlib()
 
@@ -241,72 +244,69 @@ class Extract():
 
     def __init__(self, input_image_bgr, detector, dlib_buffer=64,
                  mtcnn_kwargs=None, verbose=False,
-                 input_is_predetected_face=False):
+                 input_is_predetected_face=False,
+                 initialize_only=False):
         self.verbose = verbose
         self.keras = KERAS_MODEL
+        self.detector_name = detector
         self.detector = None
+        self.frame = None
+        self.bounding_boxes = None
+        self.landmarks = None
 
-        self.initialize(detector, mtcnn_kwargs, dlib_buffer)
+        self.initialize(mtcnn_kwargs, dlib_buffer)
 
-        self.frame = Frame(detector=detector,
-                           input_image=input_image_bgr,
-                           verbose=verbose,
-                           input_is_predetected_face=input_is_predetected_face)
-
-        self.detect_faces(input_is_predetected_face)
-        self.bounding_boxes = self.get_bounding_boxes()
+        if not initialize_only:
+            self.execute(input_image_bgr, input_is_predetected_face)
 
-        self.landmarks = Align(image=self.frame.image_rgb,
-                               detected_faces=self.bounding_boxes,
-                               keras_model=self.keras,
-                               verbose=self.verbose).landmarks
-
-    def initialize(self, detector, mtcnn_kwargs, dlib_buffer):
+    def initialize(self, mtcnn_kwargs, dlib_buffer):
         """ initialize Keras and Dlib """
         if not VRAM.initialized:
-            self.initialize_vram(detector, dlib_buffer)
+            self.initialize_vram(dlib_buffer)
 
         if not self.keras.initialized:
-            self.initialize_keras(detector)
+            self.initialize_keras()
             # VRAM Scaling factor must be set AFTER Keras has loaded
-            VRAM.set_scale_to(detector)
+            VRAM.set_scale_to(self.detector_name)
 
-        if detector == "mtcnn":
+        if self.detector_name == "mtcnn":
             self.detector = MTCNN_DETECTOR
+        elif self.detector_name == "manual":
+            self.detector = MANUAL_DETECTOR
         else:
             self.detector = DLIB_DETECTORS
 
         if not self.detector.initialized:
-            self.initialize_detector(detector, mtcnn_kwargs)
+            self.initialize_detector(mtcnn_kwargs)
 
-    def initialize_vram(self, detector, dlib_buffer):
+    def initialize_vram(self, dlib_buffer):
         """ Initialize vram based on detector """
         VRAM.verbose = self.verbose
-        VRAM.detector = detector
+        VRAM.detector = self.detector_name
         if dlib_buffer > VRAM.dlib_buffer:
             VRAM.dlib_buffer = dlib_buffer
         VRAM.initialized = True
         VRAM.output_stats()
 
-    def initialize_keras(self, detector):
+    def initialize_keras(self):
         """ Initialize keras. Allocate vram to tensorflow
             based on detector """
         ratio = None
-        if detector != "mtcnn" and VRAM.device != -1:
+        if self.detector_name != "mtcnn" and VRAM.device != -1:
             ratio = VRAM.get_tensor_gpu_ratio()
         placeholder = np.zeros((1, 3, 256, 256))
         self.keras.load_model(verbose=self.verbose,
                               ratio=ratio,
                               dummy=placeholder)
 
-    def initialize_detector(self, detector, mtcnn_kwargs):
+    def initialize_detector(self, mtcnn_kwargs):
         """ Initialize face detector """
         kwargs = {"verbose": self.verbose}
-        if detector == "mtcnn":
+        if self.detector_name == "mtcnn":
             mtcnn_kwargs = self.detector.validate_kwargs(mtcnn_kwargs)
             kwargs["mtcnn_kwargs"] = mtcnn_kwargs
-        else:
-            kwargs["detector"] = detector
+        elif self.detector_name != "manual":
+            kwargs["detector"] = self.detector_name
             scale_to = int(VRAM.scale_to ** 0.5)
 
             if self.verbose:
@@ -319,7 +319,23 @@ class Extract():
 
         self.detector.create_detector(**kwargs)
 
-    def detect_faces(self, input_is_predetected_face):
+    def execute(self, input_image_bgr,
+                input_is_predetected_face=False, manual_face=None):
+        """ Execute extract """
+        self.frame = Frame(detector=self.detector_name,
+                           input_image=input_image_bgr,
+                           verbose=self.verbose,
+                           input_is_predetected_face=input_is_predetected_face)
+
+        self.detect_faces(input_is_predetected_face, manual_face)
+        self.bounding_boxes = self.get_bounding_boxes()
+
+        self.landmarks = Align(image=self.frame.image_rgb,
+                               detected_faces=self.bounding_boxes,
+                               keras_model=self.keras,
+                               verbose=self.verbose).landmarks
+
+    def detect_faces(self, input_is_predetected_face, manual_face):
         """ Detect faces """
         # Predetected_face is used for sort tool.
         # Landmarks should not be extracted again from predetected faces,
@@ -328,6 +344,8 @@ class Extract():
 
         if input_is_predetected_face:
             self.detector.set_predetected(self.frame.width, self.frame.height)
+        elif manual_face:
+            self.detector.detect_faces(manual_face)
         else:
             self.detector.detect_faces(self.frame.image_detect)
 
diff --git a/lib/utils.py b/lib/utils.py
index 893c84e..64a1be9 100644
--- a/lib/utils.py
+++ b/lib/utils.py
@@ -9,6 +9,9 @@ import warnings
 
 from pathlib import Path
 
+import cv2
+import numpy as np
+
 
 # Global variables
 _image_extensions = ['.bmp', '.jpeg', '.jpg', '.png', '.tif', '.tiff']
@@ -26,7 +29,7 @@ def get_image_paths(directory, exclude=list(), debug=False):
     """ Return a list of images that reside in a folder """
     image_extensions = _image_extensions
     exclude_names = [basename(Path(x).stem[:Path(x).stem.rfind('_')] +
-        Path(x).suffix) for x in exclude]
+                              Path(x).suffix) for x in exclude]
     dir_contents = list()
 
     if not exists(directory):
@@ -34,7 +37,8 @@ def get_image_paths(directory, exclude=list(), debug=False):
 
     dir_scanned = sorted(os.scandir(directory), key=lambda x: x.name)
     for chkfile in dir_scanned:
-        if any([chkfile.name.lower().endswith(ext) for ext in image_extensions]):
+        if any([chkfile.name.lower().endswith(ext)
+                for ext in image_extensions]):
             if chkfile.name in exclude_names:
                 if debug:
                     print("Already processed %s" % chkfile.name)
@@ -73,10 +77,67 @@ def set_system_verbosity(loglevel):
             warnings.simplefilter(action='ignore', category=warncat)
 
 
+def rotate_image_by_angle(image, angle,
+                          rotated_width=None, rotated_height=None):
+    """ Rotate an image by a given angle.
+        From: https://stackoverflow.com/questions/22041699 """
+
+    height, width = image.shape[:2]
+    image_center = (width/2, height/2)
+    rotation_matrix = cv2.getRotationMatrix2D(image_center, -1.*angle, 1.)
+    if rotated_width is None or rotated_height is None:
+        abs_cos = abs(rotation_matrix[0, 0])
+        abs_sin = abs(rotation_matrix[0, 1])
+        if rotated_width is None:
+            rotated_width = int(height*abs_sin + width*abs_cos)
+        if rotated_height is None:
+            rotated_height = int(height*abs_cos + width*abs_sin)
+    rotation_matrix[0, 2] += rotated_width/2 - image_center[0]
+    rotation_matrix[1, 2] += rotated_height/2 - image_center[1]
+    return (cv2.warpAffine(image,
+                           rotation_matrix,
+                           (rotated_width, rotated_height)),
+            rotation_matrix)
+
+
+def rotate_landmarks(face, rotation_matrix):
+    """ Rotate the landmarks and bounding box for faces
+        found in rotated images.
+        Pass in a DetectedFace object"""
+    rotation_matrix = cv2.invertAffineTransform(rotation_matrix)
+    bounding_box = [[face.x, face.y],
+                    [face.x + face.w, face.y],
+                    [face.x + face.w, face.y + face.h],
+                    [face.x, face.y + face.h]]
+    landmarks = face.landmarksXY
+    rotated = list()
+    for item in (bounding_box, landmarks):
+        points = np.array(item, np.int32)
+        points = np.expand_dims(points, axis=0)
+        transformed = cv2.transform(points,
+                                    rotation_matrix).astype(np.int32)
+        rotated.append(transformed.squeeze())
+
+    # Bounding box should follow x, y planes, so get min/max
+    # for non-90 degree rotations
+    pnt_x = min([pnt[0] for pnt in rotated[0]])
+    pnt_y = min([pnt[1] for pnt in rotated[0]])
+    pnt_x1 = max([pnt[0] for pnt in rotated[0]])
+    pnt_y1 = max([pnt[1] for pnt in rotated[0]])
+    face.x = int(pnt_x)
+    face.y = int(pnt_y)
+    face.w = int(pnt_x1 - pnt_x)
+    face.h = int(pnt_y1 - pnt_y)
+    face.r = 0
+    face.landmarksXY = [tuple(point) for point in rotated[1].tolist()]
+    return face
+
+
 class BackgroundGenerator(threading.Thread):
     """ Run a queue in the background. From:
-        https://stackoverflow.com/questions/7323664/python-generator-pre-fetch """
-    def __init__(self, generator, prefetch=1):  # See below why prefetch count is flawed
+        https://stackoverflow.com/questions/7323664/ """
+    # See below why prefetch count is flawed
+    def __init__(self, generator, prefetch=1):
         threading.Thread.__init__(self)
         self.queue = Queue.Queue(prefetch)
         self.generator = generator
diff --git a/scripts/convert.py b/scripts/convert.py
index 549d635..34a8c2b 100644
--- a/scripts/convert.py
+++ b/scripts/convert.py
@@ -138,10 +138,13 @@ class Convert(object):
         if self.opts.check_skipface(filename, idx):
             return image
 
+        # Rotating an image is legacy code. Landmarks are now
+        # rotated at extract stage. For newer extracts face.r
+        # will always be zero.
         image = self.images.rotate_image(image, face.r)
         # TODO: This switch between 64 and 128 is a hack for now.
         # We should have a separate cli option for size
-
+        
         size = 128 if (self.args.trainer.strip().lower()
                        in ('gan128', 'originalhighres')) else 64
 
diff --git a/scripts/extract.py b/scripts/extract.py
index e6b31c8..84e4ca8 100644
--- a/scripts/extract.py
+++ b/scripts/extract.py
@@ -9,12 +9,13 @@ from tqdm import tqdm
 
 from lib.gpu_stats import GPUStats
 from lib.multithreading import pool_process
+from lib.utils import rotate_image_by_angle, rotate_landmarks
 from scripts.fsmedia import Alignments, Faces, Images, Utils
 
 tqdm.monitor_interval = 0  # workaround for TqdmSynchronisationWarning
 
 
-class Extract(object):
+class Extract():
     """ The extract process. """
 
     def __init__(self, arguments):
@@ -27,7 +28,9 @@ class Extract(object):
         self.output_dir = self.faces.output_dir
 
         self.export_face = True
-        self.save_interval = self.args.save_interval if hasattr(self.args, "save_interval") else None
+        self.save_interval = None
+        if hasattr(self.args, "save_interval"):
+            self.save_interval = self.args.save_interval
 
     def process(self):
         """ Perform the extraction process """
@@ -53,9 +56,9 @@ class Extract(object):
         self.faces.num_faces_detected = faces
 
     def write_alignments(self):
+        """ Save the alignments file """
         self.alignments.write_alignments(self.faces.faces_detected)
 
-
     def extract_single_process(self):
         """ Run extraction in a single process """
         frame_no = 0
@@ -94,19 +97,28 @@ class Extract(object):
             image = Utils.cv2_read_write('read', filename)
 
             for angle in self.images.rotation_angles:
-                currentimage = Utils.rotate_image_by_angle(image, angle)
+                currentimage, rotation_matrix = rotate_image_by_angle(image,
+                                                                      angle)
                 faces = self.faces.get_faces(currentimage, angle)
-                process_faces = [(idx, face) for idx, face in faces]
-                if process_faces and angle != 0 and self.args.verbose:
+                process_faces = [[idx, face] for idx, face in faces]
+                if not process_faces:
+                    continue
+
+                if angle != 0 and self.args.verbose:
                     print("found face(s) by rotating image "
                           "{} degrees".format(angle))
+                if angle != 0:
+                    process_faces = [[idx,
+                                      rotate_landmarks(face, rotation_matrix)]
+                                     for idx, face in process_faces]
+
                 if process_faces:
                     break
 
             final_faces = [self.process_single_face(idx,
                                                     face,
                                                     filename,
-                                                    currentimage)
+                                                    image)
                            for idx, face in process_faces]
 
             retval = filename, final_faces
@@ -114,6 +126,7 @@ class Extract(object):
             if self.args.verbose:
                 print("Failed to extract from image: "
                       "{}. Reason: {}".format(filename, err))
+            raise
         return retval
 
     def process_single_face(self, idx, face, filename, image):
@@ -141,8 +154,7 @@ class Extract(object):
                                         Path(filename).suffix)
             Utils.cv2_read_write('write', filename, resized_face)
 
-        return {"r": face.r,
-                "x": face.x,
+        return {"x": face.x,
                 "w": face.w,
                 "y": face.y,
                 "h": face.h,
diff --git a/scripts/fsmedia.py b/scripts/fsmedia.py
index a4f8911..975303f 100644
--- a/scripts/fsmedia.py
+++ b/scripts/fsmedia.py
@@ -15,7 +15,8 @@ from lib.detect_blur import is_blurry
 from lib import Serializer
 from lib.faces_detect import detect_faces, DetectedFace
 from lib.FaceFilter import FaceFilter
-from lib.utils import get_folder, get_image_paths, set_system_verbosity
+from lib.utils import (get_folder, get_image_paths, rotate_image_by_angle,
+                       set_system_verbosity)
 from plugins.PluginLoader import PluginLoader
 
 
@@ -29,30 +30,6 @@ class Utils():
         lvl = '0' if verbose else '2'
         set_system_verbosity(lvl)
 
-    @staticmethod
-    def rotate_image_by_angle(image, angle,
-                              rotated_width=None, rotated_height=None):
-        """ Rotate an image by a given angle.
-            From: https://stackoverflow.com/questions/22041699
-
-            This is required by both Faces and Images
-            so placed here for now """
-        height, width = image.shape[:2]
-        image_center = (width/2, height/2)
-        rotation_matrix = cv2.getRotationMatrix2D(image_center, -1.*angle, 1.)
-        if rotated_width is None or rotated_height is None:
-            abs_cos = abs(rotation_matrix[0, 0])
-            abs_sin = abs(rotation_matrix[0, 1])
-            if rotated_width is None:
-                rotated_width = int(height*abs_sin + width*abs_cos)
-            if rotated_height is None:
-                rotated_height = int(height*abs_cos + width*abs_sin)
-        rotation_matrix[0, 2] += rotated_width/2 - image_center[0]
-        rotation_matrix[1, 2] += rotated_height/2 - image_center[1]
-        return cv2.warpAffine(image,
-                              rotation_matrix,
-                              (rotated_width, rotated_height))
-
     @staticmethod
     def cv2_read_write(action, filename, image=None):
         """ Read or write an image using cv2 """
@@ -152,16 +129,17 @@ class Images():
 
     def rotate_image(self, image, rotation, reverse=False):
         """ Rotate the image forwards or backwards """
-        if rotation != 0:
-            if not reverse:
-                self.rotation_height, self.rotation_width = image.shape[:2]
-                image = Utils.rotate_image_by_angle(image, rotation)
-            else:
-                image = Utils.rotate_image_by_angle(
-                    image,
-                    rotation * -1,
-                    rotated_width=self.rotation_width,
-                    rotated_height=self.rotation_height)
+        if rotation == 0:
+            return image
+        if not reverse:
+            self.rotation_height, self.rotation_width = image.shape[:2]
+            image, _ = rotate_image_by_angle(image, rotation)
+        else:
+            image, _ = rotate_image_by_angle(
+                image,
+                rotation * -1,
+                rotated_width=self.rotation_width,
+                rotated_height=self.rotation_height)
         return image
 
 
@@ -254,8 +232,10 @@ class Faces():
         for rawface in faces:
             face = DetectedFace(**rawface)
             # Rotate the image if necessary
+            # NB: Rotation of landmarks now occurs at extract stage
+            # This is here for legacy alignments
             if face.r != 0:
-                image = Utils.rotate_image_by_angle(image, face.r)
+                image, _ = rotate_image_by_angle(image, face.r)
             face.image = image[face.y: face.y + face.h,
                                face.x: face.x + face.w]
             if self.filter and not self.filter.check(face):
diff --git a/tools/alignments.py b/tools/alignments.py
index 5f01ba6..f6878c1 100644
--- a/tools/alignments.py
+++ b/tools/alignments.py
@@ -2,30 +2,28 @@
 """ Tools for manipulating the alignments seralized file """
 
 # TODO merge alignments
-# TODO Remove whole frames from alignments file
-import os
-import pickle
-import struct
-from datetime import datetime
-
-from cv2 import circle, imread, imwrite, rectangle
-from tqdm import tqdm
-
-from lib import Serializer
-from lib.utils import _image_extensions
-from plugins.PluginLoader import PluginLoader
+from lib.utils import set_system_verbosity
+from .lib_alignments import (AlignmentData, Check, Draw, Extract, Manual,
+                             Reformat, RemoveAlignments, Rotate, Sort)
 
 
 class Alignments():
     """ Perform tasks relating to alignments file """
     def __init__(self, arguments):
         self.args = arguments
+        self.set_verbosity(arguments.verbose)
 
         dest_format = self.get_dest_format()
         self.alignments = AlignmentData(self.args.alignments_file,
                                         dest_format,
                                         self.args.verbose)
 
+    @staticmethod
+    def set_verbosity(verbose):
+        """ Set the system output verbosity """
+        lvl = '0' if verbose else '2'
+        set_system_verbosity(lvl)
+
     def get_dest_format(self):
         """ Set the destination format for Alignments """
         dest_format = None
@@ -36,765 +34,15 @@ class Alignments():
 
     def process(self):
         """ Main processing function of the Align tool """
-        if self.args.job == "draw":
-            job = Draw(self.alignments, self.args)
-        elif self.args.job == "extract":
-            job = Extract(self.alignments, self.args)
+        if self.args.job.startswith("remove-"):
+            job = RemoveAlignments
+        elif self.args.job.startswith("sort-"):
+            job = Sort
         elif self.args.job in("missing-alignments", "missing-frames",
                               "multi-faces", "leftover-faces",
                               "no-faces"):
-            job = Check(self.alignments, self.args)
-        elif self.args.job == "remove":
-            job = RemoveAlignments(self.alignments, self.args)
-        elif self.args.job == "reformat":
-            job = Reformat(self.alignments, self.args)
-
-        job.process()
-
-
-class AlignmentData():
-    """ Class to hold the alignment data """
-
-    def __init__(self, alignments_file, destination_format, verbose):
-        print("\n[ALIGNMENT DATA]")  # Tidy up cli output
-        self.file = alignments_file
-        self.verbose = verbose
-
-        self.check_file_exists()
-        self.src_format = self.get_source_format()
-        self.dst_format = self.get_destination_format(destination_format)
-
-        if self.src_format == "dfl":
-            self.set_destination_serializer()
-            return
-
-        self.serializer = Serializer.get_serializer_from_ext(
-            self.src_format)
-        self.alignments = self.load()
-        self.count = len(self.alignments)
-        self.count_per_frame = {key: len(value)
-                                for key, value in self.alignments.items()}
-
-        self.set_destination_serializer()
-        if self.verbose:
-            print("{} items loaded".format(self.count))
-
-    def check_file_exists(self):
-        """ Check the alignments file exists"""
-        if os.path.split(self.file.lower())[1] == "dfl":
-            self.file = "dfl"
-        if self.file.lower() == "dfl":
-            print("Using extracted pngs for alignments")
-            return
-        if not os.path.isfile(self.file):
-            print("ERROR: alignments file not "
-                  "found at: {}".format(self.file))
-            exit(0)
-        if self.verbose:
-            print("Alignments file exists at {}".format(self.file))
-        return
-
-    def get_source_format(self):
-        """ Get the source alignments format """
-        if self.file.lower() == "dfl":
-            return "dfl"
-        return os.path.splitext(self.file)[1].lower()
-
-    def get_destination_format(self, destination_format):
-        """ Standardise the destination format to the correct extension """
-        extensions = {".json": "json",
-                      ".p": "pickle",
-                      ".yml": "yaml",
-                      ".yaml": "yaml"}
-        dst_fmt = None
-
-        if destination_format is not None:
-            dst_fmt = destination_format
-        elif self.src_format == "dfl":
-            dst_fmt = "json"
-        elif self.src_format in extensions.keys():
-            dst_fmt = extensions[self.src_format]
+            job = Check
         else:
-            print("{} is not a supported serializer. "
-                  "Exiting".format(self.src_format))
-            exit(0)
-
-        if self.verbose:
-            print("Destination format set to {}".format(dst_fmt))
-
-        return dst_fmt
-
-    def set_destination_serializer(self):
-        """ set the destination serializer """
-        self.serializer = Serializer.get_serializer(self.dst_format)
-
-    def load(self):
-        """ Read the alignments data from the correct format """
-        print("Loading alignments from {}".format(self.file))
-        with open(self.file, self.serializer.roptions) as align:
-            alignments = self.serializer.unmarshal(align.read())
-        return alignments
-
-    def save_alignments(self):
-        """ Backup copy of old alignments and save new alignments """
-        dst = os.path.splitext(self.file)[0]
-        dst += ".{}".format(self.serializer.ext)
-        self.backup_alignments()
-
-        print("Saving alignments to {}".format(dst))
-        with open(dst, self.serializer.woptions) as align:
-            align.write(self.serializer.marshal(self.alignments))
-
-    def backup_alignments(self):
-        """ Backup copy of old alignments """
-        if not os.path.isfile(self.file):
-            return
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        src = self.file
-        dst = src.split(".")
-        dst[0] += "_" + now + "."
-        dst = dst[0] + dst[1]
-        print("Backing up original alignments to {}".format(dst))
-        os.rename(src, dst)
-
-    def get_alignments_one_image(self):
-        """ Return the face alignments for one image """
-        for image, alignments in self.alignments.items():
-            image_stripped = image[:image.rindex(".")]
-            number_alignments = len(alignments)
-            yield image_stripped, alignments, number_alignments
-
-    @staticmethod
-    def get_one_alignment_index_reverse(image_alignments, number_alignments):
-        """ Return the correct original index for
-            alignment in reverse order """
-        for idx, _ in enumerate(reversed(image_alignments)):
-            original_idx = number_alignments - 1 - idx
-            yield original_idx
-
-    def has_alignments(self, filename, alignments):
-        """ Check whether this frame has alignments """
-        if not alignments:
-            if self.verbose:
-                print("Skipping {} - Alignments not found".format(filename))
-            return False
-        return True
-
-
-class MediaLoader():
-    """ Class to load filenames from folder """
-    def __init__(self, folder, verbose):
-        print("\n[{} DATA]".format(self.__class__.__name__.upper()))
-        self.verbose = verbose
-        self.folder = folder
-        self.check_folder_exists()
-        self.file_list_sorted = self.sorted_items()
-        self.items = self.load_items()
-        self.count = len(self.file_list_sorted)
-        if self.verbose:
-            print("{} items loaded".format(self.count))
-
-    def check_folder_exists(self):
-        """ makes sure that the faces folder exists """
-        err = None
-        loadtype = self.__class__.__name__
-        if not self.folder:
-            err = "ERROR: A {} folder must be specified".format(loadtype)
-        elif not os.path.isdir(self.folder):
-            err = ("ERROR: The {} folder {} could not be "
-                   "found".format(loadtype, self.folder))
-        if err:
-            print(err)
-            exit(0)
-
-        if self.verbose:
-            print("Folder exists at {}".format(self.folder))
-
-    @staticmethod
-    def valid_extension(filename):
-        """ Check whether passed in file has a valid extension """
-        extension = os.path.splitext(filename)[1]
-        return bool(extension in _image_extensions)
-
-    @staticmethod
-    def sorted_items():
-        """ Override for specific folder processing """
-        return list()
-
-    @staticmethod
-    def process_folder():
-        """ Override for specific folder processing """
-        return list()
-
-    @staticmethod
-    def load_items():
-        """ Override for specific item loading """
-        return dict()
-
-    def load_image(self, filename):
-        """ Load an image """
-        src = os.path.join(self.folder, filename)
-        image = imread(src)
-        return image
-
-    @staticmethod
-    def save_image(output_folder, filename, image):
-        """ Save an image """
-        output_file = os.path.join(output_folder, filename)
-        imwrite(output_file, image)
-
-
-class Faces(MediaLoader):
-    """ Object to hold the faces that are to be swapped out """
-
-    def process_folder(self):
-        """ Iterate through the faces dir pulling out various information """
-        print("Loading file list from {}".format(self.folder))
-        for face in os.listdir(self.folder):
-            if not self.valid_extension(face):
-                continue
-            filename = os.path.splitext(face)[0]
-            file_extension = os.path.splitext(face)[1]
-            index = int(filename[filename.rindex("_") + 1:])
-            original_file = "{}".format(filename[:filename.rindex("_")])
-            yield (filename, file_extension, original_file, index)
-
-    def load_items(self):
-        """ Load the face names into dictionary """
-        faces = dict()
-        for face in self.file_list_sorted:
-            original_file, index = face[2:4]
-            if faces.get(original_file, "") == "":
-                faces[original_file] = [index]
-            else:
-                faces[original_file].append(index)
-        return faces
-
-    def sorted_items(self):
-        """ Return the items sorted by filename then index """
-        return sorted([item for item in self.process_folder()],
-                      key=lambda x: (x[2], x[3]))
-
-
-class Frames(MediaLoader):
-    """ Object to hold the frames that are to be checked against """
-
-    def process_folder(self):
-        """ Iterate through the frames dir pulling the base filename """
-        print("Loading file list from {}".format(self.folder))
-        for frame in os.listdir(self.folder):
-            if not self.valid_extension(frame):
-                continue
-            filename = os.path.basename(frame)
-            yield filename
-
-    def load_items(self):
-        """ Load the frame info into dictionary """
-        frames = dict()
-        for frame in self.file_list_sorted:
-            frames[frame] = (frame[:frame.rfind(".")],
-                             frame[frame.rfind("."):])
-        return frames
-
-    def sorted_items(self):
-        """ Return the items sorted by filename """
-        return sorted([item for item in self.process_folder()])
-
-
-class Draw():
-    """ Draw Alignments on passed in images """
-    def __init__(self, alignments, arguments):
-        self.verbose = arguments.verbose
-        self.alignments = alignments
-        self.frames = Frames(arguments.frames_dir, self.verbose)
-        self.output_folder = self.set_output()
-
-    def set_output(self):
-        """ Set the output folder path """
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        folder_name = "drawn_landmarks_{}".format(now)
-        output_folder = os.path.join(self.frames.folder, folder_name)
-        os.makedirs(output_folder)
-        return output_folder
-
-    def process(self):
-        """ Run the draw alignments process """
-        print("\n[DRAW LANDMARKS]")  # Tidy up cli output
-        frames_drawn = 0
-        for frame, alignments in tqdm(self.get_frame_alignments(),
-                                      desc="Drawing landmarks",
-                                      total=self.frames.count):
-            if not self.alignments.has_alignments(frame, alignments):
-                continue
-            self.annotate_image(frame, alignments)
-            frames_drawn += 1
-        print("{} Frame(s) output".format(frames_drawn))
-
-    def get_frame_alignments(self):
-        """ Retrieve each frame and it's corresponding alignments """
-        for frame in self.frames.file_list_sorted:
-            alignments = self.alignments.alignments.get(frame, None)
-            yield frame, alignments
-
-    def annotate_image(self, frame, alignments):
-        """ Draw the alignments """
-        image = self.frames.load_image(frame)
-        for alignment in alignments:
-            self.draw_bounding_box(image, alignment)
-            self.draw_landmarks(image, alignment["landmarksXY"])
-        self.frames.save_image(self.output_folder, frame, image)
-
-    @staticmethod
-    def draw_bounding_box(image, alignment):
-        """ Draw the bounding box around face """
-        top_left = (alignment["x"], alignment["y"])
-        bottom_right = (alignment["x"] + alignment["w"],
-                        alignment["y"] + alignment["h"])
-        rectangle(image, top_left, bottom_right, (0, 0, 255), 1)
-
-    @staticmethod
-    def draw_landmarks(image, landmarks):
-        """ Draw the facial landmarks """
-        for (pos_x, pos_y) in landmarks:
-            circle(image, (pos_x, pos_y), 1, (0, 255, 0), -1)
-
-
-class Reformat():
-    """ Reformat Alignment file """
-    def __init__(self, alignments, arguments):
-        self.verbose = arguments.verbose
-        self.alignments = alignments
-        if self.alignments.src_format == "dfl":
-            self.faces = Faces(arguments.faces_dir,
-                               self.verbose)
-
-    def process(self):
-        """ Run reformat """
-        print("\n[REFORMAT ALIGNMENTS]")  # Tidy up cli output
-        if self.alignments.src_format == "dfl":
-            self.alignments.alignments = self.load_dfl()
-            self.alignments.file = os.path.join(self.faces.folder,
-                                                "alignments.json")
-        self.alignments.save_alignments()
-
-    def load_dfl(self):
-        """ Load alignments from DeepFaceLab and format for Faceswap """
-        alignments = dict()
-        for face in self.faces.file_list_sorted:
-            if face[1] != ".png":
-                if self.verbose:
-                    print("{} is not a png. "
-                          "Skipping".format(face[0] + face[1]))
-                continue
-
-            fullpath = os.path.join(self.faces.folder, face[0] + face[1])
-            dfl = self.get_dfl_alignment(fullpath)
-
-            if not dfl:
-                continue
-
-            self.convert_dfl_alignment(dfl, alignments)
-        return alignments
-
-    @staticmethod
-    def get_dfl_alignment(filename):
-        """ Process the alignment of one face """
-        with open(filename, "rb") as dfl:
-            header = dfl.read(8)
-            if header != b"\x89PNG\r\n\x1a\n":
-                print("ERROR: No Valid PNG header: {}".format(filename))
-                return None
-            while True:
-                chunk_start = dfl.tell()
-                chunk_hdr = dfl.read(8)
-                if not chunk_hdr:
-                    break
-                chunk_length, chunk_name = struct.unpack("!I4s", chunk_hdr)
-                dfl.seek(chunk_start, os.SEEK_SET)
-                if chunk_name == b"fcWp":
-                    chunk = dfl.read(chunk_length + 12)
-                    return pickle.loads(chunk[8:-4])
-                else:
-                    dfl.seek(chunk_length+12, os.SEEK_CUR)
-            print("ERROR: Couldn't find DFL alignments: {}".format(filename))
-
-    @staticmethod
-    def convert_dfl_alignment(dfl_alignments, alignments):
-        """ Add DFL Alignments to alignments in Faceswap format """
-        sourcefile = dfl_alignments["source_filename"]
-        if not alignments.get(sourcefile, None):
-            alignments[sourcefile] = list()
-
-        left, top, right, bottom = dfl_alignments["source_rect"]
-        alignment = {"r": 0,
-                     "x": left,
-                     "w": right - left,
-                     "y": top,
-                     "h": bottom - top,
-                     "landmarksXY": dfl_alignments["source_landmarks"]}
-
-        alignments[sourcefile].append(alignment)
-
-
-class Extract():
-    """ Re-extract faces from source frames based on
-        Alignment data """
-    def __init__(self, alignments, arguments):
-        self.verbose = arguments.verbose
-        self.alignments = alignments
-        self.faces_dir = arguments.faces_dir
-        self.align_eyes = arguments.align_eyes
-        self.frames = Frames(arguments.frames_dir, self.verbose)
-        self.extractor = None
-
-    class DetectedFace():
-        """ Detected face and landmark information """
-        def __init__(self, image, r, x, w, y, h, landmarksXY):
-            self.image = image
-            self.r = r
-            self.x = x
-            self.w = w
-            self.y = y
-            self.h = h
-            self.landmarksXY = landmarksXY
-
-        def landmarks_as_xy(self):
-            """ Landmarks as XY """
-            return self.landmarksXY
-
-    def process(self):
-        """ Run extraction """
-        print("\n[EXTRACT FACES]")  # Tidy up cli output
-        self.check_folder()
-        self.extractor = PluginLoader.get_extractor("Align")()
-        self.export_faces()
-
-    def check_folder(self):
-        """ Check that the faces folder doesn't pre-exist
-            and create """
-        err = None
-        if not self.faces_dir:
-            err = "ERROR: Output faces folder not provided."
-        elif os.path.isdir(self.faces_dir):
-            err = "ERROR: Folder already exists at {}".format(self.faces_dir)
-        if err:
-            print(err)
-            exit(0)
-        if self.verbose:
-            print("Creating output folder at {}".format(self.faces_dir))
-        os.makedirs(self.faces_dir)
-
-    def export_faces(self):
-        """ Export the faces """
-        extracted_faces = 0
-        for frame, frame_info, alignments in tqdm(self.get_frame_alignments(),
-                                                  desc="Extracting faces",
-                                                  total=self.frames.count):
-            if not self.alignments.has_alignments(frame, alignments):
-                continue
-            extracted_faces += self.output_faces(frame,
-                                                 frame_info,
-                                                 alignments)
-        print("{} face(s) extracted".format(extracted_faces))
-
-    def get_frame_alignments(self):
-        """ Return the alignments for each frame """
-        for key, value in self.frames.items.items():
-            alignments = self.alignments.alignments.get(key, None)
-            yield key, value, alignments
-
-    def output_faces(self, frame, frame_info, alignments):
-        """ Output the frame's faces to file """
-        face_count = 0
-        image = self.frames.load_image(frame)
-        name, extension = frame_info
-        for idx, alignment in enumerate(alignments):
-            face = self.DetectedFace(image,
-                                     alignment["r"],
-                                     alignment["x"],
-                                     alignment["w"],
-                                     alignment["y"],
-                                     alignment["h"],
-                                     alignment["landmarksXY"])
-            resized_face, _ = self.extractor.extract(image,
-                                                     face,
-                                                     256,
-                                                     self.align_eyes)
-            output = "{}_{}{}".format(name, str(idx), extension)
-            self.frames.save_image(self.faces_dir, output, resized_face)
-            face_count += 1
-        return face_count
-
-
-class RemoveAlignments():
-    """ Remove items from alignments file """
-    def __init__(self, alignments, arguments):
-        self.verbose = arguments.verbose
-        self.alignments = alignments
-        self.faces = Faces(arguments.faces_dir, self.verbose)
-        self.removed = set()
-
-    def process(self):
-        """ run removal """
-        print("\n[REMOVE ALIGNMENTS DATA]")  # Tidy up cli output
-        del_count = 0
-        for item in tqdm(self.alignments.get_alignments_one_image(),
-                         desc="Processing alignments file",
-                         total=self.alignments.count):
-            if self.faces_count_matches(item):
-                continue
-            del_count += self.remove_alignment(item)
-
-        if del_count == 0:
-            print("No changes made to alignments file. Exiting")
-            return
-
-        print("{} alignments(s) were removed from "
-              "alignments file".format(del_count))
-        self.alignments.save_alignments()
-        self.rename_faces()
-
-    def faces_count_matches(self, item):
-        """ Check the selected face exits """
-        image_name, number_alignments = item[0], item[2]
-        number_faces = len(self.faces.items.get(image_name, list()))
-        return bool(number_alignments == 0
-                    or number_alignments == number_faces)
-
-    def remove_alignment(self, item):
-        """ Remove the alignment from the alignments file """
-        del_count = 0
-        image_name, alignments, number_alignments = item
-        processor = self.alignments.get_one_alignment_index_reverse
-        for idx in processor(alignments, number_alignments):
-            face_indexes = self.faces.items.get(image_name, [-1])
-            if idx not in face_indexes:
-                del alignments[idx]
-                self.removed.add(image_name)
-                if self.verbose:
-                    print("Removed alignment data for image:{} "
-                          "index: {}".format(image_name, str(idx)))
-                del_count += 1
-        return del_count
-
-    def rename_faces(self):
-        """ Rename the aligned faces to match their "
-            new index in alignments file """
-        current_image = ""
-        current_index = 0
-        rename_count = 0
-        for item in tqdm(self.faces.file_list_sorted,
-                         desc="Renaming aligned faces",
-                         total=self.faces.count):
-            filename, extension, original_file, index = item
-            if original_file not in self.removed:
-                continue
-            current_index, current_image = self.set_image_index(current_index,
-                                                                current_image,
-                                                                original_file)
-            if current_index != index:
-                rename_count += self.rename_file(filename,
-                                                 extension,
-                                                 current_image,
-                                                 current_index)
-
-            current_index += 1
-        if rename_count == 0:
-            print("No files were renamed. Exiting")
-            return
-        print("{} face(s) were renamed to match with "
-              "alignments file".format(rename_count))
-
-    @staticmethod
-    def set_image_index(index, current, original):
-        """ Set the current processing image and index """
-        idx = 0 if current != original else index
-        return idx, original
-
-    def rename_file(self, filename, extension, image, index):
-        """ Rename the selected file """
-        old_file = filename + extension
-        new_file = "{}_{}{}".format(image, str(index), extension)
-        src = os.path.join(self.faces.folder, old_file)
-        dst = os.path.join(self.faces.folder, new_file)
-        os.rename(src, dst)
-        if self.verbose:
-            print("Renamed {} to {}".format(src, dst))
-        return 1
-
-
-class Check():
-    """ Frames and faces checking tasks """
-    def __init__(self, alignments, arguments):
-        self.alignments_data = alignments.count_per_frame
-        self.job = arguments.job
-        self.type = None
-        self.output = arguments.output
-        self.source_dir = self.get_source_dir(arguments)
-        self.items = self.get_items(arguments)
-
-        self.items_output = []
-        self.items_discovered = 0
-        self.output_message = ""
-
-    def get_source_dir(self, arguments):
-        """ Set the correct source dir """
-        if hasattr(arguments, "faces_dir") and arguments.faces_dir:
-            self.type = "faces"
-            source_dir = arguments.faces_dir
-        elif hasattr(arguments, "frames_dir") and arguments.frames_dir:
-            self.type = "frames"
-            source_dir = arguments.frames_dir
-        else:
-            print("No source folder (-fr or -fc) was provided")
-            exit(0)
-        return source_dir
-
-    def get_items(self, arguments):
-        """ Set the correct items to process """
-        items = Frames
-        if self.type == "faces":
-            items = Faces
-        return items(self.source_dir, arguments.verbose).file_list_sorted
-
-    def process(self):
-        """ Process the frames check against the alignments file """
-        print("\n[CHECK {}]".format(self.type.upper()))
-        self.validate()
-        self.compile_output()
-        self.output_results()
-
-    def validate(self):
-        """ Check that the selected type is valid for
-            selected task and job """
-        if self.job == "missing-frames" and self.output == "move":
-            print("WARNING: missing_frames was selected with move output, but "
-                  "there will be nothing to move. "
-                  "Defaulting to output: console")
-            self.output = "console"
-        elif self.type == "faces" and self.job not in ("multi-faces",
-                                                       "leftover-faces"):
-            print("WARNING: The selected folder is not valid. "
-                  "Only folder set with '-fc' is supported for "
-                  "'multi-faces' and 'leftover-faces'")
-            exit(0)
-
-    def compile_output(self):
-        """ Compile list of frames that meet criteria """
-        action = self.job.replace("-", "_")
-        processor = getattr(self, "get_{}".format(action))
-        self.items_output = [item for item in processor()]
-
-    def get_no_faces(self):
-        """ yield each frame that has no face match in alignments file """
-        self.output_message = "Frames with no faces"
-        for item in self.items:
-            if self.alignments_data.get(item, -1) == 0:
-                yield item
-
-    def get_multi_faces(self):
-        """ yield each frame that has multiple faces
-            matched in alignments file """
-        self.output_message = "Frames with multiple faces"
-        items = self.items
-        if self.type == "faces":
-            self.output_message = "Multiple faces in frame"
-        for item in items:
-            check_item = item
-            return_item = item
-            if self.type == "faces":
-                check_item = str(item[2]) + str(item[1])
-                return_item = str(item[0]) + str(item[1])
-            if self.alignments_data.get(check_item, -1) > 1:
-                yield return_item
-
-    def get_missing_alignments(self):
-        """ yield each frame that does not exist in alignments file """
-        self.output_message = "Frames missing from alignments file"
-        exclude_filetypes = ["yaml", "yml", "p", "json", "txt"]
-        for item in self.items:
-            extension = item[item.rindex(".") + 1:]
-            if (extension not in exclude_filetypes
-                    and self.alignments_data.get(item, -1)) == -1:
-                yield item
-
-    def get_missing_frames(self):
-        """ yield each frame in alignments that does
-            not have a matching file """
-        self.output_message = "Missing frames that are in alignments file"
-        for item in self.alignments_data.keys():
-            if item not in self.items:
-                yield item
-
-    def get_leftover_faces(self):
-        """yield each face that isn't in the alignments file."""
-        self.output_message = "Faces missing from the alignments file"
-        for item in self.items:
-            frame_id = item[2] + item[1]
-
-            if (frame_id not in self.alignments_data
-                    or self.alignments_data[frame_id] <= item[3]):
-                yield item[0] + item[1]
-
-    def output_results(self):
-        """ Output the results in the requested format """
-        self.items_discovered = len(self.items_output)
-        if self.items_discovered == 0:
-            print("No {} were found meeting the criteria".format(self.type))
-            return
-        if self.output == "move":
-            self.move_file()
-            return
-        output_message = "-----------------------------------------------\r\n"
-        output_message += " {} ({})\r\n".format(self.output_message,
-                                                self.items_discovered)
-        output_message += "-----------------------------------------------\r\n"
-        output_message += "\r\n".join([frame for frame in self.items_output])
-        if self.output == "console":
-            print("\n" + output_message)
-        if self.output == "file":
-            self.output_file(output_message)
-
-    def output_file(self, output_message):
-        """ Save the output to a text file in the frames directory """
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        filename = self.output_message.replace(" ", "_").lower()
-        filename += "_" + now + ".txt"
-        output_file = os.path.join(self.source_dir, filename)
-        print("Saving {} result(s) to {}".format(self.items_discovered,
-                                                 output_file))
-        with open(output_file, "w") as f_output:
-            f_output.write(output_message)
-
-    def move_file(self):
-        """ Move the identified frames to a new subfolder """
-        now = datetime.now().strftime("%Y%m%d_%H%M%S")
-        folder_name = self.output_message.replace(" ", "_").lower()
-        folder_name += "_" + now
-        output_folder = os.path.join(self.source_dir, folder_name)
-        os.makedirs(output_folder)
-        move = getattr(self, "move_{}".format(self.type))
-        move(output_folder)
-
-    def move_frames(self, output_folder):
-        """ Move frames into single subfolder """
-        print("Moving {} frame(s) to {}".format(self.items_discovered,
-                                                output_folder))
-        for frame in self.items_output:
-            src = os.path.join(self.source_dir, frame)
-            dst = os.path.join(output_folder, frame)
-            os.rename(src, dst)
-
-    def move_faces(self, output_folder):
-        """ Make additional subdirs for each face that appears
-            Enables easier manual sorting """
-        print("Moving {} faces(s) to {}".format(self.items_discovered,
-                                                output_folder))
-        for frame in self.items_output:
-            idx = frame[frame.rfind("_") + 1:frame.rfind(".")]
-            src = os.path.join(self.source_dir, frame)
-            dst_folder = os.path.join(output_folder, idx)
-            if not os.path.isdir(dst_folder):
-                os.makedirs(dst_folder)
-            dst = os.path.join(dst_folder, frame)
-            os.rename(src, dst)
+            job = globals()[self.args.job.title()]
+        job = job(self.alignments, self.args)
+        job.process()
diff --git a/tools/cli.py b/tools/cli.py
index 0a12e95..69944ed 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -12,70 +12,85 @@ class AlignmentsArgs(FaceSwapArgs):
     def get_argument_list(self):
         frames_dir = "\n\tMust Pass in a frames folder (-fr)."
         faces_dir = "\n\tMust Pass in a faces folder (-fc)."
-        frames_or_faces_dir = ("\n\tMust Pass in either a frames folder \n\t"
-                               "OR a faces folder (-fr or -fc).")
-        frames_and_faces_dir = ("\n\tMust Pass in a frames folder AND a\n\t"
-                                "faces folder (-fr and -fc).")
+        frames_or_faces_dir = ("\n\tMust Pass in either a frames folder"
+                               "\n\tOR a faces folder (-fr or -fc).")
+        frames_and_faces_dir = ("\n\tMust Pass in a frames folder AND a faces"
+                                "\n\tfolder (-fr and -fc).")
         output_opts = "\n\tUse the output option (-o) to process\n\tresults."
+        align_eyes = "\n\tCan optionally use the align-eyes switch (-ae)."
         argument_list = list()
-        argument_list.append({"opts": ("-j", "--job"),
-                              "type": str,
-                              "choices": ("draw", "extract",
-                                          "missing-alignments",
-                                          "missing-frames", "leftover-faces",
-                                          "multi-faces", "no-faces",
-                                          "reformat", "remove"),
-                              "required": True,
-                              "help": "R|Choose which action you want to "
-                                      "perform.\nNB: All actions require an "
-                                      "alignments file (-a) to\nbe passed "
-                                      "in.\n"
-                                      "'draw': Draw landmarks on frames in "
-                                      "the selected\n\tfolder. A subfolder "
-                                      "will be created within\n\tthe frames "
-                                      "folder to hold the output." +
-                                      frames_dir + "\n"
-                                      "'extract': Re-extract faces from the "
-                                      "source frames\n\tbased on alignment "
-                                      "data. This is a\n\tlot quicker than "
-                                      "re-detecting faces. Can\n\toptionally "
-                                      "use the align-eyes switch (-ae)." +
-                                      frames_and_faces_dir + "\n"
-                                      "'missing-alignments': Identify frames "
-                                      "that do not\n\texist in the "
-                                      "alignments file." + output_opts +
-                                      frames_dir + "\n"
-                                      "'missing-frames': Identify frames in "
-                                      "the alignments\n\tfile that do not "
-                                      "appear within the frames\n\t"
-                                      "folder." + output_opts +
-                                      frames_dir + "\n" +
-                                      "'leftover-faces': Identify faces in "
-                                      "the faces folder\n\tthat do not exist "
-                                      "in the alignments file." + output_opts +
-                                      faces_dir + "\n"
-                                      "'multi-faces': Identify where multiple "
-                                      "faces exist\n\twithin the alignments "
-                                      "file." + output_opts +
-                                      frames_or_faces_dir + "\n"
-                                      "'no-faces': Identify frames that exist "
-                                      "within the\n\talignment file but no "
-                                      "faces were detected." + output_opts +
-                                      frames_dir + "\n"
-                                      "'reformat': Save a copy of alignments "
-                                      "file in a\n\tdifferent format. "
-                                      "Specify a format with\n\tthe -fmt "
-                                      "option.\n\tAlignments can be "
-                                      "converted from\n\tDeepFaceLab by "
-                                      "specifing:\n\t    -a dfl\n\t    -fc "
-                                      "<source faces folder>\n"
-                                      "'remove': Remove deleted faces from "
-                                      "an alignments\n\tfile. The original "
-                                      "alignments file will be\n\tbacked up. "
-                                      "A different file format for the\n\t"
-                                      "alignments file can optionally be\n\t"
-                                      "specified (-fmt).\n\tMust pass in a "
-                                      "faces folder (-fc).\n"})
+        argument_list.append({
+            "opts": ("-j", "--job"),
+            "type": str,
+            "choices": ("draw", "extract", "manual",
+                        "missing-alignments", "missing-frames",
+                        "leftover-faces", "multi-faces", "no-faces",
+                        "reformat", "remove-faces", "remove-frames",
+                        "rotate", "sort-x", "sort-y"),
+            "required": True,
+            "help": "R|Choose which action you want to perform.\n"
+                    "NB: All actions require an alignments file (-a) to"
+                    "\nbe passed in."
+                    "\n'draw': Draw landmarks on frames in the selected"
+                    "\n\tfolder. A subfolder will be created within"
+                    "\n\tthe frames folder to hold the output." +
+                    frames_dir + align_eyes +
+                    "\n'extract': Re-extract faces from the source frames"
+                    "\n\tbased on alignment data. This is a"
+                    "\n\tlot quicker than re-detecting faces." +
+                    frames_and_faces_dir + align_eyes +
+                    "\n'manual': Manually view and edit landmarks." +
+                    frames_dir + align_eyes +
+                    "\n'missing-alignments': Identify frames that do not"
+                    "\n\texist in the alignments file." + output_opts +
+                    frames_dir +
+                    "\n'missing-frames': Identify frames in the alignments"
+                    "\n\tfile that do not appear within the frames"
+                    "\n\tfolder." + output_opts + frames_dir +
+                    "\n'leftover-faces': Identify faces in the faces"
+                    "\n\tfolder that do not exist in the alignments file."
+                    + output_opts + faces_dir +
+                    "\n'multi-faces': Identify where multiple faces exist"
+                    "\n\twithin the alignments file." + output_opts +
+                    frames_or_faces_dir +
+                    "\n'no-faces': Identify frames that exist within the"
+                    "\n\talignment file but no faces were detected." +
+                    output_opts + frames_dir +
+                    "\n'reformat': Save a copy of alignments file in a"
+                    "\n\tdifferent format. Specify a format with"
+                    "\n\tthe -fmt option."
+                    "\n\tAlignments can be converted from"
+                    "\n\tDeepFaceLab by specifing:"
+                    "\n\t    -a dfl"
+                    "\n\t    -fc <source faces folder>"
+                    "\n'remove-faces': Remove deleted faces from an"
+                    "\n\talignments file. The original alignments file"
+                    "\n\t will be backed up. A different file format or"
+                    "\n\tthe alignments file can optionally be specified"
+                    "\n\t(-fmt)." + faces_dir +
+                    "\n'remove-frames': Remove deleted frames from an"
+                    "\n\talignments file. The original alignments file"
+                    "\n\twill be backed up. A different file format for"
+                    "\n\tthe alignments file can optionally be specified"
+                    "\n\t(-fmt)." + frames_dir +
+                    "\n'rotate' - Rotate landmarks and bounding boxes. Legacy"
+                    "\n\talignments files hold an 'r' parameter indicating"
+                    "\n\tthat the image needs to be rotated for convert. This"
+                    "\n\tmeans that the stored landarks and bounding box do"
+                    "\n\tnot correspond to the actual frame. This command"
+                    "\n\tupdates the alignments file with the correct"
+                    "\n\tlandmarks and bounding boxes and removes the 'r'"
+                    "\n\tparameter." + frames_dir +
+                    "\n'sort-x' - Re-index the alignments from left to"
+                    "\n\tright. For alignments with multiple faces this will"
+                    "\n\tensure that the left-most face is at index 0"
+                    "\n\tOptionally pass in a faces folder (-fc) to also"
+                    "\n\trename extracted faces."
+                    "\n'sort-y' - Re-index the alignments from top to"
+                    "\n\tbottom. For alignments with multiple faces this will"
+                    "\n\tensure that the top-most face is at index 0"
+                    "\n\tOptionally pass in a faces folder (-fc) to also"
+                    "\n\trename extracted faces."})
         argument_list.append({"opts": ("-a", "--alignments_file"),
                               "action": FileFullPaths,
                               "dest": "alignments_file",
@@ -97,27 +112,27 @@ class AlignmentsArgs(FaceSwapArgs):
                               "choices": ("json", "pickle", "yaml"),
                               "help": "The file format to save the alignment "
                                       "data in. Defaults to same as source."})
-        argument_list.append({"opts": ("-o", "--output"),
-                              "type": str,
-                              "choices": ("console", "file", "move"),
-                              "default": "console",
-                              "help": "R|How to output discovered items "
-                                      "('faces'\nand 'frames' only):\n"
-                                      "'console': Print the list of frames to "
-                                      "the screen.\n\t(DEFAULT)\n"
-                                      "'file': Output the list of frames to a "
-                                      "text file\n\t(stored within the source "
-                                      "directory).\n"
-                                      "'move': Move the discovered items to a "
-                                      "sub-folder\n\twithin the source "
-                                      "directory."})
+        argument_list.append({
+            "opts": ("-o", "--output"),
+            "type": str,
+            "choices": ("console", "file", "move"),
+            "default": "console",
+            "help": "R|How to output discovered items ('faces' and"
+                    "\n'frames' only):"
+                    "\n'console': Print the list of frames to the screen."
+                    "\n\t(DEFAULT)"
+                    "\n'file': Output the list of frames to a text file"
+                    "\n\t(stored within the source directory)."
+                    "\n'move': Move the discovered items to a sub-folder"
+                    "\n\twithin the source directory."})
         argument_list.append({"opts": ("-ae", "--align-eyes"),
                               "action": "store_true",
                               "dest": "align_eyes",
                               "default": False,
                               "help": "Perform extra alignment to ensure "
                                       "left/right eyes are  at the same "
-                                      "height. (Extract only)"})
+                                      "height. (Draw, Extract and manual "
+                                      "only)"})
         argument_list.append({"opts": ("-v", "--verbose"),
                               "action": "store_true",
                               "dest": "verbose",
diff --git a/tools/lib_alignments/__init__.py b/tools/lib_alignments/__init__.py
new file mode 100644
index 0000000..4038683
--- /dev/null
+++ b/tools/lib_alignments/__init__.py
@@ -0,0 +1,4 @@
+from tools.lib_alignments.media import AlignmentData, ExtractedFaces, Faces, Frames
+from tools.lib_alignments.annotate import Annotate
+from tools.lib_alignments.jobs import Check, Draw, Extract, Reformat, RemoveAlignments, Rotate, Sort
+from tools.lib_alignments.jobs_manual import Manual
diff --git a/tools/lib_alignments/annotate.py b/tools/lib_alignments/annotate.py
new file mode 100644
index 0000000..654a216
--- /dev/null
+++ b/tools/lib_alignments/annotate.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+""" Tools for annotating an input image """
+# TODO Handle landmark rotation
+
+from cv2 import (rectangle, circle, polylines, putText,
+                 FONT_HERSHEY_DUPLEX, fillPoly, addWeighted)
+from numpy import array, int32, uint8, zeros
+
+from lib.align_eyes import FACIAL_LANDMARKS_IDXS
+
+
+class Annotate():
+    """ Annotate an input image """
+
+    def __init__(self, image, alignments, original_roi=None):
+        self.image = image
+        self.alignments = alignments
+        self.roi = original_roi
+        self.colors = {1: (255, 0, 0),
+                       2: (0, 255, 0),
+                       3: (0, 0, 255),
+                       4: (255, 255, 0),
+                       5: (255, 0, 255),
+                       6: (0, 255, 255)}
+
+    def draw_black_image(self):
+        """ Change image to black at correct dimensions """
+        height, width = self.image.shape[:2]
+        self.image = zeros((height, width, 3), uint8)
+
+    def draw_bounding_box(self, color_id=1, thickness=1):
+        """ Draw the bounding box around faces """
+        color = self.colors[color_id]
+        for alignment in self.alignments:
+            top_left = (alignment["x"], alignment["y"])
+            bottom_right = (alignment["x"] + alignment["w"],
+                            alignment["y"] + alignment["h"])
+            rectangle(self.image, top_left, bottom_right,
+                      color, thickness)
+
+    def draw_extract_box(self, color_id=2, thickness=1):
+        """ Draw the extracted face box """
+        if not self.roi:
+            return
+        color = self.colors[color_id]
+        for idx, roi in enumerate(self.roi):
+            top_left = [point for point in roi[0].squeeze()[0]]
+            top_left = (top_left[0], top_left[1] - 10)
+            putText(self.image, str(idx), top_left, FONT_HERSHEY_DUPLEX, 1.0,
+                    color, thickness)
+            polylines(self.image, roi, True, color, thickness)
+
+    def draw_landmarks(self, color_id=3, radius=1):
+        """ Draw the facial landmarks """
+        color = self.colors[color_id]
+        for alignment in self.alignments:
+            landmarks = alignment["landmarksXY"]
+            for (pos_x, pos_y) in landmarks:
+                circle(self.image, (pos_x, pos_y), radius, color, -1)
+
+    def draw_landmarks_mesh(self, color_id=4, thickness=1):
+        """ Draw the facial landmarks """
+        color = self.colors[color_id]
+        for alignment in self.alignments:
+            landmarks = alignment["landmarksXY"]
+            for key, val in FACIAL_LANDMARKS_IDXS.items():
+                points = array([landmarks[val[0]:val[1]]], int32)
+                fill_poly = bool(key in ("right_eye", "left_eye", "mouth"))
+                polylines(self.image, points, fill_poly, color, thickness)
+
+    def draw_grey_out_faces(self, live_face):
+        """ Grey out all faces except target """
+        if not self.roi:
+            return
+        alpha = 0.6
+        overlay = self.image.copy()
+        for idx, roi in enumerate(self.roi):
+            if idx != int(live_face):
+                fillPoly(overlay, roi, (0, 0, 0))
+        addWeighted(overlay, alpha, self.image, 1 - alpha, 0, self.image)
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
new file mode 100644
index 0000000..ef9c7ae
--- /dev/null
+++ b/tools/lib_alignments/jobs.py
@@ -0,0 +1,651 @@
+#!/usr/bin/env python3
+""" Tools for manipulating the alignments seralized file """
+
+import os
+import pickle
+import struct
+from datetime import datetime
+
+from tqdm import tqdm
+
+from . import Annotate, ExtractedFaces, Faces, Frames
+
+
+class Check():
+    """ Frames and faces checking tasks """
+    def __init__(self, alignments, arguments):
+        self.alignments = alignments
+        self.job = arguments.job
+        self.type = None
+        self.output = arguments.output
+        self.source_dir = self.get_source_dir(arguments)
+        self.items = self.get_items(arguments)
+
+        self.output_message = ""
+
+    def get_source_dir(self, arguments):
+        """ Set the correct source dir """
+        if hasattr(arguments, "faces_dir") and arguments.faces_dir:
+            self.type = "faces"
+            source_dir = arguments.faces_dir
+        elif hasattr(arguments, "frames_dir") and arguments.frames_dir:
+            self.type = "frames"
+            source_dir = arguments.frames_dir
+        else:
+            print("No source folder (-fr or -fc) was provided")
+            exit(0)
+        return source_dir
+
+    def get_items(self, arguments):
+        """ Set the correct items to process """
+        items = globals()[self.type.title()]
+        return items(self.source_dir, arguments.verbose).file_list_sorted
+
+    def process(self):
+        """ Process the frames check against the alignments file """
+        print("\n[CHECK {}]".format(self.type.upper()))
+        self.validate()
+        items_output = self.compile_output()
+        self.output_results(items_output)
+
+    def validate(self):
+        """ Check that the selected type is valid for
+            selected task and job """
+        if self.job == "missing-frames" and self.output == "move":
+            print("WARNING: missing_frames was selected with move output, but "
+                  "there will be nothing to move. "
+                  "Defaulting to output: console")
+            self.output = "console"
+        elif self.type == "faces" and self.job not in ("multi-faces",
+                                                       "leftover-faces"):
+            print("WARNING: The selected folder is not valid. "
+                  "Only folder set with '-fc' is supported for "
+                  "'multi-faces' and 'leftover-faces'")
+            exit(0)
+
+    def compile_output(self):
+        """ Compile list of frames that meet criteria """
+        action = self.job.replace("-", "_")
+        processor = getattr(self, "get_{}".format(action))
+        return [item for item in processor()]
+
+    def get_no_faces(self):
+        """ yield each frame that has no face match in alignments file """
+        self.output_message = "Frames with no faces"
+        for frame in self.items:
+            frame_name = frame["frame_fullname"]
+            if not self.alignments.frame_has_faces(frame_name):
+                yield frame_name
+
+    def get_multi_faces(self):
+        """ yield each frame that has multiple faces
+            matched in alignments file """
+        if self.type == "faces":
+            self.output_message = "Multiple faces in frame"
+            frame_key = "frame_name"
+            retval_key = "face_fullname"
+        elif self.type == "frames":
+            self.output_message = "Frames with multiple faces"
+            frame_key = "frame_fullname"
+            retval_key = "frame_fullname"
+
+        for item in self.items:
+            frame = item[frame_key]
+            if self.type == "faces":
+                frame = self.alignments.get_full_frame_name(frame)
+            retval = item[retval_key]
+
+            if self.alignments.frame_has_multiple_faces(frame):
+                yield retval
+
+    def get_missing_alignments(self):
+        """ yield each frame that does not exist in alignments file """
+        self.output_message = "Frames missing from alignments file"
+        exclude_filetypes = ["yaml", "yml", "p", "json", "txt"]
+        for frame in self.items:
+            frame_name = frame["frame_fullname"]
+            if (frame["frame_extension"] not in exclude_filetypes
+                    and not self.alignments.frame_in_alignments(frame_name)):
+                yield frame_name
+
+    def get_missing_frames(self):
+        """ yield each frame in alignments that does
+            not have a matching file """
+        self.output_message = "Missing frames that are in alignments file"
+        frames = [item["frame_fullname"] for item in self.items]
+        for frame in self.alignments.alignments.keys():
+            if frame not in frames:
+                yield frame
+
+    def get_leftover_faces(self):
+        """yield each face that isn't in the alignments file."""
+        self.output_message = "Faces missing from the alignments file"
+        for face in self.items:
+            frame = self.alignments.get_full_frame_name(face["frame_name"])
+            alignment_faces = self.alignments.count_alignments_in_frame(frame)
+
+            if alignment_faces <= face["face_index"]:
+                yield face["face_fullname"]
+
+    def output_results(self, items_output):
+        """ Output the results in the requested format """
+        if not items_output:
+            print("No {} were found meeting the criteria".format(self.type))
+            return
+        if self.output == "move":
+            self.move_file(items_output)
+            return
+        output_message = "-----------------------------------------------\r\n"
+        output_message += " {} ({})\r\n".format(self.output_message,
+                                                len(items_output))
+        output_message += "-----------------------------------------------\r\n"
+        output_message += "\r\n".join([frame for frame in items_output])
+        if self.output == "console":
+            print("\n" + output_message)
+        if self.output == "file":
+            self.output_file(output_message, len(items_output))
+
+    def output_file(self, output_message, items_discovered):
+        """ Save the output to a text file in the frames directory """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        filename = self.output_message.replace(" ", "_").lower()
+        filename += "_" + now + ".txt"
+        output_file = os.path.join(self.source_dir, filename)
+        print("Saving {} result(s) to {}".format(items_discovered,
+                                                 output_file))
+        with open(output_file, "w") as f_output:
+            f_output.write(output_message)
+
+    def move_file(self, items_output):
+        """ Move the identified frames to a new subfolder """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        folder_name = self.output_message.replace(" ", "_").lower()
+        folder_name += "_" + now
+        output_folder = os.path.join(self.source_dir, folder_name)
+        os.makedirs(output_folder)
+        move = getattr(self, "move_{}".format(self.type))
+        move(output_folder, items_output)
+
+    def move_frames(self, output_folder, items_output):
+        """ Move frames into single subfolder """
+        print("Moving {} frame(s) to {}".format(len(items_output),
+                                                output_folder))
+        for frame in items_output:
+            src = os.path.join(self.source_dir, frame)
+            dst = os.path.join(output_folder, frame)
+            os.rename(src, dst)
+
+    def move_faces(self, output_folder, items_output):
+        """ Make additional subdirs for each face that appears
+            Enables easier manual sorting """
+        print("Moving {} faces(s) to {}".format(len(items_output),
+                                                output_folder))
+        for frame in items_output:
+            idx = frame[frame.rfind("_") + 1:frame.rfind(".")]
+            src = os.path.join(self.source_dir, frame)
+            dst_folder = os.path.join(output_folder, idx)
+            if not os.path.isdir(dst_folder):
+                os.makedirs(dst_folder)
+            dst = os.path.join(dst_folder, frame)
+            os.rename(src, dst)
+
+
+class Draw():
+    """ Draw Alignments on passed in images """
+    def __init__(self, alignments, arguments):
+        self.arguments = arguments
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.frames = Frames(arguments.frames_dir, self.verbose)
+        self.output_folder = self.set_output()
+        self.extracted_faces = None
+
+    def set_output(self):
+        """ Set the output folder path """
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        folder_name = "drawn_landmarks_{}".format(now)
+        output_folder = os.path.join(self.frames.folder, folder_name)
+        os.makedirs(output_folder)
+        return output_folder
+
+    def process(self):
+        """ Run the draw alignments process """
+        rotate = Rotate(self.alignments, self.arguments,
+                        frames=self.frames, child_process=True)
+        rotate.process()
+
+        print("\n[DRAW LANDMARKS]")  # Tidy up cli output
+        self.extracted_faces = ExtractedFaces(
+            self.frames,
+            self.alignments,
+            align_eyes=self.arguments.align_eyes)
+        frames_drawn = 0
+        for frame in tqdm(self.frames.file_list_sorted,
+                          desc="Drawing landmarks"):
+
+            frame_name = frame["frame_fullname"]
+
+            if not self.alignments.frame_in_alignments(frame_name):
+                if self.verbose:
+                    print("Skipping {} - Alignments "
+                          "not found".format(frame_name))
+                continue
+
+            self.annotate_image(frame_name)
+            frames_drawn += 1
+        print("{} Frame(s) output".format(frames_drawn))
+
+    def annotate_image(self, frame):
+        """ Draw the alignments """
+        alignments = self.alignments.get_alignments_for_frame(frame)
+        image = self.frames.load_image(frame)
+        original_roi = self.extracted_faces.get_roi_for_frame(frame)
+
+        annotate = Annotate(image, alignments, original_roi)
+        annotate.draw_bounding_box(1, 1)
+        annotate.draw_extract_box(2, 1)
+        annotate.draw_landmarks(3, 1)
+        annotate.draw_landmarks_mesh(4, 1)
+
+        image = annotate.image
+        self.frames.save_image(self.output_folder, frame, image)
+
+
+class Extract():
+    """ Re-extract faces from source frames based on
+        Alignment data """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.faces_dir = arguments.faces_dir
+        self.frames = Frames(arguments.frames_dir, self.verbose)
+        self.extracted_faces = ExtractedFaces(self.frames,
+                                              self.alignments,
+                                              align_eyes=arguments.align_eyes)
+
+    def process(self):
+        """ Run extraction """
+        print("\n[EXTRACT FACES]")  # Tidy up cli output
+        self.check_folder()
+        self.export_faces()
+
+    def check_folder(self):
+        """ Check that the faces folder doesn't pre-exist
+            and create """
+        err = None
+        if not self.faces_dir:
+            err = "ERROR: Output faces folder not provided."
+        elif os.path.isdir(self.faces_dir):
+            err = "ERROR: Folder already exists at {}".format(self.faces_dir)
+        if err:
+            print(err)
+            exit(0)
+        if self.verbose:
+            print("Creating output folder at {}".format(self.faces_dir))
+        os.makedirs(self.faces_dir)
+
+    def export_faces(self):
+        """ Export the faces """
+        extracted_faces = 0
+
+        for frame in tqdm(self.frames.file_list_sorted,
+                          desc="Saving extracted faces"):
+
+            frame_name = frame["frame_fullname"]
+
+            if not self.alignments.frame_in_alignments(frame_name):
+                if self.verbose:
+                    print("Skipping {} - Alignments "
+                          "not found".format(frame_name))
+                continue
+            extracted_faces += self.output_faces(frame)
+
+        print("{} face(s) extracted".format(extracted_faces))
+
+    def output_faces(self, frame):
+        """ Output the frame's faces to file """
+        face_count = 0
+        frame_fullname = frame["frame_fullname"]
+        frame_name = frame["frame_name"]
+        faces = self.extracted_faces.get_faces_for_frame(frame_fullname)
+        for idx, face in enumerate(faces):
+            output = "{}_{}{}".format(frame_name, str(idx), ".png")
+            self.frames.save_image(self.faces_dir, output, face)
+            face_count += 1
+        return face_count
+
+
+class Reformat():
+    """ Reformat Alignment file """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        if self.alignments.src_format == "dfl":
+            self.faces = Faces(arguments.faces_dir,
+                               self.verbose)
+
+    def process(self):
+        """ Run reformat """
+        print("\n[REFORMAT ALIGNMENTS]")  # Tidy up cli output
+        if self.alignments.src_format == "dfl":
+            self.alignments.alignments = self.load_dfl()
+            self.alignments.file = os.path.join(self.faces.folder,
+                                                "alignments.json")
+        self.alignments.save_alignments()
+
+    def load_dfl(self):
+        """ Load alignments from DeepFaceLab and format for Faceswap """
+        alignments = dict()
+        for face in self.faces.file_list_sorted:
+            if face["face_extension"] != ".png":
+                if self.verbose:
+                    print("{} is not a png. "
+                          "Skipping".format(face["face_fullname"]))
+                continue
+
+            fullpath = os.path.join(self.faces.folder, face["face_fullname"])
+            dfl = self.get_dfl_alignment(fullpath)
+
+            if not dfl:
+                continue
+
+            self.convert_dfl_alignment(dfl, alignments)
+        return alignments
+
+    @staticmethod
+    def get_dfl_alignment(filename):
+        """ Process the alignment of one face """
+        with open(filename, "rb") as dfl:
+            header = dfl.read(8)
+            if header != b"\x89PNG\r\n\x1a\n":
+                print("ERROR: No Valid PNG header: {}".format(filename))
+                return None
+            while True:
+                chunk_start = dfl.tell()
+                chunk_hdr = dfl.read(8)
+                if not chunk_hdr:
+                    break
+                chunk_length, chunk_name = struct.unpack("!I4s", chunk_hdr)
+                dfl.seek(chunk_start, os.SEEK_SET)
+                if chunk_name == b"fcWp":
+                    chunk = dfl.read(chunk_length + 12)
+                    return pickle.loads(chunk[8:-4])
+                else:
+                    dfl.seek(chunk_length+12, os.SEEK_CUR)
+            print("ERROR: Couldn't find DFL alignments: {}".format(filename))
+
+    @staticmethod
+    def convert_dfl_alignment(dfl_alignments, alignments):
+        """ Add DFL Alignments to alignments in Faceswap format """
+        sourcefile = dfl_alignments["source_filename"]
+        if not alignments.get(sourcefile, None):
+            alignments[sourcefile] = list()
+
+        left, top, right, bottom = dfl_alignments["source_rect"]
+        alignment = {"x": left,
+                     "w": right - left,
+                     "y": top,
+                     "h": bottom - top,
+                     "landmarksXY": dfl_alignments["source_landmarks"]}
+
+        alignments[sourcefile].append(alignment)
+
+
+class RemoveAlignments():
+    """ Remove items from alignments file """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.type = arguments.job.replace("remove-", "")
+        self.items = self.get_items(arguments)
+        self.removed = set()
+
+    def get_items(self, arguments):
+        """ Set the correct items to process """
+        retval = None
+        if self.type == "frames":
+            retval = list(Frames(arguments.frames_dir,
+                                 self.verbose).items.keys())
+        elif self.type == "faces":
+            retval = Faces(arguments.faces_dir, self.verbose)
+        return retval
+
+    def process(self):
+        """ run removal """
+        print("\n[REMOVE ALIGNMENTS DATA]")  # Tidy up cli output
+        del_count = 0
+
+        iterator = self.alignments.get_alignments_one_image
+        if self.type == "frames":
+            iterator = list(item[3] for item in iterator())
+
+        for item in tqdm(iterator() if self.type == "faces" else iterator,
+                         desc="Processing alignments file",
+                         total=self.alignments.count):
+            task = getattr(self, "remove_{}".format(self.type))
+            del_count += task(item)
+
+        if del_count == 0:
+            print("No changes made to alignments file. Exiting")
+            return
+
+        print("{} alignment(s) were removed from "
+              "alignments file".format(del_count))
+        self.alignments.save_alignments()
+
+        if self.type == "faces":
+            self.rename_faces()
+
+    def remove_frames(self, item):
+        """ Process to remove frames from an alignments file """
+        if item in self.items:
+            return 0
+        del self.alignments.alignments[item]
+        return 1
+
+    def remove_faces(self, item):
+        """ Process to remove faces from an alignments file """
+        if self.faces_count_matches(item):
+            return 0
+        return self.remove_alignment(item)
+
+    def faces_count_matches(self, item):
+        """ Check the selected face exits """
+        frame_name, number_alignments = item[0], item[2]
+        number_faces = len(self.items.items.get(frame_name, list()))
+        return bool(number_alignments == 0
+                    or number_alignments == number_faces)
+
+    def remove_alignment(self, item):
+        """ Remove the alignment from the alignments file """
+        del_count = 0
+        frame_name, alignments, number_alignments = item[:3]
+        processor = self.alignments.get_one_alignment_index_reverse
+        for idx in processor(alignments, number_alignments):
+            face_indexes = self.items.items.get(frame_name, [-1])
+            if idx not in face_indexes:
+                del alignments[idx]
+                self.removed.add(frame_name)
+                if self.verbose:
+                    print("Removed alignment data for image:{} "
+                          "index: {}".format(frame_name, str(idx)))
+                del_count += 1
+        return del_count
+
+    def rename_faces(self):
+        """ Rename the aligned faces to match their "
+            new index in alignments file """
+        current_frame = ""
+        current_index = 0
+        rename_count = 0
+        for face in tqdm(self.items.file_list_sorted,
+                         desc="Renaming aligned faces",
+                         total=self.items.count):
+
+            if face["frame_name"] not in self.removed:
+                continue
+            current_index, current_frame = self.set_image_index(
+                current_index,
+                current_frame,
+                face["frame_name"])
+            if current_index != face["face_index"]:
+                rename_count += self.rename_file(face,
+                                                 current_frame,
+                                                 current_index)
+
+            current_index += 1
+        if rename_count == 0:
+            print("No files were renamed. Exiting")
+            return
+        print("{} face(s) were renamed to match with "
+              "alignments file".format(rename_count))
+
+    @staticmethod
+    def set_image_index(index, current, original):
+        """ Set the current processing image and index """
+        idx = 0 if current != original else index
+        return idx, original
+
+    def rename_file(self, face, frame_name, index):
+        """ Rename the selected file """
+        old_file = face["face_name"] + face["face_extension"]
+        new_file = "{}_{}{}".format(frame_name,
+                                    str(index),
+                                    face["face_extension"])
+        src = os.path.join(self.items.folder, old_file)
+        dst = os.path.join(self.items.folder, new_file)
+        os.rename(src, dst)
+        if self.verbose:
+            print("Renamed {} to {}".format(src, dst))
+        return 1
+
+
+class Rotate():
+    """ Rotating landmarks and bounding boxes on legacy alignments
+        and remove the 'r' parameter """
+    def __init__(self, alignments, arguments,
+                 frames=None, child_process=False):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.child_process = child_process
+        self.frames = frames
+        if not frames:
+            self.frames = Frames(arguments.frames_dir, self.verbose)
+
+    def process(self):
+        """ Run the rotate alignments process """
+        rotated = self.alignments.get_rotated()
+        if not rotated and self.child_process:
+            return
+        print("\n[ROTATE LANDMARKS]")  # Tidy up cli output
+        if self.child_process:
+            print("Legacy rotated frames found. Rotating landmarks")
+        self.rotate_landmarks(rotated)
+        if not self.child_process:
+            self.alignments.save_alignments()
+
+    def rotate_landmarks(self, rotated):
+        """ Rotate the landmarks """
+        for rotate_item in tqdm(rotated,
+                                desc="Rotating Landmarks"):
+            if rotate_item not in self.frames.items.keys():
+                continue
+            dims = self.frames.load_image(rotate_item).shape[:2]
+            self.alignments.rotate_existing_landmarks(rotate_item, dims)
+
+
+class Sort():
+    """ Sort alignments' index by the order they appear in
+        an image """
+    def __init__(self, alignments, arguments):
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.axis = arguments.job.replace("sort-", "")
+        self.faces = self.get_faces(arguments)
+
+    def get_faces(self, arguments):
+        """ If faces argument is specified, load faces_dir
+            otherwise return None """
+        if not hasattr(arguments, "faces_dir") or not arguments.faces_dir:
+            return None
+        return Faces(arguments.faces_dir, self.verbose)
+
+    def process(self):
+        """ Execute the sort process """
+        print("\n[SORT INDEXES]")  # Tidy up cli output
+        self.check_rotated()
+        self.reindex_faces()
+        self.alignments.save_alignments()
+
+    def check_rotated(self):
+        """ Legacy rotated alignments will not have the correct x, y
+            positions, so generate a warning and exit """
+        if any(alignment.get("r", None)
+               for val in self.alignments.alignments.values()
+               for alignment in val):
+            print("WARNING: There are rotated frames in the alignments "
+                  "file.\n\t Position of faces will not be correctly "
+                  "calculated for these frames.\n\t You should run rotation "
+                  "tool to update the file prior to running sort:\n\t "
+                  "'python tools.py alignments -j rotate -a "
+                  "<alignments_file> -fr <frames_folder>'")
+            exit(0)
+
+    def reindex_faces(self):
+        """ Re-Index the faces """
+        reindexed = 0
+        for alignment in tqdm(self.alignments.get_alignments_one_image(),
+                              desc="Sort alignment indexes",
+                              total=self.alignments.count):
+            frame, alignments, count, key = alignment
+            if count <= 1:
+                continue
+            sorted_alignments = sorted([item for item in alignments],
+                                       key=lambda x: (x[self.axis]))
+            if sorted_alignments == alignments:
+                continue
+            map_faces = self.map_face_names(alignments,
+                                            sorted_alignments,
+                                            frame)
+            self.rename_faces(map_faces)
+            self.alignments.alignments[key] = sorted_alignments
+            reindexed += 1
+        print("{} Frames had their faces reindexed".format(reindexed))
+
+    def map_face_names(self, alignments, sorted_alignments, frame):
+        """ Map the old and new indexes for face renaming """
+        map_faces = list()
+        if not self.faces:
+            return map_faces
+        for idx, alignment in enumerate(alignments):
+            idx_new = sorted_alignments.index(alignment)
+            mapping = [{"old_name": face["face_fullname"],
+                        "new_name": "{}_{}{}".format(frame,
+                                                     idx_new,
+                                                     face["face_extension"])}
+                       for face in self.faces.file_list_sorted
+                       if face["frame_name"] == frame
+                       and face["face_index"] == idx]
+            if not mapping:
+                print("WARNING: No face image found "
+                      "for frame '{}' at index '{}'".format(frame, idx))
+            map_faces.extend(mapping)
+        return map_faces
+
+    def rename_faces(self, map_faces):
+        """ Rename faces
+            Done in 2 iterations as two files cannot share the same name """
+        temp_ext = ".temp_move"
+        for action in ("temp", "final"):
+            for face in map_faces:
+                old = face["old_name"]
+                new = face["new_name"]
+                if old == new:
+                    continue
+                old_file = old if action == "temp" else old + temp_ext
+                new_file = old + temp_ext if action == "temp" else new
+                src = os.path.join(self.faces.folder, old_file)
+                dst = os.path.join(self.faces.folder, new_file)
+                os.rename(src, dst)
+                if self.verbose and action == "final":
+                    print("Renamed {} to {}".format(old, new))
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
new file mode 100644
index 0000000..d09c1f1
--- /dev/null
+++ b/tools/lib_alignments/jobs_manual.py
@@ -0,0 +1,789 @@
+#!/usr/bin/env python3
+""" Manual processing of alignments """
+
+import cv2
+import numpy as np
+
+from lib.face_alignment import Extract
+from . import Annotate, ExtractedFaces, Frames, Rotate
+
+
+class Interface():
+    """ Key controls and interfacing options for OpenCV """
+    def __init__(self, alignments, frames):
+        self.alignments = alignments
+        self.frames = frames
+        self.controls = self.set_controls()
+        self.state = self.set_state()
+        self.skip_mode = {1: "Standard",
+                          2: "No Faces",
+                          3: "Multi-Faces",
+                          4: "Has Faces"}
+
+    def set_controls(self):
+        """ Set keyboard controls, destination and help text """
+        controls = {"z": {"action": self.iterate_frame,
+                          "args": ("navigation", - 1),
+                          "help": "Previous Frame"},
+                    "x": {"action": self.iterate_frame,
+                          "args": ("navigation", 1),
+                          "help": "Next Frame"},
+                    "[": {"action": self.iterate_frame,
+                          "args": ("navigation", - 100),
+                          "help": "100 Frames Back"},
+                    "]": {"action": self.iterate_frame,
+                          "args": ("navigation", 100),
+                          "help": "100 Frames Forward"},
+                    "{": {"action": self.iterate_frame,
+                          "args": ("navigation", "first"),
+                          "help": "Go to First Frame"},
+                    "}": {"action": self.iterate_frame,
+                          "args": ("navigation", "last"),
+                          "help": "Go to Last Frame"},
+                    27: {"action": "quit",
+                         "key_text": "ESC",
+                         "args": ("navigation", None),
+                         "help": "Exit",
+                         "key_type": ord},
+                    "/": {"action": self.iterate_state,
+                          "args": ("navigation", "frame-size"),
+                          "help": "Cycle Frame Zoom"},
+                    "s": {"action": self.iterate_state,
+                          "args": ("navigation", "skip-mode"),
+                          "help": ("Skip Mode (All, No Faces, Multi Faces, "
+                                   "Has Faces)")},
+                    " ": {"action": self.save_alignments,
+                          "key_text": "SPACE",
+                          "args": ("edit", None),
+                          "help": "Save Alignments"},
+                    "r": {"action": self.reload_alignments,
+                          "args": ("edit", None),
+                          "help": "Reload Alignments (Discard all changes)"},
+                    "d": {"action": self.delete_alignment,
+                          "args": ("edit", None),
+                          "help": "Delete Selected Alignment"},
+                    "m": {"action": self.toggle_state,
+                          "args": ("edit", "active"),
+                          "help": "Change Mode (View, Edit)"},
+                    range(10): {"action": self.set_state_value,
+                                "key_text": "0 to 9",
+                                "args": ["edit", "selected"],
+                                "help": "Select/Deselect Face at this Index",
+                                "key_type": range},
+                    "y": {"action": self.toggle_state,
+                          "args": ("image", "display"),
+                          "help": "Toggle Image"},
+                    "u": {"action": self.iterate_state,
+                          "args": ("bounding_box", "color"),
+                          "help": "Cycle Bounding Box Color"},
+                    "i": {"action": self.iterate_state,
+                          "args": ("extract_box", "color"),
+                          "help": "Cycle Extract Box Color"},
+                    "o": {"action": self.iterate_state,
+                          "args": ("landmarks", "color"),
+                          "help": "Cycle Landmarks Color"},
+                    "p": {"action": self.iterate_state,
+                          "args": ("landmarks_mesh", "color"),
+                          "help": "Cycle Landmarks Mesh Color"},
+                    "h": {"action": self.iterate_state,
+                          "args": ("bounding_box", "size"),
+                          "help": "Cycle Bounding Box thickness"},
+                    "j": {"action": self.iterate_state,
+                          "args": ("extract_box", "size"),
+                          "help": "Cycle Extract Box thickness"},
+                    "k": {"action": self.iterate_state,
+                          "args": ("landmarks", "size"),
+                          "help": "Cycle Landmarks - point size"},
+                    "l": {"action": self.iterate_state,
+                          "args": ("landmarks_mesh", "size"),
+                          "help": "Cycle Landmarks Mesh - thickness"}}
+
+        return controls
+
+    @staticmethod
+    def set_state():
+        """ Set the initial display state """
+        state = {"bounding_box": dict(),
+                 "extract_box": dict(),
+                 "landmarks": dict(),
+                 "landmarks_mesh": dict(),
+                 "image": dict(),
+                 "navigation": {"skip-mode": 1,
+                                "frame-size": 1,
+                                "frame_idx": 0,
+                                "max_frame": 0,
+                                "last_request": 0,
+                                "frame_name": None},
+                 "edit": {"updated": False,
+                          "update_faces": False,
+                          "selected": None,
+                          "active": 0,
+                          "redraw": False}}
+
+        # See lib_alignments/annotate.py for color mapping
+        color = 0
+        for key in sorted(state.keys()):
+            if key not in ("bounding_box", "extract_box", "landmarks",
+                           "landmarks_mesh", "image"):
+                continue
+            state[key]["display"] = True
+            if key == "image":
+                continue
+            color += 1
+            state[key]["size"] = 1
+            state[key]["color"] = color
+
+        return state
+
+    def save_alignments(self, *args):
+        """ Save alignments """
+        if not self.state["edit"]["updated"]:
+            return
+        self.alignments.save_alignments()
+        self.state["edit"]["updated"] = False
+        self.set_redraw(True)
+
+    def reload_alignments(self, *args):
+        """ Reload alignments """
+        if not self.state["edit"]["updated"]:
+            return
+        self.alignments.reload()
+        self.state["edit"]["updated"] = False
+        self.state["edit"]["update_faces"] = True
+        self.set_redraw(True)
+
+    def delete_alignment(self, *args):
+        """ Save alignments """
+        selected_face = self.get_selected_face_id()
+        if self.get_edit_mode() == "View" or selected_face is None:
+            return
+        frame = self.get_frame_name()
+        if self.alignments.delete_alignment_at_index(frame, selected_face):
+            self.state["edit"]["selected"] = None
+            self.state["edit"]["updated"] = True
+            self.state["edit"]["update_faces"] = True
+            self.set_redraw(True)
+
+    def toggle_state(self, item, category):
+        """ Toggle state of requested item """
+        self.state[item][category] = not self.state[item][category]
+        self.set_redraw(True)
+
+    def iterate_state(self, item, category):
+        """ Cycle through options (6 possible or 3 currently supported) """
+        if category == "color":
+            max_val = 7
+        elif category == "frame-size":
+            max_val = 6
+        elif category == "skip-mode":
+            max_val = 4
+        else:
+            max_val = 3
+        val = self.state[item][category]
+        val = val + 1 if val != max_val else 1
+        self.state[item][category] = val
+        self.set_redraw(True)
+
+    def set_state_value(self, item, category, value):
+        """ Set state of requested item or toggle off """
+        state = self.state[item][category]
+        value = str(value) if value is not None else value
+        if state == value:
+            self.state[item][category] = None
+        else:
+            self.state[item][category] = value
+        self.set_redraw(True)
+
+    def iterate_frame(self, *args):
+        """ Iterate frame up or down, stopping at either end """
+        iteration = args[1]
+        max_frame = self.state["navigation"]["max_frame"]
+        if iteration in ("first", "last"):
+            next_frame = 0 if iteration == "first" else max_frame
+            self.state["navigation"]["frame_idx"] = next_frame
+            self.state["navigation"]["last_request"] = 0
+            self.set_redraw(True)
+            return
+
+        current_frame = self.state["navigation"]["frame_idx"]
+        next_frame = current_frame + iteration
+        end = 0 if iteration < 0 else max_frame
+        if (max_frame == 0 or
+                (end > 0 and next_frame >= end) or
+                (end == 0 and next_frame <= end)):
+            next_frame = end
+        self.state["navigation"]["frame_idx"] = next_frame
+        self.state["navigation"]["last_request"] = iteration
+        self.set_state_value("edit", "selected", None)
+
+    def get_color(self, item):
+        """ Return color for selected item """
+        return self.state[item]["color"]
+
+    def get_size(self, item):
+        """ Return size for selected item """
+        return self.state[item]["size"]
+
+    def get_frame_scaling(self):
+        """ Return frame scaling factor for requested item """
+        factors = (1, 1.25, 1.5, 2, 0.5, 0.75)
+        idx = self.state["navigation"]["frame-size"] - 1
+        return factors[idx]
+
+    def get_edit_mode(self):
+        """ Return text version and border color for edit mode """
+        if self.state["edit"]["active"]:
+            return "Edit"
+        return "View"
+
+    def get_skip_mode(self):
+        """ Return text version of skip mode """
+        return self.skip_mode[self.state["navigation"]["skip-mode"]]
+
+    def get_state_color(self):
+        """ Return a color based on current state
+            white - View Mode
+            yellow - Edit Mide
+            red - Unsaved alignments """
+        color = (255, 255, 255)
+        if self.state["edit"]["updated"]:
+            color = (0, 0, 255)
+        elif self.state["edit"]["active"]:
+            color = (0, 255, 255)
+        return color
+
+    def get_frame_name(self):
+        """ Return the current frame number """
+        return self.state["navigation"]["frame_name"]
+
+    def get_selected_face_id(self):
+        """ Return the index of the currently selected face """
+        try:
+            return int(self.state["edit"]["selected"])
+        except TypeError:
+            return None
+
+    def redraw(self):
+        """ Return whether a redraw is required """
+        return self.state["edit"]["redraw"]
+
+    def set_redraw(self, request):
+        """ Turn redraw requirement on or off """
+        self.state["edit"]["redraw"] = request
+
+
+class Help():
+    """ Generate and display help in cli and in window """
+    def __init__(self, interface):
+        self.interface = interface
+        self.helptext = self.generate()
+
+    def generate(self):
+        """ Generate help output """
+        sections = ("navigation", "display", "color", "size", "edit")
+        helpout = {section: list() for section in sections}
+        helptext = ""
+        for key, val in self.interface.controls.items():
+            help_section = val["args"][0]
+            if help_section not in ("navigation", "edit"):
+                help_section = val["args"][1]
+            key_text = val.get("key_text", None)
+            key_text = key_text if key_text else key
+            helpout[help_section].append((val["help"], key_text))
+
+        helpout["edit"].append(("Bounding Box - Move", "Left Click"))
+        helpout["edit"].append(("Bounding Box - Resize", "Middle Click"))
+
+        for section in sections:
+            spacer = "=" * int((40 - len(section)) / 2)
+            display = "\n{} {} {}\n".format(spacer, section.upper(), spacer)
+            helpsection = sorted(helpout[section])
+            if section == "navigation":
+                helpsection = sorted(helpout[section], reverse=True)
+            display += "\n".join("  - '{}': {}".format(item[1], item[0])
+                                 for item in helpsection)
+
+            helptext += display
+        return helptext
+
+    def render(self):
+        """ Render help text to image window """
+        image = self.background()
+        display_text = self.helptext + self.compile_status()
+        self.text_to_image(image, display_text)
+        cv2.namedWindow("Help")
+        cv2.imshow("Help", image)
+
+    def background(self):
+        """ Create an image to hold help text """
+        height = 850
+        width = 480
+        image = np.zeros((height, width, 3), np.uint8)
+        color = self.interface.get_state_color()
+        cv2.rectangle(image, (0, 0), (width - 1, height - 1),
+                      color, 2)
+        return image
+
+    def compile_status(self):
+        """ Render the status text """
+        status = "\n=== STATUS\n"
+        navigation = self.interface.state["navigation"]
+        frame_scale = int(self.interface.get_frame_scaling() * 100)
+        status += "  File: {}\n".format(self.interface.get_frame_name())
+        status += "  Frame: {} / {}\n".format(
+            navigation["frame_idx"] + 1, navigation["max_frame"] + 1)
+        status += "  Frame Size: {}%\n".format(frame_scale)
+        status += "  Skip Mode: {}\n".format(self.interface.get_skip_mode())
+        status += "  View Mode: {}\n".format(self.interface.get_edit_mode())
+        if self.interface.get_selected_face_id() is not None:
+            status += "  Selected Face Index: {}\n".format(
+                self.interface.get_selected_face_id())
+        if self.interface.state["edit"]["updated"]:
+            status += "  Warning: There are unsaved changes\n"
+
+        return status
+
+    @staticmethod
+    def text_to_image(image, display_text):
+        """ Write out and format help text to image """
+        pos_y = 0
+        for line in display_text.split("\n"):
+            if line.startswith("==="):
+                pos_y += 10
+                line = line.replace("=", "").strip()
+            line = line.replace("- '", "[ ").replace("':", " ]")
+            cv2.putText(image, line, (20, pos_y),
+                        cv2.FONT_HERSHEY_SIMPLEX, 0.43, (255, 255, 255), 1)
+            pos_y += 20
+
+
+class Manual():
+    """ Manually adjust or create landmarks data """
+    def __init__(self, alignments, arguments):
+        self.arguments = arguments
+        self.verbose = arguments.verbose
+        self.alignments = alignments
+        self.align_eyes = arguments.align_eyes
+        self.frames = Frames(arguments.frames_dir, self.verbose)
+        self.extracted_faces = None
+        self.interface = None
+        self.help = None
+        self.mouse_handler = None
+
+    def process(self):
+        """ Process manual extraction """
+        rotate = Rotate(self.alignments, self.arguments,
+                        frames=self.frames, child_process=True)
+        rotate.process()
+
+        print("\n[MANUAL PROCESSING]")  # Tidy up cli output
+        self.extracted_faces = ExtractedFaces(self.frames,
+                                              self.alignments,
+                                              align_eyes=self.align_eyes)
+        self.interface = Interface(self.alignments, self.frames)
+        self.help = Help(self.interface)
+        self.mouse_handler = MouseHandler(self.interface, self.verbose)
+
+        print(self.help.helptext)
+        max_idx = self.frames.count - 1
+        self.interface.state["navigation"]["max_frame"] = max_idx
+        self.display_frames()
+
+    def display_frames(self):
+        """ Iterate through frames """
+        cv2.namedWindow("Frame")
+        cv2.namedWindow("Faces")
+        cv2.setMouseCallback('Frame', self.mouse_handler.on_event)
+
+        frame, faces = self.get_frame()
+        press = self.get_keys()
+
+        while True:
+            if cv2.getWindowProperty('Frame', cv2.WND_PROP_VISIBLE) < 1:
+                break
+            self.help.render()
+            cv2.imshow("Frame", frame)
+            cv2.imshow("Faces", faces)
+            key = cv2.waitKey(1)
+
+            if key in press.keys():
+                action = press[key]["action"]
+                if action == "quit":
+                    break
+
+                if press[key].get("key_type") == range:
+                    args = press[key]["args"] + [chr(key)]
+                else:
+                    args = press[key]["args"]
+                action(*args)
+
+            if not self.interface.redraw():
+                continue
+
+            frame, faces = self.get_frame()
+            self.interface.set_redraw(False)
+
+        cv2.destroyAllWindows()
+
+    def get_keys(self):
+        """ Convert keys dict into something useful
+            for OpenCV """
+        keys = dict()
+        for key, val in self.interface.controls.items():
+            if val.get("key_type", str) == range:
+                for range_key in key:
+                    keys[ord(str(range_key))] = val
+            elif val.get("key_type", str) == ord:
+                keys[key] = val
+            else:
+                keys[ord(key)] = val
+
+        return keys
+
+    def get_frame(self):
+        """ Compile the frame and get faces """
+        image = self.frame_selector()
+        frame_name = self.interface.get_frame_name()
+        alignments = self.alignments.get_alignments_for_frame(frame_name)
+        faces_updated = self.interface.state["edit"]["update_faces"]
+        roi = self.extracted_faces.get_roi_for_frame(frame_name,
+                                                     faces_updated)
+        if faces_updated:
+            self.interface.state["edit"]["update_faces"] = False
+
+        frame = FrameDisplay(image, alignments, roi, self.interface).image
+        faces = self.set_faces(frame_name, alignments).image
+        return frame, faces
+
+    def frame_selector(self):
+        """ Return frame at given index """
+        navigation = self.interface.state["navigation"]
+        frame_list = self.frames.file_list_sorted
+        frame = frame_list[navigation["frame_idx"]]["frame_fullname"]
+        skip_mode = self.interface.get_skip_mode().lower()
+
+        while True:
+            if skip_mode == "standard":
+                break
+            elif (skip_mode == "no faces"
+                  and not self.alignments.frame_has_faces(frame)):
+                break
+            elif (skip_mode == "multi-faces"
+                  and self.alignments.frame_has_multiple_faces(frame)):
+                break
+            elif (skip_mode == "has faces"
+                  and self.alignments.frame_has_faces(frame)):
+                break
+            else:
+                iteration = navigation["last_request"]
+                old_idx = navigation["frame_idx"]
+                self.interface.iterate_frame("navigation", iteration)
+                if old_idx == navigation["frame_idx"]:
+                    break
+                frame = frame_list[navigation["frame_idx"]]["frame_fullname"]
+
+        image = self.frames.load_image(frame)
+        navigation["last_request"] = 0
+        navigation["frame_name"] = frame
+        return image
+
+    def set_faces(self, frame, alignments):
+        """ Pass the current frame faces to faces window """
+        extracted = self.extracted_faces
+        size = extracted.size
+
+        faces = extracted.get_faces_for_frame(frame)
+
+        landmarks_xy = [alignment["landmarksXY"] for alignment in alignments]
+        landmarks = [
+            {"landmarksXY": aligned}
+            for aligned
+            in extracted.get_aligned_landmarks_for_frame(frame, landmarks_xy)]
+
+        return FacesDisplay(faces, landmarks, size, self.interface)
+
+
+class FrameDisplay():
+    """" Window that holds the frame """
+    def __init__(self, image, alignments, roi, interface):
+        self.image = image
+        self.roi = roi
+        self.alignments = alignments
+        self.interface = interface
+        self.annotate_frame()
+
+    def annotate_frame(self):
+        """ Annotate the frame """
+        state = self.interface.state
+        annotate = Annotate(self.image, self.alignments, self.roi)
+        if not state["image"]["display"]:
+            annotate.draw_black_image()
+
+        for item in ("bounding_box", "extract_box",
+                     "landmarks", "landmarks_mesh"):
+
+            color = self.interface.get_color(item)
+            size = self.interface.get_size(item)
+
+            state[item]["display"] = False if color == 7 else True
+
+            if not state[item]["display"]:
+                continue
+
+            annotation = getattr(annotate, "draw_{}".format(item))
+            annotation(color, size)
+
+        selected_face = self.interface.get_selected_face_id()
+        if (selected_face is not None and
+                int(selected_face) < len(self.alignments)):
+            annotate.draw_grey_out_faces(selected_face)
+
+        self.image = self.resize_frame(annotate.image)
+
+    def resize_frame(self, image):
+        """ Set the displayed frame size and add state border"""
+        height, width = image.shape[:2]
+        color = self.interface.get_state_color()
+        cv2.rectangle(image, (0, 0), (width - 1, height - 1),
+                      color, 1)
+
+        scaling = self.interface.get_frame_scaling()
+        image = cv2.resize(image, (0, 0), fx=scaling, fy=scaling)
+        return image
+
+
+class FacesDisplay():
+    """ Window that holds faces thumbnail """
+    def __init__(self, extracted_faces, landmarks, size, interface):
+        self.row_length = 4
+        self.faces = self.copy_faces(extracted_faces)
+        self.roi = self.set_full_roi(size)
+        self.landmarks = landmarks
+        self.interface = interface
+
+        self.annotate_faces()
+
+        self.image = self.build_faces_image(size)
+
+    @staticmethod
+    def copy_faces(faces):
+        """ Copy the extracted faces so as not to save the annotations back """
+        return [face.copy() for face in faces]
+
+    @staticmethod
+    def set_full_roi(size):
+        """ ROI is the full frame for faces, so set based on size """
+        return [np.array([[(0, 0), (0, size - 1),
+                           (size - 1, size - 1), (size - 1, 0)]], np.int32)]
+
+    def annotate_faces(self):
+        """ Annotate each of the faces """
+        state = self.interface.state
+        selected_face = self.interface.get_selected_face_id()
+        for idx, face in enumerate(self.faces):
+            annotate = Annotate(face, [self.landmarks[idx]], self.roi)
+            if not state["image"]["display"]:
+                annotate.draw_black_image()
+
+            for item in ("landmarks", "landmarks_mesh"):
+                if not state[item]["display"]:
+                    continue
+
+                color = self.interface.get_color(item)
+                size = self.interface.get_size(item)
+                annotation = getattr(annotate, "draw_{}".format(item))
+                annotation(color, size)
+
+            if (selected_face is not None
+                    and int(selected_face) < len(self.faces)
+                    and int(selected_face) != idx):
+                annotate.draw_grey_out_faces(1)
+
+            self.faces[idx] = annotate.image
+
+    def build_faces_image(self, size):
+        """ Display associated faces """
+        total_faces = len(self.faces)
+        if not total_faces:
+            image = self.build_faces_row(list(), size)
+            return image
+        total_rows = int(total_faces / self.row_length) + 1
+        for idx in range(total_rows):
+            face_idx = idx * self.row_length
+            row_faces = self.faces[face_idx:face_idx + self.row_length]
+            if not row_faces:
+                break
+            row = self.build_faces_row(row_faces, size)
+            image = row if idx == 0 else np.concatenate((image, row), axis=0)
+        return image
+
+    def build_faces_row(self, faces, size):
+        """ Build a row of 4 faces """
+        if len(faces) != 4:
+            remainder = 4 - (len(faces) % self.row_length)
+            for _ in range(remainder):
+                faces.append(np.zeros((size, size, 3), np.uint8))
+        for idx, face in enumerate(faces):
+            color = self.interface.get_state_color()
+            cv2.rectangle(face, (0, 0), (size - 1, size - 1),
+                          color, 1)
+            if idx == 0:
+                row = face
+            else:
+                row = np.concatenate((row, face), axis=1)
+        return row
+
+
+class MouseHandler():
+    """ Manual Extraction """
+    def __init__(self, interface, verbose):
+        self.interface = interface
+        self.alignments = interface.alignments
+        self.frames = interface.frames
+        self.extract = Extract(None, "manual",
+                               initialize_only=True, verbose=verbose)
+        self.mouse_state = None
+        self.last_move = None
+        self.center = None
+        self.dims = None
+        self.media = {"frame_id": None,
+                      "image": None,
+                      "bounding_box": list(),
+                      "bounding_box_orig": list()}
+
+    def on_event(self, event, x, y, flags, param):
+        """ Handle the mouse events """
+        if self.interface.get_edit_mode() != "Edit":
+            return
+        elif not self.mouse_state and event not in (cv2.EVENT_LBUTTONDOWN,
+                                                    cv2.EVENT_MBUTTONDOWN):
+            return
+
+        self.initialize()
+
+        if event in (cv2.EVENT_LBUTTONUP, cv2.EVENT_MBUTTONUP):
+            self.mouse_state = None
+            self.last_move = None
+        elif event == cv2.EVENT_LBUTTONDOWN:
+            self.mouse_state = "left"
+            self.set_bounding_box(x, y)
+        elif event == cv2.EVENT_MBUTTONDOWN:
+            self.mouse_state = "middle"
+        elif event == cv2.EVENT_MOUSEMOVE:
+            if self.mouse_state == "left":
+                self.move_bounding_box(x, y)
+            elif self.mouse_state == "middle":
+                self.resize_bounding_box(x, y)
+
+    def initialize(self):
+        """ Update changed parameters """
+        frame = self.interface.get_frame_name()
+        if frame == self.media["frame_id"]:
+            return
+        self.media["frame_id"] = frame
+        self.media["image"] = self.frames.load_image(frame)
+
+    def set_bounding_box(self, pt_x, pt_y):
+        """ Select or create bounding box """
+        if self.interface.get_selected_face_id() is None:
+            self.check_click_location(pt_x, pt_y)
+
+        if self.interface.get_selected_face_id() is not None:
+            self.dims_from_alignment()
+        else:
+            self.dims_from_image()
+
+        self.move_bounding_box(pt_x, pt_y)
+
+    def check_click_location(self, pt_x, pt_y):
+        """ Check whether the point clicked is within an existing
+            bounding box and set face_id """
+        frame = self.media["frame_id"]
+        alignments = self.alignments.get_alignments_for_frame(frame)
+
+        for idx, alignment in enumerate(alignments):
+            left = alignment["x"]
+            right = alignment["x"] + alignment["w"]
+            top = alignment["y"]
+            bottom = alignment["y"] + alignment["h"]
+
+            if left <= pt_x <= right and top <= pt_y <= bottom:
+                self.interface.set_state_value("edit", "selected", idx)
+                break
+
+    def dims_from_alignment(self):
+        """ Set the height and width of bounding box from alignment """
+        frame = self.media["frame_id"]
+        face_id = self.interface.get_selected_face_id()
+        alignment = self.alignments.get_alignments_for_frame(frame)[face_id]
+        self.dims = (alignment["w"], alignment["h"])
+
+    def dims_from_image(self):
+        """ Set the height and width of bounding
+            box at 10% of longest axis """
+        size = max(self.media["image"].shape[:2])
+        dim = int(size / 10.00)
+        self.dims = (dim, dim)
+
+    def bounding_from_center(self):
+        """ Get bounding X Y from center """
+        pt_x, pt_y = self.center
+        width, height = self.dims
+        scale = self.interface.get_frame_scaling()
+        self.media["bounding_box"] = [int((pt_x / scale) - width / 2),
+                                      int((pt_y / scale) - height / 2),
+                                      int((pt_x / scale) + width / 2),
+                                      int((pt_y / scale) + height / 2)]
+
+    def move_bounding_box(self, pt_x, pt_y):
+        """ Move the bounding box """
+        self.center = (pt_x, pt_y)
+        self.bounding_from_center()
+        self.update_landmarks()
+
+    def resize_bounding_box(self, pt_x, pt_y):
+        """ Resize the bounding box """
+        if not self.dims:
+            return
+        if not self.last_move:
+            self.last_move = (pt_x, pt_y)
+            self.media["bounding_box_orig"] = self.media["bounding_box"]
+
+        move_x = int(pt_x - self.last_move[0])
+        move_y = int(self.last_move[1] - pt_y)
+
+        original = self.media["bounding_box_orig"]
+        updated = self.media["bounding_box"]
+
+        updated[0] = min(self.center[0] - 10, original[0] - move_x)
+        updated[1] = min(self.center[1] - 10, original[1] - move_y)
+        updated[2] = max(self.center[0] + 10, original[2] + move_x)
+        updated[3] = max(self.center[1] + 10, original[3] + move_y)
+        self.update_landmarks()
+        self.last_move = (pt_x, pt_y)
+
+    def update_landmarks(self):
+        """ Update the landmarks """
+        self.extract.execute(self.media["image"],
+                             manual_face=self.media["bounding_box"])
+        landmarks = self.extract.landmarks[0][1]
+        left, top, right, bottom = self.media["bounding_box"]
+        alignment = {"x": left,
+                     "w": right - left,
+                     "y": top,
+                     "h": bottom - top,
+                     "landmarksXY": landmarks}
+        frame = self.media["frame_id"]
+
+        if self.interface.get_selected_face_id() is None:
+            idx = self.alignments.add_alignment(frame, alignment)
+            self.interface.set_state_value("edit", "selected", idx)
+        else:
+            self.alignments.update_alignment(
+                frame,
+                self.interface.get_selected_face_id(),
+                alignment)
+            self.interface.set_redraw(True)
+
+        self.interface.state["edit"]["updated"] = True
+        self.interface.state["edit"]["update_faces"] = True
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
new file mode 100644
index 0000000..e463b0c
--- /dev/null
+++ b/tools/lib_alignments/media.py
@@ -0,0 +1,462 @@
+#!/usr/bin/env python3
+""" Media items (Alignments, Faces, Frames)
+    for alignments tool """
+
+import os
+from datetime import datetime
+
+import cv2
+import numpy as np
+
+from lib import Serializer
+from lib.utils import _image_extensions, rotate_landmarks
+from plugins.PluginLoader import PluginLoader
+
+
+class AlignmentData():
+    """ Class to hold the alignment data """
+
+    def __init__(self, alignments_file, destination_format, verbose):
+        print("\n[ALIGNMENT DATA]")  # Tidy up cli output
+        self.file = alignments_file
+        self.verbose = verbose
+
+        self.check_file_exists()
+        self.src_format = self.get_source_format()
+        self.dst_format = self.get_destination_format(destination_format)
+
+        if self.src_format == "dfl":
+            self.set_destination_serializer()
+            return
+
+        self.serializer = Serializer.get_serializer_from_ext(
+            self.src_format)
+        self.alignments = self.load()
+        self.count = len(self.alignments)
+
+        self.set_destination_serializer()
+        if self.verbose:
+            print("{} items loaded".format(self.count))
+
+    def check_file_exists(self):
+        """ Check the alignments file exists"""
+        if os.path.split(self.file.lower())[1] == "dfl":
+            self.file = "dfl"
+        if self.file.lower() == "dfl":
+            print("Using extracted pngs for alignments")
+            return
+        if not os.path.isfile(self.file):
+            print("ERROR: alignments file not "
+                  "found at: {}".format(self.file))
+            exit(0)
+        if self.verbose:
+            print("Alignments file exists at {}".format(self.file))
+        return
+
+    def get_source_format(self):
+        """ Get the source alignments format """
+        if self.file.lower() == "dfl":
+            return "dfl"
+        return os.path.splitext(self.file)[1].lower()
+
+    def get_destination_format(self, destination_format):
+        """ Standardise the destination format to the correct extension """
+        extensions = {".json": "json",
+                      ".p": "pickle",
+                      ".yml": "yaml",
+                      ".yaml": "yaml"}
+        dst_fmt = None
+
+        if destination_format is not None:
+            dst_fmt = destination_format
+        elif self.src_format == "dfl":
+            dst_fmt = "json"
+        elif self.src_format in extensions.keys():
+            dst_fmt = extensions[self.src_format]
+        else:
+            print("{} is not a supported serializer. "
+                  "Exiting".format(self.src_format))
+            exit(0)
+
+        if self.verbose:
+            print("Destination format set to {}".format(dst_fmt))
+
+        return dst_fmt
+
+    def set_destination_serializer(self):
+        """ set the destination serializer """
+        self.serializer = Serializer.get_serializer(self.dst_format)
+
+    def load(self):
+        """ Read the alignments data from the correct format """
+        print("Loading alignments from {}".format(self.file))
+        with open(self.file, self.serializer.roptions) as align:
+            alignments = self.serializer.unmarshal(align.read())
+        return alignments
+
+    def reload(self):
+        """ Read the alignments data from the correct format """
+        print("Reloading alignments from {}".format(self.file))
+        with open(self.file, self.serializer.roptions) as align:
+            self.alignments = self.serializer.unmarshal(align.read())
+
+    def save_alignments(self):
+        """ Backup copy of old alignments and save new alignments """
+        dst = os.path.splitext(self.file)[0]
+        dst += ".{}".format(self.serializer.ext)
+        self.backup_alignments()
+
+        print("Saving alignments to {}".format(dst))
+        with open(dst, self.serializer.woptions) as align:
+            align.write(self.serializer.marshal(self.alignments))
+
+    def backup_alignments(self):
+        """ Backup copy of old alignments """
+        if not os.path.isfile(self.file):
+            return
+        now = datetime.now().strftime("%Y%m%d_%H%M%S")
+        src = self.file
+        dst = src.split(".")
+        dst[0] += "_" + now + "."
+        dst = dst[0] + dst[1]
+        print("Backing up original alignments to {}".format(dst))
+        os.rename(src, dst)
+
+    def get_alignments_one_image(self):
+        """ Return the face alignments for one image """
+        for frame_fullname, alignments in self.alignments.items():
+            frame_name = frame_fullname[:frame_fullname.rindex(".")]
+            number_alignments = len(alignments)
+            yield frame_name, alignments, number_alignments, frame_fullname
+
+    @staticmethod
+    def get_one_alignment_index_reverse(image_alignments, number_alignments):
+        """ Return the correct original index for
+            alignment in reverse order """
+        for idx, _ in enumerate(reversed(image_alignments)):
+            original_idx = number_alignments - 1 - idx
+            yield original_idx
+
+    def get_alignments_for_frame(self, frame):
+        """ Return the alignments for the selected frame """
+        return self.alignments.get(frame, list())
+
+    def frame_in_alignments(self, frame):
+        """ Return true if frame exists in alignments file """
+        return bool(self.alignments.get(frame, -1) != -1)
+
+    def frame_has_faces(self, frame):
+        """ Return true if frame exists and has faces """
+        return bool(self.alignments.get(frame, list()))
+
+    def frame_has_multiple_faces(self, frame):
+        """ Return true if frame exists and has faces """
+        if not frame:
+            return False
+        return bool(len(self.alignments.get(frame, list())) > 1)
+
+    def get_full_frame_name(self, frame):
+        """ Return a frame with extension for when the extension is
+            not known """
+        return next(key for key in self.alignments.keys()
+                    if key.startswith(frame))
+
+    def count_alignments_in_frame(self, frame):
+        """ Return number of alignments within frame """
+        return len(self.alignments.get(frame, list()))
+
+    def delete_alignment_at_index(self, frame, idx):
+        """ Delete the face alignment for given frame at given index """
+        idx = int(idx)
+        if idx + 1 > self.count_alignments_in_frame(frame):
+            return False
+        del self.alignments[frame][idx]
+        return True
+
+    def add_alignment(self, frame, alignment):
+        """ Add a new alignment for a frame and return it's index """
+        self.alignments[frame].append(alignment)
+        return self.count_alignments_in_frame(frame) - 1
+
+    def update_alignment(self, frame, idx, alignment):
+        """ Replace an alignment for given frame and index """
+        self.alignments[frame][idx] = alignment
+
+    def get_rotated(self):
+        """ Return list of keys for alignments containing
+            rotated frames """
+        keys = list()
+        for key, val in self.alignments.items():
+            if any(alignment.get("r", None) for alignment in val):
+                keys.append(key)
+        return keys
+
+    def rotate_existing_landmarks(self, frame, dimensions):
+        """ Backwards compatability fix. Rotates the landmarks to
+            their correct position and sets r to 0 """
+        for alignment in self.alignments.get(frame, list()):
+            angle = alignment.get("r", 0)
+            if not angle:
+                return
+            rotation_matrix = self.get_original_rotation_matrix(dimensions,
+                                                                angle)
+            face = DetectedFace()
+            face.alignment_to_face(None, alignment)
+            face = rotate_landmarks(face, rotation_matrix)
+            alignment = face.face_to_alignment(alignment)
+            del alignment["r"]
+
+    @staticmethod
+    def get_original_rotation_matrix(dimensions, angle):
+        """ Calculate original rotation matrix and invert """
+        height, width = dimensions
+        center = (width/2, height/2)
+        rotation_matrix = cv2.getRotationMatrix2D(center, -1.0*angle, 1.)
+
+        abs_cos = abs(rotation_matrix[0, 0])
+        abs_sin = abs(rotation_matrix[0, 1])
+        rotated_width = int(height*abs_sin + width*abs_cos)
+        rotated_height = int(height*abs_cos + width*abs_sin)
+        rotation_matrix[0, 2] += rotated_width/2 - center[0]
+        rotation_matrix[1, 2] += rotated_height/2 - center[1]
+
+        return rotation_matrix
+
+
+class MediaLoader():
+    """ Class to load filenames from folder """
+    def __init__(self, folder, verbose):
+        print("\n[{} DATA]".format(self.__class__.__name__.upper()))
+        self.verbose = verbose
+        self.folder = folder
+        self.check_folder_exists()
+        self.file_list_sorted = self.sorted_items()
+        self.items = self.load_items()
+        self.count = len(self.file_list_sorted)
+        if self.verbose:
+            print("{} items loaded".format(self.count))
+
+    def check_folder_exists(self):
+        """ makes sure that the faces folder exists """
+        err = None
+        loadtype = self.__class__.__name__
+        if not self.folder:
+            err = "ERROR: A {} folder must be specified".format(loadtype)
+        elif not os.path.isdir(self.folder):
+            err = ("ERROR: The {} folder {} could not be "
+                   "found".format(loadtype, self.folder))
+        if err:
+            print(err)
+            exit(0)
+
+        if self.verbose:
+            print("Folder exists at {}".format(self.folder))
+
+    @staticmethod
+    def valid_extension(filename):
+        """ Check whether passed in file has a valid extension """
+        extension = os.path.splitext(filename)[1]
+        return bool(extension in _image_extensions)
+
+    @staticmethod
+    def sorted_items():
+        """ Override for specific folder processing """
+        return list()
+
+    @staticmethod
+    def process_folder():
+        """ Override for specific folder processing """
+        return list()
+
+    @staticmethod
+    def load_items():
+        """ Override for specific item loading """
+        return dict()
+
+    def load_image(self, filename):
+        """ Load an image """
+        src = os.path.join(self.folder, filename)
+        image = cv2.imread(src)
+        return image
+
+    @staticmethod
+    def save_image(output_folder, filename, image):
+        """ Save an image """
+        output_file = os.path.join(output_folder, filename)
+        cv2.imwrite(output_file, image)
+
+
+class Faces(MediaLoader):
+    """ Object to hold the faces that are to be swapped out """
+
+    def process_folder(self):
+        """ Iterate through the faces dir pulling out various information """
+        print("Loading file list from {}".format(self.folder))
+        for face in os.listdir(self.folder):
+            if not self.valid_extension(face):
+                continue
+            filename = os.path.splitext(face)[0]
+            file_extension = os.path.splitext(face)[1]
+            index = int(filename[filename.rindex("_") + 1:])
+            original_file = "{}".format(filename[:filename.rindex("_")])
+            yield {"face_fullname": face,
+                   "face_name": filename,
+                   "face_extension": file_extension,
+                   "frame_name": original_file,
+                   "face_index": index}
+
+    def load_items(self):
+        """ Load the face names into dictionary """
+        faces = dict()
+        for face in self.file_list_sorted:
+            faces.setdefault(face["frame_name"],
+                             list()).append(face["face_index"])
+        return faces
+
+    def sorted_items(self):
+        """ Return the items sorted by filename then index """
+        return sorted([item for item in self.process_folder()],
+                      key=lambda x: (x["frame_name"], x["face_index"]))
+
+
+class Frames(MediaLoader):
+    """ Object to hold the frames that are to be checked against """
+
+    def process_folder(self):
+        """ Iterate through the frames dir pulling the base filename """
+        print("Loading file list from {}".format(self.folder))
+        for frame in os.listdir(self.folder):
+            if not self.valid_extension(frame):
+                continue
+            filename = os.path.splitext(frame)[0]
+            file_extension = os.path.splitext(frame)[1]
+
+            yield {"frame_fullname": frame,
+                   "frame_name": filename,
+                   "frame_extension": file_extension}
+
+    def load_items(self):
+        """ Load the frame info into dictionary """
+        frames = dict()
+        for frame in self.file_list_sorted:
+            frames[frame["frame_fullname"]] = (frame["frame_name"],
+                                               frame["frame_extension"])
+        return frames
+
+    def sorted_items(self):
+        """ Return the items sorted by filename """
+        return sorted([item for item in self.process_folder()],
+                      key=lambda x: (x["frame_name"]))
+
+
+class DetectedFace():
+    """ Detected face and landmark information """
+    def __init__(self):
+        self.image = None
+        self.x = None
+        self.w = None
+        self.y = None
+        self.h = None
+        self.landmarksXY = None
+
+    def alignment_to_face(self, image, alignment):
+        """ Convert a face alignment to detected face object """
+        self.image = image
+        self.x = alignment["x"]
+        self.w = alignment["w"]
+        self.y = alignment["y"]
+        self.h = alignment["h"]
+        self.landmarksXY = alignment["landmarksXY"]
+
+    def face_to_alignment(self, alignment):
+        """ Convert a face alignment to detected face object """
+        alignment["x"] = self.x
+        alignment["w"] = self.w
+        alignment["y"] = self.y
+        alignment["h"] = self.h
+        alignment["landmarksXY"] = self.landmarksXY
+        return alignment
+
+    def landmarks_as_xy(self):
+        """ Landmarks as XY """
+        return self.landmarksXY
+
+
+class ExtractedFaces():
+    """ Holds the extracted faces and matrix for
+        alignments """
+    def __init__(self, frames, alignments, size=256,
+                 padding=48, align_eyes=False):
+        self.size = size
+        self.padding = padding
+        self.align_eyes = align_eyes
+        self.extractor = PluginLoader.get_extractor("Align")()
+        self.alignments = alignments
+        self.frames = frames
+
+        self.current_frame = None
+        self.faces = list()
+        self.matrices = list()
+
+    def get_faces(self, frame):
+        """ Return faces and transformed face matrices
+            for each face in a given frame with it's alignments"""
+        self.current_frame = None
+        self.faces = list()
+        self.matrices = list()
+        alignments = self.alignments.get_alignments_for_frame(frame)
+        if not alignments:
+            return
+        image = self.frames.load_image(frame)
+        for alignment in alignments:
+            face, matrix = self.extract_one_face(alignment, image.copy())
+            self.faces.append(face)
+            self.matrices.append(matrix)
+        self.current_frame = frame
+
+    def extract_one_face(self, alignment, image):
+        """ Extract one face from image """
+        face = DetectedFace()
+        face.alignment_to_face(image, alignment)
+        return self.extractor.extract(image, face, self.size, self.align_eyes)
+
+    def original_roi(self, matrix):
+        """ Return the original ROI of an extracted face """
+        points = np.array([[0, 0], [0, self.size - 1],
+                           [self.size - 1, self.size - 1],
+                           [self.size - 1, 0]], np.int32)
+        points = points.reshape((-1, 1, 2))
+
+        mat = matrix * (self.size - 2 * self.padding)
+        mat[:, 2] += self.padding
+        mat = cv2.invertAffineTransform(mat)
+        return [cv2.transform(points, mat)]
+
+    def get_faces_for_frame(self, frame, update=False):
+        """ Return the faces for the selected frame """
+        if self.current_frame != frame or update:
+            self.get_faces(frame)
+        return self.faces
+
+    def get_roi_for_frame(self, frame, update=False):
+        """ Return the original rois for the selected frame """
+        if self.current_frame != frame or update:
+            self.get_faces(frame)
+        return [self.original_roi(matrix) for matrix in self.matrices]
+
+    def get_aligned_landmarks_for_frame(self, frame, landmarks_xy,
+                                        update=False):
+        """ Return the original rois for the selected frame """
+        if self.current_frame != frame or update:
+            self.get_faces(frame)
+        aligned_landmarks = list()
+        if not self.matrices:
+            return aligned_landmarks
+        for idx, landmarks in enumerate(landmarks_xy):
+            matrix = self.matrices[idx]
+            aligned_landmarks.append(
+                self.extractor.transform_points(landmarks,
+                                                matrix,
+                                                self.size,
+                                                self.padding))
+        return aligned_landmarks

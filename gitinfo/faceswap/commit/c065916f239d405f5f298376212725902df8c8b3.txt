commit c065916f239d405f5f298376212725902df8c8b3
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Wed Oct 23 15:05:24 2019 +0000

    Extract - Mask updates
    
    - Remove none mask plugin
    - Make pipeline more flexible
    - Add support for pre-aligned faces to masker plugin
    - Migrate blur and threshold settings to mask output

diff --git a/lib/cli.py b/lib/cli.py
index d491cdf..94e71aa 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -23,7 +23,7 @@ logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
 class ScriptExecutor():
     """ Loads the relevant script modules and executes the script.
-        This class is initialised in each of the argparsers for the relevant
+        This class is initialized in each of the argparsers for the relevant
         command, then execute script is called within their set_default
         function. """
 
@@ -80,7 +80,7 @@ class ScriptExecutor():
             tkinter app is available on their machine. If not
             exit gracefully.
 
-            This avoids having to import every tk function
+            This avoids having to import every tkinter function
             within the GUI in a wrapper and potentially spamming
             traceback errors to console """
 
@@ -321,9 +321,9 @@ class FullHelpArgumentParser(argparse.ArgumentParser):
 
 class SmartFormatter(argparse.HelpFormatter):
     """ Smart formatter for allowing raw formatting in help
-        text and lists in the helptext
+        text and lists in the help text
 
-        To use: prefix the help item with "R|" to overide
+        To use: prefix the help item with "R|" to override
         default formatting. List items can be marked with "L|"
         at the start of a newline
 
@@ -566,14 +566,13 @@ class ExtractArgs(ExtractConvertArgs):
             "opts": ("-M", "--masker"),
             "action": Radio,
             "type": str.lower,
-            "choices": PluginLoader.get_available_extractors("mask"),
+            "choices": PluginLoader.get_available_extractors("mask", add_none=True),
             "default": "extended",
             "group": "Plugins",
             "help": "R|Masker to use. NB: Masker is not currently used by the rest of the process "
                     "but this will store a mask in the alignments file for use when it has been "
                     "implemented."
-                    "\nL|none: An array of all ones is created to provide a 4th channel that will "
-                    "not mask any portion of the image."
+                    "\nL|none: Don't use a mask."
                     "\nL|components: Mask designed to provide facial segmentation based on the "
                     "positioning of landmark locations. A convex hull is constructed around the "
                     "exterior of the landmarks to create a mask."
diff --git a/lib/faces_detect.py b/lib/faces_detect.py
index 5d3a565..84ba7cf 100644
--- a/lib/faces_detect.py
+++ b/lib/faces_detect.py
@@ -273,7 +273,8 @@ class DetectedFace():
         logger.trace(padding)
         return padding
 
-    def load_feed_face(self, image, size=64, coverage_ratio=0.625, dtype=None):
+    def load_feed_face(self, image, size=64, coverage_ratio=0.625, dtype=None,
+                       is_aligned_face=False):
         """ Align a face in the correct dimensions for feeding into a model.
 
         Parameters
@@ -286,6 +287,9 @@ class DetectedFace():
             the ratio of the extracted image that was used for training. Default: `0.625`
         dtype: str, optional
             Optionally set a ``dtype`` for the final face to be formatted in. Default: ``None``
+        is_aligned_face: bool, optional
+            Indicates that the :attr:`image` is an aligned face rather than a frame.
+            Default: ``False``
 
         Notes
         -----
@@ -293,13 +297,21 @@ class DetectedFace():
             - :func:`feed_face`
             - :func:`feed_interpolators`
         """
-        logger.trace("Loading feed face: (size: %s, coverage_ratio: %s, dtype: %s)",
-                     size, coverage_ratio, dtype)
+        logger.trace("Loading feed face: (size: %s, coverage_ratio: %s, dtype: %s, "
+                     "is_aligned_face: %s)", size, coverage_ratio, dtype, is_aligned_face)
 
         self.feed["size"] = size
         self.feed["padding"] = self._padding_from_coverage(size, coverage_ratio)
         self.feed["matrix"] = get_align_mat(self)
-        face = AlignerExtract().transform(image, self.feed["matrix"], size, self.feed["padding"])
+        if is_aligned_face:
+            original_size = image.shape[0]
+            interp = cv2.INTER_CUBIC if original_size < size else cv2.INTER_AREA
+            face = cv2.resize(image, (size, size), interpolation=interp)
+        else:
+            face = AlignerExtract().transform(image,
+                                              self.feed["matrix"],
+                                              size,
+                                              self.feed["padding"])
         self.feed["face"] = face if dtype is None else face.astype(dtype)
 
         logger.trace("Loaded feed face. (face_shape: %s, matrix: %s)",
@@ -510,11 +522,22 @@ class Mask():
         self._frame_dims = None
         self._interpolator = None
 
+        self._blur_kernel = 0
+        self._threshold = 0.0
+
     @property
     def mask(self):
-        """ numpy.ndarray: The mask at the size of :attr:`stored_size` """
-        return np.frombuffer(decompress(self._mask),
-                             dtype="uint8").reshape((self.stored_size, self.stored_size, 1))
+        """ numpy.ndarray: The mask at the size of :attr:`stored_size` with any requested blurring
+        and threshold amount applied."""
+        dims = (self.stored_size, self.stored_size, 1)
+        mask = np.frombuffer(decompress(self._mask), dtype="uint8").reshape(dims)
+        if self._threshold != 0.0:
+            mask[mask < self._threshold] = 0.0
+            mask[mask > 255.0 - self._threshold] = 255.0
+        if self._blur_kernel != 0:
+            mask = cv2.GaussianBlur(mask, (self._blur_kernel, self._blur_kernel), 0)[..., None]
+        logger.trace("mask shape: %s", mask.shape)
+        return mask
 
     @property
     def full_frame_mask(self):
@@ -558,6 +581,22 @@ class Mask():
                            interpolation=cv2.INTER_AREA) * 255.0).astype("uint8")
         self._mask = compress(mask)
 
+    def set_blur_kernel_and_threshold(self, blur_kernel=0, threshold=0):
+        """ Set the internal blur kernel and threshold amount for returned masks
+
+        Parameters
+        ----------
+        blur_kernel: int, optional
+            The kernel size, in pixels to apply gaussian blurring to the mask. Set to 0 for no
+            blurring. Default: 0
+        threshold: int, optional
+            The threshold amount to minimize/maximize mask values to 0 and 100. Percentage value.
+            Default: 0
+        """
+        logger.trace("blur_kernel: %s, threshold: %s", blur_kernel, threshold)
+        self._blur_kernel = blur_kernel
+        self._threshold = (threshold / 100.0) * 255.0
+
     def _adjust_affine_matrix(self, mask_size, affine_matrix):
         """ Adjust the affine matrix for the mask's storage size
 
diff --git a/plugins/extract/mask/_base.py b/plugins/extract/mask/_base.py
index 6dca64d..e76d159 100644
--- a/plugins/extract/mask/_base.py
+++ b/plugins/extract/mask/_base.py
@@ -36,17 +36,15 @@ class Masker(Extractor):  # pylint:disable=abstract-method
         https://github.com/deepfakes-models/faceswap-models for more information
     model_filename: str
         The name of the model file to be loaded
+    image_is_aligned: bool, optional
+        Indicates that the passed in image is an aligned face rather than a frame.
+        Default: ``False``
 
     Other Parameters
     ----------------
     configfile: str, optional
         Path to a custom configuration ``ini`` file. Default: Use system configfile
 
-    Attributes
-    ----------
-    blur_kernel, int
-        The size of the kernel for applying gaussian blur to the output of the mask
-
     See Also
     --------
     plugins.extract.align : Aligner plugins
@@ -55,16 +53,17 @@ class Masker(Extractor):  # pylint:disable=abstract-method
     plugins.extract.align._base : Aligner parent class for extraction plugins.
     """
 
-    def __init__(self, git_model_id=None, model_filename=None, configfile=None):
+    def __init__(self, git_model_id=None, model_filename=None, configfile=None,
+                 image_is_aligned=False):
         logger.debug("Initializing %s: (configfile: %s, )", self.__class__.__name__, configfile)
         super().__init__(git_model_id,
                          model_filename,
                          configfile=configfile)
         self.input_size = 256  # Override for model specific input_size
-        self.blur_kernel = 5  # Override for model specific blur_kernel size
         self.coverage_ratio = 1.0  # Override for model specific coverage_ratio
 
         self._plugin_type = "mask"
+        self._image_is_aligned = image_is_aligned
         self._storage_name = self.__module__.split(".")[-1].replace("_", "-")
         self._storage_size = 128  # Size to store masks at. Leave this at default
         self._faces_per_filename = dict()  # Tracking for recompiling face batches
@@ -121,7 +120,8 @@ class Masker(Extractor):  # pylint:disable=abstract-method
                 face.load_feed_face(face.image,
                                     size=self.input_size,
                                     coverage_ratio=1.0,
-                                    dtype="float32")
+                                    dtype="float32",
+                                    is_aligned_face=self._image_is_aligned)
                 batch.setdefault("detected_faces", []).append(face)
                 batch.setdefault("filename", []).append(item["filename"])
                 batch.setdefault("image", []).append(item["image"])
@@ -190,14 +190,6 @@ class Masker(Extractor):  # pylint:disable=abstract-method
             :class:`lib.faces_detect.DetectedFace` objects.
 
         """
-        # TODO Migrate these settings to retrieval rather than storage
-        # if self.blur_kernel is not None:
-        #    predicted = np.array([cv2.GaussianBlur(mask, (self.blur_kernel, self.blur_kernel), 0)
-        #                          for mask in batch["prediction"]])
-        # else:
-        #    predicted = batch["prediction"]
-        # predicted[predicted < 0.04] = 0.0
-        # predicted[predicted > 0.96] = 1.0
         for mask, face in zip(batch["prediction"], batch["detected_faces"]):
             face.add_mask(self._storage_name,
                           mask,
diff --git a/plugins/extract/mask/none.py b/plugins/extract/mask/none.py
deleted file mode 100644
index a6c31eb..0000000
--- a/plugins/extract/mask/none.py
+++ /dev/null
@@ -1,36 +0,0 @@
-#!/usr/bin/env python3
-""" Dummy empty Mask for faceswap.py """
-
-import numpy as np
-from ._base import Masker, logger
-
-
-class Mask(Masker):
-    """ Perform transformation to align and get landmarks """
-    def __init__(self, **kwargs):
-        git_model_id = None
-        model_filename = None
-        super().__init__(git_model_id=git_model_id, model_filename=model_filename, **kwargs)
-        self.input_size = 256
-        self.name = "None"
-        self.vram = 0
-        self.vram_per_batch = 0
-        self.batchsize = 1
-
-    def init_model(self):
-        logger.debug("No mask model to initialize")
-
-    def process_input(self, batch):
-        """ Compile the detected faces for prediction """
-        batch["feed"] = np.zeros((self.batchsize, self.input_size, self.input_size, 1),
-                                 dtype="float32")
-        return batch
-
-    def predict(self, batch):
-        """ Run model to get predictions """
-        batch["prediction"] = np.ones_like(batch["feed"], dtype="float32")
-        return batch
-
-    def process_output(self, batch):
-        """ Compile found faces for output """
-        return batch
diff --git a/plugins/extract/pipeline.py b/plugins/extract/pipeline.py
index badb90b..ba0a7d6 100644
--- a/plugins/extract/pipeline.py
+++ b/plugins/extract/pipeline.py
@@ -5,8 +5,8 @@ Return a requested detector/aligner pipeline
 Tensorflow does not like to release GPU VRAM, so parallel plugins need to be managed to work
 together.
 
-This module sets up a pipeline for the extraction workflow, loading align and detect plugins
-either in parallel or in series, giving easy access to input and output.
+This module sets up a pipeline for the extraction workflow, loading detect, align and mask
+plugins either in parallel or in series, giving easy access to input and output.
 
  """
 
@@ -50,6 +50,9 @@ class Extractor():
     normalize_method: {`None`, 'clahe', 'hist', 'mean'}, optional
         Used to set the :attr:`~plugins.extract.align.normalize_method` attribute. Normalize the
         images fed to the aligner.Default: ``None``
+    image_is_aligned: bool, optional
+        Used to set the :attr:`~plugins.extract.mask.image_is_aligned` attribute. Indicates to the
+        masker that the fed in image is an aligned face rather than a frame.Default: ``False``
 
     Attributes
     ----------
@@ -59,19 +62,19 @@ class Extractor():
     """
     def __init__(self, detector, aligner, masker, configfile=None,
                  multiprocess=False, rotate_images=None, min_size=20,
-                 normalize_method=None):
+                 normalize_method=None, image_is_aligned=False):
         logger.debug("Initializing %s: (detector: %s, aligner: %s, masker: %s, "
                      "configfile: %s, multiprocess: %s, rotate_images: %s, min_size: %s, "
-                     "normalize_method: %s)",
+                     "normalize_method: %s, image_is_aligned: %s)",
                      self.__class__.__name__, detector, aligner, masker, configfile,
-                     multiprocess, rotate_images, min_size, normalize_method)
-        self._flow = ["detect", "align", "mask"]
+                     multiprocess, rotate_images, min_size, normalize_method, image_is_aligned)
+        self._flow = self._set_flow(detector, aligner, masker)
         self.phase = self._flow[0]
         self._queue_size = 32
         self._vram_buffer = 256  # Leave a buffer for VRAM allocation
         self._detect = self._load_detect(detector, rotate_images, min_size, configfile)
         self._align = self._load_align(aligner, configfile, normalize_method)
-        self._mask = self._load_mask(masker, configfile)
+        self._mask = self._load_mask(masker, image_is_aligned, configfile)
         self._is_parallel = self._set_parallel_processing(multiprocess)
         self._set_extractor_batchsize()
         self._queues = self._add_queues()
@@ -239,7 +242,7 @@ class Extractor():
         VRAM for parallel plugins does not stack in a linear manner. Calculating the precise
         scaling for any given plugin combination is non trivial, however the following are
         calculations based on running 2-5 plugins in parallel using s3fd, fan, unet, vgg-clear
-        and vgg-obstructed. The worst ratio is selected for each combination, plus a litle extra
+        and vgg-obstructed. The worst ratio is selected for each combination, plus a little extra
         to ensure that vram is not used up.
 
         If OOM errors are being reported, then these ratios should be relaxed some more
@@ -302,6 +305,20 @@ class Extractor():
         logger.trace("Active plugins: %s", retval)
         return retval
 
+    @staticmethod
+    def _set_flow(detector, aligner, masker):
+        """ Set the flow list based on the input plugins """
+        logger.debug("detector: %s, aligner: %s, masker: %s", detector, aligner, masker)
+        retval = []
+        if detector is not None and detector.lower() != "none":
+            retval.append("detect")
+        if aligner is not None and aligner.lower() != "none":
+            retval.append("align")
+        if masker is not None and masker.lower() != "none":
+            retval.append("mask")
+        logger.debug("flow: %s", retval)
+        return retval
+
     def _add_queues(self):
         """ Add the required processing queues to Queue Manager """
         queues = dict()
@@ -350,6 +367,9 @@ class Extractor():
     @staticmethod
     def _load_align(aligner, configfile, normalize_method):
         """ Set global arguments and load aligner plugin """
+        if aligner is None or aligner.lower() == "none":
+            logger.debug("No aligner selected. Returning None")
+            return None
         aligner_name = aligner.replace("-", "_").lower()
         logger.debug("Loading Aligner: '%s'", aligner_name)
         aligner = PluginLoader.get_aligner(aligner_name)(configfile=configfile,
@@ -359,6 +379,9 @@ class Extractor():
     @staticmethod
     def _load_detect(detector, rotation, min_size, configfile):
         """ Set global arguments and load detector plugin """
+        if detector is None or detector.lower() == "none":
+            logger.debug("No detector selected. Returning None")
+            return None
         detector_name = detector.replace("-", "_").lower()
         logger.debug("Loading Detector: '%s'", detector_name)
         detector = PluginLoader.get_detector(detector_name)(rotation=rotation,
@@ -367,11 +390,15 @@ class Extractor():
         return detector
 
     @staticmethod
-    def _load_mask(masker, configfile):
+    def _load_mask(masker, image_is_aligned, configfile):
         """ Set global arguments and load masker plugin """
+        if masker is None or masker.lower() == "none":
+            logger.debug("No masker selected. Returning None")
+            return None
         masker_name = masker.replace("-", "_").lower()
         logger.debug("Loading Masker: '%s'", masker_name)
-        masker = PluginLoader.get_masker(masker_name)(configfile=configfile)
+        masker = PluginLoader.get_masker(masker_name)(image_is_aligned=image_is_aligned,
+                                                      configfile=configfile)
         return masker
 
     def _launch_plugin(self, phase):
diff --git a/plugins/plugin_loader.py b/plugins/plugin_loader.py
index c23e2fd..8f162af 100644
--- a/plugins/plugin_loader.py
+++ b/plugins/plugin_loader.py
@@ -164,14 +164,15 @@ class PluginLoader():
         return getattr(module, ttl)
 
     @staticmethod
-    def get_available_extractors(extractor_type):
+    def get_available_extractors(extractor_type, add_none=False):
         """ Return a list of available extractors of the given type
 
         Parameters
         ----------
         extractor_type: {'aligner', 'detector', 'masker'}
             The type of extractor to return the plugins for
-
+        add_none: bool, optional
+            Append "none" to the list of returned plugins. Default: False
         Returns
         -------
         list:
@@ -186,6 +187,8 @@ class PluginLoader():
                             and not item.name.endswith("defaults.py")
                             and item.name.endswith(".py")
                             and item.name != "manual.py")
+        if add_none:
+            extractors.insert(0, "none")
         return extractors
 
     @staticmethod

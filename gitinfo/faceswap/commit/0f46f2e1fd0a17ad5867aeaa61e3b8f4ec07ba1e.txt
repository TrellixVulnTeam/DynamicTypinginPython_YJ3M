commit 0f46f2e1fd0a17ad5867aeaa61e3b8f4ec07ba1e
Author: kvrooman <vrooman.kyle@gmail.com>
Date:   Sun Dec 30 03:39:02 2018 -0600

    Improvement to blur estimates - normalize by image size & efficiency â€¦ (#563)
    
    Laplacian requires grayscale image, yet code previously loaded as either gray or color and then cast to gray. Reading as grayscale off the bat avoids the conversion and if query
    OpenCV defaults to using double precision ( 64float ) in the Lapacian calculation. This is overkill for this task and single ( 32float ) is sufficient and speedier
    Blur estimate
    3. As image size increases and the amount of pixels increase, the gradient between any two pixels will decrease accordingly as there are more pixels to spread the difference over. This dampening effect on the gradient has a corresponding effect on variance and skews the blur estimate to give different results on differnet size images. Normalizing by pixel number attempts to counteract this effect

diff --git a/tools/sort.py b/tools/sort.py
index c77d316..313eea3 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -162,7 +162,7 @@ class Sort():
         input_dir = self.args.input_dir
 
         logger.info("Sorting by blur...")
-        img_list = [[img, self.estimate_blur(cv2.imread(img))]
+        img_list = [[img, self.estimate_blur(img)]
                     for img in
                     tqdm(self.find_images(input_dir),
                          desc="Loading",
@@ -756,13 +756,16 @@ class Sort():
         return result
 
     @staticmethod
-    def estimate_blur(image):
-        """ Estimate the amount of blur an image has """
-        if image.ndim == 3:
-            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
-
-        blur_map = cv2.Laplacian(image, cv2.CV_64F)
-        score = np.var(blur_map)
+    def estimate_blur(image_file):
+        """
+        Estimate the amount of blur an image has
+        with the variance of the Laplacian.
+        Normalize by pixel number to offset the effect
+        of image size on pixel gradients & variance
+        """
+        image = cv2.imread(image_file,cv2.IMREAD_GRAYSCALE)
+        blur_map = cv2.Laplacian(image, cv2.CV_32F)
+        score = np.var(blur_map)  / np.sqrt(image.shape[0] * image.shape[1])
         return score
 
     @staticmethod

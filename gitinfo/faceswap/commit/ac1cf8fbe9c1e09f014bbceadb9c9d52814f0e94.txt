commit ac1cf8fbe9c1e09f014bbceadb9c9d52814f0e94
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sun Dec 8 10:54:26 2019 +0000

    lib.alignments: improve re-extraction speed by 500%

diff --git a/lib/image.py b/lib/image.py
index 3004503..7948c69 100644
--- a/lib/image.py
+++ b/lib/image.py
@@ -321,7 +321,7 @@ def count_frames(filename, fast=False):
             logger.debug("frame line: %s", output)
             if not init_tqdm:
                 logger.debug("Initializing tqdm")
-                pbar = tqdm(desc="Counting Video Frames", total=duration, unit="secs")
+                pbar = tqdm(desc="Counting Video Frames", leave=False, total=duration, unit="secs")
                 init_tqdm = True
             time_idx = output.find("time=") + len("time=")
             frame_idx = output.find("frame=") + len("frame=")
diff --git a/tools/lib_alignments/jobs.py b/tools/lib_alignments/jobs.py
index b7e6a16..e26391c 100644
--- a/tools/lib_alignments/jobs.py
+++ b/tools/lib_alignments/jobs.py
@@ -401,97 +401,143 @@ class Draw():
         self.frames.save_image(self.output_folder, frame, image)
 
 
-class Extract():
-    """ Re-extract faces from source frames based on
-        Alignment data """
+class Extract():  # pylint:disable=too-few-public-methods
+    """ Re-extract faces from source frames based on Alignment data
+
+    Parameters
+    ----------
+    alignments: :class:`tools.lib_alignments.media.AlignmentData`
+        The alignments data loaded from an alignments file for this rename job
+    arguments: :class:`argparse.Namespace`
+        The :mod:`argparse` arguments as passed in from :mod:`tools.py`
+    """
     def __init__(self, alignments, arguments):
         logger.debug("Initializing %s: (arguments: %s)", self.__class__.__name__, arguments)
-        self.arguments = arguments
-        self.alignments = alignments
-        self.faces_dir = arguments.faces_dir
-        self.frames = Frames(arguments.frames_dir)
-        self.extracted_faces = ExtractedFaces(self.frames,
-                                              self.alignments,
-                                              size=arguments.size,
-                                              align_eyes=arguments.align_eyes)
+        self._arguments = arguments
+        self._alignments = alignments
+        self._faces_dir = arguments.faces_dir
+        self._frames = Frames(arguments.frames_dir)
+        self._extracted_faces = ExtractedFaces(self._frames,
+                                               self._alignments,
+                                               size=arguments.size,
+                                               align_eyes=arguments.align_eyes)
         logger.debug("Initialized %s", self.__class__.__name__)
 
     def process(self):
-        """ Run extraction """
+        """ Run the re-extraction from Alignments file process"""
         logger.info("[EXTRACT FACES]")  # Tidy up cli output
-        self.check_folder()
-        self.export_faces()
+        self._check_folder()
+        self._export_faces()
 
-    def check_folder(self):
-        """ Check that the faces folder doesn't pre-exist
-            and create """
+    def _check_folder(self):
+        """ Check that the faces folder doesn't pre-exist and create. """
         err = None
-        if not self.faces_dir:
+        if not self._faces_dir:
             err = "ERROR: Output faces folder not provided."
-        elif not os.path.isdir(self.faces_dir):
-            logger.debug("Creating folder: '%s'", self.faces_dir)
-            os.makedirs(self.faces_dir)
-        elif os.listdir(self.faces_dir):
-            err = "ERROR: Output faces folder should be empty: '{}'".format(self.faces_dir)
+        elif not os.path.isdir(self._faces_dir):
+            logger.debug("Creating folder: '%s'", self._faces_dir)
+            os.makedirs(self._faces_dir)
+        elif os.listdir(self._faces_dir):
+            err = "ERROR: Output faces folder should be empty: '{}'".format(self._faces_dir)
         if err:
             logger.error(err)
             exit(0)
-        logger.verbose("Creating output folder at '%s'", self.faces_dir)
+        logger.verbose("Creating output folder at '%s'", self._faces_dir)
 
-    def export_faces(self):
-        """ Export the faces """
+    def _export_faces(self):
+        """ Export the faces to the output folder and update the alignments file with
+        new hashes. """
         extracted_faces = 0
-        skip_num = self.arguments.extract_every_n
-        if skip_num != 1:
-            logger.info("Skipping every %s frames", skip_num)
-        for idx, frame in enumerate(tqdm(self.frames.file_list_sorted,
-                                         desc="Saving extracted faces")):
-            frame_name = frame["frame_fullname"]
-            if idx % skip_num != 0:
-                logger.trace("Skipping '%s' due to extract_every_n = %s", frame_name, skip_num)
+        skip_list = self._set_skip_list()
+        count = self._frames.count if skip_list is None else self._frames.count - len(skip_list)
+        for filename, image in tqdm(self._frames.stream(skip_list=skip_list),
+                                    total=count, desc="Saving extracted faces"):
+            if not self._alignments.frame_exists(filename):
+                logger.verbose("Skipping '%s' - Alignments not found", filename)
                 continue
+            extracted_faces += self._output_faces(filename, image)
+        if extracted_faces != 0 and not self._arguments.large:
+            self._alignments.save()
+        logger.info("%s face(s) extracted", extracted_faces)
 
-            if not self.alignments.frame_exists(frame_name):
-                logger.verbose("Skipping '%s' - Alignments not found", frame_name)
-                continue
+    def _set_skip_list(self):
+        """ Set the indices for frames that should be skipped based on the `extract_every_n`
+        command line option.
+
+        Returns
+        -------
+        list or ``None``
+            A list of indices to be skipped if extract_every_n is not `1` otherwise
+            returns ``None``
+        """
+        skip_num = self._arguments.extract_every_n
+        if skip_num == 1:
+            logger.debug("Not skipping any frames")
+            return None
+        skip_list = []
+        for idx, item in enumerate(self._frames.file_list_sorted):
+            if idx % skip_num != 0:
+                logger.trace("Adding image '%s' to skip list due to extract_every_n = %s",
+                             item["frame_fullname"], skip_num)
+                skip_list.append(idx)
+        logger.debug("Adding skip list: %s", skip_list)
+        return skip_list
 
-            extracted_faces += self.output_faces(frame)
+    def _output_faces(self, filename, image):
+        """ For each frame save out the faces and update the face hash back to alignments
 
-        if extracted_faces != 0 and not self.arguments.large:
-            self.alignments.save()
-        logger.info("%s face(s) extracted", extracted_faces)
+        Parameters
+        ----------
+        filename: str
+            The filename (without the full path) of the current frame
+        image: :class:`numpy.ndarray`
+            The full frame that faces are to be extracted from
 
-    def output_faces(self, frame):
-        """ Output the frame's faces to file """
-        logger.trace("Outputting frame: %s", frame)
+        Returns
+        -------
+        int
+            The total number of faces that have been extracted
+        """
+        logger.trace("Outputting frame: %s", filename)
         face_count = 0
-        frame_fullname = frame["frame_fullname"]
-        frame_name = frame["frame_name"]
-        extension = os.path.splitext(frame_fullname)[1]
-        faces = self.select_valid_faces(frame_fullname)
+        frame_name, extension = os.path.splitext(filename)
+        faces = self._select_valid_faces(filename, image)
 
         for idx, face in enumerate(faces):
             output = "{}_{}{}".format(frame_name, str(idx), extension)
-            if self.arguments.large:
-                self.frames.save_image(self.faces_dir, output, face.aligned_face)
+            if self._arguments.large:
+                self._frames.save_image(self._faces_dir, output, face.aligned_face)
             else:
-                output = os.path.join(self.faces_dir, output)
-                f_hash = self.extracted_faces.save_face_with_hash(output,
-                                                                  extension,
-                                                                  face.aligned_face)
-                self.alignments.data[frame_fullname][idx]["hash"] = f_hash
+                output = os.path.join(self._faces_dir, output)
+                f_hash = self._extracted_faces.save_face_with_hash(output,
+                                                                   extension,
+                                                                   face.aligned_face)
+                self._alignments.data[filename][idx]["hash"] = f_hash
             face_count += 1
         return face_count
 
-    def select_valid_faces(self, frame):
-        """ Return valid faces for extraction """
-        faces = self.extracted_faces.get_faces_in_frame(frame)
-        if not self.arguments.large:
+    def _select_valid_faces(self, frame, image):
+        """ Return the aligned faces from a frame that meet the selection criteria,
+
+        Parameters
+        ----------
+        frame: str
+            The filename (without the full path) of the current frame
+        image: :class:`numpy.ndarray`
+            The full frame that faces are to be extracted from
+
+        Returns
+        -------
+        list:
+            List of valid :class:`lib,faces_detect.DetectedFace` objects
+        """
+        faces = self._extracted_faces.get_faces_in_frame(frame, image=image)
+        if not self._arguments.large:
             valid_faces = faces
         else:
-            sizes = self.extracted_faces.get_roi_size_for_frame(frame)
+            sizes = self._extracted_faces.get_roi_size_for_frame(frame)
             valid_faces = [faces[idx] for idx, size in enumerate(sizes)
-                           if size >= self.extracted_faces.size]
+                           if size >= self._extracted_faces.size]
         logger.trace("frame: '%s', total_faces: %s, valid_faces: %s",
                      frame, len(faces), len(valid_faces))
         return valid_faces
diff --git a/tools/lib_alignments/media.py b/tools/lib_alignments/media.py
index cc59ace..4eca7e7 100644
--- a/tools/lib_alignments/media.py
+++ b/tools/lib_alignments/media.py
@@ -14,7 +14,7 @@ from tqdm import tqdm
 from lib.aligner import Extract as AlignerExtract
 from lib.alignments import Alignments, get_serializer
 from lib.faces_detect import DetectedFace
-from lib.image import (count_frames, encode_image_with_hash, read_image,
+from lib.image import (count_frames, encode_image_with_hash, ImagesLoader, read_image,
                        read_image_hash_batch)
 from lib.utils import _image_extensions, _video_extensions
 
@@ -158,6 +158,29 @@ class MediaLoader():
         # image = self.vid_reader.get_next_data()[:, :, ::-1]
         return image
 
+    def stream(self, skip_list=None):
+        """ Load the images in :attr:`folder` in the order they are received from
+        :class:`lib.image.ImagesLoader` in a background thread.
+
+        Parameters
+        ----------
+        skip_list: list, optional
+            A list of frame indices that should not be loaded. Pass ``None`` if all images should
+            be loaded. Default: ``None``
+
+        Yields
+        ------
+        str
+            The filename of the image that is being returned
+        numpy.ndarray
+            The image that has been loaded from disk
+        """
+        loader = ImagesLoader(self.folder, queue_size=32)
+        if skip_list is not None:
+            loader.add_skip_list(skip_list)
+        for filename, image in loader.load():
+            yield filename, image
+
     @staticmethod
     def save_image(output_folder, filename, image):
         """ Save an image """
@@ -275,7 +298,7 @@ class ExtractedFaces():
         self.faces = list()
         logger.trace("Initialized %s", self.__class__.__name__)
 
-    def get_faces(self, frame):
+    def get_faces(self, frame, image=None):
         """ Return faces and transformed landmarks
             for each face in a given frame with it's alignments"""
         logger.trace("Getting faces for frame: '%s'", frame)
@@ -285,8 +308,8 @@ class ExtractedFaces():
         if not alignments:
             self.faces = list()
             return
-        image = self.frames.load_image(frame)
-        self.faces = [self.extract_one_face(alignment, image.copy()) for alignment in alignments]
+        image = self.frames.load_image(frame) if image is None else image
+        self.faces = [self.extract_one_face(alignment, image) for alignment in alignments]
         self.current_frame = frame
 
     def extract_one_face(self, alignment, image):
@@ -299,11 +322,11 @@ class ExtractedFaces():
         face = self.align_eyes(face, image) if self.align_eyes_bool else face
         return face
 
-    def get_faces_in_frame(self, frame, update=False):
+    def get_faces_in_frame(self, frame, update=False, image=None):
         """ Return the faces for the selected frame """
         logger.trace("frame: '%s', update: %s", frame, update)
         if self.current_frame != frame or update:
-            self.get_faces(frame)
+            self.get_faces(frame, image=image)
         return self.faces
 
     def get_roi_size_for_frame(self, frame):

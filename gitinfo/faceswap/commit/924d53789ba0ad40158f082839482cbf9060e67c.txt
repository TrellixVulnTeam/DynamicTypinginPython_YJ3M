commit 924d53789ba0ad40158f082839482cbf9060e67c
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Tue Mar 10 14:48:12 2020 +0000

    Core updates (#982)
    
    * plugins.extract.align
      - Expose normalization method
    
    * lib.gui core updates
      - Minor updates to support future development.

diff --git a/lib/gui/control_helper.py b/lib/gui/control_helper.py
index f7ad70d..7143f05 100644
--- a/lib/gui/control_helper.py
+++ b/lib/gui/control_helper.py
@@ -321,10 +321,12 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         The width that labels for controls should be set to.
         Defaults to 20
     columns: int, optional
+        The initial number of columns to set the layout for. Default: 1
+    max_columns: int, optional
         The maximum number of columns that this control panel should be able
         to accommodate. Setting to 1 means that there will only be 1 column
         regardless of how wide the control panel is. Higher numbers will
-        dynamically fill extra columns if space permits. Defaults to 1
+        dynamically fill extra columns if space permits. Defaults to 4
     option_columns: int, optional
         For check-button and radio-button containers, how many options should
         be displayed on each row. Defaults to 4
@@ -334,14 +336,19 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
     blank_nones: bool, optional
         How the control panel should handle None values. If set to True then None values will be
         converted to empty strings. Default: False
+    scrollbar: bool, optional
+        ``True`` if a scrollbar should be added to the control panel, otherwise ``False``.
+        Default: ``True``
     """
 
     def __init__(self, parent, options,  # pylint:disable=too-many-arguments
-                 label_width=20, columns=1, option_columns=4, header_text=None, blank_nones=True):
+                 label_width=20, columns=1, max_columns=4, option_columns=4, header_text=None,
+                 blank_nones=True, scrollbar=True):
         logger.debug("Initializing %s: (parent: '%s', options: %s, label_width: %s, columns: %s, "
-                     "option_columns: %s, header_text: %s, blank_nones: %s)",
-                     self.__class__.__name__, parent, options, label_width, columns,
-                     option_columns, header_text, blank_nones)
+                     "max_columns: %s, option_columns: %s, header_text: %s, blank_nones: %s, "
+                     "scrollbar: %s)",
+                     self.__class__.__name__, parent, options, label_width, columns, max_columns,
+                     option_columns, header_text, blank_nones, scrollbar)
         super().__init__(parent)
 
         self.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
@@ -350,18 +357,18 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         self.controls = []
         self.label_width = label_width
         self.columns = columns
+        self.max_columns = max_columns
         self.option_columns = option_columns
 
         self.header_text = header_text
         self.group_frames = dict()
 
-        self.canvas = tk.Canvas(self, bd=0, highlightthickness=0)
-        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
+        self._canvas = tk.Canvas(self, bd=0, highlightthickness=0)
+        self._canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 
         self.mainframe, self.optsframe = self.get_opts_frame()
-        self.optscanvas = self.canvas.create_window((0, 0), window=self.mainframe, anchor=tk.NW)
-
-        self.build_panel(blank_nones)
+        self._optscanvas = self._canvas.create_window((0, 0), window=self.mainframe, anchor=tk.NW)
+        self.build_panel(blank_nones, scrollbar)
 
         logger.debug("Initialized %s", self.__class__.__name__)
 
@@ -373,12 +380,12 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
 
     def get_opts_frame(self):
         """ Return an auto-fill container for the options inside a main frame """
-        mainframe = ttk.Frame(self.canvas)
+        mainframe = ttk.Frame(self._canvas)
         if self.header_text is not None:
             self.add_info(mainframe)
         optsframe = ttk.Frame(mainframe, name="opts_frame")
         optsframe.pack(expand=True, fill=tk.BOTH)
-        holder = AutoFillContainer(optsframe, self.columns)
+        holder = AutoFillContainer(optsframe, self.columns, self.max_columns)
         logger.debug("Opts frames: '%s'", holder)
         return mainframe, holder
 
@@ -404,11 +411,12 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
             info.bind("<Configure>", self._adjust_wraplength)
             info.pack(fill=tk.X, padx=0, pady=0, expand=True, side=tk.TOP)
 
-    def build_panel(self, blank_nones):
+    def build_panel(self, blank_nones, scrollbar):
         """ Build the options frame for this command """
         logger.debug("Add Config Frame")
-        self.add_scrollbar()
-        self.canvas.bind("<Configure>", self.resize_frame)
+        if scrollbar:
+            self.add_scrollbar()
+        self._canvas.bind("<Configure>", self.resize_frame)
 
         for option in self.options:
             group_frame = self.get_group_frame(option.group)
@@ -452,21 +460,21 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
     def add_scrollbar(self):
         """ Add a scrollbar to the options frame """
         logger.debug("Add Config Scrollbar")
-        scrollbar = ttk.Scrollbar(self, command=self.canvas.yview)
+        scrollbar = ttk.Scrollbar(self, command=self._canvas.yview)
         scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
-        self.canvas.config(yscrollcommand=scrollbar.set)
+        self._canvas.config(yscrollcommand=scrollbar.set)
         self.mainframe.bind("<Configure>", self.update_scrollbar)
         logger.debug("Added Config Scrollbar")
 
     def update_scrollbar(self, event):  # pylint: disable=unused-argument
         """ Update the options frame scrollbar """
-        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
+        self._canvas.configure(scrollregion=self._canvas.bbox("all"))
 
     def resize_frame(self, event):
         """ Resize the options frame to fit the canvas """
         logger.debug("Resize Config Frame")
         canvas_width = event.width
-        self.canvas.itemconfig(self.optscanvas, width=canvas_width)
+        self._canvas.itemconfig(self._optscanvas, width=canvas_width)
         self.optsframe.rearrange_columns(canvas_width)
         logger.debug("Resized Config Frame")
 
@@ -476,21 +484,22 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
             otherwise in a standard frame """
         logger.debug("Add Options CheckButtons Frame")
         chk_frame = ttk.Frame(frame, name="chkbuttons")
-        holder = AutoFillContainer(chk_frame, self.option_columns)
+        holder = AutoFillContainer(chk_frame, self.option_columns, self.option_columns)
         logger.debug("Added Options CheckButtons Frame")
         return holder
 
 
 class AutoFillContainer():
     """ A container object that auto-fills columns """
-    def __init__(self, parent, columns):
-        logger.debug("Initializing: %s: (parent: %s, columns: %s)", self.__class__.__name__,
-                     parent, columns)
-        self.max_columns = 4
+    def __init__(self, parent, initial_columns, max_columns):
+        logger.debug("Initializing: %s: (parent: %s, initial_columns: %s, max_columns: %s)",
+                     self.__class__.__name__, parent, initial_columns, max_columns)
+        self.max_columns = max_columns
+        self.columns = initial_columns
+        self.parent = parent
+#        self.columns = min(columns, self.max_columns)
         self.single_column_width = self.scale_column_width(288, 9)
         self.max_width = self.max_columns * self.single_column_width
-        self.parent = parent
-        self.columns = min(columns, self.max_columns)
         self._items = 0
         self._idx = 0
         self._widget_config = []  # Master list of all children in order
@@ -783,7 +792,7 @@ class ControlBuilder():
         ctl = ttk.LabelFrame(self.frame,
                              text=self.option.title,
                              name="radio_labelframe")
-        radio_holder = AutoFillContainer(ctl, self.option_columns)
+        radio_holder = AutoFillContainer(ctl, self.option_columns, self.option_columns)
         for choice in self.option.choices:
             radio = ttk.Radiobutton(radio_holder.subframe,
                                     text=choice.replace("_", " ").title(),
@@ -845,6 +854,7 @@ class ControlBuilder():
         if self.option.choices:
             logger.debug("Adding combo choices: %s", self.option.choices)
             ctl["values"] = [choice for choice in self.option.choices]
+            ctl["state"] = "readonly"
         logger.debug("Added control to Options Frame: %s", self.option.name)
         return ctl
 
diff --git a/lib/gui/custom_widgets.py b/lib/gui/custom_widgets.py
index 4d29092..b40b6fd 100644
--- a/lib/gui/custom_widgets.py
+++ b/lib/gui/custom_widgets.py
@@ -56,10 +56,7 @@ class ContextMenu(tk.Menu):  # pylint: disable=too-many-ancestors
         """
         button = "<Button-2>" if platform.system() == "Darwin" else "<Button-3>"
         logger.debug("Binding '%s' to '%s'", button, self._widget.winfo_class())
-        scaling_factor = get_config().scaling_factor if get_config() is not None else 1.0
-        x_offset = int(34 * scaling_factor)
-        self._widget.bind(button,
-                          lambda event: self.tk_popup(event.x_root + x_offset, event.y_root, 0))
+        self._widget.bind(button, lambda event: self.tk_popup(event.x_root, event.y_root))
 
     def _select_all(self):
         """ Select all for Text or Entry widgets """
@@ -72,6 +69,52 @@ class ContextMenu(tk.Menu):  # pylint: disable=too-many-ancestors
             self._widget.select_range(0, tk.END)
 
 
+class RightClickMenu(tk.Menu):  # pylint: disable=too-many-ancestors
+    """ A Pop up menu that can be bound to a right click mouse event to bring up a context menu
+
+    Parameters
+    ----------
+    labels: list
+        A list of label titles that will appear in the right click menu
+    actions: list
+        A list of python functions that are called when the corresponding label is clicked on
+    hotkeys: list, optional
+        The hotkeys corresponding to the labels. If using hotkeys, then there must be an entry in
+        the list for every label even if they don't all use hotkeys. Labels without a hotkey can be
+        an empty string or ``None``. Passing ``None`` instead of a list means that no actions will
+        be given hotkeys. NB: The hotkey is not bound by this class, that needs to be done in code.
+        Giving hotkeys here means that they will be displayed in the menu though. Default: ``None``
+    """
+    # TODO This should probably be merged with Context Menu
+    def __init__(self, labels, actions, hotkeys=None):
+        logger.debug("Initializing %s: (labels: %s, actions: %s)", self.__class__.__name__, labels,
+                     actions)
+        super().__init__(tearoff=0)
+        self._labels = labels
+        self._actions = actions
+        self._hotkeys = hotkeys
+        self._create_menu()
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    def _create_menu(self):
+        """ Create the menu based on :attr:`_labels` and :attr:`_actions`. """
+        for idx, (label, action) in enumerate(zip(self._labels, self._actions)):
+            kwargs = dict(label=label, command=action)
+            if isinstance(self._hotkeys, (list, tuple)) and self._hotkeys[idx]:
+                kwargs["accelerator"] = self._hotkeys[idx]
+            self.add_command(**kwargs)
+
+    def popup(self, event):
+        """ Pop up the right click menu.
+
+        Parameters
+        ----------
+        event: class:`tkinter.Event`
+            The tkinter mouse event calling this popup
+        """
+        self.tk_popup(event.x_root, event.y_root)
+
+
 class ConsoleOut(ttk.Frame):  # pylint: disable=too-many-ancestors
     """ The Console out section of the GUI.
 
@@ -367,30 +410,48 @@ class _OriginalCommand:
 
 
 class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
-    """ Status Bar for displaying the Status Message and  Progress Bar at the
-    bottom of the GUI. """
+    """ Status Bar for displaying the Status Message and  Progress Bar at the bottom of the GUI.
 
-    def __init__(self, parent):
+    Parameters
+    ----------
+    parent: tkinter object
+        The parent tkinter widget that will hold the status bar
+    hide_status: bool, optional
+        ``True`` to hide the status message that appears at the far left hand side of the status
+        frame otherwise ``False``. Default: ``False``
+    """
+
+    def __init__(self, parent, hide_status=False):
         ttk.Frame.__init__(self, parent)
         self.pack(side=tk.BOTTOM, padx=10, pady=2, fill=tk.X, expand=False)
 
-        self._status_message = tk.StringVar()
+        self._message = tk.StringVar()
         self._pbar_message = tk.StringVar()
         self._pbar_position = tk.IntVar()
 
-        self._status_message.set("Ready")
+        self._message.set("Ready")
 
-        self._status()
+        self._status(hide_status)
         self._pbar = self._progress_bar()
 
     @property
-    def status_message(self):
+    def message(self):
         """:class:`tkinter.StringVar`: The variable to hold the status bar message on the left
         hand side of the status bar. """
-        return self._status_message
+        return self._message
+
+    def _status(self, hide_status):
+        """ Place Status label into left of the status bar.
+
+        Parameters
+        ----------
+        hide_status: bool, optional
+            ``True`` to hide the status message that appears at the far left hand side of the
+            status frame otherwise ``False``
+        """
+        if hide_status:
+            return
 
-    def _status(self):
-        """ Place Status label into left of the status bar. """
         statusframe = ttk.Frame(self)
         statusframe.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=False)
 
@@ -399,7 +460,7 @@ class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
 
         lblstatus = ttk.Label(statusframe,
                               width=40,
-                              textvariable=self._status_message,
+                              textvariable=self._message,
                               anchor=tk.W)
         lblstatus.pack(side=tk.LEFT, anchor=tk.W, fill=tk.X, expand=True)
 
@@ -420,7 +481,7 @@ class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
         pbar.pack_forget()
         return pbar
 
-    def progress_start(self, mode):
+    def start(self, mode):
         """ Set progress bar mode and display,
 
         Parameters
@@ -428,17 +489,17 @@ class StatusBar(ttk.Frame):  # pylint: disable=too-many-ancestors
         mode: ["indeterminate", "determinate"]
             The mode that the progress bar should be executed in
         """
-        self._progress_set_mode(mode)
+        self._set_mode(mode)
         self._pbar.pack()
 
-    def progress_stop(self):
+    def stop(self):
         """ Reset progress bar and hide """
         self._pbar_message.set("")
         self._pbar_position.set(0)
-        self._progress_set_mode("determinate")
+        self._set_mode("determinate")
         self._pbar.pack_forget()
 
-    def _progress_set_mode(self, mode):
+    def _set_mode(self, mode):
         """ Set the progress bar mode """
         self._pbar.config(mode=mode)
         if mode == "indeterminate":
@@ -481,7 +542,7 @@ class Tooltip:
     text: str, optional
         The text to be displayed in the tool-tip. Default: 'widget info'
     waittime: int, optional
-        The time in miliseconds to wait before showing the tool-tip. Default: 400
+        The time in milliseconds to wait before showing the tool-tip. Default: 400
     wraplength: int, optional
         The text length for each line before wrapping. Default: 250
 
@@ -495,19 +556,6 @@ class Tooltip:
     -----
     Adapted from StackOverflow: http://stackoverflow.com/questions/3221956 and
     http://www.daniweb.com/programming/software-development/code/484591/a-tooltip-class-for-tkinter
-
-
-    - Originally written by vegaseat on 2014.09.09.
-    - Modified to include a delay time by Victor Zaccardo on 2016.03.25.
-    - Modified to correct extreme right and extreme bottom behavior by Alberto Vassena on \
-        2016.11.05.
-    - Modified to stay inside the screen whenever the tooltip might go out on the top but still \
-        the screen is higher than the tooltip  by Alberto Vassena on 2016.11.05.
-    - Modified to use the more flexible mouse positioning  by Alberto Vassena on 2016.11.05.
-    - Modified to add customizable background color, padding, waittime and wraplength on creation \
-        by Alberto Vassena on 2016.11.05.
-
-    Tested on Ubuntu 16.04/16.10, running Python 3.5.2
     """
     def __init__(self, widget, *, background="#FFFFEA", pad=(5, 3, 5, 3), text="widget info",
                  waittime=400, wraplength=250):
@@ -529,7 +577,7 @@ class Tooltip:
         self._schedule()
 
     def _on_leave(self, event=None):  # pylint:disable=unused-argument
-        """ Unschedule on a leave event """
+        """ remove schedule on a leave event """
         self._unschedule()
         self._hide()
 
@@ -583,11 +631,9 @@ class Tooltip:
 
             if offscreen_again:
                 # No further checks will be done.
-
                 # TIP:
-                # A further mod might auto-magically augment the
-                # wraplength when the tooltip is too high to be
-                # kept inside the screen.
+                # A further mod might auto-magically augment the wrap length when the tooltip is
+                # too high to be kept inside the screen.
                 y_1 = 0
 
             return x_1, y_1
@@ -596,7 +642,7 @@ class Tooltip:
         pad = self._pad
         widget = self._widget
 
-        # creates a toplevel window
+        # Creates a top level window
         self._topwidget = tk.Toplevel(widget)
         if platform.system() == "Darwin":
             # For Mac OS
diff --git a/lib/gui/popup_configure.py b/lib/gui/popup_configure.py
index 76c90d6..9a7dfd7 100644
--- a/lib/gui/popup_configure.py
+++ b/lib/gui/popup_configure.py
@@ -106,12 +106,12 @@ class ConfigurePlugins(tk.Toplevel):
         """ Build a plugin config page """
         logger.debug("Building plugin config page: '%s'", category)
         plugins = sorted(list(key for key in self.config_cpanel_dict[category].keys()))
-        panel_kwargs = dict(columns=2, option_columns=2, blank_nones=False)
+        panel_kwargs = dict(columns=2, max_columns=2, option_columns=2, blank_nones=False)
         if any(plugin != category for plugin in plugins):
             page = ttk.Notebook(container)
             page.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
             for plugin in plugins:
-                cp_options = [opt for opt in self.config_cpanel_dict[category][plugin].values()]
+                cp_options = list(self.config_cpanel_dict[category][plugin].values())
                 frame = ControlPanel(page,
                                      cp_options,
                                      header_text=self.plugin_info[plugin],
@@ -120,7 +120,7 @@ class ConfigurePlugins(tk.Toplevel):
                 title = title.replace("_", " ").title()
                 page.add(frame, text=title)
         else:
-            cp_options = [opt for opt in self.config_cpanel_dict[category][plugins[0]].values()]
+            cp_options = list(self.config_cpanel_dict[category][plugins[0]].values())
             page = ControlPanel(container,
                                 cp_options,
                                 header_text=self.plugin_info[plugins[0]],
diff --git a/lib/gui/wrapper.py b/lib/gui/wrapper.py
index 1eab26c..c31b843 100644
--- a/lib/gui/wrapper.py
+++ b/lib/gui/wrapper.py
@@ -74,9 +74,9 @@ class ProcessWrapper():
             self.tk_vars["istraining"].set(True)
         print("Loading...")
 
-        self.statusbar.status_message.set("Executing - {}.py".format(self.command))
+        self.statusbar.message.set("Executing - {}.py".format(self.command))
         mode = "indeterminate" if self.command in ("effmpeg", "train") else "determinate"
-        self.statusbar.progress_start(mode)
+        self.statusbar.start(mode)
 
         args = self.build_args(category)
         self.tk_vars["display"].set(self.command)
@@ -126,8 +126,8 @@ class ProcessWrapper():
         self.tk_vars["runningtask"].set(False)
         if self.task.command == "train":
             self.tk_vars["istraining"].set(False)
-        self.statusbar.progress_stop()
-        self.statusbar.status_message.set(message)
+        self.statusbar.stop()
+        self.statusbar.message.set(message)
         self.tk_vars["display"].set(None)
         get_images().delete_preview()
         get_config().session.__init__()
diff --git a/plugins/extract/align/_base.py b/plugins/extract/align/_base.py
index 7690384..885d101 100644
--- a/plugins/extract/align/_base.py
+++ b/plugins/extract/align/_base.py
@@ -56,7 +56,8 @@ class Aligner(Extractor):  # pylint:disable=abstract-method
         super().__init__(git_model_id,
                          model_filename,
                          configfile=configfile)
-        self.normalize_method = normalize_method
+        self._normalize_method = None
+        self.set_normalize_method(normalize_method)
 
         self._plugin_type = "align"
         self._faces_per_filename = dict()  # Tracking for recompiling face batches
@@ -64,6 +65,17 @@ class Aligner(Extractor):  # pylint:disable=abstract-method
         self._output_faces = []
         logger.debug("Initialized %s", self.__class__.__name__)
 
+    def set_normalize_method(self, method):
+        """ Set the normalization method for feeding faces into the aligner.
+
+        Parameters
+        ----------
+        method: {"none", "clahe", "hist", "mean"}
+            The normalization method to apply to faces prior to feeding into the model
+        """
+        method = None if method is None or method.lower() == "none" else method
+        self._normalize_method = method
+
     # << QUEUE METHODS >>> #
     def get_batch(self, queue):
         """ Get items for inputting into the aligner from the queue in batches
@@ -209,10 +221,10 @@ class Aligner(Extractor):  # pylint:disable=abstract-method
 
         The normalization method is dictated by the command line argument `-nh (--normalization)`
         """
-        if self.normalize_method is None:
+        if self._normalize_method is None:
             return faces
         logger.trace("Normalizing faces")
-        meth = getattr(self, "_normalize_{}".format(self.normalize_method.lower()))
+        meth = getattr(self, "_normalize_{}".format(self._normalize_method.lower()))
         faces = [meth(face) for face in faces]
         logger.trace("Normalized faces")
         return faces
diff --git a/plugins/extract/pipeline.py b/plugins/extract/pipeline.py
index 0bb7f55..f1c9e16 100644
--- a/plugins/extract/pipeline.py
+++ b/plugins/extract/pipeline.py
@@ -455,6 +455,17 @@ class Extractor():
                 available_vram = vram_free - vram_required
                 self._set_plugin_batchsize(plugin, available_vram)
 
+    def set_aligner_normalization_method(self, method):
+        """ Change the normalization method for faces fed into the aligner.
+
+        Parameters
+        ----------
+        method: {"none", "clahe", "hist", "mean"}
+            The normalization method to apply to faces prior to feeding into the aligner's model
+        """
+        logger.debug("Setting to: '%s'", method)
+        self._align.set_normalize_method(method)
+
     @staticmethod
     def _set_plugin_batchsize(plugin, available_vram):
         """ Set the batch size for the given plugin based on given available vram.
@@ -525,21 +536,21 @@ class ExtractMedia():
         :attr:`image`. """
         return self._detected_faces
 
-    def get_image_copy(self, colorformat):
+    def get_image_copy(self, color_format):
         """ Get a copy of the image in the requested color format.
 
         Parameters
         ----------
-        colorformat: ['BGR', 'RGB', 'GRAY']
+        color_format: ['BGR', 'RGB', 'GRAY']
             The requested color format of :attr:`image`
 
         Returns
         -------
         :class:`numpy.ndarray`:
-            A copy of :attr:`image` in the requested :attr:`colorformat`
+            A copy of :attr:`image` in the requested :attr:`color_format`
         """
-        logger.trace("Requested color format '%s' for frame '%s'", colorformat, self._filename)
-        image = getattr(self, "_image_as_{}".format(colorformat.lower()))()
+        logger.trace("Requested color format '%s' for frame '%s'", color_format, self._filename)
+        image = getattr(self, "_image_as_{}".format(color_format.lower()))()
         return image
 
     def add_detected_faces(self, faces):

commit 8085b4a80bc406f32d4d960a77de4c643a716946
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Thu Oct 31 11:19:29 2019 +0000

    lib.logger - Remove newlines from log messages

diff --git a/lib/image.py b/lib/image.py
index 52c21b0..d3047ae 100644
--- a/lib/image.py
+++ b/lib/image.py
@@ -262,26 +262,40 @@ def batch_convert_color(batch, colorspace):
 # <<< VIDEO UTILS >>> #
 # ################### #
 
-def count_frames(filename):
+def count_frames(filename, fast=False):
     """ Count the number of frames in a video file
 
-    Unfortunately there is no guaranteed accurate way to get a count of video frames
-    without iterating through the video.
+    There is no guaranteed accurate way to get a count of video frames without iterating through
+    a video and decoding every frame.
 
-    This counts the frames, displaying a progress bar to keep the user abreast of progress
+    :func:`count_frames` can return an accurate count (albeit fairly slowly) or a possibly less
+    accurate count, depending on the :attr:`fast` parameter. A progress bar is displayed.
 
     Parameters
     ----------
     filename: str
         Full path to the video to return the frame count from.
+    fast: bool, optional
+        Whether to count the frames without decoding them. This is significantly faster but
+        accuracy is not guaranteed. Default: ``False``.
 
     Returns
     -------
-    int: The number of frames in the given video file.
+    int:
+        The number of frames in the given video file.
+
+    Example
+    -------
+    >>> filename = "/path/to/video.mp4"
+    >>> frame_count = count_frames(filename)
     """
     assert isinstance(filename, str), "Video path must be a string"
 
-    cmd = [im_ffm.get_ffmpeg_exe(), "-i", filename, "-map", "0:v:0", "-f", "null", "-"]
+    cmd = [im_ffm.get_ffmpeg_exe(), "-i", filename, "-map", "0:v:0"]
+    if fast:
+        cmd.extend(["-c", "copy"])
+    cmd.extend(["-f", "null", "-"])
+
     logger.debug("FFMPEG Command: '%s'", " ".join(cmd))
     process = subprocess.Popen(cmd,
                                stderr=subprocess.STDOUT,
diff --git a/lib/logger.py b/lib/logger.py
index 0d4b2fa..c0a934d 100644
--- a/lib/logger.py
+++ b/lib/logger.py
@@ -10,8 +10,6 @@ import traceback
 from datetime import datetime
 from tqdm import tqdm
 
-from numpy import ndarray
-
 
 class FaceswapLogger(logging.Logger):
     """ Create custom logger  with custom levels """
@@ -40,35 +38,31 @@ class FaceswapLogger(logging.Logger):
 
 
 class FaceswapFormatter(logging.Formatter):
-    """ Override formatter to strip newlines from logger arguments """
+    """ Override formatter to strip newlines the final message """
+
     def format(self, record):
-        if isinstance(record.msg, str) and ("\n" in record.msg or "\r" in record.msg):
-            record.msg = record.msg.replace("\n", "\\n").replace("\r", "\\r")
-        if any(self.reformat_check(arg) for arg in record.args):
-            record.args = self.reformat_args(record.args)
-        return super().format(record)
-
-    @staticmethod
-    def reformat_check(arg):
-        """ Check if the argument should be reformatted
-            The argument is a string with a line break
-            The argument is a numpy array
-        """
-        return ((isinstance(arg, str) and ("\n" in arg or "\r" in arg))
-                or isinstance(arg, ndarray))
-
-    @staticmethod
-    def reformat_args(args):
-        """ Reformat args that require new lines removing """
-        new_args = []
-        for arg in args:
-            if isinstance(arg, ndarray):
-                # Convert numpy arrays to string for reformatting
-                arg = str(ndarray)
-            if isinstance(arg, str) and ("\n" in arg or "\r" in arg):
-                arg = arg.replace("\n", "\\n").replace("\r", "\\r")
-            new_args.append(arg)
-        return tuple(new_args)
+        record.message = record.getMessage()
+        # strip newlines
+        if "\n" in record.message or "\r" in record.message:
+            record.message = record.message.replace("\n", "\\n").replace("\r", "\\r")
+
+        if self.usesTime():
+            record.asctime = self.formatTime(record, self.datefmt)
+        msg = self.formatMessage(record)
+        if record.exc_info:
+            # Cache the traceback text to avoid converting it multiple times
+            # (it's constant anyway)
+            if not record.exc_text:
+                record.exc_text = self.formatException(record.exc_info)
+        if record.exc_text:
+            if msg[-1:] != "\n":
+                msg = msg + "\n"
+            msg = msg + record.exc_text
+        if record.stack_info:
+            if msg[-1:] != "\n":
+                msg = msg + "\n"
+            msg = msg + self.formatStack(record.stack_info)
+        return msg
 
 
 class RollingBuffer(collections.deque):

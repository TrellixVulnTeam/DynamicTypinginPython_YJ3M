commit dd3288672a7e8c1a57ea96fb36876617b29b3436
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sat Aug 24 20:40:44 2019 +0100

    GUI Update
    
    
    - Launch in fullscreen
    - Expand Control Helper. Clean up config popup
    - Standardize and overhaul GUI for CliOpts

diff --git a/lib/cli.py b/lib/cli.py
index bcb4280..d7f5df4 100644
--- a/lib/cli.py
+++ b/lib/cli.py
@@ -601,18 +601,6 @@ class ExtractArgs(ExtractConvertArgs):
                               "help": "Filters out faces detected below this size. Length, in "
                                       "pixels across the diagonal of the bounding box. Set to 0 "
                                       "for off"})
-        argument_list.append({"opts": ("-een", "--extract-every-n"),
-                              "type": int,
-                              "action": Slider,
-                              "dest": "extract_every_n",
-                              "min_max": (1, 100),
-                              "default": 1,
-                              "rounding": 1,
-                              "group": "Face Processing",
-                              "help": "Extract every 'nth' frame. This option will skip frames "
-                                      "when extracting faces. For example a value of 1 will "
-                                      "extract faces from every frame, a value of 10 will extract "
-                                      "faces from every 10th frame."})
         argument_list.append({"opts": ("-n", "--nfilter"),
                               "action": FilesFullPaths,
                               "filetypes": "image",
@@ -668,42 +656,46 @@ class ExtractArgs(ExtractConvertArgs):
                               "action": "store_true",
                               "default": False,
                               "backend": "nvidia",
+                              "group": "settings",
                               "help": "Don't run extraction in parallel. Will run detection first "
                                       "then alignment (2 passes). Useful if VRAM is at a "
                                       "premium."})
-        argument_list.append({"opts": ("-sz", "--size"),
-                              "type": int,
-                              "action": Slider,
-                              "min_max": (128, 512),
-                              "default": 256,
-                              "rounding": 64,
-                              "group": "output",
-                              "help": "The output size of extracted faces. Make sure that the "
-                                      "model you intend to train supports your required size. "
-                                      "This will only need to be changed for hi-res models."})
         argument_list.append({"opts": ("-s", "--skip-existing"),
                               "action": "store_true",
                               "dest": "skip_existing",
+                              "group": "skipping",
                               "default": False,
                               "help": "Skips frames that have already been extracted and exist in "
                                       "the alignments file"})
         argument_list.append({"opts": ("-sf", "--skip-existing-faces"),
                               "action": "store_true",
                               "dest": "skip_faces",
+                              "group": "skipping",
                               "default": False,
                               "help": "Skip frames that already have detected faces in the "
                                       "alignments file"})
-        argument_list.append({"opts": ("-dl", "--debug-landmarks"),
-                              "action": "store_true",
-                              "dest": "debug_landmarks",
-                              "default": False,
-                              "help": "Draw landmarks on the ouput faces for debugging purposes."})
-        argument_list.append({"opts": ("-ae", "--align-eyes"),
-                              "action": "store_true",
-                              "dest": "align_eyes",
-                              "default": False,
-                              "help": "Perform extra alignment to ensure left/right eyes are at "
-                                      "the same height"})
+        argument_list.append({"opts": ("-een", "--extract-every-n"),
+                              "type": int,
+                              "action": Slider,
+                              "dest": "extract_every_n",
+                              "min_max": (1, 100),
+                              "default": 1,
+                              "rounding": 1,
+                              "group": "output",
+                              "help": "Extract every 'nth' frame. This option will skip frames "
+                                      "when extracting faces. For example a value of 1 will "
+                                      "extract faces from every frame, a value of 10 will extract "
+                                      "faces from every 10th frame."})
+        argument_list.append({"opts": ("-sz", "--size"),
+                              "type": int,
+                              "action": Slider,
+                              "min_max": (128, 512),
+                              "default": 256,
+                              "rounding": 64,
+                              "group": "output",
+                              "help": "The output size of extracted faces. Make sure that the "
+                                      "model you intend to train supports your required size. "
+                                      "This will only need to be changed for hi-res models."})
         argument_list.append({"opts": ("-si", "--save-interval"),
                               "dest": "save_interval",
                               "type": int,
@@ -719,6 +711,19 @@ class ExtractArgs(ExtractConvertArgs):
                                       "saved out during the second pass. WARNING: Don't interrupt "
                                       "the script when writing the file because it might get "
                                       "corrupted. Set to 0 to turn off"})
+        argument_list.append({"opts": ("-dl", "--debug-landmarks"),
+                              "action": "store_true",
+                              "dest": "debug_landmarks",
+                              "group": "output",
+                              "default": False,
+                              "help": "Draw landmarks on the ouput faces for debugging purposes."})
+        argument_list.append({"opts": ("-ae", "--align-eyes"),
+                              "action": "store_true",
+                              "dest": "align_eyes",
+                              "group": "output",
+                              "default": False,
+                              "help": "Perform extra alignment to ensure left/right eyes are at "
+                                      "the same height"})
         return argument_list
 
 
@@ -932,17 +937,20 @@ class ConvertArgs(ExtractConvertArgs):
         argument_list.append({"opts": ("-k", "--keep-unchanged"),
                               "action": "store_true",
                               "dest": "keep_unchanged",
+                              "group": "Frame Processing",
                               "default": False,
                               "help": "When used with --frame-ranges outputs the unchanged frames "
                                       "that are not processed instead of discarding them."})
         argument_list.append({"opts": ("-s", "--swap-model"),
                               "action": "store_true",
                               "dest": "swap_model",
+                              "group": "settings",
                               "default": False,
                               "help": "Swap the model. Instead converting from of A -> B, "
                                       "converts B -> A"})
         argument_list.append({"opts": ("-sp", "--singleprocess"),
                               "action": "store_true",
+                              "group": "settings",
                               "default": False,
                               "help": "Disable multiprocessing. Slower but less resource "
                                       "intensive."})
@@ -1067,15 +1075,39 @@ class TrainArgs(FaceSwapArgs):
                               "group": "training",
                               "default": 1,
                               "help": "Number of GPUs to use for training"})
-        argument_list.append({"opts": ("-ps", "--preview-scale"),
-                              "type": int,
-                              "action": Slider,
-                              "dest": "preview_scale",
-                              "min_max": (25, 200),
-                              "group": "training",
-                              "rounding": 25,
-                              "default": 50,
-                              "help": "Percentage amount to scale the preview by."})
+        argument_list.append({"opts": ("-msg", "--memory-saving-gradients"),
+                              "action": "store_true",
+                              "dest": "memory_saving_gradients",
+                              "group": "VRAM Savings",
+                              "default": False,
+                              "backend": "nvidia",
+                              "help": "Trades off VRAM usage against computation time. Can fit "
+                                      "larger models into memory at a cost of slower training "
+                                      "speed. 50%%-150%% batch size increase for 20%%-50%% longer "
+                                      "training time. NB: Launch time will be significantly "
+                                      "delayed. Switching sides using ping-pong training will "
+                                      "take longer."})
+        argument_list.append({"opts": ("-o", "--optimizer-savings"),
+                              "dest": "optimizer_savings",
+                              "action": "store_true",
+                              "default": False,
+                              "group": "VRAM Savings",
+                              "backend": "nvidia",
+                              "help": "To save VRAM some optimizer gradient calculations can be "
+                                      "performed on the CPU rather than the GPU. This allows you "
+                                      "to increase batchsize at a training speed/system RAM "
+                                      "cost."})
+        argument_list.append({"opts": ("-pp", "--ping-pong"),
+                              "action": "store_true",
+                              "dest": "pingpong",
+                              "group": "VRAM Savings",
+                              "default": False,
+                              "backend": "nvidia",
+                              "help": "Enable ping pong training. Trains one side at a time, "
+                                      "switching sides at each save iteration. Training will "
+                                      "take 2 to 4 times longer, with about a 30%%-50%% reduction "
+                                      "in VRAM useage. NB: Preview won't show until both sides "
+                                      "have been trained once."})
         argument_list.append({"opts": ("-s", "--save-interval"),
                               "type": int,
                               "action": Slider,
@@ -1128,20 +1160,32 @@ class TrainArgs(FaceSwapArgs):
                                       "folder at every save iteration. If the input folders are "
                                       "supplied but no output folder, it will default to your "
                                       "model folder /timelapse/"})
+        argument_list.append({"opts": ("-ps", "--preview-scale"),
+                              "type": int,
+                              "action": Slider,
+                              "dest": "preview_scale",
+                              "min_max": (25, 200),
+                              "group": "preview",
+                              "rounding": 25,
+                              "default": 50,
+                              "help": "Percentage amount to scale the preview by."})
         argument_list.append({"opts": ("-p", "--preview"),
                               "action": "store_true",
                               "dest": "preview",
+                              "group": "preview",
                               "default": False,
                               "help": "Show training preview output. in a separate window."})
         argument_list.append({"opts": ("-w", "--write-image"),
                               "action": "store_true",
                               "dest": "write_image",
+                              "group": "preview",
                               "default": False,
                               "help": "Writes the training result to a file. The image will be "
                                       "stored in the root of your FaceSwap folder."})
         argument_list.append({"opts": ("-ag", "--allow-growth"),
                               "action": "store_true",
                               "dest": "allow_growth",
+                              "group": "training",
                               "default": False,
                               "backend": "nvidia",
                               "help": "Sets allow_growth option of Tensorflow to spare memory "
@@ -1149,43 +1193,15 @@ class TrainArgs(FaceSwapArgs):
         argument_list.append({"opts": ("-nl", "--no-logs"),
                               "action": "store_true",
                               "dest": "no_logs",
+                              "group": "training",
                               "default": False,
                               "help": "Disables TensorBoard logging. NB: Disabling logs means "
                                       "that you will not be able to use the graph or analysis "
                                       "for this session in the GUI."})
-        argument_list.append({"opts": ("-msg", "--memory-saving-gradients"),
-                              "action": "store_true",
-                              "dest": "memory_saving_gradients",
-                              "default": False,
-                              "backend": "nvidia",
-                              "help": "Trades off VRAM usage against computation time. Can fit "
-                                      "larger models into memory at a cost of slower training "
-                                      "speed. 50%%-150%% batch size increase for 20%%-50%% longer "
-                                      "training time. NB: Launch time will be significantly "
-                                      "delayed. Switching sides using ping-pong training will "
-                                      "take longer."})
-        argument_list.append({"opts": ("-o", "--optimizer-savings"),
-                              "dest": "optimizer_savings",
-                              "action": "store_true",
-                              "default": False,
-                              "backend": "nvidia",
-                              "help": "To save VRAM some optimizer gradient calculations can be "
-                                      "performed on the CPU rather than the GPU. This allows you "
-                                      "to increase batchsize at a training speed/system RAM "
-                                      "cost."})
-        argument_list.append({"opts": ("-pp", "--ping-pong"),
-                              "action": "store_true",
-                              "dest": "pingpong",
-                              "default": False,
-                              "backend": "nvidia",
-                              "help": "Enable ping pong training. Trains one side at a time, "
-                                      "switching sides at each save iteration. Training will "
-                                      "take 2 to 4 times longer, with about a 30%%-50%% reduction "
-                                      "in VRAM useage. NB: Preview won't show until both sides "
-                                      "have been trained once."})
         argument_list.append({"opts": ("-wl", "--warp-to-landmarks"),
                               "action": "store_true",
                               "dest": "warp_to_landmarks",
+                              "group": "training",
                               "default": False,
                               "help": "Warps training faces to closely matched Landmarks from the "
                                       "opposite face-set rather than randomly warping the face. "
@@ -1195,6 +1211,7 @@ class TrainArgs(FaceSwapArgs):
         argument_list.append({"opts": ("-nf", "--no-flip"),
                               "action": "store_true",
                               "dest": "no_flip",
+                              "group": "training",
                               "default": False,
                               "help": "To effectively learn, a random set of images are flipped "
                                       "horizontally. Sometimes it is desirable for this not to "
@@ -1203,6 +1220,7 @@ class TrainArgs(FaceSwapArgs):
         argument_list.append({"opts": ("-nac", "--no-augment-color"),
                               "action": "store_true",
                               "dest": "no_augment_color",
+                              "group": "training",
                               "default": False,
                               "help": "Color augmentation helps make the model less susceptible "
                                       "to color differences between the A and B sets, at an "
diff --git a/lib/gui/command.py b/lib/gui/command.py
index ab28da2..f4e6b08 100644
--- a/lib/gui/command.py
+++ b/lib/gui/command.py
@@ -5,9 +5,9 @@ import logging
 import tkinter as tk
 from tkinter import ttk
 
-from .control_helper import set_slider_rounding
+from .control_helper import set_slider_rounding, ControlPanel
 from .tooltip import Tooltip
-from .utils import ContextMenu, FileHandler, get_images, get_config
+from .utils import get_images, get_config
 
 logger = logging.getLogger(__name__)  # pylint:disable=invalid-name
 
@@ -18,8 +18,10 @@ class CommandNotebook(ttk.Notebook):  # pylint:disable=too-many-ancestors
     def __init__(self, parent):
         logger.debug("Initializing %s: (parent: %s)", self.__class__.__name__, parent)
         scaling_factor = get_config().scaling_factor
-        width = int(420 * scaling_factor)
-        height = int(500 * scaling_factor)
+        width = int(470 * scaling_factor)
+        root_height = get_config().root.winfo_height()
+        height = int(round(root_height * 0.78125))
+
         self.actionbtns = dict()
         super().__init__(parent, width=width, height=height)
         parent.add(self)
@@ -94,8 +96,8 @@ class CommandTab(ttk.Frame):  # pylint:disable=too-many-ancestors
     def build_tab(self):
         """ Build the tab """
         logger.debug("Build Tab: '%s'", self.command)
-        OptionsFrame(self)
-
+        options = get_config().cli_opts.opts[self.command]
+        ControlPanel(self, options, label_width=16, radio_columns=2, columns=2)
         self.add_frame_separator()
 
         ActionFrame(self)
@@ -109,343 +111,6 @@ class CommandTab(ttk.Frame):  # pylint:disable=too-many-ancestors
         logger.debug("Added frame seperator")
 
 
-class OptionsFrame(ttk.Frame):  # pylint:disable=too-many-ancestors
-    """ Options Frame - Holds the Options for each command """
-
-    def __init__(self, parent):
-        logger.debug("Initializing %s", self.__class__.__name__)
-        super().__init__(parent)
-        self.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
-
-        self.command = parent.command
-
-        self.canvas = tk.Canvas(self, bd=0, highlightthickness=0)
-        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
-
-        self.optsframe = ttk.Frame(self.canvas)
-        self.group_frames = dict()
-        self.optscanvas = self.canvas.create_window((0, 0),
-                                                    window=self.optsframe,
-                                                    anchor=tk.NW)
-        self.chkbtns = self.checkbuttons_frame()
-
-        self.build_frame()
-        cli_opts = get_config().cli_opts
-        cli_opts.set_context_option(self.command)
-        logger.debug("Initialized %s", self.__class__.__name__)
-
-    def checkbuttons_frame(self):
-        """ Build and format frame for holding the check buttons """
-        logger.debug("Add Options CheckButtons Frame")
-        container = ttk.Frame(self.optsframe)
-
-        lbl = ttk.Label(container, text="Options", width=16, anchor=tk.W)
-        lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
-
-        chkframe = ttk.Frame(container)
-        chkleft = ttk.Frame(chkframe, name="leftFrame")
-        chkright = ttk.Frame(chkframe, name="rightFrame")
-
-        chkframe.pack(fill=tk.X, expand=True)
-        chkleft.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.LEFT, anchor=tk.N)
-        chkright.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.RIGHT, anchor=tk.N)
-        logger.debug("Added Options CheckButtons Frame")
-
-        return container, chkframe
-
-    def build_frame(self):
-        """ Build the options frame for this command """
-        logger.debug("Add Options Frame")
-        self.add_scrollbar()
-        self.canvas.bind("<Configure>", self.resize_frame)
-
-        cli_opts = get_config().cli_opts
-        for option in cli_opts.gen_command_options(self.command):
-            group = option["group"]
-            frame = self.optsframe
-            if group is not None:
-                group = group.lower()
-                if self.group_frames.get(group, None) is None:
-                    group_frame = ttk.LabelFrame(self.optsframe, text=group.title())
-                    group_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)
-                    self.group_frames[group] = group_frame
-                frame = self.group_frames[group]
-
-            optioncontrol = OptionControl(self.command,
-                                          option,
-                                          frame,
-                                          self.chkbtns[1])
-            optioncontrol.build_full_control()
-
-        if self.chkbtns[1].winfo_children():
-            self.chkbtns[0].pack(side=tk.BOTTOM, fill=tk.X, expand=True)
-        logger.debug("Added Options Frame")
-
-    def add_scrollbar(self):
-        """ Add a scrollbar to the options frame """
-        logger.debug("Add Options Scrollbar")
-        scrollbar = ttk.Scrollbar(self, command=self.canvas.yview)
-        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
-        self.canvas.config(yscrollcommand=scrollbar.set)
-        self.optsframe.bind("<Configure>", self.update_scrollbar)
-        logger.debug("Added Options Scrollbar")
-
-    def update_scrollbar(self, event):  # pylint:disable=unused-argument
-        """ Update the options frame scrollbar """
-        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
-
-    def resize_frame(self, event):
-        """ Resize the options frame to fit the canvas """
-        logger.debug("Resize Options Frame")
-        canvas_width = event.width
-        self.canvas.itemconfig(self.optscanvas, width=canvas_width)
-        logger.debug("Resized Options Frame")
-
-
-class OptionControl():
-    """ Build the correct control for the option parsed and place it on the
-    frame """
-
-    def __init__(self, command, option, option_frame, checkbuttons_frame):
-        logger.debug("Initializing %s", self.__class__.__name__)
-        self.command = command
-        self.option = option
-        self.option_frame = option_frame
-        self.chkbtns = checkbuttons_frame
-        logger.debug("Initialized %s", self.__class__.__name__)
-
-    def build_full_control(self):
-        """ Build the correct control type for the option passed through """
-        logger.debug("Build option control")
-        ctl = self.option["control"]
-        ctltitle = self.option["control_title"]
-        sysbrowser = self.option["filesystem_browser"]
-        ctlhelp = self.format_help(ctltitle)
-        dflt = self.option.get("default", "")
-        if self.option.get("nargs", None) and isinstance(dflt, (list, tuple)):
-            dflt = ' '.join(str(val) for val in dflt)
-        if ctl == ttk.Checkbutton:
-            dflt = self.option.get("default", False)
-        choices = self.option["choices"] if ctl in(ttk.Combobox, ttk.Radiobutton) else None
-        min_max = self.option["min_max"] if ctl == ttk.Scale else None
-
-        ctlframe = self.build_one_control_frame()
-
-        if ctl != ttk.Checkbutton:
-            self.build_one_control_label(ctlframe, ctltitle)
-
-        ctlvars = (ctl, ctltitle, dflt, ctlhelp)
-        self.option["value"] = self.build_one_control(ctlframe,
-                                                      ctlvars,
-                                                      choices,
-                                                      min_max,
-                                                      sysbrowser)
-        logger.debug("Built option control")
-
-    def format_help(self, ctltitle):
-        """ Format the help text for tooltips """
-        logger.debug("Format control help: '%s'", ctltitle)
-        ctlhelp = self.option.get("help", "")
-        if ctlhelp.startswith("R|"):
-            ctlhelp = ctlhelp[2:].replace("\nL|", "\n - ").replace("\n", "\n\n")
-        else:
-            ctlhelp = " ".join(ctlhelp.split())
-        ctlhelp = ctlhelp.replace("%%", "%")
-        ctlhelp = ". ".join(i.capitalize() for i in ctlhelp.split(". "))
-        ctlhelp = ctltitle + " - " + ctlhelp
-        logger.debug("Formatted control help: (title: '%s', help: '%s'", ctltitle, ctlhelp)
-        return ctlhelp
-
-    def build_one_control_frame(self):
-        """ Build the frame to hold the control """
-        logger.debug("Build control frame")
-        frame = ttk.Frame(self.option_frame)
-        frame.pack(fill=tk.X, expand=True)
-        logger.debug("Built control frame")
-        return frame
-
-    @staticmethod
-    def build_one_control_label(frame, control_title):
-        """ Build and place the control label """
-        logger.debug("Build control label: '%s'", control_title)
-        lbl = ttk.Label(frame, text=control_title, width=16, anchor=tk.W)
-        lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
-        logger.debug("Built control label: '%s'", control_title)
-
-    def build_one_control(self, frame, controlvars, choices, min_max, sysbrowser):
-        """ Build and place the option controls """
-        logger.debug("Build control: (controlvars: %s, choices: %s, min_max: %s, sysbrowser: %s",
-                     controlvars, choices, min_max, sysbrowser)
-        control, control_title, default, helptext = controlvars
-        default = default if default is not None else ""
-
-        var = tk.BooleanVar(frame) if control == ttk.Checkbutton else tk.StringVar(frame)
-        var.set(default)
-
-        if sysbrowser:
-            self.add_browser_buttons(frame, sysbrowser, var)
-
-        if control == ttk.Checkbutton:
-            self.checkbutton_to_checkframe(control, control_title, var, helptext)
-        elif control == ttk.Radiobutton:
-            self.radio_control(frame, control_title, var, choices, helptext)
-        elif control == ttk.Scale:
-            self.slider_control(control, frame, var, min_max, helptext)
-        else:
-            self.control_to_optionsframe(control, frame, var, choices, helptext)
-        logger.debug("Built control: '%s'", control_title)
-        return var
-
-    @staticmethod
-    def radio_control(frame, control_title, var, choices, helptext):
-        """ Create a group of radio buttons """
-        logger.debug("Adding radio group: %s", control_title)
-        radio_frame_left = ttk.Frame(frame)
-        radio_frame_middle = ttk.Frame(frame)
-        radio_frame_right = ttk.Frame(frame)
-
-        radio_frame_left.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.LEFT, anchor=tk.N)
-        radio_frame_middle.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.LEFT, anchor=tk.N)
-        radio_frame_right.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.RIGHT, anchor=tk.N)
-
-        for idx, choice in enumerate(choices):
-            pos = idx + 1
-            if pos % 3 == 0:
-                radio_frame = radio_frame_right
-            elif (pos + 1) % 3 == 0:
-                radio_frame = radio_frame_middle
-            else:
-                radio_frame = radio_frame_left
-
-            ctl = ttk.Radiobutton(radio_frame, text=choice.title(), value=choice, variable=var)
-            ctl.pack(anchor=tk.W)
-            Tooltip(ctl, text=helptext, wraplength=920)
-        logger.debug("Added radio group: '%s'", control_title)
-
-    def checkbutton_to_checkframe(self, control, control_title, var, helptext):
-        """ Add checkbuttons to the checkbutton frame """
-        logger.debug("Add control checkframe: '%s'", control_title)
-        leftframe = self.chkbtns.children["leftFrame"]
-        rightframe = self.chkbtns.children["rightFrame"]
-        chkbtn_count = len({**leftframe.children, **rightframe.children})
-
-        frame = leftframe if chkbtn_count % 2 == 0 else rightframe
-
-        ctl = control(frame, variable=var, text=control_title)
-        ctl.pack(side=tk.TOP, anchor=tk.W)
-
-        Tooltip(ctl, text=helptext, wraplength=200)
-        logger.debug("Added control checkframe: '%s'", control_title)
-
-    def slider_control(self, control, frame, tk_var, min_max, helptext):
-        """ A slider control with corresponding Entry box """
-        logger.debug("Add slider control to Options Frame: %s", control)
-        d_type = self.option.get("type", float)
-        rnd = self.option.get("rounding", 2) if d_type == float else self.option.get("rounding", 1)
-
-        tbox = ttk.Entry(frame, width=8, textvariable=tk_var, justify=tk.RIGHT)
-        tbox.pack(padx=(0, 5), side=tk.RIGHT)
-        ctl = control(
-            frame,
-            variable=tk_var,
-            command=lambda val, var=tk_var, dt=d_type, rn=rnd, mm=min_max:
-            set_slider_rounding(val, var, dt, rn, mm))
-        ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
-        rc_menu = ContextMenu(ctl)
-        rc_menu.cm_bind()
-        ctl["from_"] = min_max[0]
-        ctl["to"] = min_max[1]
-
-        Tooltip(ctl, text=helptext, wraplength=920)
-        Tooltip(tbox, text=helptext, wraplength=920)
-        logger.debug("Added slider control to Options Frame: %s", control)
-
-    @staticmethod
-    def control_to_optionsframe(control, frame, var, choices, helptext):
-        """ Standard non-check buttons sit in the main options frame """
-        logger.debug("Add control to Options Frame: %s", control)
-        ctl = control(frame, textvariable=var)
-        ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
-        rc_menu = ContextMenu(ctl)
-        rc_menu.cm_bind()
-        if control == ttk.Combobox:
-            logger.debug("Adding combo choices: %s", choices)
-            ctl["values"] = [choice for choice in choices]
-        Tooltip(ctl, text=helptext, wraplength=920)
-        logger.debug("Added control to Options Frame: %s", control)
-
-    def add_browser_buttons(self, frame, sysbrowser, filepath):
-        """ Add correct file browser button for control """
-        logger.debug("Adding browser buttons: (sysbrowser: '%s', filepath: '%s'",
-                     sysbrowser, filepath)
-        for browser in sysbrowser:
-            img = get_images().icons[browser]
-            action = getattr(self, "ask_" + browser)
-            filetypes = self.option.get("filetypes", "default")
-            fileopn = ttk.Button(frame,
-                                 image=img,
-                                 command=lambda cmd=action: cmd(filepath, filetypes))
-            fileopn.pack(padx=(0, 5), side=tk.RIGHT)
-            logger.debug("Added browser buttons: (action: %s, filetypes: %s",
-                         action, filetypes)
-
-    @staticmethod
-    def ask_folder(filepath, filetypes=None):
-        """ Pop-up to get path to a directory
-            :param filepath: tkinter StringVar object
-            that will store the path to a directory.
-            :param filetypes: Unused argument to allow
-            filetypes to be given in ask_load(). """
-        dirname = FileHandler("dir", filetypes).retfile
-        if dirname:
-            logger.debug(dirname)
-            filepath.set(dirname)
-
-    @staticmethod
-    def ask_load(filepath, filetypes):
-        """ Pop-up to get path to a file """
-        filename = FileHandler("filename", filetypes).retfile
-        if filename:
-            logger.debug(filename)
-            filepath.set(filename)
-
-    @staticmethod
-    def ask_load_multi(filepath, filetypes):
-        """ Pop-up to get path to a file """
-        filenames = FileHandler("filename_multi", filetypes).retfile
-        if filenames:
-            final_names = " ".join("\"{}\"".format(fname) for fname in filenames)
-            logger.debug(final_names)
-            filepath.set(final_names)
-
-    @staticmethod
-    def ask_save(filepath, filetypes=None):
-        """ Pop-up to get path to save a new file """
-        filename = FileHandler("savefilename", filetypes).retfile
-        if filename:
-            logger.debug(filename)
-            filepath.set(filename)
-
-    @staticmethod
-    def ask_nothing(filepath, filetypes=None):  # pylint:disable=unused-argument
-        """ Method that does nothing, used for disabling open/save pop up """
-        return
-
-    def ask_context(self, filepath, filetypes):
-        """ Method to pop the correct dialog depending on context """
-        logger.debug("Getting context filebrowser")
-        selected_action = self.option["action_option"].get()
-        selected_variable = self.option["dest"]
-        filename = FileHandler("context",
-                               filetypes,
-                               command=self.command,
-                               action=selected_action,
-                               variable=selected_variable).retfile
-        if filename:
-            logger.debug(filename)
-            filepath.set(filename)
-
-
 class ActionFrame(ttk.Frame):  # pylint:disable=too-many-ancestors
     """Action Frame - Displays action controls for the command tab """
 
diff --git a/lib/gui/control_helper.py b/lib/gui/control_helper.py
index acb42e2..cba8aa3 100644
--- a/lib/gui/control_helper.py
+++ b/lib/gui/control_helper.py
@@ -5,7 +5,7 @@ import tkinter as tk
 from tkinter import ttk
 
 from .tooltip import Tooltip
-from .utils import ContextMenu
+from .utils import ContextMenu, FileHandler, get_images
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
 
@@ -31,15 +31,19 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         Also keeps tally if groups passed in, so that any options with special
         processing needs are processed in the correct group frame """
 
-    def __init__(self, parent, options, items_per_row=1, radio_columns=4, header_text=None):
-        logger.debug("Initializing %s: (parent: '%s', options: %s, items_per_row: %s, "
-                     "radio_columns: %s, header_text: %s)",
-                     self.__class__.__name__, parent, options, items_per_row, radio_columns,
-                     header_text)
+    def __init__(self, parent, options, label_width=20, columns=1, radio_columns=4,
+                 header_text=None, blank_nones=True):
+        logger.debug("Initializing %s: (parent: '%s', options: %s, label_width: %s, columns: %s, "
+                     "radio_columns: %s, header_text: %s, blank_nones: %s)",
+                     self.__class__.__name__, parent, options, label_width, columns, radio_columns,
+                     header_text, blank_nones)
         super().__init__(parent)
         self.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
 
         self.options = options
+        self.label_width = label_width
+        self.columns = columns
+        self.radio_columns = radio_columns
 
         self.header_text = header_text
         self.group_frames = dict()
@@ -47,48 +51,96 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         self.canvas = tk.Canvas(self, bd=0, highlightthickness=0)
         self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 
-        self.optsframe = ttk.Frame(self.canvas)
-        self.optscanvas = self.canvas.create_window((0, 0), window=self.optsframe, anchor=tk.NW)
+        self.mainframe, self.optsframe = self.get_opts_frame()
+        self.optscanvas = self.canvas.create_window((0, 0), window=self.mainframe, anchor=tk.NW)
 
-        self.build_panel(radio_columns)
+        self.build_panel(radio_columns, blank_nones)
         logger.debug("Initialized %s", self.__class__.__name__)
 
-    def build_panel(self, radio_columns):
+    def get_opts_frame(self):
+        """ Return an autofill container for the options inside a main frame """
+        mainframe = ttk.Frame(self.canvas)
+        if self.header_text is not None:
+            self.add_info(mainframe)
+        optsframe = ttk.Frame(mainframe)
+        optsframe.pack(expand=True, fill=tk.BOTH)
+        holder = AutoFillContainer(optsframe, self.columns)
+        logger.debug("Opts frames: '%s'", holder)
+        return mainframe, holder
+
+    def add_info(self, frame):
+        """ Plugin information """
+        gui_style = ttk.Style()
+        gui_style.configure('White.TFrame', background='#FFFFFF')
+        gui_style.configure('Header.TLabel', background='#FFFFFF', font=("", 9, "bold"))
+        gui_style.configure('Body.TLabel', background='#FFFFFF', font=("", 9))
+
+        info_frame = ttk.Frame(frame, style='White.TFrame', relief=tk.SOLID)
+        info_frame.pack(fill=tk.X, side=tk.TOP, expand=True, padx=10, pady=10)
+        label_frame = ttk.Frame(info_frame, style='White.TFrame')
+        label_frame.pack(padx=5, pady=5, fill=tk.X, expand=True)
+        for idx, line in enumerate(self.header_text.splitlines()):
+            if not line:
+                continue
+            style = "Header.TLabel" if idx == 0 else "Body.TLabel"
+            info = ttk.Label(label_frame, text=line, style=style, anchor=tk.W)
+            info.pack(fill=tk.X, padx=0, pady=0, expand=True, side=tk.TOP)
+        info.bind("<Configure>", adjust_wraplength)
+
+    def build_panel(self, radio_columns, blank_nones):
         """ Build the options frame for this command """
         logger.debug("Add Config Frame")
         self.add_scrollbar()
         self.canvas.bind("<Configure>", self.resize_frame)
 
-        self.add_info()
         for key, val in self.options.items():
             if key == "helptext":
                 continue
-            frame = self.get_holding_frame(val["group"])
-            ctl = ControlBuilder(frame,
+            group = "_master" if val["group"] is None else val["group"]
+            group_frame = self.get_group_frame(group)
+            ctl = ControlBuilder(group_frame["frame"],
                                  key,
                                  val["type"],
                                  val["default"],
+                                 label_width=self.label_width,
                                  selected_value=val["value"],
                                  choices=val["choices"],
                                  is_radio=val["gui_radio"],
                                  rounding=val["rounding"],
                                  min_max=val["min_max"],
                                  helptext=val["helptext"],
-                                 radio_columns=radio_columns)
+                                 sysbrowser=val.get("sysbrowser", None),
+                                 checkbuttons_frame=group_frame["chkbtns"],
+                                 radio_columns=radio_columns,
+                                 blank_nones=blank_nones)
+            if group_frame["chkbtns"].items > 0:
+                group_frame["chkbtns"].parent.pack(side=tk.BOTTOM, fill=tk.X, anchor=tk.NW)
             val["selected"] = ctl.tk_var
+            self.options[key]["_gui_option"] = ctl
+        for key, val in self.options.items():
+            if key == "helptext":
+                continue
+            filebrowser = val["_gui_option"].filebrowser
+            if filebrowser is not None:
+                filebrowser.set_context_action_option(self.options)
         logger.debug("Added Config Frame")
 
-    def get_holding_frame(self, group):
-        """ Return either the main options frame or a group frame """
-        if group is None:
-            return self.optsframe
+    def get_group_frame(self, group):
+        """ Return a new group frame """
         group = group.lower()
         if self.group_frames.get(group, None) is None:
             logger.debug("Creating new group frame for: %s", group)
-            group_frame = ttk.LabelFrame(self.optsframe, text=group.title())
-            group_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)
-            self.group_frames[group] = group_frame
-        return self.group_frames[group]
+            is_master = group == "_master"
+            opts_frame = self.optsframe.subframe
+            group_frame = ttk.LabelFrame(opts_frame,
+                                         text="" if is_master else group.title(),
+                                         name=group.lower())
+            group_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5, anchor=tk.NW)
+
+            self.group_frames[group] = dict(frame=group_frame,
+                                            chkbtns=self.checkbuttons_frame(group_frame))
+        group_frame = self.group_frames[group]
+        return group_frame
 
     def add_scrollbar(self):
         """ Add a scrollbar to the options frame """
@@ -96,7 +148,7 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         scrollbar = ttk.Scrollbar(self, command=self.canvas.yview)
         scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
         self.canvas.config(yscrollcommand=scrollbar.set)
-        self.optsframe.bind("<Configure>", self.update_scrollbar)
+        self.mainframe.bind("<Configure>", self.update_scrollbar)
         logger.debug("Added Config Scrollbar")
 
     def update_scrollbar(self, event):  # pylint: disable=unused-argument
@@ -110,19 +162,66 @@ class ControlPanel(ttk.Frame):  # pylint:disable=too-many-ancestors
         self.canvas.itemconfig(self.optscanvas, width=canvas_width)
         logger.debug("Resized Config Frame")
 
-    def add_info(self):
-        """ Plugin information """
-        info_frame = ttk.Frame(self.optsframe)
-        info_frame.pack(fill=tk.X, expand=True)
-        lbl = ttk.Label(info_frame, text="About:", width=20, anchor=tk.W)
-        lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
-        info = ttk.Label(info_frame, text=self.header_text)
-        info.pack(padx=5, pady=5, fill=tk.X, expand=True)
-        info.bind("<Configure>", adjust_wraplength)
+    def checkbuttons_frame(self, frame):
+        """ Build and format frame for holding the check buttons
+            if is_master then check buttons will be placed in a LabelFrame
+            otherwise in a standard frame """
+        logger.debug("Add Options CheckButtons Frame")
+        chk_frame = ttk.Frame(frame, name="chkbuttons")
+        holder = AutoFillContainer(chk_frame, self.radio_columns)
+        logger.debug("Added Options CheckButtons Frame")
+        return holder
+
+
+class AutoFillContainer():
+    """ A container object that autofills columns """
+    def __init__(self, parent, columns):
+        logger.debug("Initializing: %s: (parent: %s, columns: %s)", self.__class__.__name__,
+                     parent, columns)
+        self.parent = parent
+        self.columns = columns
+        self._items = 0
+        self._idx = 0
+        self.subframes = self.set_subframes()
+        logger.debug("Initialized: %s: (items: %s)", self.__class__.__name__, self.items)
+
+    @property
+    def items(self):
+        """ Returns the number if items held in this containter """
+        return self._items
+
+    @property
+    def subframe(self):
+        """ Returns the next subframe to be populated """
+        frame = self.subframes[self._idx]
+        next_idx = self._idx + 1 if self._idx + 1 != self.columns else 0
+        logger.debug("current_idx: %s, next_idx: %s", self._idx, next_idx)
+        self._idx = next_idx
+        return frame
+
+    @property
+    def last_subframe(self):
+        """ Returns the last column """
+        return self.subframes[self.columns - 1]
+
+    def set_subframes(self):
+        """ Set a subrame for each requested column """
+        subframes = []
+        for idx in range(self.columns):
+            if self.columns != 1:
+                name = "{}_{}".format(self.parent.winfo_name(), idx)
+                subframe = ttk.Frame(self.parent, name=name)
+                subframe.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N, expand=True, fill=tk.X)
+                subframes.append(subframe)
+                logger.debug("Added subframe: %s", name)
+            else:
+                subframes.append(self.parent)
+                logger.debug("Using parent as subframe: %s", self.parent.winfo_name())
+            self._items += 1
+        return subframes
 
 
 class ControlBuilder():
-    # TODO Expand out for cli options
     """
     Builds and returns a frame containing a tkinter control with label
 
@@ -135,7 +234,7 @@ class ControlBuilder():
     title: str
         Title of the control. Will be used for label text
     dtype: datatype object
-        Datatype of the control
+        Datatype of the control.
     default: str
         Default value for the control
     selected_value: str, optional
@@ -148,55 +247,69 @@ class ControlBuilder():
         For slider controls. Sets the stepping
     min_max: int or float, optional
         For slider controls. Sets the min and max values
+    sysbrowser: dict, optional
+        Adds Filesystem browser buttons to ttk.Entry options.
+        Expects a dict: {sysbrowser: str, filetypes: str}
     helptext: str, optional
         Sets the tooltip text
     radio_columns: int, optional
         Sets the number of columns to use for grouping radio buttons
     label_width: int, optional
         Sets the width of the control label. Defaults to 20
+    checkbuttons_frame: tk.frame, optional
+        If a checkbutton frame is passed in, then checkbuttons will be placed in this frame
+        rather than the main options frame
     control_width: int, optional
         Sets the width of the control. Default is to auto expand
+    blank_nones: bool, optional
+        Sets selected values to an empty string rather than None if this is true. Default is true
     """
     def __init__(self, parent, title, dtype, default,
                  selected_value=None, choices=None, is_radio=False, rounding=None,
-                 min_max=None, helptext=None, radio_columns=3, label_width=20, control_width=None):
+                 min_max=None, sysbrowser=None, helptext=None, radio_columns=3, label_width=20,
+                 checkbuttons_frame=None, control_width=None, blank_nones=True):
         logger.debug("Initializing %s: (parent: %s, title: %s, dtype: %s, default: %s, "
                      "selected_value: %s, choices: %s, is_radio: %s, rounding: %s, min_max: %s, "
-                     "helptext: %s, radio_columns: %s, label_width: %s, control_width: %s)",
+                     "sysbrowser: %s, helptext: %s, radio_columns: %s, label_width: %s, "
+                     "checkbuttons_frame: %s, control_width: %s, blank_nones: %s)",
                      self.__class__.__name__, parent, title, dtype, default, selected_value,
-                     choices, is_radio, rounding, min_max, helptext, radio_columns, label_width,
-                     control_width)
+                     choices, is_radio, rounding, min_max, sysbrowser, helptext, radio_columns,
+                     label_width, checkbuttons_frame, control_width, blank_nones)
 
         self.title = title
         self.default = default
+        self.helptext = self.format_helptext(helptext)
+        self.label_width = label_width
+        self.filebrowser = None
 
-        self.frame = self.control_frame(parent, helptext)
+        self.frame = self.control_frame(parent)
+        self.chkbtns = checkbuttons_frame
         self.control = self.set_control(dtype, choices, is_radio)
-        self.tk_var = self.set_tk_var(dtype, selected_value)
+        self.tk_var = self.set_tk_var(dtype, selected_value, blank_nones)
 
         self.build_control(choices,
                            dtype,
                            rounding,
                            min_max,
+                           sysbrowser,
                            radio_columns,
-                           label_width,
                            control_width)
         logger.debug("Initialized: %s", self.__class__.__name__)
 
     # Frame, control type and varable
-    def control_frame(self, parent, helptext):
+    @staticmethod
+    def control_frame(parent):
         """ Frame to hold control and it's label """
         logger.debug("Build control frame")
         frame = ttk.Frame(parent)
-        frame.pack(side=tk.TOP, fill=tk.X)
-        if helptext is not None:
-            helptext = self.format_helptext(helptext)
-            Tooltip(frame, text=helptext, wraplength=720)
+        frame.pack(fill=tk.X)
         logger.debug("Built control frame")
         return frame
 
     def format_helptext(self, helptext):
         """ Format the help text for tooltips """
+        if helptext is None:
+            return helptext
         logger.debug("Format control help: '%s'", self.title)
         helptext = helptext.replace("\n\t", "\n  - ").replace("%%", "%")
         helptext = self.title + " - " + helptext
@@ -218,10 +331,11 @@ class ControlBuilder():
         logger.debug("Setting control '%s' to %s", self.title, control)
         return control
 
-    def set_tk_var(self, dtype, selected_value):
+    def set_tk_var(self, dtype, selected_value, blank_nones):
         """ Correct variable type for control """
-        logger.debug("Setting tk variable: (title: '%s', dtype: %s, selected_value: %s)",
-                     self.title, dtype, selected_value)
+        logger.debug("Setting tk variable: (title: '%s', dtype: %s, selected_value: %s, "
+                     "blank_nones: %s)",
+                     self.title, dtype, selected_value, blank_nones)
         if dtype == bool:
             var = tk.BooleanVar
         elif dtype == int:
@@ -232,43 +346,60 @@ class ControlBuilder():
             var = tk.StringVar
         var = var(self.frame)
         val = self.default if selected_value is None else selected_value
+        val = "" if val is None and blank_nones else val
         var.set(val)
         logger.debug("Set tk variable: (title: '%s', type: %s, value: '%s')",
                      self.title, type(var), val)
         return var
 
     # Build the full control
-    def build_control(self, choices, dtype, rounding, min_max, radio_columns,
-                      label_width, control_width):
+    def build_control(self, choices, dtype, rounding, min_max, sysbrowser, radio_columns,
+                      control_width):
         """ Build the correct control type for the option passed through """
         logger.debug("Build confog option control")
-        self.build_control_label(label_width)
-        self.build_one_control(choices, dtype, rounding, min_max, radio_columns, control_width)
+        if self.control not in (ttk.Checkbutton, ttk.Radiobutton):
+            self.build_control_label()
+        self.build_one_control(choices,
+                               dtype,
+                               rounding,
+                               min_max,
+                               sysbrowser,
+                               radio_columns,
+                               control_width)
         logger.debug("Built option control")
 
-    def build_control_label(self, label_width):
+    def build_control_label(self):
         """ Label for control """
-        logger.debug("Build control label: (title: '%s', label_width: %s)",
-                     self.title, label_width)
+        logger.debug("Build control label: (title: '%s')", self.title)
         title = self.title.replace("_", " ").title()
-        lbl = ttk.Label(self.frame, text=title, width=label_width, anchor=tk.W)
+        lbl = ttk.Label(self.frame, text=title, width=self.label_width, anchor=tk.W)
         lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
+        if self.helptext is not None:
+            Tooltip(lbl, text=self.helptext, wraplength=720)
+
         logger.debug("Built control label: '%s'", self.title)
 
-    def build_one_control(self, choices, dtype, rounding, min_max, radio_columns, control_width):
+    def build_one_control(self, choices, dtype, rounding, min_max,
+                          sysbrowser, radio_columns, control_width):
         """ Build and place the option controls """
         logger.debug("Build control: (title: '%s', control: %s, choices: %s, dtype: %s, "
-                     "rounding: %s, min_max: %s: radio_columns: %s, control_width: %s)",
-                     self.title, self.control, choices, dtype, rounding, min_max, radio_columns,
-                     control_width)
+                     "rounding: %s, sysbrowser: %s, min_max: %s: radio_columns: %s, "
+                     "control_width: %s)", self.title, self.control, choices, dtype, rounding,
+                     sysbrowser, min_max, radio_columns, control_width)
         if self.control == ttk.Scale:
             ctl = self.slider_control(dtype, rounding, min_max)
         elif self.control == ttk.Radiobutton:
             ctl = self.radio_control(choices, radio_columns)
+        elif self.control == ttk.Checkbutton:
+            ctl = self.control_to_checkframe()
         else:
-            ctl = self.control_to_optionsframe(choices)
+            ctl = self.control_to_optionsframe(choices, sysbrowser)
         self.set_control_width(ctl, control_width)
-        ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
+        if self.control != ttk.Checkbutton:
+            ctl.pack(padx=5, pady=5, fill=tk.X, expand=True)
+            if self.helptext is not None:
+                Tooltip(ctl, text=self.helptext, wraplength=720)
+
         logger.debug("Built control: '%s'", self.title)
 
     @staticmethod
@@ -280,23 +411,17 @@ class ControlBuilder():
     def radio_control(self, choices, columns):
         """ Create a group of radio buttons """
         logger.debug("Adding radio group: %s", self.title)
-        ctl = ttk.Frame(self.frame)
-        frames = list()
-        for _ in range(columns):
-            frame = ttk.Frame(ctl)
-            frame.pack(padx=5, pady=5, fill=tk.X, expand=True, side=tk.LEFT, anchor=tk.N)
-            frames.append(frame)
-
+        ctl = ttk.LabelFrame(self.frame, text=self.title.replace("_", " ").title())
+        radio_holder = AutoFillContainer(ctl, columns)
         for idx, choice in enumerate(choices):
             frame_id = idx % columns
-            radio = ttk.Radiobutton(frames[frame_id],
+            radio = ttk.Radiobutton(radio_holder.subframe,
                                     text=choice.title(),
                                     value=choice,
                                     variable=self.tk_var)
             radio.pack(anchor=tk.W)
             logger.debug("Adding radio option %s to column %s", choice, frame_id)
-        logger.debug("Added radio group: '%s'", self.title)
-        return ctl
+        return radio_holder.parent
 
     def slider_control(self, dtype, rounding, min_max):
         """ A slider control with corresponding Entry box """
@@ -316,13 +441,15 @@ class ControlBuilder():
         logger.debug("Added slider control to Options Frame: %s", self.title)
         return ctl
 
-    def control_to_optionsframe(self, choices):
+    def control_to_optionsframe(self, choices, sysbrowser):
         """ Standard non-check buttons sit in the main options frame """
         logger.debug("Add control to Options Frame: (title: '%s', control: %s, choices: %s)",
                      self.title, self.control, choices)
         if self.control == ttk.Checkbutton:
             ctl = self.control(self.frame, variable=self.tk_var, text=None)
         else:
+            if sysbrowser is not None:
+                self.filebrowser = FileBrowser(self.tk_var, self.frame, sysbrowser)
             ctl = self.control(self.frame, textvariable=self.tk_var)
             rc_menu = ContextMenu(ctl)
             rc_menu.cm_bind()
@@ -331,3 +458,111 @@ class ControlBuilder():
             ctl["values"] = [choice for choice in choices]
         logger.debug("Added control to Options Frame: %s", self.title)
         return ctl
+
+    def control_to_checkframe(self):
+        """ Add checkbuttons to the checkbutton frame """
+        logger.debug("Add control checkframe: '%s'", self.title)
+        chkframe = self.chkbtns.subframe
+        ctl = self.control(chkframe,
+                           variable=self.tk_var,
+                           text=self.title.replace("_", " ").title(),
+                           name=self.title.lower())
+        Tooltip(ctl, text=self.helptext, wraplength=200)
+        ctl.pack(side=tk.TOP, anchor=tk.W)
+        logger.debug("Added control checkframe: '%s'", self.title)
+        return ctl
+
+
+class FileBrowser():
+    """ Add FileBrowser buttons to control and handle routing """
+    def __init__(self, tk_var, control_frame, sysbrowser_dict):
+        logger.debug("Initializing: %s: (tk_var: %s, control_frame: %s, sysbrowser_dict: %s)",
+                     self.__class__.__name__, tk_var, control_frame, sysbrowser_dict)
+        self.tk_var = tk_var
+        self.frame = control_frame
+        self.browser = sysbrowser_dict["browser"]
+        self.filetypes = sysbrowser_dict["filetypes"]
+        self.action_option = sysbrowser_dict.get("action_option", None)
+        self.command = sysbrowser_dict.get("command", None)
+        self.destination = sysbrowser_dict.get("destination", None)
+        self.add_browser_buttons()
+        logger.debug("Initialized: %s", self.__class__.__name__)
+
+    def add_browser_buttons(self):
+        """ Add correct file browser button for control """
+        logger.debug("Adding browser buttons: (sysbrowser: '%s'", self.browser)
+        for browser in self.browser:
+            img = get_images().icons[browser]
+            action = getattr(self, "ask_" + browser)
+            fileopn = ttk.Button(self.frame,
+                                 image=img,
+                                 command=lambda cmd=action: cmd(self.tk_var, self.filetypes))
+            fileopn.pack(padx=(0, 5), side=tk.RIGHT)
+            logger.debug("Added browser buttons: (action: %s, filetypes: %s",
+                         action, self.filetypes)
+
+    def set_context_action_option(self, options):
+        """ Set the tk_var for the source action option
+            that dictates the context sensitive file browser. """
+        if self.browser != ["context"]:
+            return
+        actions = {item["opts"][0]: item["selected"]
+                   for item in options.values()}
+        logger.debug("Settiong action option for opt %s", self.action_option)
+        self.action_option = actions[self.action_option]
+
+    @staticmethod
+    def ask_folder(filepath, filetypes=None):
+        """ Pop-up to get path to a directory
+            :param filepath: tkinter StringVar object
+            that will store the path to a directory.
+            :param filetypes: Unused argument to allow
+            filetypes to be given in ask_load(). """
+        dirname = FileHandler("dir", filetypes).retfile
+        if dirname:
+            logger.debug(dirname)
+            filepath.set(dirname)
+
+    @staticmethod
+    def ask_load(filepath, filetypes):
+        """ Pop-up to get path to a file """
+        filename = FileHandler("filename", filetypes).retfile
+        if filename:
+            logger.debug(filename)
+            filepath.set(filename)
+
+    @staticmethod
+    def ask_load_multi(filepath, filetypes):
+        """ Pop-up to get path to a file """
+        filenames = FileHandler("filename_multi", filetypes).retfile
+        if filenames:
+            final_names = " ".join("\"{}\"".format(fname) for fname in filenames)
+            logger.debug(final_names)
+            filepath.set(final_names)
+
+    @staticmethod
+    def ask_save(filepath, filetypes=None):
+        """ Pop-up to get path to save a new file """
+        filename = FileHandler("savefilename", filetypes).retfile
+        if filename:
+            logger.debug(filename)
+            filepath.set(filename)
+
+    @staticmethod
+    def ask_nothing(filepath, filetypes=None):  # pylint:disable=unused-argument
+        """ Method that does nothing, used for disabling open/save pop up """
+        return
+
+    def ask_context(self, filepath, filetypes):
+        """ Method to pop the correct dialog depending on context """
+        logger.debug("Getting context filebrowser")
+        selected_action = self.action_option.get()
+        selected_variable = self.destination
+        filename = FileHandler("context",
+                               filetypes,
+                               command=self.command,
+                               action=selected_action,
+                               variable=selected_variable).retfile
+        if filename:
+            logger.debug(filename)
+            filepath.set(filename)
diff --git a/lib/gui/options.py b/lib/gui/options.py
index 609a058..20f3ca8 100644
--- a/lib/gui/options.py
+++ b/lib/gui/options.py
@@ -4,7 +4,7 @@ import inspect
 from argparse import SUPPRESS
 import logging
 import re
-from tkinter import ttk
+from collections import OrderedDict
 
 from lib import cli
 import tools.cli as ToolsCli
@@ -72,7 +72,7 @@ class CliOptions():
             logger.debug("Processing: (classname: '%s')", classname)
             command = self.format_command_name(classname)
             options = self.get_cli_arguments(cli_source, classname, command)
-            options = self.process_options(options)
+            options = self.process_options(options, command)
             logger.debug("Processed: (classname: '%s', command: '%s', options: %s)",
                          classname, command, options)
             subopts[command] = options
@@ -84,24 +84,29 @@ class CliOptions():
         meth = getattr(cli_source, classname)(None, command)
         return meth.argument_list + meth.optional_arguments + meth.global_arguments
 
-    def process_options(self, command_options):
+    def process_options(self, command_options, command):
         """ Process the options for a single command """
-        final_options = list()
+        gui_options = OrderedDict()
         for opt in command_options:
             logger.trace("Processing: %s", opt)
             if opt.get("help", "") == SUPPRESS:
                 logger.trace("Skipping suppressed option: %s", opt)
                 continue
-            ctl, sysbrowser, filetypes, action_option, group = self.set_control(opt)
-            opt["control_title"] = self.set_control_title(opt.get("opts", ""))
-            opt["control"] = ctl
-            opt["filesystem_browser"] = sysbrowser
-            opt["filetypes"] = filetypes
-            opt["action_option"] = action_option
-            opt["group"] = group
-            final_options.append(opt)
+            title = self.set_control_title(opt["opts"])
+            gui_options[title] = {
+                "type": self.get_data_type(opt),
+                "default": opt.get("default", None),
+                "value": opt.get("default", ""),
+                "choices": opt.get("choices", None),
+                "gui_radio": opt.get("action", "") == cli.Radio,
+                "rounding": self.get_rounding(opt),
+                "min_max": opt.get("min_max", None),
+                "sysbrowser": self.get_sysbrowser(opt, command),
+                "group": opt.get("group", None),
+                "helptext": opt["help"],
+                "opts": opt["opts"]}
             logger.trace("Processed: %s", opt)
-        return final_options
+        return gui_options
 
     @staticmethod
     def set_control_title(opts):
@@ -110,75 +115,76 @@ class CliOptions():
         ctltitle = ctltitle.replace("-", " ").replace("_", " ").strip().title()
         return ctltitle
 
-    def set_control(self, option):
-        """ Set the control and filesystem browser to use for each option """
-        sysbrowser = None
-        group = option.get("group", None)
-        action = option.get("action", None)
-        action_option = option.get("action_option", None)
-        filetypes = option.get("filetypes", None)
-        ctl = ttk.Entry
-        if action in (cli.FullPaths,
-                      cli.DirFullPaths,
-                      cli.FileFullPaths,
-                      cli.FilesFullPaths,
-                      cli.DirOrFileFullPaths,
-                      cli.SaveFileFullPaths,
-                      cli.ContextFullPaths):
-            sysbrowser, filetypes = self.set_sysbrowser(action,
-                                                        filetypes,
-                                                        action_option)
-        elif option.get("min_max", None):
-            ctl = ttk.Scale
-        elif option.get("action", "") == cli.Radio:
-            ctl = ttk.Radiobutton
-        elif option.get("choices", "") != "":
-            ctl = ttk.Combobox
-        elif option.get("action", "") == "store_true":
-            ctl = ttk.Checkbutton
-        return ctl, sysbrowser, filetypes, action_option, group
+    @staticmethod
+    def get_data_type(opt):
+        """ Return a datatype for passing into control_helper.py to get the correct control """
+        if opt.get("type", None) is not None and isinstance(opt["type"], type):
+            retval = opt["type"]
+        elif opt.get("action", "") in ("store_true", "store_false"):
+            retval = bool
+        else:
+            retval = str
+        return retval
 
     @staticmethod
-    def set_sysbrowser(action, filetypes, action_option):
-        """ Set the correct file system browser and filetypes
-            for the passed in action """
-        sysbrowser = ["folder"]
-        filetypes = "default" if not filetypes else filetypes
+    def get_rounding(opt):
+        """ Return rounding if correct data type, else None """
+        dtype = opt.get("type", None)
+        if dtype == float:
+            retval = opt.get("rounding", 2)
+        elif dtype == int:
+            retval = opt.get("rounding", 1)
+        else:
+            retval = None
+        return retval
+
+    @staticmethod
+    def get_sysbrowser(option, command):
+        """ Return the system file browser and file types if required else None """
+        action = option.get("action", None)
+        if action not in (cli.FullPaths,
+                          cli.DirFullPaths,
+                          cli.FileFullPaths,
+                          cli.FilesFullPaths,
+                          cli.DirOrFileFullPaths,
+                          cli.SaveFileFullPaths,
+                          cli.ContextFullPaths):
+            return None
+
+        retval = dict()
+        action_option = option.get("action_option", None)
+        retval["filetypes"] = option.get("filetypes", "default")
         if action == cli.FileFullPaths:
-            sysbrowser = ["load"]
+            retval["browser"] = ["load"]
         elif action == cli.FilesFullPaths:
-            sysbrowser = ["load_multi"]
+            retval["browser"] = ["load_multi"]
         elif action == cli.SaveFileFullPaths:
-            sysbrowser = ["save"]
+            retval["browser"] = ["save"]
         elif action == cli.DirOrFileFullPaths:
-            sysbrowser = ["folder", "load"]
+            retval["browser"] = ["folder", "load"]
         elif action == cli.ContextFullPaths and action_option:
-            sysbrowser = ["context"]
-        logger.debug("sysbrowser: %s, filetypes: '%s'", sysbrowser, filetypes)
-        return sysbrowser, filetypes
-
-    def set_context_option(self, command):
-        """ Set the tk_var for the source action option
-            that dictates the context sensitive file browser. """
-        actions = {item["opts"][0]: item["value"]
-                   for item in self.gen_command_options(command)}
-        for opt in self.gen_command_options(command):
-            if opt["filesystem_browser"] == ["context"]:
-                opt["action_option"] = actions[opt["action_option"]]
+            retval["browser"] = ["context"]
+            retval["command"] = command
+            retval["action_option"] = action_option
+            retval["destination"] = option.get("dest", option["opts"][1].replace("--", ""))
+        else:
+            retval["browser"] = ["folder"]
+        logger.debug(retval)
+        return retval
 
     def gen_command_options(self, command):
         """ Yield each option for specified command """
-        for option in self.opts[command]:
-            yield option
+        for key, val in self.opts[command].items():
+            yield key, val
 
     def options_to_process(self, command=None):
         """ Return a consistent object for processing
             regardless of whether processing all commands
             or just one command for reset and clear """
         if command is None:
-            options = [opt for opts in self.opts.values() for opt in opts]
+            options = [opt for opts in self.opts.values() for opt in opts.values()]
         else:
-            options = [opt for opt in self.gen_command_options(command)]
+            options = [opt for opt in self.opts[command].values()]
         return options
 
     def reset(self, command=None):
@@ -191,19 +197,19 @@ class CliOptions():
             if (option.get("nargs", None)
                     and isinstance(default, (list, tuple))):
                 default = ' '.join(str(val) for val in default)
-            option["value"].set(default)
+            option["selected"].set(default)
 
     def clear(self, command=None):
         """ Clear the options values for all or passed
             commands """
         logger.debug("Clearing options. (command: '%s'", command)
         for option in self.options_to_process(command):
-            if isinstance(option["value"].get(), bool):
-                option["value"].set(False)
-            elif isinstance(option["value"].get(), int):
-                option["value"].set(0)
+            if isinstance(option["selected"].get(), bool):
+                option["selected"].set(False)
+            elif isinstance(option["selected"].get(), int):
+                option["selected"].set(0)
             else:
-                option["value"].set("")
+                option["selected"].set("")
 
     def get_option_values(self, command=None):
         """ Return all or single command control titles
@@ -214,7 +220,7 @@ class CliOptions():
                 continue
             cmd_dict = dict()
             for opt in opts:
-                cmd_dict[opt["control_title"]] = opt["value"].get()
+                cmd_dict[opt["control_title"]] = opt["selected"].get()
             ctl_dict[cmd] = cmd_dict
         logger.debug("command: '%s', ctl_dict: '%s'", command, ctl_dict)
         return ctl_dict
@@ -222,16 +228,16 @@ class CliOptions():
     def get_one_option_variable(self, command, title):
         """ Return a single tk_var for the specified
             command and control_title """
-        for option in self.gen_command_options(command):
-            if option["control_title"] == title:
-                return option["value"]
+        for opt_title, option in self.gen_command_options(command):
+            if opt_title == title:
+                return option["selected"]
         return None
 
     def gen_cli_arguments(self, command):
         """ Return the generated cli arguments for
             the selected command """
-        for option in self.gen_command_options(command):
-            optval = str(option.get("value", "").get())
+        for _, option in self.gen_command_options(command):
+            optval = str(option.get("selected", "").get())
             opt = option["opts"][0]
             if command in ("extract", "convert") and opt == "-o":
                 get_images().pathoutput = optval
diff --git a/lib/gui/popup_configure.py b/lib/gui/popup_configure.py
index 5bb6be3..d11a485 100644
--- a/lib/gui/popup_configure.py
+++ b/lib/gui/popup_configure.py
@@ -51,7 +51,7 @@ class ConfigurePlugins(tk.Toplevel):
         scaling_factor = get_config().scaling_factor
         pos_x = root.winfo_x() + 80
         pos_y = root.winfo_y() + 80
-        width = int(720 * scaling_factor)
+        width = int(600 * scaling_factor)
         height = int(400 * scaling_factor)
         logger.debug("Pop up Geometry: %sx%s, %s+%s", width, height, pos_x, pos_y)
         self.geometry("{}x{}+{}+{}".format(width, height, pos_x, pos_y))
@@ -94,20 +94,23 @@ class ConfigurePlugins(tk.Toplevel):
         """ Build a plugin config page """
         logger.debug("Building plugin config page: '%s'", category)
         plugins = sorted(list(key for key in self.config_dict_gui[category].keys()))
+        panel_kwargs = dict(columns=2, radio_columns=2, blank_nones=False)
         if any(plugin != category for plugin in plugins):
             page = ttk.Notebook(container)
             page.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
             for plugin in plugins:
                 frame = ControlPanel(page,
                                      self.config_dict_gui[category][plugin],
-                                     self.plugin_info[plugin])
+                                     header_text=self.plugin_info[plugin],
+                                     **panel_kwargs)
                 title = plugin[plugin.rfind(".") + 1:]
                 title = title.replace("_", " ").title()
                 page.add(frame, text=title)
         else:
             page = ControlPanel(container,
                                 self.config_dict_gui[category][plugins[0]],
-                                self.plugin_info[plugins[0]])
+                                header_text=self.plugin_info[plugins[0]],
+                                **panel_kwargs)
 
         logger.debug("Built plugin config page: '%s'", category)
 
diff --git a/scripts/gui.py b/scripts/gui.py
index cc44210..c32581a 100644
--- a/scripts/gui.py
+++ b/scripts/gui.py
@@ -116,6 +116,7 @@ class Gui():  # pylint: disable=too-few-public-methods
         pathscript = os.path.realpath(os.path.dirname(cmd))
         self.args = arguments
         self.root = FaceswapGui(pathscript)
+        self.root.state("zoomed")
 
     def process(self):
         """ Builds the GUI """

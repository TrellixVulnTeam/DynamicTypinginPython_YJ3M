commit d2dbd440d89d22b4b75f30ddeb4c4ebd3882ecfa
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Tue May 14 18:19:00 2019 +0000

    Sort: Faster sort by face/face-dissim

diff --git a/lib/vgg_face.py b/lib/vgg_face.py
index b30c39c..14dd978 100644
--- a/lib/vgg_face.py
+++ b/lib/vgg_face.py
@@ -12,6 +12,8 @@ import os
 
 import cv2
 import numpy as np
+from fastcluster import linkage
+from scipy.spatial.distance import pdist, squareform
 
 from lib.utils import GetModel
 
@@ -77,3 +79,44 @@ class VGGFace():
         var_b = np.sum(np.multiply(source_face, source_face))
         var_c = np.sum(np.multiply(test_face, test_face))
         return 1 - (var_a / (np.sqrt(var_b) * np.sqrt(var_c)))
+
+    def sorted_similarity(self, predictions, method="ward"):
+        """ Sort a matrix of predictions by similarity Adapted from:
+            https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html
+        input:
+            - predictions is a stacked matrix of vgg_face predictions shape: (x, 4096)
+            - method = ["ward","single","average","complete"]
+        output:
+            - result_order is a list of indices with the order implied by the hierarhical tree
+
+        sorted_similarity transforms a distance matrix into a sorted distance matrix according to
+        the order implied by the hierarchical tree (dendrogram)
+        """
+        logger.verbose("Calculating pairwise distances")
+        flat_distance_matrix = pdist(predictions)
+        distance_matrix = squareform(flat_distance_matrix)
+        num_predictions = len(distance_matrix)
+        logger.verbose("Sorting distances")
+        result_linkage = linkage(flat_distance_matrix, method=method, preserve_input=True)
+        result_order = self.seriation(result_linkage,
+                                      num_predictions,
+                                      num_predictions + num_predictions - 2)
+
+        return result_order
+
+    def seriation(self, tree, points, current_index):
+        """ Seriation method for sorted similarity
+            input:
+                - tree is a hierarchical tree (dendrogram)
+                - points is the number of points given to the clustering process
+                - current_index is the position in the tree for the recursive traversal
+            output:
+                - order implied by the hierarchical tree
+
+            seriation computes the order implied by a hierarchical tree (dendrogram)
+        """
+        if current_index < points:
+            return [current_index]
+        left = int(tree[current_index-points, 0])
+        right = int(tree[current_index-points, 1])
+        return self.seriation(tree, points, left) + self.seriation(tree, points, right)
diff --git a/requirements.txt b/requirements.txt
index 909b72e..100e52f 100755
--- a/requirements.txt
+++ b/requirements.txt
@@ -7,6 +7,7 @@ scikit-image
 Pillow
 scikit-learn
 toposort
+fastcluster
 matplotlib==2.2.2
 imageio
 imageio-ffmpeg
diff --git a/tools/sort.py b/tools/sort.py
index 8d36829..7679471 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -181,28 +181,13 @@ class Sort():
 
         logger.info("Sorting by face similarity...")
 
-        img_list = [[img, self.vgg_face.predict(cv2.imread(img))]
-                    for img in
-                    tqdm(self.find_images(input_dir),
-                         desc="Loading",
-                         file=sys.stdout)]
-
-        img_list_len = len(img_list)
-        for i in tqdm(range(0, img_list_len - 1),
-                      desc="Sorting",
-                      file=sys.stdout):
-            min_score = float("inf")
-            j_min_score = i + 1
-            for j in range(i + 1, len(img_list)):
-                f1encs = img_list[i][1]
-                f2encs = img_list[j][1]
-                score = self.vgg_face.find_cosine_similiarity(f1encs, f2encs)
-                if score < min_score:
-                    min_score = score
-                    j_min_score = j
-            (img_list[i + 1],
-             img_list[j_min_score]) = (img_list[j_min_score],
-                                       img_list[i + 1])
+        images = np.array(self.find_images(input_dir))
+        preds = np.array([self.vgg_face.predict(cv2.imread(img))
+                          for img in tqdm(images, desc="loading", file=sys.stdout)])
+        logger.info("Sorting. Depending on ths size of your dataset, this may take a few "
+                    "minutes...")
+        indices = self.vgg_face.sorted_similarity(preds, method="ward")
+        img_list = images[indices]
         return img_list
 
     def sort_face_dissim(self):
@@ -210,27 +195,12 @@ class Sort():
         input_dir = self.args.input_dir
 
         logger.info("Sorting by face dissimilarity...")
-
-        img_list = [[img, self.vgg_face.predict(cv2.imread(img)), 0]
-                    for img in
-                    tqdm(self.find_images(input_dir),
-                         desc="Loading",
-                         file=sys.stdout)]
-
-        img_list_len = len(img_list)
-        for i in tqdm(range(0, img_list_len), desc="Sorting", file=sys.stdout):
-            score_total = 0
-            for j in range(0, img_list_len):
-                if i == j:
-                    continue
-                score_total += self.vgg_face.find_cosine_similiarity(
-                    img_list[i][1],
-                    img_list[j][1])
-
-            img_list[i][2] = score_total
-
-        logger.info("Sorting...")
-        img_list = sorted(img_list, key=operator.itemgetter(2), reverse=True)
+        images = np.array(self.find_images(input_dir))
+        preds = np.array([self.vgg_face.predict(cv2.imread(img))
+                          for img in tqdm(images, desc="loading", file=sys.stdout)])
+        logger.info("Sorting. Depending on ths size of your dataset, this may take a while...")
+        indices = self.vgg_face.sorted_similarity(preds, method="complete")
+        img_list = images[indices]
         return img_list
 
     def sort_face_cnn(self):
@@ -581,7 +551,7 @@ class Sort():
                       desc=description,
                       leave=False,
                       file=sys.stdout):
-            src = img_list[i][0]
+            src = img_list[i] if isinstance(img_list[i], str) else img_list[i][0]
             src_basename = os.path.basename(src)
 
             dst = os.path.join(output_dir, '{:05d}_{}'.format(i, src_basename))
@@ -595,7 +565,8 @@ class Sort():
                       desc=description,
                       file=sys.stdout):
             renaming = self.set_renaming_method(self.args.log_changes)
-            src, dst = renaming(img_list[i][0], output_dir, i, self.changes)
+            fname = img_list[i] if isinstance(img_list[i], str) else img_list[i][0]
+            src, dst = renaming(fname, output_dir, i, self.changes)
 
             try:
                 os.rename(src, dst)
@@ -729,9 +700,9 @@ class Sort():
         for i in tqdm(range(len(sorted_list)),
                       desc="Splicing",
                       file=sys.stdout):
-            current_image = sorted_list[i][0]
-            new_val_index = val_index_list.index(current_image)
-            new_list.append([current_image, new_vals_list[new_val_index][1]])
+            current_img = sorted_list[i] if isinstance(sorted_list[i], str) else sorted_list[i][0]
+            new_val_index = val_index_list.index(current_img)
+            new_list.append([current_img, new_vals_list[new_val_index][1]])
 
         return new_list
 

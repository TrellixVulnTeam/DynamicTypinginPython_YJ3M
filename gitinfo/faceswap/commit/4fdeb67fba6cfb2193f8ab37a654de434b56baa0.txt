commit 4fdeb67fba6cfb2193f8ab37a654de434b56baa0
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Fri Nov 29 23:53:00 2019 +0000

    Bugfix - Manual tool. Use new ExtractMedia class

diff --git a/plugins/extract/align/_base.py b/plugins/extract/align/_base.py
index e6dfc8b..7690384 100644
--- a/plugins/extract/align/_base.py
+++ b/plugins/extract/align/_base.py
@@ -122,8 +122,10 @@ class Aligner(Extractor):  # pylint:disable=abstract-method
                 if idx == self.batchsize:
                     frame_faces = len(item.detected_faces)
                     if f_idx + 1 != frame_faces:
-                        self._rollover = ExtractMedia(item.filename, item.image)
-                        self._rollover.add_detected_faces(item.detected_faces[f_idx + 1:])
+                        self._rollover = ExtractMedia(
+                            item.filename,
+                            item.image,
+                            detected_faces=item.detected_faces[f_idx + 1:])
                         logger.trace("Rolled over %s faces of %s to next batch for '%s'",
                                      len(self._rollover.detected_faces), frame_faces,
                                      item.filename)
diff --git a/plugins/extract/detect/manual.py b/plugins/extract/detect/manual.py
deleted file mode 100644
index 5953e9b..0000000
--- a/plugins/extract/detect/manual.py
+++ /dev/null
@@ -1,39 +0,0 @@
-#!/usr/bin/env python3
-""" Manual face detection plugin """
-
-import numpy as np
-from ._base import Detector
-
-
-class Detect(Detector):
-    """ Manual Detector """
-    def __init__(self, **kwargs):
-        super().__init__(**kwargs)
-        self.name = "Manual"
-        self.input_size = 1440  # Arbitrary size for manual tool
-        self.vram = 0
-        self.vram_warnings = 0
-        self.vram_per_batch = 1
-        self.batchsize = 1
-
-    def _compile_detection_image(self, input_image):
-        """ Override compile detection image for manual. No face is actually fed into a model """
-        return input_image, 1, (0, 0)
-
-    def init_model(self):
-        """ No model for Manual """
-        return
-
-    def process_input(self, batch):
-        """ No pre-processing for Manual. Just set a dummy feed """
-        batch["feed"] = batch["image"]
-        return batch
-
-    def predict(self, batch):
-        """ No prediction for Manual """
-        batch["prediction"] = [np.array(batch["manual_face"])]
-        return batch
-
-    def process_output(self, batch):
-        """ Post process the detected faces """
-        return batch
diff --git a/plugins/extract/mask/_base.py b/plugins/extract/mask/_base.py
index 37aed6a..13b9096 100644
--- a/plugins/extract/mask/_base.py
+++ b/plugins/extract/mask/_base.py
@@ -126,8 +126,10 @@ class Masker(Extractor):  # pylint:disable=abstract-method
                 if idx == self.batchsize:
                     frame_faces = len(item.detected_faces)
                     if f_idx + 1 != frame_faces:
-                        self._rollover = ExtractMedia(item.filename, item.image)
-                        self._rollover.add_detected_faces(item.detected_faces[f_idx + 1:])
+                        self._rollover = ExtractMedia(
+                            item.filename,
+                            item.image,
+                            detected_faces=item.detected_faces[f_idx + 1:])
                         logger.trace("Rolled over %s faces of %s to next batch for '%s'",
                                      len(self._rollover.detected_faces), frame_faces,
                                      item.filename)
diff --git a/plugins/extract/pipeline.py b/plugins/extract/pipeline.py
index 6b5546e..0bb7f55 100644
--- a/plugins/extract/pipeline.py
+++ b/plugins/extract/pipeline.py
@@ -487,14 +487,17 @@ class ExtractMedia():
         The base name of the original frame's filename
     image: :class:`numpy.ndarray`
         The original frame
+    detected_faces: list, optional
+        A list of :class:`~lib.faces_detect.DetectedFace` objects. Detected faces can be added
+        later with :func:`add_detected_faces`. Default: None
     """
 
-    def __init__(self, filename, image):
-        logger.trace("Initializing %s: (filename: '%s', image shape: %s)",
-                     self.__class__.__name__, filename, image.shape)
+    def __init__(self, filename, image, detected_faces=None):
+        logger.trace("Initializing %s: (filename: '%s', image shape: %s, detected_faces: %s)",
+                     self.__class__.__name__, filename, image.shape, detected_faces)
         self._filename = filename
         self._image = image
-        self._detected_faces = None
+        self._detected_faces = detected_faces
 
     @property
     def filename(self):
diff --git a/plugins/plugin_loader.py b/plugins/plugin_loader.py
index 8f162af..525fc76 100644
--- a/plugins/plugin_loader.py
+++ b/plugins/plugin_loader.py
@@ -185,8 +185,7 @@ class PluginLoader():
                             for item in os.scandir(extractpath)
                             if not item.name.startswith("_")
                             and not item.name.endswith("defaults.py")
-                            and item.name.endswith(".py")
-                            and item.name != "manual.py")
+                            and item.name.endswith(".py"))
         if add_none:
             extractors.insert(0, "none")
         return extractors
diff --git a/tools/lib_alignments/jobs_manual.py b/tools/lib_alignments/jobs_manual.py
index 2f933c0..ead991e 100644
--- a/tools/lib_alignments/jobs_manual.py
+++ b/tools/lib_alignments/jobs_manual.py
@@ -7,8 +7,9 @@ import sys
 import cv2
 import numpy as np
 
+from lib.faces_detect import DetectedFace
 from lib.queue_manager import queue_manager
-from plugins.extract.pipeline import Extractor
+from plugins.extract.pipeline import Extractor, ExtractMedia
 from . import Annotate, ExtractedFaces, Frames
 
 logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
@@ -720,7 +721,7 @@ class FacesDisplay():
     def build_faces_image(self, size):
         """ Display associated faces """
         total_faces = len(self.faces)
-        logger.trace("Building faces panel. (total_faces: %s", total_faces)
+        logger.trace("Building faces panel. (total_faces: %s)", total_faces)
         if not total_faces:
             logger.trace("Returning empty row")
             image = self.build_faces_row(list(), size)
@@ -781,11 +782,10 @@ class MouseHandler():
     def init_extractor(self):
         """ Initialize Aligner """
         logger.debug("Initialize Extractor")
-        extractor = Extractor("manual", "fan", None, multiprocess=True, normalize_method="hist")
+        extractor = Extractor(None, "fan", None, multiprocess=True, normalize_method="hist")
         self.queues["in"] = extractor.input_queue
-        # Set the batchsizes to 1
-        for plugin_type in ("detect", "align"):
-            extractor.set_batchsize(plugin_type, 1)
+        # Set the batchsize to 1
+        extractor.set_batchsize("align", 1)
         extractor.launch()
         logger.debug("Initialized Extractor")
         return extractor
@@ -829,8 +829,8 @@ class MouseHandler():
         self.center = None
         self.last_move = None
         self.mouse_state = None
-        self.media["bounding_box"] = list()
-        self.media["bounding_box_orig"] = list()
+        self.media["bounding_box"] = DetectedFace()
+        self.media["bounding_box_orig"] = None
 
     def set_bounding_box(self, pt_x, pt_y):
         """ Select or create bounding box """
@@ -882,10 +882,10 @@ class MouseHandler():
         pt_x, pt_y = self.center
         width, height = self.dims
         scale = self.interface.get_frame_scaling()
-        self.media["bounding_box"] = [int((pt_x / scale) - width / 2),
-                                      int((pt_y / scale) - height / 2),
-                                      int((pt_x / scale) + width / 2),
-                                      int((pt_y / scale) + height / 2)]
+        self.media["bounding_box"].x = int((pt_x / scale) - width / 2)
+        self.media["bounding_box"].y = int((pt_y / scale) - height / 2)
+        self.media["bounding_box"].w = width
+        self.media["bounding_box"].h = height
 
     def move_bounding_box(self, pt_x, pt_y):
         """ Move the bounding box """
@@ -896,7 +896,6 @@ class MouseHandler():
     def resize_bounding_box(self, pt_x, pt_y):
         """ Resize the bounding box """
         scale = self.interface.get_frame_scaling()
-
         if not self.last_move:
             self.last_move = (pt_x, pt_y)
             self.media["bounding_box_orig"] = self.media["bounding_box"]
@@ -907,21 +906,22 @@ class MouseHandler():
         original = self.media["bounding_box_orig"]
         updated = self.media["bounding_box"]
 
-        minsize = int(10 / scale)
+        minsize = int(20 / scale)
         center = (int(self.center[0] / scale), int(self.center[1] / scale))
-        updated[0] = min(center[0] - minsize, original[0] - move_x)
-        updated[1] = min(center[1] - minsize, original[1] - move_y)
-        updated[2] = max(center[0] + minsize, original[2] + move_x)
-        updated[3] = max(center[1] + minsize, original[3] + move_y)
+        updated.x = min(center[0] - (minsize // 2), original.x - move_x)
+        updated.y = min(center[1] - (minsize // 2), original.y - move_y)
+        updated.w = max(minsize, original.w + move_x)
+        updated.h = max(minsize, original.h + move_y)
         self.update_landmarks()
         self.last_move = (pt_x, pt_y)
 
     def update_landmarks(self):
         """ Update the landmarks """
-        self.queues["in"].put({"image": self.media["image"],
-                               "filename": self.media["frame_id"],
-                               "manual_face": self.media["bounding_box"]})
-        detected_face = next(self.extractor.detected_faces())["detected_faces"][0]
+        feed = ExtractMedia(self.media["frame_id"],
+                            self.media["image"],
+                            detected_faces=[self.media["bounding_box"]])
+        self.queues["in"].put(feed)
+        detected_face = next(self.extractor.detected_faces()).detected_faces[0]
         alignment = detected_face.to_alignment()
         # Mask will now be incorrect for updated landmarks so delete
         alignment["mask"] = dict()

commit b9b93771c6ac72180837133fe420ff4890ad5088
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Wed Sep 19 11:00:30 2018 +0100

    MTCNN Alignment improvements (#504)

diff --git a/lib/face_alignment/detectors.py b/lib/face_alignment/detectors.py
index 992d2a8..0790cec 100644
--- a/lib/face_alignment/detectors.py
+++ b/lib/face_alignment/detectors.py
@@ -4,7 +4,10 @@
     https://github.com/1adrianb/face-alignment """
 
 import os
+import numpy as np
+
 from tensorflow import Graph, Session
+
 import dlib
 
 from .mtcnn import create_mtcnn, detect_face
@@ -177,7 +180,41 @@ class MTCNNDetector(Detector):
     def detect_faces(self, image):
         """ Detect faces in rgb image """
         self.detected_faces = None
-        detected_faces = detect_face(image, **self.kwargs)
+        detected_faces, points = detect_face(image, **self.kwargs)
+        detected_faces = self.tighten_bounding_box(detected_faces, points)
         self.detected_faces = [dlib.rectangle(int(face[0]), int(face[1]),
                                               int(face[2]), int(face[3]))
                                for face in detected_faces]
+
+    @staticmethod
+    def tighten_bounding_box(faces, landmarks):
+        """ Tighten the bounding box for Face Alignment.
+
+            Face Alignment was built to expect a DLIB bounding
+            box and sometimes can't calculate landmarks on edge
+            cases. Tightening up the bounding box along the
+            longest edge improves it's chances and helps remove
+            'jitter' """
+        retval = list()
+        if len(faces) == 0:
+            return retval
+        face_landmarks = np.hsplit(landmarks, len(faces))
+        for idx, face in enumerate(faces):
+            pts = np.vsplit(face_landmarks[idx], 2)
+            boundary = (np.amin(pts[0]), np.amin(pts[1]),
+                        np.amax(pts[0]), np.amax(pts[1]))
+
+            len_x, len_y = face[2] - face[0], face[3] - face[1]
+            raw = 1 if len_x > len_y else 0 if len_x < len_y else -1
+            bounding = list()
+
+            for i in range(4):
+                if i % 2 == raw:
+                    bounding.append(int(face[i]))
+                else:
+                    # Reduce bounding box by 75% around landmarks
+                    remove = (boundary[i] - face[i]) / 4
+                    bounding.append(int(boundary[i] - remove))
+
+            retval.append(bounding)
+        return retval
diff --git a/lib/face_alignment/mtcnn.py b/lib/face_alignment/mtcnn.py
index 29f2939..4413dd7 100644
--- a/lib/face_alignment/mtcnn.py
+++ b/lib/face_alignment/mtcnn.py
@@ -310,7 +310,7 @@ def detect_face(img, minsize, pnet, rnet, onet, threshold, factor):
     """
     factor_count=0
     total_boxes=np.empty((0,9))
-    # points=np.empty(0)
+    points=np.empty(0)
     h=img.shape[0]
     w=img.shape[1]
     minl=np.amin([h, w])
@@ -417,25 +417,24 @@ def detect_face(img, minsize, pnet, rnet, onet, threshold, factor):
         out1 = np.transpose(out[1])
         out2 = np.transpose(out[2])
         score = out2[1,:]
-        # points = out1
+        points = out1
         ipass = np.where(score>threshold[2])
-        # points = points[:,ipass[0]]
+        points = points[:,ipass[0]]
         total_boxes = np.hstack([total_boxes[ipass[0],0:4].copy(), np.expand_dims(score[ipass].copy(),1)])
         mv = out0[:,ipass[0]]
 
         w = total_boxes[:,2]-total_boxes[:,0]+1
         h = total_boxes[:,3]-total_boxes[:,1]+1
-        # points[0:5,:] = np.tile(w,(5, 1))*points[0:5,:] + np.tile(total_boxes[:,0],(5, 1))-1
-        # points[5:10,:] = np.tile(h,(5, 1))*points[5:10,:] + np.tile(total_boxes[:,1],(5, 1))-1
+        points[0:5,:] = np.tile(w,(5, 1))*points[0:5,:] + np.tile(total_boxes[:,0],(5, 1))-1
+        points[5:10,:] = np.tile(h,(5, 1))*points[5:10,:] + np.tile(total_boxes[:,1],(5, 1))-1
         if total_boxes.shape[0]>0:
             total_boxes = bbreg(total_boxes.copy(), np.transpose(mv))
             pick = nms(total_boxes.copy(), 0.7, 'Min')
             total_boxes = total_boxes[pick,:]
-            # points = points[:,pick]
-
-    # return total_boxes, points
-    return total_boxes
+            points = points[:,pick]
 
+    return total_boxes, points
+    
 # function [boundingbox] = bbreg(boundingbox,reg)
 def bbreg(boundingbox,reg):
     """Calibrate bounding boxes"""

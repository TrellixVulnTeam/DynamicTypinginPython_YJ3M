commit 7ceeabac87f03c7f2065de902f146570220dcd89
Author: kilroythethird <44308116+kilroythethird@users.noreply.github.com>
Date:   Sun Jul 21 13:37:41 2019 +0200

    Switch to keras version for sort face (#791)
    
    Upgrade to vgg_face2 (keras) to speed up sort by face

diff --git a/lib/model/layers.py b/lib/model/layers.py
index 32c10cc..0bd91f7 100644
--- a/lib/model/layers.py
+++ b/lib/model/layers.py
@@ -336,6 +336,21 @@ class ReflectionPadding2D(Layer):
         return dict(list(base_config.items()) + list(config.items())) 
 
 
+class L2_normalize(Layer):
+    def __init__(self, axis, **kwargs):
+        self.axis = axis
+        super(L2_normalize, self).__init__(**kwargs)
+
+    def call(self, x):
+        return K.l2_normalize(x, self.axis)
+
+    def get_config(self):
+        config = super(L2_normalize, self).get_config()
+        config["axis"] = self.axis
+        return config
+
+
+
 # Update layers into Keras custom objects
 for name, obj in inspect.getmembers(sys.modules[__name__]):
     if inspect.isclass(obj) and obj.__module__ == __name__:
diff --git a/lib/vgg_face2_keras.py b/lib/vgg_face2_keras.py
new file mode 100644
index 0000000..922d20d
--- /dev/null
+++ b/lib/vgg_face2_keras.py
@@ -0,0 +1,124 @@
+#!/usr/bin python3
+""" VGG_Face2 inference
+Model exported from: https://github.com/WeidiXie/Keras-VGGFace2-ResNet50
+which is based on: https://www.robots.ox.ac.uk/~vgg/software/vgg_face/
+
+Licensed under Creative Commons Attribution License.
+https://creativecommons.org/licenses/by-nc/4.0/
+"""
+
+import logging
+import sys
+import os
+
+import cv2
+import numpy as np
+from fastcluster import linkage
+from lib.utils import GetModel
+
+logger = logging.getLogger(__name__)  # pylint: disable=invalid-name
+
+
+class VGGFace2():
+    """ VGG Face feature extraction.
+        Input images should be in BGR Order """
+
+    def __init__(self, backend="GPU"):
+        logger.debug("Initializing %s:", self.__class__.__name__,)
+        backend = backend.upper()
+        git_model_id = 10
+        model_filename = ["vggface2_resnet50_v2.h5"]
+        self.input_size = 224
+        # Average image provided in https://github.com/ox-vgg/vgg_face2
+        self.average_img = np.array([91.4953, 103.8827, 131.0912])
+
+        self.model = self.get_model(git_model_id, model_filename, backend)
+        logger.debug("Initialized %s", self.__class__.__name__)
+
+    # <<< GET MODEL >>> #
+    def get_model(self, git_model_id, model_filename, backend):
+        """ Check if model is available, if not, download and unzip it """
+        root_path = os.path.abspath(os.path.dirname(sys.argv[0]))
+        cache_path = os.path.join(root_path, "plugins", "extract", ".cache")
+        model = GetModel(model_filename, cache_path, git_model_id).model_path
+        if backend == "CPU":
+            if os.environ.get("KERAS_BACKEND", "") == "plaidml.keras.backend":
+                logger.info("Switching to tensorflow backend.")
+                os.environ["KERAS_BACKEND"] = "tensorflow"
+        import keras
+        from lib.model.layers import L2_normalize
+        if backend == "CPU":
+            with keras.backend.tf.device("/cpu:0"):
+                return keras.models.load_model(model, {
+                    "L2_normalize":  L2_normalize
+                })
+        else:
+            return keras.models.load_model(model, {
+                "L2_normalize":  L2_normalize
+            })
+
+    def predict(self, face):
+        """ Return encodings for given image from vgg_face """
+        if face.shape[0] != self.input_size:
+            face = self.resize_face(face)
+        face = np.expand_dims(face - self.average_img, axis=0)
+        preds = self.model.predict(face)
+        return preds[0, :]
+
+    def resize_face(self, face):
+        """ Resize incoming face to model_input_size """
+        if face.shape[0] < self.input_size:
+            interpolation = cv2.INTER_CUBIC  # pylint:disable=no-member
+        else:
+            interpolation = cv2.INTER_AREA  # pylint:disable=no-member
+
+        face = cv2.resize(face,  # pylint:disable=no-member
+                          dsize=(self.input_size, self.input_size),
+                          interpolation=interpolation)
+        return face
+
+    @staticmethod
+    def find_cosine_similiarity(source_face, test_face):
+        """ Find the cosine similarity between a source face and a test face """
+        var_a = np.matmul(np.transpose(source_face), test_face)
+        var_b = np.sum(np.multiply(source_face, source_face))
+        var_c = np.sum(np.multiply(test_face, test_face))
+        return 1 - (var_a / (np.sqrt(var_b) * np.sqrt(var_c)))
+
+    def sorted_similarity(self, predictions, method="ward"):
+        """ Sort a matrix of predictions by similarity Adapted from:
+            https://gmarti.gitlab.io/ml/2017/09/07/how-to-sort-distance-matrix.html
+        input:
+            - predictions is a stacked matrix of vgg_face predictions shape: (x, 4096)
+            - method = ["ward","single","average","complete"]
+        output:
+            - result_order is a list of indices with the order implied by the hierarhical tree
+
+        sorted_similarity transforms a distance matrix into a sorted distance matrix according to
+        the order implied by the hierarchical tree (dendrogram)
+        """
+        logger.info("Sorting face distances. Depending on your dataset this may take some time...")
+        num_predictions = predictions.shape[0]
+        result_linkage = linkage(predictions, method=method, preserve_input=False)
+        result_order = self.seriation(result_linkage,
+                                      num_predictions,
+                                      num_predictions + num_predictions - 2)
+
+        return result_order
+
+    def seriation(self, tree, points, current_index):
+        """ Seriation method for sorted similarity
+            input:
+                - tree is a hierarchical tree (dendrogram)
+                - points is the number of points given to the clustering process
+                - current_index is the position in the tree for the recursive traversal
+            output:
+                - order implied by the hierarchical tree
+
+            seriation computes the order implied by a hierarchical tree (dendrogram)
+        """
+        if current_index < points:
+            return [current_index]
+        left = int(tree[current_index-points, 0])
+        right = int(tree[current_index-points, 1])
+        return self.seriation(tree, points, left) + self.seriation(tree, points, right)
diff --git a/tools/cli.py b/tools/cli.py
index 76a8477..2c868fd 100644
--- a/tools/cli.py
+++ b/tools/cli.py
@@ -542,11 +542,10 @@ class SortArgs(FaceSwapArgs):
         argument_list.append({"opts": ("-be", "--backend"),
                               "action": Radio,
                               "type": str.upper,
-                              "choices": ("CPU", "OPENCL"),
-                              "default": "CPU",
-                              "help": "Backend to use for VGG Face inference. OpenCL is slightly "
-                                      "faster but may not be available on all systems. Only used "
-                                      "for sort by 'face'."})
+                              "choices": ("CPU", "GPU"),
+                              "default": "GPU",
+                              "help": "Backend to use for VGG Face inference."
+                                      "Only used for sort by 'face'."})
 
         argument_list.append({"opts": ('-l', '--log-changes'),
                               "action": 'store_true',
diff --git a/tools/sort.py b/tools/sort.py
index 9b5d924..c2638c3 100644
--- a/tools/sort.py
+++ b/tools/sort.py
@@ -19,7 +19,7 @@ from lib.faces_detect import DetectedFace
 from lib.multithreading import SpawnProcess
 from lib.queue_manager import queue_manager, QueueEmpty
 from lib.utils import cv2_read_img
-from lib.vgg_face import VGGFace
+from lib.vgg_face2_keras import VGGFace2 as VGGFace
 from plugins.plugin_loader import PluginLoader
 
 from . import cli

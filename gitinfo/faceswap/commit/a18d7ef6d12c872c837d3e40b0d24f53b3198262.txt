commit a18d7ef6d12c872c837d3e40b0d24f53b3198262
Author: torzdf <36920800+torzdf@users.noreply.github.com>
Date:   Sun Apr 8 20:33:50 2018 +0100

    GUI v0.1.0a (#336)
    
    * Code clean up
    
    * Code refactor
    
    * bugfix: Find paths to icons when launched from outside faceswap dir
    
    * Bugfix: Disable GUI if TkInter app not available
    
    * BugFix: Disable GUI if $DISPLAY not detected
    
    * Minor code ammends
    
    * Code Refactor
    
    * DISPLAY check fix

diff --git a/scripts/gui.py b/scripts/gui.py
index 784a24c..6e93793 100644
--- a/scripts/gui.py
+++ b/scripts/gui.py
@@ -1,107 +1,86 @@
 import sys
-from threading import Thread
-import tkinter as tk
 
-from tkinter import ttk
-from tkinter import filedialog
+from os import environ, path
+from threading import Thread
 
 from lib.cli import FullPaths
 from lib.Serializer import JSONSerializer
 
-class TKGui(object):
+# Users without tkinter distrubtion packages or without an X-Console will error out
+# importing tkinter. Therefore run a check on these and only import if required 
+tk = None
+ttk = None
+filedialog = None
+
+def import_tkinter(command):
+    ''' Perform checks when importing tkinter module to ensure that GUI will load '''
+    global tk
+    global ttk
+    global filedialog
+    try:
+        import tkinter
+        from tkinter import ttk
+        from tkinter import filedialog
+        tk = tkinter
+    except ImportError:
+        if 'gui' in command:
+            print(  'It looks like TkInter isn''t installed for your OS, so the GUI has been '
+                    'disabled. To enable the GUI please install the TkInter application.\n'
+                    'You can try:\n'
+                    '  Windows/macOS:      Install ActiveTcl Community Edition from '
+                    'www.activestate.com\n'
+                    '  Ubuntu/Mint/Debian: sudo apt install python3-tk\n'
+                    '  Arch:               sudo pacman -S tk\n'
+                    '  CentOS/Redhat:      sudo yum install tkinter\n'
+                    '  Fedora:             sudo dnf install python3-tkinter\n')
+        return False
+    return True    
+
+def check_display(command):
+    # Check whether there is a display to output the GUI '''
+    if not environ.get('DISPLAY', None):
+        if 'gui' in command:
+            print ('Could not detect a display. The GUI has been disabled')
+        return False
+    return True
+
+class FaceswapGui(object):
     ''' The Graphical User Interface '''
-    def __init__(self, subparser, subparsers, parser, command, description='default'):
-        self.root = tk.Tk()
+    def __init__(self, options, parser):
+        self.gui = tk.Tk()
+        self.opts = options
         self.parser = parser
-        self.opts = self.extract_options(subparsers)
-        self.icofolder = tk.PhotoImage(file='icons/open_folder.png')
-        self.icofile = tk.PhotoImage(file='icons/open_file.png')
-        self.icosave = tk.PhotoImage(file='icons/save.png')
-        self.icoreset = tk.PhotoImage(file='icons/reset.png')
-        self.icoclear = tk.PhotoImage(file='icons/clear.png')
+        
+        pathscript = path.realpath(path.dirname(sys.argv[0]))
+        pathicons = path.join(pathscript, 'icons')
+        self.icofolder = tk.PhotoImage(file=path.join(pathicons,'open_folder.png'))
+        self.icoload = tk.PhotoImage(file=path.join(pathicons,'open_file.png'))
+        self.icosave = tk.PhotoImage(file=path.join(pathicons,'save.png'))
+        self.icoreset = tk.PhotoImage(file=path.join(pathicons,'reset.png'))
+        self.icoclear = tk.PhotoImage(file=path.join(pathicons,'clear.png'))
+
         self.helptext = tk.StringVar()
         self.statustext = tk.StringVar()
         self.serializer = JSONSerializer
         self.filetypes=(('Faceswap files', '*.fsw'),  ('All files', '*.*'))
-       
-        self.parse_arguments(description, subparser, command)
-
-    def bad_args(self, args):
-        self.parser.print_help()
-        exit(0)
-
-    def extract_options(self, subparsers):
-        ''' Extract the existing ArgParse Options '''
-        options = {command: subparsers[command].argument_list + subparsers[command].optional_arguments for command in subparsers.keys()}
-        for command in options.values():
-            for option in command:
-                option['control_title'] = self.set_control_title(option.get('opts',''))
-                option['control_type'] = self.set_control_type(option)
-        return options
-
-    @staticmethod
-    def set_control_title(opts):
-        ''' Take the option switch and format it nicely '''
-        ctl_title = opts[0]
-        if len(opts) == 2:
-            ctl_title = opts[1]
-        ctl_title = ctl_title.replace('-',' ').replace('_',' ')
-        ctl_title = ctl_title.title().strip()
-        return ctl_title
- 
-    @staticmethod
-    def set_control_type(option):
-        ''' Set what control type we should use for an option based on existence of various variables '''
-        if option.get('dest', '') == 'alignments_path':
-            ctl_type = 'filechooser'
-        elif option.get('action', '') == FullPaths:
-            ctl_type = 'folderchooser'
-        elif option.get('choices', '') != '':
-            ctl_type = 'combobox'
-        elif option.get('type', '') in (str, float, int):
-            ctl_type = 'entrybox'
-        elif option.get('action', '') == 'store_true':
-            ctl_type = 'checkbox'
-        return ctl_type
-
-    def parse_arguments(self, description, subparser, command):
-        parser = subparser.add_parser(
-            command,
-            help="This Launches a GUI for Faceswap.",
-            description=description,
-            epilog="Questions and feedback: \
-            https://github.com/deepfakes/faceswap-playground"
-        )
-        parser.set_defaults(func=self.process)
+        self.task = FaceswapControl()
 
-    def process(self, arguments):
-        ''' Builds the GUI '''
-        self.arguments = arguments
-        self.root.title('faceswap.py')
+    def build_gui(self):
+        ''' Build the GUI '''
+        self.gui.title('faceswap.py')
         self.menu()
-        notebook = ttk.Notebook(self.root)
+        notebook = ttk.Notebook(self.gui)
         notebook.pack(fill=tk.BOTH, expand=True)
 
-        # extract, train and convert are explicitly stated to ensure they are always displayed in the same order
+        # Commands explicitly stated to ensure consistent ordering
         for command in ('extract', 'train', 'convert'):
-            title = command.title()
-            page = ttk.Frame(notebook)
-            
-            self.add_left_frame(page, command)
-            self.add_frame_seperator(page)
-            opt_frame = self.add_right_frame(page)
-            
-            for option in self.opts[command]:
-                self.build_tabs(option, opt_frame)
-            
-            notebook.add(page, text=title)
-
-        self.root.mainloop()
+            commandtab = CommandTab(self, notebook, command)
+            commandtab.build_tab()
 
 # All pages stuff
     def menu(self):
         ''' Menu bar for loading and saving configs '''
-        menubar = tk.Menu(self.root)
+        menubar = tk.Menu(self.gui)
         filemenu = tk.Menu(menubar, tearoff=0)
         filemenu.add_command(label='Load full config...', command=self.load_config)
         filemenu.add_command(label='Save full config...', command=self.save_config)
@@ -109,49 +88,53 @@ class TKGui(object):
         filemenu.add_command(label='Reset all to default', command=self.reset_config)
         filemenu.add_command(label='Clear all', command=self.clear_config)
         filemenu.add_separator()
-        filemenu.add_command(label='Quit', command=self.root.quit)
+        filemenu.add_command(label='Quit', command=self.gui.quit)
         menubar.add_cascade(label="File", menu=filemenu)
-        self.root.config(menu=menubar)
+        self.gui.config(menu=menubar)
 
     def load_config(self, command=None):
         ''' Load a saved config file '''
-        config_file = filedialog.askopenfile(mode='r', filetypes=self.filetypes)
-        if not config_file:
+        cfgfile = filedialog.askopenfile(mode='r', filetypes=self.filetypes)
+        if not cfgfile:
             return
-        config = self.serializer.unmarshal(config_file.read())
+        cfg = self.serializer.unmarshal(cfgfile.read())
         if command is None:
-            for command, options in config.items():
-                self.set_command_args(command, options)
+            for cmd, opts in cfg.items():
+                self.set_command_args(cmd, opts)
         else:
-            options = config[command]
-            self.set_command_args(command, options)
+            opts = cfg[command]
+            self.set_command_args(command, opts)
                 
     def set_command_args(self, command, options):
         ''' Pass the saved config items back to the GUI '''
-        for src_option, src_value in options.items():
-            for dst_options in self.opts[command]:
-                if dst_options['control_title'] == src_option:
-                    dst_options['value'].set(src_value)
+        for srcopt, srcval in options.items():
+            for dstopts in self.opts[command]:
+                if dstopts['control_title'] == srcopt:
+                    dstopts['value'].set(srcval)
                     break
         
     def save_config(self, command=None):
         ''' Save the current GUI state to a config file in json format '''
-        config_file = filedialog.asksaveasfile(mode='w', filetypes=self.filetypes, defaultextension='.fsw')
-        if not config_file:
+        cfgfile = filedialog.asksaveasfile( mode='w',
+                                            filetypes=self.filetypes, 
+                                            defaultextension='.fsw')
+        if not cfgfile:
             return
         if command is None:
-            config = {command: {option['control_title']: option['value'].get() for option in options} for command, options in self.opts.items()}
+            cfg = {cmd: {opt['control_title']: opt['value'].get() for opt in opts} 
+                   for cmd, opts in self.opts.items()}
         else:
-            config = {command: {option['control_title']: option['value'].get() for option in self.opts[command]}}
-        config_file.write(self.serializer.marshal(config))
-        config_file.close
+            cfg = {command: {opt['control_title']: opt['value'].get()
+                   for opt in self.opts[command]}}
+        cfgfile.write(self.serializer.marshal(cfg))
+        cfgfile.close
 
     def reset_config(self, command=None):
         ''' Reset the GUI to the default values '''
         if command is None:
-            options = [option for options in self.opts.values() for option in options]
+            options = [opt for opts in self.opts.values() for opt in opts]
         else:
-            options = [option for option in self.opts[command]]
+            options = [opt for opt in self.opts[command]]
         for option in options:
             default = option.get('default', '')
             default = '' if default is None else default
@@ -160,9 +143,9 @@ class TKGui(object):
     def clear_config(self, command=None):
         ''' Clear all values from the GUI '''
         if command is None:
-            options = [option for options in self.opts.values() for option in options]
+            options = [opt for opts in self.opts.values() for opt in opts]
         else:
-            options = [option for option in self.opts[command]]
+            options = [opt for opt in self.opts[command]]
         for option in options:
             if isinstance(option['value'].get(), bool):
                 option['value'].set(False)
@@ -171,120 +154,127 @@ class TKGui(object):
             else:
                 option['value'].set('')
 
-    @staticmethod
-    def add_frame_seperator(page):
-        ''' Add a seperator between left and right frames '''
-        separator = tk.Frame(page, width=2, bd=1, relief=tk.SUNKEN)
-        separator.pack(fill=tk.Y, padx=5, side=tk.LEFT)
-
-# Left Frame stuff
-    def add_left_frame(self, page, title):
-        ''' Add help display and execute button to the left frame of each page '''
-        frame = tk.Frame(page)
+    def bind_help(self, control, helptext):
+        ''' Controls the help text displayed on mouse hover '''
+        for action in ('<Enter>', '<FocusIn>', '<Leave>', '<FocusOut>'):
+            helptext = helptext if action in ('<Enter>', '<FocusIn>') else ''
+            control.bind(action, lambda event, txt=helptext: self.helptext.set(txt))
+
+    def execute_task(self, command):
+        ''' Execute the task in Faceswap.py '''
+        self.task.execute_script(self.opts, command, self.parser, self.statustext)
+
+class ActionFrame(object):
+    '''Action Frame - Displays information and action controls '''
+    def __init__(self, gui, page, command):
+        self.gui = gui
+        self.page = page
+        self.command = command
+        self.title = command.title()
+
+    def build_frame(self):
+        ''' Add help display and Action buttons to the left frame of each page '''
+        frame = tk.Frame(self.page)
         frame.pack(fill=tk.X, padx=(10,5), side=tk.LEFT, anchor=tk.N)
 
-        topframe = tk.Frame(frame)
-        topframe.pack(fill=tk.X, side=tk.TOP)
-        bottomframe = tk.Frame(frame)
-        bottomframe.pack(fill=tk.X, side=tk.BOTTOM)
-        self.add_info_section(topframe)
-        self.add_action_buttons(topframe, title)
-        self.add_util_buttons(bottomframe, title)
-        self.add_status_section(bottomframe)
+        self.add_info_section(frame)
+        self.add_action_buttons(frame)
+        self.add_util_buttons(frame)
+        self.add_status_section(frame)
         
     def add_info_section(self, frame):
         ''' Build the info text section page '''
-        helpframe=tk.Frame(frame)
-        helpframe.pack(fill=tk.X, side=tk.TOP, pady=5)
-        lbl_title = tk.Label(helpframe, text='Info', width=15, anchor=tk.SW)
-        lbl_title.pack(side=tk.TOP)
-        self.helptext.set('')
-        lbl_help = tk.Label(helpframe, height=20, width=15, textvariable=self.helptext,  wraplength=120, justify=tk.LEFT, anchor=tk.NW, bg="gray90")
-        lbl_help.pack(side=tk.BOTTOM, anchor=tk.N)
-
-    def bind_help(self, control, helptext):
-        ''' Controls the help text displayed on mouse hover '''
-        control.bind('<Enter>', lambda event: self.helptext.set(helptext))
-        control.bind('<FocusIn>', lambda event: self.helptext.set(helptext))
-        control.bind('<Leave>', lambda event: self.helptext.set(''))
-        control.bind('<FocusOut>', lambda event: self.helptext.set(''))
-
-    def add_action_buttons(self, frame, title):
+        hlpframe=tk.Frame(frame)
+        hlpframe.pack(fill=tk.X, side=tk.TOP, pady=5)
+        lbltitle = tk.Label(hlpframe, text='Info', width=15, anchor=tk.SW)
+        lbltitle.pack(side=tk.TOP)
+        self.gui.helptext.set('')
+        lblhelp = tk.Label( hlpframe,
+                            height=20,
+                            width=15,
+                            textvariable=self.gui.helptext,
+                            wraplength=120, 
+                            justify=tk.LEFT, 
+                            anchor=tk.NW,
+                            bg="gray90")
+        lblhelp.pack(side=tk.TOP, anchor=tk.N)
+
+    def add_action_buttons(self, frame):
         ''' Add the action buttons for page '''
-        command = title.lower()
-        title = title.capitalize()
-
         actframe = tk.Frame(frame)
-        actframe.pack(fill=tk.X, side=tk.BOTTOM, pady=(15, 0))
+        actframe.pack(fill=tk.X, side=tk.TOP, pady=(15, 0))
 
-        btnexecute = tk.Button(actframe, text=title, height=2, width=12, command=lambda: self.execute_script(command))
-        btnexecute.pack()
-        self.bind_help(btnexecute, 'Run the {} script'.format(title))
+        btnexecute = tk.Button( actframe,
+                                text=self.title,
+                                height=2,
+                                width=12,
+                                command=lambda: self.gui.execute_task(self.command))
+        btnexecute.pack(side=tk.TOP)
+        self.gui.bind_help(btnexecute, 'Run the {} script'.format(self.title))
 
-    def add_util_buttons(self, frame, title):
+    def add_util_buttons(self, frame):
         ''' Add the section utility buttons '''
-        command = title.lower()
-        title = title.capitalize()
-
-        utilframe = tk.Frame(frame)
-        utilframe.pack(side=tk.TOP, pady=(5,0))
-
-        btnload = tk.Button(utilframe, image=self.icofile, height=16, width=16, command=lambda: self.load_config(command))
-        btnload.pack(padx=2, pady=2, side=tk.LEFT)
-        self.bind_help(btnload, 'Load existing {} config'.format(title))
-
-        btnsave = tk.Button(utilframe, image=self.icosave, height=16, width=16, command=lambda: self.save_config(command))
-        btnsave.pack(padx=2, pady=2, side=tk.LEFT)
-        self.bind_help(btnsave, 'Save {} config'.format(title))
-
-        btnreset = tk.Button(utilframe, image=self.icoreset, height=16, width=16, command=lambda: self.reset_config(command))
-        btnreset.pack(padx=2, pady=2, side=tk.RIGHT)
-        self.bind_help(btnreset, 'Reset {} config to default'.format(title))
-
-        btnclear = tk.Button(utilframe, image=self.icoclear, height=16, width=16, command=lambda: self.clear_config(command))
-        btnclear.pack(padx=2, pady=2, side=tk.RIGHT)
-        self.bind_help(btnclear, 'Clear all entries for {} config'.format(title))
+        utlframe = tk.Frame(frame)
+        utlframe.pack(side=tk.TOP, pady=(5,0))
+
+        for utl in ('load', 'save', 'clear', 'reset'):
+            img = getattr(self.gui, 'ico' + utl)
+            action = getattr(self.gui, utl + '_config')
+            btnutl = tk.Button( utlframe,
+                                height=16,
+                                width=16,
+                                image=img,
+                                command=lambda cmd=action: cmd(self.command))
+            btnutl.pack(padx=2, pady=2, side=tk.LEFT)
+            self.gui.bind_help(btnutl, utl.capitalize() + ' ' + self.title + ' config')
 
     def add_status_section(self, frame):
         ''' Build the info text section page '''
         statusframe = tk.Frame(frame)
-        statusframe.pack(side=tk.BOTTOM, pady=(5,0))
+        statusframe.pack(side=tk.TOP, pady=(5,0))
         
-        lbl_title = tk.Label(statusframe, text='Status', width=15, anchor=tk.SW)
-        lbl_title.pack(side=tk.TOP)
-        self.statustext.set('Idle')
-        lbl_status = tk.Label(statusframe, height=1, width=15, textvariable=self.statustext,  wraplength=120, justify=tk.LEFT, anchor=tk.NW, bg="gray90")
-        lbl_status.pack(side=tk.BOTTOM, anchor=tk.N)
-
-    def execute_script(self, command):
+        lbltitle = tk.Label(statusframe, text='Status', width=15, anchor=tk.SW)
+        lbltitle.pack(side=tk.TOP)
+        self.gui.statustext.set('Idle')
+        lblstatus = tk.Label(   statusframe,
+                                height=1,
+                                width=15,
+                                textvariable=self.gui.statustext,
+                                wraplength=120,
+                                justify=tk.LEFT,
+                                anchor=tk.NW,
+                                bg="gray90")
+        lblstatus.pack(side=tk.BOTTOM, anchor=tk.N)
+
+class CommandTab(object):
+    ''' Tabs to hold the command options '''
+    def __init__(self, gui, notebook, command):
+        self.gui = gui
+        self.notebook = notebook
+        self.page = ttk.Frame(self.notebook)
+        self.command = command
+        self.title = command.title()
+
+    def build_tab(self):
+        ''' Build the tab '''
+        actionframe = ActionFrame(self.gui, self.page, self.command)
+        actionframe.build_frame()
+        self.add_frame_seperator()
+        opt_frame = self.add_right_frame()
         
-        optlist = ['faceswap.py', command]
-        for item in self.opts[command]:
-            opt_value = str(item.get('value','').get())
-            opt = item['opts'][0]
-            if opt_value == 'False' or opt_value == '':
-                continue
-            elif opt_value == 'True':
-                optlist.append(opt)
-            else:
-                optlist.extend((opt, opt_value))
-        sys.argv = optlist
-        process = Thread(target=self.launch_thread, args=(command,))
-        process.start()
-
-    def launch_thread(self, command):
-        ''' Launch the script inside a subprocess to keep the GUI active '''
-        title = command.capitalize()
-        self.statustext.set('Running - {}'.format(title))
-        self.parser.set_defaults(func=self.bad_args)
-        arguments = self.parser.parse_args()
-        arguments.func(arguments)
-        self.statustext.set('Idle')
+        for option in self.gui.opts[self.command]:
+            self.build_tabs(option, opt_frame)
         
-# Right Frame setup    
-    def add_right_frame(self, page):
+        self.notebook.add(self.page, text=self.title)
+
+    def add_frame_seperator(self):
+        ''' Add a seperator between left and right frames '''
+        sep = tk.Frame(self.page, width=2, bd=1, relief=tk.SUNKEN)
+        sep.pack(fill=tk.Y, padx=5, side=tk.LEFT)
+
+    def add_right_frame(self):
         ''' Add the options panel to the right frame of each page '''
-        frame = tk.Frame(page)
+        frame = tk.Frame(self.page)
         frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(0,5))
 
         canvas = tk.Canvas(frame, width=490, height=450, bd=0, highlightthickness=0)
@@ -292,111 +282,202 @@ class TKGui(object):
 
         self.add_scrollbar(frame, canvas)
 
-        opts_frame = tk.Frame(canvas)
-        canvas.create_window((0,0), window=opts_frame, anchor=tk.NW)
+        optsframe = tk.Frame(canvas)
+        canvas.create_window((0,0), window=optsframe, anchor=tk.NW)
 
-        return opts_frame
+        return optsframe
 
     def add_scrollbar(self, frame, canvas):
         ''' Add a scrollbar to the options frame '''
         scrollbar = tk.Scrollbar(frame, command=canvas.yview)
         scrollbar.pack(side=tk.LEFT, fill='y')
         canvas.configure(yscrollcommand = scrollbar.set)
-        canvas.bind('<Configure>', lambda event, opt_canvas=canvas: self.update_scrollbar(event, opt_canvas))
+        canvas.bind('<Configure>',lambda event, cvs=canvas: self.update_scrollbar(event, cvs))
 
     @staticmethod
     def update_scrollbar(event, canvas):
         canvas.configure(scrollregion=canvas.bbox('all'))
 
 # Build the Right Frame Options
-    def build_tabs(self, option, page):
+    def build_tabs(self, option, option_frame):
         ''' Build the correct control type for the option passed through '''
-        ctl_type = option['control_type']
-        ctl_title = option['control_title']
-        ctl_help = ' '.join(option.get('help', '').split())
-        ctl_help = '. '.join(i.capitalize() for i in ctl_help.split('. '))
-        ctl_help = ctl_title + ' - ' + ctl_help
-        ctl_frame = self.build_control_frame(page)
-        self.build_control_label(ctl_frame, ctl_title)
-        if ctl_type == 'combobox':
-            option['value'] = self.build_combobox(ctl_frame, ctl_help, option.get('default',''), option['choices'])
-        if ctl_type == 'checkbox':
-            option['value'] = self.build_checkbox(ctl_frame, ctl_help, option.get('default', False), ctl_title)
-        if ctl_type == 'entrybox':
-            option['value'] = self.build_entrybox(ctl_frame, ctl_help, option.get('default',''), None)
-        if ctl_type in ('filechooser', 'folderchooser'):
-            option['value'] = self.build_entrybox(ctl_frame, ctl_help, option.get('default',''), ctl_type)
+        ctl = option['control']
+        ctltitle = option['control_title']
+        sysbrowser = option['filesystem_browser']
+        ctlhelp = ' '.join(option.get('help', '').split())
+        ctlhelp = '. '.join(i.capitalize() for i in ctlhelp.split('. '))
+        ctlhelp = ctltitle + ' - ' + ctlhelp
+        ctlframe = self.build_control_frame(option_frame)
+        
+        dflt = option.get('default', False) if ctl == tk.Checkbutton else option.get('default', '')
+        choices = option['choices'] if ctl == ttk.Combobox else None
 
-    @staticmethod
-    def build_control_frame(page):
+        self.build_control_label(ctlframe, ctltitle)
+        option['value'] = self.build_control(ctlframe, ctl, dflt, ctlhelp, choices, sysbrowser)
+
+    def build_control_frame(self, option_frame):
         ''' Build the frame to hold the control '''
-        frame = tk.Frame(page)
+        frame = tk.Frame(option_frame)
         frame.pack(fill=tk.X)
         return frame
     
-    @staticmethod
-    def build_control_label(frame, title):
+    def build_control_label(self, frame, control_title):
         ''' Build and place the control label '''
-        label = tk.Label(frame, text=title, width=15, anchor=tk.W)
-        label.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
-
-    def build_combobox(self, frame, helptext, default, items):
-        ''' Build and place combobox controls '''
-        default = default if default in items else ''
-        cmbvar = tk.StringVar(frame)
-        cmbvar.set(default)
-                        
-        cmbbox = ttk.Combobox(frame, textvariable=cmbvar, width=40)
-        cmbbox['values'] = [item for item in items]
-        cmbbox.pack(fill=tk.X, padx=5, pady=5)
-
-        self.bind_help(cmbbox, helptext)
-        return cmbvar
-
-    def build_checkbox(self, frame, helptext, default, title):
-        ''' Build and place checkbox controls '''
-        chkvar = tk.BooleanVar(frame)
-        chkvar.set(default)
-
-        chkbox = tk.Checkbutton(frame, variable=chkvar)
-        chkbox.pack(padx=5, pady=5, anchor=tk.W)
-        
-        self.bind_help(chkbox, helptext)
-        return chkvar
+        lbl = tk.Label(frame, text=control_title, width=15, anchor=tk.W)
+        lbl.pack(padx=5, pady=5, side=tk.LEFT, anchor=tk.N)
 
-    def build_entrybox(self, frame, helptext, default, opentype = None):
-        ''' Build and place entry controls '''
+    def build_control(self, frame, control, default, helptext, choices, sysbrowser):
+        ''' Build and place the option controls '''
         default = default if default is not None else ''
-        etyvar = tk.StringVar(frame)
-        etyvar.set(default)
 
-        if opentype is not None:
-            self.add_browser_buttons(frame, opentype, etyvar)
+        var = tk.BooleanVar(frame) if control == tk.Checkbutton else tk.StringVar(frame)
+        var.set(default)
+
+        if sysbrowser is not None:
+            self.add_browser_buttons(frame, sysbrowser, var)
 
-        etybox = tk.Entry(frame, textvariable=etyvar)
-        etybox.pack(fill=tk.X, padx=5, pady=5)
+        ctlkwargs = {'variable': var} if control == tk.Checkbutton else {'textvariable': var}
+        packkwargs = {'anchor': tk.W} if control == tk.Checkbutton else {'fill': tk.X}
 
-        self.bind_help(etybox, helptext)
-        return etyvar
+        if control == ttk.Combobox: #TODO: Remove this hacky fix to force the width of the frame
+            ctlkwargs['width'] = 40
 
-    def add_browser_buttons(self, frame, opentype, filepath):
+        ctl = control(frame, **ctlkwargs)
+        
+        if control == ttk.Combobox:
+            ctl['values'] = [choice for choice in choices]
+        
+        ctl.pack(padx=5, pady=5, **packkwargs)
+
+        self.gui.bind_help(ctl, helptext)
+        return(var)
+
+    def add_browser_buttons(self, frame, sysbrowser, filepath):
         ''' Add correct file browser button for control '''
-        if opentype == 'filechooser':
-            fileopn = tk.Button(frame, image=self.icofile, command=lambda: self.askfile(filepath), width=16, height=16)
-        else:
-            fileopn = tk.Button(frame, image=self.icofolder, command=lambda: self.askdirectory(filepath))
+        img = getattr(self.gui, 'ico' + sysbrowser)
+        action = getattr(self, 'ask_' + sysbrowser)
+        fileopn = tk.Button(frame, image=img, command=lambda cmd=action: cmd(filepath))
         fileopn.pack(side=tk.RIGHT)
 
     @staticmethod
-    def askdirectory(filepath):
-        ''' Pop-up to get path to a directory '''
+    def ask_folder(filepath):
+        ''' Pop-up to get path to a folder '''
         dirname = filedialog.askdirectory()
         if dirname:
             filepath.set(dirname)
    
     @staticmethod
-    def askfile(filepath):
+    def ask_load(filepath):
         ''' Pop-up to get path to a file '''
         filename = filedialog.askopenfilename()
         if filename:
             filepath.set(filename)
+
+class FaceswapControl(object):
+    ''' Control the underlying Faceswap tasks '''
+    def __init__(self):
+        self.opts = None
+        self.command = None
+        self.parser = None
+        self.statustext = None
+
+    def bad_args(self, args):
+        self.parser.print_help()
+        exit(0)
+
+    def execute_script(self, options, command, parser, statustext):
+        self.opts = options
+        self.command = command
+        self.parser = parser
+        self.statustext = statustext
+        
+        optlist = ['faceswap.py', self.command]
+        for item in self.opts[self.command]:
+            optval = str(item.get('value','').get())
+            opt = item['opts'][0]
+            if optval == 'False' or optval == '':
+                continue
+            elif optval == 'True':
+                optlist.append(opt)
+            else:
+                optlist.extend((opt, optval))
+        sys.argv = optlist
+        process = Thread(target=self.launch_faceswap, args=(self.command,))
+        process.start()
+
+    def launch_faceswap(self, command):
+        ''' Launch the script inside a subprocess to keep the GUI active '''
+        self.statustext.set('Executing: ' + command.title())
+        try:
+            self.parser.set_defaults(func=self.bad_args)
+            arguments = self.parser.parse_args()
+            arguments.func(arguments)
+        except:
+            self.statustext.set('Failed: ' + command.title())    
+            raise
+        self.statustext.set('Idle')
+        exit()        
+
+class TKGui(object):
+    ''' Main GUI Control '''
+    def __init__ (self, subparser, subparsers, parser, command, description='default'):
+    # Don't try to load the GUI if there is no display or there are problems importing tkinter
+        cmd = sys.argv
+        if not check_display(cmd) or not import_tkinter(cmd):
+            return
+       
+        self.parser = parser
+        self.opts = self.extract_options(subparsers)
+        self.root = FaceswapGui(self.opts, self.parser)
+        self.parse_arguments(description, subparser, command)
+
+    def extract_options(self, subparsers):
+        ''' Extract the existing ArgParse Options '''
+        opts = {cmd: subparsers[cmd].argument_list + 
+                subparsers[cmd].optional_arguments for cmd in subparsers.keys()}
+        for command in opts.values():
+            for opt in command:
+                ctl, sysbrowser = self.set_control(opt)
+                opt['control_title'] = self.set_control_title(opt.get('opts',''))
+                opt['control'] = ctl
+                opt['filesystem_browser'] = sysbrowser
+        return opts
+
+    @staticmethod
+    def set_control_title(opts):
+        ''' Take the option switch and format it nicely '''
+        ctltitle = opts[1] if len(opts) == 2 else opts[0]
+        ctltitle = ctltitle.replace('-',' ').replace('_',' ').strip().title()
+        return ctltitle
+ 
+    @staticmethod
+    def set_control(option):
+        ''' Set the control and filesystem browser to use for each option '''
+        sysbrowser = None
+        ctl = tk.Entry
+        if option.get('dest', '') == 'alignments_path':
+            sysbrowser = 'load'
+        elif option.get('action', '') == FullPaths:
+            sysbrowser = 'folder'
+        elif option.get('choices', '') != '':
+            ctl = ttk.Combobox
+        elif option.get('action', '') == 'store_true':
+            ctl = tk.Checkbutton
+        return ctl, sysbrowser
+
+    def parse_arguments(self, description, subparser, command):
+        parser = subparser.add_parser(
+            command,
+            help="This Launches a GUI for Faceswap.",
+            description=description,
+            epilog="Questions and feedback: \
+            https://github.com/deepfakes/faceswap-playground"
+        )
+        parser.set_defaults(func=self.process)        
+
+    def process(self, arguments):
+        ''' Builds the GUI '''
+        self.arguments = arguments
+        self.root.build_gui()
+        self.root.gui.mainloop()
+
